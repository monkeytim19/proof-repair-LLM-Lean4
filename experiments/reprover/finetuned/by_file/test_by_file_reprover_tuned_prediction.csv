filepath,thm_name,decl_name,commit,failed_proof,error_msg,statement,proof,predicted_proof
Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean,Matrix.coeff_charpoly_mem_ideal_pow,coeff_charpoly_mem_ideal_pow,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  delta charpoly
  rw [Matrix.det_apply, finset_sum_coeff]
  apply sum_mem
  rintro c -
  rw [coeff_smul, Submodule.smul_mem_iff']
  have : ‚àë x : n, 1 = Fintype.card n := by rw [Finset.sum_const, card_univ, smul_eq_mul, mul_one]
  rw [‚Üê this]
  apply coeff_prod_mem_ideal_pow_tsub
  rintro i - (_ | k)
  ¬∑ rw [Nat.zero_eq]  
    rw [tsub_zero, pow_one, charmatrix_apply, coeff_sub, ‚Üê smul_one_eq_diagonal, smul_apply,
      smul_eq_mul, coeff_X_mul_zero, coeff_C_zero, zero_sub]
    apply neg_mem  
    exact h (c i) i
  ¬∑ rw [Nat.succ_eq_one_add, tsub_self_add, pow_zero, Ideal.one_eq_top]
    exact Submodule.mem_top","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case h.h.zero
R : Type u
inst‚úù‚Å¥ : CommRing R
n G : Type v
inst‚úù¬≥ : DecidableEq n
inst‚úù¬≤ : Fintype n
Œ± Œ≤ : Type v
inst‚úù¬π : DecidableEq Œ±
M : Matrix n n R
p : ‚Ñï
inst‚úù : Fact (Nat.Prime p)
I : Ideal R
h : ‚àÄ (i j : n), M i j ‚àà I
k : ‚Ñï
c : Equiv.Perm n
this : ‚àë x : n, 1 = Fintype.card n
i : n
‚ä¢ (M.charmatrix (c i) i).coeff 0 ‚àà I ^ (1 - 0)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case h.h.succ
R : Type u
inst‚úù‚Å¥ : CommRing R
n G : Type v
inst‚úù¬≥ : DecidableEq n
inst‚úù¬≤ : Fintype n
Œ± Œ≤ : Type v
inst‚úù¬π : DecidableEq Œ±
M : Matrix n n R
p : ‚Ñï
inst‚úù : Fact (Nat.Prime p)
I : Ideal R
h : ‚àÄ (i j : n), M i j ‚àà I
k‚úù : ‚Ñï
c : Equiv.Perm n
this : ‚àë x : n, 1 = Fintype.card n
i : n
k : ‚Ñï
‚ä¢ (M.charmatrix (c i) i).coeff (k + 1) ‚àà I ^ (1 - (k + 1))","theorem coeff_charpoly_mem_ideal_pow {I : Ideal R} (h : ‚àÄ i j, M i j ‚àà I) (k : ‚Ñï) :
    M.charpoly.coeff k ‚àà I ^ (Fintype.card n - k) ",":= by
  delta charpoly
  rw [Matrix.det_apply, finset_sum_coeff]
  apply sum_mem
  rintro c -
  rw [coeff_smul, Submodule.smul_mem_iff']
  have : ‚àë x : n, 1 = Fintype.card n := by rw [Finset.sum_const, card_univ, smul_eq_mul, mul_one]
  rw [‚Üê this]
  apply coeff_prod_mem_ideal_pow_tsub
  rintro i - (_ | k)
  ¬∑ rw [tsub_zero, pow_one, charmatrix_apply, coeff_sub, ‚Üê smul_one_eq_diagonal, smul_apply,
      smul_eq_mul, coeff_X_mul_zero, coeff_C_zero, zero_sub]
    apply neg_mem  
    exact h (c i) i
  ¬∑ rw [add_comm, tsub_self_add, pow_zero, Ideal.one_eq_top]
    exact Submodule.mem_top",":= by
  delta charpoly
  rw [Matrix.det_apply, finset_sum_coeff]
  apply sum_mem
  rintro c -
  rw [coeff_smul, Submodule.smul_mem_iff']
  have : ‚àë x ‚àà n, 1 = Fintype.card n := by rw [Finset.sum_const, card_univ, smul_eq_mul, mul_one]
  rw [‚Üê this]
  apply coeff_prod_mem_ideal_pow_tsub
  rintro i - (_ | k)
  ¬∑ rw [Nat.zero_eq] 
    rw [tsub_zero, pow_one, charmatrix_apply, coeff_sub, ‚Üê smul_one_eq_diagonal, smul_apply,
      smul_eq_mul, coeff_X_mul_zero, coeff_C_zero, zero_sub]
    apply neg_mem  
    exact h (c i) i
  ¬∑ rw [Nat.succ_eq_one_add, tsub_self_add, pow_zero, Ideal.one_eq_top]
    exact Submodule.mem_top"
Mathlib/RingTheory/PowerSeries/Basic.lean,PowerSeries.coeff_mul,coeff_mul,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":= by
  refine Finset.sum_congr ?_ fun _ _ => rfl
  rw [Subsingleton.elim (Classical.decEq œÉ) ‚ÄπDecidableEq œÉ‚Ä∫]","error:  typeclass instance problem is stuck, it is often due to metavariables
  AddCommMonoid ?m.30524
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated","theorem coeff_mul (n : ‚Ñï) (œÜ œà : R‚ü¶X‚üß) :
    coeff R n (œÜ * œà) = ‚àë p ‚àà antidiagonal n, coeff R p.1 œÜ * coeff R p.2 œà ",":= by
  refine (MvPowerSeries.coeff_mul _ œÜ œà).trans ?_
  rw [Finsupp.antidiagonal_single, Finset.sum_map]
  rfl",":= by
  refine Finset.sum_congr ?_ fun _ _ => rfl
  rw [Subsingleton.elim (Classical.decEq œÉ) ‚ÄπDecidableEq œÉ‚Ä∫]"
Mathlib/Topology/Metrizable/Urysohn.lean,TopologicalSpace.exists_inducing_l_infty,exists_inducing_l_infty,048fe93af13417a7050bfb46d3540a78a24f34a2,":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono (inter_subset_left _ _)).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine' ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, _‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_closed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine' ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm _ _‚ü©
  ¬∑ refine' (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => _
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine' (eventually_all_finite h_fin).2 fun UV _ => _
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine' this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => _
    cases' le_total Œ¥ (Œµ UV) with hle hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine' ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 _
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine' ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => _‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV
    exact (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _","error:  unexpected identifier; expected '|'
error:  unsolved goals
case intro.intro.refine'_2.intro.intro.intro.intro
X : Type u_1
inst‚úù¬≤ : TopologicalSpace X
inst‚úù¬π : RegularSpace X
inst‚úù : SecondCountableTopology X
B : Set (Set X)
hBc : B.Countable
hB : IsTopologicalBasis B
s : Set (Set X √ó Set X) := {UV | UV ‚àà B √óÀ¢ B ‚àß closure UV.1 ‚äÜ UV.2}
this‚úù¬π : Encodable ‚Üës
this‚úù : TopologicalSpace ‚Üës := ‚ä•
this : DiscreteTopology ‚Üës
hd : ‚àÄ (UV : ‚Üës), Disjoint (closure (‚ÜëUV).1) (‚ÜëUV).2·∂ú
Œµ : ‚Üës ‚Üí ‚Ñù
Œµ01 : ‚àÄ (UV : ‚Üës), Œµ UV ‚àà Ioc 0 1
hŒµ : Tendsto Œµ cofinite (ùìù 0)
f : ‚Üës ‚Üí C(X, ‚Ñù)
hf0 : ‚àÄ (UV : ‚Üës), EqOn (‚áë(f UV)) 0 (‚ÜëUV).1
hfŒµ : ‚àÄ (UV : ‚Üës), EqOn (‚áë(f UV)) (fun x ‚Ü¶ Œµ UV) (‚ÜëUV).2·∂ú
hf0Œµ : ‚àÄ (UV : ‚Üës) (x : X), (f UV) x ‚àà Icc 0 (Œµ UV)
hf01 : ‚àÄ (UV : ‚Üës) (x : X), (f UV) x ‚àà Icc 0 1
F : X ‚Üí ‚Üës ‚Üí·µá ‚Ñù := fun x ‚Ü¶ { toFun := fun UV ‚Ü¶ (f UV) x, continuous_toFun := ‚ãØ, map_bounded' := ‚ãØ }
hF : ‚àÄ (x : X) (UV : ‚Üës), (F x) UV = (f UV) x
x : X
V : Set X
hVB : V ‚àà B
hxV : x ‚àà V
U : Set X
hUB : U ‚àà B
hxU : x ‚àà U
hUV : closure U ‚äÜ V
UV : ‚Üës := ‚ü®(U, V), ‚ãØ‚ü©
y : X
hy : dist ((F y) UV) ((F x) UV) < Œµ UV
‚ä¢ y ‚àà V","theorem exists_inducing_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Inducing f ",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => ?_
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => ?_‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_closed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_clos"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicAt.order_eq_int_iff,order_eq_int_iff,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_nat, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©","warning:  `WithTop.coe_nat` has been deprecated, use `WithTop.coe_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚ä§ - ‚Üë?m.79514
case pos
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí E
x : ùïú
hf : MeromorphicAt f x
n : ‚Ñ§
h : ‚ãØ.order = ‚ä§
‚ä¢ ‚ä§ - ‚Üë‚Üë(Exists.choose hf) = ‚Üën ‚Üî ‚àÉ g, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z
warning:  `WithTop.coe_nat` has been deprecated, use `WithTop.coe_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë?m.80098 - ‚Üë?m.80099
case neg.intro
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí E
x : ùïú
hf : MeromorphicAt f x
n : ‚Ñ§
h‚úù : ¬¨‚ãØ.order = ‚ä§
m : ‚Ñï
h : ‚Üëm = ‚ãØ.order
‚ä¢ ‚Üë‚Üëm - ‚Üë‚Üë(Exists.choose hf) = ‚Üën ‚Üî ‚àÉ g, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z","lemma order_eq_int_iff {f : ùïú ‚Üí E} {x : ùïú} (hf : MeromorphicAt f x) (n : ‚Ñ§) : hf.order = n ‚Üî
    ‚àÉ g : ùïú ‚Üí E, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z ",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_natCast, ‚Üê coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_nat, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©"
Mathlib/NumberTheory/ClassNumber/Finite.lean,ClassGroup.norm_le,norm_le,6eab74639023015a7887e2f82e153907286e3801,":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, LinearEquiv.map_sum,
    LinearEquiv.map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  rw [‚Üê LinearMap.det_toMatrix bS]
  convert Matrix.det_sum_smul_le (n := Œπ) Finset.univ _ hy using 3
  ¬∑ simp; rfl
  ¬∑ rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearEquiv
has type
  (œÉ : ?m.53606 ‚Üí+* ?m.53607) ‚Üí
    {œÉ' : ?m.53607 ‚Üí+* ?m.53606} ‚Üí
      [inst : RingHomInvPair œÉ œÉ'] ‚Üí
        [inst : RingHomInvPair œÉ' œÉ] ‚Üí
          (M : Type ?u.53603) ‚Üí
            (M‚ÇÇ : Type ?u.53602) ‚Üí
              [inst : AddCommMonoid M] ‚Üí
                [inst_1 : AddCommMonoid M‚ÇÇ] ‚Üí
                  [inst : Module ?m.53606 M] ‚Üí [inst : Module ?m.53607 M‚ÇÇ] ‚Üí Type (max ?u.53603 ?u.53602)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  LinearMap.det ?f
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
inst‚úù¬π‚Å¥ : EuclideanDomain R
inst‚úù¬π¬≥ : CommRing S
inst‚úù¬π¬≤ : IsDomain S
inst‚úù¬π¬π : Field K
inst‚úù¬π‚Å∞ : Field L
inst‚úù‚Åπ : Algebra R K
inst‚úù‚Å∏ : IsFractionRing R K
inst‚úù‚Å∑ : Algebra K L
inst‚úù‚Å∂ : FiniteDimensional K L
inst‚úù‚Åµ : IsSeparable K L
algRL : Algebra R L
inst‚úù‚Å¥ : IsScalarTower R K L
inst‚úù¬≥ : Algebra R S
inst‚úù¬≤ : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R ‚Ñ§
Œπ : Type u_5
inst‚úù¬π : DecidableEq Œπ
inst‚úù : Fintype Œπ
bS : Basis Œπ R S
a : S
y : ‚Ñ§
hy : ‚àÄ (k : Œπ), abv ((bS.repr a) k) ‚â§ y
‚ä¢ abv ((LinearMap.toMatrix bS bS) (‚àë x : Œπ, (bS.repr a) x ‚Ä¢ (Algebra.lmul R S) (bS x))).det ‚â§
    (Fintype.card Œπ).factorial ‚Ä¢
      (Fintype.card Œπ ‚Ä¢
          ((Finset.image (fun ijk ‚Ü¶ abv ((Algebra.leftMulMatrix bS) (bS ijk.1) ijk.2.1 ijk.2.2)) Finset.univ).max' ‚ãØ *
            y)) ^
        Fintype.card Œπ","theorem norm_le (a : S) {y : ‚Ñ§} (hy : ‚àÄ k, abv (bS.repr a k) ‚â§ y) :
    abv (Algebra.norm R a) ‚â§ normBound abv bS * y ^ Fintype.card Œπ ",":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  convert Matrix.det_sum_smul_le Finset.univ _ hy using 3
  ¬∑ rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©",":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, LinearEquiv.map_sum,
    LinearEquiv.map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  rw [‚Üê LinearMap.det_toMatrix bS]
  convert Matrix.det_sum_smul_le (n := Œπ) Finset.univ _ hy using 3
  ¬∑ simp
  ¬∑ rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©"
Mathlib/Order/OrderIsoNat.lean,RelEmbedding.acc_iff_no_decreasing_seq,acc_iff_no_decreasing_seq,1fad85974a73e087cf79e277c849def2b34e2100,":= by
  constructor
  ¬∑ refine' fun h => h.recOn fun x _ IH => _
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    obtain ‚ü®f, h‚ü© := Classical.axiom_of_choice this
    refine' fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => _, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h","error:  unknown identifier 'lt_add_one'
error:  unknown identifier 'Classical.axiom_of_choice'
error:  rcases tactic failed: x‚úù : ?m.2248 is not an inductive datatype","theorem acc_iff_no_decreasing_seq {x} :
    Acc r x ‚Üî IsEmpty { f : ((¬∑ > ¬∑) : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop) ‚Ü™r r // x ‚àà Set.range f } ",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (Nat.lt_succ_self _))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    choose f h using this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, ?_, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    obtain ‚ü®f, h‚ü© := Classical.axiom_of_choice this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h"
Mathlib/NumberTheory/FermatPsp.lean,Nat.exists_infinite_pseudoprimes,exists_infinite_pseudoprimes,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by linarith
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by linarith) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by linarith
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact ‚ü®fermatPsp_base_one (by linarith) this, by linarith‚ü©","error:  unsolved goals
b : ‚Ñï
h : 1 ‚â§ b
m : ‚Ñï
b_ge_two : ¬¨2 ‚â§ b
h‚ÇÅ : b = 1
‚ä¢ ¬¨m + 2 = 1","theorem exists_infinite_pseudoprimes {b : ‚Ñï} (h : 1 ‚â§ b) (m : ‚Ñï) :
    ‚àÉ n : ‚Ñï, FermatPsp n b ‚àß m ‚â§ n ",":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by omega
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by omega) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by omega
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by omega) (by omega)
    exact ‚ü®fermatPsp_base_one (by omega) this, by omega‚ü©",":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by linarith
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by linarith) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by linarith
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact ‚ü®fermatPsp_base_one (by linarith) this, by linarith‚ü©"
Mathlib/GroupTheory/SpecificGroups/Alternating.lean,alternatingGroup.isConj_swap_mul_swap_of_cycleType_two,isConj_swap_mul_swap_of_cycleType_two,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  have h := g.support.card_le_univ
  rw [‚Üê Multiset.eq_replicate_card] at h2
  rw [‚Üê sum_cycleType, h2, Multiset.sum_replicate, smul_eq_mul] at h
  have h : Multiset.card g.cycleType ‚â§ 3 :=
    le_of_mul_le_mul_right (le_trans h (by simp only [card_fin]; ring_nf)) (by simp)
  rw [mem_alternatingGroup, sign_of_cycleType, h2] at ha
  norm_num at ha
  rw [pow_add, pow_mul, Int.units_pow_two, one_mul, Units.ext_iff, Units.val_one,
    Units.val_pow_eq_pow_val, Units.coe_neg_one, neg_one_pow_eq_one_iff_even _] at ha
  swap; ¬∑ decide
  rw [isConj_iff_cycleType_eq, h2]
  interval_cases h_1 : Multiset.card g.cycleType
  ¬∑ exact (h1 (card_cycleType_eq_zero.1 h_1)).elim
  ¬∑ contrapose! ha
    simp [h_1]
  ¬∑ have h04 : (0 : Fin 5) ‚â† 4 := by decide
    have h13 : (1 : Fin 5) ‚â† 3 := by decide
    rw [Disjoint.cycleType, (isCycle_swap h04).cycleType, (isCycle_swap h13).cycleType,
      card_support_swap h04, card_support_swap h13]
    ¬∑ rfl
    ¬∑ rw [disjoint_iff_disjoint_support, support_swap h04, support_swap h13]
      decide
  ¬∑ contrapose! ha
    simp [h_1]","warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  unsolved goals
Œ± : Type u_1
inst‚úù¬π : Fintype Œ±
inst‚úù : DecidableEq Œ±
g : Perm (Fin 5)
ha : g ‚àà alternatingGroup (Fin 5)
h1 : g ‚â† 1
h2 : g.cycleType = Multiset.replicate (Multiset.card g.cycleType) 2
h : Multiset.card g.cycleType * 2 ‚â§ card (Fin 5)
‚ä¢ 5 ‚â§ 6
error:  simp made no progress","theorem isConj_swap_mul_swap_of_cycleType_two {g : Perm (Fin 5)} (ha : g ‚àà alternatingGroup (Fin 5))
    (h1 : g ‚â† 1) (h2 : ‚àÄ n, n ‚àà cycleType (g : Perm (Fin 5)) ‚Üí n = 2) :
    IsConj (swap 0 4 * swap 1 3) g ",":= by
  have h := g.support.card_le_univ
  rw [‚Üê Multiset.eq_replicate_card] at h2
  rw [‚Üê sum_cycleType, h2, Multiset.sum_replicate, smul_eq_mul] at h
  have h : Multiset.card g.cycleType ‚â§ 3 :=
    le_of_mul_le_mul_right (le_trans h (by simp only [card_fin]; ring_nf; decide)) (by simp)
  rw [mem_alternatingGroup, sign_of_cycleType, h2] at ha
  norm_num at ha
  rw [pow_add, pow_mul, Int.units_pow_two, one_mul, neg_one_pow_eq_one_iff_even] at ha
  swap; ¬∑ decide
  rw [isConj_iff_cycleType_eq, h2]
  interval_cases h_1 : Multiset.card g.cycleType
  ¬∑ exact (h1 (card_cycleType_eq_zero.1 h_1)).elim
  ¬∑ simp at ha
  ¬∑ have h04 : (0 : Fin 5) ‚â† 4 := by decide
    have h13 : (1 : Fin 5) ‚â† 3 := by decide
    rw [Disjoint.cycleType, (isCycle_swap h04).cycleType, (isCycle_swap h13).cycleType,
      card_support_swap h04, card_support_swap h13]
    ¬∑ rfl
    ¬∑ rw [disjoint_iff_disjoint_support, support_swap h04, support_swap h13]
      decide
  ¬∑ contradiction",":= by
  have h := g.support.card_le_univ
  rw [‚Üê Multiset.eq_replicate_card] at h2
  rw [‚Üê sum_cycleType, h2, Multiset.sum_replicate, smul_eq_mul] at h
  have h : Multiset.card g.cycleType ‚â§ 3 :=
    le_of_mul_le_mul_right (le_trans h (by simp only [card_fin]; ring_nf)) (by simp)
  rw [mem_alternatingGroup, sign_of_cycleType, h2] at ha
  norm_num at ha
  rw [pow_add, pow_mul, Int.units_pow_two, one_mul, Units.ext_iff, Units.val_one,
    Units.val_pow_eq_pow_val, Units.coe_neg_one, neg_one_pow_eq_one_iff_even _] at ha
  swap; ¬∑ decide
  rw [isConj_iff_cycleType_eq, h2]
  interval_cases h_1 : Multiset.card g.cycleType
  ¬∑ exact (h1 (card_cycleType_eq_zero.1 h_1)).elim
  ¬∑ contrapose! ha
    simp [h_1]
  ¬∑ have h04 : (0 : Fin 5) ‚â† 4 := by decide
    rw [Disjoint.cycleType, (isCycle_swap h04).cycleType, (isCycle_swap h13).cycleType,
      card_support_swap h04, card_support_swap h13]
    ¬∑ rfl
    ¬∑ rw [disjoint_iff_disjoint_support, support_swap h04, support_swap h13]
      decide
  ¬∑ contrapose! ha
    simp [h_1]"
Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean,Collinear.oangle_sign_of_sameRay_vsub,_root_.Collinear.oangle_sign_of_sameRay_vsub,ed737e5773cdf087080f52542509535e7446ced4,":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _
          (Set.mem_singleton _)))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÉ‚ÇÑ
    rw [‚Üê Real.Angle.sign_eq_zero_iff] at hs‚ÇÅ‚ÇÖ‚ÇÇ hs‚ÇÉ‚ÇÖ‚ÇÑ
    rw [hs‚ÇÅ‚ÇÖ‚ÇÇ, hs‚ÇÉ‚ÇÖ‚ÇÑ]
  ¬∑ let s : Set (P √ó P √ó P) :=
      (fun x : line[‚Ñù, p‚ÇÅ, p‚ÇÇ] √ó V => (x.1, p‚ÇÖ, x.2 +·µ• (x.1 : P))) ''
        Set.univ √óÀ¢ {v | SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) v ‚àß v ‚â† 0}
    have hco : IsConnected s :=
      haveI : ConnectedSpace line[‚Ñù, p‚ÇÅ, p‚ÇÇ] := AddTorsor.connectedSpace _ _
      (isConnected_univ.prod (isConnected_setOf_sameRay_and_ne_zero
        (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm))).image _
        (continuous_fst.subtype_val.prod_mk (continuous_const.prod_mk
          (continuous_snd.vadd continuous_fst.subtype_val))).continuousOn
    have hf : ContinuousOn (fun p : P √ó P √ó P => ‚à° p.1 p.2.1 p.2.2) s := by
      refine' ContinuousAt.continuousOn fun p hp => continuousAt_oangle _ _
      all_goals
        simp_rw [Set.mem_image, Set.mem_prod, Set.mem_univ, true_and_iff, Prod.ext_iff] at hp
        obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
        dsimp only at hp ‚ä¢
        obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
        dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
        obtain ‚ü®hvr, -‚ü© := hv
        rintro rfl
        refine' hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan _).2 (collinear_pair _ _ _))
      ¬∑ exact hq
      ¬∑ refine' vadd_mem_of_mem_direction _ hq
        rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
        obtain ‚ü®r, -, rfl‚ü© := hvr
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hsp : ‚àÄ p : P √ó P √ó P, p ‚àà s ‚Üí ‚à° p.1 p.2.1 p.2.2 ‚â† 0 ‚àß ‚à° p.1 p.2.1 p.2.2 ‚â† œÄ := by
      intro p hp
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff] at hp
      obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
      dsimp only at hp ‚ä¢
      obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
      dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
      obtain ‚ü®hvr, hv0‚ü© := hv
      rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
      obtain ‚ü®r, -, rfl‚ü© := hvr
      change q ‚àà line[‚Ñù, p‚ÇÅ, p‚ÇÇ] at hq
      rw [oangle_ne_zero_and_ne_pi_iff_affineIndependent]
      refine' affineIndependent_of_ne_of_mem_of_not_mem_of_mem _ hq
          (fun h => hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan h).2 (collinear_pair _ _ _))) _
      ¬∑ rwa [‚Üê @vsub_ne_zero V, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, neg_ne_zero]
      ¬∑ refine' vadd_mem_of_mem_direction _ hq
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hp‚ÇÅp‚ÇÇs : (p‚ÇÅ, p‚ÇÖ, p‚ÇÇ) ‚àà s := by
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff, Prod.ext_iff]
      refine' ‚ü®‚ü®‚ü®p‚ÇÅ, left_mem_affineSpan_pair ‚Ñù _ _‚ü©, p‚ÇÇ -·µ• p‚ÇÅ‚ü©,
        ‚ü®SameRay.rfl, vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm‚ü©, _‚ü©
      simp
    have hp‚ÇÉp‚ÇÑs : (p‚ÇÉ, p‚ÇÖ, p‚ÇÑ) ‚àà s := by
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff, Prod.ext_iff]
      refine' ‚ü®‚ü®‚ü®p‚ÇÉ, hc.mem_affineSpan_of_mem_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _))) hp‚ÇÅp‚ÇÇ‚ü©, p‚ÇÑ -·µ• p‚ÇÉ‚ü©,
        ‚ü®hr, vsub_ne_zero.2 hp‚ÇÉp‚ÇÑ.symm‚ü©, _‚ü©
      simp
    convert Real.Angle.sign_eq_of_continuousOn hco hf hsp hp‚ÇÉp‚ÇÑs hp‚ÇÅp‚ÇÇs","warning:  @oangle does not have a doc string
error:  simp made no progress
error:  simp made no progress
error:  unknown identifier 'hq'
error:  unknown identifier 'hq'
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress","theorem _root_.Collinear.oangle_sign_of_sameRay_vsub {p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P} (p‚ÇÖ : P) (hp‚ÇÅp‚ÇÇ : p‚ÇÅ ‚â† p‚ÇÇ)
    (hp‚ÇÉp‚ÇÑ : p‚ÇÉ ‚â† p‚ÇÑ) (hc : Collinear ‚Ñù ({p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P))
    (hr : SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) (p‚ÇÑ -·µ• p‚ÇÉ)) : (‚à° p‚ÇÅ p‚ÇÖ p‚ÇÇ).sign = (‚à° p‚ÇÉ p‚ÇÖ p‚ÇÑ).sign ",":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _
          (Set.mem_singleton _)))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÉ‚ÇÑ
    rw [‚Üê Real.Angle.sign_eq_zero_iff] at hs‚ÇÅ‚ÇÖ‚ÇÇ hs‚ÇÉ‚ÇÖ‚ÇÑ
    rw [hs‚ÇÅ‚ÇÖ‚ÇÇ, hs‚ÇÉ‚ÇÖ‚ÇÑ]
  ¬∑ let s : Set (P √ó P √ó P) :=
      (fun x : line[‚Ñù, p‚ÇÅ, p‚ÇÇ] √ó V => (x.1, p‚ÇÖ, x.2 +·µ• (x.1 : P))) ''
        Set.univ √óÀ¢ {v | SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) v ‚àß v ‚â† 0}
    have hco : IsConnected s :=
      haveI : ConnectedSpace line[‚Ñù, p‚ÇÅ, p‚ÇÇ] := AddTorsor.connectedSpace _ _
      (isConnected_univ.prod (isConnected_setOf_sameRay_and_ne_zero
        (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm))).image _
        (continuous_fst.subtype_val.prod_mk (continuous_const.prod_mk
          (continuous_snd.vadd continuous_fst.subtype_val))).continuousOn
    have hf : ContinuousOn (fun p : P √ó P √ó P => ‚à° p.1 p.2.1 p.2.2) s := by
      refine ContinuousAt.continuousOn fun p hp => continuousAt_oangle ?_ ?_
      all_goals
        simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_univ, true_and_iff, Prod.ext_iff] at hp
        obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
        dsimp only at hp ‚ä¢
        obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
        dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
        obtain ‚ü®hvr, -‚ü© := hv
        rintro rfl
        refine hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan ?_).2 (collinear_pair _ _ _))
      ¬∑ exact hq
      ¬∑ refine vadd_mem_of_mem_direction ?_ hq
        rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
        obtain ‚ü®r, -, rfl‚ü© := hvr
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hsp : ‚àÄ p : P √ó P √ó P, p ‚àà s ‚Üí ‚à° p.1 p.2.1 p.2.2 ‚â† 0 ‚àß ‚à° p.1 p.2.1 p.2.2 ‚â† œÄ := by
      intro p hp
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff] at hp
      obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
      dsimp only at hp ‚ä¢
      obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
      dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
      obtain ‚ü®hvr, hv0‚ü© := hv
      rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
      obtain ‚ü®r, -, rfl‚ü© := hvr
      change q ‚àà line[‚Ñù, p‚ÇÅ, p‚ÇÇ] at hq
      rw [oangle_ne_zero_and_ne_pi_iff_affineIndependent]
      refine affineIndependent_of_ne_of_mem_of_not_mem_of_mem ?_ hq
          (fun h => hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan h).2 (collinear_pair _ _ _))) ?_
      ¬∑ rwa [‚Üê @vsub_ne_zero V, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, neg_ne_zero]
      ¬∑ refine vadd_mem_of_mem_direction ?_ hq
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hp‚ÇÅp‚ÇÇs : (p‚ÇÅ, p‚ÇÖ, p‚ÇÇ) ‚àà s := by
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine ‚ü®‚ü®‚ü®p‚ÇÅ, left_mem_affineSpan_pair ‚Ñù _ _‚ü©, p‚ÇÇ -·µ• p‚ÇÅ‚ü©,
        ‚ü®SameRay.rfl, vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm‚ü©, ?_‚ü©
      simp
    have hp‚ÇÉp‚ÇÑs : (p‚ÇÉ, p‚ÇÖ, p‚ÇÑ) ‚àà s := by
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine ‚ü®‚ü®‚ü®p‚ÇÉ, hc.mem_affineSpan_of_mem_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _))) hp‚ÇÅp‚ÇÇ‚ü©, p‚ÇÑ -·µ• p‚ÇÉ‚ü©,
        ‚ü®hr, vsub_ne_zero.2 hp‚ÇÉp‚ÇÑ.symm‚ü©, ?_‚ü©
      simp
    convert Real.Angle.sign_eq_of_continuousOn hco hf hsp hp‚ÇÉp‚ÇÑs hp‚ÇÅp‚ÇÇs",":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ Set.mem_insert _ _))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2"
Mathlib/Condensed/TopComparison.lean,factorsThrough_of_pullbackCondition,factorsThrough_of_pullbackCondition,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  intro x y hxy
  let xy : G.obj (pullback œÄ œÄ) := (PreservesPullback.iso G œÄ œÄ).inv <|
    (TopCat.pullbackIsoProdSubtype (G.map œÄ) (G.map œÄ)).inv ‚ü®(x, y), hxy‚ü©
  have ha' := congr_fun ha xy
  dsimp at ha'
  have h‚ÇÅ : ‚àÄ y, G.map pullback.fst ((PreservesPullback.iso G œÄ œÄ).inv y) =
      pullback.fst (f := G.map œÄ) (g := G.map œÄ) y := by
    simp only [‚Üê PreservesPullback.iso_inv_fst]; intro y; rfl
  have h‚ÇÇ : ‚àÄ y, G.map pullback.snd ((PreservesPullback.iso G œÄ œÄ).inv y) =
      pullback.snd (f := G.map œÄ) (g := G.map œÄ) y := by
    simp only [‚Üê PreservesPullback.iso_inv_snd]; intro y; rfl
  erw [h‚ÇÅ, h‚ÇÇ] at ha'
  simpa using ha'","error:  type mismatch
  h‚úù
has type
  a (pullback.fst ((TopCat.pullbackIsoProdSubtype (G.map œÄ) (G.map œÄ)).inv ‚ü®(x, y), hxy‚ü©)) =
    a (pullback.snd ((TopCat.pullbackIsoProdSubtype (G.map œÄ) (G.map œÄ)).inv ‚ü®(x, y), hxy‚ü©)) : Prop
but is expected to have type
  a x = a y : Prop","theorem factorsThrough_of_pullbackCondition {Z B : C} {œÄ : Z ‚ü∂ B} [HasPullback œÄ œÄ]
    [PreservesLimit (cospan œÄ œÄ) G]
    {a : C(G.obj Z, X)}
    (ha : a ‚àò (G.map pullback.fst) = a ‚àò (G.map (pullback.snd (f := œÄ) (g := œÄ)))) :
    Function.FactorsThrough a (G.map œÄ) ",":= by
  intro x y hxy
  let xy : G.obj (pullback œÄ œÄ) := (PreservesPullback.iso G œÄ œÄ).inv <|
    (TopCat.pullbackIsoProdSubtype (G.map œÄ) (G.map œÄ)).inv ‚ü®(x, y), hxy‚ü©
  have ha' := congr_fun ha xy
  dsimp at ha'
  have h‚ÇÅ : ‚àÄ y, G.map pullback.fst ((PreservesPullback.iso G œÄ œÄ).inv y) =
      pullback.fst (f := G.map œÄ) (g := G.map œÄ) y := by
    simp only [‚Üê PreservesPullback.iso_inv_fst]; intro y; rfl
  have h‚ÇÇ : ‚àÄ y, G.map pullback.snd ((PreservesPullback.iso G œÄ œÄ).inv y) =
      pullback.snd (f := G.map œÄ) (g := G.map œÄ) y := by
    simp only [‚Üê PreservesPullback.iso_inv_snd]; intro y; rfl
  erw [h‚ÇÅ, h‚ÇÇ, TopCat.pullbackIsoProdSubtype_inv_fst_apply,
    TopCat.pullbackIsoProdSubtype_inv_snd_apply] at ha'
  simpa using ha'",":= by
  intro x y hxy
  let xy : G.obj (pullback œÄ œÄ) := (PreservesPullback.iso G œÄ œÄ).inv <|
    (TopCat.pullbackIsoProdSubtype (G.map œÄ) (G.map œÄ)).inv ‚ü®(x, y), hxy‚ü©
  have ha' := congr_fun ha xy
  dsimp at ha'
  have h‚ÇÅ : ‚àÄ y, G.map pullback.fst ((PreservesPullback.iso G œÄ œÄ).inv y) =
      pullback.fst (f := G.map œÄ) (g := G.map œÄ) y := by
    simp only [‚Üê PreservesPullback.iso_inv_fst]; intro y; rfl
  have h‚ÇÇ : ‚àÄ y, G.map pullback.snd ((PreservesPullback.iso G œÄ œÄ).inv y) =
      pullback.snd (f := G.map œÄ) (g := G.map œÄ) y := by
    simp only [‚Üê PreservesPullback.iso_inv_fst]; intro y; rfl
  have h‚ÇÇ : ‚àÄ y, G.map pullback.snd ((PreservesPullback.iso G œÄ œÄ).inv y) =
      pullback.snd (f := G.map œÄ) (g := G.map œÄ) y := by
    simp only [‚Üê PreservesPullback.iso_inv_snd]; intro y; rfl
  erw [h‚ÇÅ, h‚ÇÇ] at ha'
  simpa using ha'"
Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean,MeasureTheory.integral_Iic_of_hasDerivAt_of_tendsto,integral_Iic_of_hasDerivAt_of_tendsto,c97b9b00802c2ed343d9ac73e59be287428dbcf0,":= by
  have hcont : ContinuousOn f (Iic a) := by
    intro x hx
    rcases hx.out.eq_or_lt with rfl|hx
    ¬∑ exact hcont
    ¬∑ exact (hderiv x hx).continuousAt.continuousWithinAt
  refine' tendsto_nhds_unique (intervalIntegral_tendsto_integral_Iic a f'int tendsto_id) _
  apply Tendsto.congr' _ (hf.const_sub _)
  filter_upwards [Iic_mem_atBot a] with x hx
  symm
  apply intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le hx
    (hcont.mono Icc_subset_Iic_self) fun y hy => hderiv y hy.2
  rw [intervalIntegrable_iff_integrable_Ioc_of_le hx]
  exact f'int.mono (fun y hy => hy.2) le_rfl","error:  unknown identifier 'intervalIntegrable_iff_integrable_Ioc_of_le'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.239605
case h
E : Type u_1
f f' : ‚Ñù ‚Üí E
g g' : ‚Ñù ‚Üí ‚Ñù
a b l : ‚Ñù
m : E
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
inst‚úù : CompleteSpace E
hcont‚úù : ContinuousWithinAt f (Iic a) a
hderiv : ‚àÄ x ‚àà Iio a, HasDerivAt f (f' x) x
f'int : IntegrableOn f' (Iic a) volume
hf : Tendsto f atBot (ùìù m)
hcont : ContinuousOn f (Iic a)
x : ‚Ñù
hx : x ‚àà Iic a
‚ä¢ IntervalIntegrable f' volume x a","theorem integral_Iic_of_hasDerivAt_of_tendsto (hcont : ContinuousWithinAt f (Iic a) a)
    (hderiv : ‚àÄ x ‚àà Iio a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Iic a))
    (hf : Tendsto f atBot (ùìù m)) : ‚à´ x in Iic a, f' x = f a - m ",":= by
  have hcont : ContinuousOn f (Iic a) := by
    intro x hx
    rcases hx.out.eq_or_lt with rfl|hx
    ¬∑ exact hcont
    ¬∑ exact (hderiv x hx).continuousAt.continuousWithinAt
  refine tendsto_nhds_unique (intervalIntegral_tendsto_integral_Iic a f'int tendsto_id) ?_
  apply Tendsto.congr' _ (hf.const_sub _)
  filter_upwards [Iic_mem_atBot a] with x hx
  symm
  apply intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le hx
    (hcont.mono Icc_subset_Iic_self) fun y hy => hderiv y hy.2
  rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hx]
  exact f'int.mono (fun y hy => hy.2) le_rfl",":= by
  have hcont : ContinuousOn f (Iic a) := by
    intro x hx
    rcases hx.out.eq_or_lt with rfl|hx
    ¬∑ exact hcont
    ¬∑ exact (hderiv x hx).continuousAt.continuousWithinAt
  refine tendsto_nhds_unique (intervalIntegral_tendsto_integral_Iic a f'int tendsto_id) ?_
  apply Tendsto.congr' _ (hf.const_sub _)
  filter_upwards [Iic_mem_atBot a] with x hx
  symm
  apply intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le hx
    (hcont.mono Icc_subset_Iic_self) fun y hy => hderiv y hy.2
  rw [intervalIntegrable_iff_integrable_Ioc_of_le hx]
  exact f'int.mono (fun y hy => hy.2) le_rfl"
Mathlib/NumberTheory/SumTwoSquares.lean,ZMod.isSquare_neg_one_iff,ZMod.isSquare_neg_one_iff,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  refine' ‚ü®fun H q hqp hqd => hqp.mod_four_ne_three_of_dvd_isSquare_neg_one hqd H, fun H => _‚ü©
  induction' n using induction_on_primes with p n hpp ih
  ¬∑ exact False.elim (hn.ne_zero rfl)
  ¬∑ exact ‚ü®0, by simp only [Fin.zero_mul, neg_eq_zero, Fin.one_eq_zero_iff]‚ü©
  ¬∑ haveI : Fact p.Prime := ‚ü®hpp‚ü©
    have hcp : p.Coprime n := by
      by_contra hc
      exact hpp.not_unit (hn p <| mul_dvd_mul_left p <| hpp.dvd_iff_not_coprime.mpr hc)
    have hp‚ÇÅ := ZMod.exists_sq_eq_neg_one_iff.mpr (H hpp (dvd_mul_right p n))
    exact ZMod.isSquare_neg_one_mul hcp hp‚ÇÅ
      (ih hn.of_mul_right fun hqp hqd => H hqp <| dvd_mul_of_dvd_right hqd _)",error:  simp made no progress,"theorem ZMod.isSquare_neg_one_iff {n : ‚Ñï} (hn : Squarefree n) :
    IsSquare (-1 : ZMod n) ‚Üî ‚àÄ {q : ‚Ñï}, q.Prime ‚Üí q ‚à£ n ‚Üí q % 4 ‚â† 3 ",":= by
  refine ‚ü®fun H q hqp hqd => hqp.mod_four_ne_three_of_dvd_isSquare_neg_one hqd H, fun H => ?_‚ü©
  induction' n using induction_on_primes with p n hpp ih
  ¬∑ exact False.elim (hn.ne_zero rfl)
  ¬∑ exact ‚ü®0, by simp only [mul_zero, eq_iff_true_of_subsingleton]‚ü©
  ¬∑ haveI : Fact p.Prime := ‚ü®hpp‚ü©
    have hcp : p.Coprime n := by
      by_contra hc
      exact hpp.not_unit (hn p <| mul_dvd_mul_left p <| hpp.dvd_iff_not_coprime.mpr hc)
    have hp‚ÇÅ := ZMod.exists_sq_eq_neg_one_iff.mpr (H hpp (dvd_mul_right p n))
    exact ZMod.isSquare_neg_one_mul hcp hp‚ÇÅ
      (ih hn.of_mul_right fun hqp hqd => H hqp <| dvd_mul_of_dvd_right hqd _)",":= by
  refine ‚ü®fun H q hqp hqd => hqp.mod_four_ne_three_of_dvd_isSquare_neg_one hqd H, fun H => ?_‚ü©
  induction' n using induction_on_primes with p n hpp ih
  ¬∑ exact False.elim (hn.ne_zero rfl)
  ¬∑ exact ‚ü®0, by simp only [Fin.zero_mul, neg_eq_zero, Fin.one_eq_zero_iff]‚ü©
  ¬∑ haveI : Fact p.Prime := ‚ü®hpp‚ü©
    have hcp : p.Coprime n := by
      by_contra hc
      exact hpp.not_unit (hn p <| mul_dvd_mul_left p <| hpp.dvd_iff_not_coprime.mpr hc)
    have hp‚ÇÅ := ZMod.exists_sq_eq_neg_one_iff.mpr (H hpp (dvd_mul_right p n))
    exact ZMod.isSquare_neg_one_mul hcp hp‚ÇÅ
      (ih hn.of_mul_right fun hqp hqd => H hqp <| dvd_mul_of_dvd_right hqd _)"
Mathlib/Analysis/Complex/Basic.lean,Complex.conj_mul',conj_mul',cc92efbba7c836fd1168a41a3a4ef1d126c990d7,:= IsROrC.conj_mul z,error:  unknown identifier 'IsROrC.conj_mul',lemma conj_mul' (z : ‚ÑÇ) : conj z * z = ‚Äñz‚Äñ ^ 2 ,:= RCLike.conj_mul z,:= IsRorC.conj_mul z
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.exists_of_mem_join,exists_of_mem_join,88f252d9ef6777980e9cb4396094e178f3ed4acb,":= by
  suffices
    ‚àÄ ss : WSeq Œ±,
      a ‚àà ss ‚Üí ‚àÄ s S, s ++ join S = ss ‚Üí a ‚àà s ++ join S ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)
  intro ss h; induction' h using mem_rec_on with ss b ss _ IH ss _ IH <;> intro s S <;>
    cases' ss with ss
  ¬∑ induction' s using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg (Seq'.dest ‚àò data) ej <;>
      simp at this; cases this
    substs b' ss
    simp? at m ‚ä¢ says simp only [cons_append, mem_cons_iff, true_or] at m ‚ä¢
  ¬∑ induction' s using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg (Seq'.dest ‚àò data) ej <;>
      simp at this; try cases this; try contradiction
    substs b' ss
    simp at m ‚ä¢
    cases' m with e m
    ¬∑ simp [e]
    exact Or.imp_left Or.inr (IH _ _ rfl m)
  ¬∑ induction' s using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg (Seq'.dest ‚àò data) ej <;>
      simp at this <;> subst ss
    ¬∑ apply Or.inr
      simp [- exists_eq_or_imp] at m ‚ä¢
      cases' IH s S rfl m with as ex
      ¬∑ exact ‚ü®s, Or.inl rfl, as‚ü©
      ¬∑ rcases ex with ‚ü®s', sS, as‚ü©
        exact ‚ü®s', Or.inr sS, as‚ü©
    ¬∑ apply Or.inr
      simp? at m says simp only [join_think, nil_append, mem_think] at m
      rcases (IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with ‚ü®s, sS, as‚ü©
      exact ‚ü®s, by simp [sS], as‚ü©
    ¬∑ simp only [think_append, mem_think] at m IH ‚ä¢
      apply IH _ _ rfl m","error:  failed to synthesize
  HAppend (WSeq Œ±) (WSeq Œ±) (WSeq Œ±)
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  HAppend (WSeq Œ±) (WSeq Œ±) (?m.108809 ss s S)
use `set_option diagnostics true` to get diagnostic information
error:  simp made no progress
error:  simp made no progress
error:  unsolved goals
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
a : Œ±
‚ä¢ ‚àÄ {S : WSeq (WSeq Œ±)}, a ‚àà S.join ‚Üí ‚àÉ s, s ‚àà S ‚àß a ‚àà s","theorem exists_of_mem_join {a : Œ±} : ‚àÄ {S : WSeq (WSeq Œ±)}, a ‚àà join S ‚Üí ‚àÉ s, s ‚àà S ‚àß a ‚àà s ",":= by
  suffices
    ‚àÄ ss : WSeq Œ±,
      a ‚àà ss ‚Üí ‚àÄ s S, append s (join S) = ss ‚Üí a ‚àà append s (join S) ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)
  intro ss h; apply mem_rec_on h <;> [intro b ss o; intro ss IH] <;> intro s S
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp? at m ‚ä¢ says simp only [cons_append, mem_cons_iff] at m ‚ä¢
    cases' o with e IH
    ¬∑ simp [e]
    cases' m with e m
    ¬∑ simp [e]
    exact Or.imp_left Or.inr (IH _ _ rfl m)
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq.destruct ej <;> simp at this <;>
      subst ss
    ¬∑ apply Or.inr
      simp [-exists_eq_or_imp] at m ‚ä¢
      cases' IH s S rfl m with as ex
      ¬∑ exact ‚ü®s, Or.inl rfl, as‚ü©
      ¬∑ rcases ex with ‚ü®s', sS, as‚ü©
        exact ‚ü®s', Or.inr sS, as‚ü©
    ¬∑ apply Or.inr
      simp? at m says simp only [join_think, nil_append, mem_think] at m
      rcases (IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with ‚ü®s, sS, as‚ü©
      exact ‚ü®s, by simp [sS], as‚ü©
    ¬∑ simp only [think_append, mem_think] at m IH ‚ä¢
      apply IH _ _ rfl m",":= by
  suffices
    ‚àÄ ss : WSeq Œ±,
      a ‚àà ss ‚Üí ‚àÄ s S, s ++ join S = ss ‚Üí a ‚àà s ++ join S ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)
  intro ss h; induction' h using mem_rec_on with ss b ss _ IH ss _ IH <;> intro s S <;>
    cases' ss with ss
  ¬∑ induction' s using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg (Seq'.dest ‚àò data) ej <;>
      simp at this; try cases this; try contradiction
    substs b' ss
    simp? at m ‚ä¢ says simp only [cons_append, mem_cons_iff, true_or] at m ‚ä¢
  ¬∑ induction' s using WSeq.recOn' s using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg (Seq'.dest ‚àò data) ej <;>
      simp at this; try cases this; try contradiction
    substs b' ss
    simp? at m ‚ä¢ says simp only [cons_append, mem_cons_iff, true_or] at m ‚ä¢
  ¬∑ induction' s using WSeq.recOn' s using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg (Seq'.dest ‚àò data) ej <;>
      simp at this; try cases this; try contradiction
    substs b' ss
    simp? at m ‚ä¢ says simp only [cons_append, mem_cons_iff, true_or] at m ‚ä¢
  ¬∑ induction' s using WSeq.recOn' s using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with b' s s <;>
      [induction' S using WSeq.recOn' with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg (Seq'.dest ‚àò data) ej <;>
      simp at this; try cases this; try contradiction
    substs b' ss
    simp? at m ‚ä¢ says simp only [cons_append, mem_cons_iff, true_or] at m ‚ä¢
  ¬∑ induction' s using WSeq.recOn' s using WSeq.recOn' with b' s s <;>
      [induction' S using W"
Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean,MeasureTheory.Measure.tendsto_addHaar_inter_smul_one_of_density_one,tendsto_addHaar_inter_smul_one_of_density_one,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  have I : ‚àÄ u v, Œº u ‚â† 0 ‚Üí Œº u ‚â† ‚àû ‚Üí MeasurableSet v ‚Üí
    Œº u / Œº u - Œº (v·∂ú ‚à© u) / Œº u = Œº (v ‚à© u) / Œº u := by
    intro u v uzero utop vmeas
    simp_rw [div_eq_mul_inv]
    rw [‚Üê ENNReal.sub_mul]; swap
    ¬∑ simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]
    congr 1
    apply
      ENNReal.sub_eq_of_add_eq (ne_top_of_le_ne_top utop (measure_mono (inter_subset_right _ _)))
    rw [inter_comm _ u, inter_comm _ u]
    exact measure_inter_add_diff u vmeas
  have L : Tendsto (fun r => Œº (s·∂ú ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0) := by
    have A : Tendsto (fun r => Œº (closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1) := by
      apply tendsto_const_nhds.congr' _
      filter_upwards [self_mem_nhdsWithin]
      intro r hr
      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]
      ¬∑ exact (measure_closedBall_pos Œº _ hr).ne'
      ¬∑ exact measure_closedBall_lt_top.ne
    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)
    simp only [tsub_self] at B
    apply B.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    convert I (closedBall x r) s·∂ú (measure_closedBall_pos Œº _ rpos).ne'
      measure_closedBall_lt_top.ne hs.compl
    rw [compl_compl]
  have L' : Tendsto (fun r : ‚Ñù => Œº (s·∂ú ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 0) :=
    tendsto_addHaar_inter_smul_zero_of_density_zero Œº s·∂ú x L t ht h''t
  have L'' : Tendsto (fun r : ‚Ñù => Œº ({x} + r ‚Ä¢ t) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by
    apply tendsto_const_nhds.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    rw [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne', ENNReal.div_self h't h''t]
  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)
  simp only [tsub_zero] at this
  apply this.congr' _
  filter_upwards [self_mem_nhdsWithin]
  rintro r (rpos : 0 < r)
  refine' I ({x} + r ‚Ä¢ t) s _ _ hs
  ¬∑ simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage_add, abs_pow,
      singleton_add, mul_eq_zero]
  ¬∑ simp [h''t, ENNReal.ofReal_ne_top, addHaar_smul, image_add_left, ENNReal.mul_eq_top,
      Ne, not_false_iff, measure_preimage_add, singleton_add, and_false_iff, false_and_iff,
      or_self_iff]","error:  function expected at
  inter_subset_right ?m.538807
term has type
  ?m.538806 ‚àà ?m.538805","theorem tendsto_addHaar_inter_smul_one_of_density_one_aux (s : Set E) (hs : MeasurableSet s)
    (x : E) (h : Tendsto (fun r => Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1))
    (t : Set E) (ht : MeasurableSet t) (h't : Œº t ‚â† 0) (h''t : Œº t ‚â† ‚àû) :
    Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) ",":= by
  have I : ‚àÄ u v, Œº u ‚â† 0 ‚Üí Œº u ‚â† ‚àû ‚Üí MeasurableSet v ‚Üí
    Œº u / Œº u - Œº (v·∂ú ‚à© u) / Œº u = Œº (v ‚à© u) / Œº u := by
    intro u v uzero utop vmeas
    simp_rw [div_eq_mul_inv]
    rw [‚Üê ENNReal.sub_mul]; swap
    ¬∑ simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]
    congr 1
    apply
      ENNReal.sub_eq_of_add_eq (ne_top_of_le_ne_top utop (measure_mono inter_subset_right))
    rw [inter_comm _ u, inter_comm _ u]
    exact measure_inter_add_diff u vmeas
  have L : Tendsto (fun r => Œº (s·∂ú ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0) := by
    have A : Tendsto (fun r => Œº (closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1) := by
      apply tendsto_const_nhds.congr' _
      filter_upwards [self_mem_nhdsWithin]
      intro r hr
      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]
      ¬∑ exact (measure_closedBall_pos Œº _ hr).ne'
      ¬∑ exact measure_closedBall_lt_top.ne
    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)
    simp only [tsub_self] at B
    apply B.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    convert I (closedBall x r) s·∂ú (measure_closedBall_pos Œº _ rpos).ne'
      measure_closedBall_lt_top.ne hs.compl
    rw [compl_compl]
  have L' : Tendsto (fun r : ‚Ñù => Œº (s·∂ú ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 0) :=
    tendsto_addHaar_inter_smul_zero_of_density_zero Œº s·∂ú x L t ht h''t
  have L'' : Tendsto (fun r : ‚Ñù => Œº ({x} + r ‚Ä¢ t) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by
    apply tendsto_const_nhds.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    rw [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne', ENNReal.div_self h't h''t]
  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)
  simp only [tsub_zero] at this
  apply this.congr' _
  filter_upwards [self_mem_nhdsWithin]
  rintro r (rpos : 0 < r)
  refine I ({x} + r ‚Ä¢ t) s ?_ ?_ hs
  ¬∑ simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage_add, abs_pow,
      singleton_add, mul_eq_zero]
  ¬∑ simp [h''t, ENNReal.ofReal_ne_top, addHaar_smul, image_add_left, ENNReal.mul_eq_top,
      Ne, not_false_iff, measure_preimage_add, singleton_add, and_false_iff, false_and_iff,
      or_self_iff]",":= by
  have I : ‚àÄ u v, Œº u ‚â† 0 ‚Üí Œº u ‚â† ‚àû ‚Üí MeasurableSet v ‚Üí
    Œº u / Œº u - Œº (v·∂ú ‚à© u) / Œº u = Œº (v ‚à© u) / Œº u := by
    intro u v uzero utop vmeas
    simp_rw [div_eq_mul_inv]
    rw [‚Üê ENNReal.sub_mul]; swap
    ¬∑ simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]
    congr 1
    apply
      ENNReal.sub_eq_of_add_eq (ne_top_of_le_ne_top utop (measure_mono inter_subset_right))
    rw [inter_comm _ u, inter_comm _ u]
    exact measure_inter_add_diff u vmeas
  have L : Tendsto (fun r => Œº (s·∂ú ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1) := by
      apply tendsto_const_nhds.congr' _
      filter_upwards [self_mem_nhdsWithin]
      intro r hr
      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]
      ¬∑ exact (measure_closedBall_pos Œº _ hr).ne'
      ¬∑ exact measure_closedBall_lt_top.ne
    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)
    simp only [tsub_self] at B
    apply B.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    rw [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne', ENNReal.div_self h't h''t]
  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)
  simp only [tsub_zero] at this
  apply this.congr' _
  filter_upwards [self_mem_nhdsWithin]
  rintro r (rpos : 0 < r)
  refine I ({x} + r ‚Ä¢ t) s ?_ ?_ hs
  ¬∑ simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,7dc162787d2a79bf721a83a87f641ace70251b17,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_ortho"
Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean,quadraticChar_sq_one,quadraticChar_sq_one,8e31b5ac6bed8ba535a30f3442252684d2f151c1,":= by
  simp only [quadraticCharFun, ha, pow_eq_zero_iff, Nat.succ_pos', IsSquare_sq, if_true, if_false,
    quadraticChar_apply]","error:  unsolved goals
F : Type u_1
inst‚úù¬≤ : Field F
inst‚úù¬π : Fintype F
inst‚úù : DecidableEq F
a : F
ha : a ‚â† 0
‚ä¢ (if a ^ 2 = 0 then 0 else 1) = 1
warning:  `MulChar.IsNontrivial` has been deprecated
warning:  `MulChar.isNontrivial_iff` has been deprecated",theorem quadraticChar_sq_one' {a : F} (ha : a ‚â† 0) : quadraticChar F (a ^ 2) = 1 ,":= by
  simp only [quadraticChar_apply, quadraticCharFun, sq_eq_zero_iff, ha, IsSquare_sq, if_true,
    if_false]",":= by
  simp only [quadraticCharFun, ha, pow_eq_zero_iff, Nat.succ_pos, IsSquare_sq, if_true, if_false,
    quadraticChar_apply]"
Mathlib/Analysis/NormedSpace/Units.lean,NormedRing.inverse_add,inverse_add,9e34a191034458a56331f976ff7400a26407c888,":= by
  nontriviality R
  rw [Metric.eventually_nhds_iff]
  refine ‚ü®‚Äñ(‚Üëx‚Åª¬π : R)‚Äñ‚Åª¬π, by cancel_denoms, fun t ht ‚Ü¶ ?_‚ü©
  rw [dist_zero_right] at ht
  rw [‚Üê x.add_val t ht, inverse_unit, Units.add, Units.copy_eq, mul_inv_rev, Units.val_mul,
    ‚Üê inverse_unit, Units.oneSub_val, sub_neg_eq_add]","error:  invalid field 'add_val', the environment does not contain 'Units.add_val'
  x
has type
  RÀ£
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.29443
R : Type u_1
inst‚úù¬π : NormedRing R
inst‚úù : CompleteSpace R
x : RÀ£
a‚úù : Nontrivial R
t : R
ht : ‚Äñt‚Äñ < ‚Äñ‚Üëx‚Åª¬π‚Äñ‚Åª¬π
‚ä¢ inverse (‚Üëx + t) = inverse (1 + ‚Üëx‚Åª¬π * t) * ‚Üëx‚Åª¬π","theorem inverse_add (x : RÀ£) :
    ‚àÄ·∂† t in ùìù 0, inverse ((x : R) + t) = inverse (1 + ‚Üëx‚Åª¬π * t) * ‚Üëx‚Åª¬π ",":= by
  nontriviality R
  rw [Metric.eventually_nhds_iff]
  refine ‚ü®‚Äñ(‚Üëx‚Åª¬π : R)‚Äñ‚Åª¬π, by cancel_denoms, fun t ht ‚Ü¶ ?_‚ü©
  rw [dist_zero_right] at ht
  rw [‚Üê x.val_add t ht, inverse_unit, Units.add, Units.copy_eq, mul_inv_rev, Units.val_mul,
    ‚Üê inverse_unit, Units.val_oneSub, sub_neg_eq_add]",":= by
  nontriviality R
  rw [Metric.eventually_nhds_iff]
  refine ‚ü®‚Äñ(‚Üëx‚Åª¬π : R)‚Äñ‚Åª¬π, by cancel_denoms, fun t ht ‚Ü¶ ?_‚ü©
  rw [dist_zero_right] at ht
  rw [‚Üê x.add_val t ht, inverse_unit, Units.add, Units.copy_eq, Units.val_mul,
    ‚Üê inverse_unit, Units.oneSub_val, sub_neg_eq_add]"
Mathlib/NumberTheory/ADEInequality.lean,ADEInequality.Admissible.one_lt_sumInv,Admissible.one_lt_sumInv,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [Admissible]
  rintro (‚ü®p', q', H‚ü© | ‚ü®n, H‚ü© | H | H | H)
  ¬∑ rw [‚Üê H, A', sumInv_pqr, add_assoc]
    simp only [lt_add_iff_pos_right, PNat.one_coe, inv_one, Nat.cast_one]
    apply add_pos <;> simp only [PNat.pos, Nat.cast_pos, inv_pos]
  ¬∑ rw [‚Üê H, D', sumInv_pqr]
    conv_rhs => simp only [OfNat.ofNat, PNat.mk_coe]
    norm_num
  all_goals
    rw [‚Üê H, E', sumInv_pqr]
    conv_rhs => simp only [OfNat.ofNat, PNat.mk_coe]","error:  unsolved goals
case inr.inr.inl
pqr : Multiset ‚Ñï+
H : E' 3 = pqr
‚ä¢ 1 < (‚Üë2)‚Åª¬π + (‚Üë3)‚Åª¬π + (‚Üë3)‚Åª¬π

case inr.inr.inr.inl
pqr : Multiset ‚Ñï+
H : E' 4 = pqr
‚ä¢ 1 < (‚Üë2)‚Åª¬π + (‚Üë3)‚Åª¬π + (‚Üë4)‚Åª¬π

case inr.inr.inr.inr
pqr : Multiset ‚Ñï+
H : E' 5 = pqr
‚ä¢ 1 < (‚Üë2)‚Åª¬π + (‚Üë3)‚Åª¬π + (‚Üë5)‚Åª¬π",theorem Admissible.one_lt_sumInv {pqr : Multiset ‚Ñï+} : Admissible pqr ‚Üí 1 < sumInv pqr ,":= by
  rw [Admissible]
  rintro (‚ü®p', q', H‚ü© | ‚ü®n, H‚ü© | H | H | H)
  ¬∑ rw [‚Üê H, A', sumInv_pqr, add_assoc]
    simp only [lt_add_iff_pos_right, PNat.one_coe, inv_one, Nat.cast_one]
    apply add_pos <;> simp only [PNat.pos, Nat.cast_pos, inv_pos]
  ¬∑ rw [‚Üê H, D', sumInv_pqr]
    conv_rhs => simp only [OfNat.ofNat, PNat.mk_coe]
    norm_num
  all_goals
    rw [‚Üê H, E', sumInv_pqr]
    conv_rhs => simp only [OfNat.ofNat, PNat.mk_coe]
    rfl",":= by
  rw [Admissible]
  rintro (‚ü®p', q', H‚ü© | ‚ü®n, H‚ü© | H | H | H)
  ¬∑ rw [‚Üê H, A', sumInv_pqr, add_assoc]
    simp only [lt_add_iff_pos_right, PNat.one_coe, inv_one, Nat.cast_one]
    apply add_pos <;> simp only [PNat.pos, Nat.cast_pos, inv_pos]
  ¬∑ rw [‚Üê H, D', sumInv_pqr]
    conv_rhs => simp only [OfNat.ofNat, PNat.mk_coe]
    norm_num
  all_goals
    rw [‚Üê H, E', sumInv_pqr]
    conv_rhs => simp only [OfNat.ofNat, PNat.mk_coe]"
Mathlib/Data/Num/Lemmas.lean,Num.ofNat'_eq,ofNat'_eq,c047c646d66e915f27c3e7f159bef508bfc8dd10,":=
  Nat.binaryRec (by simp) fun b n IH => by
    rw [ofNat'] at IH ‚ä¢
    rw [Nat.binaryRec_eq, IH]
    ¬∑ cases b <;> simp [Nat.bit, ‚Üê bit0_of_bit0, ‚Üê bit1_of_bit1, _root_.bit0, _root_.bit1]
    ¬∑ left; rfl","warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `castNum` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  tactic 'left' failed, left tactic works for inductive types with exactly 2 constructors
case h
Œ± : Type u_1
b : Bool
n : ‚Ñï
IH : Nat.binaryRec 0 (fun b x ‚Ü¶ bif b then Num.bit1 else Num.bit0) n = ‚Üën
‚ä¢ (bif false then Num.bit1 else Num.bit0) 0 = 0
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated","theorem ofNat'_eq : ‚àÄ n, Num.ofNat' n = n ",":=
  Nat.binaryRec (by simp) fun b n IH => by
    rw [ofNat'] at IH ‚ä¢
    rw [Nat.binaryRec_eq, IH]
    ¬∑ cases b <;> simp [Nat.bit, bit0_of_bit0, bit1_of_bit1, Nat.cast_bit0, Nat.cast_bit1]
    ¬∑ rfl",":=
  Nat.binaryRec (by simp) fun b n IH => by
    rw [ofNat'] at IH ‚ä¢
    rw [Nat.binaryRec_eq, IH]
    ¬∑ cases b <;> simp [Nat.bit, ‚Üê bit0_of_bit0, ‚Üê bit1_of_bit0, _root_.bit1]
    ¬∑ left; rfl"
Mathlib/CategoryTheory/Abelian/Pseudoelements.lean,CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono,pseudo_injective_of_mono,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  intro abar abar'
  refine' Quotient.inductionOn‚ÇÇ abar abar' fun a a' ha => _
  apply Quotient.sound
  have : ‚ü¶(a.hom ‚â´ f : Over Q)‚üß = ‚ü¶‚Üë(a'.hom ‚â´ f)‚üß := by convert ha
  have ‚ü®R, p, q, ep, Eq, comm‚ü© := Quotient.exact this
  exact ‚ü®R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact comm‚ü©","error:  don't know how to synthesize implicit argument 'Œ±'
  @Eq (Quotient ?m.42591) ‚ü¶Over.mk (a.hom ‚â´ f)‚üß ‚ü¶Over.mk (a'.hom ‚â´ f)‚üß
context:
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ Type (max u v)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ Setoid (Over Q)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ Setoid (Over Q)
error:  unsolved goals
case a
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ a ‚âà a'",theorem pseudo_injective_of_mono {P Q : C} (f : P ‚ü∂ Q) [Mono f] : Function.Injective f ,":= by
  intro abar abar'
  refine Quotient.inductionOn‚ÇÇ abar abar' fun a a' ha => ?_
  apply Quotient.sound
  have : (‚ü¶(a.hom ‚â´ f : Over Q)‚üß : Quotient (setoid Q)) = ‚ü¶‚Üë(a'.hom ‚â´ f)‚üß := by convert ha
  have ‚ü®R, p, q, ep, Eq, comm‚ü© := Quotient.exact this
  exact ‚ü®R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact comm‚ü©",":= by
  intro abar abar'
  refine Quotient.inductionOn‚ÇÇ abar abar' fun a a' ha => ?_
  apply Quotient.exact this
  exact ‚ü®R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact comm‚ü©"
Mathlib/Order/SuccPred/LinearLocallyFinite.lean,le_of_toZ_le,le_of_toZ_le,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases le_or_lt i0 i with hi | hi <;> rcases le_or_lt i0 j with hj | hj
  ¬∑ rw [‚Üê iterate_succ_toZ i hi, ‚Üê iterate_succ_toZ j hj]
    exact Monotone.monotone_iterate_of_le_map succ_mono (le_succ _) (Int.toNat_le_toNat h_le)
  ¬∑ exact absurd ((toZ_neg hj).trans_le (toZ_nonneg hi)) (not_lt.mpr h_le)
  ¬∑ exact hi.le.trans hj
  ¬∑ rw [‚Üê iterate_pred_toZ i hi, ‚Üê iterate_pred_toZ j hj]
    refine' Monotone.antitone_iterate_of_map_le pred_mono (pred_le _) (Int.toNat_le_toNat _)
    exact neg_le_neg h_le","error:  typeclass instance problem is stuck, it is often due to metavariables
  OrderedAddCommGroup ?m.66541",theorem le_of_toZ_le {j : Œπ} (h_le : toZ i0 i ‚â§ toZ i0 j) : i ‚â§ j ,":= by
  rcases le_or_lt i0 i with hi | hi <;> rcases le_or_lt i0 j with hj | hj
  ¬∑ rw [‚Üê iterate_succ_toZ i hi, ‚Üê iterate_succ_toZ j hj]
    exact Monotone.monotone_iterate_of_le_map succ_mono (le_succ _) (Int.toNat_le_toNat h_le)
  ¬∑ exact absurd ((toZ_neg hj).trans_le (toZ_nonneg hi)) (not_lt.mpr h_le)
  ¬∑ exact hi.le.trans hj
  ¬∑ rw [‚Üê iterate_pred_toZ i hi, ‚Üê iterate_pred_toZ j hj]
    refine Monotone.antitone_iterate_of_map_le pred_mono (pred_le _) (Int.toNat_le_toNat ?_)
    exact Int.neg_le_neg h_le",":= by
  rcases le_or_lt i0 i with hi | hi <;> rcases le_or_lt i0 j with hj | hj
  ¬∑ rw [‚Üê iterate_succ_toZ i hi, ‚Üê iterate_succ_toZ j hj]
    exact Monotone.monotone_iterate_of_le_map succ_mono (le_succ _) (Int.toNat_le_toNat h_le)
  ¬∑ exact absurd ((toZ_neg hj).trans_le (toZ_nonneg hi)) (not_lt.mpr h_le)
  ¬∑ exact hi.le.trans hj
  ¬∑ rw [‚Üê iterate_pred_toZ i hi, ‚Üê iterate_pred_toZ j hj]
    refine Monotone.antitone_iterate_of_map_le pred_mono (pred_le _) (Int.toNat_le_toNat _)
    exact neg_le_neg h_le"
Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean,CategoryTheory.Limits.hasPushout_symmetry,hasPushout_symmetry,1a0bc1a77a6fdc0ca1a001a809a7fce122885a6f,":=
  ‚ü®‚ü®‚ü®PushoutCocone.mk _ _ pushout.condition.symm,
        PushoutCocone.flipIsColimit (pushoutIsPushout _ _)‚ü©‚ü©‚ü©","error:  application type mismatch
  PushoutCocone.flipIsColimit (pushoutIsPushout f g)
argument
  pushoutIsPushout f g
has type
  IsColimit (PushoutCocone.mk pushout.inl pushout.inr ‚ãØ) : Type (max u v)
but is expected to have type
  IsColimit (colimit.cocone (span f g)) : Type (max u v)",theorem hasPushout_symmetry [HasPushout f g] : HasPushout g f ,":=
  ‚ü®‚ü®‚ü®_, PushoutCocone.flipIsColimit (pushoutIsPushout f g)‚ü©‚ü©‚ü©",":=
  ‚ü®‚ü®‚ü®PushoutCocone.mk _ _ pushout.condition.symm,
        PushoutCocone.flipIsColimit (pushoutIsPushout _ _)‚ü©‚ü©‚ü©"
Mathlib/Topology/Perfect.lean,exists_perfect_nonempty_of_isClosed_of_not_countable,exists_perfect_nonempty_of_isClosed_of_not_countable,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with ‚ü®V, D, Vct, Dperf, VD‚ü©
  refine ‚ü®D, ‚ü®Dperf, ?_‚ü©‚ü©
  constructor
  ¬∑ rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right _ _","error:  function expected at
  subset_union_right ?m.8728
term has type
  ?m.8727 ‚àà ?m.8725 ‚à™ ?m.8726","theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology Œ±]
    (hclosed : IsClosed C) (hunc : ¬¨C.Countable) : ‚àÉ D : Set Œ±, Perfect D ‚àß D.Nonempty ‚àß D ‚äÜ C ",":= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with ‚ü®V, D, Vct, Dperf, VD‚ü©
  refine ‚ü®D, ‚ü®Dperf, ?_‚ü©‚ü©
  constructor
  ¬∑ rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right",":= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with ‚ü®V, D, Vct, Dperf, VD‚ü©
  refine ‚ü®D, ‚ü®Dperf, ?_‚ü©‚ü©
  constructor
  ¬∑ rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right"
Mathlib/Topology/Separation.lean,Dense.diff_finset,Dense.diff_finset,25e538f3a737a71314ac143929711e67d0b14d73,":= by
  induction t with
  | empty => simpa using hs
  | insert _ ih =>
    rw [Finset.coe_insert, ‚Üê union_singleton, ‚Üê diff_diff]
    exact ih.diff_singleton _",error:  invalid alternative name 'empty',"theorem Dense.diff_finset [T1Space X] [‚àÄ x : X, NeBot (ùìù[‚â†] x)] {s : Set X} (hs : Dense s)
    (t : Finset X) : Dense (s \ t) ",":= by
  induction t using Finset.induction_on with
  | empty => simpa using hs
  | insert _ ih =>
    rw [Finset.coe_insert, ‚Üê union_singleton, ‚Üê diff_diff]
    exact ih.diff_singleton _",":= by
  induction t using Finset.induction with
  | empty => simpa using hs
  | insert _ ih =>
    rw [Finset.coe_insert, ‚Üê union_singleton, ‚Üê diff_diff]
    exact ih.diff_singleton _"
Mathlib/RingTheory/Ideal/Quotient.lean,Ideal.Quotient.maximal_ideal_iff_isField_quotient,maximal_ideal_iff_isField_quotient,78a827f8ad68a8983cd158fe2eb6dd86ed8c4965,":=
  ‚ü®fun h =>
    letI := @quotient.field _ _ I h
    Field.toIsField _,
    maximal_of_isField _‚ü©","error:  unknown identifier 'quotient.field'
error:  type mismatch
  Field.toIsField (R ‚ß∏ I)
has type
  @IsField (R ‚ß∏ I) DivisionSemiring.toSemiring : Prop
but is expected to have type
  @IsField (R ‚ß∏ I) CommSemiring.toSemiring : Prop
error:  failed to synthesize
  Field (R ‚ß∏ I)
use `set_option diagnostics true` to get diagnostic information",theorem maximal_ideal_iff_isField_quotient (I : Ideal R) : I.IsMaximal ‚Üî IsField (R ‚ß∏ I) ,":=
  ‚ü®fun h =>
    let _i := @Quotient.field _ _ I h
    Field.toIsField _,
    maximal_of_isField _‚ü©",":=
  ‚ü®fun h =>
    @quotient.field _ _ I h
    Field.toIsField _,
    maximal_of_isField _‚ü©"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.null_of_frequently_le_of_frequently_ge,null_of_frequently_le_of_frequently_ge,9d3887769246754772c178dd6c594378dce58448,":= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ‚ü®o, xo, o_open, Œºo‚ü© : ‚àÉ o : Set Œ±, x ‚àà o ‚àß IsOpen o ‚àß Œº o < ‚àû :=
    Measure.exists_isOpen_measure_lt_top Œº x
  refine' ‚ü®s ‚à© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), _‚ü©
  let s' := s ‚à© o
  by_contra h
  apply lt_irrefl (œÅ s')
  calc
    œÅ s' ‚â§ c * Œº s' := v.measure_le_of_frequently_le (c ‚Ä¢ Œº) hœÅ s' fun x hx => hc x hx.1
    _ < d * Œº s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono (inter_subset_right _ _)) Œºo).ne
    _ ‚â§ œÅ s' :=
      v.measure_le_of_frequently_le œÅ ((Measure.AbsolutelyContinuous.refl Œº).smul d) s' fun x hx =>
        hd x hx.1","error:  function expected at
  inter_subset_right ?m.58097
term has type
  ?m.58096 ‚àà ?m.58095","theorem null_of_frequently_le_of_frequently_ge {c d : ‚Ñù‚â•0} (hcd : c < d) (s : Set Œ±)
    (hc : ‚àÄ x ‚àà s, ‚àÉ·∂† a in v.filterAt x, œÅ a ‚â§ c * Œº a)
    (hd : ‚àÄ x ‚àà s, ‚àÉ·∂† a in v.filterAt x, (d : ‚Ñù‚â•0‚àû) * Œº a ‚â§ œÅ a) : Œº s = 0 ",":= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ‚ü®o, xo, o_open, Œºo‚ü© : ‚àÉ o : Set Œ±, x ‚àà o ‚àß IsOpen o ‚àß Œº o < ‚àû :=
    Measure.exists_isOpen_measure_lt_top Œº x
  refine ‚ü®s ‚à© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_‚ü©
  let s' := s ‚à© o
  by_contra h
  apply lt_irrefl (œÅ s')
  calc
    œÅ s' ‚â§ c * Œº s' := v.measure_le_of_frequently_le (c ‚Ä¢ Œº) hœÅ s' fun x hx => hc x hx.1
    _ < d * Œº s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono inter_subset_right) Œºo).ne
    _ ‚â§ œÅ s' :=
      v.measure_le_of_frequently_le œÅ ((Measure.AbsolutelyContinuous.refl Œº).smul d) s' fun x hx =>
        hd x hx.1",":= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ‚ü®o, xo, o_open, Œºo‚ü© : ‚àÉ o : Set Œ±, x ‚àà o ‚àß IsOpen o ‚àß Œº o < ‚àû :=
    Measure.exists_isOpen_measure_lt_top Œº x
  refine ‚ü®s ‚à© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_‚ü©
  let s' := s ‚à© o
  by_contra h
  apply lt_irrefl (œÅ s')
  calc
    œÅ s' ‚â§ c * Œº s' := v.measure_le_of_frequently_le (c ‚Ä¢ Œº) hœÅ s' fun x hx => hc x hx.1
    _ < d * Œº s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt inter_subset_right) Œºo).ne
    _ ‚â§ œÅ s' :=
      v.measure_le_of_frequently_le œÅ ((Measure.AbsolutelyContinuous.refl Œº).smul d) s' fun x hx =>
        hd x hx.1"
Mathlib/Data/Finset/Lattice.lean,Finset.sup_sdiff_left,sup_sdiff_left,dee5d9343d596781e8ec7749927ce52e2d12df27,":= by
  induction s using Finset.cons_induction with
  | empty => rw [sup_empty, inf_empty, sdiff_top]
  | cons _ h => rw [sup_cons, inf_cons, h, sdiff_inf]","error:  tactic 'rewrite' failed, equality or iff proof expected
  Finset Œπ
case cons
F : Type u_1
Œ± : Type u_2
Œ≤ : Type u_3
Œ≥ : Type u_4
Œπ : Type u_5
Œ∫ : Type u_6
inst‚úù : BooleanAlgebra Œ±
s : Finset Œπ
f : Œπ ‚Üí Œ±
a : Œ±
a‚úù¬π : Œπ
h : Finset Œπ
h‚úù : a‚úù¬π ‚àâ h
a‚úù : (h.sup fun b ‚Ü¶ a \ f b) = a \ h.inf f
‚ä¢ (a \ f a‚úù¬π ‚äî h.sup fun b ‚Ü¶ a \ f b) = a \ (f a‚úù¬π ‚äì h.inf f)","theorem sup_sdiff_left (s : Finset Œπ) (f : Œπ ‚Üí Œ±) (a : Œ±) :
    (s.sup fun b => a \ f b) = a \ s.inf f ",":= by
  induction s using Finset.cons_induction with
  | empty => rw [sup_empty, inf_empty, sdiff_top]
  | cons _ _ _ h => rw [sup_cons, inf_cons, h, sdiff_inf]",":= by
  induction s using Finset.cons_induction with
  | empty => rw [sup_empty, inf_empty, sdiff_top]
  | cons _ h => rw [sup_cons, inf_cons, h, sdiff_inf]"
Mathlib/Analysis/NormedSpace/QuaternionExponential.lean,Quaternion.hasSum_expSeries_of_imaginary,hasSum_expSeries_of_imaginary,712f1941e008d38cffb7dc9c0396cb5024253869,":= by
  replace hc := hasSum_coe.mpr hc
  replace hs := (hs.div_const ‚Äñq‚Äñ).smul_const q
  obtain rfl | hq0 := eq_or_ne q 0
  ¬∑ simp_rw [expSeries_apply_zero, norm_zero, div_zero, zero_smul, add_zero]
    simp_rw [norm_zero] at hc
    convert hc using 1
    ext (_ | n) : 1
    ¬∑ rw [pow_zero, Nat.zero_eq, mul_zero, pow_zero, Nat.factorial_zero, Nat.cast_one,
        div_one, one_mul, Pi.single_eq_same, coe_one]
    ¬∑ rw [zero_pow (mul_pos two_pos (Nat.succ_pos _)), mul_zero, zero_div,
        Pi.single_eq_of_ne n.succ_ne_zero, coe_zero]
  simp_rw [expSeries_apply_eq]
  have hq2 : q ^ 2 = -normSq q := sq_eq_neg_normSq.mpr hq
  have hqn := norm_ne_zero_iff.mpr hq0
  refine' HasSum.even_add_odd _ _
  ¬∑ convert hc using 1
    ext n : 1
    letI k : ‚Ñù := ‚Üë(2 * n)!
    calc
      k‚Åª¬π ‚Ä¢ q ^ (2 * n) = k‚Åª¬π ‚Ä¢ (-normSq q) ^ n := by rw [pow_mul, hq2]
      _ = k‚Åª¬π ‚Ä¢ ‚Üë((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n)) := ?_
      _ = ‚Üë((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n) / k) := ?_
    ¬∑ congr 1
      rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq]
      push_cast
      rfl
    ¬∑ rw [‚Üê coe_mul_eq_smul, div_eq_mul_inv]
      norm_cast
      ring_nf
  ¬∑ convert hs using 1
    ext n : 1
    let k : ‚Ñù := ‚Üë(2 * n + 1)!
    calc
      k‚Åª¬π ‚Ä¢ q ^ (2 * n + 1) = k‚Åª¬π ‚Ä¢ ((-normSq q) ^ n * q) := by
        rw [pow_succ', pow_mul, hq2]
      _ = k‚Åª¬π ‚Ä¢ ((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n)) ‚Ä¢ q := ?_
      _ = ((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n + 1) / k / ‚Äñq‚Äñ) ‚Ä¢ q := ?_
    ¬∑ congr 1
      rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq, ‚Üê coe_mul_eq_smul]
      norm_cast
    ¬∑ rw [smul_smul]
      congr 1
      simp_rw [pow_succ', mul_div_assoc, div_div_cancel_left' hqn]
      ring","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case h.e'_5.h.zero
c s : ‚Ñù
hq : re 0 = 0
hs : HasSum (fun z ‚Ü¶ ((-1) ^ z * ‚Äñ0‚Äñ ^ (2 * z + 1) / ‚Üë(2 * z + 1)! / ‚Äñ0‚Äñ) ‚Ä¢ 0) ((s / ‚Äñ0‚Äñ) ‚Ä¢ 0)
hc : HasSum (fun a ‚Ü¶ ‚Üë((-1) ^ a * 0 ^ (2 * a) / ‚Üë(2 * a)!)) ‚Üëc
‚ä¢ Pi.single 0 1 0 = ‚Üë(1 * 0 ^ (2 * 0) / ‚Üë(2 * 0)!)
error:  application type mismatch
  zero_pow (mul_pos ?m.39247 (Nat.succ_pos ?m.39364))
argument
  mul_pos ?m.39247 (Nat.succ_pos ?m.39364)
has type
  0 < ?m.36565 * ?m.39364.succ : Prop
but is expected to have type
  ?m.36562 ‚â† 0 : Prop
error:  unsolved goals
q : ‚Ñç
hq : q.re = 0
c s : ‚Ñù
hc : HasSum (fun a ‚Ü¶ ‚Üë((-1) ^ a * ‚Äñq‚Äñ ^ (2 * a) / ‚Üë(2 * a)!)) ‚Üëc
hs : HasSum (fun z ‚Ü¶ ((-1) ^ z * ‚Äñq‚Äñ ^ (2 * z + 1) / ‚Üë(2 * z + 1)! / ‚Äñq‚Äñ) ‚Ä¢ q) ((s / ‚Äñq‚Äñ) ‚Ä¢ q)
hq0 : q ‚â† 0
hq2 : q ^ 2 = -‚Üë(normSq q)
hqn : ‚Äñq‚Äñ ‚â† 0
n : ‚Ñï
k : ‚Ñù := ‚Üë(2 * n + 1)!
‚ä¢ k‚Åª¬π ‚Ä¢ (q * (-‚Üë(normSq q)) ^ n) = k‚Åª¬π ‚Ä¢ ((-‚Üë(normSq q)) ^ n * q)
error:  simp made no progress","theorem hasSum_expSeries_of_imaginary {q : Quaternion ‚Ñù} (hq : q.re = 0) {c s : ‚Ñù}
    (hc : HasSum (fun n => (-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n) / (2 * n)!) c)
    (hs : HasSum (fun n => (-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n + 1) / (2 * n + 1)!) s) :
    HasSum (fun n => expSeries ‚Ñù (Quaternion ‚Ñù) n fun _ => q) (‚Üëc + (s / ‚Äñq‚Äñ) ‚Ä¢ q) ",":= by
  replace hc := hasSum_coe.mpr hc
  replace hs := (hs.div_const ‚Äñq‚Äñ).smul_const q
  refine HasSum.even_add_odd ?_ ?_
  ¬∑ convert hc using 1
    ext n : 1
    rw [expSeries_even_of_imaginary hq]
  ¬∑ convert hs using 1
    ext n : 1
    rw [expSeries_odd_of_imaginary hq]",":= by
  replace hc := hasSum_coe.mpr hc
  replace hs := (hs.div_const ‚Äñq‚Äñ).smul_const q
  obtain rfl | hq0 := eq_or_ne q 0
  ¬∑ simp_rw [expSeries_apply_zero, norm_zero, div_zero, zero_smul, add_zero]
    simp_rw [norm_zero] at hc
    convert hc using 1
    ext (_ | n) : 1
    ¬∑ rw [pow_zero, Nat.zero_eq, mul_zero, pow_zero, Nat.factorial_zero, Nat.cast_one,
        div_one, one_mul, Pi.single_eq_same, coe_one]
    ¬∑ rw [zero_pow (mul_pos two_pos (Nat.succ_pos _)), mul_zero, zero_div,
        Pi.single_eq_of_ne n.succ_ne_zero, coe_zero]
  simp_rw [expSeries_apply_eq]
  have hq2 : q ^ 2 = -normSq q := sq_eq_neg_normSq.mpr hq
  have hqn := norm_ne_zero_iff.mpr hq0
  refine HasSum.even_add_odd ?_ ?_
  ¬∑ convert hc using 1
    ext n : 1
    letI k : ‚Ñù := ‚Üë(2 * n)!
    calc
      k‚Åª¬π ‚Ä¢ q ^ (2 * n) = k‚Åª¬π ‚Ä¢ (-normSq q) ^ n := by rw [pow_mul, hq2]
      _ = k‚Åª¬π ‚Ä¢ ‚Üë((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n)) := ?_
      _ = ‚Üë((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n) / k) := ?_
    ¬∑ congr 1
      rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq, ‚Üê coe_mul_eq_smul]
      norm_cast
    ¬∑ rw [smul_smul]
      congr 1
      simp_rw [pow_succ', mul_div_assoc, div_div_cancel_left' hqn]
      ring"
Mathlib/Data/Nat/Factorization/Basic.lean,Nat.factorization_pow,factorization_pow,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  induction' k with k ih; ¬∑ simp
  rcases eq_or_ne n 0 with (rfl | hn)
  ¬∑ simp
  rw [pow_succ, mul_comm, factorization_mul hn (pow_ne_zero _ hn), ih, succ_eq_one_add, add_smul,
   one_smul]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ.inr
a b m n‚úù p n k : ‚Ñï
ih : (n ^ k).factorization = k ‚Ä¢ n.factorization
hn : n ‚â† 0
‚ä¢ n.factorization + k ‚Ä¢ n.factorization = (k + 1) ‚Ä¢ n.factorization",theorem factorization_pow (n k : ‚Ñï) : factorization (n ^ k) = k ‚Ä¢ n.factorization ,":= by
  induction' k with k ih; ¬∑ simp
  rcases eq_or_ne n 0 with (rfl | hn)
  ¬∑ simp
  rw [Nat.pow_succ, mul_comm, factorization_mul hn (pow_ne_zero _ hn), ih,
    add_smul, one_smul, add_comm]",":= by
  induction' k with k ih; ¬∑ simp
  rcases eq_or_ne n 0 with (rfl | hn)
  ¬∑ simp
  rw [pow_succ, mul_comm, factorization_mul hn (pow_ne_zero _ hn), ih, succ_eq_one_add, add_smul,
    one_smul]"
Mathlib/GroupTheory/HNNExtension.lean,HNNExtension.NormalWord.unitsSMul_one_group_smul,unitsSMul_one_group_smul,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  unfold unitsSMul
  have : Cancels 1 ((g : G) ‚Ä¢ w) ‚Üî Cancels 1 w := by
    simp [Cancels, Subgroup.mul_mem_cancel_left]
  by_cases hcan : Cancels 1 w
  ¬∑ simp [unitsSMulWithCancel, dif_pos (this.2 hcan), dif_pos hcan]
    cases w using consRecOn
    ¬∑ simp [Cancels] at hcan
    ¬∑ simp only [smul_cons, consRecOn_cons, mul_smul]
      rw [‚Üê mul_smul, ‚Üê Subgroup.coe_mul, ‚Üê map_mul œÜ]
      rfl
  ¬∑ rw [dif_neg (mt this.1 hcan), dif_neg hcan]
    simp [‚Üê mul_smul, mul_assoc, unitsSMulGroup]
    dsimp
    congr 1
    ¬∑ conv_lhs => erw [IsComplement.equiv_mul_left]
      simp? says
        simp only [toSubgroup_one, SetLike.coe_sort_coe, map_mul, Submonoid.coe_mul,
          coe_toSubmonoid]
    conv_lhs => erw [IsComplement.equiv_mul_left]","error:  unsolved goals
case neg.e_w
G : Type u_1
inst‚úù¬≥ : Group G
A B : Subgroup G
œÜ : ‚Ü•A ‚âÉ* ‚Ü•B
H : Type u_2
inst‚úù¬≤ : Group H
M : Type u_3
inst‚úù¬π : Monoid M
d : TransversalPair G A B
inst‚úù : DecidableEq G
g : ‚Ü•A
w : NormalWord d
this : Cancels 1 (‚Üëg ‚Ä¢ w) ‚Üî Cancels 1 w
hcan : ¬¨Cancels 1 w
‚ä¢ (‚Üë(g * (‚ãØ.equiv w.head).1, (‚ãØ.equiv w.head).2).2 * w.head‚Åª¬π) ‚Ä¢ w = (‚Üë(‚ãØ.equiv w.head).2 * w.head‚Åª¬π) ‚Ä¢ w","theorem unitsSMul_one_group_smul (g : A) (w : NormalWord d) :
    unitsSMul œÜ 1 ((g : G) ‚Ä¢ w) = (œÜ g : G) ‚Ä¢ (unitsSMul œÜ 1 w) ",":= by
  unfold unitsSMul
  have : Cancels 1 ((g : G) ‚Ä¢ w) ‚Üî Cancels 1 w := by
    simp [Cancels, Subgroup.mul_mem_cancel_left]
  by_cases hcan : Cancels 1 w
  ¬∑ simp [unitsSMulWithCancel, dif_pos (this.2 hcan), dif_pos hcan]
    cases w using consRecOn
    ¬∑ simp [Cancels] at hcan
    ¬∑ simp only [smul_cons, consRecOn_cons, mul_smul]
      rw [‚Üê mul_smul, ‚Üê Subgroup.coe_mul, ‚Üê map_mul œÜ]
      rfl
  ¬∑ rw [dif_neg (mt this.1 hcan), dif_neg hcan]
    simp [‚Üê mul_smul, mul_assoc, unitsSMulGroup]
    dsimp
    congr 1
    ¬∑ conv_lhs => erw [IsComplement.equiv_mul_left]
      simp? says
        simp only [toSubgroup_one, SetLike.coe_sort_coe, map_mul, Submonoid.coe_mul,
          coe_toSubmonoid]
    conv_lhs => erw [IsComplement.equiv_mul_left]
    rfl",":= by
  unfold unitsSMul
  have : Cancels 1 ((g : G) ‚Ä¢ w) ‚Üî Cancels 1 w := by
    simp [Cancels, Subgroup.mul_mem_cancel_left]
  by_cases hcan : Cancels 1 w
  ¬∑ simp [unitsSMulWithCancel, dif_pos (this.2 hcan), dif_pos hcan]
    cases w using consRecOn
    ¬∑ simp [Cancels] at hcan
    ¬∑ simp only [smul_cons, consRecOn_cons, mul_smul]
      rw [‚Üê mul_smul, ‚Üê Subgroup.coe_mul, ‚Üê map_mul œÜ]
      rfl
  ¬∑ rw [dif_neg (mt this.1 hcan), dif_neg hcan]
    simp [‚Üê mul_smul, mul_assoc, unitsSMulGroup]
    dsimp
    congr 1
    ¬∑ conv_lhs => erw [IsComplement.equiv_mul_left]
      simp? says
        simp only [toSubgroup_one, SetLike.coe_sort_coe, map_mul, Submonoid.coe_mul,
          coe_toSubmonoid]
    conv_lhs => erw [IsComplement.equiv_mul_left]"
Mathlib/Topology/Order/ScottTopology.lean,Topology.IsScottHausdorff.dirSupInacc_of_isOpen,dirSupInacc_of_isOpen,8b0925372fa04d1a63cab2bd48d77259af9c5245,":=
  fun d _ hd‚ÇÅ hd‚ÇÇ a hda hd‚ÇÉ ‚Ü¶ by
    obtain ‚ü®b, hbd, hb‚ü© := isOpen_iff.1 h hd‚ÇÅ hd‚ÇÇ hda hd‚ÇÉ; exact ‚ü®b, hbd, hb ‚ü®le_rfl, hbd‚ü©‚ü©","error:  type mismatch
  fun d x hd‚ÇÅ hd‚ÇÇ a hda hd‚ÇÉ ‚Ü¶ ?m.25614 d x hd‚ÇÅ hd‚ÇÇ a hda hd‚ÇÉ
has type
  (d : Set Œ±) ‚Üí
    (x : d.Nonempty) ‚Üí
      (hd‚ÇÅ : DirectedOn (fun x x_1 ‚Ü¶ x ‚â§ x_1) d) ‚Üí
        (hd‚ÇÇ : Œ±) ‚Üí
          (a : IsLUB d hd‚ÇÇ) ‚Üí
            (hda : hd‚ÇÇ ‚àà s) ‚Üí
              (hd‚ÇÉ : ?m.25612 d x hd‚ÇÅ hd‚ÇÇ a hda) ‚Üí
                ?m.25613 d x hd‚ÇÅ hd‚ÇÇ a hda hd‚ÇÉ : Sort (imax (u_1 + 1) (u_1 + 1) ?u.25606 ?u.25609)
but is expected to have type
  DirSupInacc s : Prop
error:  application type mismatch
  isOpen_iff.mp h hd‚ÇÅ
argument
  hd‚ÇÅ
has type
  DirectedOn (fun x x_1 ‚Ü¶ x ‚â§ x_1) d : Prop
but is expected to have type
  ?m.26073.Nonempty : Prop
error:  tactic 'cases' failed, nested error:
tactic 'induction' failed, recursor 'Exists.casesOn' can only eliminate into Prop
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬≤ : Preorder Œ±
s‚úù : Set Œ±
inst‚úù¬π : TopologicalSpace Œ±
inst‚úù : IsScottHausdorff Œ±
s : Set Œ±
h : IsOpen s
d : Set Œ±
x‚úù¬π : d.Nonempty
hd‚ÇÅ : DirectedOn (fun x x_1 ‚Ü¶ x ‚â§ x_1) d
hd‚ÇÇ : Œ±
a : IsLUB d hd‚ÇÇ
hda : hd‚ÇÇ ‚àà s
hd‚ÇÉ : ?m.26566 d x‚úù¬π hd‚ÇÅ hd‚ÇÇ a hda ‚àà s
x‚úù : ‚àÉ b ‚àà ?m.26073, Ici b ‚à© ?m.26073 ‚äÜ s
‚ä¢ ?m.25613 d x‚úù¬π hd‚ÇÅ hd‚ÇÇ a hda hd‚ÇÉ
error:  application type mismatch
  Iff.intro (IsScottHausdorff.dirSupInacc_of_isOpen ?m.27862)
argument
  IsScottHausdorff.dirSupInacc_of_isOpen ?m.27862
has type
  DirSupInacc ?m.27861 : Prop
but is expected to have type
  IsOpen s ‚Üí DirSupInacc s : Prop",lemma dirSupInacc_of_isOpen (h : IsOpen s) : DirSupInacc s ,":=
  fun d hd‚ÇÅ hd‚ÇÇ a hda hd‚ÇÉ ‚Ü¶ by
    obtain ‚ü®b, hbd, hb‚ü© := isOpen_iff.1 h hd‚ÇÅ hd‚ÇÇ hda hd‚ÇÉ; exact ‚ü®b, hbd, hb ‚ü®le_rfl, hbd‚ü©‚ü©",":=
  fun d _ hd‚ÇÅ hd‚ÇÇ a hda hd‚ÇÉ ‚Ü¶ by
    obtain ‚ü®b, hbd, hb‚ü© := isOpen_iff.1 h hd‚ÇÅ hd‚ÇÇ hda hd‚ÇÉ; exact ‚ü®b, hbd, hb ‚ü®le_rfl, hbd‚ü©‚ü©"
Mathlib/Topology/Order/ScottTopology.lean,Topology.IsScott.isOpen_iff_isUpperSet_and_dirSupInacc,isOpen_iff_isUpperSet_and_dirSupInacc,9f6d33884de569540c527b667d1573e1b97e1347,":= by
  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open]
  refine and_congr_right fun h ‚Ü¶
    ‚ü®@IsScottHausdorff.dirSupInacc_of_isOpen _ _ scottHausdorff _ _, fun h' d d‚ÇÅ d‚ÇÇ _ d‚ÇÉ ha ‚Ü¶ ?_‚ü©
  obtain ‚ü®b, hbd, hbu‚ü© := h' d‚ÇÅ d‚ÇÇ d‚ÇÉ ha
  exact ‚ü®b, hbd, Subset.trans (inter_subset_left (Ici b) d) (h.Ici_subset hbu)‚ü©","error:  application type mismatch
  @IsScottHausdorff.dirSupInacc_of_isOpen ?m.27091 ?m.27092 scottHausdorff
argument
  scottHausdorff
has type
  (Œ± : Type ?u.27093) ‚Üí [inst : Preorder Œ±] ‚Üí TopologicalSpace Œ± : Type (?u.27093 + 1)
but is expected to have type
  TopologicalSpace ?m.27091 : Type ?u.27090
error:  application type mismatch
  inter_subset_left (Ici b)
argument
  Ici b
has type
  Set Œ± : Type u_1
but is expected to have type
  ?m.27950 ‚àà ?m.27948 ‚à© ?m.27949 : Prop",lemma isOpen_iff_isUpperSet_and_dirSupInacc : IsOpen s ‚Üî IsUpperSet s ‚àß DirSupInacc s ,":= by
  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open]
  refine and_congr_right fun h ‚Ü¶
    ‚ü®@IsScottHausdorff.dirSupInacc_of_isOpen _ _ (scottHausdorff Œ±) _ _,
      fun h' d d‚ÇÅ d‚ÇÇ _ d‚ÇÉ ha ‚Ü¶ ?_‚ü©
  obtain ‚ü®b, hbd, hbu‚ü© := h' d‚ÇÅ d‚ÇÇ d‚ÇÉ ha
  exact ‚ü®b, hbd, Subset.trans inter_subset_left (h.Ici_subset hbu)‚ü©",":= by
  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open]
  refine and_congr_right fun h ‚Ü¶
    ‚ü®@IsScottHausdorff.dirSupInacc_of_isOpen _ _ scottHausdorff _ _, fun h' d d‚ÇÅ d‚ÇÇ _ d‚ÇÉ ha ‚Ü¶ ?_‚ü©
  obtain ‚ü®b, hbd, hbu‚ü© := h' d‚ÇÅ d‚ÇÇ d‚ÇÉ ha
  exact ‚ü®b, hbd, Subset.trans inter_subset_left (Ici b) d) (h.Ici_subset hbu)‚ü©"
Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean,WeierstrassCurve.Projective.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,9059c6118913fb5f09fcfd016a01a0b1d4a0edc2,":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp [nonsingular_iff, equation_iff] at hP hQ
  simp [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]‚ü©","error:  application type mismatch
  div_mul_cancel ?m.251323 hQ
argument
  hQ
has type
  ¬¨Q 1 = 0 : Prop
but is expected to have type
  ?m.251321 : Type ?u.251320
error:  unsolved goals
R : Type u
inst‚úù¬π : CommRing R
W‚úù : Projective R
F : Type u
inst‚úù : Field F
W : Projective F
P Q : Fin 3 ‚Üí F
hPz : P 2 = 0
hQz : Q 2 = 0
hP : ¬¨P 1 = 0
hQ : ¬¨Q 1 = 0
‚ä¢ ![0, P 1 / Q 1 * Q 1, 0] = ![0, P 1, 0]","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp [nonsingular_iff, equation_iff] at hP hQ
  simp [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]‚ü©"
Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean,tprod_setProd_singleton_right,tprod_setProd_singleton_right,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [tprod_congr_set_coe _ Set.prod_singleton, tprod_image _ ((Prod.mk.inj_right c).injOn _)]","error:  application type mismatch
  tprod_image ?m.8074 (Injective.injOn (Prod.mk.inj_right c) ?m.8103)
argument
  Injective.injOn (Prod.mk.inj_right c) ?m.8103
has type
  ‚àÄ ‚¶Éx‚ÇÇ : ?m.8092‚¶Ñ, x‚ÇÇ ‚àà ?m.8101 ‚Üí (?m.8102, c) = (x‚ÇÇ, c) ‚Üí ?m.8102 = x‚ÇÇ : Prop
but is expected to have type
  Set.InjOn ?m.8073 ?m.8075 : Prop","lemma tprod_setProd_singleton_right (s : Set Œ≤) (c : Œ≥) (f : Œ≤ √ó Œ≥ ‚Üí Œ±) :
    (‚àè' x : s √óÀ¢ {c}, f x) = ‚àè' b : s, f (b, c) ",":= by
  rw [tprod_congr_set_coe _ Set.prod_singleton, tprod_image _ (Prod.mk.inj_right c).injOn]",":= by
  rw [tprod_congr_set_coe _ Set.prod_singleton, tprod_image _ ((Prod.mk.inj_right c).injOn)]"
Mathlib/Topology/Connected/Basic.lean,isPreconnected_iff_subset_of_disjoint,isPreconnected_iff_subset_of_disjoint,64b674911520c89d4467fb9e8410ab9d79e82064,":= by
  constructor <;> intro h
  ¬∑ intro u v hu hv hs huv
    specialize h u v hu hv hs
    contrapose! huv
    rw [‚Üê nonempty_iff_ne_empty]
    simp [not_subset] at huv
    rcases huv with ‚ü®‚ü®x, hxs, hxu‚ü©, ‚ü®y, hys, hyv‚ü©‚ü©
    have hxv : x ‚àà v := or_iff_not_imp_left.mp (hs hxs) hxu
    have hyu : y ‚àà u := or_iff_not_imp_right.mp (hs hys) hyv
    exact h ‚ü®y, hys, hyu‚ü© ‚ü®x, hxs, hxv‚ü©
  ¬∑ intro u v hu hv hs hsu hsv
    rw [nonempty_iff_ne_empty]
    intro H
    specialize h u v hu hv hs H
    contrapose H
    apply Nonempty.ne_empty
    cases' h with h h
    ¬∑ rcases hsv with ‚ü®x, hxs, hxv‚ü©
      exact ‚ü®x, hxs, ‚ü®h hxs, hxv‚ü©‚ü©
    ¬∑ rcases hsu with ‚ü®x, hxs, hxu‚ü©
      exact ‚ü®x, hxs, ‚ü®hxu, h hxs‚ü©‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.82811 ‚â† ‚àÖ
case mp
Œ± : Type u
Œ≤ : Type v
Œπ : Type u_1
œÄ : Œπ ‚Üí Type u_2
inst‚úù : TopologicalSpace Œ±
s‚úù t u‚úù v‚úù s u v : Set Œ±
hu : IsOpen u
hv : IsOpen v
hs : s ‚äÜ u ‚à™ v
h : (s ‚à© u).Nonempty ‚Üí (s ‚à© v).Nonempty ‚Üí (s ‚à© (u ‚à© v)).Nonempty
huv : ¬¨s ‚äÜ u ‚àß ¬¨s ‚äÜ v
‚ä¢ (s ‚à© (u ‚à© v)).Nonempty","theorem isPreconnected_iff_subset_of_disjoint {s : Set Œ±} :
    IsPreconnected s ‚Üî
      ‚àÄ u v, IsOpen u ‚Üí IsOpen v ‚Üí s ‚äÜ u ‚à™ v ‚Üí s ‚à© (u ‚à© v) = ‚àÖ ‚Üí s ‚äÜ u ‚à® s ‚äÜ v ",":= by
  constructor <;> intro h
  ¬∑ intro u v hu hv hs huv
    specialize h u v hu hv hs
    contrapose! huv
    simp [not_subset] at huv
    rcases huv with ‚ü®‚ü®x, hxs, hxu‚ü©, ‚ü®y, hys, hyv‚ü©‚ü©
    have hxv : x ‚àà v := or_iff_not_imp_left.mp (hs hxs) hxu
    have hyu : y ‚àà u := or_iff_not_imp_right.mp (hs hys) hyv
    exact h ‚ü®y, hys, hyu‚ü© ‚ü®x, hxs, hxv‚ü©
  ¬∑ intro u v hu hv hs hsu hsv
    by_contra H
    specialize h u v hu hv hs (Set.not_nonempty_iff_eq_empty.mp H)
    apply H
    cases' h with h h
    ¬∑ rcases hsv with ‚ü®x, hxs, hxv‚ü©
      exact ‚ü®x, hxs, ‚ü®h hxs, hxv‚ü©‚ü©
    ¬∑ rcases hsu with ‚ü®x, hxs, hxu‚ü©
      exact ‚ü®x, hxs, ‚ü®hxu, h hxs‚ü©‚ü©",":= by
  constructor <;> intro h
  ¬∑ intro u v hu hv hs huv
    specialize h u v hu hv hs
    contrapose! huv
    rw [‚Üê nonempty_iff_ne_empty]
    simp [not_subset] at huv
    rcases huv with ‚ü®‚ü®x, hxs, hxu‚ü©, ‚ü®y, hys, hyv‚ü©‚ü©
    have hxv : x ‚àà v := or_iff_not_imp_left.mp (hs hxs) hxu
    have hyu : y ‚àà u := or_iff_not_imp_right.mp (hs hys) hyv
    exact h ‚ü®y, hys, hyu‚ü© ‚ü®x, hxs, hxv‚ü©
  ¬∑ intro u v hu hv hs hsu hsv
    rw [nonempty_iff_ne_empty]
    intro H
    specialize h u v hu hv hs H
    contrapose H
    apply Nonempty.ne_empty
    cases' h with h h
    ¬∑ rcases hsv with ‚ü®x, hxs, hxv‚ü©
      exact ‚ü®x, hxs, ‚ü®h hxs, hxv‚ü©‚ü©
    ¬∑ rcases hsu with ‚ü®x, hxs, hxu‚ü©
      exact ‚ü®x, hxs, ‚ü®h hxs, hxv‚ü©‚ü©"
Mathlib/Algebra/Polynomial/Eval.lean,Polynomial.mul_X_comp,mul_X_comp,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction p with
  | h_add p q hp hq =>
    simp only [hp, hq, add_mul, add_comp]
  | h_monomial n b =>
    simp only [pow_succ, mul_assoc, monomial_mul_X, monomial_comp]","error:  invalid alternative name 'h_add'
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem mul_X_comp : (p * X).comp r = p.comp r * r ,":= by
  induction p using Polynomial.induction_on' with
  | h_add p q hp hq =>
    simp only [hp, hq, add_mul, add_comp]
  | h_monomial n b =>
    simp only [pow_succ, mul_assoc, monomial_mul_X, monomial_comp]",":= by
  induction p using Polynomial.induction_on'"
Mathlib/Order/OrderIsoNat.lean,RelEmbedding.acc_iff_no_decreasing_seq,acc_iff_no_decreasing_seq,518c1e170f81dd769be38262c88a0aef65109d9f,":= by
  constructor
  ¬∑ refine' fun h => h.recOn fun x _ IH => _
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    choose f h using this
    refine' fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => _, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h",error:  unknown identifier 'lt_add_one',"theorem acc_iff_no_decreasing_seq {x} :
    Acc r x ‚Üî IsEmpty { f : ((¬∑ > ¬∑) : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop) ‚Ü™r r // x ‚àà Set.range f } ",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (Nat.lt_succ_self _))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    choose f h using this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, ?_, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    choose f h using this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h"
Mathlib/Analysis/Convex/Mul.lean,convexOn_zpow,convexOn_zpow,8a7d6ba3b03c4b2062f1ce69fca7b9125c7bc032,"  | (n : ‚Ñï) => by
    simp_rw [zpow_ofNat]
    exact (convexOn_pow n).subset Ioi_subset_Ici_self (convex_Ioi _)
  | -[n+1] => by
    simp_rw [zpow_negSucc, ‚Üê inv_pow]
    refine (convexOn_iff_forall_pos.2 ‚ü®convex_Ioi _, ?_‚ü©).pow (fun x (hx : 0 < x) ‚Ü¶ by positivity) _
    rintro x (hx : 0 < x) y (hy : 0 < y) a b ha hb hab
    field_simp
    rw [div_le_div_iff, ‚Üê sub_nonneg]
    calc
      0 ‚â§ a * b * (x - y) ^ 2 := by positivity
      _ = _ := by obtain rfl := eq_sub_of_add_eq hab; ring
    all_goals positivity",error:  simp made no progress,"lemma convexOn_zpow : ‚àÄ n : ‚Ñ§, ConvexOn ùïú (Ioi 0) fun x : ùïú ‚Ü¶ x ^ n
","  | (n : ‚Ñï) => by
    simp_rw [zpow_natCast]
    exact (convexOn_pow n).subset Ioi_subset_Ici_self (convex_Ioi _)
  | -[n+1] => by
    simp_rw [zpow_negSucc, ‚Üê inv_pow]
    refine (convexOn_iff_forall_pos.2 ‚ü®convex_Ioi _, ?_‚ü©).pow (fun x (hx : 0 < x) ‚Ü¶ by positivity) _
    rintro x (hx : 0 < x) y (hy : 0 < y) a b ha hb hab
    field_simp
    rw [div_le_div_iff, ‚Üê sub_nonneg]
    ¬∑ calc
        0 ‚â§ a * b * (x - y) ^ 2 := by positivity
        _ = _ := by obtain rfl := eq_sub_of_add_eq hab; ring
    all_goals positivity",":= by
  | (n : ‚Ñï) => by
    simp_rw [zpow_ofNat]
    exact (convexOn_pow n).subset Ioi_subset_Ici_self (convex_Ioi _)
  | -[n+1] => by
    simp_rw [zpow_negSucc, ‚Üê inv_pow]
    refine (convexOn_iff_forall_pos.2 ‚ü®convex_Ioi _, ?_‚ü©).pow (fun x (hx : 0 < x) ‚Ü¶ by positivity) ?_
    rintro x (hx : 0 < x) y (hy : 0 < y) a b ha hb hab
    field_simp
    rw [div_le_div_iff, ‚Üê sub_nonneg]
    calc
      0 ‚â§ a * b * (x - y) ^ 2 := by positivity
      _ = _ := by obtain rfl := eq_sub_of_add_eq hab; ring
    all_goals positivity"
Mathlib/Data/Set/Prod.lean,Set.diagonal_nonempty,diagonal_nonempty,6c01dc6e338875d28ad701a2b39f6d55e774b7d9,:=,error:  unexpected token 'instance'; expected term,lemma diagonal_nonempty [Nonempty Œ±] : (diagonal Œ±).Nonempty ,":=
  Nonempty.elim ‚Äπ_‚Ä∫ fun x => ‚ü®_, mem_diagonal x‚ü©",":=
  diagonal_nonempty"
Mathlib/FieldTheory/Extension.lean,IntermediateField.exists_algHom_adjoin_of_splits_of_aeval,exists_algHom_adjoin_of_splits_of_aeval,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have ix := isAlgebraic_adjoin (fun s hs ‚Ü¶ (hK s hs).1) ‚ü®x, hx‚ü©
  rw [isAlgebraic_iff_isIntegral, isIntegral_iff] at ix
  obtain ‚ü®œÜ, hœÜ‚ü© := exists_algHom_adjoin_of_splits hK ((algHomAdjoinIntegralEquiv F ix).symm
    ‚ü®y, mem_aroots.mpr ‚ü®minpoly.ne_zero ix, hy‚ü©‚ü©) (adjoin_simple_le_iff.mpr hx)
  exact ‚ü®œÜ, (DFunLike.congr_fun hœÜ <| AdjoinSimple.gen F x).trans <|
    algHomAdjoinIntegralEquiv_symm_apply_gen F ix _‚ü©","error:  function expected at
  isAlgebraic_adjoin fun s hs ‚Ü¶ (hK s hs).left
term has type
  Algebra.IsAlgebraic F ‚Ü•(adjoin F S)
error:  unsolved goals
F : Type u_1
E : Type u_2
K : Type u_3
inst‚úù‚Å¥ : Field F
inst‚úù¬≥ : Field E
inst‚úù¬≤ : Field K
inst‚úù¬π : Algebra F E
inst‚úù : Algebra F K
S : Set E
hK : ‚àÄ s ‚àà S, IsIntegral F s ‚àß Splits (algebraMap F K) (minpoly F s)
hK' : ‚àÄ (s : E), IsIntegral F s ‚àß Splits (algebraMap F K) (minpoly F s)
L : IntermediateField F E
f : ‚Ü•L ‚Üí‚Çê[F] K
hL : L ‚â§ adjoin F S
hS : adjoin F S = ‚ä§
x : E
hx : x ‚àà adjoin F S
y : K
hy : (aeval y) (minpoly F x) = 0
‚ä¢ ‚àÉ œÜ, œÜ ‚ü®x, hx‚ü© = y
error:  application type mismatch
  @exists_algHom_adjoin_of_splits_of_aeval ?m.118616 ?m.118617 ?m.118618 ?m.118619 ?m.118620 ?m.118621 ?m.118622
    ?m.118623 ?m.118624 ?m.118625 hK
argument
  hK
has type
  ‚àÄ s ‚àà S, IsIntegral F s ‚àß Splits (algebraMap F K) (minpoly F s) : Prop
but is expected to have type
  ?m.118625 ‚àà adjoin ?m.118616 ?m.118624 : Prop
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  ?m.119148
error:  function expected at
  exists_algHom_of_adjoin_splits_of_aeval
term has type
  ‚àÉ œÜ, œÜ ?m.127678 = ?m.127679
error:  function expected at
  IntermediateField.exists_algHom_of_splits_of_aeval
term has type
  ‚àÉ œÜ, œÜ ?m.132867 = ?m.132868","theorem exists_algHom_adjoin_of_splits_of_aeval : ‚àÉ œÜ : adjoin F S ‚Üí‚Çê[F] K, œÜ ‚ü®x, hx‚ü© = y ",":= by
  have := isAlgebraic_adjoin (fun s hs ‚Ü¶ (hK s hs).1)
  have ix : IsAlgebraic F _ := Algebra.IsAlgebraic.isAlgebraic (‚ü®x, hx‚ü© : adjoin F S)
  rw [isAlgebraic_iff_isIntegral, isIntegral_iff] at ix
  obtain ‚ü®œÜ, hœÜ‚ü© := exists_algHom_adjoin_of_splits hK ((algHomAdjoinIntegralEquiv F ix).symm
    ‚ü®y, mem_aroots.mpr ‚ü®minpoly.ne_zero ix, hy‚ü©‚ü©) (adjoin_simple_le_iff.mpr hx)
  exact ‚ü®œÜ, (DFunLike.congr_fun hœÜ <| AdjoinSimple.gen F x).trans <|
    algHomAdjoinIntegralEquiv_symm_apply_gen F ix _‚ü©",":= by
  have ix := isAlgebraic_adjoin (fun s hs ‚Ü¶ (hK s hs).1) ‚ü®x, hx‚ü©
  rw [isAlgebraic_iff_isIntegral] at ix
  obtain ‚ü®œÜ, hœÜ‚ü© := exists_algHom_adjoin_of_splits hK ((algHomAdjoinIntegralEquiv F ix).symm
    ‚ü®y, mem_aroots.mpr ‚ü®minpoly.ne_zero ix, hy‚ü©‚ü©) (adjoin_simple_le_iff.mpr hx)
  exact ‚ü®œÜ, (DFunLike.congr_fun hœÜ <| AdjoinSimple.gen F x).trans <|
    algHomAdjoinIntegralEquiv_symm_apply_gen F ix _‚ü©"
Mathlib/Topology/Separation.lean,loc_compact_Haus_tot_disc_of_zero_dim,loc_compact_Haus_tot_disc_of_zero_dim,8ffb78dfb7ae6d7a715b2782ac93ea174198224b,":= by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.2) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := s ‚Üì‚à© interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, VisClopen, Vx, V_sub‚ü© := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine' ‚ü®comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.1, _‚ü©
    let v : Set u := u ‚Üì‚à© V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine' ‚ü®f0, _‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_right interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.2.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_right V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  refine' ‚ü®(‚Üë) '' V, VisClopen', by simp [Vx], Subset.trans _ sU‚ü©
  simp","error:  type mismatch
  s
has type
  Set H : Type u_3
but is expected to have type
  Set ‚Üës : Type u_3
error:  unsolved goals
case intro.intro.intro
X : Type u_1
Y : Type u_2
inst‚úù‚Å¥ : TopologicalSpace X
H : Type u_3
inst‚úù¬≥ : TopologicalSpace H
inst‚úù¬≤ : LocallyCompactSpace H
inst‚úù¬π : T2Space H
inst‚úù : TotallyDisconnectedSpace H
x : H
U : Set H
memU : x ‚àà U
hU : IsOpen U
s : Set H
comp : IsCompact s
xs : x ‚àà interior s
sU : s ‚äÜ U
u : Set ‚Üës := sorryAx (Set ‚Üës) true
‚ä¢ ‚àÉ v ‚àà {s | IsClopen s}, x ‚àà v ‚àß v ‚äÜ U
error:  unexpected token '‚Üì'; expected command","theorem loc_compact_Haus_tot_disc_of_zero_dim [TotallyDisconnectedSpace H] :
    IsTopologicalBasis { s : Set H | IsClopen s } ",":= by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.2) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := ((‚Üë) : s ‚Üí H) ‚Åª¬π' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, VisClopen, Vx, V_sub‚ü© := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine ‚ü®comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.1, ?_‚ü©
    let v : Set u := ((‚Üë) : u ‚Üí s) ‚Åª¬π' V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine ‚ü®f0, ?_‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_right interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.2.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_right V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  use (‚Üë) '' V, VisClopen', by simp [Vx], Subset.trans (by simp) sU",":= by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.2) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := s ‚Üì‚à© interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, VisClopen, Vx, V_sub‚ü© := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine ‚ü®comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.1, ?_‚ü©
    let v : Set u := u ‚Üì‚à© V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine ‚ü®f0, ?_‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_right interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.2.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_right V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  refine ‚ü®(‚Üë) '' V, VisClopen', by simp [Vx], Subset.trans ?_ sU‚ü©
  simp"
Mathlib/Algebra/BigOperators/Ring/Multiset.lean,Multiset.prod_map_add,prod_map_add,662209fa40f2c766f473b22b0726a9cfef63b01f,":= by
  refine s.induction_on ?_ fun a s ih ‚Ü¶ ?_
  ¬∑ simp only [map_zero, prod_zero, antidiagonal_zero, map_singleton, mul_one, sum_singleton]
  ¬∑ simp only [map_cons, prod_cons, ih, sum_map_mul_left.symm, add_mul, mul_left_comm (f a),
      mul_left_comm (g a), sum_map_add, antidiagonal_cons, Prod.map_apply_fst, Prod.map_apply_snd,
      id_eq, map_add, map_map, Function.comp_apply, mul_assoc, sum_add]
    exact add_comm _ _","error:  unknown constant 'Prod.map_apply_fst'
error:  unknown constant 'Prod.map_apply_snd'
error:  type mismatch
  add_comm (map (fun i ‚Ü¶ (map f i.1).prod * (f a * (map g i.2).prod)) s.antidiagonal).sum
    (map (fun i ‚Ü¶ (map f i.1).prod * (g a * (map g i.2).prod)) s.antidiagonal).sum
has type
  (map (fun i ‚Ü¶ (map f i.1).prod * (f a * (map g i.2).prod)) s.antidiagonal).sum +
      (map (fun i ‚Ü¶ (map f i.1).prod * (g a * (map g i.2).prod)) s.antidiagonal).sum =
    (map (fun i ‚Ü¶ (map f i.1).prod * (g a * (map g i.2).prod)) s.antidiagonal).sum +
      (map (fun i ‚Ü¶ (map f i.1).prod * (f a * (map g i.2).prod)) s.antidiagonal).sum : Prop
but is expected to have type
  (map (fun i ‚Ü¶ (map f i.1).prod * (f a * (map g i.2).prod)) s.antidiagonal).sum +
      (map (fun i ‚Ü¶ (map f i.1).prod * (g a * (map g i.2).prod)) s.antidiagonal).sum =
    (map (fun x ‚Ü¶ (map f (Prod.map id (cons a) x).1).prod * (map g (Prod.map id (cons a) x).2).prod)
          s.antidiagonal).sum +
      (map (fun x ‚Ü¶ (map f (Prod.map (cons a) id x).1).prod * (map g (Prod.map (cons a) id x).2).prod)
          s.antidiagonal).sum : Prop","lemma prod_map_add {s : Multiset Œπ} {f g : Œπ ‚Üí Œ±} :
    prod (s.map fun i ‚Ü¶ f i + g i) =
      sum ((antidiagonal s).map fun p ‚Ü¶ (p.1.map f).prod * (p.2.map g).prod) ",":= by
  refine s.induction_on ?_ fun a s ih ‚Ü¶ ?_
  ¬∑ simp only [map_zero, prod_zero, antidiagonal_zero, map_singleton, mul_one, sum_singleton]
  ¬∑ simp only [map_cons, prod_cons, ih, sum_map_mul_left.symm, add_mul, mul_left_comm (f a),
      mul_left_comm (g a), sum_map_add, antidiagonal_cons, Prod.map_fst, Prod.map_snd,
      id_eq, map_add, map_map, Function.comp_apply, mul_assoc, sum_add]
    exact add_comm _ _",":= by
  refine s.induction_on ?_ fun a s ih ‚Ü¶ ?_
  ¬∑ simp only [map_zero, prod_zero, map_singleton, mul_one, sum_singleton]
  ¬∑ simp only [map_cons, prod_cons, ih, sum_map_mul_left.symm, add_mul, mul_left_comm (f a),
      mul_left_comm (g a), sum_map_add, antidiagonal_cons, Prod.map_apply_fst, Prod.map_apply_snd,
      id_eq, map_add, map_map, Function.comp_apply, mul_assoc, sum_add]
    exact add_comm _ _"
Mathlib/LinearAlgebra/FiniteDimensional.lean,Submodule.eq_top_of_finrank_eq,_root_.Submodule.eq_top_of_finrank_eq,e27501749727a36b2d6cda6d1c3eddca7a541f68,":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V).incl :=
    @LinearIndependent.image_subtype _ _ _ _ _ _ _ _ _ (Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent (by simpa using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Set.range_restrict, Set.image_id, ‚Üê this,
    ‚ÜêSubmodule.coeSubtype, span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Set.range_restrict, Set.image_id] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]","error:  invalid field 'incl', the environment does not contain 'Set.incl'
  ?m.77824 '' Basis.ofVectorSpaceIndex K ‚Ü•S
has type
  Set V
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  ?m.77824 '' Basis.ofVectorSpaceIndex K ‚Ü•S
has type
  V ‚Üí Prop
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information","theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ‚ä§ ",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V).incl :=
    @LinearIndependent.image_subtype _ _ _ _ _ _ _ _ (Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
             finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Set.range_restrict, Set.image_id, ‚Üê this,
    ‚ÜêSubmodule.coeSubtype, span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Set.range_restrict, Set.image_id] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.exists_iso_binaryBiproduct_of_distTriang,exists_iso_binaryBiproduct_of_distTriang,eb4e7cb40c973c5fbf11d3373bd0829447b7de8a,":= by
  have := T.epi‚ÇÇ hT zero
  have := isSplitEpi_of_epi T.mor‚ÇÇ
  obtain ‚ü®fst, hfst‚ü© := T.coyoneda_exact‚ÇÇ hT (ùüô T.obj‚ÇÇ - T.mor‚ÇÇ ‚â´ section_ T.mor‚ÇÇ) (by simp)
  let d := binaryBiproductData _ hT zero (section_ T.mor‚ÇÇ) (by simp) fst
    (by simp only [‚Üê hfst, sub_add_cancel])
  refine' ‚ü®biprod.uniqueUpToIso _ _ d.isBilimit, ‚ü®_, by simp‚ü©‚ü©
  ext
  ¬∑ simpa using d.bicone.inl_fst
  ¬∑ simpa using d.bicone.inl_snd","error:  unsolved goals
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T ‚àà distinguishedTriangles
zero : T.mor‚ÇÉ = 0
this‚úù : Epi T.mor‚ÇÇ
this : IsSplitEpi T.mor‚ÇÇ
fst : T.obj‚ÇÇ ‚ü∂ T.obj‚ÇÅ
hfst : ùüô T.obj‚ÇÇ - T.mor‚ÇÇ ‚â´ section_ T.mor‚ÇÇ = fst ‚â´ T.mor‚ÇÅ
d : BinaryBiproductData T.obj‚ÇÅ T.obj‚ÇÉ := binaryBiproductData T hT zero (section_ T.mor‚ÇÇ) ‚ãØ fst ‚ãØ
‚ä¢ T.mor‚ÇÇ = d.bicone.snd
error:  type mismatch
  h‚úù
has type
  True : Prop
but is expected to have type
  T.mor‚ÇÅ ‚â´ d.bicone.fst = ùüô T.obj‚ÇÅ : Prop
error:  type mismatch
  h‚úù
has type
  True : Prop
but is expected to have type
  T.mor‚ÇÅ ‚â´ d.bicone.snd = 0 : Prop","lemma exists_iso_binaryBiproduct_of_distTriang (T : Triangle C) (hT : T ‚àà distTriang C)
    (zero : T.mor‚ÇÉ = 0) :
    ‚àÉ (e : T.obj‚ÇÇ ‚âÖ T.obj‚ÇÅ ‚äû T.obj‚ÇÉ), T.mor‚ÇÅ ‚â´ e.hom = biprod.inl ‚àß
      T.mor‚ÇÇ = e.hom ‚â´ biprod.snd ",":= by
  have := T.epi‚ÇÇ hT zero
  have := isSplitEpi_of_epi T.mor‚ÇÇ
  obtain ‚ü®fst, hfst‚ü© := T.coyoneda_exact‚ÇÇ hT (ùüô T.obj‚ÇÇ - T.mor‚ÇÇ ‚â´ section_ T.mor‚ÇÇ) (by simp)
  let d := binaryBiproductData _ hT zero (section_ T.mor‚ÇÇ) (by simp) fst
    (by simp only [‚Üê hfst, sub_add_cancel])
  refine ‚ü®biprod.uniqueUpToIso _ _ d.isBilimit, ‚ü®?_, by simp [d]‚ü©‚ü©
  ext
  ¬∑ simpa [d] using d.bicone.inl_fst
  ¬∑ simpa [d] using d.bicone.inl_snd",":= by
  have := T.epi‚ÇÇ hT zero
  have := isSplitEpi_of_epi T.mor‚ÇÇ
  obtain ‚ü®fst, hfst‚ü© := T.coyoneda_exact‚ÇÇ hT (ùüô T.obj‚ÇÇ - T.mor‚ÇÇ ‚â´ section_ T.mor‚ÇÇ) (by simp)
  let d := binaryBiproductData _ hT zero (section_ T.mor‚ÇÇ) (by simp) fst
    (by simp only [‚Üê hfst, sub_add_cancel])
  refine ‚ü®biprod.uniqueUpToIso _ _ d.isBilimit, ‚ü®?_, by simp‚ü©‚ü©
  ext
  ¬∑ simpa using d.bicone.inl_fst
  ¬∑ simpa using d.bicone.inl_snd"
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [‚Üê coe_comp, D.w] 
      rfl",error:  invalid alternative name 'empty',"theorem isTopologicalBasis_cofiltered_limit (T : ‚àÄ j, Set (Set (F.obj j)))
    (hT : ‚àÄ j, IsTopologicalBasis (T j)) (univ : ‚àÄ i : J, Set.univ ‚àà T i)
    (inter : ‚àÄ (i) (U1 U2 : Set (F.obj i)), U1 ‚àà T i ‚Üí U2 ‚àà T i ‚Üí U1 ‚à© U2 ‚àà T i)
    (compat : ‚àÄ (i j : J) (f : i ‚ü∂ j) (V : Set (F.obj j)) (_hV : V ‚àà T j), F.map f ‚Åª¬π' V ‚àà T i) :
    IsTopologicalBasis
      {U : Set C.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = C.œÄ.app j ‚Åª¬π' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [‚Üê coe_comp, D.w] 
      rfl",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ _ (univ _) (inte"
Mathlib/Analysis/NormedSpace/Star/Spectrum.lean,IsSelfAdjoint.mem_spectrum_eq_re,IsSelfAdjoint.mem_spectrum_eq_re,4c88fd56518cfb6778da87e9cffbf49cba130bef,":= by
  letI : Algebra ‚Ñö A := RestrictScalars.algebra ‚Ñö ‚ÑÇ A
  have hu := exp_mem_unitary_of_mem_skewAdjoint ‚ÑÇ (ha.smul_mem_skewAdjoint conj_I)
  let Iu := Units.mk0 I I_ne_zero
  have : NormedSpace.exp (I ‚Ä¢ z) ‚àà spectrum ‚ÑÇ (NormedSpace.exp (I ‚Ä¢ a)) := by
    simpa only [Units.smul_def, Units.val_mk0] using
      spectrum.exp_mem_exp (Iu ‚Ä¢ a) (smul_mem_smul_iff.mpr hz)
  exact Complex.ext (ofReal_re _) <| by
    simpa only [‚Üê Complex.exp_eq_exp_‚ÑÇ, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,
      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using
      spectrum.subset_circle_of_unitary hu this","error:  type mismatch
  I ‚Ä¢ z
has type
  ‚ÑÇ : outParam Type
but is expected to have type
  Type ?u.38533 : Type (?u.38533 + 1)
error:  type mismatch
  I ‚Ä¢ a
has type
  A : outParam (Type u_1)
but is expected to have type
  Type ?u.41026 : Type (?u.41026 + 1)
error:  failed to synthesize
  Membership (?m.40509 ‚Üí ?m.40509) (Set ‚ÑÇ)
use `set_option diagnostics true` to get diagnostic information
error:  type mismatch
  h‚úù
has type
  ?m.46815 ‚àà Metric.sphere 0 1 : Prop
but is expected to have type
  z.im = (‚Üëz.re).im : Prop","theorem IsSelfAdjoint.mem_spectrum_eq_re [StarModule ‚ÑÇ A] {a : A} (ha : IsSelfAdjoint a) {z : ‚ÑÇ}
    (hz : z ‚àà spectrum ‚ÑÇ a) : z = z.re ",":= by
  have hu := exp_mem_unitary_of_mem_skewAdjoint ‚ÑÇ (ha.smul_mem_skewAdjoint conj_I)
  let Iu := Units.mk0 I I_ne_zero
  have : NormedSpace.exp ‚ÑÇ (I ‚Ä¢ z) ‚àà spectrum ‚ÑÇ (NormedSpace.exp ‚ÑÇ (I ‚Ä¢ a)) := by
    simpa only [Units.smul_def, Units.val_mk0] using
      spectrum.exp_mem_exp (Iu ‚Ä¢ a) (smul_mem_smul_iff.mpr hz)
  exact Complex.ext (ofReal_re _) <| by
    simpa only [‚Üê Complex.exp_eq_exp_‚ÑÇ, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,
      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using
      spectrum.subset_circle_of_unitary hu this",":= by
  letI : Algebra ‚Ñö A := RestrictScalars.algebra ‚Ñö ‚ÑÇ A
  have hu := exp_mem_unitary_of_mem_skewAdjoint ‚ÑÇ (ha.smul_mem_skewAdjoint conj_I)
  let Iu := Units.mk0 I I_ne_zero
  have : NormedSpace.exp (I ‚Ä¢ z) ‚àà spectrum ‚ÑÇ (NormedSpace.exp (I ‚Ä¢ a)) := by
    simpa only [Units.smul_def, Units.val_mk0] using
      spectrum.exp_mem_exp (Iu ‚Ä¢ a) (smul_mem_smul_iff.mpr hz)
  exact Complex.ext (ofReal_re _) <| by
    simpa only [‚Üê Complex.exp_eq_exp_‚ÑÇ, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,
      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using
      spectrum.subset_circle_of_unitary hu this"
Mathlib/RingTheory/PowerSeries/WellKnown.lean,PowerSeries.mk_one_pow_eq_mk_choose_add,mk_one_pow_eq_mk_choose_add,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":= by
  induction d with
  | zero => simp only [Nat.zero_eq, zero_add, pow_one, Nat.choose_zero_right, Nat.cast_one]; rfl
  | succ d hd =>
      rw [pow_add, pow_one, mul_comm, show Nat.succ d = d + 1 by rfl, ext_iff]; exact fun n => by
        rw [hd, coeff_mul]; simp only [coeff_mk, one_mul]; rw [Nat.succ_add, Nat.choose_succ_succ,
        ‚Üê Finset.sum_antidiagonal_choose_add]; simp only [Pi.one_apply, one_mul, Nat.cast_sum]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  d.succ
case succ
S : Type u_1
inst‚úù : CommRing S
d‚úù d : ‚Ñï
hd : mk 1 ^ (d + 1) = mk fun n ‚Ü¶ ‚Üë((d + n).choose d)
‚ä¢ mk 1 * mk 1 ^ (d + 1) = mk fun n ‚Ü¶ ‚Üë((d + 1 + n).choose (d + 1))
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated","theorem mk_one_pow_eq_mk_choose_add :
    (mk 1 : S‚ü¶X‚üß) ^ (d + 1) = (mk fun n => Nat.choose (d + n) d : S‚ü¶X‚üß) ",":= by
  induction d with
  | zero => ext; simp
  | succ d hd =>
      ext n
      rw [pow_add, hd, pow_one, mul_comm, coeff_mul]
      simp_rw [coeff_mk, Pi.one_apply, one_mul]
      norm_cast
      rw [Finset.sum_antidiagonal_choose_add, ‚Üê Nat.choose_succ_succ, Nat.succ_eq_add_one,
        add_right_comm]",":= by
  induction d with
  | zero => simp only [Nat.zero_eq, zero_add, pow_one, Nat.choose_zero_right, Nat.cast_one]; rfl
  | succ d hd =>
      rw [pow_add, pow_one, mul_comm, show Nat.succ d = d + 1 by rfl, ext_iff]; exact fun n => by
        rw [hd, coeff_mul]; simp only [coeff_mk, one_mul]; rw [Nat.succ_add, Nat.choose_succ_succ,
        ‚Üê Finset.sum_antidiagonal_choose_add]; simp only [Pi.one_apply, one_mul, Nat.cast_sum]"
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.epi_iff_surjective,epi_iff_surjective,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  rw [‚Üê Functor.epi_map_iff_epi skeletalEquivalence.functor.{0}]
  dsimp only [skeletalEquivalence, Functor.asEquivalence_functor]
  rw [NonemptyFinLinOrdCat.epi_iff_surjective, skeletalFunctor.coe_map,
    Function.Surjective.of_comp_iff' ULift.up_bijective,
    Function.Surjective.of_comp_iff _ ULift.down_surjective]",error:  too many explicit universe levels for 'SimplexCategory.skeletalEquivalence',"theorem epi_iff_surjective {n m : SimplexCategory} {f : n ‚ü∂ m} :
    Epi f ‚Üî Function.Surjective f.toOrderHom ",":= by
  rw [‚Üê Functor.epi_map_iff_epi skeletalEquivalence.functor]
  dsimp only [skeletalEquivalence, Functor.asEquivalence_functor]
  simp only [skeletalFunctor_obj, skeletalFunctor_map,
    NonemptyFinLinOrd.epi_iff_surjective, NonemptyFinLinOrd.coe_of]",":= by
  rw [‚Üê Functor.epi_map_iff_epi skeletalEquivalence.functor.{0}]
  dsimp only [skeletalEquivalence, Functor.asEquivalence_functor]
  rw [NonemptyFinLinOrdCat.epi_iff_surjective, skeletalFunctor.coe_map,
    Function.Surjective.of_comp_iff' ULift.down_surjective]"
Mathlib/Algebra/Tropical/BigOperators.lean,Multiset.trop_inf,Multiset.trop_inf,040e24340352a4333b5b2688f637a85dc78123c1,":= by
  induction' s with s x IH
  ¬∑ simp
  ¬∑ simp [‚Üê IH]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
R : Type u_1
S : Type u_2
inst‚úù¬π : LinearOrder R
inst‚úù : OrderTop R
s : Multiset R
‚ä¢ trop s.inf = (map trop s).sum","theorem Multiset.trop_inf [LinearOrder R] [OrderTop R] (s : Multiset R) :
    trop s.inf = Multiset.sum (s.map trop) ",":= by
  induction' s using Multiset.induction with s x IH
  ¬∑ simp
  ¬∑ simp [‚Üê IH]",":= by
  induction' s using Multiset.induction with s x IH
  ¬∑ simp
  ¬∑ simp [‚Üê IH]"
Mathlib/Algebra/Order/Floor.lean,Nat.one_le_floor_iff,one_le_floor_iff,f8dea2620ed854ca48ed31434fd52cc5ab2b6542,":=
  mod_cast @le_floor_iff' Œ± _ _ _ x 1 one_ne_zero","warning:  @floor does not have a doc string
warning:  @ceil does not have a doc string
error:  application type mismatch
  @le_floor_iff' Œ± ?m.22731 ?m.22732 ?m.22733 x
argument
  x
has type
  Œ± : Type u_2
but is expected to have type
  ‚Ñï : Type
warning:  @floor does not have a doc string
warning:  @ceil does not have a doc string",theorem one_le_floor_iff (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x ,":=
  mod_cast @le_floor_iff' Œ± _ _ x 1 one_ne_zero",":=
  le_floor_iff' Œ± _ _ _ x 1 one_ne_zero"
Mathlib/Combinatorics/SimpleGraph/Operations.lean,SimpleGraph.adj_replaceVertex_iff_of_ne,adj_replaceVertex_iff_of_ne,f61a485edf966de0b09bd70c1edc7f254cd1b0ae,:= by simp [hw],error:  simp made no progress,"lemma adj_replaceVertex_iff_of_ne_left {w : V} (hw : w ‚â† t) :
    (G.replaceVertex s t).Adj s w ‚Üî G.Adj s w ",":= by simp [replaceVertex, hw]",:= by simp [hw]
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.mul_le_addHaar_image_of_lt_det,mul_le_addHaar_image_of_lt_det,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ filter_upwards
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine' Tendsto.mul (tendsto_const_nhds.mul _) tendsto_id
      refine' (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ _
      simpa only [tsub_zero, inv_eq_zero, Ne.def] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toPartialEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target by
    change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne.def] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne.def, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.195494 ‚Üí ?m.195494 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  ‚Äñ‚ÜëB.symm‚Äñ‚Çä ‚â† 0 : Prop
but is expected to have type
  ‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π ‚â† 0 : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.205087 ‚Üí ?m.205087 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  m ‚â† 0 : Prop
but is expected to have type
  ‚Üëm ‚â† 0 : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.205354 ‚Üí ?m.205354 ‚Üí Prop
error:  simp made no progress","theorem mul_le_addHaar_image_of_lt_det (A : E ‚ÜíL[‚Ñù] E) {m : ‚Ñù‚â•0}
    (hm : (m : ‚Ñù‚â•0‚àû) < ENNReal.ofReal |A.det|) :
    ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù‚â•0),
      ‚àÄ (s : Set E) (f : E ‚Üí E), ApproximatesLinearOn f A s Œ¥ ‚Üí (m : ‚Ñù‚â•0‚àû) * Œº s ‚â§ Œº (f '' s) ",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ filter_upwards
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_eq_zero, Ne] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toPartialEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target by
    change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ filter_upwards
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_eq_zero]"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,contMDiff_coe_sphere,contMDiff_coe_sphere,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  have := smoothMfldWithCorners (E := E) (n := n)
  rw [contMDiff_iff]
  constructor
  ¬∑ exact continuous_subtype_val
  ¬∑ intro v _
    let U : _ ‚âÉ‚Çó·µ¢[‚Ñù] _ :=
      (
          OrthonormalBasis.fromOrthogonalSpanSingleton
          n (ne_zero_of_mem_unit_sphere (-v))).repr
    exact
      ((contDiff_stereoInvFunAux.comp (‚Ñù ‚àô (-v : E))·óÆ.subtypeL.contDiff).comp
          U.symm.contDiff).contDiffOn","error:  unknown identifier 'smoothMfldWithCorners'
error:  unsolved goals
E : Type u_1
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : InnerProductSpace ‚Ñù E
n : ‚Ñï
inst‚úù : Fact (finrank ‚Ñù E = n + 1)
‚ä¢ ContMDiff ùìò(‚Ñù, EuclideanSpace ‚Ñù (Fin n)) ùìò(‚Ñù, E) ‚ä§ Subtype.val","theorem contMDiff_coe_sphere {n : ‚Ñï} [Fact (finrank ‚Ñù E = n + 1)] :
    ContMDiff (ùì° n) ùìò(‚Ñù, E) ‚àû ((‚Üë) : sphere (0 : E) 1 ‚Üí E) ",":= by
  have := EuclideanSpace.instSmoothManifoldWithCornersSphere (E := E) (n := n)
  rw [contMDiff_iff]
  constructor
  ¬∑ exact continuous_subtype_val
  ¬∑ intro v _
    let U : _ ‚âÉ‚Çó·µ¢[‚Ñù] _ :=
      (
          OrthonormalBasis.fromOrthogonalSpanSingleton
          n (ne_zero_of_mem_unit_sphere (-v))).repr
    exact
      ((contDiff_stereoInvFunAux.comp (‚Ñù ‚àô (-v : E))·óÆ.subtypeL.contDiff).comp
          U.symm.contDiff).contDiffOn",":= by
  have := smoothMfldWithCorners (E := E) (n := n)
  rw [contMDiff_iff]
  constructor
  ¬∑ exact continuous_subtype_val
  ¬∑ intro v _
    let U : _ ‚âÉ‚Çó·µ¢[‚Ñù] _ :=
      (
          OrthonormalBasis.fromOrthogonalSpanSingleton
           n (ne_zero_of_mem_unit_sphere (-v))).repr
    exact
      ((contDiff_stereoInvFunAux.comp (‚Ñù ‚àô (-v : E))·óÆ.subtypeL.contDiff).comp
          U.symm.contDiff).contDiffOn"
Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean,Behrend.bound_aux',bound_aux',453c456b049db19d87dc21aed1a69aaf23bd5e15,"  let ‚ü®_, h‚ü© := exists_large_sphere n d
  h.trans <| cast_le.2 <| card_sphere_le_rothNumberNat _ _ _","error:  unexpected token 'let'; expected ':=', 'where' or '|'",theorem bound_aux' (n d : ‚Ñï) : ((d ^ n :) / (n * d ^ 2 :) : ‚Ñù) ‚â§ rothNumberNat ((2 * d - 1) ^ n) ,":=
  let ‚ü®_, h‚ü© := exists_large_sphere n d
  h.trans <| cast_le.2 <| card_sphere_le_rothNumberNat _ _ _",":= exists_large_sphere n d
  h.trans <| card_sphere_le_rothNumberNat _ _ _"
Mathlib/NumberTheory/ClassNumber/Finite.lean,ClassGroup.norm_le,norm_le,89ef31102f161fe84e63f6600973e8e72b470760,":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  rw [‚Üê LinearMap.det_toMatrix bS]
  convert Matrix.det_sum_smul_le (n := Œπ) Finset.univ _ hy using 3
  ¬∑ simp [map_sum]; rfl
  ¬∑ rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  LinearMap.det ?f
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
inst‚úù¬π‚Å¥ : EuclideanDomain R
inst‚úù¬π¬≥ : CommRing S
inst‚úù¬π¬≤ : IsDomain S
inst‚úù¬π¬π : Field K
inst‚úù¬π‚Å∞ : Field L
inst‚úù‚Åπ : Algebra R K
inst‚úù‚Å∏ : IsFractionRing R K
inst‚úù‚Å∑ : Algebra K L
inst‚úù‚Å∂ : FiniteDimensional K L
inst‚úù‚Åµ : IsSeparable K L
algRL : Algebra R L
inst‚úù‚Å¥ : IsScalarTower R K L
inst‚úù¬≥ : Algebra R S
inst‚úù¬≤ : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R ‚Ñ§
Œπ : Type u_5
inst‚úù¬π : DecidableEq Œπ
inst‚úù : Fintype Œπ
bS : Basis Œπ R S
a : S
y : ‚Ñ§
hy : ‚àÄ (k : Œπ), abv ((bS.repr a) k) ‚â§ y
‚ä¢ abv (‚àë x : Œπ, (bS.repr a) x ‚Ä¢ (LinearMap.toMatrix bS bS) ((Algebra.lmul R S) (bS x))).det ‚â§
    (Fintype.card Œπ).factorial ‚Ä¢
      (Fintype.card Œπ ‚Ä¢
          ((Finset.image (fun ijk ‚Ü¶ abv ((Algebra.leftMulMatrix bS) (bS ijk.1) ijk.2.1 ijk.2.2)) Finset.univ).max' ‚ãØ *
            y)) ^
        Fintype.card Œπ","theorem norm_le (a : S) {y : ‚Ñ§} (hy : ‚àÄ k, abv (bS.repr a k) ‚â§ y) :
    abv (Algebra.norm R a) ‚â§ normBound abv bS * y ^ Fintype.card Œπ ",":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  convert Matrix.det_sum_smul_le Finset.univ _ hy using 3
  ¬∑ rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©",":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  rw [‚Üê LinearMap.det_toMatrix bS]
  convert Matrix.det_sum_smul_le (n := Œπ) Finset.univ _ hy using 3
  ¬∑ simp [map_sum]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©"
Mathlib/Algebra/Homology/ExactSequence.lean,CategoryTheory.ComposableArrows.exact‚ÇÅ,exact‚ÇÅ,0bb63b2bff135338722ab98f6da549f3e6350f0a,"  toIsComplex := S.isComplex‚ÇÅ
  exact i hi := by exfalso; linarith","error:  unknown tactic
error:  unsolved goals
C : Type u_1
inst‚úù¬π : Category.{u_2, u_1} C
inst‚úù : HasZeroMorphisms C
n : ‚Ñï
S‚úù : ComposableArrows C n
S : ComposableArrows C 1
i : ‚Ñï
hi : autoParam (i + 2 ‚â§ 1) _auto‚úù
‚ä¢ False","lemma exact‚ÇÅ (S : ComposableArrows C 1) : S.Exact where
","  toIsComplex := S.isComplex‚ÇÅ
  exact i hi := by exfalso; omega",:= S.isComplex‚ÇÅ
Mathlib/Order/OrderIsoNat.lean,RelEmbedding.acc_iff_no_decreasing_seq,acc_iff_no_decreasing_seq,bf799bb912c215766620a5a7133594b711412432,":= by
  constructor
  ¬∑ refine' fun h => h.recOn fun x _ IH => _
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    obtain ‚ü®f, h‚ü© := Classical.axiom_of_choice this
    refine' fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGt (fun n => ((f^[n]) ‚ü®x, hx‚ü©).1) fun n => _, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h","error:  unknown identifier 'lt_add_one'
error:  unknown identifier 'Classical.axiom_of_choice'
error:  rcases tactic failed: x‚úù : ?m.2248 is not an inductive datatype","theorem acc_iff_no_decreasing_seq {x} :
    Acc r x ‚Üî IsEmpty { f : ((¬∑ > ¬∑) : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop) ‚Ü™r r // x ‚àà Set.range f } ",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (Nat.lt_succ_self _))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    choose f h using this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, ?_, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    obtain ‚ü®f, h‚ü© := Classical.axiom_of_choice this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGt (fun n => ((f^[n]) ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h"
Mathlib/Topology/Separation.lean,Specializes.symm,Specializes.symm,ea54eb89c8a123dcfceeb11bd200d459f2f95413,":= by
  simpa only [specializes_iff_not_disjoint, disjoint_comm] using h","error:  unknown identifier 'specializes_iff_not_disjoint'
error:  type mismatch
  h‚úù
has type
  x ‚§≥ y : Prop
but is expected to have type
  y ‚§≥ x : Prop",theorem Specializes.symm (h : x ‚§≥ y) : y ‚§≥ x ,:= specializes_symmetric h,":= by
  simpa [specializes_iff_not_disjoint, disjoint_comm] using h"
Mathlib/Geometry/Euclidean/Circumcenter.lean,EuclideanGeometry.exists_circumradius_eq_of_cospherical_subset,exists_circumradius_eq_of_cospherical_subset,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rw [cospherical_iff_exists_mem_of_finiteDimensional h] at hc
  rcases hc with ‚ü®c, hc, r, hcr‚ü©
  use r
  intro sx hsxps
  have hsx : affineSpan ‚Ñù (Set.range sx.points) = s := by
    refine'
      sx.Independent.affineSpan_eq_of_le_of_card_eq_finrank_add_one
        (spanPoints_subset_coe_of_subset_coe (hsxps.trans h)) _
    simp [hd]
  have hc : c ‚àà affineSpan ‚Ñù (Set.range sx.points) := hsx.symm ‚ñ∏ hc
  exact
    (sx.eq_circumradius_of_dist_eq hc fun i =>
        hcr (sx.points i) (hsxps (Set.mem_range_self i))).symm","error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  sx
has type
  Simplex ‚Ñù P n
error:  no goals to be solved","theorem exists_circumradius_eq_of_cospherical_subset {s : AffineSubspace ‚Ñù P} {ps : Set P}
    (h : ps ‚äÜ s) [Nonempty s] {n : ‚Ñï} [FiniteDimensional ‚Ñù s.direction]
    (hd : finrank ‚Ñù s.direction = n) (hc : Cospherical ps) :
    ‚àÉ r : ‚Ñù, ‚àÄ sx : Simplex ‚Ñù P n, Set.range sx.points ‚äÜ ps ‚Üí sx.circumradius = r ",":= by
  rw [cospherical_iff_exists_mem_of_finiteDimensional h] at hc
  rcases hc with ‚ü®c, hc, r, hcr‚ü©
  use r
  intro sx hsxps
  have hsx : affineSpan ‚Ñù (Set.range sx.points) = s := by
    refine
      sx.independent.affineSpan_eq_of_le_of_card_eq_finrank_add_one
        (spanPoints_subset_coe_of_subset_coe (hsxps.trans h)) ?_
    simp [hd]
  have hc : c ‚àà affineSpan ‚Ñù (Set.range sx.points) := hsx.symm ‚ñ∏ hc
  exact
    (sx.eq_circumradius_of_dist_eq hc fun i =>
        hcr (sx.points i) (hsxps (Set.mem_range_self i))).symm",":= by
  rw [cospherical_iff_exists_mem_of_finiteDimensional h] at hc
  rcases hc with ‚ü®c, hc, r, hcr‚ü©
  use r
  intro sx hsxps
  have hsx : affineSpan ‚Ñù (Set.range sx.points) = s := by
    refine
      sx.Independent.affineSpan_eq_of_le_of_card_eq_finrank_add_one
        (spanPoints_subset_coe_of_subset_coe (hsxps.trans h)) ?_
    simp [hd]
  have hc : c ‚àà affineSpan ‚Ñù (Set.range sx.points) := hsx.symm ‚ñ∏ hc
  exact
    (sx.eq_circumradius_of_dist_eq hc fun i =>
        hcr (sx.points i) (hsxps (Set.mem_range_self i))).symm"
Mathlib/Combinatorics/SimpleGraph/StronglyRegular.lean,SimpleGraph.IsSRGWith.card_neighborFinset_union_of_not_adj,IsSRGWith.card_neighborFinset_union_of_not_adj,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  rw [‚Üê h.of_not_adj v w hne ha]
  apply h.card_neighborFinset_union_eq","error:  application type mismatch
  h.of_not_adj v
argument
  v
has type
  V : Type u
but is expected to have type
  ?m.15238 ‚â† ?m.15239 : Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.15773
V : Type u
inst‚úù¬≤ : Fintype V
inst‚úù¬π : DecidableEq V
G : SimpleGraph V
inst‚úù : DecidableRel G.Adj
n k ‚Ñì Œº : ‚Ñï
v w : V
h : G.IsSRGWith n k ‚Ñì Œº
hne : v ‚â† w
ha : ¬¨G.Adj v w
‚ä¢ (G.neighborFinset v ‚à™ G.neighborFinset w).card = 2 * k - Œº","theorem IsSRGWith.card_neighborFinset_union_of_not_adj {v w : V} (h : G.IsSRGWith n k ‚Ñì Œº)
    (hne : v ‚â† w) (ha : ¬¨G.Adj v w) :
    (G.neighborFinset v ‚à™ G.neighborFinset w).card = 2 * k - Œº ",":= by
  rw [‚Üê h.of_not_adj hne ha]
  apply h.card_neighborFinset_union_eq",":= by
  rw [h.of_not_adj v w hne ha]
  apply h.card_neighborFinset_union_eq"
Mathlib/Geometry/Manifold/VectorBundle/Basic.lean,Bundle.contMDiffWithinAt_totalSpace,contMDiffWithinAt_totalSpace,bbc6e56d76341e236fa4e15748bebff612b5cb4f,":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp, LocalEquiv.trans_apply,
    LocalEquiv.prod_coe, LocalEquiv.refl_coe, extChartAt_self_apply, modelWithCornersSelf_coe,
    id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]","error:  unknown identifier 'LocalEquiv.trans_apply'
error:  simp made no progress","theorem contMDiffWithinAt_totalSpace (f : M ‚Üí TotalSpace F E) {s : Set M} {x‚ÇÄ : M} :
    ContMDiffWithinAt IM (IB.prod ùìò(ùïú, F)) n f s x‚ÇÄ ‚Üî
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s x‚ÇÄ ‚àß
      ContMDiffWithinAt IM ùìò(ùïú, F) n (fun x ‚Ü¶ (trivializationAt F E (f x‚ÇÄ).proj (f x)).2) s x‚ÇÄ ",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,
    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, ‚Üê chartedSpaceSelf_prod]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp, LocalEquiv.trans_apply,
    LocalEquiv.prod_coe, LocalEquiv.refl_coe, extChartAt_self_apply, modelWithCornersSelf_coe,
    id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]"
Mathlib/Data/Matroid/Dual.lean,Matroid.setOf_dual_base_eq,setOf_dual_base_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext B
  simp only [mem_setOf_eq, mem_image, dual_base_iff']
  refine' ‚ü®fun h ‚Ü¶ ‚ü®_, h.1, diff_diff_cancel_left h.2‚ü©,
    fun ‚ü®B', hB', h‚ü© ‚Ü¶ ‚ü®_,h.symm.trans_subset (diff_subset _ _)‚ü©‚ü©
  rwa [‚Üê h, diff_diff_cancel_left hB'.subset_ground]","error:  function expected at
  diff_subset ?m.25303
term has type
  ?m.25302 ‚àà ?m.25300",theorem setOf_dual_base_eq : {B | M‚ú∂.Base B} = (fun X ‚Ü¶ M.E \ X) '' {B | M.Base B} ,":= by
  ext B
  simp only [mem_setOf_eq, mem_image, dual_base_iff']
  refine ‚ü®fun h ‚Ü¶ ‚ü®_, h.1, diff_diff_cancel_left h.2‚ü©,
    fun ‚ü®B', hB', h‚ü© ‚Ü¶ ‚ü®?_,h.symm.trans_subset diff_subset‚ü©‚ü©
  rwa [‚Üê h, diff_diff_cancel_left hB'.subset_ground]",":= by
  ext B
  simp only [mem_setOf_eq, mem_image, dual_base_iff']
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, h.1, diff_diff_cancel_left h.2‚ü©,
    fun ‚ü®B', hB', h‚ü© ‚Ü¶ ‚ü®_,h.symm.trans_subset diff_subset‚ü©‚ü©
  rwa [‚Üê h, diff_diff_cancel_left hB'.subset_ground]"
Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean,Collinear.oangle_sign_of_sameRay_vsub,_root_.Collinear.oangle_sign_of_sameRay_vsub,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _
          (Set.mem_singleton _)))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÉ‚ÇÑ
    rw [‚Üê Real.Angle.sign_eq_zero_iff] at hs‚ÇÅ‚ÇÖ‚ÇÇ hs‚ÇÉ‚ÇÖ‚ÇÑ
    rw [hs‚ÇÅ‚ÇÖ‚ÇÇ, hs‚ÇÉ‚ÇÖ‚ÇÑ]
  ¬∑ let s : Set (P √ó P √ó P) :=
      (fun x : line[‚Ñù, p‚ÇÅ, p‚ÇÇ] √ó V => (x.1, p‚ÇÖ, x.2 +·µ• (x.1 : P))) ''
        Set.univ √óÀ¢ {v | SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) v ‚àß v ‚â† 0}
    have hco : IsConnected s :=
      haveI : ConnectedSpace line[‚Ñù, p‚ÇÅ, p‚ÇÇ] := AddTorsor.connectedSpace _ _
      (isConnected_univ.prod (isConnected_setOf_sameRay_and_ne_zero
        (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm))).image _
        (continuous_fst.subtype_val.prod_mk (continuous_const.prod_mk
          (continuous_snd.vadd continuous_fst.subtype_val))).continuousOn
    have hf : ContinuousOn (fun p : P √ó P √ó P => ‚à° p.1 p.2.1 p.2.2) s := by
      refine' ContinuousAt.continuousOn fun p hp => continuousAt_oangle _ _
      all_goals
        simp_rw [Set.mem_image, Set.mem_prod, Set.mem_univ, true_and_iff, Prod.ext_iff] at hp
        obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
        dsimp only at hp ‚ä¢
        obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
        dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
        obtain ‚ü®hvr, -‚ü© := hv
        rintro rfl
        refine hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan ?_).2 (collinear_pair _ _ _))
      ¬∑ exact hq
      ¬∑ refine' vadd_mem_of_mem_direction _ hq
        rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
        obtain ‚ü®r, -, rfl‚ü© := hvr
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hsp : ‚àÄ p : P √ó P √ó P, p ‚àà s ‚Üí ‚à° p.1 p.2.1 p.2.2 ‚â† 0 ‚àß ‚à° p.1 p.2.1 p.2.2 ‚â† œÄ := by
      intro p hp
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff] at hp
      obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
      dsimp only at hp ‚ä¢
      obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
      dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
      obtain ‚ü®hvr, hv0‚ü© := hv
      rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
      obtain ‚ü®r, -, rfl‚ü© := hvr
      change q ‚àà line[‚Ñù, p‚ÇÅ, p‚ÇÇ] at hq
      rw [oangle_ne_zero_and_ne_pi_iff_affineIndependent]
      refine' affineIndependent_of_ne_of_mem_of_not_mem_of_mem _ hq
          (fun h => hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan h).2 (collinear_pair _ _ _))) _
      ¬∑ rwa [‚Üê @vsub_ne_zero V, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, neg_ne_zero]
      ¬∑ refine' vadd_mem_of_mem_direction _ hq
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hp‚ÇÅp‚ÇÇs : (p‚ÇÅ, p‚ÇÖ, p‚ÇÇ) ‚àà s := by
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine' ‚ü®‚ü®‚ü®p‚ÇÅ, left_mem_affineSpan_pair ‚Ñù _ _‚ü©, p‚ÇÇ -·µ• p‚ÇÅ‚ü©,
        ‚ü®SameRay.rfl, vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm‚ü©, _‚ü©
      simp
    have hp‚ÇÉp‚ÇÑs : (p‚ÇÉ, p‚ÇÖ, p‚ÇÑ) ‚àà s := by
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine' ‚ü®‚ü®‚ü®p‚ÇÉ, hc.mem_affineSpan_of_mem_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _))) hp‚ÇÅp‚ÇÇ‚ü©, p‚ÇÑ -·µ• p‚ÇÉ‚ü©,
        ‚ü®hr, vsub_ne_zero.2 hp‚ÇÉp‚ÇÑ.symm‚ü©, _‚ü©
      simp
    convert Real.Angle.sign_eq_of_continuousOn hco hf hsp hp‚ÇÉp‚ÇÑs hp‚ÇÅp‚ÇÇs","warning:  @oangle does not have a doc string
error:  simp made no progress
error:  simp made no progress
error:  unknown identifier 'hq'
error:  unknown identifier 'hq'
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress","theorem _root_.Collinear.oangle_sign_of_sameRay_vsub {p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P} (p‚ÇÖ : P) (hp‚ÇÅp‚ÇÇ : p‚ÇÅ ‚â† p‚ÇÇ)
    (hp‚ÇÉp‚ÇÑ : p‚ÇÉ ‚â† p‚ÇÑ) (hc : Collinear ‚Ñù ({p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P))
    (hr : SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) (p‚ÇÑ -·µ• p‚ÇÉ)) : (‚à° p‚ÇÅ p‚ÇÖ p‚ÇÇ).sign = (‚à° p‚ÇÉ p‚ÇÖ p‚ÇÑ).sign ",":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _
          (Set.mem_singleton _)))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÉ‚ÇÑ
    rw [‚Üê Real.Angle.sign_eq_zero_iff] at hs‚ÇÅ‚ÇÖ‚ÇÇ hs‚ÇÉ‚ÇÖ‚ÇÑ
    rw [hs‚ÇÅ‚ÇÖ‚ÇÇ, hs‚ÇÉ‚ÇÖ‚ÇÑ]
  ¬∑ let s : Set (P √ó P √ó P) :=
      (fun x : line[‚Ñù, p‚ÇÅ, p‚ÇÇ] √ó V => (x.1, p‚ÇÖ, x.2 +·µ• (x.1 : P))) ''
        Set.univ √óÀ¢ {v | SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) v ‚àß v ‚â† 0}
    have hco : IsConnected s :=
      haveI : ConnectedSpace line[‚Ñù, p‚ÇÅ, p‚ÇÇ] := AddTorsor.connectedSpace _ _
      (isConnected_univ.prod (isConnected_setOf_sameRay_and_ne_zero
        (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm))).image _
        (continuous_fst.subtype_val.prod_mk (continuous_const.prod_mk
          (continuous_snd.vadd continuous_fst.subtype_val))).continuousOn
    have hf : ContinuousOn (fun p : P √ó P √ó P => ‚à° p.1 p.2.1 p.2.2) s := by
      refine ContinuousAt.continuousOn fun p hp => continuousAt_oangle ?_ ?_
      all_goals
        simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_univ, true_and_iff, Prod.ext_iff] at hp
        obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
        dsimp only at hp ‚ä¢
        obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
        dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
        obtain ‚ü®hvr, -‚ü© := hv
        rintro rfl
        refine hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan ?_).2 (collinear_pair _ _ _))
      ¬∑ exact hq
      ¬∑ refine vadd_mem_of_mem_direction ?_ hq
        rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
        obtain ‚ü®r, -, rfl‚ü© := hvr
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hsp : ‚àÄ p : P √ó P √ó P, p ‚àà s ‚Üí ‚à° p.1 p.2.1 p.2.2 ‚â† 0 ‚àß ‚à° p.1 p.2.1 p.2.2 ‚â† œÄ := by
      intro p hp
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff] at hp
      obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
      dsimp only at hp ‚ä¢
      obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
      dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
      obtain ‚ü®hvr, hv0‚ü© := hv
      rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
      obtain ‚ü®r, -, rfl‚ü© := hvr
      change q ‚àà line[‚Ñù, p‚ÇÅ, p‚ÇÇ] at hq
      rw [oangle_ne_zero_and_ne_pi_iff_affineIndependent]
      refine affineIndependent_of_ne_of_mem_of_not_mem_of_mem ?_ hq
          (fun h => hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan h).2 (collinear_pair _ _ _))) ?_
      ¬∑ rwa [‚Üê @vsub_ne_zero V, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, neg_ne_zero]
      ¬∑ refine vadd_mem_of_mem_direction ?_ hq
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hp‚ÇÅp‚ÇÇs : (p‚ÇÅ, p‚ÇÖ, p‚ÇÇ) ‚àà s := by
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine ‚ü®‚ü®‚ü®p‚ÇÅ, left_mem_affineSpan_pair ‚Ñù _ _‚ü©, p‚ÇÇ -·µ• p‚ÇÅ‚ü©,
        ‚ü®SameRay.rfl, vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm‚ü©, ?_‚ü©
      simp
    have hp‚ÇÉp‚ÇÑs : (p‚ÇÉ, p‚ÇÖ, p‚ÇÑ) ‚àà s := by
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine ‚ü®‚ü®‚ü®p‚ÇÉ, hc.mem_affineSpan_of_mem_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _))) hp‚ÇÅp‚ÇÇ‚ü©, p‚ÇÑ -·µ• p‚ÇÉ‚ü©,
        ‚ü®hr, vsub_ne_zero.2 hp‚ÇÉp‚ÇÑ.symm‚ü©, ?_‚ü©
      simp
    convert Real.Angle.sign_eq_of_continuousOn hco hf hsp hp‚ÇÉp‚ÇÑs hp‚ÇÅp‚ÇÇs",":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ Set.mem_insert _ _))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2"
Mathlib/RingTheory/Finiteness.lean,AlgHom.Finite.of_comp_finite,of_comp_finite,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  letI := f.toSMul
  letI := g.toSMul
  letI := (g.comp f).toSMul
  letI := f.toAlgebra
  letI := g.toAlgebra
  letI := (g.comp f).toAlgebra
  letI : IsScalarTower A B C := RestrictScalars.isScalarTower A B C
  letI : Module.Finite A C := h
  exact Module.Finite.of_restrictScalars_finite A B C","warning:  Module.Finite does not have a doc string
error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  A ‚Üí+* B
error:  unsolved goals
A : Type u_1
B : Type u_2
C : Type u_3
inst‚úù¬≤ : CommRing A
inst‚úù¬π : CommRing B
inst‚úù : CommRing C
f : A ‚Üí+* B
g : B ‚Üí+* C
h : (g.comp f).Finite
‚ä¢ g.Finite",theorem of_comp_finite {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite ,":= by
  letI := f.toAlgebra
  letI := g.toAlgebra
  letI := (g.comp f).toAlgebra
  letI : IsScalarTower A B C := RestrictScalars.isScalarTower A B C
  letI : Module.Finite A C := h
  exact Module.Finite.of_restrictScalars_finite A B C",":= by
  letI := f.toAlgebra
  letI := (g.comp f).toAlgebra
  letI : IsScalarTower A B C := RestrictScalars.isScalarTower A B C
  letI : Module.Finite A C := h
  exact Module.Finite.of_restrictScalars_finite A B C"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Œµ hŒµ).mono fun y hy => _
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",error:  unexpected token ';'; expected '|',"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tend"
Mathlib/Analysis/SpecialFunctions/Integrals.lean,intervalIntegral.intervalIntegrable_rpow',intervalIntegrable_rpow',99a86b16ee62e275b4ba2d10af676ef15108402a,":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine' (continuousOn_id.rpow_const _).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine' m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply _, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",error:  no goals to be solved,"theorem intervalIntegrable_rpow' {r : ‚Ñù} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const _).div_const ?_; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply _, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]"
Mathlib/RingTheory/IntegralDomain.lean,sum_hom_units,sum_hom_units,ef974f8646c0e311a0099369431445e66aff22d5,":= by
  classical
    obtain ‚ü®x, hx‚ü© :
      ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0  
    exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u : RÀ£ in univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u : RÀ£ in univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := (congr_arg‚ÇÇ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n in range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only [mem_univ, forall_true_iff])
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
            (fun m n hm hn => pow_injOn_Iio_orderOf (by simpa only [mem_range] using hm)
                (by simpa only [mem_range] using hn))
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ‚ä¢; rw [pow_mod_orderOf, hn]‚ü©)
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]","error:  unexpected identifier; expected '|'
error:  unsolved goals
case intro
R : Type u_1
G : Type u_2
inst‚úù¬≥ : CommRing R
inst‚úù¬≤ : IsDomain R
inst‚úù¬π : Group G
inst‚úù : Fintype G
f : G ‚Üí* R
hf : f ‚â† 1
x : ‚Ü•f.toHomUnits.range
hx : ‚àÄ (y : ‚Ü•f.toHomUnits.range), y ‚àà Submonoid.powers x
hx1 : ‚Üë‚Üëx - 1 ‚â† 0
‚ä¢ ‚àë g : G, f g = 0","theorem sum_hom_units_eq_zero (f : G ‚Üí* R) (hf : f ‚â† 1) : ‚àë g : G, f g = 0 ",":= by
  classical
    obtain ‚ü®x, hx‚ü© : ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u ‚àà univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u ‚àà univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := congr_arg‚ÇÇ _ rfl ?_
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n ‚àà range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ ¬∑) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ‚ä¢; rw [pow_mod_orderOf, hn]‚ü©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]",":= by
  classical
    obtain ‚ü®x, hx‚ü© :
      ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0 := fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u : RÀ£ ‚àà univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u : RÀ£ ‚àà univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := (congr_arg‚ÇÇ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n ‚àà range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only [mem_univ, forall_true_iff])
             (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                 Units.val_pow_eq_pow_val])
             (fun m n hm hn => pow_injOn_Iio_orderOf (by simpa only [mem_range] using hm)
                (by simpa only [mem_range] using hn))
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
                 by dsimp at hn ‚ä¢; rw [pow_mod_orderOf, hn]‚ü©)
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]"
Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean,AlgebraicGeometry.sourceAffineLocally_isLocal,sourceAffineLocally_isLocal,b649502be2aa6ccb36fde61da8467844af9f617e,":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
    ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
          IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
        exact this _ rfl
      intro V hV
      rw [Scheme.preimage_basicOpen] at hV
      subst hV
      exact U.2.ŒπOpens_preimage (Scheme.Œì.map f.op r.1)","error:  invalid field 'ŒπOpens_preimage', the environment does not contain 'Membership.mem.ŒπOpens_preimage'
  U.property
has type
  ‚ÜëU ‚àà X.affineOpens
error:  invalid field 'ŒπOpens_preimage', the environment does not contain 'Set.Mem.ŒπOpens_preimage'
  U.property
has type
  Set.Mem (‚ÜëU) X.affineOpens
error:  invalid field 'ŒπOpens_preimage', the environment does not contain 'AlgebraicGeometry.Scheme.affineOpens.ŒπOpens_preimage'
  U.property
has type
  X.affineOpens ‚ÜëU
error:  invalid field 'ŒπOpens_preimage', the environment does not contain 'setOf.ŒπOpens_preimage'
  U.property
has type
  {U | IsAffineOpen U} ‚ÜëU
error:  invalid field 'ŒπOpens_preimage', the environment does not contain 'AlgebraicGeometry.IsAffineOpen.ŒπOpens_preimage'
  U.property
has type
  IsAffineOpen ‚ÜëU
error:  invalid field 'ŒπOpens_preimage', the environment does not contain 'AlgebraicGeometry.IsAffine.ŒπOpens_preimage'
  U.property
has type
  IsAffine (X.restrict ‚ãØ)","theorem sourceAffineLocally_isLocal (h‚ÇÅ : RingHom.RespectsIso @P)
    (h‚ÇÇ : RingHom.LocalizationPreserves @P) (h‚ÇÉ : RingHom.OfLocalizationSpan @P) :
    (sourceAffineLocally @P).IsLocal ",":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
    ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
          IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
        exact this _ rfl
      intro V hV
      rw [Scheme.preimage_basicOpen] at hV
      subst hV
      exact U.2.ŒπOpens_basicOpen_preimage (Scheme.Œì.map f.op r.1)",":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
    ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
          IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
        exact this _ rfl
      intro V hV
      rw [Scheme.preimage_basicOpen] at hV
      subst hV
      exact U.2.ŒπOpens_preimage (Scheme.Œì.map f.op r.1)"
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,7fa386b9c1d5f5e8344fb34659b062d90996f3f0,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      rw [‚Üê coe_comp, D.w]
      rfl",error:  invalid alternative name 'empty',"theorem isTopologicalBasis_cofiltered_limit (T : ‚àÄ j, Set (Set (F.obj j)))
    (hT : ‚àÄ j, IsTopologicalBasis (T j)) (univ : ‚àÄ i : J, Set.univ ‚àà T i)
    (inter : ‚àÄ (i) (U1 U2 : Set (F.obj i)), U1 ‚àà T i ‚Üí U2 ‚àà T i ‚Üí U1 ‚à© U2 ‚àà T i)
    (compat : ‚àÄ (i j : J) (f : i ‚ü∂ j) (V : Set (F.obj j)) (_hV : V ‚àà T j), F.map f ‚Åª¬π' V ‚àà T i) :
    IsTopologicalBasis
      {U : Set C.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = C.œÄ.app j ‚Åª¬π' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [‚Üê coe_comp, D.w] 
      rfl",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ _ (univ _) (inte"
Mathlib/Topology/EMetricSpace/Basic.lean,edist_triangle_left,edist_triangle_left,2e2b45002b3b12fba4295a40fefb75963ca16803,":= by
  rw [edist_comm (fact := .mk le_rfl) z]; apply edist_triangle","error:  invalid argument name 'fact' for function 'PseudoEMetricSpace.edist_comm'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.4810
Œ± : Type u
Œ≤ : Type v
X : Type u_1
inst‚úù : PseudoEMetricSpace Œ±
x y z : Œ±
‚ä¢ edist x y ‚â§ edist z x + edist z y",theorem edist_triangle_left (x y z : Œ±) : edist x y ‚â§ edist z x + edist z y ,":= by
  rw [edist_comm z]; apply edist_triangle",":= by
  rw [edist_comm (fact := .mk le_rfl) z]; apply edist_triang"
Mathlib/GroupTheory/MonoidLocalization.lean,Submonoid.LocalizationMap.exists_of_sec_mk',exists_of_sec_mk',61ca0ea882c23bb336df737657ab5b9a48ebdbbe,":=
  f.eq_iff_exists.1 <| f.mk'_eq_iff_eq.1 <| (mk'_sec _ _).symm
  AddSubmonoid.LocalizationMap.exists_of_sec_mk'","error:  function expected at
  Eq.symm (mk'_sec ?m.194606 ?m.194671)
term has type
  ?m.194671 = ?m.194606.mk' (?m.194606.sec ?m.194671).1 (?m.194606.sec ?m.194671).2","theorem exists_of_sec_mk' (x) (y : S) :
    ‚àÉ c : S, ‚Üëc * (‚Üë(f.sec <| f.mk' x y).2 * x) = c * (y * (f.sec <| f.mk' x y).1) ",":=
  f.eq_iff_exists.1 <| f.mk'_eq_iff_eq.1 <| (mk'_sec _ _).symm",":=
  f.eq_iff_exists.1 <| f.mk'_eq_iff_eq.1 <| (mk'_sec _ _).symm"
Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean,NNReal.strictConcaveOn_rpow,strictConcaveOn_rpow,783c2cc3b72b0104b94f3708dd6af2f6563bdfd8,":= by
  have hp‚ÇÄ' : 0 < 1 / p := by positivity
  have hp‚ÇÅ' : 1 < 1 / p := by rw [one_lt_div hp‚ÇÄ]; exact hp‚ÇÅ
  let f := NNReal.orderIsoRpow (1 / p) hp‚ÇÄ'
  have h‚ÇÅ : StrictConvexOn ‚Ñù‚â•0 univ f := by
    refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
    exact (strictConvexOn_rpow hp‚ÇÅ').2 (by positivity : 0 ‚â§ x) (by positivity : 0 ‚â§ y)
      (by simp [hxy]) ha hb (by simp; norm_cast)
  have h‚ÇÇ : ‚àÄ x, f.symm x = x ^ p := by simp [NNReal.orderIsoRpow_symm_eq]
  refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
  simp only [‚Üê h‚ÇÇ]
  exact (f.strictConcaveOn_symm h‚ÇÅ).2 (Set.mem_univ x) (Set.mem_univ y) hxy ha hb hab",error:  simp made no progress,"lemma strictConcaveOn_rpow {p : ‚Ñù} (hp‚ÇÄ : 0 < p) (hp‚ÇÅ : p < 1) :
    StrictConcaveOn ‚Ñù‚â•0 univ fun x : ‚Ñù‚â•0 ‚Ü¶ x ^ p ",":= by
  have hp‚ÇÄ' : 0 < 1 / p := div_pos zero_lt_one hp‚ÇÄ
  have hp‚ÇÅ' : 1 < 1 / p := by rw [one_lt_div hp‚ÇÄ]; exact hp‚ÇÅ
  let f := NNReal.orderIsoRpow (1 / p) hp‚ÇÄ'
  have h‚ÇÅ : StrictConvexOn ‚Ñù‚â•0 univ f := by
    refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
    exact (strictConvexOn_rpow hp‚ÇÅ').2 x.2 y.2 (by simp [hxy]) ha hb (by simp; norm_cast)
  have h‚ÇÇ : ‚àÄ x, f.symm x = x ^ p := by simp [f, NNReal.orderIsoRpow_symm_eq]
  refine ‚ü®convex_univ, fun x mx y my hxy a b ha hb hab => ?_‚ü©
  simp only [‚Üê h‚ÇÇ]
  exact (f.strictConcaveOn_symm h‚ÇÅ).2 mx my hxy ha hb hab",":= by
  have hp‚ÇÄ' : 0 < 1 / p := by positivity
  have hp‚ÇÅ' : 1 < 1 / p := by rw [one_lt_div hp‚ÇÄ]; exact hp‚ÇÅ
  let f := NNReal.orderIsoRpow (1 / p) hp‚ÇÄ'
  have h‚ÇÅ : StrictConvexOn ‚Ñù‚â•0 univ f := by
    refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
    exact (strictConvexOn_rpow hp‚ÇÅ').2 (by positivity : 0 ‚â§ x) (by positivity : 0 ‚â§ y)
      (by simp [hxy]) ha hb (by simp; norm_cast)
  have h‚ÇÇ : ‚àÄ x, f.symm x = x ^ p := by simp [NNReal.orderIsoRpow_symm_eq]
  refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
  simp only [‚Üê h‚ÇÇ]
  exact (f.strictConcaveOn_symm h‚ÇÅ).2 (Set.mem_univ x) (Set.mem_univ y) hxy ha hb hab"
Mathlib/Data/Nat/Log.lean,Nat.pow_le_iff_le_log,pow_le_iff_le_log,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => dsimp; omega
  | succ x =>
    rw [log]; split_ifs with h
    ¬∑ have b_pos : 0 < b := lt_of_succ_lt hb
      rw [succ_eq_add_one, Nat.add_le_add_iff_right, ‚Üê ih (y / b) (div_lt_self
        (Nat.pos_iff_ne_zero.2 hy) hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', Nat.mul_comm]
    ¬∑ exact iff_of_false (fun hby => h ‚ü®(le_self_pow x.succ_ne_zero _).trans hby, hb‚ü©)
        (not_succ_le_zero _)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case pos
b : ‚Ñï
hb : 1 < b
y : ‚Ñï
ih : ‚àÄ m < y, ‚àÄ {x : ‚Ñï}, m ‚â† 0 ‚Üí (b ^ x ‚â§ m ‚Üî x ‚â§ log b m)
hy : y ‚â† 0
x : ‚Ñï
h : b ‚â§ y ‚àß 1 < b
b_pos : 0 < b
‚ä¢ b ^ (x + 1) ‚â§ y ‚Üî x + 1 ‚â§ log b (y / b) + 1","theorem pow_le_iff_le_log {b : ‚Ñï} (hb : 1 < b) {x y : ‚Ñï} (hy : y ‚â† 0) :
    b ^ x ‚â§ y ‚Üî x ‚â§ log b y ",":= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => dsimp; omega
  | succ x =>
    rw [log]; split_ifs with h
    ¬∑ have b_pos : 0 < b := lt_of_succ_lt hb
      rw [Nat.add_le_add_iff_right, ‚Üê ih (y / b) (div_lt_self
        (Nat.pos_iff_ne_zero.2 hy) hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', Nat.mul_comm]
    ¬∑ exact iff_of_false (fun hby => h ‚ü®(le_self_pow x.succ_ne_zero _).trans hby, hb‚ü©)
        (not_succ_le_zero _)",":= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => dsimp; omega
  | succ x =>
    rw [log]; split_ifs with h
    ¬∑ have b_pos : 0 < b := lt_of_succ_lt hb
      rw [succ_eq_add_one, Nat.add_le_add_iff_right, ‚Üê ih (y / b) (div_lt_self
        (Nat.pos_iff_ne_zero.2 hy) hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', Nat.mul_comm]
    ¬∑ exact iff_of_false (fun hby => h ‚ü®(le_self_pow x.succ_ne_zero _).trans hby, hb‚ü©)
        (not_succ_le_zero _)"
Mathlib/MeasureTheory/Function/LpSpace.lean,MeasureTheory.indicatorConstLp_eq_toSpanSingleton_compLp,indicatorConstLp_eq_toSpanSingleton_compLp,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  ext1
  refine' indicatorConstLp_coeFn.trans _
  have h_compLp :=
    (ContinuousLinearMap.toSpanSingleton ‚Ñù x).coeFn_compLp (indicatorConstLp 2 hs hŒºs (1 : ‚Ñù))
  rw [‚Üê EventuallyEq] at h_compLp
  refine' EventuallyEq.trans _ h_compLp.symm
  refine' (@indicatorConstLp_coeFn _ _ _ 2 Œº _ s hs hŒºs (1 : ‚Ñù)).mono fun y hy => _
  dsimp only
  rw [hy]
  simp_rw [ContinuousLinearMap.toSpanSingleton_apply]
  by_cases hy_mem : y ‚àà s <;> simp [hy_mem, ContinuousLinearMap.lsmul_apply]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  ContinuousLinearMap
has type
  (?m.664723 ‚Üí+* ?m.664724) ‚Üí
    (M : Type ?u.664720) ‚Üí
      [inst : TopologicalSpace M] ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          (M‚ÇÇ : Type ?u.664719) ‚Üí
            [inst_1 : TopologicalSpace M‚ÇÇ] ‚Üí
              [inst_2 : AddCommMonoid M‚ÇÇ] ‚Üí
                [inst : Module ?m.664723 M] ‚Üí [inst : Module ?m.664724 M‚ÇÇ] ‚Üí Type (max ?u.664720 ?u.664719)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  ContinuousLinearMap
has type
  (?m.666508 ‚Üí+* ?m.666509) ‚Üí
    (M : Type ?u.666505) ‚Üí
      [inst : TopologicalSpace M] ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          (M‚ÇÇ : Type ?u.666504) ‚Üí
            [inst_1 : TopologicalSpace M‚ÇÇ] ‚Üí
              [inst_2 : AddCommMonoid M‚ÇÇ] ‚Üí
                [inst : Module ?m.666508 M] ‚Üí [inst : Module ?m.666509 M‚ÇÇ] ‚Üí Type (max ?u.666505 ?u.666504)","theorem indicatorConstLp_eq_toSpanSingleton_compLp {s : Set Œ±} [NormedSpace ‚Ñù F]
    (hs : MeasurableSet s) (hŒºs : Œº s ‚â† ‚àû) (x : F) :
    indicatorConstLp 2 hs hŒºs x =
      (ContinuousLinearMap.toSpanSingleton ‚Ñù x).compLp (indicatorConstLp 2 hs hŒºs (1 : ‚Ñù)) ",":= by
  ext1
  refine indicatorConstLp_coeFn.trans ?_
  have h_compLp :=
    (ContinuousLinearMap.toSpanSingleton ‚Ñù x).coeFn_compLp (indicatorConstLp 2 hs hŒºs (1 : ‚Ñù))
  rw [‚Üê EventuallyEq] at h_compLp
  refine EventuallyEq.trans ?_ h_compLp.symm
  refine (@indicatorConstLp_coeFn _ _ _ 2 Œº _ s hs hŒºs (1 : ‚Ñù)).mono fun y hy => ?_
  dsimp only
  rw [hy]
  simp_rw [ContinuousLinearMap.toSpanSingleton_apply]
  by_cases hy_mem : y ‚àà s <;> simp [hy_mem]",":= by
  ext1
  refine indicatorConstLp_coeFn.trans ?_
  have h_compLp :=
    (ContinuousLinearMap.toSpanSingleton ‚Ñù x).coeFn_compLp (indicatorConstLp 2 hs hŒºs (1 : ‚Ñù))
  rw [‚Üê EventuallyEq] at h_compLp
  refine EventuallyEq.trans ?_ h_compLp.symm
  refine (@indicatorConstLp_coeFn _ _ _ 2 Œº _ s hs hŒºs (1 : ‚Ñù)).mono fun y hy => ?_
  dsimp only
  rw [hy]
  simp_rw [ContinuousLinearMap.toSpanSingleton_apply]
  by_cases hy_mem : y ‚àà s <;> simp [hy_mem, ContinuousLinearMap.lsmul_apply]"
Mathlib/Data/Rat/Floor.lean,Rat.floor_int_div_nat_eq_div,floor_int_div_nat_eq_div,f8dea2620ed854ca48ed31434fd52cc5ab2b6542,":= by
  rw [Rat.floor_def]
  obtain rfl | hd := @eq_zero_or_pos _ _ _ d
  ¬∑ simp
  set q := (n : ‚Ñö) / d with q_eq
  obtain ‚ü®c, n_eq_c_mul_num, d_eq_c_mul_denom‚ü© : ‚àÉ c, n = c * q.num ‚àß (d : ‚Ñ§) = c * q.den := by
    rw [q_eq]
    exact mod_cast @Rat.exists_eq_mul_div_num_and_eq_mul_div_den n d (mod_cast hd.ne')
  rw [n_eq_c_mul_num, d_eq_c_mul_denom]
  refine (Int.mul_ediv_mul_of_pos _ _ <| pos_of_mul_pos_left ?_ <| Int.natCast_nonneg q.den).symm
  rwa [‚Üê d_eq_c_mul_denom, Int.natCast_pos]","error:  function expected at
  eq_zero_or_pos ?m.2965
term has type
  ?m.2965 = 0 ‚à® 0 < ?m.2965
error:  rcases tactic failed: x‚úù : ?m.3013 is not an inductive datatype",theorem floor_int_div_nat_eq_div {n : ‚Ñ§} {d : ‚Ñï} : ‚åä(‚Üën : ‚Ñö) / (‚Üëd : ‚Ñö)‚åã = n / (‚Üëd : ‚Ñ§) ,":= by
  rw [Rat.floor_def]
  obtain rfl | hd := @eq_zero_or_pos _ _ d
  ¬∑ simp
  set q := (n : ‚Ñö) / d with q_eq
  obtain ‚ü®c, n_eq_c_mul_num, d_eq_c_mul_denom‚ü© : ‚àÉ c, n = c * q.num ‚àß (d : ‚Ñ§) = c * q.den := by
    rw [q_eq]
    exact mod_cast @Rat.exists_eq_mul_div_num_and_eq_mul_div_den n d (mod_cast hd.ne')
  rw [n_eq_c_mul_num, d_eq_c_mul_denom]
  refine (Int.mul_ediv_mul_of_pos _ _ <| pos_of_mul_pos_left ?_ <| Int.natCast_nonneg q.den).symm
  rwa [‚Üê d_eq_c_mul_denom, Int.natCast_pos]",":= by
  rw [Rat.floor_def]
  obtain rfl | hd := @eq_zero_or_pos _ _ _ d
  ¬∑ simp
  set q := (n : ‚Ñö) / d with q_eq
  obtain ‚ü®c, n_eq_c_mul_num, d_eq_c_mul_denom‚ü© : ‚àÉ c, n = c * q.num ‚àß (d : ‚Ñ§) = c * q.den := by
    rw [q_eq]
    exact mod_cast @Rat.exists_eq_mul_div_num_and_eq_mul_div_den n d (mod_cast hd.ne')
  rw [n_eq_c_mul_num, d_eq_c_mul_denom]
  refine (Int.mul_ediv_mul_of_pos _ _ <| pos_of_mul_pos_left ?_ <| Int.natCast_nonneg q.den).symm
  rwa [‚Üê d_eq_c_mul_denom, Int.natCast_pos]"
Mathlib/Data/Finset/Basic.lean,Multiset.toFinset_singleton,toFinset_singleton,b502dbb455f708f5af5e6017e88f53565165ab0a,":= by
  rw [‚Üê cons_zero, toFinset_cons, toFinset_zero, IsLawfulSingleton.insert_emptyc_eq]","error:  unknown identifier 'IsLawfulSingleton.insert_emptyc_eq'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.251503
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
inst‚úù : DecidableEq Œ±
s t : Multiset Œ±
a : Œ±
‚ä¢ insert a ‚àÖ = {a}",theorem toFinset_singleton (a : Œ±) : toFinset ({a} : Multiset Œ±) = {a} ,":= by
  rw [‚Üê cons_zero, toFinset_cons, toFinset_zero, LawfulSingleton.insert_emptyc_eq]",":= by
  rw [‚Üê cons_zero, toFinset_cons, toFinset_zero]"
Mathlib/Data/Multiset/Powerset.lean,Multiset.powersetCard_map,powersetCard_map,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' s with t s ih generalizing n
  ¬∑ cases n <;> simp [powersetCard_zero_left, powersetCard_zero_right]
  ¬∑ cases n <;> simp [ih, map_comp_cons]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ± : Type u_1
Œ≤ : Type u_2
f : Œ± ‚Üí Œ≤
n : ‚Ñï
s : Multiset Œ±
‚ä¢ powersetCard n (map f s) = map (map f) (powersetCard n s)","theorem powersetCard_map {Œ≤ : Type*} (f : Œ± ‚Üí Œ≤) (n : ‚Ñï) (s : Multiset Œ±) :
    powersetCard n (s.map f) = (powersetCard n s).map (map f) ",":= by
  induction' s using Multiset.induction with t s ih generalizing n
  ¬∑ cases n <;> simp [powersetCard_zero_left, powersetCard_zero_right]
  ¬∑ cases n <;> simp [ih, map_comp_cons]",":= by
  induction' s using Multiset.induction_on with t s ih generalizing n
  ¬∑ cases n <;> simp [ih, map_comp_cons]"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,56d6c36569bfa5f38809662c438716c5f84ec909,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniforml"
Mathlib/MeasureTheory/Measure/Typeclasses.lean,MeasureTheory.Measure.le_of_add_le_add_left,Measure.le_of_add_le_add_left,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":=
  fun S B1 => ENNReal.le_of_add_le_add_left (MeasureTheory.measure_ne_top Œº S) (A2 S B1)","error:  application type mismatch
  ENNReal.le_of_add_le_add_left (measure_ne_top Œº S) (A2 S B1)
argument
  A2 S B1
has type
  (Œº + ŒΩ‚ÇÇ) S = ‚ÜëB1 ‚Üí ‚àÉ b, (Œº + ŒΩ‚ÇÅ) S = ‚Üëb ‚àß b ‚â§ B1 : Prop
but is expected to have type
  Œº S + ?m.22442 ‚â§ Œº S + ?m.22443 : Prop",theorem Measure.le_of_add_le_add_left [IsFiniteMeasure Œº] (A2 : Œº + ŒΩ‚ÇÅ ‚â§ Œº + ŒΩ‚ÇÇ) : ŒΩ‚ÇÅ ‚â§ ŒΩ‚ÇÇ ,":=
  fun S => ENNReal.le_of_add_le_add_left (MeasureTheory.measure_ne_top Œº S) (A2 S)",":=
  fun S B1 => ENNReal.le_of_add_le_add_left (measure_ne_top Œº S) (A2 S B1)"
Mathlib/Algebra/FreeAlgebra.lean,FreeAlgebra.induction,induction,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := ‚ü®C‚ü©
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  FreeAlgebra R X ‚Üí Prop
error:  application type mismatch
  Subtype.coind (Œπ R) h_grade1
argument
  h_grade1
has type
  ‚àÄ (x : X), C (Œπ R x) : Prop
but is expected to have type
  ‚àÄ (a : X), Œπ R a ‚àà s : Prop
error:  type mismatch
  Subtype.prop (((lift R) of) a)
has type
  ‚Üë(((lift R) of) a) ‚àà s : Prop
but is expected to have type
  C ‚Üë(((lift R) of) a) : Prop","theorem induction {C : FreeAlgebra R X ‚Üí Prop}
    (h_grade0 : ‚àÄ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ‚àÄ x, C (Œπ R x))
    (h_mul : ‚àÄ a b, C a ‚Üí C b ‚Üí C (a * b)) (h_add : ‚àÄ a b, C a ‚Üí C b ‚Üí C (a + b))
    (a : FreeAlgebra R X) : C a ",":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a",":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := ‚ü®C‚ü©
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a"
Mathlib/MeasureTheory/Function/Jacobian.lean,exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt,exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt,b59290a60c46dde5929497c93a9814bf43d45c31,":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine' ‚ü®fun _ => ‚àÖ, fun _ => 0, _, _, _, _‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' x)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine' mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, _‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine' ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, _, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine' ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, _‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := (norm_add_le _ _)
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ + ‚Äñf' x - f' z‚Äñ * ‚Äñy - x‚Äñ := by
        refine' add_le_add (hŒ¥ _) (ContinuousLinearMap.le_op_norm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ‚â§ r (f' z) * ‚Äñy - x‚Äñ := by
        rw [‚Üê add_mul, add_comm]
        exact mul_le_mul_of_nonneg_right hŒµ (norm_nonneg _)
  have closure_M_subset : ‚àÄ n z, s ‚à© closure (M n z) ‚äÜ M n z := by
    rintro n z x ‚ü®xs, hx‚ü©
    refine' ‚ü®xs, fun y hy => _‚ü©
    obtain ‚ü®a, aM, a_lim‚ü© : ‚àÉ a : ‚Ñï ‚Üí E, (‚àÄ k, a k ‚àà M n z) ‚àß Tendsto a atTop (ùìù x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ‚Ñï => ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ) atTop
        (ùìù ‚Äñf y - f x - (f' z) (y - x)‚Äñ) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (ùìù (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ‚Ñï => (r (f' z) : ‚Ñù) * ‚Äñy - a k‚Äñ) atTop (ùìù (r (f' z) * ‚Äñy - x‚Äñ)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ‚àÄ·∂† k in atTop, ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ ‚â§ r (f' z) * ‚Äñy - a k‚Äñ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (ùìù (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ‚ü®hy.1, hk‚ü©
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ‚ü®d, hd‚ü©
  let K : ‚Ñï ‚Üí T ‚Üí ‚Ñï ‚Üí Set E := fun n z p => closure (M n z) ‚à© closedBall (d p) (u n / 3)
  have K_approx : ‚àÄ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ‚à© K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ‚àà M n z := closure_M_subset _ _ ‚ü®hy.1, hy.2.1‚ü©
    refine' yM.2 _ ‚ü®hx.1, _‚ü©
    calc
      dist x y ‚â§ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ‚â§ u n / 3 + u n / 3 := (add_le_add hx.2.2 hy.2.2)
      _ < u n := by linarith [u_pos n]
  have K_closed : ‚àÄ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñï ‚Üí ‚Ñï √ó T √ó ‚Ñï, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases eq_empty_or_nonempty T with (rfl | hT)
      ¬∑ rcases hs with ‚ü®x, xs‚ü©
        rcases s_subset x xs with ‚ü®n, z, _‚ü©
        exact False.elim z.2
      ¬∑ exact hT.coe_sort
    inhabit ‚Ü•T
    exact ‚ü®_, Encodable.surjective_decode_iget (‚Ñï √ó T √ó ‚Ñï)‚ü©
  refine'
    ‚ü®fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => _, fun q => K_approx _ _ _, fun _ q => ‚ü®(F q).2.1, (F q).2.1.1.2, rfl‚ü©‚ü©
  obtain ‚ü®n, z, hnz‚ü© : ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := s_subset x xs
  obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, x ‚àà closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, d p ‚àà ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ‚ü®p, (mem_ball'.1 hp).le‚ü©
  obtain ‚ü®q, hq‚ü© : ‚àÉ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ‚ü®q, _‚ü©
  simp (config := { zeta := false }) only [hq, subset_closure hnz, hp, mem_inter_iff, and_true, hnz]","error:  application type mismatch
  IsLittleO.def (hf' x xs)
argument
  hf' x xs
has type
  HasFDerivWithinAt f (f' x) s x : Prop
but is expected to have type
  (fun y ‚Ü¶ f y - f x - (f' x) (y - x)) =o[ùìù[s] x] fun y ‚Ü¶ y - x : Prop
warning:  `ContinuousLinearMap.le_op_norm` has been deprecated, use `ContinuousLinearMap.le_opNorm` instead
error:  unsolved goals
E : Type u_1
F‚úù : Type u_2
inst‚úù‚Åµ : NormedAddCommGroup E
inst‚úù‚Å¥ : NormedSpace ‚Ñù E
inst‚úù¬≥ : FiniteDimensional ‚Ñù E
inst‚úù¬≤ : NormedAddCommGroup F‚úù
inst‚úù¬π : NormedSpace ‚Ñù F‚úù
s‚úù : Set E
f‚úù : E ‚Üí E
f'‚úù : E ‚Üí E ‚ÜíL[‚Ñù] E
inst‚úù : SecondCountableTopology F‚úù
f : E ‚Üí F‚úù
s : Set E
f' : E ‚Üí E ‚ÜíL[‚Ñù] F‚úù
hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x
r : (E ‚ÜíL[‚Ñù] F‚úù) ‚Üí ‚Ñù‚â•0
rpos : ‚àÄ (A : E ‚ÜíL[‚Ñù] F‚úù), r A ‚â† 0
hs : s.Nonempty
T : Set ‚Üës
T_count : T.Countable
hT : ‚ãÉ x ‚àà T, ball (f' ‚Üëx) ‚Üë(r (f' ‚Üëx)) = ‚ãÉ x, ball (f' ‚Üëx) ‚Üë(r (f' ‚Üëx))
u : ‚Ñï ‚Üí ‚Ñù
left‚úù : StrictAnti u
u_pos : ‚àÄ (n : ‚Ñï), 0 < u n
u_lim : Tendsto u atTop (ùìù 0)
M : ‚Ñï ‚Üí ‚ÜëT ‚Üí Set E :=
  fun n z ‚Ü¶ {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - (f' ‚Üë‚Üëz) (y - x)‚Äñ ‚â§ ‚Üë(r (f' ‚Üë‚Üëz)) * ‚Äñy - x‚Äñ}
s_subset : ‚àÄ x ‚àà s, ‚àÉ n z, x ‚àà M n z
closure_M_subset : ‚àÄ (n : ‚Ñï) (z : ‚ÜëT), s ‚à© closure (M n z) ‚äÜ M n z
d : ‚Ñï ‚Üí E
hd : DenseRange d
K : ‚Ñï ‚Üí ‚ÜëT ‚Üí ‚Ñï ‚Üí Set E := fun n z p ‚Ü¶ closure (M n z) ‚à© closedBall (d p) (u n / 3)
K_approx : ‚àÄ (n : ‚Ñï) (z : ‚ÜëT) (p : ‚Ñï), ApproximatesLinearOn f (f' ‚Üë‚Üëz) (s ‚à© K n z p) (r (f' ‚Üë‚Üëz))
K_closed : ‚àÄ (n : ‚Ñï) (z : ‚ÜëT) (p : ‚Ñï), IsClosed (K n z p)
F : ‚Ñï ‚Üí ‚Ñï √ó ‚ÜëT √ó ‚Ñï
hF : Function.Surjective F
x : E
xs : x ‚àà s
n : ‚Ñï
z : ‚ÜëT
hnz : x ‚àà M n z
p : ‚Ñï
hp : x ‚àà closedBall (d p) (u n / 3)
q : ‚Ñï
hq : F q = (n, z, p)
‚ä¢ x ‚àà K n z p","theorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]
    (f : E ‚Üí F) (s : Set E) (f' : E ‚Üí E ‚ÜíL[‚Ñù] F) (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x)
    (r : (E ‚ÜíL[‚Ñù] F) ‚Üí ‚Ñù‚â•0) (rpos : ‚àÄ A, r A ‚â† 0) :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] F),
      (‚àÄ n, IsClosed (t n)) ‚àß
        (s ‚äÜ ‚ãÉ n, t n) ‚àß
          (‚àÄ n, ApproximatesLinearOn f (A n) (s ‚à© t n) (r (A n))) ‚àß
            (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) ",":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => 0, ?_, ?_, ?_, ?_‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' x)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, ?_‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ + ‚Äñf' x - f' z‚Äñ * ‚Äñy - x‚Äñ := by
        refine add_le_add (hŒ¥ ?_) (ContinuousLinearMap.le_opNorm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ‚â§ r (f' z) * ‚Äñy - x‚Äñ := by
        rw [‚Üê add_mul, add_comm]
        gcongr
  have closure_M_subset : ‚àÄ n z, s ‚à© closure (M n z) ‚äÜ M n z := by
    rintro n z x ‚ü®xs, hx‚ü©
    refine ‚ü®xs, fun y hy => ?_‚ü©
    obtain ‚ü®a, aM, a_lim‚ü© : ‚àÉ a : ‚Ñï ‚Üí E, (‚àÄ k, a k ‚àà M n z) ‚àß Tendsto a atTop (ùìù x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ‚Ñï => ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ) atTop
        (ùìù ‚Äñf y - f x - (f' z) (y - x)‚Äñ) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (ùìù (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ‚Ñï => (r (f' z) : ‚Ñù) * ‚Äñy - a k‚Äñ) atTop (ùìù (r (f' z) * ‚Äñy - x‚Äñ)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ‚àÄ·∂† k in atTop, ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ ‚â§ r (f' z) * ‚Äñy - a k‚Äñ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (ùìù (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ‚ü®hy.1, hk‚ü©
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ‚ü®d, hd‚ü©
  let K : ‚Ñï ‚Üí T ‚Üí ‚Ñï ‚Üí Set E := fun n z p => closure (M n z) ‚à© closedBall (d p) (u n / 3)
  have K_approx : ‚àÄ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ‚à© K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ‚àà M n z := closure_M_subset _ _ ‚ü®hy.1, hy.2.1‚ü©
    refine yM.2 _ ‚ü®hx.1, ?_‚ü©
    calc
      dist x y ‚â§ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ‚â§ u n / 3 + u n / 3 := add_le_add hx.2.2 hy.2.2
      _ < u n := by linarith [u_pos n]
  have K_closed : ‚àÄ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñï ‚Üí ‚Ñï √ó T √ó ‚Ñï, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases hs with ‚ü®x, xs‚ü©
      rcases s_subset x xs with ‚ü®n, z, _‚ü©
      exact ‚ü®z‚ü©
    inhabit ‚Ü•T
    exact ‚ü®_, Encodable.surjective_decode_iget (‚Ñï √ó T √ó ‚Ñï)‚ü©
  refine
    ‚ü®fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => ?_, fun q => K_approx _ _ _, fun _ q => ‚ü®(F q).2.1, (F q).2.1.1.2, rfl‚ü©‚ü©
  obtain ‚ü®n, z, hnz‚ü© : ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := s_subset x xs
  obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, x ‚àà closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, d p ‚àà ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ‚ü®p, (mem_ball'.1 hp).le‚ü©
  obtain ‚ü®q, hq‚ü© : ‚àÉ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ‚ü®q, _‚ü©
  simp (config := { zeta := false }) only [K, hq, mem_inter_iff, hp, and_true]
  exact subset_closure hnz",":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => 0, ?_, ?_, ?_, ?_‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' z)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, ?_‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñ"
Mathlib/MeasureTheory/Measure/Typeclasses.lean,MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top,countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top,7dbc4ee943ff99bb5a359e820806969fa45b18b0,":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only []
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine' countable_iUnion fun n => Finite.countable _
  refine' finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite",error:  simp made no progress,"theorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ {Œπ : Type*} {_ : MeasurableSpace Œ±}
    (Œº : Measure Œ±) {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, NullMeasurableSet (As i) Œº)
    (As_disj : Pairwise (AEDisjoint Œº on As)) (Union_As_finite : Œº (‚ãÉ i, As i) ‚â† ‚àû) :
    Set.Countable { i : Œπ | 0 < Œº (As i) } ",":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only [fairmeas]
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable ?_
  exact finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite",":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only []
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable _
  refine finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite"
Mathlib/Data/List/TFAE.lean,List.forall_tfae,forall_tfae,c932badd26769438b46c1ea96eb6e2d1fd7e0896,":= by
  simp_rw [TFAE, List.forall_mem_map_iff]
  intros p‚ÇÅ hp‚ÇÅ p‚ÇÇ hp‚ÇÇ
  exact forall_congr' fun a ‚Ü¶ H a (p‚ÇÅ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÅ)
    (p‚ÇÇ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÇ)","error:  unknown tactic
error:  unsolved goals
Œ± : Type u_1
l : List (Œ± ‚Üí Prop)
H : ‚àÄ (a : Œ±), (map (fun p ‚Ü¶ p a) l).TFAE
‚ä¢ (map (fun p ‚Ü¶ ‚àÄ (a : Œ±), p a) l).TFAE","theorem forall_tfae {Œ± : Type*} (l : List (Œ± ‚Üí Prop)) (H : ‚àÄ a : Œ±, (l.map (fun p ‚Ü¶ p a)).TFAE) :
    (l.map (fun p ‚Ü¶ ‚àÄ a, p a)).TFAE ",":= by
  simp only [TFAE, List.forall_mem_map_iff]
  intros p‚ÇÅ hp‚ÇÅ p‚ÇÇ hp‚ÇÇ
  exact forall_congr' fun a ‚Ü¶ H a (p‚ÇÅ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÅ)
    (p‚ÇÇ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÇ)",":= by
  simp_rw [List.forall_mem_map_iff]
  intros p‚ÇÅ hp‚ÇÅ p‚ÇÇ hp‚ÇÇ
  exact forall_congr' fun a ‚Ü¶ H a (p‚ÇÅ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÅ)
    (p‚ÇÇ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÇ)"
Mathlib/Analysis/InnerProductSpace/PiL2.lean,Orthonormal.exists_orthonormalBasis_extension,Orthonormal.exists_orthonormalBasis_extension,1aadd4f4012334f6f1cd811e685b9c75a27ee9ed,":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.finite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := Equiv.cast (congr_arg (‚Ü•) hu‚ÇÄ_finite.coe_toFinset)
  have hfu : ((‚Üë) : u ‚Üí E) = ((‚Üë) : u‚ÇÄ ‚Üí E) ‚àò fu := by ext; simp
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa [hfu] using hu‚ÇÄ.comp _ fu.injective
  refine' ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu _, _, _‚ü©
  ¬∑ simpa using hu‚ÇÄ_max
  ¬∑ simpa using hu‚ÇÄs
  ¬∑ simp","error:  unsolved goals
case h
Œπ : Type u_1
Œπ' : Type u_2
ùïú : Type u_3
inst‚úù¬π‚Å∞ : _root_.RCLike ùïú
E : Type u_4
inst‚úù‚Åπ : NormedAddCommGroup E
inst‚úù‚Å∏ : InnerProductSpace ùïú E
E' : Type u_5
inst‚úù‚Å∑ : NormedAddCommGroup E'
inst‚úù‚Å∂ : InnerProductSpace ùïú E'
F : Type u_6
inst‚úù‚Åµ : NormedAddCommGroup F
inst‚úù‚Å¥ : InnerProductSpace ‚Ñù F
F' : Type u_7
inst‚úù¬≥ : NormedAddCommGroup F'
inst‚úù¬≤ : InnerProductSpace ‚Ñù F'
inst‚úù¬π : Fintype Œπ
v : Set E
A : Œπ ‚Üí Submodule ùïú E
inst‚úù : FiniteDimensional ùïú E
hv : Orthonormal ùïú Subtype.val
u‚ÇÄ : Set E
hu‚ÇÄs : u‚ÇÄ ‚äá v
hu‚ÇÄ : Orthonormal ùïú Subtype.val
hu‚ÇÄ_max : (span ùïú u‚ÇÄ)·óÆ = ‚ä•
hu‚ÇÄ_finite : u‚ÇÄ.Finite
u : Finset E := hu‚ÇÄ_finite.toFinset
fu : { x // x ‚àà u } ‚âÉ ‚Üëu‚ÇÄ := Equiv.cast ‚ãØ
x‚úù : { x // x ‚àà u }
‚ä¢ ‚Üëx‚úù = ‚Üë(fu x‚úù)
error:  type mismatch
  h‚úù
has type
  span ùïú u‚ÇÄ = ‚ä§ : Prop
but is expected to have type
  span ùïú ‚Üëu = ‚ä§ : Prop
error:  type mismatch
  h‚úù
has type
  u‚ÇÄ ‚äá v : Prop
but is expected to have type
  v ‚äÜ ‚Üëu : Prop","theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal ùïú ((‚Üë) : v ‚Üí E)) :
    ‚àÉ (u : Finset E) (b : OrthonormalBasis u ùïú E), v ‚äÜ u ‚àß ‚áëb = ((‚Üë) : u ‚Üí E) ",":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.setFinite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_‚ü©
  ¬∑ simpa [u] using hu‚ÇÄ_max
  ¬∑ simpa [u] using hu‚ÇÄs
  ¬∑ simp",":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.finite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := Equiv.cast (congr_arg (‚Ü•) hu‚ÇÄ_finite.coe_toFinset)
  have hfu : ((‚Üë) : u ‚Üí E) = ((‚Üë) : u‚ÇÄ ‚Üí E) ‚àò fu := by ext; simp
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa [hfu] using hu‚ÇÄ.comp _ fu.injective
  refine ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_‚ü©
  ¬∑ simpa using hu‚ÇÄ_max
  ¬∑ simpa using hu‚ÇÄs
  ¬∑ simp"
Mathlib/Data/Rat/Defs.lean,Rat.divInt_mul_divInt_cancel,divInt_mul_divInt_cancel,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  by_cases hd : d = 0
  ¬∑ rw [hd]
    simp
  rw [divInt_mul_divInt _ _ hx hd, mul_comm x, divInt_mul_right hx]","error:  failed to synthesize
  CommMagma ‚Ñ§
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.31205
case neg
q a b c : ‚Ñö
x : ‚Ñ§
hx : x ‚â† 0
n d : ‚Ñ§
hd : ¬¨d = 0
‚ä¢ n * x /. (x * d) = n /. d",theorem divInt_mul_divInt_cancel {x : ‚Ñ§} (hx : x ‚â† 0) (n d : ‚Ñ§) : n /. x * (x /. d) = n /. d ,":= by
  by_cases hd : d = 0
  ¬∑ rw [hd]
    simp
  rw [divInt_mul_divInt _ _ hx hd, x.mul_comm, divInt_mul_right hx]",":= by
  by_cases hd : d = 0
  ¬∑ rw [hd]
    simp
  rw [divInt_mul_divInt _ _ hx hd, mul_comm x, divInt_mul_right hx]"
Mathlib/Probability/ConditionalProbability.lean,ProbabilityTheory.cond_cond_eq_cond_inter',cond_cond_eq_cond_inter',51625e908ad8a7478f13ad7a109d3bb32c2d610d,":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 :=
      le_antisymm (le_trans (measure_mono (Set.inter_subset_left _ _)) hst.le) bot_le
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (Œº.toOuterMeasure.pos_of_subset_ne_zero (Set.inter_subset_left _ _) hst).ne'
    simp [*, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Œº s)‚Åª¬π]","warning:  @cond does not have a doc string
warning:  @cond does not have a doc string
error:  function expected at
  inter_subset_left ?m.28251
term has type
  ?m.28250 ‚àà ?m.28248
warning:  `MeasureTheory.OuterMeasure.pos_of_subset_ne_zero` has been deprecated, use `MeasureTheory.measure_pos_of_superset` instead
error:  function expected at
  inter_subset_left ?m.30975
term has type
  ?m.30974 ‚àà ?m.30972","lemma cond_cond_eq_cond_inter' (hms : MeasurableSet s) (hmt : MeasurableSet t) (hcs : Œº s ‚â† ‚àû) :
    Œº[|s][|t] = Œº[|s ‚à© t] ",":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (measure_pos_of_superset Set.inter_subset_left hst).ne'
    simp [*, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Œº s)‚Åª¬π]",":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 :=
      le_antisymm (le_trans (measure_mono Set.inter_subset_left) hst.le) bot_le
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (Œº.toOuterMeasure.pos_of_subset_ne_zero (Set.inter_subset_left hst).ne'
    simp [*, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Œº s)‚Åª¬π]"
Mathlib/MeasureTheory/Integral/Periodic.lean,Function.Periodic.intervalIntegral_add_eq_of_pos,intervalIntegral_add_eq_of_pos,e80793ed2602b66d6dec49d0ef95cdf56a9ea10f,":= by
  simp only [integral_of_le, hT.le, le_add_iff_nonneg_right]
  haveI : VAddInvariantMeasure (AddSubgroup.zmultiples T) ‚Ñù volume :=
    ‚ü®fun c s _ => measure_preimage_add _ _ _‚ü©
  apply IsAddFundamentalDomain.set_integral_eq (G := AddSubgroup.zmultiples T)
  exacts [isAddFundamentalDomain_Ioc hT t, isAddFundamentalDomain_Ioc hT s, hf.map_vadd_zmultiples]",error:  unknown constant 'MeasureTheory.IsAddFundamentalDomain.set_integral_eq',"theorem intervalIntegral_add_eq_of_pos (hf : Periodic f T) (hT : 0 < T) (t s : ‚Ñù) :
    ‚à´ x in t..t + T, f x = ‚à´ x in s..s + T, f x ",":= by
  simp only [integral_of_le, hT.le, le_add_iff_nonneg_right]
  haveI : VAddInvariantMeasure (AddSubgroup.zmultiples T) ‚Ñù volume :=
    ‚ü®fun c s _ => measure_preimage_add _ _ _‚ü©
  apply IsAddFundamentalDomain.setIntegral_eq (G := AddSubgroup.zmultiples T)
  exacts [isAddFundamentalDomain_Ioc hT t, isAddFundamentalDomain_Ioc hT s, hf.map_vadd_zmultiples]",":=
  ‚ü®fun c s _ => measure_preimage_add _ _ _‚ü©
  apply IsAddFundamentalDomain.setIntegral_eq (G := AddSubgroup.zmultiples T)
  exacts [isAddFundamentalDomain_Ioc hT t, isAddFundamentalDomain_Ioc hT s, hf.map_vadd_zmultiples]"
Mathlib/RingTheory/MvPolynomial/Homogeneous.lean,MvPolynomial.IsHomogeneous.totalDegree_le,totalDegree_le,b271affacf1fa368c4e879d75cd5aaf54b75b7ed,":= by
  apply Finset.sup_le
  intro d hd
  rw [mem_support_iff] at hd
  rw [Finsupp.sum, hœÜ hd]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (weightedDegree 1) d
case a
œÉ : Type u_1
œÑ : Type u_2
R : Type u_3
S : Type u_4
inst‚úù¬≤ inst‚úù¬π : CommSemiring R
inst‚úù : CommSemiring S
œÜ œà : MvPolynomial œÉ R
m n : ‚Ñï
hœÜ : œÜ.IsHomogeneous n
d : œÉ ‚Üí‚ÇÄ ‚Ñï
hd : coeff d œÜ ‚â† 0
‚ä¢ ‚àë a ‚àà d.support, d a ‚â§ n",lemma totalDegree_le (hœÜ : IsHomogeneous œÜ n) : œÜ.totalDegree ‚â§ n ,":= by
  apply Finset.sup_le
  intro d hd
  rw [mem_support_iff] at hd
  rw [Finsupp.sum, ‚Üê hœÜ hd, weightedDegree_apply]
  simp only [Pi.one_apply, smul_eq_mul, mul_one]
  exact Nat.le.refl",":= by
  apply Finset.sup_le
  intro d hd
  rw [Finsupp.sum, hœÜ hd]"
Mathlib/Algebra/CharZero/Quotient.lean,AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div,zsmul_mem_zmultiples_iff_exists_sub_div,da32edd74856504ceb69ecabbf69a11fb5b1342b,":= by
  rw [AddSubgroup.mem_zmultiples_iff]
  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, ‚Üê smul_mul_assoc, eq_sub_iff_add_eq]
  have hz' : (z : R) ‚â† 0 := Int.cast_ne_zero.mpr hz
  conv_rhs => simp (config := { singlePass := true }) only [‚Üê (mul_right_injective‚ÇÄ hz').eq_iff]
  simp_rw [‚Üê zsmul_eq_mul, smul_add, ‚Üê mul_smul_comm, zsmul_eq_mul (z : R)‚Åª¬π, mul_inv_cancel hz',
    mul_one, ‚Üê coe_nat_zsmul, smul_smul, ‚Üê add_smul]
  constructor
  ¬∑ rintro ‚ü®k, h‚ü©
    simp_rw [‚Üê h]
    refine' ‚ü®‚ü®(k % z).toNat, _‚ü©, k / z, _‚ü©
    ¬∑ rw [‚Üê Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)
    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
    nth_rewrite 3 [‚Üê Int.div_add_mod k z]
    rw [Int.mod_def, ‚Üê Int.div_def', Int.emod_def]
    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']
  ¬∑ rintro ‚ü®k, n, h‚ü©
    exact ‚ü®_, h‚ü©
    AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div",error:  unknown tactic,"theorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : ‚Ñ§} (hz : z ‚â† 0) :
    z ‚Ä¢ r ‚àà AddSubgroup.zmultiples p ‚Üî
      ‚àÉ k : Fin z.natAbs, r - (k : ‚Ñï) ‚Ä¢ (p / z : R) ‚àà AddSubgroup.zmultiples p ",":= by
  rw [AddSubgroup.mem_zmultiples_iff]
  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, ‚Üê smul_mul_assoc, eq_sub_iff_add_eq]
  have hz' : (z : R) ‚â† 0 := Int.cast_ne_zero.mpr hz
  conv_rhs => simp (config := { singlePass := true }) only [‚Üê (mul_right_injective‚ÇÄ hz').eq_iff]
  simp_rw [‚Üê zsmul_eq_mul, smul_add, ‚Üê mul_smul_comm, zsmul_eq_mul (z : R)‚Åª¬π, mul_inv_cancel hz',
    mul_one, ‚Üê natCast_zsmul, smul_smul, ‚Üê add_smul]
  constructor
  ¬∑ rintro ‚ü®k, h‚ü©
    simp_rw [‚Üê h]
    refine ‚ü®‚ü®(k % z).toNat, ?_‚ü©, k / z, ?_‚ü©
    ¬∑ rw [‚Üê Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)
    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
    nth_rewrite 3 [‚Üê Int.ediv_add_emod k z]
    rfl
  ¬∑ rintro ‚ü®k, n, h‚ü©
    exact ‚ü®_, h‚ü©",":= by
  rw [AddSubgroup.mem_zmultiples_iff]
  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, ‚Üê smul_mul_assoc, eq_sub_iff_add_eq]
  have hz' : (z : R) ‚â† 0 := Int.cast_ne_zero.mpr hz
  conv_rhs => simp (config := { singlePass := true }) only [‚Üê (mul_right_injective‚ÇÄ hz').eq_iff]
  simp_rw [‚Üê zsmul_eq_mul, smul_add, ‚Üê mul_smul_comm, zsmul_eq_mul (z : R)‚Åª¬π, mul_inv_cancel hz',
    mul_one, ‚Üê coe_natCast, smul_smul, ‚Üê add_smul]
  constructor
  ¬∑ rintro ‚ü®k, h‚ü©
    simp_rw [‚Üê h]
    refine ‚ü®‚ü®(k % z).toNat, ?_‚ü©, k / z, ?_‚ü©
    ¬∑ rw [‚Üê Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)
    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
    nth_rewrite 3 [‚Üê Int.div_add_mod k z]
    rw [Int.mod_def, ‚Üê Int.div_def', Int.emod_def]
    simp only [add_sub_cancel_right, zsmul_eq_mul, Int.div_def']
  ¬∑ rintro ‚ü®k, n, h‚ü©
    exact ‚ü®_, h‚ü©
    AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div"
Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean,Finset.mul_pluennecke_petridis,mul_pluennecke_petridis,67ee3b7709353762fdc01cfb00722ee8c27ff6a5,":= by
  induction' C using Finset.induction_on with x C _ ih
  ¬∑ simp
  set A' := A ‚à© (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have h‚ÇÄ : A' * {x} = A * {x} ‚à© (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have h‚ÇÅ : A * B * C' = A * B * C ‚à™ (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine (sup_sdiff_eq_sup ?_).symm
    rw [mul_right_comm, mul_right_comm A, h‚ÇÄ]
    exact mul_subset_mul_right (inter_subset_right _ _)
  have h‚ÇÇ : A' * B * {x} ‚äÜ A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right <| inter_subset_left _ _)
  have h‚ÇÉ : (A * B * C').card ‚â§ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [h‚ÇÅ]
    refine (card_union_le _ _).trans_eq ?_
    rw [card_sdiff h‚ÇÇ, ‚Üê add_tsub_assoc_of_le (card_le_card h‚ÇÇ), card_mul_singleton,
      card_mul_singleton]
  refine (mul_le_mul_right' h‚ÇÉ _).trans ?_
  rw [tsub_mul, add_mul]
  refine (tsub_le_tsub (add_le_add_right ih _) <| hA _ <| inter_subset_left _ _).trans_eq ?_
  rw [‚Üê mul_add, ‚Üê mul_tsub, ‚Üê hA', hC', insert_eq, mul_union, ‚Üê card_mul_singleton A x, ‚Üê
    card_mul_singleton A' x, add_comm (card _), h‚ÇÄ,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]","error:  function expected at
  inter_subset_right ?m.23523
term has type
  ?m.23522 ‚àà ?m.23521
error:  function expected at
  inter_subset_left ?m.25626
term has type
  ?m.25625 ‚àà ?m.25623
error:  function expected at
  inter_subset_left ?m.30577
term has type
  ?m.30576 ‚àà ?m.30574
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  A ‚à© (A * C / {x})
case insert
Œ± : Type u_1
inst‚úù¬π : CommGroup Œ±
inst‚úù : DecidableEq Œ±
A B C‚úù : Finset Œ±
hA : ‚àÄ A' ‚äÜ A, (A * B).card * A'.card ‚â§ (A' * B).card * A.card
x : Œ±
C : Finset Œ±
a‚úù : x ‚àâ C
ih : (A * B * C).card * A.card ‚â§ (A * B).card * (A * C).card
A' : Finset Œ± := A ‚à© (A * C / {x})
hA' : A' = A ‚à© (A * C / {x})
C' : Finset Œ± := insert x C
hC' : C' = insert x C
h‚ÇÄ : A' * {x} = A * {x} ‚à© (A * C)
h‚ÇÅ : A * B * C' = A * B * C ‚à™ (A * B * {x}) \ (A' * B * {x})
h‚ÇÇ : A' * B * {x} ‚äÜ A * B * {x}
h‚ÇÉ : (A * B * C').card ‚â§ (A * B * C).card + (A * B).card - (A' * B).card
‚ä¢ (A * B).card * ((A * C).card + A.card - A'.card) = (A * B).card * (A * C').card","theorem mul_pluennecke_petridis (C : Finset Œ±)
    (hA : ‚àÄ A' ‚äÜ A, (A * B).card * A'.card ‚â§ (A' * B).card * A.card) :
    (A * B * C).card * A.card ‚â§ (A * B).card * (A * C).card ",":= by
  induction' C using Finset.induction_on with x C _ ih
  ¬∑ simp
  set A' := A ‚à© (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have h‚ÇÄ : A' * {x} = A * {x} ‚à© (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have h‚ÇÅ : A * B * C' = A * B * C ‚à™ (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine (sup_sdiff_eq_sup ?_).symm
    rw [mul_right_comm, mul_right_comm A, h‚ÇÄ]
    exact mul_subset_mul_right inter_subset_right
  have h‚ÇÇ : A' * B * {x} ‚äÜ A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right inter_subset_left)
  have h‚ÇÉ : (A * B * C').card ‚â§ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [h‚ÇÅ]
    refine (card_union_le _ _).trans_eq ?_
    rw [card_sdiff h‚ÇÇ, ‚Üê add_tsub_assoc_of_le (card_le_card h‚ÇÇ), card_mul_singleton,
      card_mul_singleton]
  refine (mul_le_mul_right' h‚ÇÉ _).trans ?_
  rw [tsub_mul, add_mul]
  refine (tsub_le_tsub (add_le_add_right ih _) <| hA _ inter_subset_left).trans_eq ?_
  rw [‚Üê mul_add, ‚Üê mul_tsub, ‚Üê hA', hC', insert_eq, mul_union, ‚Üê card_mul_singleton A x, ‚Üê
    card_mul_singleton A' x, add_comm (card _), h‚ÇÄ,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]",":= by
  induction' C using Finset.induction_on with x C _ ih
  ¬∑ simp
  set A' := A ‚à© (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have h‚ÇÄ : A' * {x} = A * {x} ‚à© (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have h‚ÇÅ : A * B * C' = A * B * C ‚à™ (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine (sup_sdiff_eq_sup ?_).symm
    rw [mul_right_comm, mul_right_comm A, h‚ÇÄ]
    exact mul_subset_mul_right inter_subset_right
  have h‚ÇÇ : A' * B * {x} ‚äÜ A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right inter_subset_left)
  have h‚ÇÉ : (A * B * C').card ‚â§ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [h‚ÇÅ]
    refine (card_union_le _ _).trans_eq ?_
    rw [card_sdiff h‚ÇÇ, ‚Üê add_tsub_assoc_of_le (card_le_card h‚ÇÇ), card_mul_singleton,
      card_mul_singleton]
  refine (mul_le_mul_right' h‚ÇÉ ?_).trans ?_
  rw [tsub_mul, add_mul]
  refine (tsub_le_tsub (add_le_add_right ih _) <| hA _ <| inter_subset_left).trans_eq ?_
  rw [‚Üê mul_add, ‚Üê mul_tsub, ‚Üê hA', hC', insert_eq, mul_union, ‚Üê card_mul_singleton A x, ‚Üê
    card_mul_singleton A' x, add_comm (card _), h‚ÇÄ,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicAt.iff_eventuallyEq_zpow_smul_analyticAt,iff_eventuallyEq_zpow_smul_analyticAt,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  refine ‚ü®fun ‚ü®n, hn‚ü© ‚Ü¶ ‚ü®-n, _, ‚ü®hn, eventually_nhdsWithin_iff.mpr ?_‚ü©‚ü©, ?_‚ü©
  ¬∑ filter_upwards with z hz
    rw [‚Üê mul_smul, ‚Üê zpow_ofNat, ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), add_left_neg,
      zpow_zero, one_smul]
  ¬∑ refine fun ‚ü®n, g, hg_an, hg_eq‚ü© ‚Ü¶ MeromorphicAt.congr ?_ (EventuallyEq.symm hg_eq)
    exact (((MeromorphicAt.id x).sub (.const _ x)).zpow _).smul hg_an.meromorphicAt","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a ^ OfNat.ofNat ?n
case refine_1.h
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí E
x : ùïú
x‚úù : MeromorphicAt f x
n : ‚Ñï
hn : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ n ‚Ä¢ f z) x
z : ùïú
hz : z ‚àà {x}·∂ú
‚ä¢ f z = ((z - x) ^ (-‚Üën) * (z - x) ^ n) ‚Ä¢ f z","lemma iff_eventuallyEq_zpow_smul_analyticAt {f : ùïú ‚Üí E} {x : ùïú} : MeromorphicAt f x ‚Üî
    ‚àÉ (n : ‚Ñ§) (g : ùïú ‚Üí E), AnalyticAt ùïú g x ‚àß ‚àÄ·∂† z in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z ",":= by
  refine ‚ü®fun ‚ü®n, hn‚ü© ‚Ü¶ ‚ü®-n, _, ‚ü®hn, eventually_nhdsWithin_iff.mpr ?_‚ü©‚ü©, ?_‚ü©
  ¬∑ filter_upwards with z hz
    rw [‚Üê mul_smul, ‚Üê zpow_natCast, ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), add_left_neg,
      zpow_zero, one_smul]
  ¬∑ refine fun ‚ü®n, g, hg_an, hg_eq‚ü© ‚Ü¶ MeromorphicAt.congr ?_ (EventuallyEq.symm hg_eq)
    exact (((MeromorphicAt.id x).sub (.const _ x)).zpow _).smul hg_an.meromorphicAt",":= by
  refine ‚ü®fun ‚ü®n, hn‚ü© ‚Ü¶ ‚ü®-n, _, ‚ü®hn, eventually_nhdsWithin_iff.mpr ?_‚ü©‚ü©, ?_‚ü©
  ¬∑ filter_upwards with z hz
    rw [‚Üê mul_smul, ‚Üê zpow_ofNat, ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), add_left_neg,
      zpow_zero, one_smul]
  ¬∑ refine fun ‚ü®n, g, hg_an, hg_eq‚ü© ‚Ü¶ MeromorphicAt.congr ?_ (EventuallyEq.symm hg_eq)
    exact (((MeromorphicAt.id x).sub (.const _ x)).zpow _).smul hg_an.meromorphicAt"
Mathlib/GroupTheory/Exponent.lean,Group.one_lt_exponent,Group.one_lt_exponent,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  let _inst := Fintype.ofFinite G
  obtain ‚ü®g, hg‚ü© := exists_ne (1 : G)
  rw [‚Üê Monoid.lcm_orderOf_eq_exponent]
  have hg' : 2 ‚â§ orderOf g := Nat.lt_of_le_of_ne (orderOf_pos g) <| by
    simpa [eq_comm, orderOf_eq_one_iff] using hg
  refine hg'.trans <| Nat.le_of_dvd ?_ <| Finset.dvd_lcm (by simp)
  rw [Nat.pos_iff_ne_zero, Ne.def, Finset.lcm_eq_zero_iff]
  rintro ‚ü®x, -, hx‚ü©
  exact (orderOf_pos x).ne' hx","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.80232 ‚Üí ?m.80232 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.80234
case intro
G : Type u
inst‚úù¬≤ : Group G
inst‚úù¬π : Finite G
inst‚úù : Nontrivial G
_inst : Fintype G := Fintype.ofFinite G
g : G
hg : g ‚â† 1
hg' : 2 ‚â§ orderOf g
‚ä¢ Finset.univ.lcm orderOf ‚â† 0",lemma Group.one_lt_exponent [Finite G] [Nontrivial G] : 1 < Monoid.exponent G ,":=
  Monoid.one_lt_exponent",":= by
  let _inst := Fintype.ofFinite G
  obtain ‚ü®g, hg‚ü© := exists_ne (1 : G)
  rw [‚Üê Monoid.lcm_orderOf_eq_exponent]
  have hg' : 2 ‚â§ orderOf g := Nat.lt_of_le_of_ne (orderOf_pos g) <| by
    simpa [eq_comm, orderOf_eq_one_iff] using hg
  refine hg'.trans <| Nat.le_of_dvd ?_ <| Finset.dvd_lcm (by simp)
  rw [Nat.pos_iff_ne_zero, Ne, Finset.lcm_eq_zero_iff]
  rintro ‚ü®x, -, hx‚ü©
  exact (orderOf_pos x).ne' hx"
Mathlib/Data/Complex/Exponential.lean,Complex.cos_add_sin_mul_I_pow,cos_add_sin_mul_I_pow,9b164dcaf39db774305ec5d27d811517b352a7b9,":= by
  rw [‚Üê exp_mul_I, ‚Üê exp_mul_I]
  induction' n with n ih
  ¬∑ rw [pow_zero, Nat.cast_zero, zero_mul, zero_mul, exp_zero]
  ¬∑ rw [pow_succ', ih, Nat.cast_succ, add_mul, add_mul, one_mul, exp_add]","error:  unsolved goals
case succ
x y z : ‚ÑÇ
n : ‚Ñï
ih : cexp (z * I) ^ n = cexp (‚Üën * z * I)
‚ä¢ cexp (z * I) * cexp (‚Üën * z * I) = cexp (‚Üën * z * I) * cexp (z * I)","theorem cos_add_sin_mul_I_pow (n : ‚Ñï) (z : ‚ÑÇ) :
    (cos z + sin z * I) ^ n = cos (‚Üën * z) + sin (‚Üën * z) * I ",":= by
  rw [‚Üê exp_mul_I, ‚Üê exp_mul_I]
  induction' n with n ih
  ¬∑ rw [pow_zero, Nat.cast_zero, zero_mul, zero_mul, exp_zero]
  ¬∑ rw [pow_succ, ih, Nat.cast_succ, add_mul, add_mul, one_mul, exp_add]",":= by
  rw [‚Üê exp_mul_I, ‚Üê exp_mul_I]
  induction' n with n ih
  ¬∑ rw [pow_zero, Nat.cast_zero, zero_mul, zero_mul, exp_zero]
  ¬∑ rw [pow_succ, ih, Nat.cast_succ, add_mul, add_mul, one_mul, exp_add]"
Mathlib/Topology/Separation.lean,loc_compact_Haus_tot_disc_of_zero_dim,loc_compact_Haus_tot_disc_of_zero_dim,3d6160e482fc7b12ad9350c18001a29bd2b3d8ce,":= by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.2) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := ((‚Üë) : s ‚Üí H) ‚Åª¬π' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, VisClopen, Vx, V_sub‚ü© := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine' ‚ü®comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.1, _‚ü©
    let v : Set u := ((‚Üë) : u ‚Üí s) ‚Åª¬π' V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine' ‚ü®f0, _‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_left interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.2.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  refine' ‚ü®(‚Üë) '' V, VisClopen', by simp [Vx], Subset.trans _ sU‚ü©
  simp","error:  tactic 'apply' failed, failed to unify
  interior ?m.223147 ‚à© ?m.223147 = interior ?m.223147
with
  s ‚à© interior s = interior s
X : Type u_1
Y : Type u_2
inst‚úù‚Å¥ : TopologicalSpace X
H : Type u_3
inst‚úù¬≥ : TopologicalSpace H
inst‚úù¬≤ : LocallyCompactSpace H
inst‚úù¬π : T2Space H
inst‚úù : TotallyDisconnectedSpace H
U : Set H
hU : IsOpen U
s : Set H
comp : IsCompact s
sU : s ‚äÜ U
u : Set ‚Üës := Subtype.val ‚Åª¬π' interior s
u_open_in_s : IsOpen u
x : { x // x ‚àà s }
memU : ‚Üëx ‚àà U
xs : ‚Üëx ‚àà interior s
this‚úù : CompactSpace ‚Üës
V : Set ‚Üës
VisClopen : IsClopen V
Vx : x ‚àà V
V_sub : V ‚äÜ u
v : Set ‚Üëu := Subtype.val ‚Åª¬π' V
this : (fun x ‚Ü¶ ‚Üë‚Üëx) = Subtype.val ‚àò Subtype.val
f0 : _root_.Embedding fun x ‚Ü¶ ‚Üë‚Üëx
‚ä¢ s ‚à© interior s = interior s
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  V ‚à© u
X : Type u_1
Y : Type u_2
inst‚úù‚Å¥ : TopologicalSpace X
H : Type u_3
inst‚úù¬≥ : TopologicalSpace H
inst‚úù¬≤ : LocallyCompactSpace H
inst‚úù¬π : T2Space H
inst‚úù : TotallyDisconnectedSpace H
U : Set H
hU : IsOpen U
s : Set H
comp : IsCompact s
sU : s ‚äÜ U
u : Set ‚Üës := Subtype.val ‚Åª¬π' interior s
u_open_in_s : IsOpen u
x : { x // x ‚àà s }
memU : ‚Üëx ‚àà U
xs : ‚Üëx ‚àà interior s
this‚úù : CompactSpace ‚Üës
V : Set ‚Üës
VisClopen : IsClopen V
Vx : x ‚àà V
V_sub : V ‚äÜ u
v : Set ‚Üëu := Subtype.val ‚Åª¬π' V
this : (fun x ‚Ü¶ ‚Üë‚Üëx) = Subtype.val ‚àò Subtype.val
f0 : _root_.Embedding fun x ‚Ü¶ ‚Üë‚Üëx
f1 : OpenEmbedding fun x ‚Ü¶ ‚Üë‚Üëx
f2 : IsOpen v
‚ä¢ Subtype.val '' V = Subtype.val '' (u ‚à© V)","theorem loc_compact_Haus_tot_disc_of_zero_dim [TotallyDisconnectedSpace H] :
    IsTopologicalBasis { s : Set H | IsClopen s } ",":= by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.2) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := ((‚Üë) : s ‚Üí H) ‚Åª¬π' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, VisClopen, Vx, V_sub‚ü© := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine ‚ü®comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.1, ?_‚ü©
    let v : Set u := ((‚Üë) : u ‚Üí s) ‚Åª¬π' V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine ‚ü®f0, ?_‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_right interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.2.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_right V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  use (‚Üë) '' V, VisClopen', by simp [Vx], Subset.trans (by simp) sU",":= by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.2) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := ((‚Üë) : s ‚Üí H) ‚Åª¬π' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, VisClopen, Vx, V_sub‚ü© := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine ‚ü®comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.1, ?_‚ü©
    let v : Set u := ((‚Üë) : u ‚Üí s) ‚Åª¬π' V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine ‚ü®f0, ?_‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_left interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.2.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  refine ‚ü®(‚Üë) '' V, VisClopen', by simp [Vx], Subset.trans ?_ sU‚ü©
  simp"
Mathlib/Analysis/SpecialFunctions/Complex/Circle.lean,Real.Angle.expMapCircle_neg,Real.Angle.expMapCircle_neg,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction Œ∏
  simp_rw [‚Üê Real.Angle.coe_neg, Real.Angle.expMapCircle_coe, _root_.expMapCircle_neg]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ∏ : Angle
‚ä¢ (-Œ∏).expMapCircle = Œ∏.expMapCircle‚Åª¬π","theorem Real.Angle.expMapCircle_neg (Œ∏ : Real.Angle) :
    Real.Angle.expMapCircle (-Œ∏) = (Real.Angle.expMapCircle Œ∏)‚Åª¬π ",":= by
  induction Œ∏ using Real.Angle.induction_on
  simp_rw [‚Üê Real.Angle.coe_neg, Real.Angle.expMapCircle_coe, _root_.expMapCircle_neg]",":= by
  induction Œ∏
  simp_rw [‚Üê Real.Angle.coe_neg, Real.Angle.expMapCircle_coe, _root_.expMapCircle_neg]"
Mathlib/LinearAlgebra/Matrix/Hermitian.lean,Matrix.isHermitian_zero,isHermitian_zero,1c643aca968064296312bf5328c84d0c50cfe5ae,":=
  IsSelfAdjoint.zero _","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsSelfAdjoint
has type
  ?m.13554 ‚Üí Prop",theorem isHermitian_zero : (0 : Matrix n n Œ±).IsHermitian ,":=
  isSelfAdjoint_zero _",":=
  IsSelfAdjoint.zero _"
Mathlib/Algebra/Order/BigOperators/Group/Multiset.lean,Multiset.prod_le_prod_map,prod_le_prod_map,571e842d55864d9e0851a5bc5675a71391b31d48,":=
  @prod_map_le_prod Œ±·µí·µà _ _ _ f h","error:  application type mismatch
  prod_map_le_prod ?m.5455 f
argument
  f
has type
  Œ± ‚Üí Œ± : Type u_2
but is expected to have type
  ‚àÄ x ‚àà ?m.5454, ?m.5455 x ‚â§ x : Prop","lemma prod_le_prod_map (f : Œ± ‚Üí Œ±) (h : ‚àÄ x, x ‚àà s ‚Üí x ‚â§ f x) : s.prod ‚â§ (s.map f).prod ",":=
  @prod_map_le_prod Œ±·µí·µà _ _ f h",":=
  @prod_map_le_prod _ _ _ f h"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,49b8ee5c731881e8d562a13d37f3ee3fd50b8092,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg ((¬∑ * ¬∑) œÅ) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_ad"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,a76dc22f3a90e5ab96e9284d30276a87a4324a5d,":= by
  refine' ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, _‚ü©, rfl‚ü©, _‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := IsIntegral.sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)","error:  function expected at
  le_integralClosure_iff_isIntegral.mp (adjoin_le_integralClosure (IsPrimitiveRoot.isIntegral hŒ∂ (PNat.pos (p ^ k))))
term has type
  Algebra.IsIntegral ‚Ñ§ ‚Ü•(adjoin ‚Ñ§ {Œ∂})
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë(?m ^ ?n)
case refine'_1.intro.intro
p : ‚Ñï+
k : ‚Ñï
K : Type u
inst‚úù¬π : Field K
inst‚úù : CharZero K
Œ∂ : K
hp : Fact (Nat.Prime ‚Üëp)
hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)
x : K
h : IsIntegral ‚Ñ§ x
B : PowerBasis ‚Ñö K := IsPrimitiveRoot.subOnePowerBasis ‚Ñö hŒ∂
hint : IsIntegral ‚Ñ§ B.gen
this : FiniteDimensional ‚Ñö K := finiteDimensional {p ^ k} ‚Ñö K
u : ‚Ñ§À£
n : ‚Ñï
hun : Algebra.discr ‚Ñö ‚áë(IsPrimitiveRoot.subOnePowerBasis ‚Ñö hŒ∂).basis = ‚Üë‚Üëu * ‚Üë‚Üëp ^ n
H : ‚Üë‚Üëp ^ n ‚Ä¢ x ‚àà adjoin ‚Ñ§ {B.gen}
‚ä¢ x ‚àà adjoin ‚Ñ§ {Œ∂}","theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)) : IsIntegralClosure (adjoin ‚Ñ§ ({Œ∂} : Set K)) ‚Ñ§ K ",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := IsIntegral.sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adj"
Mathlib/Topology/UniformSpace/UniformConvergence.lean,UniformCauchySeqOn.prod,UniformCauchySeqOn.prod,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  intro u hu
  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu
  obtain ‚ü®v, hv, w, hw, hvw‚ü© := hu
  simp_rw [mem_prod, Prod_map, and_imp, Prod.forall]
  rw [‚Üê Set.image_subset_iff] at hvw
  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono
  intro x hx a b ha hb
  exact hvw ‚ü®_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl‚ü©","warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  simp made no progress","theorem UniformCauchySeqOn.prod_map {Œπ' Œ±' Œ≤' : Type*} [UniformSpace Œ≤'] {F' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'}
    {p' : Filter Œπ'} {s' : Set Œ±'} (h : UniformCauchySeqOn F p s)
    (h' : UniformCauchySeqOn F' p' s') :
    UniformCauchySeqOn (fun i : Œπ √ó Œπ' => Prod.map (F i.1) (F' i.2)) (p √óÀ¢ p') (s √óÀ¢ s') ",":= by
  intro u hu
  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu
  obtain ‚ü®v, hv, w, hw, hvw‚ü© := hu
  simp_rw [mem_prod, and_imp, Prod.forall, Prod.map_apply]
  rw [‚Üê Set.image_subset_iff] at hvw
  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono
  intro x hx a b ha hb
  exact hvw ‚ü®_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl‚ü©",":= by
  intro u hu
  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu
  obtain ‚ü®v, hv, w, hw, hvw‚ü© := hu
  simp_rw [mem_prod, Prod_map, and_imp, Prod.forall]
  rw [‚Üê Set.image_subset_iff] at hvw
  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono
  intro x hx a b ha hb
  exact hvw ‚ü®_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl‚ü©"
Mathlib/Analysis/NormedSpace/QuaternionExponential.lean,Quaternion.hasSum_expSeries_of_imaginary,hasSum_expSeries_of_imaginary,29989664323235e82eaee87f0a17599c62b6e697,":= by
  replace hc := hasSum_coe.mpr hc
  replace hs := (hs.div_const ‚Äñq‚Äñ).smul_const q
  obtain rfl | hq0 := eq_or_ne q 0
  ¬∑ simp_rw [expSeries_apply_zero, norm_zero, div_zero, zero_smul, add_zero]
    simp_rw [norm_zero] at hc
    convert hc using 1
    ext (_ | n) : 1
    ¬∑ rw [pow_zero, Nat.zero_eq, MulZeroClass.mul_zero, pow_zero, Nat.factorial_zero, Nat.cast_one,
        div_one, one_mul, Pi.single_eq_same, coe_one]
    ¬∑ rw [zero_pow (mul_pos two_pos (Nat.succ_pos _)), MulZeroClass.mul_zero, zero_div,
        Pi.single_eq_of_ne n.succ_ne_zero, coe_zero]
  simp_rw [expSeries_apply_eq]
  have hq2 : q ^ 2 = -normSq q := sq_eq_neg_normSq.mpr hq
  have hqn := norm_ne_zero_iff.mpr hq0
  refine' HasSum.even_add_odd _ _
  ¬∑ convert hc using 1
    ext n : 1
    letI k : ‚Ñù := ‚Üë(2 * n)!
    calc
      k‚Åª¬π ‚Ä¢ q ^ (2 * n) = k‚Åª¬π ‚Ä¢ (-normSq q) ^ n := by rw [pow_mul, hq2]; norm_cast
      _ = k‚Åª¬π ‚Ä¢ ‚Üë((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n)) := ?_
      _ = ‚Üë((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n) / k) := ?_
    ¬∑ congr 1
      rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq]
      push_cast
      rfl
    ¬∑ rw [‚Üê coe_mul_eq_smul, div_eq_mul_inv]
      norm_cast
      ring_nf
  ¬∑ convert hs using 1
    ext n : 1
    let k : ‚Ñù := ‚Üë(2 * n + 1)!
    calc
      k‚Åª¬π ‚Ä¢ q ^ (2 * n + 1) = k‚Åª¬π ‚Ä¢ ((-normSq q) ^ n * q) := by
        rw [pow_succ', pow_mul, hq2]
        norm_cast
      _ = k‚Åª¬π ‚Ä¢ ((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n)) ‚Ä¢ q := ?_
      _ = ((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n + 1) / k / ‚Äñq‚Äñ) ‚Ä¢ q := ?_
    ¬∑ congr 1
      rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq, ‚Üê coe_mul_eq_smul]
    ¬∑ rw [smul_smul]
      congr 1
      simp_rw [pow_succ', mul_div_assoc, div_div_cancel_left' hqn]
      ring","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case h.e'_5.h.zero
c s : ‚Ñù
hq : re 0 = 0
hs : HasSum (fun z ‚Ü¶ ((-1) ^ z * ‚Äñ0‚Äñ ^ (2 * z + 1) / ‚Üë(2 * z + 1)! / ‚Äñ0‚Äñ) ‚Ä¢ 0) ((s / ‚Äñ0‚Äñ) ‚Ä¢ 0)
hc : HasSum (fun a ‚Ü¶ ‚Üë((-1) ^ a * 0 ^ (2 * a) / ‚Üë(2 * a)!)) ‚Üëc
‚ä¢ Pi.single 0 1 0 = ‚Üë(1 * 0 ^ (2 * 0) / ‚Üë(2 * 0)!)
error:  application type mismatch
  zero_pow (mul_pos ?m.39247 (Nat.succ_pos ?m.39364))
argument
  mul_pos ?m.39247 (Nat.succ_pos ?m.39364)
has type
  0 < ?m.36565 * ?m.39364.succ : Prop
but is expected to have type
  ?m.36562 ‚â† 0 : Prop
error:  no goals to be solved
error:  unsolved goals
q : ‚Ñç
hq : q.re = 0
c s : ‚Ñù
hc : HasSum (fun a ‚Ü¶ ‚Üë((-1) ^ a * ‚Äñq‚Äñ ^ (2 * a) / ‚Üë(2 * a)!)) ‚Üëc
hs : HasSum (fun z ‚Ü¶ ((-1) ^ z * ‚Äñq‚Äñ ^ (2 * z + 1) / ‚Üë(2 * z + 1)! / ‚Äñq‚Äñ) ‚Ä¢ q) ((s / ‚Äñq‚Äñ) ‚Ä¢ q)
hq0 : q ‚â† 0
hq2 : q ^ 2 = -‚Üë(normSq q)
hqn : ‚Äñq‚Äñ ‚â† 0
n : ‚Ñï
k : ‚Ñù := ‚Üë(2 * n + 1)!
‚ä¢ k‚Åª¬π ‚Ä¢ (q * ‚Üë((-normSq q) ^ n)) = k‚Åª¬π ‚Ä¢ (‚Üë((-normSq q) ^ n) * q)
error:  unsolved goals
case h.e'_5.h.calc_1.e_a
q : ‚Ñç
hq : q.re = 0
c s : ‚Ñù
hc : HasSum (fun a ‚Ü¶ ‚Üë((-1) ^ a * ‚Äñq‚Äñ ^ (2 * a) / ‚Üë(2 * a)!)) ‚Üëc
hs : HasSum (fun z ‚Ü¶ ((-1) ^ z * ‚Äñq‚Äñ ^ (2 * z + 1) / ‚Üë(2 * z + 1)! / ‚Äñq‚Äñ) ‚Ä¢ q) ((s / ‚Äñq‚Äñ) ‚Ä¢ q)
hq0 : q ‚â† 0
hq2 : q ^ 2 = -‚Üë(normSq q)
hqn : ‚Äñq‚Äñ ‚â† 0
n : ‚Ñï
k : ‚Ñù := ‚Üë(2 * n + 1)!
‚ä¢ (-1) ^ n * ‚Üë(‚Äñq‚Äñ * ‚Äñq‚Äñ) ^ n * q = ‚Üë((-1) ^ n * (‚Äñq‚Äñ * ‚Äñq‚Äñ) ^ n) * q
error:  simp made no progress","theorem hasSum_expSeries_of_imaginary {q : Quaternion ‚Ñù} (hq : q.re = 0) {c s : ‚Ñù}
    (hc : HasSum (fun n => (-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n) / (2 * n)!) c)
    (hs : HasSum (fun n => (-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n + 1) / (2 * n + 1)!) s) :
    HasSum (fun n => expSeries ‚Ñù (Quaternion ‚Ñù) n fun _ => q) (‚Üëc + (s / ‚Äñq‚Äñ) ‚Ä¢ q) ",":= by
  replace hc := hasSum_coe.mpr hc
  replace hs := (hs.div_const ‚Äñq‚Äñ).smul_const q
  refine HasSum.even_add_odd ?_ ?_
  ¬∑ convert hc using 1
    ext n : 1
    rw [expSeries_even_of_imaginary hq]
  ¬∑ convert hs using 1
    ext n : 1
    rw [expSeries_odd_of_imaginary hq]",":= by
  replace hc := hasSum_coe.mpr hc
  replace hs := (hs.div_const ‚Äñq‚Äñ).smul_const q
  obtain rfl | hq0 := eq_or_ne q 0
  ¬∑ simp_rw [expSeries_apply_zero, norm_zero, div_zero, zero_smul, add_zero]
    simp_rw [norm_zero] at hc
    convert hc using 1
    ext (_ | n) : 1
    ¬∑ rw [pow_zero, Nat.zero_eq, MulZeroClass.mul_zero, pow_zero, Nat.factorial_zero, Nat.cast_one,
        div_one, one_mul, Pi.single_eq_same, coe_one]
    ¬∑ rw [zero_pow (mul_pos two_pos (Nat.succ_pos _)), MulZeroClass.mul_zero, zero_div,
        Pi.single_eq_of_ne n.succ_ne_zero, coe_zero]
  simp_rw [expSeries_apply_eq]
  have hq2 : q ^ 2 = -normSq q := sq_eq_neg_normSq.mpr hq
  have hqn := norm_ne_zero_iff.mpr hq0
  refine HasSum.even_add_odd ?_ ?_
  ¬∑ convert hc using 1
    ext n : 1
    letI k : ‚Ñù := ‚Üë(2 * n)!
    calc
      k‚Åª¬π ‚Ä¢ q ^ (2 * n) = k‚Åª¬π ‚Ä¢ (-normSq q) ^ n := by rw [pow_mul, hq2]; norm_cast
      _ = k‚Åª¬π ‚Ä¢ ‚Üë((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n)) := ?_
      _ = ‚Üë((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n) / k) := ?_
    ¬∑ congr 1
      rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq, ‚Üê coe_mul_eq_smul]
    ¬∑ rw [smul_smul]
      congr 1
      simp_rw [pow_succ', mul_div_assoc, div_div_cancel_left' hqn]
      ring"
Mathlib/Order/Filter/Archimedean.lean,Filter.Tendsto.const_mul_atTop',Tendsto.const_mul_atTop',9a5e0ce9f9b714fd5383610a12746cded21f030f,":= by
  refine' tendsto_atTop.2 fun b => _
  obtain ‚ü®n : ‚Ñï, hn : 1 ‚â§ n ‚Ä¢ r‚ü© := Archimedean.arch 1 hr
  rw [nsmul_eq_mul'] at hn
  filter_upwards [tendsto_atTop.1 hf (n * max b 0)]with x hx
  calc
    b ‚â§ 1 * max b 0 := by
    { rw [one_mul]
      exact le_max_left _ _ }
    _ ‚â§ r * n * max b 0 := by rel_congr
    _ = r * (n * max b 0) := by rw [mul_assoc]
    _ ‚â§ r * f x := by rel_congr","error:  unknown tactic
error:  unsolved goals
Œ± : Type u_1
R : Type u_2
l : Filter Œ±
f : Œ± ‚Üí R
r : R
inst‚úù¬π : LinearOrderedSemiring R
inst‚úù : Archimedean R
hr : 0 < r
hf : Tendsto f l atTop
b : R
n : ‚Ñï
hn : 1 ‚â§ r * ‚Üën
x : Œ±
hx : ‚Üën * max b 0 ‚â§ f x
‚ä¢ 1 * max b 0 ‚â§ r * ‚Üën * max b 0
error:  unsolved goals
case h.calc.step
Œ± : Type u_1
R : Type u_2
l : Filter Œ±
f : Œ± ‚Üí R
r : R
inst‚úù¬π : LinearOrderedSemiring R
inst‚úù : Archimedean R
hr : 0 < r
hf : Tendsto f l atTop
b : R
n : ‚Ñï
hn : 1 ‚â§ r * ‚Üën
x : Œ±
hx : ‚Üën * max b 0 ‚â§ f x
‚ä¢ r * ‚Üën * max b 0 ‚â§ r * f x","theorem Tendsto.const_mul_atTop' (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atTop ",":= by
  refine tendsto_atTop.2 fun b => ?_
  obtain ‚ü®n : ‚Ñï, hn : 1 ‚â§ n ‚Ä¢ r‚ü© := Archimedean.arch 1 hr
  rw [nsmul_eq_mul'] at hn
  filter_upwards [tendsto_atTop.1 hf (n * max b 0)] with x hx
  calc
    b ‚â§ 1 * max b 0 := by
    { rw [one_mul]
      exact le_max_left _ _ }
    _ ‚â§ r * n * max b 0 := by gcongr
    _ = r * (n * max b 0) := by rw [mul_assoc]
    _ ‚â§ r * f x := by gcongr",":= by
  refine tendsto_atTop.2 fun b => ?_
  obtain ‚ü®n : ‚Ñï, hn : 1 ‚â§ n ‚Ä¢ r‚ü© := Archimedean.arch 1 hr
  rw [nsmul_eq_mul'] at hn
  filter_upwards [tendsto_atTop.1 hf (n * max b 0)]with x hx
  calc
    b ‚â§ 1 * max b 0 := by
    { rw [one_mul]
      exact le_max_left _ _ }
    _ ‚â§ r * n * max b 0 := by rel_congr
    _ = r * (n * max b 0) := by rw [mul_assoc]
    _ ‚â§ r * f x := by rel_congr"
Mathlib/MeasureTheory/Integral/CircleIntegral.lean,circleIntegral.integral_sub_zpow_of_ne,integral_sub_zpow_of_ne,e92ad7acc4d771729f70601a74a3c091f330e507,":= by
  rcases em (w ‚àà sphere c (|R|) ‚àß n < -1) with (‚ü®hw, hn‚ü© | H)
  ¬∑ exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : ‚àÄ z, z ‚â† w ‚à® -1 ‚â§ n ‚Üí
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    ¬∑ have hn' : (n + 1 : ‚ÑÇ) ‚â† 0 := by
        rwa [Ne, ‚Üê eq_neg_iff_add_eq_zero, ‚Üê Int.cast_one, ‚Üê Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_left _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine' integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z _).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h ‚ñ∏ hz","error:  application type mismatch
  mul_div_cancel_left ?m.192024 hn'
argument
  hn'
has type
  ‚Üën + 1 ‚â† 0 : Prop
but is expected to have type
  ?m.192022 : Type ?u.192021
error:  unsolved goals
case h.e'_7
E : Type u_1
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚ÑÇ E
inst‚úù : CompleteSpace E
n : ‚Ñ§
hn : n ‚â† -1
c w : ‚ÑÇ
R : ‚Ñù
H : w ‚àà sphere c |R| ‚Üí -1 ‚â§ n
z : ‚ÑÇ
hne : z ‚â† w ‚à® -1 ‚â§ n
hn' : ‚Üën + 1 ‚â† 0
‚ä¢ (z - w) ^ n = (‚Üën + 1) * (z - w) ^ n / (‚Üën + 1)","theorem integral_sub_zpow_of_ne {n : ‚Ñ§} (hn : n ‚â† -1) (c w : ‚ÑÇ) (R : ‚Ñù) :
    (‚àÆ z in C(c, R), (z - w) ^ n) = 0 ",":= by
  rcases em (w ‚àà sphere c |R| ‚àß n < -1) with (‚ü®hw, hn‚ü© | H)
  ¬∑ exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : ‚àÄ z, z ‚â† w ‚à® -1 ‚â§ n ‚Üí
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    ¬∑ have hn' : (n + 1 : ‚ÑÇ) ‚â† 0 := by
        rwa [Ne, ‚Üê eq_neg_iff_add_eq_zero, ‚Üê Int.cast_one, ‚Üê Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_left‚ÇÄ _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z ?_).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h ‚ñ∏ hz",":= by
  rcases em (w ‚àà sphere c (|R|) ‚àß n < -1) with (‚ü®hw, hn‚ü© | H)
  ¬∑ exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : ‚àÄ z, z ‚â† w ‚à® -1 ‚â§ n ‚Üí
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    ¬∑ have hn' : (n + 1 : ‚ÑÇ) ‚â† 0 := by
        rwa [Ne, ‚Üê eq_neg_iff_add_eq_zero, ‚Üê Int.cast_one, ‚Üê Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_left _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z ?_).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h ‚ñ∏ hz"
Mathlib/NumberTheory/NumberField/Embeddings.lean,NumberField.Embeddings.pow_eq_one_of_norm_eq_one,pow_eq_one_of_norm_eq_one,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ ¬∑ : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  ¬∑ wlog hlt : b < a
    ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
    refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
    rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
    refine h.resolve_right fun hp => ?_
    specialize hx (IsAlgClosed.lift (NumberField.isAlgebraic K)).toRingHom
    rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsAlgClosed.lift ?m.50146
has type
  ?m.49328
error:  application type mismatch
  IsAlgClosed.lift ‚ãØ
argument
  NumberField.isAlgebraic K
has type
  Algebra.IsAlgebraic ‚Ñö K : Prop
but is expected to have type
  ?m.49333 : Type ?u.49325","theorem pow_eq_one_of_norm_eq_one {x : K} (hxi : IsIntegral ‚Ñ§ x) (hx : ‚àÄ œÜ : K ‚Üí+* A, ‚ÄñœÜ x‚Äñ = 1) :
    ‚àÉ (n : ‚Ñï) (_ : 0 < n), x ^ n = 1 ",":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ ¬∑ : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  wlog hlt : b < a
  ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
  refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
  rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
  refine h.resolve_right fun hp => ?_
  specialize hx (IsAlgClosed.lift (R := ‚Ñö)).toRingHom
  rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx",":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ ¬∑ : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  ¬∑ wlog hlt : b < a
    ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
    refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
    rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
    refine h.resolve_right fun hp => ?_
    specialize hx (IsAlgClosed.lift (NumberField.isAlgebraic K)).toRingHom
    rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.mul_le_addHaar_image_of_lt_det,mul_le_addHaar_image_of_lt_det,66c0098b0b62ad14d9c618b402e7673658137a7e,":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine' Tendsto.mul (tendsto_const_nhds.mul _) tendsto_id
      refine' (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ _
      simpa only [tsub_zero, inv_eq_zero, Ne.def] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toPartialEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target by
    change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne.def] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne.def, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.195426 ‚Üí ?m.195426 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  ‚Äñ‚ÜëB.symm‚Äñ‚Çä ‚â† 0 : Prop
but is expected to have type
  ‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π ‚â† 0 : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.205019 ‚Üí ?m.205019 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  m ‚â† 0 : Prop
but is expected to have type
  ‚Üëm ‚â† 0 : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.205286 ‚Üí ?m.205286 ‚Üí Prop
error:  simp made no progress","theorem mul_le_addHaar_image_of_lt_det (A : E ‚ÜíL[‚Ñù] E) {m : ‚Ñù‚â•0}
    (hm : (m : ‚Ñù‚â•0‚àû) < ENNReal.ofReal |A.det|) :
    ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù‚â•0),
      ‚àÄ (s : Set E) (f : E ‚Üí E), ApproximatesLinearOn f A s Œ¥ ‚Üí (m : ‚Ñù‚â•0‚àû) * Œº s ‚â§ Œº (f '' s) ",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ filter_upwards
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_eq_zero, Ne] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toPartialEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target by
    change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, tsub_zero] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, tsub_zero, tsub_zero, tsub_zero] using tendsto_const_nhds
      refine Tendsto.mul ("
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,166d0bf5448fdaad518cf95891af45e08a3e9c35,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniforml"
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,925559df7538f58188bf3ba42208c10426adbafd,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      refine' ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      refine' ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine' ‚ü®U, {j}, _, _‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa
    ¬∑ simp
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ (e) (_he : e ‚àà G), j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine' ‚ü®j, V, _, _‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine' this _ _ _ (univ _) (inter _) _
      intro e he
      dsimp
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      rw [‚Üê coe_comp, D.w]
      rfl","error:  unknown identifier 'isTopologicalBasis_iInf'
error:  no goals to be solved","theorem isTopologicalBasis_cofiltered_limit (T : ‚àÄ j, Set (Set (F.obj j)))
    (hT : ‚àÄ j, IsTopologicalBasis (T j)) (univ : ‚àÄ i : J, Set.univ ‚àà T i)
    (inter : ‚àÄ (i) (U1 U2 : Set (F.obj i)), U1 ‚àà T i ‚Üí U2 ‚àà T i ‚Üí U1 ‚à© U2 ‚àà T i)
    (compat : ‚àÄ (i j : J) (f : i ‚ü∂ j) (V : Set (F.obj j)) (_hV : V ‚àà T j), F.map f ‚Åª¬π' V ‚àà T i) :
    IsTopologicalBasis
      {U : Set C.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = C.œÄ.app j ‚Åª¬π' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [‚Üê coe_comp, D.w] 
      rfl",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      refine ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      refine ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa
    ¬∑ simp
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ (e) (_he : e ‚àà G), j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
      dsimp
      rw [dif_pos he]
      exact compat j e (g e h)"
Mathlib/Data/Fin/Basic.lean,Fin.le_of_castSucc_lt_of_succ_lt,le_of_castSucc_lt_of_succ_lt,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,:= (castSucc_lt_iff_succ_le.mp hl).trans_lt' hu,"warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  type mismatch
  LE.le.trans_lt' ?m.30597 ?m.30846
has type
  @LT.lt (Fin (n + 1)) Preorder.toLT b a : Prop
but is expected to have type
  @LT.lt (Fin (n + 1)) instLTFin b a : Prop","theorem le_of_castSucc_lt_of_succ_lt {a b : Fin (n + 1)} {i : Fin n}
    (hl : castSucc i < a) (hu : b < succ i) : b < a ",":= by
  simp [Fin.lt_def, -val_fin_lt] at *; omega",:= castSucc_lt_iff_succ_le.mp hl
Mathlib/Analysis/Analytic/Constructions.lean,formalMultilinearSeries_geometric_apply_norm,formalMultilinearSeries_geometric_apply_norm,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  ContinuousMultilinearMap.norm_mkPiAlgebraFin (Ei := fun _ ‚Ü¶ A)",error:  invalid argument name 'Ei' for function 'ContinuousMultilinearMap.norm_mkPiAlgebraFin',"lemma formalMultilinearSeries_geometric_apply_norm (n : ‚Ñï) :
    ‚ÄñformalMultilinearSeries_geometric ùïú A n‚Äñ = 1 ",":=
  ContinuousMultilinearMap.norm_mkPiAlgebraFin",":=
  ContinuousMultilinearMap.norm_mkPiAlgebraFin (Ei := fun _ ‚Ü¶ A)"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.mul_measure_le_of_subset_lt_limRatioMeas,mul_measure_le_of_subset_lt_limRatioMeas,9e34a191034458a56331f976ff7400a26407c888,":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº t·∂ú = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t);
  exact
    calc
      (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
      _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := (measure_union_le _ _)
      _ ‚â§ œÅ (s ‚à© t) + q * Œº t·∂ú := by
        apply add_le_add H
        rw [coe_nnreal_smul_apply]
        exact mul_le_mul_left' (measure_mono (inter_subset_right _ _)) _
      _ ‚â§ œÅ s := by
        rw [A, MulZeroClass.mul_zero, add_zero]; exact measure_mono (inter_subset_left _ _)
  refine' v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ _
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le",error:  unexpected token ';'; expected 'by' or 'from',"theorem mul_measure_le_of_subset_lt_limRatioMeas {q : ‚Ñù‚â•0} {s : Set Œ±}
    (h : s ‚äÜ {x | (q : ‚Ñù‚â•0‚àû) < v.limRatioMeas hœÅ x}) : (q : ‚Ñù‚â•0‚àû) * Œº s ‚â§ œÅ s ",":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº t·∂ú = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t) by calc
    (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
    _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := measure_union_le _ _
    _ ‚â§ œÅ (s ‚à© t) + (q ‚Ä¢ Œº) t·∂ú := by gcongr; apply inter_subset_right
    _ = œÅ (s ‚à© t) := by simp [A]
    _ ‚â§ œÅ s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ ?_
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le",":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº t·∂ú = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t) by
    calc
      (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
      _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := measure_union_le _ _
      _ ‚â§ œÅ (s ‚à© t) + q * Œº t·∂ú := by
        apply add_le_add H
        rw [coe_nnreal_smul_apply]
        exact mul_le_mul_left' (measure_mono inter_subset_right) _
      _ ‚â§ œÅ s := by
        rw [A, MulZeroClass.mul_zero, add_zero]; exact measure_mono inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) ?_ ?_
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/MeasureTheory/Function/ContinuousMapDense.lean,MeasureTheory.Mem‚Ñíp.exists_hasCompactSupport_integral_rpow_sub_le,Mem‚Ñíp.exists_hasCompactSupport_integral_rpow_sub_le,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  have I : 0 < Œµ ^ (1 / p) := Real.rpow_pos_of_pos hŒµ _
  have A : ENNReal.ofReal (Œµ ^ (1 / p)) ‚â† 0 := by
    simp only [Ne.def, ENNReal.ofReal_eq_zero, not_le, I]
  have B : ENNReal.ofReal p ‚â† 0 := by simpa only [Ne.def, ENNReal.ofReal_eq_zero, not_le] using hp
  rcases hf.exists_hasCompactSupport_snorm_sub_le ENNReal.coe_ne_top A with
    ‚ü®g, g_support, hg, g_cont, g_mem‚ü©
  change snorm _ (ENNReal.ofReal p) _ ‚â§ _ at hg
  refine' ‚ü®g, g_support, _, g_cont, g_mem‚ü©
  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,
    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,
    Real.rpow_le_rpow_iff _ hŒµ.le (inv_pos.2 hp)] at hg
  exact integral_nonneg fun x => Real.rpow_nonneg_of_nonneg (norm_nonneg _) _","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.36991 ‚Üí ?m.36991 ‚Üí Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.37136 ‚Üí ?m.37136 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  0 < p : Prop
but is expected to have type
  ENNReal.ofReal p ‚â† 0 : Prop
error:  unknown constant 'Real.rpow_nonneg_of_nonneg'","theorem Mem‚Ñíp.exists_hasCompactSupport_integral_rpow_sub_le
    [WeaklyLocallyCompactSpace Œ±] [Œº.Regular]
    {p : ‚Ñù} (hp : 0 < p) {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f (ENNReal.ofReal p) Œº) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :
    ‚àÉ g : Œ± ‚Üí E,
      HasCompactSupport g ‚àß
        (‚à´ x, ‚Äñf x - g x‚Äñ ^ p ‚àÇŒº) ‚â§ Œµ ‚àß Continuous g ‚àß Mem‚Ñíp g (ENNReal.ofReal p) Œº ",":= by
  have I : 0 < Œµ ^ (1 / p) := Real.rpow_pos_of_pos hŒµ _
  have A : ENNReal.ofReal (Œµ ^ (1 / p)) ‚â† 0 := by
    simp only [Ne, ENNReal.ofReal_eq_zero, not_le, I]
  have B : ENNReal.ofReal p ‚â† 0 := by simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hp
  rcases hf.exists_hasCompactSupport_snorm_sub_le ENNReal.coe_ne_top A with
    ‚ü®g, g_support, hg, g_cont, g_mem‚ü©
  change snorm _ (ENNReal.ofReal p) _ ‚â§ _ at hg
  refine ‚ü®g, g_support, ?_, g_cont, g_mem‚ü©
  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,
    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,
    Real.rpow_le_rpow_iff _ hŒµ.le (inv_pos.2 hp)] at hg
  positivity",":= by
  have I : 0 < Œµ ^ (1 / p) := Real.rpow_pos_of_pos hŒµ _
  have A : ENNReal.ofReal (Œµ ^ (1 / p)) ‚â† 0 := by
    simp only [Ne, ENNReal.ofReal_eq_zero, not_le, I]
  have B : ENNReal.ofReal p ‚â† 0 := by simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hp
  rcases hf.exists_hasCompactSupport_snorm_sub_le ENNReal.coe_ne_top A with
    ‚ü®g, g_support, hg, g_cont, g_mem‚ü©
  change snorm _ (ENNReal.ofReal p) _ ‚â§ _ at hg
  refine ‚ü®g, g_support, ?_, g_cont, g_mem‚ü©
  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,
    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,
    Real.rpow_le_rpow_iff _ hŒµ.le (inv_pos.2 hp)] at hg
  exact integral_nonneg fun x => Real.rpow_nonneg_of_nonneg (norm_nonneg _) _"
Mathlib/CategoryTheory/Closed/Functor.lean,CategoryTheory.frobeniusMorphism_iso_of_expComparison_iso,frobeniusMorphism_iso_of_expComparison_iso,20c0686cf053be713b40d93c23f03f412d1d6066,":= by
  rw [‚Üê frobeniusMorphism_mate F h] at i
  exact @Conjugates_of_iso _ _ _ _ _ _ _ _ _ _ _ i",error:  unknown identifier 'Conjugates_of_iso',"theorem frobeniusMorphism_iso_of_expComparison_iso (h : L ‚ä£ F) (A : C)
    [i : IsIso (expComparison F A)] : IsIso (frobeniusMorphism F h A) ",":= by
  rw [‚Üê frobeniusMorphism_mate F h] at i
  exact @transferNatTransSelf_of_iso _ _ _ _ _ _ _ _ _ _ _ i",":= by
  rw [‚Üê frobeniusMorphism_mate F h] at i
  exact @Conjugates_of_iso _ _ _ _ _ _ _ _ i"
Mathlib/Algebra/Module/Submodule/LinearMap.lean,LinearMap.restrict_commute,restrict_commute,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  change _ * _ = _ * _
  conv_lhs => rw [mul_eq_comp, ‚Üê restrict_comp]; congr; rw [‚Üê mul_eq_comp, h.eq]","error:  unsolved goals
R : Type u_1
R‚ÇÅ : Type u_2
R‚ÇÇ : Type u_3
R‚ÇÉ : Type u_4
M : Type u_5
M‚ÇÅ : Type u_6
M‚ÇÇ : Type u_7
M‚ÇÉ : Type u_8
Œπ : Type u_9
inst‚úù¬π¬π : Semiring R
inst‚úù¬π‚Å∞ : Semiring R‚ÇÇ
inst‚úù‚Åπ : Semiring R‚ÇÉ
inst‚úù‚Å∏ : AddCommMonoid M
inst‚úù‚Å∑ : AddCommMonoid M‚ÇÅ
inst‚úù‚Å∂ : AddCommMonoid M‚ÇÇ
inst‚úù‚Åµ : AddCommMonoid M‚ÇÉ
inst‚úù‚Å¥ : Module R M
inst‚úù¬≥ : Module R M‚ÇÅ
inst‚úù¬≤ : Module R‚ÇÇ M‚ÇÇ
inst‚úù¬π : Module R‚ÇÉ M‚ÇÉ
œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ
œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ
œÉ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ
inst‚úù : RingHomCompTriple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ
f‚úù : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ
g‚úù : M‚ÇÇ ‚Üí‚Çõ‚Çó[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ
f g : M ‚Üí‚Çó[R] M
h : Commute f g
p : Submodule R M
hf : MapsTo ‚áëf ‚Üëp ‚Üëp
hg : MapsTo ‚áëg ‚Üëp ‚Üëp
‚ä¢ (g * f).restrict ‚ãØ = g.restrict hg * f.restrict hf","lemma restrict_commute {f g : M ‚Üí‚Çó[R] M} (h : Commute f g) {p : Submodule R M}
    (hf : MapsTo f p p) (hg : MapsTo g p p) :
    Commute (f.restrict hf) (g.restrict hg) ",":= by
  change _ * _ = _ * _
  conv_lhs => rw [mul_eq_comp, ‚Üê restrict_comp]; congr; rw [‚Üê mul_eq_comp, h.eq]
  rfl",":= by
  change _ * _ = _ * _
  conv_lhs => rw [mul_eq_comp, ‚Üê restrict_comp]; congr; rw [‚Üê mul_eq_comp, h.eq]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,a8a39f2a9556ea47ea96518d2df01a0c62fc8289,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg ((¬∑ * ¬∑) œÅ) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finran"
Mathlib/Algebra/Lie/BaseChange.lean,LieSubmodule.lie_baseChange,lie_baseChange,fc0107e21675a8298fc7ac3cc6e26f680430b1b5,":= by
  set s : Set (A ‚äó[R] M) := { m | ‚àÉ x ‚àà I, ‚àÉ n ‚àà N, 1 ‚äó‚Çú ‚ÅÖx, n‚ÅÜ = m}
  have : (TensorProduct.mk R A M 1) '' {m | ‚àÉ x ‚àà I, ‚àÉ n ‚àà N, ‚ÅÖx, n‚ÅÜ = m} = s := by ext; simp
  rw [‚Üê coe_toSubmodule_eq_iff, coe_baseChange, lieIdeal_oper_eq_linear_span',
    Submodule.baseChange_span, this, lieIdeal_oper_eq_linear_span']
  refine le_antisymm (Submodule.span_mono ?_) (Submodule.span_le.mpr ?_)
  ¬∑ rintro - ‚ü®x, hx, m, hm, rfl‚ü©
    exact ‚ü®1 ‚äó‚Çú x, tmul_mem_baseChange_of_mem 1 hx,
           1 ‚äó‚Çú m, tmul_mem_baseChange_of_mem 1 hm, by simp‚ü©
  ¬∑ rintro - ‚ü®x, hx, m, hm, rfl‚ü©
    revert m
    apply Submodule.span_induction
      (p := fun x' ‚Ü¶ ‚àÄ m' ‚àà N.baseChange A, ‚ÅÖx', m'‚ÅÜ ‚àà Submodule.span A s) hx
    ¬∑ rintro _ ‚ü®y : L, hy : y ‚àà I, rfl‚ü© m hm
      apply Submodule.span_induction (p := fun m' ‚Ü¶ ‚ÅÖ(1 : A) ‚äó‚Çú[R] y, m'‚ÅÜ ‚àà Submodule.span A s) hm
      ¬∑ rintro - ‚ü®m', hm' : m' ‚àà N, rfl‚ü©
        rw [TensorProduct.mk_apply, LieAlgebra.ExtendScalars.bracket_tmul, mul_one]
        apply Submodule.subset_span
        exact ‚ü®y, hy, m', hm', rfl‚ü©
      ¬∑ simp
      ¬∑ intro u v hu hv
        rw [lie_add]
        exact Submodule.add_mem _ hu hv
      ¬∑ intro a u hu
        rw [lie_smul]
        exact Submodule.smul_mem _ a hu
    ¬∑ simp
    ¬∑ intro x y hx hy m' hm'
      rw [add_lie]
      exact Submodule.add_mem _ (hx _ hm') (hy _ hm')
    ¬∑ intro a x hx m' hm'
      rw [smul_lie]
      exact Submodule.smul_mem _ a (hx _ hm')","error:  unsolved goals
case h
R : Type u_1
A : Type u_2
L : Type u_3
M : Type u_4
inst‚úù‚Å∏ : CommRing R
inst‚úù‚Å∑ : LieRing L
inst‚úù‚Å∂ : LieAlgebra R L
inst‚úù‚Åµ : AddCommGroup M
inst‚úù‚Å¥ : Module R M
inst‚úù¬≥ : LieRingModule L M
inst‚úù¬≤ : LieModule R L M
inst‚úù¬π : CommRing A
inst‚úù : Algebra R A
N‚úù : LieSubmodule R L M
I : LieIdeal R L
N : LieSubmodule R L M
s : Set (A ‚äó[R] M) := {m | ‚àÉ x ‚àà I, ‚àÉ n ‚àà N, 1 ‚äó‚Çú[R] ‚ÅÖx, n‚ÅÜ = m}
x‚úù : A ‚äó[R] M
‚ä¢ (‚àÉ a ‚àà I, ‚àÉ b ‚àà N, 1 ‚äó‚Çú[R] ‚ÅÖa, b‚ÅÜ = x‚úù) ‚Üî x‚úù ‚àà s","lemma lie_baseChange {I : LieIdeal R L} {N : LieSubmodule R L M} :
    ‚ÅÖI, N‚ÅÜ.baseChange A = ‚ÅÖI.baseChange A, N.baseChange A‚ÅÜ ",":= by
  set s : Set (A ‚äó[R] M) := { m | ‚àÉ x ‚àà I, ‚àÉ n ‚àà N, 1 ‚äó‚Çú ‚ÅÖx, n‚ÅÜ = m}
  have : (TensorProduct.mk R A M 1) '' {m | ‚àÉ x ‚àà I, ‚àÉ n ‚àà N, ‚ÅÖx, n‚ÅÜ = m} = s := by ext; simp [s]
  rw [‚Üê coe_toSubmodule_eq_iff, coe_baseChange, lieIdeal_oper_eq_linear_span',
    Submodule.baseChange_span, this, lieIdeal_oper_eq_linear_span']
  refine le_antisymm (Submodule.span_mono ?_) (Submodule.span_le.mpr ?_)
  ¬∑ rintro - ‚ü®x, hx, m, hm, rfl‚ü©
    exact ‚ü®1 ‚äó‚Çú x, tmul_mem_baseChange_of_mem 1 hx,
           1 ‚äó‚Çú m, tmul_mem_baseChange_of_mem 1 hm, by simp‚ü©
  ¬∑ rintro - ‚ü®x, hx, m, hm, rfl‚ü©
    revert m
    apply Submodule.span_induction
      (p := fun x' ‚Ü¶ ‚àÄ m' ‚àà N.baseChange A, ‚ÅÖx', m'‚ÅÜ ‚àà Submodule.span A s) hx
    ¬∑ rintro _ ‚ü®y : L, hy : y ‚àà I, rfl‚ü© m hm
      apply Submodule.span_induction (p := fun m' ‚Ü¶ ‚ÅÖ(1 : A) ‚äó‚Çú[R] y, m'‚ÅÜ ‚àà Submodule.span A s) hm
      ¬∑ rintro - ‚ü®m', hm' : m' ‚àà N, rfl‚ü©
        rw [TensorProduct.mk_apply, LieAlgebra.ExtendScalars.bracket_tmul, mul_one]
        apply Submodule.subset_span
        exact ‚ü®y, hy, m', hm', rfl‚ü©
      ¬∑ simp
      ¬∑ intro u v hu hv
        rw [lie_add]
        exact Submodule.add_mem _ hu hv
      ¬∑ intro a u hu
        rw [lie_smul]
        exact Submodule.smul_mem _ a hu
    ¬∑ simp
    ¬∑ intro x y hx hy m' hm'
      rw [add_lie]
      exact Submodule.add_mem _ (hx _ hm') (hy _ hm')
    ¬∑ intro a x hx m' hm'
      rw [smul_lie]
      exact Submodule.smul_mem _ a (hx _ hm')",":= by
  set s : Set (A ‚äó[R] M) := { m | ‚àÉ x ‚àà I, ‚àÉ n ‚àà N, 1 ‚äó‚Çú ‚ÅÖx, n‚ÅÜ = m}
  have : (TensorProduct.mk R A M 1) '' {m | ‚àÉ x ‚àà I, ‚àÉ n ‚àà N, ‚ÅÖx, n‚ÅÜ = m} = s := by ext; simp
  rw [‚Üê coe_toSubmodule_eq_iff, coe_baseChange, lieIdeal_oper_eq_linear_span',
    Submodule.baseChange_span, this, lieIdeal_oper_eq_linear_span']
  refine le_antisymm (Submodule.span_mono ?_) (Submodule.span_le.mpr ?_)
  ¬∑ rintro - ‚ü®x, hx, m, hm, rfl‚ü©
    exact ‚ü®1 ‚äó‚Çú x, tmul_mem_baseChange_of_mem 1 hx,
          1 ‚äó‚Çú m, tmul_mem_baseChange_of_mem 1 hm, by simp‚ü©
  ¬∑ rintro - ‚ü®x, hx, m, hm, rfl‚ü©
    revert m
    apply Submodule.span_induction
      (p := fun x' ‚Ü¶ ‚àÄ m' ‚àà N.baseChange A, ‚ÅÖx', m'‚ÅÜ ‚àà Submodule.span A s) hx
    ¬∑ rintro _ ‚ü®y : L, hy : y ‚àà I, rfl‚ü© m hm
      apply Submodule.span_induction (p := fun m' ‚Ü¶ ‚ÅÖ(1 : A) ‚äó‚Çú[R] y, m'‚ÅÜ ‚àà Submodule.span A s) hm
      ¬∑ rintro - ‚ü®m', hm' : m' ‚àà N, rfl‚ü©
        rw [TensorProduct.mk_apply, LieAlgebra.ExtendScalars.bracket_tmul, mul_one]
        apply Submodule.subset_span
        exact ‚ü®y, hy, m', hm', rfl‚ü©
      ¬∑ simp
      ¬∑ intro u v hu hv
        rw [lie_add]
        exact Submodule.add_mem _ hu hv
      ¬∑ intro a u hu
        rw [lie_smul]
        exact Submodule.smul_mem _ a hu
    ¬∑ simp
    ¬∑ intro x y hx hy m' hm'
      rw [add_lie]
      exact Submodule.add_mem _ (hx _ hm') (hy _ hm')
    ¬∑ intro a x hx m' hm'
      rw [smul_lie]
      exact Submodule.smul_mem _ a (hx _ hm')"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 ‚Üí ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 ‚Üí ?m.124403
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.132197 ‚Üí ?m.132197 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.132333 ‚Üí ?m.132333 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/Data/Set/Function.lean,Equiv.bijOn',bijOn',ea1b2576466eb49ae109b64acf312f52285dafce,":=
  ‚ü®h‚ÇÅ, e.injective.injOn _, fun b hb ‚Ü¶ ‚ü®e.symm b, h‚ÇÇ hb, apply_symm_apply _ _‚ü©‚ü©","error:  application type mismatch
  And.intro (Injective.injOn (Equiv.injective e) ?m.142457)
argument
  Injective.injOn (Equiv.injective e) ?m.142457
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Œ±‚¶Ñ, x‚ÇÇ ‚àà ?m.142455 ‚Üí e ?m.142456 = e x‚ÇÇ ‚Üí ?m.142456 = x‚ÇÇ : Prop
but is expected to have type
  InjOn (‚áëe) s : Prop",lemma bijOn' (h‚ÇÅ : MapsTo e s t) (h‚ÇÇ : MapsTo e.symm t s) : BijOn e s t ,":=
  ‚ü®h‚ÇÅ, e.injective.injOn, fun b hb ‚Ü¶ ‚ü®e.symm b, h‚ÇÇ hb, apply_symm_apply _ _‚ü©‚ü©",":=
  ‚ü®h‚ÇÅ, e.injective.injOn, fun b hb ‚Ü¶ ‚ü®e.symm b, h‚ÇÇ hb, apply_symm_apply _ _‚ü©‚ü©"
Mathlib/Topology/Sheaves/SheafCondition/UniqueGluing.lean,TopCat.Presheaf.isSheaf_iff_isSheafUniqueGluing_types,isSheaf_iff_isSheafUniqueGluing_types,6fc8e6ec44a01eed01778e1f6cfe13cab42118b2,":=
  Iff.intro (isSheafUniqueGluing_of_isSheaf_types F) (isSheaf_of_isSheafUniqueGluing_types F)","error:  unknown identifier 'isSheafUniqueGluing_of_isSheaf_types'
error:  unknown identifier 'isSheaf_of_isSheafUniqueGluing_types'",theorem isSheaf_iff_isSheafUniqueGluing_types : F.IsSheaf ‚Üî F.IsSheafUniqueGluing ,":= by
  simp_rw [isSheaf_iff_isSheafPairwiseIntersections, IsSheafPairwiseIntersections,
    Types.isLimit_iff, IsSheafUniqueGluing, isGluing_iff_pairwise]
  refine forall‚ÇÇ_congr fun Œπ U ‚Ü¶ ‚ü®fun h sf cpt ‚Ü¶ ?_, fun h s hs ‚Ü¶ ?_‚ü©
  ¬∑ exact h _ cpt.sectionPairwise.prop
  ¬∑ specialize h (fun i ‚Ü¶ s <| op <| Pairwise.single i) fun i j ‚Ü¶
      (hs <| op <| Pairwise.Hom.left i j).trans (hs <| op <| Pairwise.Hom.right i j).symm
    convert h; ext (i|‚ü®i,j‚ü©)
    ¬∑ rfl
    ¬∑ exact (hs <| op <| Pairwise.Hom.left i j).symm",":=
  Iff.intro (isSheafUniqueGluing_of_isSheaf_types F)"
Mathlib/Algebra/Order/Monoid/WithTop.lean,WithBot.coe_nsmul,coe_nsmul,554c20d1eb6d2f1f6a5b53ccd3a727a93147a4de,":=
  (addHom : Œ± ‚Üí+ WithTop Œ±).map_nsmul _ _",error:  unknown identifier 'addHom',lemma coe_nsmul (a : Œ±) (n : ‚Ñï) : ‚Üë(n ‚Ä¢ a) = n ‚Ä¢ (a : WithTop Œ±) ,:= rfl,":=
  (addHom : Œ± ‚Üí+ WithTop Œ±).map_nsmul _ _"
Mathlib/Data/Fin/Tuple/Basic.lean,Fin.isSome_find_iff,isSome_find_iff,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,"  | 0, p, _ => iff_of_false (fun h ‚Ü¶ Bool.noConfusion h) fun ‚ü®i, _‚ü© ‚Ü¶ Fin.elim0' i
  | n + 1, p, _ =>
    ‚ü®fun h ‚Ü¶ by
      rw [Option.isSome_iff_exists] at h
      cases' h with i hi
      exact ‚ü®i, find_spec _ hi‚ü©, fun ‚ü®‚ü®i, hin‚ü©, hi‚ü© ‚Ü¶ by
      dsimp [find]
      cases' h : find fun i : Fin n ‚Ü¶ p (i.castLT (Nat.lt_succ_of_lt i.2)) with j
      ¬∑ split_ifs with hl
        ¬∑ exact Option.isSome_some
        ¬∑ have := (@isSome_find_iff n (fun x ‚Ü¶ p (x.castLT (Nat.lt_succ_of_lt x.2))) _).2
              ‚ü®‚ü®i, lt_of_le_of_ne (Nat.le_of_lt_succ hin) fun h ‚Ü¶ by cases h; exact hl hi‚ü©, hi‚ü©
          rw [h] at this
          exact this
      ¬∑ simp‚ü©",error:  unknown constant 'Fin.elim0'',"theorem isSome_find_iff :
    ‚àÄ {n : ‚Ñï} {p : Fin n ‚Üí Prop} [DecidablePred p], (find p).isSome ‚Üî ‚àÉ i, p i
","  | 0, p, _ => iff_of_false (fun h ‚Ü¶ Bool.noConfusion h) fun ‚ü®i, _‚ü© ‚Ü¶ Fin.elim0 i
  | n + 1, p, _ =>
    ‚ü®fun h ‚Ü¶ by
      rw [Option.isSome_iff_exists] at h
      cases' h with i hi
      exact ‚ü®i, find_spec _ hi‚ü©, fun ‚ü®‚ü®i, hin‚ü©, hi‚ü© ‚Ü¶ by
      dsimp [find]
      cases' h : find fun i : Fin n ‚Ü¶ p (i.castLT (Nat.lt_succ_of_lt i.2)) with j
      ¬∑ split_ifs with hl
        ¬∑ exact Option.isSome_some
        ¬∑ have := (@isSome_find_iff n (fun x ‚Ü¶ p (x.castLT (Nat.lt_succ_of_lt x.2))) _).2
              ‚ü®‚ü®i, lt_of_le_of_ne (Nat.le_of_lt_succ hin) fun h ‚Ü¶ by cases h; exact hl hi‚ü©, hi‚ü©
          rw [h] at this
          exact this
      ¬∑ simp‚ü©",":= | 0, p, _ => iff_of_false (fun h ‚Ü¶ Bool.noConfusion h) fun ‚ü®i, _‚ü© ‚Ü¶ Fin.elim0' i
  | n + 1, p, _ =>
    ‚ü®fun h ‚Ü¶ by
      rw [Option.isSome_iff_exists] at h
      cases' h with i hi
      exact ‚ü®i, find_spec _ hi‚ü©, fun ‚ü®‚ü®i, hin‚ü©, hi‚ü© ‚Ü¶ by
      dsimp [find]
      cases' h : find fun i : Fin n ‚Ü¶ p (i.castLT (Nat.lt_succ_of_lt i.2)) with j
      ¬∑ split_ifs with hl
        ¬∑ exact Option.isSome_some
        ¬∑ have := (@isSome_find_iff n (fun x ‚Ü¶ p (x.castLT (Nat.lt_succ_of_lt x.2))) _).2
              ‚ü®‚ü®i, lt_of_le_of_ne (Nat.le_of_lt_succ hin) fun h ‚Ü¶ by cases h; exact hl hi‚ü©, hi‚ü©
          rw [h] at this
          exact this
      ¬∑ simp‚ü©"
Mathlib/AlgebraicGeometry/Spec.lean,AlgebraicGeometry.Spec.sheafedSpaceMap_id,Spec.sheafedSpaceMap_id,9fe8df0e363b05d86962c4bfbd8514bd00253a97,":=
  AlgebraicGeometry.PresheafedSpace.Hom.ext _ _ (Spec.topMap_id R) <| by
    ext
    dsimp
    erw [comap_id (by simp)]
    simp
    rfl",error:  no goals to be solved,"theorem Spec.sheafedSpaceMap_id {R : CommRingCat.{u}} :
    Spec.sheafedSpaceMap (ùüô R) = ùüô (Spec.sheafedSpaceObj R) ",":=
  AlgebraicGeometry.PresheafedSpace.Hom.ext _ _ (Spec.topMap_id R) <| by
    ext
    dsimp
    erw [comap_id (by simp)]
    simp",":=
  AlgebraicGeometry.PresheafedSpace.Hom.ext _ _ (Spec.topMap_id R) <| by
    ext
    erw [comap_id (by simp)]
    simp
    rfl"
Mathlib/Data/Nat/ModEq.lean,Nat.ModEq.cancel_left_div_gcd',cancel_left_div_gcd',0c7d6fa5bb16b4a1ca9eaa97c01bce48bcac90d5,:=,"warning:  ModEq does not have a doc string
error:  unexpected token 'lemma'; expected term","lemma cancel_left_div_gcd' (hm : 0 < m) (hcd : c ‚â° d [MOD m]) (h : c * a ‚â° d * b [MOD m]) :
    a ‚â° b [MOD m / gcd m c] ",":=
  (h.trans <| hcd.symm.mul_right b).cancel_left_div_gcd hm",":= by
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h
  rw [modEq_zero_iff_dvd] at h"
Mathlib/Geometry/Manifold/VectorBundle/Basic.lean,Bundle.contMDiffWithinAt_totalSpace,contMDiffWithinAt_totalSpace,2c616cf6d72eab2cc0cb8be21b40be572f4b56bf,":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp_def,
    LocalEquiv.trans_apply, LocalEquiv.prod_coe, LocalEquiv.refl_coe, extChartAt_self_apply,
    modelWithCornersSelf_coe, id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, LocalHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]","error:  unknown identifier 'LocalEquiv.trans_apply'
error:  simp made no progress","theorem contMDiffWithinAt_totalSpace (f : M ‚Üí TotalSpace F E) {s : Set M} {x‚ÇÄ : M} :
    ContMDiffWithinAt IM (IB.prod ùìò(ùïú, F)) n f s x‚ÇÄ ‚Üî
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s x‚ÇÄ ‚àß
      ContMDiffWithinAt IM ùìò(ùïú, F) n (fun x ‚Ü¶ (trivializationAt F E (f x‚ÇÄ).proj (f x)).2) s x‚ÇÄ ",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,
    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, ‚Üê chartedSpaceSelf_prod]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp_def,
    LocalEquiv.trans_apply, LocalEquiv.prod_coe, LocalEquiv.refl_coe, extChartAt_self_apply,
    modelWithCornersSelf_coe, id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, LocalHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.aemeasurable_fderivWithin,aemeasurable_fderivWithin,60e2ebb714fa61b2422f9c1cd4cff5fd09169c21,":= by
  refine' aemeasurable_of_unif_approx fun Œµ Œµpos => _
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, _‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
              (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine' ‚ü®g, g_meas.aemeasurable, _‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n => Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ
  ¬∑ have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine' ae_sum_iff.2 fun n => _
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono (inter_subset_left _ _)
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono (inter_subset_right _ _) le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem aemeasurable_fderivWithin (hs : MeasurableSet s)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (Œº.restrict s) ",":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, _‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
              (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ‚ü®g, g_meas.aemeasurable, ?_‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n ‚Ü¶ Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1",":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, ?_‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
             (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ‚ü®g, g_meas.aemeasurable, ?_‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n => Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1"
Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean,Path.Homotopy.continuous_transReflReparamAux,continuous_transReflReparamAux,4da4e0ebfbf51ecc2e064d04970434177efdead3,":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn? _) (Continuous.continuousOn ?_) ?_ <;>
    [continuity; continuity; continuity; continuity; skip]
  intro x hx
  simp [hx]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Continuous
has type
  (?m.154440 ‚Üí ?m.154441) ‚Üí Prop
error:  too many tactics
warning:  fundamentalGroupoidFunctor does not have a doc string",theorem continuous_transReflReparamAux : Continuous transReflReparamAux ,":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_ <;>
    [continuity; continuity; continuity; continuity; skip]
  intro x hx
  simp [hx]",":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_ <;>
    [continuity; continuity; continuity; continuity; skip]
  intro x hx
  simp [hx]"
Mathlib/Topology/Metrizable/Urysohn.lean,TopologicalSpace.exists_inducing_l_infty,exists_inducing_l_infty,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono (inter_subset_left _ _)).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine' ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, _‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine' ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm _ _‚ü©
  ¬∑ refine' (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => _
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine' (eventually_all_finite h_fin).2 fun UV _ => _
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine' this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => _
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine' ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 _
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine' ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => _‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV
    exact (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _","error:  unexpected identifier; expected '|'
error:  unsolved goals
case intro.intro.refine'_2.intro.intro.intro.intro
X : Type u_1
inst‚úù¬≤ : TopologicalSpace X
inst‚úù¬π : RegularSpace X
inst‚úù : SecondCountableTopology X
B : Set (Set X)
hBc : B.Countable
hB : IsTopologicalBasis B
s : Set (Set X √ó Set X) := {UV | UV ‚àà B √óÀ¢ B ‚àß closure UV.1 ‚äÜ UV.2}
this‚úù¬π : Encodable ‚Üës
this‚úù : TopologicalSpace ‚Üës := ‚ä•
this : DiscreteTopology ‚Üës
hd : ‚àÄ (UV : ‚Üës), Disjoint (closure (‚ÜëUV).1) (‚ÜëUV).2·∂ú
Œµ : ‚Üës ‚Üí ‚Ñù
Œµ01 : ‚àÄ (UV : ‚Üës), Œµ UV ‚àà Ioc 0 1
hŒµ : Tendsto Œµ cofinite (ùìù 0)
f : ‚Üës ‚Üí C(X, ‚Ñù)
hf0 : ‚àÄ (UV : ‚Üës), EqOn (‚áë(f UV)) 0 (‚ÜëUV).1
hfŒµ : ‚àÄ (UV : ‚Üës), EqOn (‚áë(f UV)) (fun x ‚Ü¶ Œµ UV) (‚ÜëUV).2·∂ú
hf0Œµ : ‚àÄ (UV : ‚Üës) (x : X), (f UV) x ‚àà Icc 0 (Œµ UV)
hf01 : ‚àÄ (UV : ‚Üës) (x : X), (f UV) x ‚àà Icc 0 1
F : X ‚Üí ‚Üës ‚Üí·µá ‚Ñù := fun x ‚Ü¶ { toFun := fun UV ‚Ü¶ (f UV) x, continuous_toFun := ‚ãØ, map_bounded' := ‚ãØ }
hF : ‚àÄ (x : X) (UV : ‚Üës), (F x) UV = (f UV) x
x : X
V : Set X
hVB : V ‚àà B
hxV : x ‚àà V
U : Set X
hUB : U ‚àà B
hxU : x ‚àà U
hUV : closure U ‚äÜ V
UV : ‚Üës := ‚ü®(U, V), ‚ãØ‚ü©
y : X
hy : dist ((F y) UV) ((F x) UV) < Œµ UV
‚ä¢ y ‚àà V","theorem exists_inducing_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Inducing f ",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => ?_
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => ?_‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.isometry_extend (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV"
Mathlib/MeasureTheory/Measure/FiniteMeasureProd.lean,MeasureTheory.FiniteMeasure.prod_apply_symm,prod_apply_symm,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp [Measure.prod_apply_symm s_mble]","error:  simp made no progress
error:  simp made no progress","lemma prod_apply_symm (s : Set (Œ± √ó Œ≤)) (s_mble : MeasurableSet s) :
    Œº.prod ŒΩ s = ENNReal.toNNReal (‚à´‚Åª y, Œº.toMeasure ((fun x ‚Ü¶ ‚ü®x, y‚ü©) ‚Åª¬π' s) ‚àÇŒΩ) ",":= by
  simp [coeFn_def, Measure.prod_apply_symm s_mble]",":= by
  simp [Measure.prod_apply_symm s_mble]"
Mathlib/Algebra/Homology/Single.lean,HomologicalComplex.from_single_hom_ext,from_single_hom_ext,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  ext i
  by_cases i = j
  ¬∑ subst h
    exact hfg
  ¬∑ apply (isZero_single_obj_X c j A i h).eq_of_src","error:  unknown identifier 'h'
error:  unknown identifier 'h'","lemma from_single_hom_ext {K : HomologicalComplex V c} {j : Œπ} {A : V}
    {f g : (single V c j).obj A ‚ü∂ K} (hfg : f.f j = g.f j) : f = g ",":= by
  ext i
  by_cases h : i = j
  ¬∑ subst h
    exact hfg
  ¬∑ apply (isZero_single_obj_X c j A i h).eq_of_src",":= by
  ext i
  by_cases i = j
  ¬∑ exact hfg
  ¬∑ apply (isZero_single_obj_X c j A i h).eq_of_src"
Mathlib/Data/Multiset/Antidiagonal.lean,Multiset.antidiagonal_eq_map_powerset,antidiagonal_eq_map_powerset,7fa386b9c1d5f5e8344fb34659b062d90996f3f0,":= by
  induction' s with a s hs
  ¬∑ simp only [antidiagonal_zero, powerset_zero, zero_tsub, map_singleton]
  ¬∑ simp_rw [antidiagonal_cons, powerset_cons, map_add, hs, map_map, Function.comp, Prod.map_mk,
      id, sub_cons, erase_cons_head]
    rw [add_comm]
    congr 1
    refine Multiset.map_congr rfl fun x hx ‚Ü¶ ?_
    rw [cons_sub_of_le _ (mem_powerset.mp hx)]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù : DecidableEq Œ±
s : Multiset Œ±
‚ä¢ s.antidiagonal = map (fun t ‚Ü¶ (s - t, t)) s.powerset","theorem antidiagonal_eq_map_powerset [DecidableEq Œ±] (s : Multiset Œ±) :
    s.antidiagonal = s.powerset.map fun t ‚Ü¶ (s - t, t) ",":= by
  induction' s using Multiset.induction_on with a s hs
  ¬∑ simp only [antidiagonal_zero, powerset_zero, zero_tsub, map_singleton]
  ¬∑ simp_rw [antidiagonal_cons, powerset_cons, map_add, hs, map_map, Function.comp, Prod.map_mk,
      id, sub_cons, erase_cons_head]
    rw [add_comm]
    congr 1
    refine Multiset.map_congr rfl fun x hx ‚Ü¶ ?_
    rw [cons_sub_of_le _ (mem_powerset.mp hx)]",":= by
  induction' s using Multiset.induction_on with a s hs
  ¬∑ simp only [antidiagonal_zero, powerset_zero, zero_tsub, map_singleton]
  ¬∑ simp_rw [antidiagonal_cons, powerset_cons, map_add, hs, map_map, Function.comp, Prod.map_mk,
      id, sub_cons, erase_cons_head]
    rw [add_comm]
    congr 1
    refine Multiset.map_congr rfl fun x hx ‚Ü¶ ?_
    rw [cons_sub_of_le _ (mem_powerset.mp hx)]"
Mathlib/Analysis/SpecialFunctions/Integrals.lean,intervalIntegral.intervalIntegrable_rpow',intervalIntegrable_rpow',7c008ed091a3f28c5996e87c85976b7758fadc03,":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine' (continuousOn_id.rpow_const _).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine' m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",error:  no goals to be solved,"theorem intervalIntegrable_rpow' {r : ‚Ñù} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const _).div_const ?_; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]"
Mathlib/Data/Nat/Bitwise.lean,Nat.bitwise_bit',bitwise_bit',c047c646d66e915f27c3e7f159bef508bfc8dd10,":= by
  conv_lhs => unfold bitwise
  rw [‚Üê bit_ne_zero_iff] at ham hbn
  simp only [ham, hbn, bit_mod_two_eq_one_iff, Bool.decide_coe, ‚Üê div2_val, div2_bit, ne_eq,
    ite_false]
  conv_rhs => simp only [bit, bit1, bit0, Bool.cond_eq_ite]","warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unsolved goals
f : Bool ‚Üí Bool ‚Üí Bool
a : Bool
m : ‚Ñï
b : Bool
n : ‚Ñï
ham : bit a m ‚â† 0
hbn : bit b n ‚â† 0
‚ä¢ (if f a b = true then bitwise f m n + bitwise f m n + 1 else bitwise f m n + bitwise f m n) =
    (if f a b = true then bit1 else bit0) (bitwise f m n)
warning:  `Nat.mul_lt_mul'` has been deprecated, use `Nat.mul_lt_mul_of_le_of_lt` instead
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated","lemma bitwise_bit' {f : Bool ‚Üí Bool ‚Üí Bool} (a : Bool) (m : Nat) (b : Bool) (n : Nat)
    (ham : m = 0 ‚Üí a = true) (hbn : n = 0 ‚Üí b = true) :
    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) ",":= by
  conv_lhs => unfold bitwise
  rw [‚Üê bit_ne_zero_iff] at ham hbn
  simp only [ham, hbn, bit_mod_two_eq_one_iff, Bool.decide_coe, ‚Üê div2_val, div2_bit, ne_eq,
    ite_false]
  conv_rhs => simp only [bit, bit1, bit0, Bool.cond_eq_ite]
  split_ifs with hf <;> rfl",":= by
  conv_lhs => unfold bitwise
  rw [‚Üê bit_ne_zero_iff] at ham hbn
  simp only [ham, hbn, bit_mod_two_eq_one_iff, Bool.decide_coe, ‚Üê div2_val, div2_bit, ne_eq,
    ite_false]
  conv_rhs => simp only [bit, bit1, bit0, Bool.cond_eq_ite]"
Mathlib/LinearAlgebra/FiniteDimensional.lean,Submodule.eq_top_of_finrank_eq,_root_.Submodule.eq_top_of_finrank_eq,f817426d82bfa5675e82d1b149debeaf04e3d580,":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent (by simpa using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]","error:  type mismatch
  h‚úù
has type
  LinearIndependent (Œπ := ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) K ‚áëbS : Prop
but is expected to have type
  LinearIndependent K fun (x : ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) ‚Ü¶ ‚Üëx : Prop
warning:  `finite_of_linearIndependent` has been deprecated, use `LinearIndependent.set_finite_of_isNoetherian` instead
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  no goals to be solved
error:  unknown identifier 'eq_top_of_finrank_eq'","theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ‚ä§ ",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
             finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]"
Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean,FiniteField.isSquare_odd_prime_iff,FiniteField.isSquare_odd_prime_iff,9e34a191034458a56331f976ff7400a26407c888,":= by
  classical
  by_cases hFp : ringChar F = p
  ¬∑ rw [show (p : F) = 0 by rw [‚Üê hFp]; exact ringChar.Nat.cast_ringChar]
    simp only [isSquare_zero, Ne.def, true_iff_iff, map_mul]
    obtain ‚ü®n, _, hc‚ü© := FiniteField.card F (ringChar F)
    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm
    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]
    simp only [zero_pow n.pos, MulZeroClass.mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]
  ¬∑ rw [‚Üê Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),
      quadraticChar_odd_prime hF hp]
    exact hFp","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.37884 ‚Üí ?m.37884 ‚Üí Prop
error:  cannot select argument","theorem FiniteField.isSquare_odd_prime_iff (hF : ringChar F ‚â† 2) {p : ‚Ñï} [Fact p.Prime]
    (hp : p ‚â† 2) :
    IsSquare (p : F) ‚Üî quadraticChar (ZMod p) (œá‚ÇÑ (Fintype.card F) * Fintype.card F) ‚â† -1 ",":= by
  classical
  by_cases hFp : ringChar F = p
  ¬∑ rw [show (p : F) = 0 by rw [‚Üê hFp]; exact ringChar.Nat.cast_ringChar]
    simp only [isSquare_zero, Ne, true_iff_iff, map_mul]
    obtain ‚ü®n, _, hc‚ü© := FiniteField.card F (ringChar F)
    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm
    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]
    simp only [zero_pow n.ne_zero, mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]
  ¬∑ rw [‚Üê Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),
      quadraticChar_odd_prime hF hp]
    exact hFp",":= by
  classical
  by_cases hFp : ringChar F = p
  ¬∑ rw [show (p : F) = 0 by rw [‚Üê hFp]; exact ringChar.Nat.cast_ringChar]
    simp only [isSquare_zero, Ne, true_iff_iff, map_mul]
    obtain ‚ü®n, _, hc‚ü© := FiniteField.card F (ringChar F)
    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm
    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]
    simp only [zero_pow n.pos, zero_eq_neg, one_ne_zero, not_false_iff]
  ¬∑ rw [‚Üê Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),
      quadraticChar_odd_prime hF hp]
    exact hFp"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,878024beabe74d3476b6e31acfd90d64e274a958,":= by
  refine' ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, _‚ü©, rfl‚ü©, _‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := isIntegral_sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)","error:  function expected at
  le_integralClosure_iff_isIntegral.mp (adjoin_le_integralClosure (IsPrimitiveRoot.isIntegral hŒ∂ (PNat.pos (p ^ k))))
term has type
  Algebra.IsIntegral ‚Ñ§ ‚Ü•(adjoin ‚Ñ§ {Œ∂})
error:  unknown identifier 'isIntegral_sub'
error:  unknown constant 'StrictOrderedSemiring.to_charZero'","theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)) : IsIntegralClosure (adjoin ‚Ñ§ ({Œ∂} : Set K)) ‚Ñ§ K ",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := isIntegral_sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjoin"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.map_think,map_think,88f252d9ef6777980e9cb4396094e178f3ed4acb,":=
  WSeq.ext _ _ <| Seq'.map_cons _ _ _",error:  unknown constant 'Stream'.WSeq.ext',theorem map_think (f : Œ± ‚Üí Œ≤) (s) : map f (think s) = think (map f s) ,":=
  Seq.map_cons _ _ _",":=
  WSeq.ext _ _ <| Seq.map_cons _ _ _"
Mathlib/CategoryTheory/Localization/CalculusOfFractions/Fractions.lean,CategoryTheory.MorphismProperty.LeftFraction‚ÇÇ.map_eq_iff,map_eq_iff,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  simp only [LeftFraction.map_eq_iff L W]
  constructor
  ¬∑ intro ‚ü®h, h'‚ü©
    obtain ‚ü®Z, t‚ÇÅ, t‚ÇÇ, hst, hft, ht‚ü© := h
    obtain ‚ü®Z', t‚ÇÅ', t‚ÇÇ', hst', hft', ht'‚ü© := h'
    dsimp at t‚ÇÅ t‚ÇÇ t‚ÇÅ' t‚ÇÇ' hst hft hst' hft' ht ht'
    have ‚ü®Œ±, hŒ±‚ü© := (RightFraction.mk _ ht (œÜ.s ‚â´ t‚ÇÅ')).exists_leftFraction
    simp only [Category.assoc] at hŒ±
    obtain ‚ü®Z'', u, hu, fac‚ü© := HasLeftCalculusOfFractions.ext _ _ _ œÜ.hs hŒ±
    have hŒ±' : œà.s ‚â´ t‚ÇÇ ‚â´ Œ±.f ‚â´ u = œà.s ‚â´ t‚ÇÇ' ‚â´ Œ±.s ‚â´ u := by
      rw [‚Üê reassoc_of% hst, ‚Üê reassoc_of% hŒ±, ‚Üê reassoc_of% hst']
    obtain ‚ü®Z''', u', hu', fac'‚ü© := HasLeftCalculusOfFractions.ext _ _ _ œà.hs hŒ±'
    simp only [Category.assoc] at fac fac'
    refine ‚ü®Z''', t‚ÇÅ' ‚â´ Œ±.s ‚â´ u ‚â´ u', t‚ÇÇ' ‚â´ Œ±.s ‚â´ u ‚â´ u', ?_, ?_?, _, ?_‚ü©
    ¬∑ rw [reassoc_of% hst']
    ¬∑ rw [reassoc_of% fac, reassoc_of% hft, fac']
    ¬∑ rw [reassoc_of% hft']
    ¬∑ rw [‚Üê Category.assoc]
      exact W.comp_mem _ _ ht' (W.comp_mem _ _ Œ±.hs (W.comp_mem _ _ hu hu'))
  ¬∑ intro h
    exact ‚ü®h.fst, h.snd‚ü©","error:  don't know how to synthesize placeholder for argument 'w'
context:
C : Type u_1
D : Type u_2
inst‚úù¬≥ : Category.{u_3, u_1} C
inst‚úù¬≤ : Category.{u_4, u_2} D
L : C ‚•§ D
W : MorphismProperty C
inst‚úù¬π : L.IsLocalization W
inst‚úù : W.HasLeftCalculusOfFractions
X Y : C
œÜ œà : W.LeftFraction‚ÇÇ X Y
Z : C
t‚ÇÅ : œÜ.Y' ‚ü∂ Z
t‚ÇÇ : œà.Y' ‚ü∂ Z
hst : œÜ.s ‚â´ t‚ÇÅ = œà.s ‚â´ t‚ÇÇ
hft : œÜ.f ‚â´ t‚ÇÅ = œà.f ‚â´ t‚ÇÇ
ht : W (œÜ.s ‚â´ t‚ÇÅ)
Z' : C
t‚ÇÅ' : œÜ.Y' ‚ü∂ Z'
t‚ÇÇ' : œà.Y' ‚ü∂ Z'
hst' : œÜ.s ‚â´ t‚ÇÅ' = œà.s ‚â´ t‚ÇÇ'
hft' : œÜ.f' ‚â´ t‚ÇÅ' = œà.f' ‚â´ t‚ÇÇ'
ht' : W (œÜ.s ‚â´ t‚ÇÅ')
Œ± : W.LeftFraction Z Z'
hŒ± : œÜ.s ‚â´ t‚ÇÅ' ‚â´ Œ±.s = œÜ.s ‚â´ t‚ÇÅ ‚â´ Œ±.f
Z'' : C
u : Œ±.Y' ‚ü∂ Z''
hu : W u
hŒ±' : œà.s ‚â´ t‚ÇÇ ‚â´ Œ±.f ‚â´ u = œà.s ‚â´ t‚ÇÇ' ‚â´ Œ±.s ‚â´ u
Z''' : C
u' : Z'' ‚ü∂ Z'''
hu' : W u'
fac : t‚ÇÅ' ‚â´ Œ±.s ‚â´ u = t‚ÇÅ ‚â´ Œ±.f ‚â´ u
fac' : t‚ÇÇ ‚â´ Œ±.f ‚â´ u ‚â´ u' = t‚ÇÇ' ‚â´ Œ±.s ‚â´ u ‚â´ u'
‚ä¢ œÜ.f' ‚â´ t‚ÇÅ' ‚â´ Œ±.s ‚â´ u ‚â´ u' = œà.f' ‚â´ t‚ÇÇ' ‚â´ Œ±.s ‚â´ u ‚â´ u'","lemma map_eq_iff {X Y : C} (œÜ œà : W.LeftFraction‚ÇÇ X Y) :
    (œÜ.fst.map L (Localization.inverts _ _) = œà.fst.map L (Localization.inverts _ _) ‚àß
    œÜ.snd.map L (Localization.inverts _ _) = œà.snd.map L (Localization.inverts _ _)) ‚Üî
      LeftFraction‚ÇÇRel œÜ œà ",":= by
  simp only [LeftFraction.map_eq_iff L W]
  constructor
  ¬∑ intro ‚ü®h, h'‚ü©
    obtain ‚ü®Z, t‚ÇÅ, t‚ÇÇ, hst, hft, ht‚ü© := h
    obtain ‚ü®Z', t‚ÇÅ', t‚ÇÇ', hst', hft', ht'‚ü© := h'
    dsimp at t‚ÇÅ t‚ÇÇ t‚ÇÅ' t‚ÇÇ' hst hft hst' hft' ht ht'
    have ‚ü®Œ±, hŒ±‚ü© := (RightFraction.mk _ ht (œÜ.s ‚â´ t‚ÇÅ')).exists_leftFraction
    simp only [Category.assoc] at hŒ±
    obtain ‚ü®Z'', u, hu, fac‚ü© := HasLeftCalculusOfFractions.ext _ _ _ œÜ.hs hŒ±
    have hŒ±' : œà.s ‚â´ t‚ÇÇ ‚â´ Œ±.f ‚â´ u = œà.s ‚â´ t‚ÇÇ' ‚â´ Œ±.s ‚â´ u := by
      rw [‚Üê reassoc_of% hst, ‚Üê reassoc_of% hŒ±, ‚Üê reassoc_of% hst']
    obtain ‚ü®Z''', u', hu', fac'‚ü© := HasLeftCalculusOfFractions.ext _ _ _ œà.hs hŒ±'
    simp only [Category.assoc] at fac fac'
    refine ‚ü®Z''', t‚ÇÅ' ‚â´ Œ±.s ‚â´ u ‚â´ u', t‚ÇÇ' ‚â´ Œ±.s ‚â´ u ‚â´ u', ?_, ?_, ?_, ?_‚ü©
    ¬∑ rw [reassoc_of% hst']
    ¬∑ rw [reassoc_of% fac, reassoc_of% hft, fac']
    ¬∑ rw [reassoc_of% hft']
    ¬∑ rw [‚Üê Category.assoc]
      exact W.comp_mem _ _ ht' (W.comp_mem _ _ Œ±.hs (W.comp_mem _ _ hu hu'))
  ¬∑ intro h
    exact ‚ü®h.fst, h.snd‚ü©",":= by
  simp only [LeftFraction.map_eq_iff L W]
  constructor
  ¬∑ intro ‚ü®h, h'‚ü©
    obtain ‚ü®Z, t‚ÇÅ, t‚ÇÇ, hst, hft, ht‚ü© := h
    obtain ‚ü®Z', t‚ÇÅ', t‚ÇÇ', hst', hft', ht'‚ü© := h'
    dsimp at t‚ÇÅ t‚ÇÇ t‚ÇÅ' t‚ÇÇ' hst hft hst' hft' ht ht'
    have ‚ü®Œ±, hŒ±‚ü© := (RightFraction.mk _ ht (œÜ.s ‚â´ t‚ÇÅ')).exists_leftFraction
    simp only [Category.assoc] at hŒ±
    obtain ‚ü®Z'', u, hu, fac‚ü© := HasLeftCalculusOfFractions.ext _ _ _ œÜ.hs hŒ±
    have hŒ±' : œà.s ‚â´ t‚ÇÇ ‚â´ Œ±.f ‚â´ u = œà.s ‚â´ t‚ÇÇ' ‚â´ Œ±.s ‚â´ u := by
      rw [‚Üê reassoc_of% hst, ‚Üê reassoc_of% hŒ±, ‚Üê reassoc_of% hst']
    obtain ‚ü®Z''', u', hu', fac'‚ü© := HasLeftCalculusOfFractions.ext _ _ _ œà.hs hŒ±'
    simp only [Category.assoc] at fac fac'
    refine ‚ü®Z''', t‚ÇÅ' ‚â´ Œ±.s ‚â´ u ‚â´ u', t‚ÇÇ' ‚â´ Œ±.s ‚â´ u ‚â´ u', ?_, ?_, ?_‚ü©
    ¬∑ rw [reassoc_of% hst']
    ¬∑ rw [reassoc_of% fac, reassoc_of% hft, fac']
    ¬∑ rw [reassoc_of% hft']
    ¬∑ rw [‚Üê Category.assoc]
      exact W.comp_mem _ _ ht' (W.comp_mem _ _ Œ±.hs (W.comp_mem _ _ hu hu'))
  ¬∑ intro h
    exact ‚ü®h.fst, h.snd‚ü©"
Mathlib/Analysis/Complex/Schwarz.lean,Complex.affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div,affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  set g := dslope f c
  rintro z hz
  by_cases h : z = c; ¬∑ simp [h]
  have h_R‚ÇÅ : 0 < R‚ÇÅ := nonempty_ball.mp ‚ü®_, h_z‚ÇÄ‚ü©
  have g_le_div : ‚àÄ z ‚àà ball c R‚ÇÅ, ‚Äñg z‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ := fun z hz =>
    norm_dslope_le_div_of_mapsTo_ball hd h_maps hz
  have g_max : IsMaxOn (norm ‚àò g) (ball c R‚ÇÅ) z‚ÇÄ :=
    isMaxOn_iff.mpr fun z hz => by simpa [h_eq] using g_le_div z hz
  have g_diff : DifferentiableOn ‚ÑÇ g (ball c R‚ÇÅ) :=
    (differentiableOn_dslope (isOpen_ball.mem_nhds (mem_ball_self h_R‚ÇÅ))).mpr hd
  have : g z = g z‚ÇÄ := eqOn_of_isPreconnected_of_isMaxOn_norm (convex_ball c R‚ÇÅ).isPreconnected
    isOpen_ball g_diff h_z‚ÇÄ g_max hz
  simp [‚Üê this]","error:  unsolved goals
case neg
E : Type u_1
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚ÑÇ E
R R‚ÇÅ R‚ÇÇ : ‚Ñù
f : ‚ÑÇ ‚Üí E
c z‚úù z‚ÇÄ : ‚ÑÇ
inst‚úù¬π : CompleteSpace E
inst‚úù : StrictConvexSpace ‚Ñù E
hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ)
h_maps : MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ)
h_z‚ÇÄ : z‚ÇÄ ‚àà ball c R‚ÇÅ
g : ‚ÑÇ ‚Üí E := dslope f c
h_eq : ‚Äñg z‚ÇÄ‚Äñ = R‚ÇÇ / R‚ÇÅ
z : ‚ÑÇ
hz : z ‚àà ball c R‚ÇÅ
h : ¬¨z = c
h_R‚ÇÅ : 0 < R‚ÇÅ
g_le_div : ‚àÄ z ‚àà ball c R‚ÇÅ, ‚Äñg z‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ
g_max : IsMaxOn (norm ‚àò g) (ball c R‚ÇÅ) z‚ÇÄ
g_diff : DifferentiableOn ‚ÑÇ g (ball c R‚ÇÅ)
this : g z = g z‚ÇÄ
‚ä¢ f z = f c + (z - c) ‚Ä¢ g z","theorem affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div [CompleteSpace E] [StrictConvexSpace ‚Ñù E]
    (hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ)) (h_maps : Set.MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ))
    (h_z‚ÇÄ : z‚ÇÄ ‚àà ball c R‚ÇÅ) (h_eq : ‚Äñdslope f c z‚ÇÄ‚Äñ = R‚ÇÇ / R‚ÇÅ) :
    Set.EqOn f (fun z => f c + (z - c) ‚Ä¢ dslope f c z‚ÇÄ) (ball c R‚ÇÅ) ",":= by
  set g := dslope f c
  rintro z hz
  by_cases h : z = c; ¬∑ simp [h]
  have h_R‚ÇÅ : 0 < R‚ÇÅ := nonempty_ball.mp ‚ü®_, h_z‚ÇÄ‚ü©
  have g_le_div : ‚àÄ z ‚àà ball c R‚ÇÅ, ‚Äñg z‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ := fun z hz =>
    norm_dslope_le_div_of_mapsTo_ball hd h_maps hz
  have g_max : IsMaxOn (norm ‚àò g) (ball c R‚ÇÅ) z‚ÇÄ :=
    isMaxOn_iff.mpr fun z hz => by simpa [h_eq] using g_le_div z hz
  have g_diff : DifferentiableOn ‚ÑÇ g (ball c R‚ÇÅ) :=
    (differentiableOn_dslope (isOpen_ball.mem_nhds (mem_ball_self h_R‚ÇÅ))).mpr hd
  have : g z = g z‚ÇÄ := eqOn_of_isPreconnected_of_isMaxOn_norm (convex_ball c R‚ÇÅ).isPreconnected
    isOpen_ball g_diff h_z‚ÇÄ g_max hz
  simp [g] at this
  simp [g, ‚Üê this]",":= by
  set g := dslope f c
  rintro z hz
  by_cases h : z = c; ¬∑ simp [h]
  have h_R‚ÇÅ : 0 < R‚ÇÅ := nonempty_ball.mp ‚ü®_, h_z‚ÇÄ‚ü©
  have g_le_div : ‚àÄ z ‚àà ball c R‚ÇÅ, ‚Äñg z‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ := fun z hz =>
    norm_dslope_le_div_of_mapsTo_ball hd h_maps hz
  have g_max : IsMaxOn (norm ‚àò g) (ball c R‚ÇÅ) z‚ÇÄ :=
    isMaxOn_iff.mpr fun z hz => by simpa [h_eq] using g_le_div z hz
  have g_diff : DifferentiableOn ‚ÑÇ g (ball c R‚ÇÅ) :=
    (differentiableOn_dslope (isOpen_ball.mem_nhds (mem_ball_self h_R‚ÇÅ))).mpr hd
  have : g z = g z‚ÇÄ := eqOn_of_isPreconnected_of_isMaxOn_norm (convex_ball c R‚ÇÅ).isPreconnected
    isOpen_ball g_diff h_z‚ÇÄ g_max hz
  simp [‚Üê this]"
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,c0e01e2659027402daf13d3c9c6f81d96a0d9b85,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine' ‚ü®U, {j}, _, _‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine' ‚ü®j, V, _, _‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine' this _ _ _ (univ _) (inter _) _
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      rw [‚Üê coe_comp, D.w]
      rfl",error:  invalid alternative name 'empty',"theorem isTopologicalBasis_cofiltered_limit (T : ‚àÄ j, Set (Set (F.obj j)))
    (hT : ‚àÄ j, IsTopologicalBasis (T j)) (univ : ‚àÄ i : J, Set.univ ‚àà T i)
    (inter : ‚àÄ (i) (U1 U2 : Set (F.obj i)), U1 ‚àà T i ‚Üí U2 ‚àà T i ‚Üí U1 ‚à© U2 ‚àà T i)
    (compat : ‚àÄ (i j : J) (f : i ‚ü∂ j) (V : Set (F.obj j)) (_hV : V ‚àà T j), F.map f ‚Åª¬π' V ‚àà T i) :
    IsTopologicalBasis
      {U : Set C.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = C.œÄ.app j ‚Åª¬π' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [‚Üê coe_comp, D.w] 
      rfl",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    refine this _ _ ?_ (univ _) "
Mathlib/Topology/Order/ScottTopology.lean,Topology.IsScott.lowerClosure_subset_closure,lowerClosure_subset_closure,98740267311a24ae6a2fe792964006babfd6788e,":= by
  convert closure.mono (@upperSet_le_scott Œ± _)
  rw [@IsUpperSet.closure_eq_lowerClosure Œ± _ (upperSet Œ±) ?_ s]
  ¬∑ exact instIsUpperSetUpperSet
  ¬∑ exact topology_eq Œ±",error:  unknown identifier 'instIsUpperSetUpperSet',lemma lowerClosure_subset_closure : ‚Üë(lowerClosure s) ‚äÜ closure s ,":= by
  convert closure.mono (@upperSet_le_scott Œ± _)
  ¬∑ rw [@IsUpperSet.closure_eq_lowerClosure Œ± _ (upperSet Œ±) ?_ s]
    infer_instance
  ¬∑ exact topology_eq Œ±",":= by
  convert closure.mono (@upperSet_le_scott Œ± _)
  rw [@IsUpperSet.closure_eq_lowerClosure Œ± _ (upperSet Œ±) ?_ s]
  ¬∑ exact instIsUpperSetUpperSet"
Mathlib/Algebra/CharZero/Quotient.lean,AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div,zsmul_mem_zmultiples_iff_exists_sub_div,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  rw [AddSubgroup.mem_zmultiples_iff]
  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, ‚Üê smul_mul_assoc, eq_sub_iff_add_eq]
  have hz' : (z : R) ‚â† 0 := Int.cast_ne_zero.mpr hz
  conv_rhs => simp (config := { singlePass := true }) only [‚Üê (mul_right_injective‚ÇÄ hz').eq_iff]
  simp_rw [‚Üê zsmul_eq_mul, smul_add, ‚Üê mul_smul_comm, zsmul_eq_mul (z : R)‚Åª¬π, mul_inv_cancel hz',
    mul_one, ‚Üê coe_nat_zsmul, smul_smul, ‚Üê add_smul]
  constructor
  ¬∑ rintro ‚ü®k, h‚ü©
    simp_rw [‚Üê h]
    refine' ‚ü®‚ü®(k % z).toNat, _‚ü©, k / z, _‚ü©
    ¬∑ rw [‚Üê Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)
    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
    nth_rewrite 3 [‚Üê Int.div_add_mod k z]
    rw [Int.mod_def, ‚Üê Int.div_def', Int.emod_def]
    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']
  ¬∑ rintro ‚ü®k, n, h‚ü©
    exact ‚ü®_, h‚ü©","warning:  `coe_nat_zsmul` has been deprecated, use `natCast_zsmul` instead
error:  unknown constant 'Int.div_def''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.8816
case mp.intro.refine'_2
R : Type u_1
inst‚úù¬π : DivisionRing R
inst‚úù : CharZero R
p r : R
z : ‚Ñ§
hz : z ‚â† 0
hz' : ‚Üëz ‚â† 0
k : ‚Ñ§
h : k ‚Ä¢ p = z ‚Ä¢ r
‚ä¢ (z * (k / z) + k % z) ‚Ä¢ p = (z * k.div z + (k - z * k.div z)) ‚Ä¢ p","theorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : ‚Ñ§} (hz : z ‚â† 0) :
    z ‚Ä¢ r ‚àà AddSubgroup.zmultiples p ‚Üî
      ‚àÉ k : Fin z.natAbs, r - (k : ‚Ñï) ‚Ä¢ (p / z : R) ‚àà AddSubgroup.zmultiples p ",":= by
  rw [AddSubgroup.mem_zmultiples_iff]
  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, ‚Üê smul_mul_assoc, eq_sub_iff_add_eq]
  have hz' : (z : R) ‚â† 0 := Int.cast_ne_zero.mpr hz
  conv_rhs => simp (config := { singlePass := true }) only [‚Üê (mul_right_injective‚ÇÄ hz').eq_iff]
  simp_rw [‚Üê zsmul_eq_mul, smul_add, ‚Üê mul_smul_comm, zsmul_eq_mul (z : R)‚Åª¬π, mul_inv_cancel hz',
    mul_one, ‚Üê natCast_zsmul, smul_smul, ‚Üê add_smul]
  constructor
  ¬∑ rintro ‚ü®k, h‚ü©
    simp_rw [‚Üê h]
    refine ‚ü®‚ü®(k % z).toNat, ?_‚ü©, k / z, ?_‚ü©
    ¬∑ rw [‚Üê Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)
    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
    nth_rewrite 3 [‚Üê Int.ediv_add_emod k z]
    rfl
  ¬∑ rintro ‚ü®k, n, h‚ü©
    exact ‚ü®_, h‚ü©",":= by
  rw [AddSubgroup.mem_zmultiples_iff]
  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, ‚Üê smul_mul_assoc, eq_sub_iff_add_eq]
  have hz' : (z : R) ‚â† 0 := Int.cast_ne_zero.mpr hz
  conv_rhs => simp (config := { singlePass := true }) only [‚Üê (mul_right_injective‚ÇÄ hz').eq_iff]
  simp_rw [‚Üê zsmul_eq_mul, smul_add, ‚Üê mul_smul_comm, zsmul_eq_mul (z : R)‚Åª¬π, mul_inv_cancel hz',
    mul_one, ‚Üê coe_natCast, smul_smul, ‚Üê add_smul]
  constructor
  ¬∑ rintro ‚ü®k, h‚ü©
    simp_rw [‚Üê h]
    refine ‚ü®‚ü®(k % z).toNat, ?_‚ü©, k / z, ?_‚ü©
    ¬∑ rw [‚Üê Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)
    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]
    nth_rewrite 3 [‚Üê Int.div_add_mod k z]
    rw [Int.mod_def, ‚Üê Int.div_def', Int.emod_def]
    simp only [add_sub_cancel_right, zsmul_eq_mul, Int.div_def']
  ¬∑ rintro ‚ü®k, n, h‚ü©
    exact ‚ü®_, h‚ü©"
Mathlib/Probability/ConditionalProbability.lean,ProbabilityTheory.cond_cond_eq_cond_inter',cond_cond_eq_cond_inter',a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 := measure_mono_null (Set.inter_subset_left _ _) hst
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (measure_pos_of_superset (Set.inter_subset_left _ _) hst).ne'
    simp [*, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Œº s)‚Åª¬π]","warning:  @cond does not have a doc string
warning:  @cond does not have a doc string
error:  function expected at
  inter_subset_left ?m.28019
term has type
  ?m.28018 ‚àà ?m.28016
error:  function expected at
  inter_subset_left ?m.30422
term has type
  ?m.30421 ‚àà ?m.30419","lemma cond_cond_eq_cond_inter' (hms : MeasurableSet s) (hmt : MeasurableSet t) (hcs : Œº s ‚â† ‚àû) :
    Œº[|s][|t] = Œº[|s ‚à© t] ",":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (measure_pos_of_superset Set.inter_subset_left hst).ne'
    simp [*, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Œº s)‚Åª¬π]",":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (measure_pos_of_superset Set.inter_subset_left hst).ne'
    simp [*, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Œº s)‚Åª¬π]"
Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean,CategoryTheory.Equalizer.Presieve.Arrows.FirstObj.ext,FirstObj.ext,f76dc92a63457a8b36463cee1fe33a048c0ba0ce,":= by
  apply Limits.Types.limit_ext
  rintro ‚ü®i‚ü©
  exact h i","error:  application type mismatch
  h i
argument
  i
has type
  (Y : C) √ó { f // R f } : Type (max u v)
but is expected to have type
  C : Type u","lemma FirstObj.ext (z‚ÇÅ z‚ÇÇ : FirstObj P R) (h : ‚àÄ (Y : C) (f : Y ‚ü∂ X)
    (hf : R f), (Pi.œÄ _ ‚ü®Y, f, hf‚ü© : FirstObj P R ‚ü∂ _) z‚ÇÅ =
      (Pi.œÄ _ ‚ü®Y, f, hf‚ü© : FirstObj P R ‚ü∂ _) z‚ÇÇ) : z‚ÇÅ = z‚ÇÇ ",":= by
  apply Limits.Types.limit_ext
  rintro ‚ü®‚ü®Y, f, hf‚ü©‚ü©
  exact h Y f hf",":= by
  apply Limits.Types.limit_ext
  exact h i"
Mathlib/Data/Set/Pairwise/Basic.lean,Set.pairwise_union,pairwise_union,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp only [Set.Pairwise, mem_union, or_imp, forall_and]
  exact
    ‚ü®fun H => ‚ü®H.1.1, H.2.2, H.2.1, fun x hx y hy hne => H.1.2 y hy x hx hne.symm‚ü©, fun H =>
      ‚ü®‚ü®H.1, fun x hx y hy hne => H.2.2.2 y hy x hx hne.symm‚ü©, H.2.2.1, H.2.1‚ü©‚ü©","error:  application type mismatch
  And.intro H.right.left
argument
  H.right.left
has type
  ‚àÄ x ‚àà t, ‚àÄ x_2 ‚àà s, x ‚â† x_2 ‚Üí r x x_2 : Prop
but is expected to have type
  ‚àÄ x ‚àà s, ‚àÄ x_2 ‚àà t, x ‚â† x_2 ‚Üí r x x_2 : Prop
error:  application type mismatch
  H.left.right y hy
argument
  hy
has type
  y ‚àà t : Prop
but is expected to have type
  y ‚àà s : Prop
error:  application type mismatch
  H.right.right.right y hy
argument
  hy
has type
  y ‚àà t : Prop
but is expected to have type
  y ‚àà s : Prop
error:  application type mismatch
  And.intro H.right.right.left
argument
  H.right.right.left
has type
  ‚àÄ x ‚àà s, ‚àÄ x_2 ‚àà t, x ‚â† x_2 ‚Üí r x x_2 : Prop
but is expected to have type
  ‚àÄ x ‚àà t, ‚àÄ x_2 ‚àà s, x ‚â† x_2 ‚Üí r x x_2 : Prop","theorem pairwise_union :
    (s ‚à™ t).Pairwise r ‚Üî
    s.Pairwise r ‚àß t.Pairwise r ‚àß ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b ‚Üí r a b ‚àß r b a ",":= by
  simp only [Set.Pairwise, mem_union, or_imp, forall_and]
  exact
    ‚ü®fun H => ‚ü®H.1.1, H.2.2, H.1.2, fun x hx y hy hne => H.2.1 y hy x hx hne.symm‚ü©,
     fun H => ‚ü®‚ü®H.1, H.2.2.1‚ü©, fun x hx y hy hne => H.2.2.2 y hy x hx hne.symm, H.2.1‚ü©‚ü©",":= by
  simp only [Set.Pairwise, mem_union, or_imp, forall_and]
  exact
    ‚ü®fun H => ‚ü®H.1.1, H.2.2, H.2.1, fun x hx y hy hne => H.1.2 y hy x hx hne.symm‚ü©, fun H =>
      ‚ü®‚ü®H.1, fun x hx y hy hne => H.2.2.2 y hy x hx hne.symm‚ü©, H.2.2.1, H.2.1‚ü©‚ü©"
Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean,Path.Homotopy.continuous_transReflReparamAux,continuous_transReflReparamAux,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn? _) (Continuous.continuousOn ??_) _ <;>
    [continuity; continuity; continuity; continuity; skip]
  intro x hx
  simp [hx]","error:  unexpected token '?'; expected '_' or identifier
warning:  fundamentalGroupoidFunctor does not have a doc string",theorem continuous_transReflReparamAux : Continuous transReflReparamAux ,":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_ <;>
    [continuity; continuity; continuity; continuity; skip]
  intro x hx
  simp [hx]",":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_ <;>
    [continuity; continuity; continuity; continuity; skip]
  intro x hx
  simp [hx]"
Mathlib/Probability/Process/PartitionFiltration.lean,ProbabilityTheory.iSup_countableFiltration,iSup_countableFiltration,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  conv_rhs => rw [‚Üê generateFrom_iUnion_countablePartition Œ±, ‚Üê iSup_generateFrom]","error:  unsolved goals
Œ±‚úù : Type u_1
inst‚úù¬≤ : MeasurableSpace Œ±‚úù
inst‚úù¬π : CountablyGenerated Œ±‚úù
Œ± : Type u_2
m : MeasurableSpace Œ±
inst‚úù : CountablyGenerated Œ±
‚ä¢ ‚®Ü n, ‚Üë(countableFiltration Œ±) n = ‚®Ü i, generateFrom (countablePartition Œ± i)","lemma iSup_countableFiltration (Œ± : Type*) [m : MeasurableSpace Œ±] [CountablyGenerated Œ±] :
    ‚®Ü n, countableFiltration Œ± n = m ",":= by
  conv_rhs => rw [‚Üê generateFrom_iUnion_countablePartition Œ±, ‚Üê iSup_generateFrom]
  rfl",":= by
  rw [‚Üê generateFrom_iUnion_countablePartition Œ±, ‚Üê iSup_generateFrom]"
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Œ¥_comp_œÉ_of_gt,Œ¥_comp_œÉ_of_gt,7472132820a806816d92180a5476e45b47a8d68b,":=
  Hom.ext _ _ (OrderHom.ext _ _ (Fin.predAbove_castSucc_comp_succAbove_castSucc H))",error:  unknown constant 'Fin.predAbove_castSucc_comp_succAbove_castSucc',"theorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Œ¥ i.succ ‚â´ œÉ (Fin.castSucc j) = œÉ j ‚â´ Œ¥ i ",":= by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]",":=
  Hom.ext _ _ (OrderHom.ext _ _ (Fin.predAbove_castSucc_castSucc H))"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,1bab9e3823740c27026995d4c01c24399c2a8dfa,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ 
      sorry
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero, Nat.zero_eq,
          Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.123443 ‚Üí ?m.123443
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133298 ‚Üí ?m.133298 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133434 ‚Üí ?m.133434 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicOn.inv,inv,0788787e4cbf8892c4d5415e2a91fb7666b8fc59,":= by
  rcases hf with ‚ü®m, hf‚ü©
  by_cases h_eq : (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
  ¬∑ 
    apply (meromorphicAt_const 0 x).congr
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  ¬∑ 
    obtain ‚ü®n, g, hg_an, hg_ne, hg_eq‚ü© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ùïú x).sub analyticAt_const).pow _
    refine ‚ü®n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_‚ü©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    ¬∑ simp only [sub_self, pow_succ, zero_mul, zero_smul]
    ¬∑ simp_rw [smul_eq_mul] at hfg ‚ä¢
      have aux1 : f z ‚â† 0
      ¬∑ have : (z - x) ^ n * g z ‚â† 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [‚Üê hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ, mul_assoc, hfg]
      ring","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case h.inl
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí ùïú
m n : ‚Ñï
g : ùïú ‚Üí ùïú
z : ùïú
hg_ne' : g z ‚â† 0
hf : AnalyticAt ùïú (fun z_1 ‚Ü¶ (z_1 - z) ^ m ‚Ä¢ f z_1) z
h_eq : ¬¨(fun z_1 ‚Ü¶ (z_1 - z) ^ m ‚Ä¢ f z_1) =·∂†[ùìù z] 0
hg_an : AnalyticAt ùïú g z
hg_ne : g z ‚â† 0
hg_eq : ‚àÄ·∂† (z_1 : ùïú) in ùìù z, (z_1 - z) ^ m ‚Ä¢ f z_1 = (z_1 - z) ^ n ‚Ä¢ g z_1
this : AnalyticAt ùïú (fun z_1 ‚Ü¶ (z_1 - z) ^ (m + 1)) z
hfg : (z - z) ^ m ‚Ä¢ f z = (z - z) ^ n ‚Ä¢ g z
‚ä¢ (0 ^ m * 0) ‚Ä¢ (g z)‚Åª¬π = (0 ^ n * 0) ‚Ä¢ f‚Åª¬π z
error:  unsolved goals
case h.inr
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí ùïú
x : ùïú
m : ‚Ñï
hf : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) x
h_eq : ¬¨(fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
n : ‚Ñï
g : ùïú ‚Üí ùïú
hg_an : AnalyticAt ùïú g x
hg_ne : g x ‚â† 0
hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù x, (z - x) ^ m ‚Ä¢ f z = (z - x) ^ n ‚Ä¢ g z
this : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x
z : ùïú
hfg : (z - x) ^ m * f z = (z - x) ^ n * g z
hg_ne' : g z ‚â† 0
hz_ne : z ‚â† x
aux1 : f z ‚â† 0
‚ä¢ (z - x) ^ (m + 1) * (g z)‚Åª¬π = (z - x) ^ (n + 1) * f‚Åª¬π z",lemma inv {f : ùïú ‚Üí ùïú} {x : ùïú} (hf : MeromorphicAt f x) : MeromorphicAt f‚Åª¬π x ,":= by
  rcases hf with ‚ü®m, hf‚ü©
  by_cases h_eq : (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
  ¬∑ 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  ¬∑ 
    obtain ‚ü®n, g, hg_an, hg_ne, hg_eq‚ü© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ùïú x).sub analyticAt_const).pow _
    refine ‚ü®n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_‚ü©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    ¬∑ simp only [sub_self, pow_succ, mul_zero, zero_smul]
    ¬∑ simp_rw [smul_eq_mul] at hfg ‚ä¢
      have aux1 : f z ‚â† 0 := by
        have : (z - x) ^ n * g z ‚â† 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [‚Üê hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ', mul_assoc, hfg]
      ring",":= by
  rcases hf with ‚ü®m, hf‚ü©
  by_cases h_eq : (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
  ¬∑ 
    apply (meromorphicAt_const 0 x).congr
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  ¬∑ 
    obtain ‚ü®n, g, hg_an, hg_ne, hg_eq‚ü© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ùïú x).sub analyticAt_const).pow _
    refine ‚ü®n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_‚ü©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    ¬∑ simp only [sub_self, pow_succ, zero_mul, zero_smul]
    ¬∑ simp_rw [smul_eq_mul] at hfg ‚ä¢
      have aux1 : f z ‚â† 0
      ¬∑ have : (z - x) ^ n * g z ‚â† 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [‚Üê hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ, mul_assoc, hfg]
      ring"
Mathlib/Algebra/Order/Module/Defs.lean,inv_smul_lt_iff_of_neg,inv_smul_lt_iff_of_neg,299792d941f0a59647d1864dd577af60b4b0228f,":= by
  rw [‚Üê smul_lt_smul_iff_of_neg h, smul_inv_smul‚ÇÄ h.ne]","error:  unknown identifier 'smul_lt_smul_iff_of_neg'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.448457
Œ± : Type u_1
Œ≤ : Type u_2
a‚úù a‚ÇÅ a‚ÇÇ : Œ±
b b‚ÇÅ‚úù b‚ÇÇ‚úù : Œ≤
inst‚úù¬≥ : LinearOrderedField Œ±
inst‚úù¬≤ : OrderedAddCommGroup Œ≤
inst‚úù¬π : Module Œ± Œ≤
a : Œ±
b‚ÇÅ b‚ÇÇ : Œ≤
inst‚úù : PosSMulStrictMono Œ± Œ≤
h : a < 0
‚ä¢ a‚Åª¬π ‚Ä¢ b‚ÇÅ < b‚ÇÇ ‚Üî a ‚Ä¢ b‚ÇÇ < b‚ÇÅ",lemma inv_smul_lt_iff_of_neg (h : a < 0) : a‚Åª¬π ‚Ä¢ b‚ÇÅ < b‚ÇÇ ‚Üî a ‚Ä¢ b‚ÇÇ < b‚ÇÅ ,":= by
  rw [‚Üê smul_lt_smul_iff_of_neg_left h, smul_inv_smul‚ÇÄ h.ne]",":= by
  rw [‚Üê smul_lt_smul_iff_of_neg h, smul_inv_smul‚ÇÄ h.ne]"
Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean,gramSchmidt_orthogonal,gramSchmidt_orthogonal,9e34a191034458a56331f976ff7400a26407c888,":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ ha
    ¬∑ rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply WellFounded.induction (@IsWellFounded.wf Œπ (¬∑ < ¬∑) _) b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, MulZeroClass.zero_mul, sub_zero]
    ¬∑ rw [IsROrC.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ","error:  unknown identifier 'IsROrC.ofReal_pow'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.51226
case neg
ùïú : Type u_1
E : Type u_2
inst‚úù‚Åµ : RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : InnerProductSpace ùïú E
Œπ : Type u_3
inst‚úù¬≤ : LinearOrder Œπ
inst‚úù¬π : LocallyFiniteOrderBot Œπ
inst‚úù : IsWellOrder Œπ fun x x_1 ‚Ü¶ x < x_1
f : Œπ ‚Üí E
b‚úù b : Œπ
ih : ‚àÄ y < b, ‚àÄ a < y, ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f y‚ü´_ùïú = 0
a : Œπ
h‚ÇÄ : a < b
h : ¬¨gramSchmidt ùïú f a = 0
‚ä¢ ‚ü™gramSchmidt ùïú f a, f b‚ü´_ùïú -
      ‚ü™gramSchmidt ùïú f a, f b‚ü´_ùïú / ‚Üë(‚ÄñgramSchmidt ùïú f a‚Äñ ^ 2) * ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f a‚ü´_ùïú =
    0","theorem gramSchmidt_orthogonal (f : Œπ ‚Üí E) {a b : Œπ} (h‚ÇÄ : a ‚â† b) :
    ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 ",":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ ha
    ¬∑ rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply wellFounded_lt.induction b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    ¬∑ rw [RCLike.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel‚ÇÄ, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ",":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ ha
    ¬∑ rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply WellFounded.induction (@IsWellFounded.wf Œπ (¬∑ < ¬∑) _) b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, MulZeroClass.zero_mul, sub_zero]
    ¬∑ rw [IsROrC.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel_right]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ"
Mathlib/Data/DFinsupp/Basic.lean,DFinsupp.mem_support_toFun,mem_support_toFun,c342c339a777827331257acd880fea6d441a6aa6,":= by
  cases' f with f s
  induction' s with s
  dsimp only [support, Trunc.lift_mk]
  rw [Finset.mem_filter, Multiset.mem_toFinset, coe_mk']
  exact and_iff_right_of_imp (s.prop i).resolve_right","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
case mk'
Œπ : Type u
Œ≥ : Type w
Œ≤ : Œπ ‚Üí Type v
Œ≤‚ÇÅ : Œπ ‚Üí Type v‚ÇÅ
Œ≤‚ÇÇ : Œπ ‚Üí Type v‚ÇÇ
inst‚úù¬≤ : DecidableEq Œπ
inst‚úù¬π : (i : Œπ) ‚Üí Zero (Œ≤ i)
inst‚úù : (i : Œπ) ‚Üí (x : Œ≤ i) ‚Üí Decidable (x ‚â† 0)
i : Œπ
f : (i : Œπ) ‚Üí Œ≤ i
s : Trunc { s // ‚àÄ (i : Œπ), i ‚àà s ‚à® f i = 0 }
‚ä¢ i ‚àà { toFun := f, support' := s }.support ‚Üî { toFun := f, support' := s } i ‚â† 0","theorem mem_support_toFun (f : Œ†‚ÇÄ i, Œ≤ i) (i) : i ‚àà f.support ‚Üî f i ‚â† 0 ",":= by
  cases' f with f s
  induction' s using Trunc.induction_on with s
  dsimp only [support, Trunc.lift_mk]
  rw [Finset.mem_filter, Multiset.mem_toFinset, coe_mk']
  exact and_iff_right_of_imp (s.prop i).resolve_right",":= by
  cases' f with f s
  induction' s using Finset.induction_on with s
  dsimp only [Finset.mem_filter, Multiset.mem_toFinset, coe_mk']
  exact and_iff_right_of_imp (s.prop i).resolve_right"
Mathlib/RingTheory/ChainOfDivisors.lean,DivisorChain.element_of_chain_eq_pow_second_of_chain,element_of_chain_eq_pow_second_of_chain,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ‚ü®‚ü®i, ?_‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_) _
      refine
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) ?_ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine dvd_trans ?_ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2","error:  type mismatch
  Set.injOn_of_injective (fun m m' h ‚Ü¶ Fin.ext (?m.30170 m m' h)) ?m.30176
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Fin ?m.30169‚¶Ñ, x‚ÇÇ ‚àà ?m.30174 ‚Üí ?m.30152 ?m.30175 = ?m.30152 x‚ÇÇ ‚Üí ?m.30175 = x‚ÇÇ : Prop
but is expected to have type
  Set.InjOn (fun m ‚Ü¶ c 1 ^ ‚Üëm) ‚ÜëFinset.univ : Prop","theorem element_of_chain_eq_pow_second_of_chain {q r : Associates M} {n : ‚Ñï} (hn : n ‚â† 0)
    {c : Fin (n + 1) ‚Üí Associates M} (h‚ÇÅ : StrictMono c) (h‚ÇÇ : ‚àÄ {r}, r ‚â§ q ‚Üî ‚àÉ i, r = c i)
    (hr : r ‚à£ q) (hq : q ‚â† 0) : ‚àÉ i : Fin (n + 1), r = c 1 ^ (i : ‚Ñï) ",":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ‚ü®‚ü®i, ?_‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_)
      refine
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) ?_ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine dvd_trans ?_ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2",":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ‚ü®‚ü®i, ?_‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_) ?_
      refine
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) ?_ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine dvd_trans ?_ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2"
Mathlib/Topology/Order/ScottTopology.lean,Topology.IsScott.isOpen_iff_isUpperSet_and_dirSupInacc,isOpen_iff_isUpperSet_and_dirSupInacc,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open]
  refine and_congr_right fun h ‚Ü¶
    ‚ü®@IsScottHausdorff.dirSupInacc_of_isOpen _ _ (scottHausdorff Œ±) _ _,
      fun h' d d‚ÇÅ d‚ÇÇ _ d‚ÇÉ ha ‚Ü¶ ?_‚ü©
  obtain ‚ü®b, hbd, hbu‚ü© := h' d‚ÇÅ d‚ÇÇ d‚ÇÉ ha
  exact ‚ü®b, hbd, Subset.trans (inter_subset_left (Ici b) d) (h.Ici_subset hbu)‚ü©","error:  application type mismatch
  inter_subset_left (Ici b)
argument
  Ici b
has type
  Set Œ± : Type u_1
but is expected to have type
  ?m.27260 ‚àà ?m.27258 ‚à© ?m.27259 : Prop",lemma isOpen_iff_isUpperSet_and_dirSupInacc : IsOpen s ‚Üî IsUpperSet s ‚àß DirSupInacc s ,":= by
  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open]
  refine and_congr_right fun h ‚Ü¶
    ‚ü®@IsScottHausdorff.dirSupInacc_of_isOpen _ _ (scottHausdorff Œ±) _ _,
      fun h' d d‚ÇÅ d‚ÇÇ _ d‚ÇÉ ha ‚Ü¶ ?_‚ü©
  obtain ‚ü®b, hbd, hbu‚ü© := h' d‚ÇÅ d‚ÇÇ d‚ÇÉ ha
  exact ‚ü®b, hbd, Subset.trans inter_subset_left (h.Ici_subset hbu)‚ü©",":= by
  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open]
  refine and_congr_right fun h ‚Ü¶
    ‚ü®@IsScottHausdorff.dirSupInacc_of_isOpen _ _ (scottHausdorff Œ±) _ _,
      fun h' d d‚ÇÅ d‚ÇÇ _ d‚ÇÉ ha ‚Ü¶ ?_‚ü©
  obtain ‚ü®b, hbd, hbu‚ü© := h' d‚ÇÅ d‚ÇÇ d‚ÇÉ ha
  exact ‚ü®b, hbd, Subset.trans inter_subset_left (Ici b) d) (h.Ici_subset hbu)‚ü©"
Mathlib/Data/List/Cycle.lean,List.next_prev,next_prev,d46528409610b391797c6ae50b570899f3d41002,":= by
  obtain ‚ü®n, hn, rfl‚ü© := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  ¬∑ simp at hx
  ¬∑ have : (n + length tl + 1) % (length tl + 1) = n := by
      rw [length_cons, Nat.succ_eq_add_one] at hn
      rw [add_assoc, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp [this]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
l : List Œ±
x : Œ±
n : ‚Ñï
hd : Œ±
tl : List Œ±
h : (hd :: tl).Nodup
hn‚úù : n < (hd :: tl).length
hn : n < tl.length + 1
hx : (hd :: tl).nthLe n hn‚úù ‚àà hd :: tl
‚ä¢ (n + tl.length + 1) % (tl.length + 1) = n
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead","theorem next_prev (l : List Œ±) (h : Nodup l) (x : Œ±) (hx : x ‚àà l) :
    next l (prev l x hx) (prev_mem _ _ _) = x ",":= by
  obtain ‚ü®n, hn, rfl‚ü© := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  ¬∑ simp at hx
  ¬∑ have : (n + length tl + 1) % (length tl + 1) = n := by
      rw [length_cons] at hn
      rw [add_assoc, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp [this]",":= by
  obtain ‚ü®n, hn, rfl‚ü© := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  ¬∑ simp at hx
  ¬∑ have : (n + length tl + 1) % (length tl + 1) = n := by
      rw [length_cons, Nat.succ_eq_add_one] at hn
      rw [Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp [this]"
Mathlib/LinearAlgebra/BilinearForm/Properties.lean,LinearMap.BilinForm.dualBasis_dualBasis,dualBasis_dualBasis,47690ed0e74b35be38bbd1d60fa70e442b9730ca,":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ‚Ü¶ ?_))
  simp_rw [BilinForm.toLin_apply, apply_dualBasis_left, ‚Üê B.flip_apply,
    apply_dualBasis_left, @eq_comm _ i j]","warning:  `BilinForm.toLin_apply` has been deprecated
error:  simp made no progress","lemma dualBasis_dualBasis_flip (B : BilinForm K V) (hB : B.Nondegenerate) {Œπ}
    [Finite Œπ] [DecidableEq Œπ] (b : Basis Œπ K V) :
    B.dualBasis hB (B.flip.dualBasis hB.flip b) = b ",":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ‚Ü¶ ?_))
  simp_rw [apply_dualBasis_left, ‚Üê B.flip_apply, apply_dualBasis_left, @eq_comm _ i j]",":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ‚Ü¶ ?_))
  simp_rw [BilinForm.toLin_apply, apply_dualBasis_left, ‚Üê B.flip_apply,
    apply_dualBasis_left, @eq_comm _ i j]"
Mathlib/Data/Multiset/Basic.lean,Multiset.cons_lt_cons,cons_lt_cons,ad88a031b67d9f51d39379f0e5f82a31c1929202,:=,"warning:  @cons does not have a doc string
error:  unexpected token 'lemma'; expected term
warning:  `List.filter_congr'` has been deprecated, use `List.filter_congr` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead",lemma cons_lt_cons_iff : a ::‚Çò s < a ::‚Çò t ‚Üî s < t ,":=
  lt_iff_lt_of_le_iff_le' (cons_le_cons_iff _) (cons_le_cons_iff _)",":=
  cons_lt_cons_iff"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.le_mul_withDensity,le_mul_withDensity,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine le_trans (measure_mono (inter_subset_right _ _)) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono (inter_subset_right _ _)).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ŒΩ, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
          ‚àë' n : ‚Ñ§, (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = (t ‚Ä¢ ŒΩ) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t ‚Ä¢ ŒΩ) f_meas hs ht).symm","error:  function expected at
  inter_subset_right ?m.233065
term has type
  ?m.233064 ‚àà ?m.233063
error:  function expected at
  inter_subset_right ?m.235331
term has type
  ?m.235330 ‚àà ?m.235329","theorem le_mul_withDensity {s : Set Œ±} (hs : MeasurableSet s) {t : ‚Ñù‚â•0} (ht : 1 < t) :
    œÅ s ‚â§ t * Œº.withDensity (v.limRatioMeas hœÅ) s ",":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ŒΩ, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
          ‚àë' n : ‚Ñ§, (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = (t ‚Ä¢ ŒΩ) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t ‚Ä¢ ŒΩ) f_meas hs ht).symm",":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ŒΩ, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {0}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ "
Mathlib/MeasureTheory/Constructions/Polish.lean,Measurable.measurableEmbedding,_root_.Measurable.measurableEmbedding,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":=
  { injective := f_inj
    measurable := f_meas
    measurableSet_image' := fun _u hu => hu.image_of_measurable_injOn f_meas (f_inj.injOn _) }","error:  application type mismatch
  MeasurableSet.image_of_measurable_injOn hu f_meas (Injective.injOn f_inj ?m.73937)
argument
  Injective.injOn f_inj ?m.73937
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Œ≥‚¶Ñ, x‚ÇÇ ‚àà ?m.73935 ‚Üí f ?m.73936 = f x‚ÇÇ ‚Üí ?m.73936 = x‚ÇÇ : Prop
but is expected to have type
  InjOn f _u : Prop","theorem _root_.Measurable.measurableEmbedding {f : Œ≥ ‚Üí Œ±}
    [MeasurableSpace.CountablySeparated Œ±]
    [MeasurableSpace Œ≥] [StandardBorelSpace Œ≥]
    (f_meas : Measurable f) (f_inj : Injective f) : MeasurableEmbedding f ",":=
  { injective := f_inj
    measurable := f_meas
    measurableSet_image' := fun _u hu => hu.image_of_measurable_injOn f_meas f_inj.injOn }",":=
  { injective := f_inj
    measurable := f_meas
    measurableSet_image' := fun _u hu => hu.image_of_measurable_injOn f_meas (f_inj.injOn _) }"
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.epi_iff_surjective,epi_iff_surjective,ab56fa28da38a962b7952fc9e52edb14bef2bc5a,":= by
  rw [‚Üê Functor.epi_map_iff_epi skeletalEquivalence.functor.{0}]
  dsimp only [skeletalEquivalence, Functor.asEquivalence_functor]
  rw [NonemptyFinLinOrd.epi_iff_surjective, skeletalFunctor.coe_map,
    Function.Surjective.of_comp_iff' ULift.up_bijective,
    Function.Surjective.of_comp_iff _ ULift.down_surjective]",error:  too many explicit universe levels for 'SimplexCategory.skeletalEquivalence',"theorem epi_iff_surjective {n m : SimplexCategory} {f : n ‚ü∂ m} :
    Epi f ‚Üî Function.Surjective f.toOrderHom ",":= by
  rw [‚Üê Functor.epi_map_iff_epi skeletalEquivalence.functor]
  dsimp only [skeletalEquivalence, Functor.asEquivalence_functor]
  simp only [skeletalFunctor_obj, skeletalFunctor_map,
    NonemptyFinLinOrd.epi_iff_surjective, NonemptyFinLinOrd.coe_of]",":= by
  rw [‚Üê Functor.epi_map_iff_epi skeletalEquivalence.functor.{0}]
  dsimp only [skeletalEquivalence, Functor.asEquivalence_functor]
  rw [NonemptyFinLinOrd.epi_iff_surjective, skeletalFunctor.coe_map,
    Function.Surjective.of_comp_iff _ ULift.down_surjective]"
Mathlib/NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean,ZMod.Ico_map_valMinAbs_natAbs_eq_Ico_map_id,Ico_map_valMinAbs_natAbs_eq_Ico_map_id,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, lt_succ_iff, succ_le_iff, pos_iff_ne_zero,
      natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x, ‚àÉ _ : x ‚àà Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine' ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®_, _‚ü©, _‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne.def, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [nat_cast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel' _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
      ¬∑ erw [mul_neg, mul_div_cancel' _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,
          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)","error:  unknown identifier 'lt_succ_iff'
error:  unsolved goals
p : ‚Ñï
hp : Fact (Nat.Prime p)
a : ZMod p
hap : a ‚â† 0
he : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2
hep : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p
hpe : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x
x : ‚Ñï
hx : x ‚àà Ico 1 (p / 2).succ
‚ä¢ (a * ‚Üëx).valMinAbs.natAbs < p / 2 + 1
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.14841 ‚Üí ?m.14841 ‚Üí Prop
error:  unsolved goals
case refine'_1.a
p : ‚Ñï
hp : Fact (Nat.Prime p)
a : ZMod p
hap : a ‚â† 0
he : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2
hep : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p
hpe : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x
hmem : ‚àÄ x ‚àà Ico 1 (p / 2).succ, (a * ‚Üëx).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ
b : ‚Ñï
hb : b ‚àà Ico 1 (p / 2).succ
‚ä¢ (‚Üëb * a‚Åª¬π).valMinAbs.natAbs ‚â† 0
warning:  `ZMod.nat_cast_natAbs_valMinAbs` has been deprecated, use `ZMod.natCast_natAbs_valMinAbs` instead
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead","theorem Ico_map_valMinAbs_natAbs_eq_Ico_map_id (p : ‚Ñï) [hp : Fact p.Prime] (a : ZMod p)
    (hap : a ‚â† 0) : ((Ico 1 (p / 2).succ).1.map fun (x : ‚Ñï) => (a * x).valMinAbs.natAbs) =
    (Ico 1 (p / 2).succ).1.map fun a => a ",":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,
      pos_iff_ne_zero, natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x, ‚àÉ _ : x ‚àà Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®?_, ?_‚ü©, ?_‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [natCast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel‚ÇÄ _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
      ¬∑ erw [mul_neg, mul_div_cancel‚ÇÄ _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,
          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)",":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, lt_succ_iff, succ_le_iff, pos_iff_ne_zero,
      natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x, ‚àÉ _ : x ‚àà Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®_, ?_‚ü©, ?_‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [nat_cast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel' _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)"
Mathlib/Data/Nat/Factorization/Basic.lean,Nat.factors_count_eq,factors_count_eq,19886c8a65d45c7c65705b7482580bc5741c87a8,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization, coe_mk, pp, if_true]
  rw [‚Üê PartENat.natCast_inj, padicValNat_def' pp.ne_one hn0,
    UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors pp hn0.ne']
  simp [factors_eq]","error:  unknown identifier 'UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.7120
case inr
a b m n‚úù p‚úù n p : ‚Ñï
hn0 : n > 0
pp : Prime p
‚ä¢ ‚Üë(count p n.factors) = multiplicity p n",theorem factors_count_eq {n p : ‚Ñï} : n.factors.count p = n.factorization p ,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization_def _ pp]
  apply _root_.le_antisymm
  ¬∑ rw [le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm
  ¬∑ rw [‚Üê Nat.lt_add_one_iff, lt_iff_not_ge, ge_iff_le,
      le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this",":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization, coe_mk, pp, if_true]
  rw [‚Üê PartENat.natCast_inj, padicValNat_def' pp.ne_one hn0,
    UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors pp hn0.ne']"
Mathlib/NumberTheory/DiophantineApproximation.lean,Real.exists_rat_eq_convergent',exists_rat_eq_convergent',5c53be23402af61bb64911e1bc2b921c7f7f183f,":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, MulZeroClass.zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    cases' le_or_lt (u : ‚Ñù) Œæ with ht ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      cases' eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine' ‚ü®(fract_lt_one Œæ).le, _‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (by exact_mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_ofNat, inv_div, sub_div, mul_div_cancel _ Hv, add_sub_cancel'_right]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë(OfNat.ofNat ?n)
case h
v‚úù : ‚Ñ§
hv : 2 ‚â§ v‚úù
v : ‚Ñï
ih : ‚àÄ m < v, ‚àÄ {Œæ : ‚Ñù} {u : ‚Ñ§}, ContfracLegendre.Ass Œæ u ‚Üëm ‚Üí ‚àÉ n, ‚Üëu / ‚Üëm = Œæ.convergent n
Œæ : ‚Ñù
u : ‚Ñ§
h : ContfracLegendre.Ass Œæ u ‚Üëv
ht : 1 < v
huv‚ÇÄ : 0 < u - ‚åäŒæ‚åã * ‚Üëv
huv‚ÇÅ : u - ‚åäŒæ‚åã * ‚Üëv < ‚Üëv
Hv : ‚Üëv ‚â† 0
huv‚ÇÅ' : (u - ‚åäŒæ‚åã * ‚Üëv).toNat < v
inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π ‚Üëv ‚Üë(u - ‚åäŒæ‚åã * ‚Üëv).toNat
n : ‚Ñï
hn : ‚Üë‚Üëv / ‚Üë(u - ‚åäŒæ‚åã * ‚Üëv).toNat = (fract Œæ)‚Åª¬π.convergent n
‚ä¢ ‚Üëu / ‚Üëv = ‚Üë‚åäŒæ‚åã + (‚Üë‚Üëv / (‚Üëu - ‚Üë‚åäŒæ‚åã * ‚Üëv))‚Åª¬π","theorem exists_rat_eq_convergent' {v : ‚Ñï} (h' : ContfracLegendre.Ass Œæ u v) :
    ‚àÉ n, (u / v : ‚Ñö) = Œæ.convergent n ",":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    rcases le_or_lt (u : ‚Ñù) Œæ with ht | ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      rcases eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ | HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine ‚ü®(fract_lt_one Œæ).le, ?_‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_natCast, inv_div, sub_div, mul_div_cancel_right‚ÇÄ _ Hv, add_sub_cancel]",":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, MulZeroClass.zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    cases' le_or_lt (u : ‚Ñù) Œæ with ht ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      cases' eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine ‚ü®(fract_lt_one Œæ).le, ?_‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (by exact_mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_ofNat, inv_div, sub_div, mul_div_cancel _ Hv, add_sub_cancel'_right]"
Mathlib/Computability/Primrec.lean,Primrec.nat_div,nat_div,b912476b37f2ea41ee51af7e63439f4a769be095,":= by
  refine of_graph fst (fun p => Nat.div_le_self _ _) ?_
  have : PrimrecRel fun (a : ‚Ñï √ó ‚Ñï) (b : ‚Ñï) => (a.2 = 0 ‚àß b = 0) ‚à®
      (0 < a.2 ‚àß b * a.2 ‚â§ a.1 ‚àß a.1 < (b + 1) * a.2) :=
    PrimrecPred.or
      (.and (const 0 |> Primrec.eq.comp (fst |> snd.comp)) (const 0 |> Primrec.eq.comp snd))
      (.and (nat_lt.comp (const 0) (fst |> snd.comp)) <|
          .and (nat_le.comp (nat_mul.comp‚ÇÇ snd (fst |> snd.comp)) (fst |> fst.comp))
          (nat_lt.comp (fst.comp fst) (nat_mul.comp‚ÇÇ (Primrec.succ.comp snd) (snd.comp fst))))
  refine this.of_eq_rel ?_
  rintro ‚ü®a, k‚ü© q
  if H : k = 0 then simp [H, eq_comm]
  else
    have : q * k ‚â§ a ‚àß a < (q + 1) * k ‚Üî q = a / k := by
      rw [le_antisymm_iff, ‚Üê (@Nat.lt_succ _ q), Nat.le_div_iff_mul_le' (Nat.pos_of_ne_zero H),
          Nat.div_lt_iff_lt_mul' (Nat.pos_of_ne_zero H)]
    simpa [H, zero_lt_iff, eq_comm (b := q)]","error:  application type mismatch
  of_graph fst
argument
  fst
has type
  Primrec Prod.fst : Prop
but is expected to have type
  PrimrecBounded ?m.103754 : Prop
error:  no goals to be solved",theorem nat_div : Primrec‚ÇÇ ((¬∑ / ¬∑) : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï) ,":= by
  refine of_graph ‚ü®_, fst, fun p => Nat.div_le_self _ _‚ü© ?_
  have : PrimrecRel fun (a : ‚Ñï √ó ‚Ñï) (b : ‚Ñï) => (a.2 = 0 ‚àß b = 0) ‚à®
      (0 < a.2 ‚àß b * a.2 ‚â§ a.1 ‚àß a.1 < (b + 1) * a.2) :=
    PrimrecPred.or
      (.and (const 0 |> Primrec.eq.comp (fst |> snd.comp)) (const 0 |> Primrec.eq.comp snd))
      (.and (nat_lt.comp (const 0) (fst |> snd.comp)) <|
          .and (nat_le.comp (nat_mul.comp snd (fst |> snd.comp)) (fst |> fst.comp))
          (nat_lt.comp (fst.comp fst) (nat_mul.comp (Primrec.succ.comp snd) (snd.comp fst))))
  refine this.of_eq ?_
  rintro ‚ü®a, k‚ü© q
  if H : k = 0 then simp [H, eq_comm]
  else
    have : q * k ‚â§ a ‚àß a < (q + 1) * k ‚Üî q = a / k := by
      rw [le_antisymm_iff, ‚Üê (@Nat.lt_succ _ q), Nat.le_div_iff_mul_le' (Nat.pos_of_ne_zero H),
          Nat.div_lt_iff_lt_mul' (Nat.pos_of_ne_zero H)]
    simpa [H, zero_lt_iff, eq_comm (b := q)]",":= by
  refine of_graph fst (fun p => Nat.div_le_self _ _) ?_
  have : PrimrecRel fun (a : ‚Ñï √ó ‚Ñï) (b : ‚Ñï) => (a.2 = 0 ‚àß b = 0) ‚à®
      (0 < a.2 ‚àß b * a.2 ‚â§ a.1 ‚àß a.1 < (b + 1) * a.2) :=
    PrimrecPred.or
      (.and (const 0 |> Primrec.eq.comp (fst |> snd.comp)) (const 0 |> Primrec.eq.comp snd))
      (.and (nat_lt.comp (const 0) (fst |> snd.comp)) <|
          .and (nat_le.comp (nat_mul.comp‚ÇÇ snd (fst |> snd.comp)) (fst |> fst.comp))
          (nat_lt.comp (fst.comp fst) (nat_mul.comp‚ÇÇ (Primrec.succ.comp snd) (snd.comp fst))))
  refine this.of_eq_rel ?_
  rintro ‚ü®a, k‚ü© q
  if H : k = 0 then simp [H, eq_comm]
  else
    have : q * k ‚â§ a ‚àß a < (q + 1) * k ‚Üî q = a / k := by
      rw [le_antisymm_iff, ‚Üê (@Nat.lt_succ _ q), Nat.le_div_iff_mul_le' (Nat.pos_of_ne_zero H),
          Nat.div_lt_iff_lt_mul' (Nat.pos_of_ne_zero H)]
    simpa [H, zero_lt_iff, eq_comm (b := q)]"
Mathlib/LinearAlgebra/FiniteDimensional.lean,Submodule.eq_top_of_finrank_eq,_root_.Submodule.eq_top_of_finrank_eq,fb6ba072b0a93cf43e39a87367072a958d7be9cf,":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent (by simpa using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]","error:  type mismatch
  h‚úù
has type
  LinearIndependent (Œπ := ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) K ‚áëbS : Prop
but is expected to have type
  LinearIndependent K fun (x : ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) ‚Ü¶ ‚Üëx : Prop
warning:  `finite_of_linearIndependent` has been deprecated, use `LinearIndependent.set_finite_of_isNoetherian` instead
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  no goals to be solved
error:  unknown identifier 'eq_top_of_finrank_eq'","theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ‚ä§ ",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
             finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpi_tfae,effectiveEpi_tfae,fba28f571f3d12084f060ccc0fd73ca4e275ccce,":= by
  tfae_have : 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have : 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have : 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (œÄ : X ‚ü∂ B) :
    TFAE
    [ EffectiveEpi œÄ
    , Epi œÄ
    , Function.Surjective œÄ
    ] ",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.mul_measure_le_of_subset_lt_limRatioMeas,mul_measure_le_of_subset_lt_limRatioMeas,2c23e43ba179a9dd2928e06c32f043d20e9798c8,":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº (t·∂ú) = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t);
  exact
    calc
      (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
      _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := (measure_union_le _ _)
      _ ‚â§ œÅ (s ‚à© t) + q * Œº (t·∂ú) := by
        apply add_le_add H
        rw [coe_nnreal_smul_apply]
        exact mul_le_mul_left' (measure_mono (inter_subset_right _ _)) _
      _ ‚â§ œÅ s := by
        rw [A, MulZeroClass.mul_zero, add_zero]; exact measure_mono (inter_subset_left _ _)
  refine' v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ _
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le",error:  unexpected token ';'; expected 'by' or 'from',"theorem mul_measure_le_of_subset_lt_limRatioMeas {q : ‚Ñù‚â•0} {s : Set Œ±}
    (h : s ‚äÜ {x | (q : ‚Ñù‚â•0‚àû) < v.limRatioMeas hœÅ x}) : (q : ‚Ñù‚â•0‚àû) * Œº s ‚â§ œÅ s ",":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº t·∂ú = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t) by calc
    (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
    _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := measure_union_le _ _
    _ ‚â§ œÅ (s ‚à© t) + (q ‚Ä¢ Œº) t·∂ú := by gcongr; apply inter_subset_right
    _ = œÅ (s ‚à© t) := by simp [A]
    _ ‚â§ œÅ s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ ?_
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le",":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº (t·∂ú) = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t) by
    calc
      (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
      _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := measure_union_le _ _
      _ ‚â§ œÅ (s ‚à© t) + q * Œº (t·∂ú) := by
        apply add_le_add H
        rw [coe_nnreal_smul_apply]
        exact mul_le_mul_left' (measure_mono inter_subset_right) _
      _ ‚â§ œÅ s := by
        rw [A, MulZeroClass.mul_zero, add_zero]; exact measure_mono inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) ?_ ?_
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le"
Mathlib/Topology/Homotopy/HomotopyGroup.lean,GenLoop.homotopicFrom,homotopicFrom,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, ?_,? _‚ü©?, _‚ü©
  pick_goal 3
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ rw [H.eq_fst]; exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    first
    | rw [H.apply_zero]
    | rw [H.apply_one]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv","warning:  GenLoop does not have a doc string
error:  unexpected token '?'; expected '‚ü©'","theorem homotopicFrom (i : N) {p q : Œ©^ N X x} :
    (toLoop i p).Homotopic (toLoop i q) ‚Üí Homotopic p q ",":= by
  refine Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, ?_, ?_‚ü©, ?_‚ü©
  pick_goal 3
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
        Function.uncurry_apply_pair]
      rw [H.eq_fst]
      exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
      Function.uncurry_apply_pair, ContinuousMap.HomotopyWith.apply_zero,
      ContinuousMap.HomotopyWith.apply_one, ne_eq, Path.coe_toContinuousMap, toLoop_apply_coe,
      ContinuousMap.curry_apply, ContinuousMap.comp_apply]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv",":= by
  refine Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, ?_, ?_‚ü©, ?_‚ü©
  pick_goal 3
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ rw [H.eq_fst]; exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    first
    | rw [H.apply_zero]
    | rw [H.apply_one]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv"
Mathlib/Data/Num/Lemmas.lean,PosNum.succ_to_nat,succ_to_nat,0c824fb54f74f0c66db893166b73e377be2feb6f,"  | 1 => rfl
  | bit0 p => rfl
  | bit1 p =>
    (congr_arg _root_.bit0 (succ_to_nat p)).trans <|
      show ‚Üëp + 1 + ‚Üëp + 1 = ‚Üëp + ‚Üëp + 1 + 1 by simp [Nat.add_right_comm]","warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unsolved goals
Œ± : Type u_1
p : PosNum
‚ä¢ 1 + (‚Üëp + 1) = ‚Üëp + 2
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `castNum` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated","theorem succ_to_nat : ‚àÄ n, (succ n : ‚Ñï) = n + 1
","  | 1 => rfl
  | bit0 p => rfl
  | bit1 p =>
    (congr_arg _root_.bit0 (succ_to_nat p)).trans <|
      show ‚Üëp + 1 + ‚Üëp + 1 = ‚Üëp + ‚Üëp + 1 + 1 by simp [add_left_comm]",":= by
  | 1 => rfl
  | bit1 p =>
    (congr_arg _root_.bit0 (succ_to_nat p)).trans <|
      show ‚Üëp + 1 + ‚Üëp + 1 = ‚Üëp + ‚Üëp + 1 + 1 by simp [Nat.add_right_comm]"
Mathlib/Analysis/SpecialFunctions/Integrals.lean,intervalIntegral.intervalIntegrable_rpow',intervalIntegrable_rpow',3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine' (continuousOn_id.rpow_const _).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",error:  no goals to be solved,"theorem intervalIntegrable_rpow' {r : ‚Ñù} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const _).div_const ?_; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]"
Mathlib/MeasureTheory/Function/AEEqFun.lean,MeasureTheory.AEEqFun.mk_coeFn,mk_coeFn,98432adbfdba1f3943aae82d872657b9de000467,":= by
  conv_lhs => simp only [cast]
  split_ifs with h
  ¬∑ exact Classical.choose_spec h |>.2.1.symm
  conv_rhs => rw [‚Üê Quotient.out_eq' f]
  rw [‚Üê mk, mk_eq_mk]
  exact (AEStronglyMeasurable.ae_eq_mk _).symm","warning:  AEEqFun does not have a doc string
error:  tactic 'split_ifs' failed, no if-then-else conditions to split
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œ¥ : Type u_4
inst‚úù¬≥ : MeasurableSpace Œ±
Œº ŒΩ : Measure Œ±
inst‚úù¬≤ : TopologicalSpace Œ≤
inst‚úù¬π : TopologicalSpace Œ≥
inst‚úù : TopologicalSpace Œ¥
f : Œ± ‚Üí‚Çò[Œº] Œ≤
‚ä¢ mk (AEStronglyMeasurable.mk ‚Üë(Quotient.out' f) ‚ãØ) ‚ãØ = f",theorem mk_coeFn (f : Œ± ‚Üí‚Çò[Œº] Œ≤) : mk f f.aestronglyMeasurable = f ,":= by
  conv_rhs => rw [‚Üê Quotient.out_eq' f]
  set g : { f : Œ± ‚Üí Œ≤ // AEStronglyMeasurable f Œº } := Quotient.out' f
  have : g = ‚ü®g.1, g.2‚ü© := Subtype.eq rfl
  rw [this, ‚Üê mk, mk_eq_mk]
  exact (AEStronglyMeasurable.ae_eq_mk _).symm",":= by
  conv_lhs => simp only [cast]
  split_ifs with h
  ¬∑ exact Classical.choose_spec h |>.2.1.symm
  conv_rhs => rw [‚Üê Quotient.out_eq' f]
  rw [‚Üê mk, mk_eq_mk]
  exact (AEStronglyMeasurable.ae_eq_mk _).symm"
Mathlib/Topology/Category/TopCat/Limits/Products.lean,TopCat.binaryCofan_isColimit_iff,binaryCofan_isColimit_iff,fdfff7b3a618d890d340c3e3a74a9ad345cdf7b7,":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine' ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inr, _‚ü©
      erw [Set.range_comp, ‚Üê eq_compl_iff_isCompl, coe_comp, coe_comp, Set.range_comp _ Sum.inr,
        ‚Üê Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
      aesop
    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      have : ‚àÄ x, x ‚àà Set.range c.inl ‚à® x ‚àà Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
        exact fun _ => or_not
      refine' ‚ü®BinaryCofan.IsColimit.mk _ _ _ _ _‚ü©
      ¬∑ intro T f g
        refine' ContinuousMap.mk _ _
        ¬∑ exact fun x =>
            if h : x ‚àà Set.range c.inl then f ((Equiv.ofInjective _ h‚ÇÅ.inj).symm ‚ü®x, h‚ü©)
            else g ((Equiv.ofInjective _ h‚ÇÇ.inj).symm ‚ü®x, (this x).resolve_left h‚ü©)
        rw [continuous_iff_continuousAt]
        intro x
        by_cases h : x ‚àà Set.range c.inl
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            convert_to Continuous (f ‚àò h‚ÇÅ.toHomeomorph.symm)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_pos hx
            apply Continuous.comp
            ¬∑ exact f.continuous_toFun
            ¬∑ continuity
          ¬∑ exact h‚ÇÅ.isOpen_range
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            have : ‚àÄ a, a ‚àâ Set.range c.inl ‚Üí a ‚àà Set.range c.inr := by
              rintro a (h : a ‚àà (Set.range c.inl)·∂ú)
              rwa [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            convert_to Continuous
                (g ‚àò h‚ÇÇ.toHomeomorph.symm ‚àò Subtype.map _ this)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_neg hx
            apply Continuous.comp
            ¬∑ exact g.continuous_toFun
            ¬∑ apply Continuous.comp
              ¬∑ continuity
              ¬∑ rw [embedding_subtype_val.toInducing.continuous_iff]
                exact continuous_subtype_val
          ¬∑ change IsOpen (Set.range c.inl)·∂ú
            rw [‚Üê eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            exact h‚ÇÇ.isOpen_range
      ¬∑ intro T f g
        ext x
        refine' (dif_pos _).trans _
        ¬∑ exact ‚ü®x, rfl‚ü©
        ¬∑ dsimp; conv_lhs => erw [Equiv.ofInjective_symm_apply]
      ¬∑ intro T f g
        ext x
        refine' (dif_neg _).trans _
        ¬∑ rintro ‚ü®y, e‚ü©
          have : c.inr x ‚àà Set.range c.inl ‚äì Set.range c.inr := ‚ü®‚ü®_, e‚ü©, ‚ü®_, rfl‚ü©‚ü©
          rwa [disjoint_iff.mp h‚ÇÉ.1] at this
        ¬∑ exact congr_arg g (Equiv.ofInjective_symm_apply _ _)
      ¬∑ rintro T _ _ m rfl rfl
        ext x
        change m x = dite _ _ _
        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ‚ü®_, _‚ü©).symm","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚áë(?f ‚â´ ?g)
case mp.intro
J : Type v
inst‚úù : SmallCategory J
X Y : TopCat
c : BinaryCofan X Y
h : IsColimit c
‚ä¢ ‚áë(h.coconePointUniqueUpToIso (X.binaryCofanIsColimit Y)).inv '' Set.range ‚áë(X.binaryCofan Y).inl =
    (Set.range (‚áë(h.coconePointUniqueUpToIso (X.binaryCofanIsColimit Y)).inv ‚àò ‚áë(X.binaryCofan Y).inr))·∂ú
error:  invalid field 'toHomeomorph', the environment does not contain 'OpenEmbedding.toHomeomorph'
  h‚ÇÅ
has type
  OpenEmbedding ‚áëc.inl
error:  tactic 'aesop' failed, failed to prove the goal after exhaustive search.
Initial goal:
  case pos.convert_3.hf
  J : Type v
  inst‚úù : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  h‚ÇÅ : OpenEmbedding ‚áëc.inl
  h‚ÇÇ : OpenEmbedding ‚áëc.inr
  h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
  this :
    ‚àÄ (x : ‚Üë(((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := WalkingPair.left })),
      x ‚àà Set.range ‚áëc.inl ‚à® x ‚àà Set.range ‚áëc.inr
  T : TopCat
  f : X ‚ü∂ T
  g : Y ‚ü∂ T
  ‚ä¢ Continuous (sorryAx (‚Üë(Set.range ‚áëc.inl) ‚Üí ‚ÜëX) true)
Remaining goals after safe rules:
  J : Type v
  inst : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  T : TopCat
  f : X ‚ü∂ T
  g : Y ‚ü∂ T
  h‚ÇÅ : OpenEmbedding ‚áëc.inl
  h‚ÇÇ : OpenEmbedding ‚áëc.inr
  h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
  this : ‚àÄ (x : ‚Üëc.pt), (‚àÉ y, c.inl y = x) ‚à® ‚àÉ y, c.inr y = x
  ‚ä¢ Continuous (sorryAx (‚Üë(Set.range ‚áëc.inl) ‚Üí ‚ÜëX) true)
error:  invalid field 'toHomeomorph', the environment does not contain 'OpenEmbedding.toHomeomorph'
  h‚ÇÇ
has type
  OpenEmbedding ‚áëc.inr
error:  tactic 'aesop' failed, failed to prove the goal after exhaustive search.
Initial goal:
  case neg.hf.hg
  J : Type v
  inst‚úù : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  h‚ÇÅ : OpenEmbedding ‚áëc.inl
  h‚ÇÇ : OpenEmbedding ‚áëc.inr
  h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
  this‚úù :
    ‚àÄ (x : ‚Üë(((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := WalkingPair.left })),
      x ‚àà Set.range ‚áëc.inl ‚à® x ‚àà Set.range ‚áëc.inr
  T : TopCat
  f : X ‚ü∂ T
  g : Y ‚ü∂ T
  this : ‚àÄ a ‚àâ Set.range ‚áëc.inl, a ‚àà Set.range ‚áëc.inr
  ‚ä¢ Continuous (sorryAx (Subtype Exists ‚Üí ‚ÜëY) true)
Remaining goals after safe rules:
  J : Type v
  inst : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  T : TopCat
  f : X ‚ü∂ T
  g : Y ‚ü∂ T
  h‚ÇÅ : OpenEmbedding ‚áëc.inl
  h‚ÇÇ : OpenEmbedding ‚áëc.inr
  h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
  this_1 : ‚àÄ (x : ‚Üëc.pt), (‚àÉ y, c.inl y = x) ‚à® ‚àÉ y, c.inr y = x
  this : ‚àÄ (a : ‚Üëc.pt), (‚àÄ (x : ‚ÜëX), ¬¨c.inl x = a) ‚Üí ‚àÉ y, c.inr y = a
  ‚ä¢ Continuous (sorryAx (Subtype Exists ‚Üí ‚ÜëY) true)
error:  type mismatch
  continuous_subtype_val
has type
  Continuous Subtype.val : Prop
but is expected to have type
  Continuous (Subtype.val ‚àò Subtype.map (fun a y ‚Ü¶ c.inr y = a) this) : Prop
error:  unsolved goals
case mpr.intro.intro.refine'_2.w.refine'_2
J : Type v
inst‚úù : SmallCategory J
X Y : TopCat
c : BinaryCofan X Y
h‚ÇÅ : OpenEmbedding ‚áëc.inl
h‚ÇÇ : OpenEmbedding ‚áëc.inr
h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
this :
  ‚àÄ (x : ‚Üë(((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := WalkingPair.left })),
    x ‚àà Set.range ‚áëc.inl ‚à® x ‚àà Set.range ‚áëc.inr
T : TopCat
f : X ‚ü∂ T
g : Y ‚ü∂ T
x : (forget TopCat).obj ((pair X Y).obj { as := WalkingPair.left })
‚ä¢ f x = f x","theorem binaryCofan_isColimit_iff {X Y : TopCat} (c : BinaryCofan X Y) :
    Nonempty (IsColimit c) ‚Üî
      OpenEmbedding c.inl ‚àß OpenEmbedding c.inr ‚àß IsCompl (Set.range c.inl) (Set.range c.inr) ",":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inr, ?_‚ü©
      erw [Set.range_comp, ‚Üê eq_compl_iff_isCompl, Set.range_comp _ Sum.inr,
        ‚Üê Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      have : ‚àÄ x, x ‚àà Set.range c.inl ‚à® x ‚àà Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
        exact fun _ => or_not
      refine ‚ü®BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_‚ü©
      ¬∑ intro T f g
        refine ContinuousMap.mk ?_ ?_
        ¬∑ exact fun x =>
            if h : x ‚àà Set.range c.inl then f ((Equiv.ofInjective _ h‚ÇÅ.inj).symm ‚ü®x, h‚ü©)
            else g ((Equiv.ofInjective _ h‚ÇÇ.inj).symm ‚ü®x, (this x).resolve_left h‚ü©)
        rw [continuous_iff_continuousAt]
        intro x
        by_cases h : x ‚àà Set.range c.inl
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            convert_to Continuous (f ‚àò (Homeomorph.ofEmbedding _ h‚ÇÅ.toEmbedding).symm)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_pos hx
            apply Continuous.comp
            ¬∑ exact f.continuous_toFun
            ¬∑ continuity
          ¬∑ exact h‚ÇÅ.isOpen_range
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            have : ‚àÄ a, a ‚àâ Set.range c.inl ‚Üí a ‚àà Set.range c.inr := by
              rintro a (h : a ‚àà (Set.range c.inl)·∂ú)
              rwa [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            convert_to Continuous
                (g ‚àò (Homeomorph.ofEmbedding _ h‚ÇÇ.toEmbedding).symm ‚àò Subtype.map _ this)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_neg hx
            apply Continuous.comp
            ¬∑ exact g.continuous_toFun
            ¬∑ apply Continuous.comp
              ¬∑ continuity
              ¬∑ rw [embedding_subtype_val.toInducing.continuous_iff]
                exact continuous_subtype_val
          ¬∑ change IsOpen (Set.range c.inl)·∂ú
            rw [‚Üê eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            exact h‚ÇÇ.isOpen_range
      ¬∑ intro T f g
        ext x
        refine (dif_pos ?_).trans ?_
        ¬∑ exact ‚ü®x, rfl‚ü©
        ¬∑ dsimp
          conv_lhs => erw [Equiv.ofInjective_symm_apply]
          rfl 
      ¬∑ intro T f g
        ext x
        refine (dif_neg ?_).trans ?_
        ¬∑ rintro ‚ü®y, e‚ü©
          have : c.inr x ‚àà Set.range c.inl ‚äì Set.range c.inr := ‚ü®‚ü®_, e‚ü©, ‚ü®_, rfl‚ü©‚ü©
          rwa [disjoint_iff.mp h‚ÇÉ.1] at this
        ¬∑ exact congr_arg g (Equiv.ofInjective_symm_apply _ _)
      ¬∑ rintro T _ _ m rfl rfl
        ext x
        change m x = dite _ _ _
        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ‚ü®_, _‚ü©).symm",":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
           (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
           (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binary"
Mathlib/MeasureTheory/Measure/Haar/Unique.lean,MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure,measure_isMulInvariant_eq_smul_of_isCompact_closure,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  apply le_antisymm ?_ (smul_measure_isMulInvariant_le_of_isCompact_closure Œº' Œº hs h's)
  let ŒΩ := haarScalarFactor Œº' Œº ‚Ä¢ Œº
  change Œº' s ‚â§ ŒΩ s
  obtain ‚ü®‚ü®f, f_cont‚ü©, hf, -, f_comp, -‚ü© : ‚àÉ f : C(G, ‚Ñù), EqOn f 1 (closure s) ‚àß EqOn f 0 ‚àÖ
      ‚àß HasCompactSupport f ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 :=
    exists_continuous_one_zero_of_isCompact h's isClosed_empty (disjoint_empty _)
  let t := f ‚Åª¬π' {1}
  have t_closed : IsClosed t := isClosed_singleton.preimage f_cont
  have t_comp : IsCompact t := f_comp.isCompact_preimage f_cont isClosed_singleton (by simp)
  have st : s ‚äÜ t := (IsClosed.closure_subset_iff t_closed).mp hf
  have A : ŒΩ (t \ s) ‚â§ Œº' (t \ s) := by
    apply smul_measure_isMulInvariant_le_of_isCompact_closure _ _ (t_closed.measurableSet.diff hs)
    exact t_comp.closure_of_subset (diff_subset t s)
  have B : Œº' t = ŒΩ t :=
    measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp
  rwa [measure_diff st hs, measure_diff st hs, ‚Üê B, ENNReal.sub_le_sub_iff_left] at A
  ¬∑ exact measure_mono st
  ¬∑ exact t_comp.measure_lt_top.ne
  ¬∑ exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne
  ¬∑ exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne","error:  application type mismatch
  diff_subset t
argument
  t
has type
  Set G : Type u_1
but is expected to have type
  ?m.165361 ‚àà ?m.165359 \ ?m.165360 : Prop","lemma measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop
    [LocallyCompactSpace G]
    (Œº' Œº : Measure G) [IsHaarMeasure Œº] [IsFiniteMeasureOnCompacts Œº'] [IsMulLeftInvariant Œº']
    [InnerRegularCompactLTTop Œº]
    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :
    Œº' s = haarScalarFactor Œº' Œº ‚Ä¢ Œº s ",":= by
  apply le_antisymm ?_ (smul_measure_isMulInvariant_le_of_isCompact_closure Œº' Œº hs h's)
  let ŒΩ := haarScalarFactor Œº' Œº ‚Ä¢ Œº
  change Œº' s ‚â§ ŒΩ s
  obtain ‚ü®‚ü®f, f_cont‚ü©, hf, -, f_comp, -‚ü© : ‚àÉ f : C(G, ‚Ñù), EqOn f 1 (closure s) ‚àß EqOn f 0 ‚àÖ
      ‚àß HasCompactSupport f ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 :=
    exists_continuous_one_zero_of_isCompact h's isClosed_empty (disjoint_empty _)
  let t := f ‚Åª¬π' {1}
  have t_closed : IsClosed t := isClosed_singleton.preimage f_cont
  have t_comp : IsCompact t := f_comp.isCompact_preimage f_cont isClosed_singleton (by simp)
  have st : s ‚äÜ t := (IsClosed.closure_subset_iff t_closed).mp hf
  have A : ŒΩ (t \ s) ‚â§ Œº' (t \ s) := by
    apply smul_measure_isMulInvariant_le_of_isCompact_closure _ _ (t_closed.measurableSet.diff hs)
    exact t_comp.closure_of_subset diff_subset
  have B : Œº' t = ŒΩ t :=
    measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp
  rwa [measure_diff st hs, measure_diff st hs, ‚Üê B, ENNReal.sub_le_sub_iff_left] at A
  ¬∑ exact measure_mono st
  ¬∑ exact t_comp.measure_lt_top.ne
  ¬∑ exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne
  ¬∑ exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne",":= by
  apply le_antisymm ?_ (smul_measure_isMulInvariant_le_of_isCompact_closure Œº' Œº hs h's)
  let ŒΩ := haarScalarFactor Œº' Œº ‚Ä¢ Œº
  change Œº' s ‚â§ ŒΩ s
  obtain ‚ü®‚ü®f, f_cont‚ü©, hf, -, f_comp, -‚ü© : ‚àÉ f : C(G, ‚Ñù), EqOn f 1 (closure s) ‚àß EqOn f 0 ‚àÖ
      ‚àß HasCompactSupport f ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 :=
    exists_continuous_one_zero_of_isCompact h's isClosed_empty (disjoint_empty _)
  let t := f ‚Åª¬π' {1}
  have t_closed : IsClosed t := isClosed_singleton.preimage f_cont
  have t_comp : IsCompact t := f_comp.isCompact_preimage f_cont isClosed_singleton (by simp)
  have st : s ‚äÜ t := (IsClosed.closure_subset_iff t_closed).mp hf
  have A : ŒΩ (t \ s) ‚â§ Œº' (t \ s) := by
    apply smul_measure_isMulInvariant_le_of_isCompact_closure _ _ f_cont f_comp
  rwa [measure_diff st hs, measure_diff st hs, ‚Üê B, ENNReal.sub_le_sub_iff_left] at A
  ¬∑ exact measure_mono st
  ¬∑ exact t_comp.measure_lt_top.ne
  ¬∑ exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne
  ¬∑ exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne"
Mathlib/Analysis/ConstantSpeed.lean,hasConstantSpeedOnWith_zero_iff,hasConstantSpeedOnWith_zero_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  dsimp [HasConstantSpeedOnWith]
  simp only [zero_mul, ENNReal.ofReal_zero, ‚Üê eVariationOn.eq_zero_iff]
  constructor
  ¬∑ by_contra!
    obtain ‚ü®h, hfs‚ü© := this
    simp_rw [ne_eq, eVariationOn.eq_zero_iff] at hfs h
    push_neg at hfs
    obtain ‚ü®x, xs, y, ys, hxy‚ü© := hfs
    rcases le_total x y with (xy | yx)
    ¬∑ exact hxy (h xs ys x ‚ü®xs, le_rfl, xy‚ü© y ‚ü®ys, xy, le_rfl‚ü©)
    ¬∑ rw [edist_comm] at hxy
      exact hxy (h ys xs y ‚ü®ys, le_rfl, yx‚ü© x ‚ü®xs, yx, le_rfl‚ü©)
  ¬∑ rintro h x _ y _
    refine le_antisymm ?_ zero_le'
    rw [‚Üê h]
    exact eVariationOn.mono f (inter_subset_left s (Icc x y))","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set ‚Ñù : Type
but is expected to have type
  ?m.16196 ‚àà ?m.16194 ‚à© ?m.16195 : Prop","theorem hasConstantSpeedOnWith_zero_iff :
    HasConstantSpeedOnWith f s 0 ‚Üî ‚àÄ·µâ (x ‚àà s) (y ‚àà s), edist (f x) (f y) = 0 ",":= by
  dsimp [HasConstantSpeedOnWith]
  simp only [zero_mul, ENNReal.ofReal_zero, ‚Üê eVariationOn.eq_zero_iff]
  constructor
  ¬∑ by_contra!
    obtain ‚ü®h, hfs‚ü© := this
    simp_rw [ne_eq, eVariationOn.eq_zero_iff] at hfs h
    push_neg at hfs
    obtain ‚ü®x, xs, y, ys, hxy‚ü© := hfs
    rcases le_total x y with (xy | yx)
    ¬∑ exact hxy (h xs ys x ‚ü®xs, le_rfl, xy‚ü© y ‚ü®ys, xy, le_rfl‚ü©)
    ¬∑ rw [edist_comm] at hxy
      exact hxy (h ys xs y ‚ü®ys, le_rfl, yx‚ü© x ‚ü®xs, yx, le_rfl‚ü©)
  ¬∑ rintro h x _ y _
    refine le_antisymm ?_ zero_le'
    rw [‚Üê h]
    exact eVariationOn.mono f inter_subset_left",":= by
  dsimp [HasConstantSpeedOnWith]
  simp only [zero_mul, ENNReal.ofReal_zero, ‚Üê eVariationOn.eq_zero_iff]
  constructor
  ¬∑ by_contra!
    obtain ‚ü®h, hfs‚ü© := this
    simp_rw [ne_eq, eVariationOn.eq_zero_iff] at hfs h
    push_neg at hfs
    obtain ‚ü®x, xs, y, ys, hxy‚ü© := hfs
    rcases le_total x y with (xy | yx)
    ¬∑ exact hxy (h xs ys x ‚ü®xs, le_rfl, xy‚ü© y ‚ü®ys, xy, le_rfl‚ü©)
    ¬∑ rw [edist_comm] at hxy
      exact hxy (h ys xs y ‚ü®ys, le_rfl, yx‚ü© x ‚ü®xs, yx, le_rfl‚ü©)
  ¬∑ rintro h x _ y _
    refine le_antisymm ?_ zero_le'
    rw [‚Üê h]
    exact eVariationOn.mono f inter_subset_left"
Mathlib/GroupTheory/Torsion.lean,ExponentExists.isTorsion,ExponentExists.isTorsion,1d775649ea8e0e1abd5584cd2fe1890edc775880,":= fun g => by
  obtain ‚ü®n, npos, hn‚ü© := h
  exact (isOfFinOrder_iff_pow_eq_one g).mpr ‚ü®n, npos, hn g‚ü©","error:  function expected at
  isOfFinOrder_iff_pow_eq_one
term has type
  IsOfFinOrder ?m.11128 ‚Üî ‚àÉ n, 0 < n ‚àß ?m.11128 ^ n = 1",theorem ExponentExists.isTorsion (h : ExponentExists G) : IsTorsion G ,":= fun g => by
  obtain ‚ü®n, npos, hn‚ü© := h
  exact isOfFinOrder_iff_pow_eq_one.mpr ‚ü®n, npos, hn g‚ü©",":= by
  obtain ‚ü®n, npos, hn‚ü© := h
  exact (isOfFinOrder_iff_pow_eq_one g).mpr ‚ü®n, npos, hn g‚ü©"
Mathlib/Probability/Process/PartitionFiltration.lean,ProbabilityTheory.iSup_partitionFiltration,iSup_partitionFiltration,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  conv_rhs => rw [‚Üê generateFrom_iUnion_memPartition t, ‚Üê iSup_generateFrom]","error:  unsolved goals
Œ± : Type u_1
m : MeasurableSpace Œ±
t : ‚Ñï ‚Üí Set Œ±
ht : ‚àÄ (n : ‚Ñï), MeasurableSet (t n)
‚ä¢ ‚®Ü n, ‚Üë(partitionFiltration ht) n = ‚®Ü i, generateFrom (memPartition t i)","lemma iSup_partitionFiltration_eq_generateFrom_range (ht : ‚àÄ n, MeasurableSet (t n)) :
    ‚®Ü n, partitionFiltration ht n = generateFrom (Set.range t) ",":= by
  conv_rhs => rw [‚Üê generateFrom_iUnion_memPartition t, ‚Üê iSup_generateFrom]
  rfl",":= by
  rw [‚Üê generateFrom_iUnion_memPartition t, ‚Üê iSup_generateFrom]"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right _ _, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) ?_
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 ‚àà ?m.92170 ‚à™ ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 ‚àà ?m.92636 ‚à™ ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 ‚àà ?m.94503 ‚à™ ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 ‚àà ?m.97297 ‚à™ ?m.97298
error:  function expected at
  subset_union_left ?m.98875
term has type
  ?m.98874 ‚àà ?m.98872 ‚à™ ?m.98873","theorem shadow_compression_subset_compression_shadow (u v : Finset Œ±)
    (huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú) :
    ‚àÇ (ùìí u v ùíú) ‚äÜ ùìí u v (‚àÇ ùíú) ",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine mem_shadow_iff.2
        ‚ü®(t ‚äî u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) ?_
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.mul_le_addHaar_image_of_lt_det,mul_le_addHaar_image_of_lt_det,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine' Tendsto.mul (tendsto_const_nhds.mul _) tendsto_id
      refine' (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ _
      simpa only [tsub_zero, inv_eq_zero, Ne.def] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toLocalEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target
  ¬∑ change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne.def] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne.def, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)","error:  unexpected token '¬∑'; expected 'by' or 'from'
error:  unsolved goals
case h
E : Type u_1
F : Type u_2
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : FiniteDimensional ‚Ñù E
inst‚úù‚Å¥ : NormedAddCommGroup F
inst‚úù¬≥ : NormedSpace ‚Ñù F
s‚úù : Set E
f‚úù : E ‚Üí E
f' : E ‚Üí E ‚ÜíL[‚Ñù] E
inst‚úù¬≤ : MeasurableSpace E
inst‚úù¬π : BorelSpace E
Œº : Measure E
inst‚úù : Œº.IsAddHaarMeasure
A : E ‚ÜíL[‚Ñù] E
m : ‚Ñù‚â•0
hm : ‚Üëm < ENNReal.ofReal |A.det|
mpos : 0 < m
hA : A.det ‚â† 0
B : E ‚âÉL[‚Ñù] E := A.toContinuousLinearEquivOfDetNeZero hA
I : ENNReal.ofReal |(‚ÜëB.symm).det| < ‚Üëm‚Åª¬π
Œ¥‚ÇÄ : ‚Ñù‚â•0
Œ¥‚ÇÄpos : 0 < Œ¥‚ÇÄ
hŒ¥‚ÇÄ : ‚àÄ (t : Set E) (g : E ‚Üí E), ApproximatesLinearOn g (‚ÜëB.symm) t Œ¥‚ÇÄ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t
L1 : ‚àÄ·∂† (Œ¥ : ‚Ñù‚â•0) in ùìù 0, Subsingleton E ‚à® Œ¥ < ‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π
L2 : ‚àÄ·∂† (Œ¥ : ‚Ñù‚â•0) in ùìù 0, ‚Äñ‚ÜëB.symm‚Äñ‚Çä * (‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ
Œ¥ : ‚Ñù‚â•0
h1Œ¥ : Subsingleton E ‚à® Œ¥ < ‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π
h2Œ¥ : ‚Äñ‚ÜëB.symm‚Äñ‚Çä * (‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ
s : Set E
f : E ‚Üí E
hf : ApproximatesLinearOn f A s Œ¥
hf' : ApproximatesLinearOn f (‚ÜëB) s Œ¥
‚ä¢ ‚Üëm * Œº s ‚â§ Œº (f '' s)","theorem mul_le_addHaar_image_of_lt_det (A : E ‚ÜíL[‚Ñù] E) {m : ‚Ñù‚â•0}
    (hm : (m : ‚Ñù‚â•0‚àû) < ENNReal.ofReal |A.det|) :
    ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù‚â•0),
      ‚àÄ (s : Set E) (f : E ‚Üí E), ApproximatesLinearOn f A s Œ¥ ‚Üí (m : ‚Ñù‚â•0‚àû) * Œº s ‚â§ Œº (f '' s) ",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ filter_upwards
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_eq_zero, Ne] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toPartialEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target by
    change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_zero, inv_zero] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_zero, inv_zero, inv_zero] using tendsto_const_nhds
      refine Tendsto.mul"
Mathlib/CategoryTheory/Adjunction/FullyFaithful.lean,CategoryTheory.Adjunction.inv_counit_map,inv_counit_map,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  IsIso.inv_eq_of_inv_hom_id h.right_triangle_components","error:  application type mismatch
  IsIso.inv_eq_of_inv_hom_id (right_triangle_components h)
argument
  right_triangle_components h
has type
  ‚àÄ (Y : D), h.unit.app (R.obj Y) ‚â´ R.map (h.counit.app Y) = ùüô (R.obj Y) : Prop
but is expected to have type
  h.unit.app (R.obj X) ‚â´ R.map (h.counit.app X) = ùüô (R.obj ((ùü≠ D).obj X)) : Prop","theorem inv_counit_map {X : D} [IsIso (h.counit.app X)] :
    inv (R.map (h.counit.app X)) = h.unit.app (R.obj X) ",":=
  IsIso.inv_eq_of_inv_hom_id (h.right_triangle_components X)",":=
  IsIso.inv_eq_of_inv_hom_id h.right_triang_components"
Mathlib/Topology/CompactOpen.lean,ContinuousMap.continuous_comp,continuous_comp,847a3fdc5138725139077c1ba700dd4bb54bb91c,":= by
  simp_rw [compactOpen_eq, continuous_generateFrom_iff, forall_image2_iff, mapsTo',
    CompactOpen.gen, image_subset_iff, preimage_setOf_eq, mem_setOf]","error:  unknown identifier 'CompactOpen.gen'
error:  simp made no progress
warning:  `ContinuousMap.curry'` has been deprecated, use `ContinuousMap.curry` instead","lemma continuous_compactOpen {f : X ‚Üí C(Y, Z)} :
    Continuous f ‚Üî ‚àÄ K, IsCompact K ‚Üí ‚àÄ U, IsOpen U ‚Üí IsOpen {x | MapsTo (f x) K U} ",":=
  continuous_generateFrom_iff.trans forall_image2_iff",":= by
  simp_rw [compactOpen_eq, continuous_generateFrom_iff, forall_image2_iff, mapsTo']"
Mathlib/Topology/UniformSpace/UniformConvergence.lean,tendstoLocallyUniformlyOn_iff_filter,tendstoLocallyUniformlyOn_iff_filter,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  simp only [TendstoUniformlyOnFilter, eventually_prod_iff]
  constructor
  ¬∑ rintro h x hx u hu
    obtain ‚ü®s, hs1, hs2‚ü© := h u hu x hx
    exact ‚ü®_, hs2, _, eventually_of_mem hs1 fun x => id, fun hi y hy => hi y hy‚ü©
  ¬∑ rintro h u hu x hx
    obtain ‚ü®pa, hpa, pb, hpb, h‚ü© := h x hx u hu
    exact ‚ü®‚ü®pb‚ü©, hpb, eventually_of_mem hpa fun i hi y hy => h hi hy‚ü©","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  Œ± ‚Üí Prop","theorem tendstoLocallyUniformlyOn_iff_filter :
    TendstoLocallyUniformlyOn F f p s ‚Üî ‚àÄ x ‚àà s, TendstoUniformlyOnFilter F f p (ùìù[s] x) ",":= by
  simp only [TendstoUniformlyOnFilter, eventually_prod_iff]
  constructor
  ¬∑ rintro h x hx u hu
    obtain ‚ü®s, hs1, hs2‚ü© := h u hu x hx
    exact ‚ü®_, hs2, _, eventually_of_mem hs1 fun x => id, fun hi y hy => hi y hy‚ü©
  ¬∑ rintro h u hu x hx
    obtain ‚ü®pa, hpa, pb, hpb, h‚ü© := h x hx u hu
    exact ‚ü®pb, hpb, eventually_of_mem hpa fun i hi y hy => h hi hy‚ü©",":= by
  simp only [TendstoUniformlyOnFilter, eventually_prod_iff]
  constructor
  ¬∑ rintro h x hx u hu
    obtain ‚ü®s, hs1, hs2‚ü© := h u hu x hx
    exact ‚ü®_, hs2, _, eventually_of_mem hs1 fun x => id, fun hi y hy => hi y hy‚ü©
  ¬∑ rintro h u hu x hx
    obtain ‚ü®pa, hpa, pb, hpb, h‚ü© := h x hx u hu
    exact ‚ü®‚ü®pb‚ü©, hpb, eventually_of_mem hpa fun i hi y hy => h hi hy‚ü©"
Mathlib/LinearAlgebra/BilinearForm/Properties.lean,LinearMap.BilinForm.dualBasis_dualBasis,dualBasis_dualBasis,31c261277bc3e8a52b74d248691ef6b40c75b452,":=
  LinearMap.BilinForm.dualBasis_dualBasis_flip (BilinForm.toLin B) hB b","warning:  `LinearMap.BilinForm.toLin` has been deprecated
error:  fail to show termination for
  LinearMap.BilinForm.dualBasis_dualBasis_flip
with errors
structural recursion cannot be used:

argument #1 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #2 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #3 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #4 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #5 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #6 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #7 cannot be used for structural recursion
  its type does not have a recursor

argument #8 cannot be used for structural recursion
  its type is not an inductive

argument #9 cannot be used for structural recursion
  its type is not an inductive

argument #10 cannot be used for structural recursion
  its type does not have a recursor

argument #11 cannot be used for structural recursion
  its type is not an inductive

argument #12 cannot be used for structural recursion
  its type does not have a recursor

Could not find a decreasing measure.
The arguments relate at each recursive call as follows:
(<, ‚â§, =: relation proved, ? all proofs failed, _: no proof attempted)
           
1) 357:2-71
Please use `termination_by` to specify a decreasing measure.","lemma dualBasis_dualBasis_flip (B : BilinForm K V) (hB : B.Nondegenerate) {Œπ}
    [Finite Œπ] [DecidableEq Œπ] (b : Basis Œπ K V) :
    B.dualBasis hB (B.flip.dualBasis hB.flip b) = b ",":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ‚Ü¶ ?_))
  simp_rw [apply_dualBasis_left, ‚Üê B.flip_apply, apply_dualBasis_left, @eq_comm _ i j]",":=
  LinearMap.BilinForm.dualBasis_dualBasis_flip hB b"
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,3710573e803613ba42d61073f0a18aa1c7564c5b,":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    unfold inversion
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ F ‚ÜíL[‚Ñù] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x ‚Ü¶ c + x) x) c) ^ 2 ‚Ä¢
      ‚Üë{ toLinearEquiv := (reflection (Submodule.span ‚Ñù {(fun x ‚Ü¶ c + x) x - c})·óÆ).toLinearEquiv, continuous_toFun := ‚ãØ,
          continuous_invFun := ‚ãØ })
    ((fun x ‚Ü¶ c + x) x)","theorem hasFDerivAt_inversion (hx : x ‚â† c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 ‚Ä¢ (reflection (‚Ñù ‚àô (x - c))·óÆ : F ‚ÜíL[‚Ñù] F)) x ",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (?_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    unfold inversion
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]"
Mathlib/Analysis/Calculus/LineDeriv/Basic.lean,HasFDerivWithinAt.hasLineDerivWithinAt,HasFDerivWithinAt.hasLineDerivWithinAt,e3adc4f0695a3d67fb7d7efd6330f16323f31c79,":= by
  let F := fun (t : ùïú) ‚Ü¶ x + t ‚Ä¢ v
  rw [show x = F (0 : ùïú) by simp] at hf
  have A : HasDerivWithinAt F (0 + (1 : ùïú) ‚Ä¢ v) (F ‚Åª¬π' s) 0 :=
    ((hasDerivAt_const (0 : ùïú) x).add ((hasDerivAt_id' (0 : ùïú)).smul_const v)).hasDerivWithinAt
  simp only [one_smul, zero_add] at A
  exact hf.comp_hasDerivWithinAt (x := (0 : ùïú)) A (mapsTo_preimage F s)",error:  simp made no progress,"lemma HasFDerivWithinAt.hasLineDerivWithinAt (hf : HasFDerivWithinAt f L s x) (v : E) :
    HasLineDerivWithinAt ùïú f (L v) s x v ",":= by
  let F := fun (t : ùïú) ‚Ü¶ x + t ‚Ä¢ v
  rw [show x = F (0 : ùïú) by simp [F]] at hf
  have A : HasDerivWithinAt F (0 + (1 : ùïú) ‚Ä¢ v) (F ‚Åª¬π' s) 0 :=
    ((hasDerivAt_const (0 : ùïú) x).add ((hasDerivAt_id' (0 : ùïú)).smul_const v)).hasDerivWithinAt
  simp only [one_smul, zero_add] at A
  exact hf.comp_hasDerivWithinAt (x := (0 : ùïú)) A (mapsTo_preimage F s)",":= by
  let F := fun (t : ùïú) ‚Ü¶ x + t ‚Ä¢ v
  rw [show x = F (0 : ùïú) by simp] at hf
  have A : HasDerivWithinAt F (0 + (1 : ùïú) ‚Ä¢ v) (F ‚Åª¬π' s) 0 :=
    ((hasDerivAt_const (0 : ùïú) x).add ((hasDerivAt_id' (0 : ùïú)).smul_const v)).hasDerivWithinAt
  simp only [one_smul, zero_add] at A
  exact hf.comp_hasDerivWithinAt (x := (0 : ùïú)) A (mapsTo_preimage F s)"
Mathlib/Algebra/Order/Group/Abs.lean,abs_add,abs_add,2b42dc7c3f9ebf6e7f17bff850d9c0bc3f1cf75e,":=
  abs_le.2
    ‚ü®(neg_add (|a|) (|b|)).symm ‚ñ∏
        add_le_add ((@neg_le Œ± ..).2 <| neg_le_abs_self _) ((@neg_le Œ± ..).2 <| neg_le_abs_self _),
      add_le_add (le_abs_self _) (le_abs_self _)‚ü©","warning:  @mabs does not have a doc string
error:  unknown identifier 'neg_le_abs_self'
error:  unknown identifier 'neg_le_abs_self'",theorem abs_add (a b : Œ±) : |a + b| ‚â§ |a| + |b| ,":=
  abs_le.2
    ‚ü®(neg_add |a| |b|).symm ‚ñ∏
        add_le_add ((@neg_le Œ± ..).2 <| neg_le_abs _) ((@neg_le Œ± ..).2 <| neg_le_abs _),
      add_le_add (le_abs_self _) (le_abs_self _)‚ü©",":=
  abs_le.2
    ‚ü®(neg_add (|a|) (|b|)).symm ‚ñ∏
        add_le_add ((@neg_le Œ± ..).2 <| neg_le_abs_self _) ((@neg_le Œ± ..).2 <| neg_le_abs_self _),
      add_le_add (le_abs_self _) (le_abs_self _)‚ü©"
Mathlib/MeasureTheory/Group/Measure.lean,MeasureTheory.measure_univ_of_isMulLeftInvariant,measure_univ_of_isMulLeftInvariant,488012d0f5ac537bb8055c310b3f223de3f6802e,":= by
  obtain ‚ü®K, hK, Kclosed, K1‚ü© : ‚àÉ K : Set G, IsCompact K ‚àß IsClosed K ‚àß K ‚àà ùìù 1 :=
    exists_isCompact_isClosed_nhds_one G
  have K_pos : 0 < Œº K := measure_pos_of_nonempty_interior _ ‚ü®_, mem_interior_iff_mem_nhds.2 K1‚ü©
  have A : ‚àÄ L : Set G, IsCompact L ‚Üí ‚àÉ g : G, Disjoint L (g ‚Ä¢ K) := fun L hL =>
    exists_disjoint_smul_of_isCompact hL hK
  choose! g hg using A
  set L : ‚Ñï ‚Üí Set G := fun n => (fun T => T ‚à™ g T ‚Ä¢ K)^[n] K
  have Lcompact : ‚àÄ n, IsCompact (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact hK
    ¬∑ simp_rw [iterate_succ']
      apply IsCompact.union IH (hK.smul (g (L n)))
  have Lclosed : ‚àÄ n, IsClosed (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ simp only [one_mul, Nat.cast_one, iterate_zero, id.def, Nat.zero_eq, Nat.zero_add]
    ¬∑ calc
        Œº (L (n + 1)) = Œº (L n) + Œº (g (L n) ‚Ä¢ K) := by
          simp_rw [iterate_succ']
          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet
        _ = (n + 1 + 1 : ‚Ñï) * Œº K := by
          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]
  have N : Tendsto (fun n => Œº (L n)) atTop (ùìù (‚àû * Œº K)) := by
    simp_rw [M]
    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)
    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)
  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N
  apply top_le_iff.1
  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)","warning:  `exists_isCompact_isClosed_nhds_one` has been deprecated, use `exists_mem_nhds_isCompact_isClosed` instead
error:  simp made no progress
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.183761 ‚Üí ?m.183761
error:  unsolved goals
case zero
ùïú : Type u_1
G : Type u_2
H : Type u_3
inst‚úù¬π‚Å∞ : MeasurableSpace G
inst‚úù‚Åπ : MeasurableSpace H
inst‚úù‚Å∏ : TopologicalSpace G
inst‚úù‚Å∑ : BorelSpace G
Œº‚úù : Measure G
inst‚úù‚Å∂ : Group G
inst‚úù‚Åµ : TopologicalGroup G
inst‚úù‚Å¥ : Œº‚úù.IsMulLeftInvariant
inst‚úù¬≥ : WeaklyLocallyCompactSpace G
inst‚úù¬≤ : NoncompactSpace G
Œº : Measure G
inst‚úù¬π : Œº.IsOpenPosMeasure
inst‚úù : Œº.IsMulLeftInvariant
K : Set G
hK : IsCompact K
Kclosed : IsClosed K
K1 : K ‚àà ùìù 1
K_pos : 0 < Œº K
g : Set G ‚Üí G
hg : ‚àÄ (L : Set G), IsCompact L ‚Üí Disjoint L (g L ‚Ä¢ K)
L : ‚Ñï ‚Üí Set G := fun n ‚Ü¶ (fun T ‚Ü¶ T ‚à™ g T ‚Ä¢ K)^[n] K
Lcompact : ‚àÄ (n : ‚Ñï), IsCompact (L n)
Lclosed : ‚àÄ (n : ‚Ñï), IsClosed (L n)
‚ä¢ Œº (L 0) = Œº K
error:  simp made no progress","theorem measure_univ_of_isMulLeftInvariant [WeaklyLocallyCompactSpace G] [NoncompactSpace G]
    (Œº : Measure G) [IsOpenPosMeasure Œº] [Œº.IsMulLeftInvariant] : Œº univ = ‚àû ",":= by
  obtain ‚ü®K, K1, hK, Kclosed‚ü© : ‚àÉ K ‚àà ùìù (1 : G), IsCompact K ‚àß IsClosed K :=
    exists_mem_nhds_isCompact_isClosed 1
  have K_pos : 0 < Œº K := measure_pos_of_mem_nhds Œº K1
  have A : ‚àÄ L : Set G, IsCompact L ‚Üí ‚àÉ g : G, Disjoint L (g ‚Ä¢ K) := fun L hL =>
    exists_disjoint_smul_of_isCompact hL hK
  choose! g hg using A
  set L : ‚Ñï ‚Üí Set G := fun n => (fun T => T ‚à™ g T ‚Ä¢ K)^[n] K
  have Lcompact : ‚àÄ n, IsCompact (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact hK
    ¬∑ simp_rw [L, iterate_succ']
      apply IsCompact.union IH (hK.smul (g (L n)))
  have Lclosed : ‚àÄ n, IsClosed (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [L, iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ simp only [L, one_mul, Nat.cast_one, iterate_zero, id, Nat.zero_eq, Nat.zero_add]
    ¬∑ calc
        Œº (L (n + 1)) = Œº (L n) + Œº (g (L n) ‚Ä¢ K) := by
          simp_rw [L, iterate_succ']
          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet
        _ = (n + 1 + 1 : ‚Ñï) * Œº K := by
          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]
  have N : Tendsto (fun n => Œº (L n)) atTop (ùìù (‚àû * Œº K)) := by
    simp_rw [M]
    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)
    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)
  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N
  apply top_le_iff.1
  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)",":= by
  obtain ‚ü®K, hK, Kclosed, K1‚ü© : ‚àÉ K : Set G, IsCompact K ‚àß IsClosed K ‚àß K ‚àà ùìù 1 :=
    exists_isCompact_isClosed_nhds_one G
  have K_pos : 0 < Œº K := measure_pos_of_nonempty_interior _ ‚ü®_, mem_interior_iff_mem_nhds.2 K1‚ü©
  have A : ‚àÄ L : Set G, IsCompact L ‚Üí ‚àÉ g : G, Disjoint L (g ‚Ä¢ K) := fun L hL =>
    exists_disjoint_smul_of_isCompact hL hK
  choose! g hg using A
  set L : ‚Ñï ‚Üí Set G := fun n => (fun T => T ‚à™ g T ‚Ä¢ K)^[n] K
  have Lcompact : ‚àÄ n, IsCompact (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact hK
    ¬∑ simp_rw [iterate_succ']
      apply IsCompact.union IH (hK.smul (g (L n)))
  have Lclosed : ‚àÄ n, IsClosed (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ simp only [one_mul, Nat.cast_one, iterate_zero, id, Nat.zero_eq, Nat.zero_add]
    ¬∑ calc
        Œº (L (n + 1)) = Œº (L n) + Œº (g (L n) ‚Ä¢ K) := by
          simp_rw [iterate_succ']
          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet
        _ = (n + 1 + 1 : ‚Ñï) * Œº K := by
          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]
  have N : Tendsto (fun n => Œº (L n)) atTop (ùìù (‚àû * Œº K)) := by
    simp_rw [M]
    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)
    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)
  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N
  apply top_le_iff.1
  exact le_of_tendsto' N fun n => measure_mono subset_univ"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,b0906f1a9f950f5731cad2defb88e9843a7e3fc9,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/Algebra/Category/ModuleCat/Free.lean,ModuleCat.linearIndependent_leftExact,linearIndependent_leftExact,cb4aef88b270b6c6e6daba92888fc7a77476eaed,":=
  linearIndependent_sum.mpr
  ‚ü®(congr_arg (fun f ‚Ü¶ LinearIndependent R f) huv).mpr
    ((LinearMap.linearIndependent_iff (f : N ‚Üí‚Çó[R] M)
    (LinearMap.ker_eq_bot.mpr ((mono_iff_injective _).mp hm))).mpr hv),","error:  unexpected token 'theorem'; expected '‚ü©'
error:  function expected at
  linearIndependent_leftExact
term has type
  LinearIndependent ?m.19010 ?m.19013
error:  application type mismatch
  linearIndependent_shortExact hS'
argument
  hS'
has type
  S.ShortExact : Prop
but is expected to have type
  LinearIndependent ?m.56126 ?m.56130 : Prop",theorem linearIndependent_leftExact : LinearIndependent R u ,":= by
  rw [linearIndependent_sum]
  refine ‚ü®?_, LinearIndependent.of_comp S.g hw, disjoint_span_sum hS hw huv‚ü©
  rw [huv, LinearMap.linearIndependent_iff S.f]; swap
  ¬∑ rw [LinearMap.ker_eq_bot, ‚Üê mono_iff_injective]
    infer_instance
  exact hv",":=
  linearIndependent_sum.mpr
  ‚ü®(congr_arg (fun f ‚Ü¶ LinearIndependent R f) huv).mpr
    ((LinearMap.linearIndependent_iff (f : N ‚Üí‚Çó[R] M)
    (LinearMap.ker_eq_bot.mpr ((mono_iff_injective _).mp hm))).mpr hv),"
Mathlib/MeasureTheory/Measure/VectorMeasure.lean,MeasureTheory.VectorMeasure.MutuallySingular.add_left,add_left,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  obtain ‚ü®u, hmu, hu‚ÇÅ, hu‚ÇÇ‚ü© := h‚ÇÅ
  obtain ‚ü®v, hmv, hv‚ÇÅ, hv‚ÇÇ‚ü© := h‚ÇÇ
  refine' mk (u ‚à© v) (hmu.inter hmv) (fun t ht _ => _) fun t ht hmt => _
  ¬∑ rw [add_apply, hu‚ÇÅ _ (Set.subset_inter_iff.1 ht).1, hv‚ÇÅ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  ¬∑ rw [Set.compl_inter] at ht
    rw [(_ : t = u·∂ú ‚à© t ‚à™ v·∂ú \ u·∂ú ‚à© t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), hu‚ÇÇ, hv‚ÇÇ, add_zero]
    ¬∑ exact Set.Subset.trans (Set.inter_subset_left _ _) (Set.diff_subset _ _)
    ¬∑ exact Set.inter_subset_left _ _
    ¬∑ exact disjoint_sdiff_self_right.mono (Set.inter_subset_left _ _) (Set.inter_subset_left _ _)
    ¬∑ apply Set.Subset.antisymm <;> intro x hx
      ¬∑ by_cases hxu' : x ‚àà u·∂ú
        ¬∑ exact Or.inl ‚ü®hxu', hx‚ü©
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr ‚ü®‚ü®hxv, hxu'‚ü©, hx‚ü©]
      ¬∑ cases' hx with hx hx <;> exact hx.2","warning:  @VectorMeasure.AbsolutelyContinuous does not have a doc string
warning:  @VectorMeasure.MutuallySingular does not have a doc string
error:  function expected at
  inter_subset_left ?m.336041
term has type
  ?m.336040 ‚àà ?m.336038
error:  function expected at
  diff_subset ?m.336083
term has type
  ?m.336082 ‚àà ?m.336080
error:  function expected at
  inter_subset_left ?m.336125
term has type
  ?m.336124 ‚àà ?m.336122
error:  function expected at
  inter_subset_left ?m.336366
term has type
  ?m.336365 ‚àà ?m.336363
error:  function expected at
  inter_subset_left ?m.336418
term has type
  ?m.336417 ‚àà ?m.336415",theorem add_left [T2Space N] [ContinuousAdd M] (h‚ÇÅ : v‚ÇÅ ‚üÇ·µ• w) (h‚ÇÇ : v‚ÇÇ ‚üÇ·µ• w) : v‚ÇÅ + v‚ÇÇ ‚üÇ·µ• w ,":= by
  obtain ‚ü®u, hmu, hu‚ÇÅ, hu‚ÇÇ‚ü© := h‚ÇÅ
  obtain ‚ü®v, hmv, hv‚ÇÅ, hv‚ÇÇ‚ü© := h‚ÇÇ
  refine mk (u ‚à© v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_
  ¬∑ rw [add_apply, hu‚ÇÅ _ (Set.subset_inter_iff.1 ht).1, hv‚ÇÅ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  ¬∑ rw [Set.compl_inter] at ht
    rw [(_ : t = u·∂ú ‚à© t ‚à™ v·∂ú \ u·∂ú ‚à© t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), hu‚ÇÇ, hv‚ÇÇ, add_zero]
    ¬∑ exact Set.Subset.trans Set.inter_subset_left diff_subset
    ¬∑ exact Set.inter_subset_left
    ¬∑ exact disjoint_sdiff_self_right.mono Set.inter_subset_left Set.inter_subset_left
    ¬∑ apply Set.Subset.antisymm <;> intro x hx
      ¬∑ by_cases hxu' : x ‚àà u·∂ú
        ¬∑ exact Or.inl ‚ü®hxu', hx‚ü©
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr ‚ü®‚ü®hxv, hxu'‚ü©, hx‚ü©]
      ¬∑ cases' hx with hx hx <;> exact hx.2",":= by
  obtain ‚ü®u, hmu, hu‚ÇÅ, hu‚ÇÇ‚ü© := h‚ÇÅ
  obtain ‚ü®v, hmv, hv‚ÇÅ, hv‚ÇÇ‚ü© := h‚ÇÇ
  refine mk (u ‚à© v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_
  ¬∑ rw [add_apply, hu‚ÇÅ _ (Set.subset_inter_iff.1 ht).1, hv‚ÇÅ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  ¬∑ rw [Set.compl_inter] at ht
    rw [(_ : t = u·∂ú ‚à© t ‚à™ v·∂ú \ u·∂ú ‚à© t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), hu‚ÇÇ, hv‚ÇÇ, add_zero]
    ¬∑ exact Set.Subset.trans Set.inter_subset_left Set.diff_subset
    ¬∑ exact Set.inter_subset_left
    ¬∑ exact disjoint_sdiff_self_right.mono Set.inter_subset_left Set.inter_subset_left
    ¬∑ apply Set.Subset.antisymm <;> intro x hx
      ¬∑ by_cases hxu' : x ‚àà u·∂ú
        ¬∑ exact Or.inl ‚ü®hxu', hx‚ü©
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr ‚ü®‚ü®hxv, hxu'‚ü©, hx‚ü©]
      ¬∑ cases' hx with hx hx <;> exact hx.2"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.Triangle.isZero‚ÇÅ_iff,isZero‚ÇÅ_iff,8535b08ef59bcdb8a9d09a473f4b6c583f54aef0,":= by
  refine' (isZero‚ÇÇ_iff _ (inv_rot_of_dist_triangle _ hT)).trans _
  dsimp
  simp [neg_eq_zero, IsIso.comp_right_eq_zero, Functor.map_eq_zero_iff]
  tauto","error:  unknown identifier 'inv_rot_of_dist_triangle'
error:  function expected at
  isZero‚ÇÅ_iff T
term has type
  IsZero T.obj‚ÇÅ ‚Üî T.mor‚ÇÅ = 0 ‚àß T.mor‚ÇÉ = 0
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.113342
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (CategoryTheory.shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T ‚àà distinguishedTriangles
h‚ÇÇ : IsZero T.obj‚ÇÇ
h‚ÇÉ : IsZero T.obj‚ÇÉ
‚ä¢ IsZero T.obj‚ÇÅ
error:  function expected at
  isZero‚ÇÅ_iff T
term has type
  IsZero T.obj‚ÇÅ ‚Üî T.mor‚ÇÅ = 0 ‚àß T.mor‚ÇÉ = 0
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.118619
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (CategoryTheory.shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T ‚àà distinguishedTriangles
‚ä¢ IsZero T.obj‚ÇÅ ‚Üî IsIso T.mor‚ÇÇ
error:  function expected at
  isZero‚ÇÅ_iff_isIso‚ÇÇ ?m.119336
term has type
  IsZero ?m.119336.obj‚ÇÅ ‚Üî IsIso ?m.119336.mor‚ÇÇ
error:  function expected at
  isZero‚ÇÅ_iff_isIso‚ÇÇ ?m.120243
term has type
  IsZero ?m.120243.obj‚ÇÅ ‚Üî IsIso ?m.120243.mor‚ÇÇ
error:  unsolved goals
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (CategoryTheory.shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T ‚àà distinguishedTriangles
‚ä¢ IsZero T.obj‚ÇÉ ‚Üî IsIso T.mor‚ÇÅ
error:  function expected at
  isZero‚ÇÅ_iff_isIso‚ÇÇ T
term has type
  IsZero T.obj‚ÇÅ ‚Üî IsIso T.mor‚ÇÇ
error:  function expected at
  isZero‚ÇÇ_iff_isIso‚ÇÉ T
term has type
  IsZero T.obj‚ÇÇ ‚Üî IsIso T.mor‚ÇÉ
error:  function expected at
  isZero‚ÇÉ_iff_isIso‚ÇÅ T
term has type
  IsZero T.obj‚ÇÉ ‚Üî IsIso T.mor‚ÇÅ",lemma isZero‚ÇÅ_iff : IsZero T.obj‚ÇÅ ‚Üî (T.mor‚ÇÅ = 0 ‚àß T.mor‚ÇÉ = 0) ,":= by
  refine (isZero‚ÇÇ_iff _ (inv_rot_of_distTriang _ hT)).trans ?_
  dsimp
  simp only [neg_eq_zero, IsIso.comp_right_eq_zero, Functor.map_eq_zero_iff]
  tauto",":= by
  refine (isZero‚ÇÇ_iff _ (inv_rot_of_distTriang _ hT)).trans ?_
  dsimp
  simp [neg_eq_zero, IsIso.comp_right_eq_zero, Functor.map_eq_zero_iff]"
Mathlib/SetTheory/Game/Nim.lean,SetTheory.PGame.grundyValue_nim_add_nim,grundyValue_nim_add_nim,ad88a031b67d9f51d39379f0e5f82a31c1929202,":= by
  induction' n using Nat.strong_induction_on with n hn generalizing m
  induction' m using Nat.strong_induction_on with m hm
  rw [grundyValue_eq_mex_left]
  refine (Ordinal.mex_le_of_ne.{u, u} fun i => ?_).antisymm
    (Ordinal.le_mex_of_forall fun ou hu => ?_)
  ¬∑ apply leftMoves_add_cases i <;>
      ¬∑ 
        refine' fun a => leftMovesNimRecOn a fun ok hk => _
        obtain ‚ü®k, rfl‚ü© := Ordinal.lt_omega.1 (hk.trans (Ordinal.nat_lt_omega _))
        simp only [add_moveLeft_inl, add_moveLeft_inr, moveLeft_nim', Equiv.symm_apply_apply]
        rw [nat_cast_lt] at hk
        first
        | rw [hn _ hk]
        | rw [hm _ hk]
        refine' fun h => hk.ne _
        rw [Ordinal.nat_cast_inj] at h
        first
        | rwa [Nat.xor_left_inj] at h
        | rwa [Nat.xor_right_inj] at h
  ¬∑ 
    obtain ‚ü®u, rfl‚ü© := Ordinal.lt_omega.1 (hu.trans (Ordinal.nat_lt_omega _))
    replace hu := Ordinal.nat_cast_lt.1 hu
    cases' Nat.lt_xor_cases hu with h h
    ¬∑ refine' ‚ü®toLeftMovesAdd (Sum.inl <| toLeftMovesNim ‚ü®_, Ordinal.nat_cast_lt.2 h‚ü©), _‚ü©
      simp [Nat.lxor_cancel_right, hn _ h]
    ¬∑ refine' ‚ü®toLeftMovesAdd (Sum.inr <| toLeftMovesNim ‚ü®_, Ordinal.nat_cast_lt.2 h‚ü©), _‚ü©
      have : n ^^^ (u ^^^ n) = u; rw [Nat.xor_comm u, Nat.xor_cancel_left]
      simpa [hm _ h] using this","error:  unexpected token ';'; expected '|'
error:  unsolved goals
case h.h.refine_2.intro.inl
n : ‚Ñï
hn : ‚àÄ m < n, ‚àÄ (m_1 : ‚Ñï), (nim ‚Üëm + nim ‚Üëm_1).grundyValue = ‚Üë(m ^^^ m_1)
m : ‚Ñï
hm : ‚àÄ m_1 < m, (nim ‚Üën + nim ‚Üëm_1).grundyValue = ‚Üë(n ^^^ m_1)
u : ‚Ñï
hu : u < n ^^^ m
h : u ^^^ m < n
‚ä¢ u ^^^ m ^^^ m = u
error:  unsolved goals
case h.h.refine_2.intro.inr
n : ‚Ñï
hn : ‚àÄ m < n, ‚àÄ (m_1 : ‚Ñï), (nim ‚Üëm + nim ‚Üëm_1).grundyValue = ‚Üë(m ^^^ m_1)
m : ‚Ñï
hm : ‚àÄ m_1 < m, (nim ‚Üën + nim ‚Üëm_1).grundyValue = ‚Üë(n ^^^ m_1)
u : ‚Ñï
hu : u < n ^^^ m
h : u ^^^ n < m
this : n ^^^ (u ^^^ n) = u
‚ä¢ ((nim ‚Üën + nim ‚Üëm).moveLeft (toLeftMovesAdd (Sum.inr (toLeftMovesNim ‚ü®‚Üë(u ^^^ n), ‚ãØ‚ü©)))).grundyValue = ‚Üëu","theorem grundyValue_nim_add_nim (n m : ‚Ñï) :
    grundyValue (nim.{u} n + nim.{u} m) = n ^^^ m ",":= by
  induction' n using Nat.strong_induction_on with n hn generalizing m
  induction' m using Nat.strong_induction_on with m hm
  rw [grundyValue_eq_mex_left]
  refine (Ordinal.mex_le_of_ne.{u, u} fun i => ?_).antisymm
    (Ordinal.le_mex_of_forall fun ou hu => ?_)
  ¬∑ apply leftMoves_add_cases i <;>
      ¬∑ 
        refine fun a => leftMovesNimRecOn a fun ok hk => ?_
        obtain ‚ü®k, rfl‚ü© := Ordinal.lt_omega.1 (hk.trans (Ordinal.nat_lt_omega _))
        simp only [add_moveLeft_inl, add_moveLeft_inr, moveLeft_nim', Equiv.symm_apply_apply]
        rw [natCast_lt] at hk
        first
        | rw [hn _ hk]
        | rw [hm _ hk]
        refine fun h => hk.ne ?_
        rw [Ordinal.natCast_inj] at h
        first
        | rwa [Nat.xor_left_inj] at h
        | rwa [Nat.xor_right_inj] at h
  ¬∑ 
    obtain ‚ü®u, rfl‚ü© := Ordinal.lt_omega.1 (hu.trans (Ordinal.nat_lt_omega _))
    replace hu := Ordinal.natCast_lt.1 hu
    cases' Nat.lt_xor_cases hu with h h
    ¬∑ refine ‚ü®toLeftMovesAdd (Sum.inl <| toLeftMovesNim ‚ü®_, Ordinal.natCast_lt.2 h‚ü©), ?_‚ü©
      simp [Nat.xor_cancel_right, hn _ h]
    ¬∑ refine ‚ü®toLeftMovesAdd (Sum.inr <| toLeftMovesNim ‚ü®_, Ordinal.natCast_lt.2 h‚ü©), ?_‚ü©
      have : n ^^^ (u ^^^ n) = u := by rw [Nat.xor_comm u, Nat.xor_cancel_left]
      simpa [hm _ h] using this",":= by
  induction' n using Nat.strong_induction_on with n hn generalizing m
  induction' m using Nat.strong_induction_on with m hm
  rw [grundyValue_eq_mex_left]
  refine (Ordinal.mex_le_of_ne.{u, u} fun i => ?_).antisymm
    (Ordinal.le_mex_of_forall fun ou hu => ?_)
  ¬∑ apply leftMoves_add_cases i <;>
      ¬∑ 
        refine fun a => leftMovesNimRecOn a fun ok hk => ?_
        obtain ‚ü®k, rfl‚ü© := Ordinal.lt_omega.1 (hk.trans (Ordinal.nat_lt_omega _))
        simp only [add_moveLeft_inl, add_moveLeft_inr, moveLeft_nim', Equiv.symm_apply_apply]
        rw [nat_cast_lt] at hk
        first
        | rwa [Nat.xor_left_inj] at h
        | rwa [Nat.xor_right_inj] at h
  ¬∑ 
    obtain ‚ü®u, rfl‚ü© := Ordinal.lt_omega.1 (hu.trans (Ordinal.nat_lt_omega _))
    replace hu := Ordinal.nat_cast_lt.1 hu
    cases' Nat.lt_xor_cases hu with h h
    ¬∑ refine ‚ü®toLeftMovesAdd (Sum.inl <| toLeftMovesNim ‚ü®_, Ordinal.nat_cast_lt.2 h‚ü©), ?_‚ü©
      have : n ^^^ (u ^^^ n) = u; rw [Nat.xor_comm u, Nat.xor_cancel_left]
      simpa [hm _ h] using this"
Mathlib/Topology/Category/Profinite/Nobeling.lean,Profinite.Nobeling.embedding,Nobeling.embedding,ee1b50f22a15c325154089232309c36ed1721967,":= by
  apply Continuous.closedEmbedding
  ¬∑ dsimp (config := { unfoldPartialApp := true }) [Œπ]
    refine continuous_pi ?_
    intro C
    rw [‚Üê IsLocallyConstant.iff_continuous]
    refine ((IsLocallyConstant.tfae _).out 0 3).mpr ?_
    rintro ‚ü®‚ü©
    ¬∑ refine IsClopen.isOpen (isClopen_compl_iff.mp ?_)
      convert C.2
      ext x
      simp only [Set.mem_compl_iff, Set.mem_preimage, Set.mem_singleton_iff,
        decide_eq_false_iff_not, not_not]
    ¬∑ refine IsClopen.isOpen ?_
      convert C.2
      ext x
      simp only [Set.mem_preimage, Set.mem_singleton_iff, decide_eq_true_eq]
  ¬∑ intro a b h
    by_contra hn
    obtain ‚ü®C, hC, hh‚ü© := exists_clopen_of_totally_separated hn
    apply hh.2 ‚àò of_decide_eq_true
    dsimp (config := { unfoldPartialApp := true }) [Œπ] at h
    rw [‚Üê congr_fun h ‚ü®C, hC‚ü©]
    exact decide_eq_true hh.1","error:  unknown identifier 'exists_clopen_of_totally_separated'
error:  rcases tactic failed: x‚úù : ?m.585878 is not an inductive datatype",theorem Nobeling.embedding : ClosedEmbedding (Nobeling.Œπ S) ,":= by
  apply Continuous.closedEmbedding
  ¬∑ dsimp (config := { unfoldPartialApp := true }) [Œπ]
    refine continuous_pi ?_
    intro C
    rw [‚Üê IsLocallyConstant.iff_continuous]
    refine ((IsLocallyConstant.tfae _).out 0 3).mpr ?_
    rintro ‚ü®‚ü©
    ¬∑ refine IsClopen.isOpen (isClopen_compl_iff.mp ?_)
      convert C.2
      ext x
      simp only [Set.mem_compl_iff, Set.mem_preimage, Set.mem_singleton_iff,
        decide_eq_false_iff_not, not_not]
    ¬∑ refine IsClopen.isOpen ?_
      convert C.2
      ext x
      simp only [Set.mem_preimage, Set.mem_singleton_iff, decide_eq_true_eq]
  ¬∑ intro a b h
    by_contra hn
    obtain ‚ü®C, hC, hh‚ü© := exists_isClopen_of_totally_separated hn
    apply hh.2 ‚àò of_decide_eq_true
    dsimp (config := { unfoldPartialApp := true }) [Œπ] at h
    rw [‚Üê congr_fun h ‚ü®C, hC‚ü©]
    exact decide_eq_true hh.1",":= by
  apply Continuous.closedEmbedding
  ¬∑ dsimp (config := { unfoldPartialApp := true }) [Œπ]
    refine continuous_pi ?_
    intro C
    rw [‚Üê IsLocallyConstant.iff_continuous]
    refine ((IsLocallyConstant.tfae _).out 0 3).mpr ?_
    rintro ‚ü®‚ü©
    ¬∑ refine IsClopen.isOpen (isClopen_compl_iff.mp ?_)
      convert C.2
      ext x
      simp only [Set.mem_compl_iff, Set.mem_preimage, Set.mem_singleton_iff, decide_eq_true_eq]
  ¬∑ intro a b h
    by_contra hn
    obtain ‚ü®C, hC, hh‚ü© := exists_clopen_of_totally_separated hn
    apply hh.2 ‚àò of_decide_eq_true
    dsimp (config := { unfoldPartialApp := true }) [Œπ] at h
    rw [‚Üê congr_fun h ‚ü®C, hC‚ü©]
    exact decide_eq_true hh.1"
Mathlib/Data/Set/Countable.lean,Set.countable_setOf_finite_subset,countable_setOf_finite_subset,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have := hs.to_subtype
  refine (countable_range fun t : Finset s => Subtype.val '' (t : Set s)).mono ?_
  rintro t ‚ü®ht, hts‚ü©
  lift t to Set s using hts
  lift t to Finset s using ht.of_finite_image (Subtype.val_injective.injOn _)
  exact mem_range_self _","error:  application type mismatch
  Finite.of_finite_image ht (Injective.injOn Subtype.val_injective ?m.10744)
argument
  Injective.injOn Subtype.val_injective ?m.10744
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Subtype ?m.10721‚¶Ñ, x‚ÇÇ ‚àà ?m.10742 ‚Üí ‚Üë?m.10743 = ‚Üëx‚ÇÇ ‚Üí ?m.10743 = x‚ÇÇ : Prop
but is expected to have type
  InjOn Subtype.val t : Prop","theorem countable_setOf_finite_subset {s : Set Œ±} (hs : s.Countable) :
    { t | Set.Finite t ‚àß t ‚äÜ s }.Countable ",":= by
  have := hs.to_subtype
  refine (countable_range fun t : Finset s => Subtype.val '' (t : Set s)).mono ?_
  rintro t ‚ü®ht, hts‚ü©
  lift t to Set s using hts
  lift t to Finset s using ht.of_finite_image Subtype.val_injective.injOn
  exact mem_range_self _",":= by
  have := hs.to_subtype
  refine (countable_range fun t : Finset s => Subtype.val '' (t : Set s)).mono ?_
  rintro t ‚ü®ht, hts‚ü©
  lift t to Set s using hts
  lift t to Finset s using ht.of_finite_image Subtype.val_injective.injOn
  exact mem_range_self _"
Mathlib/Algebra/Homology/TotalComplex.lean,HomologicalComplex‚ÇÇ.ŒπTotal_map,ŒπTotal_map,10f63baf7e1660a2ffa3e891eef40812f434a38f,":= by
  simp [total.map]","error:  unsolved goals
C : Type u_1
inst‚úù‚Åµ : Category.{u_5, u_1} C
inst‚úù‚Å¥ : Preadditive C
I‚ÇÅ : Type u_2
I‚ÇÇ : Type u_3
I‚ÇÅ‚ÇÇ : Type u_4
c‚ÇÅ : ComplexShape I‚ÇÅ
c‚ÇÇ : ComplexShape I‚ÇÇ
K L M : HomologicalComplex‚ÇÇ C c‚ÇÅ c‚ÇÇ
œÜ : K ‚ü∂ L
e : K ‚âÖ L
œà : L ‚ü∂ M
c‚ÇÅ‚ÇÇ : ComplexShape I‚ÇÅ‚ÇÇ
inst‚úù¬≥ : DecidableEq I‚ÇÅ‚ÇÇ
inst‚úù¬≤ : TotalComplexShape c‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ
inst‚úù¬π : K.HasTotal c‚ÇÅ‚ÇÇ
inst‚úù : L.HasTotal c‚ÇÅ‚ÇÇ
i‚ÇÅ : I‚ÇÅ
i‚ÇÇ : I‚ÇÇ
i‚ÇÅ‚ÇÇ : I‚ÇÅ‚ÇÇ
h : c‚ÇÅ.œÄ c‚ÇÇ c‚ÇÅ‚ÇÇ (i‚ÇÅ, i‚ÇÇ) = i‚ÇÅ‚ÇÇ
‚ä¢ K.ŒπTotal c‚ÇÅ‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÅ‚ÇÇ h ‚â´ GradedObject.mapMap (toGradedObjectMap œÜ) (c‚ÇÅ.œÄ c‚ÇÇ c‚ÇÅ‚ÇÇ) i‚ÇÅ‚ÇÇ =
    (œÜ.f i‚ÇÅ).f i‚ÇÇ ‚â´ L.ŒπTotal c‚ÇÅ‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÅ‚ÇÇ h","lemma ŒπTotal_map (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÅ‚ÇÇ : I‚ÇÅ‚ÇÇ) (h : ComplexShape.œÄ c‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ (i‚ÇÅ, i‚ÇÇ) = i‚ÇÅ‚ÇÇ) :
    K.ŒπTotal c‚ÇÅ‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÅ‚ÇÇ h ‚â´ (total.map œÜ c‚ÇÅ‚ÇÇ).f i‚ÇÅ‚ÇÇ =
      (œÜ.f i‚ÇÅ).f i‚ÇÇ ‚â´ L.ŒπTotal c‚ÇÅ‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÅ‚ÇÇ h ",":= by
  simp [total.map, ŒπTotal]",":= by
  rw [total.map]"
Mathlib/MeasureTheory/Group/GeometryOfNumbers.lean,MeasureTheory.exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure,exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure,26dcb0a78bda63252389cd8290cafcd2d953c437,":= by
  have h_vol : Œº F < Œº ((2‚Åª¬π : ‚Ñù) ‚Ä¢ s) := by
    rw [addHaar_smul_of_nonneg Œº (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π) s, ‚Üê
      mul_lt_mul_right (pow_ne_zero (finrank ‚Ñù E) (two_ne_zero' _)) (pow_ne_top two_ne_top),
      mul_right_comm, ofReal_pow (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π), ‚Üê ofReal_inv_of_pos zero_lt_two]
    norm_num
    rwa [‚Üê mul_pow, ENNReal.inv_mul_cancel two_ne_zero two_ne_top, one_pow, one_mul]
  obtain ‚ü®x, y, hxy, h‚ü© :=
    exists_pair_mem_lattice_not_disjoint_vadd fund ((h_conv.smul _).nullMeasurableSet _) h_vol
  obtain ‚ü®_, ‚ü®v, hv, rfl‚ü©, w, hw, hvw‚ü© := Set.not_disjoint_iff.mp h
  refine' ‚ü®x - y, sub_ne_zero.2 hxy, _‚ü©
  rw [Set.mem_inv_smul_set_iff‚ÇÄ (two_ne_zero' ‚Ñù)] at hv hw
  simp_rw [AddSubgroup.vadd_def, vadd_eq_add, add_comm _ w, ‚Üê sub_eq_sub_iff_add_eq_add, ‚Üê
    AddSubgroup.coe_sub] at hvw
  rw [‚Üê hvw, ‚Üê inv_smul_smul‚ÇÄ (two_ne_zero' ‚Ñù) (_ - _), smul_sub, sub_eq_add_neg, smul_add]
  refine' h_conv hw (h_symm _ hv) _ _ _ <;> norm_num","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (ENNReal.ofReal 2)‚Åª¬π
E : Type u_1
L‚úù : Type u_2
inst‚úù‚Å∂ : MeasurableSpace E
Œº : Measure E
F s : Set E
inst‚úù‚Åµ : NormedAddCommGroup E
inst‚úù‚Å¥ : NormedSpace ‚Ñù E
inst‚úù¬≥ : BorelSpace E
inst‚úù¬≤ : FiniteDimensional ‚Ñù E
inst‚úù¬π : Œº.IsAddHaarMeasure
L : AddSubgroup E
inst‚úù : Countable ‚Ü•L
fund : IsAddFundamentalDomain (‚Ü•L) F Œº
h_symm : ‚àÄ x ‚àà s, -x ‚àà s
h_conv : Convex ‚Ñù s
h : Œº F * 2 ^ finrank ‚Ñù E < Œº s
‚ä¢ Œº F * 2 ^ finrank ‚Ñù E < ENNReal.ofReal 2‚Åª¬π ^ finrank ‚Ñù E * 2 ^ finrank ‚Ñù E * Œº s","theorem exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure [NormedAddCommGroup E]
    [NormedSpace ‚Ñù E] [BorelSpace E] [FiniteDimensional ‚Ñù E] [IsAddHaarMeasure Œº]
    {L : AddSubgroup E} [Countable L] (fund : IsAddFundamentalDomain L F Œº)
    (h_symm : ‚àÄ x ‚àà s, -x ‚àà s) (h_conv : Convex ‚Ñù s) (h : Œº F * 2 ^ finrank ‚Ñù E < Œº s) :
    ‚àÉ x ‚â† 0, ((x : L) : E) ‚àà s ",":= by
  have h_vol : Œº F < Œº ((2‚Åª¬π : ‚Ñù) ‚Ä¢ s) := by
    rw [addHaar_smul_of_nonneg Œº (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π) s, ‚Üê
      mul_lt_mul_right (pow_ne_zero (finrank ‚Ñù E) (two_ne_zero' _)) (pow_ne_top two_ne_top),
      mul_right_comm, ofReal_pow (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π), ofReal_inv_of_pos zero_lt_two]
    norm_num
    rwa [‚Üê mul_pow, ENNReal.inv_mul_cancel two_ne_zero two_ne_top, one_pow, one_mul]
  obtain ‚ü®x, y, hxy, h‚ü© :=
    exists_pair_mem_lattice_not_disjoint_vadd fund ((h_conv.smul _).nullMeasurableSet _) h_vol
  obtain ‚ü®_, ‚ü®v, hv, rfl‚ü©, w, hw, hvw‚ü© := Set.not_disjoint_iff.mp h
  refine ‚ü®x - y, sub_ne_zero.2 hxy, ?_‚ü©
  rw [Set.mem_inv_smul_set_iff‚ÇÄ (two_ne_zero' ‚Ñù)] at hv hw
  simp_rw [AddSubgroup.vadd_def, vadd_eq_add, add_comm _ w, ‚Üê sub_eq_sub_iff_add_eq_add, ‚Üê
    AddSubgroup.coe_sub] at hvw
  rw [‚Üê hvw, ‚Üê inv_smul_smul‚ÇÄ (two_ne_zero' ‚Ñù) (_ - _), smul_sub, sub_eq_add_neg, smul_add]
  refine h_conv hw (h_symm _ hv) ?_ ?_ ?_ <;> norm_num",":= by
  have h_vol : Œº F < Œº ((2‚Åª¬π : ‚Ñù) ‚Ä¢ s) := by
    rw [addHaar_smul_of_nonneg Œº (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π) s, ‚Üê
      mul_lt_mul_right (pow_ne_zero (finrank ‚Ñù E) (two_ne_zero' _)) (pow_ne_top two_ne_top),
      mul_right_comm, ofReal_pow (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π), ‚Üê ofReal_inv_of_pos zero_lt_two]
    norm_num
    rwa [‚Üê mul_pow, ENNReal.inv_mul_cancel two_ne_zero two_ne_top, one_pow, one_mul]
  obtain ‚ü®x, y, hxy, h‚ü© :=
    exists_pair_mem_lattice_not_disjoint_vadd fund ((h_conv.smul _).nullMeasurableSet _) h_vol
  obtain ‚ü®_, ‚ü®v, hv, rfl‚ü©, w, hw, hvw‚ü© := Set.not_disjoint_iff.mp h
  refine ‚ü®x - y, sub_ne_zero.2 hxy, ?_‚ü©
  rw [Set.mem_inv_smul_set_iff‚ÇÄ (two_ne_zero' ‚Ñù)] at hv hw
  simp_rw [AddSubgroup.vadd_def, vadd_eq_add, add_comm _ w, ‚Üê sub_eq_sub_iff_add_eq_add, ‚Üê
    AddSubgroup.coe_sub] at hvw
  rw [‚Üê hvw, ‚Üê inv_smul_smul‚ÇÄ (two_ne_zero' ‚Ñù) (_ - _), smul_sub, sub_eq_add_neg, smul_add]
  refine h_conv hw (h_symm _ hv) _ _ ?_ <;> norm_num"
Mathlib/RingTheory/MvPolynomial/Homogeneous.lean,MvPolynomial.IsHomogeneous.eval‚ÇÇ,eval‚ÇÇ,b271affacf1fa368c4e879d75cd5aaf54b75b7ed,":= by
  apply IsHomogeneous.sum
  intro i hi
  rw [‚Üê zero_add (n * m)]
  apply IsHomogeneous.mul (hf _) _
  convert IsHomogeneous.prod _ _ (fun k ‚Ü¶ n * i k) _
  ¬∑ rw [Finsupp.mem_support_iff] at hi
    rw [‚Üê Finset.mul_sum, hœÜ hi]
  ¬∑ rintro k -
    apply (hg k).pow","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (weightedDegree 1) i
case h.e'_1
œÉ : Type u_1
œÑ : Type u_2
R : Type u_3
S : Type u_4
inst‚úù¬≤ inst‚úù¬π : CommSemiring R
inst‚úù : CommSemiring S
œÜ œà : MvPolynomial œÉ R
m n : ‚Ñï
hœÜ : œÜ.IsHomogeneous m
f : R ‚Üí+* MvPolynomial œÑ S
g : œÉ ‚Üí MvPolynomial œÑ S
hf : ‚àÄ (r : R), (f r).IsHomogeneous 0
hg : ‚àÄ (i : œÉ), (g i).IsHomogeneous n
i : œÉ ‚Üí‚ÇÄ ‚Ñï
hi : œÜ i ‚â† 0
‚ä¢ n * m = n * ‚àë i_1 ‚àà i.support, i i_1","lemma eval‚ÇÇ (hœÜ : œÜ.IsHomogeneous m) (f : R ‚Üí+* MvPolynomial œÑ S) (g : œÉ ‚Üí MvPolynomial œÑ S)
    (hf : ‚àÄ r, (f r).IsHomogeneous 0) (hg : ‚àÄ i, (g i).IsHomogeneous n) :
    (eval‚ÇÇ f g œÜ).IsHomogeneous (n * m) ",":= by
  apply IsHomogeneous.sum
  intro i hi
  rw [‚Üê zero_add (n * m)]
  apply IsHomogeneous.mul (hf _) _
  convert IsHomogeneous.prod _ _ (fun k ‚Ü¶ n * i k) _
  ¬∑ rw [Finsupp.mem_support_iff] at hi
    rw [‚Üê Finset.mul_sum, ‚Üê hœÜ hi, weightedDegree_apply]
    simp_rw [smul_eq_mul, Finsupp.sum, Pi.one_apply, mul_one]
  ¬∑ rintro k -
    apply (hg k).pow",":= by
  apply IsHomogeneous.sum
  intro i hi
  rw [‚Üê zero_add (n * m)]
  apply IsHomogeneous.mul (hf _) _
  convert IsHomogeneous.prod _ _ (fun k ‚Ü¶ n * i k) _
  ¬∑ rw [Finsupp.mem_support_iff] at hi
    rw [‚Üê Finset.mul_sum, hœÜ hi]
  ¬∑ rintro k -
    apply (hg k).pow"
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      refine' ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      refine' ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine' ‚ü®U, {j}, _, _‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa
    ¬∑ simp
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine' ‚ü®j, V, _, _‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine' this _ _ _ (univ _) (inter _) _
      intro e he
      dsimp
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      rw [‚Üê coe_comp, D.w]
      rfl","error:  unknown identifier 'isTopologicalBasis_iInf'
error:  no goals to be solved","theorem isTopologicalBasis_cofiltered_limit (T : ‚àÄ j, Set (Set (F.obj j)))
    (hT : ‚àÄ j, IsTopologicalBasis (T j)) (univ : ‚àÄ i : J, Set.univ ‚àà T i)
    (inter : ‚àÄ (i) (U1 U2 : Set (F.obj i)), U1 ‚àà T i ‚Üí U2 ‚àà T i ‚Üí U1 ‚à© U2 ‚àà T i)
    (compat : ‚àÄ (i j : J) (f : i ‚ü∂ j) (V : Set (F.obj j)) (_hV : V ‚àà T j), F.map f ‚Åª¬π' V ‚àà T i) :
    IsTopologicalBasis
      {U : Set C.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = C.œÄ.app j ‚Åª¬π' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [‚Üê coe_comp, D.w] 
      rfl",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      refine ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      refine ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa
    ¬∑ simp
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
      dsimp
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_ortho"
Mathlib/Analysis/Calculus/LocalExtr/Polynomial.lean,Polynomial.card_roots_le_derivative,card_roots_le_derivative,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  calc
    Multiset.card p.roots = ‚àë x ‚àà p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.rootMultiplicity x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.rootMultiplicity x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x ‚àà p.derivative.roots.toFinset \ p.roots.toFinset,
            p.derivative.roots.count x) + 1) := by
      simp only [‚Üê count_roots]
      refine add_le_add_left (add_le_add_right ((Finset.card_eq_sum_ones _).trans_le ?_) _) _
      refine Finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| ?_
      rw [Multiset.count_pos, ‚Üê Multiset.mem_toFinset]
      exact (Finset.mem_sdiff.1 hx).1
    _ = Multiset.card (derivative p).roots + 1 := by
      rw [‚Üê add_assoc, ‚Üê Finset.sum_union Finset.disjoint_sdiff, Finset.union_sdiff_self_eq_union, ‚Üê
        Multiset.toFinset_sum_count_eq, ‚Üê Finset.sum_subset (Finset.subset_union_right _ _)]
      intro x _ hx‚ÇÇ
      simpa only [Multiset.mem_toFinset, Multiset.count_eq_zero] using hx‚ÇÇ","error:  function expected at
  Finset.subset_union_right ?m.14170
term has type
  ?m.14169 ‚àà ?m.14167 ‚à™ ?m.14168","theorem card_roots_le_derivative (p : ‚Ñù[X]) :
    Multiset.card p.roots ‚â§ Multiset.card (derivative p).roots + 1 ",":=
  calc
    Multiset.card p.roots = ‚àë x ‚àà p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.rootMultiplicity x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.rootMultiplicity x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x ‚àà p.derivative.roots.toFinset \ p.roots.toFinset,
            p.derivative.roots.count x) + 1) := by
      simp only [‚Üê count_roots]
      refine add_le_add_left (add_le_add_right ((Finset.card_eq_sum_ones _).trans_le ?_) _) _
      refine Finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| ?_
      rw [Multiset.count_pos, ‚Üê Multiset.mem_toFinset]
      exact (Finset.mem_sdiff.1 hx).1
    _ = Multiset.card (derivative p).roots + 1 := by
      rw [‚Üê add_assoc, ‚Üê Finset.sum_union Finset.disjoint_sdiff, Finset.union_sdiff_self_eq_union, ‚Üê
        Multiset.toFinset_sum_count_eq, ‚Üê Finset.sum_subset Finset.subset_union_right]
      intro x _ hx‚ÇÇ
      simpa only [Multiset.mem_toFinset, Multiset.count_eq_zero] using hx‚ÇÇ",":=
  calc
    Multiset.card p.roots = ‚àë x ‚àà p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x ‚àà p.derivative.roots.toFinset \ p.roots.toFinset,
             p.derivative.roots.count x) + 1) := by
        simp only [‚Üê count_roots]
      refine add_le_add_left (add_le_add_right ((Finset.card_eq_sum_ones _).trans_le ?_) ?_) ?_
      refine Finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| ?_
      rw [Multiset.count_pos, ‚Üê Multiset.mem_toFinset]
      exact (Finset.mem_sdiff.1 hx).1
    _ = Multiset.card (derivative p).roots + 1 := by
      rw [‚Üê add_assoc, ‚Üê Finset.sum_union Finset.disjoint_sdiff, Finset.union_sdiff_self_eq_union, ‚Üê
        Multiset.toFinset_sum_count_eq, ‚Üê Finset.sum_subset (Finset.subset_union_right]
      intro x _ hx‚ÇÇ
      simpa only [Multiset.mem_toFinset, Multiset.count_eq_zero] using hx‚ÇÇ"
Mathlib/CategoryTheory/Idempotents/Basic.lean,CategoryTheory.Idempotents.isIdempotentComplete_of_isIdempotentComplete_opposite,isIdempotentComplete_of_isIdempotentComplete_opposite,e909ecb0df49c3c96c769b4bf702a3d6084d240e,":= by
  refine' ‚ü®_‚ü©
  intro X p hp
  rcases IsIdempotentComplete.idempotents_split (op X) p.op (by rw [‚Üê op_comp, hp]) with
    ‚ü®Y, i, e, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©‚ü©
  use Y.unop, e.unop, i.unop
  constructor
  ¬∑ simp only [‚Üê unop_comp, h‚ÇÅ]
    rfl
  ¬∑ simp only [‚Üê unop_comp, h‚ÇÇ]","error:  unsolved goals
case h.right
C : Type u_1
inst‚úù : Category.{u_2, u_1} C
h : IsIdempotentComplete C·µí·µñ
X : C
p : X ‚ü∂ X
hp : p ‚â´ p = p
Y : C·µí·µñ
i : Y ‚ü∂ { unop := X }
e : { unop := X } ‚ü∂ Y
h‚ÇÅ : i ‚â´ e = ùüô Y
h‚ÇÇ : e ‚â´ i = p.op
‚ä¢ p.op.unop = p","theorem isIdempotentComplete_of_isIdempotentComplete_opposite (h : IsIdempotentComplete C·µí·µñ) :
    IsIdempotentComplete C ",":= by
  refine ‚ü®?_‚ü©
  intro X p hp
  rcases IsIdempotentComplete.idempotents_split (op X) p.op (by rw [‚Üê op_comp, hp]) with
    ‚ü®Y, i, e, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©‚ü©
  use Y.unop, e.unop, i.unop
  constructor
  ¬∑ simp only [‚Üê unop_comp, h‚ÇÅ]
    rfl
  ¬∑ simp only [‚Üê unop_comp, h‚ÇÇ]
    rfl",":= by
  refine ‚ü®?_‚ü©
  intro X p hp
  rcases IsIdempotentComplete.idempotents_split (op X) p.op (by rw [‚Üê op_comp, hp]) with
    ‚ü®Y, i, e, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©‚ü©
  use Y.unop, e.unop, i.unop
  constructor
  ¬∑ simp only [‚Üê unop_comp, h‚ÇÅ]
    rfl
  ¬∑ simp only [‚Üê unop_comp, h‚ÇÇ]"
Mathlib/SetTheory/Game/PGame.lean,SetTheory.PGame.lf_iff_exists_le,lf_iff_exists_le,69b7f4ab1136e43d2da107e18d8154c3019665d2,":= by
  rw [Lf, le_iff_forall_lf, not_and_or]
  simp","warning:  LF does not have a doc string
error:  unknown identifier 'Lf'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.12632
xl xr : Type u
x y : PGame
‚ä¢ x ‚ßè y ‚Üî (‚àÉ i, x ‚â§ y.moveLeft i) ‚à® ‚àÉ j, x.moveRight j ‚â§ y
warning:  Fuzzy does not have a doc string
warning:  Relabelling does not have a doc string","theorem lf_iff_exists_le {x y : PGame} :
    x ‚ßè y ‚Üî (‚àÉ i, x ‚â§ y.moveLeft i) ‚à® ‚àÉ j, x.moveRight j ‚â§ y ",":= by
  rw [LF, le_iff_forall_lf, not_and_or]
  simp",":= by
  rw [Lf, le_iff_forall_lf]
  simp"
Mathlib/GroupTheory/OrderOfElement.lean,IsOfFinOrder.apply,IsOfFinOrder.apply,ab56fa28da38a962b7952fc9e52edb14bef2bc5a,":= by
  rcases(isOfFinOrder_iff_pow_eq_one _).mp h with ‚ü®n, npos, hn‚ü©
  exact fun _ => (isOfFinOrder_iff_pow_eq_one _).mpr ‚ü®n, npos, (congr_fun hn.symm _).symm‚ü©","error:  function expected at
  isOfFinOrder_iff_pow_eq_one
term has type
  IsOfFinOrder ?m.14062 ‚Üî ‚àÉ n, 0 < n ‚àß ?m.14062 ^ n = 1
error:  rcases tactic failed: x‚úù : ?m.13903 is not an inductive datatype","theorem IsOfFinOrder.apply {Œ∑ : Type*} {Gs : Œ∑ ‚Üí Type*} [‚àÄ i, Monoid (Gs i)] {x : ‚àÄ i, Gs i}
    (h : IsOfFinOrder x) : ‚àÄ i, IsOfFinOrder (x i) ",":= by
  obtain ‚ü®n, npos, hn‚ü© := h.exists_pow_eq_one
  exact fun _ => isOfFinOrder_iff_pow_eq_one.mpr ‚ü®n, npos, (congr_fun hn.symm _).symm‚ü©",":= by
  rcases (isOfFinOrder_iff_pow_eq_one _).mp h with ‚ü®n, npos, hn‚ü©
  exact fun _ => (isOfFinOrder_iff_pow_eq_one _).mpr ‚ü®n, npos, (congr_fun hn.symm _).symm‚ü©"
Mathlib/FieldTheory/Galois.lean,IsGalois.card_aut_eq_finrank,card_aut_eq_finrank,3544438ac0a17c2c6d18d7eccc013535de664988,":= by
  cases' Field.exists_primitive_element F E with Œ± hŒ±
  let iso : F‚üÆŒ±‚üØ ‚âÉ‚Çê[F] E :=
    { toFun := fun e => e.val
      invFun := fun e => ‚ü®e, by rw [hŒ±]; exact IntermediateField.mem_top‚ü©
      left_inv := fun _ => by ext; rfl
      right_inv := fun _ => rfl
      map_mul' := fun _ _ => rfl
      map_add' := fun _ _ => rfl
      commutes' := fun _ => rfl }
  have H : IsIntegral F Œ± := IsGalois.integral F Œ±
  have h_sep : IsSeparable F Œ± := IsGalois.separable F Œ±
  have h_splits : (minpoly F Œ±).Splits (algebraMap F E) := IsGalois.splits F Œ±
  replace h_splits : Polynomial.Splits (algebraMap F F‚üÆŒ±‚üØ) (minpoly F Œ±) := by
    simpa using
      Polynomial.splits_comp_of_splits (algebraMap F E) iso.symm.toAlgHom.toRingHom h_splits
  rw [‚Üê LinearEquiv.finrank_eq iso.toLinearEquiv]
  rw [‚Üê IntermediateField.AdjoinSimple.card_aut_eq_finrank F E H h_sep h_splits]
  apply Fintype.card_congr
  apply Equiv.mk (fun œï => iso.trans (œï.trans iso.symm)) fun œï => iso.symm.trans (œï.trans iso)
  ¬∑ intro œï; ext1; simp only [trans_apply, apply_symm_apply]
  ¬∑ intro œï; ext1; simp only [trans_apply, symm_apply_apply]","error:  application type mismatch
  @IsSeparable F Œ±
argument
  Œ±
has type
  E : Type u_2
but is expected to have type
  Type ?u.19507 : Type (?u.19507 + 1)","theorem card_aut_eq_finrank [FiniteDimensional F E] [IsGalois F E] :
    Fintype.card (E ‚âÉ‚Çê[F] E) = finrank F E ",":= by
  cases' Field.exists_primitive_element F E with Œ± hŒ±
  let iso : F‚üÆŒ±‚üØ ‚âÉ‚Çê[F] E :=
    { toFun := fun e => e.val
      invFun := fun e => ‚ü®e, by rw [hŒ±]; exact IntermediateField.mem_top‚ü©
      left_inv := fun _ => by ext; rfl
      right_inv := fun _ => rfl
      map_mul' := fun _ _ => rfl
      map_add' := fun _ _ => rfl
      commutes' := fun _ => rfl }
  have H : IsIntegral F Œ± := IsGalois.integral F Œ±
  have h_sep : (minpoly F Œ±).Separable := IsGalois.separable F Œ±
  have h_splits : (minpoly F Œ±).Splits (algebraMap F E) := IsGalois.splits F Œ±
  replace h_splits : Polynomial.Splits (algebraMap F F‚üÆŒ±‚üØ) (minpoly F Œ±) := by
    simpa using
      Polynomial.splits_comp_of_splits (algebraMap F E) iso.symm.toAlgHom.toRingHom h_splits
  rw [‚Üê LinearEquiv.finrank_eq iso.toLinearEquiv]
  rw [‚Üê IntermediateField.AdjoinSimple.card_aut_eq_finrank F E H h_sep h_splits]
  apply Fintype.card_congr
  apply Equiv.mk (fun œï => iso.trans (œï.trans iso.symm)) fun œï => iso.symm.trans (œï.trans iso)
  ¬∑ intro œï; ext1; simp only [trans_apply, apply_symm_apply]
  ¬∑ intro œï; ext1; simp only [trans_apply, symm_apply_apply]",":= by
  cases' Field.exists_primitive_element F E with Œ± hŒ±
  let iso : F‚üÆŒ±‚üØ ‚âÉ‚Çê[F] E :=
    { toFun := fun e => e.val
      invFun := fun e => ‚ü®e, by rw [hŒ±]; exact IntermediateField.mem_top‚ü©
      left_inv := fun _ => by ext; rfl
      right_inv := fun _ => rfl
      map_mul' := fun _ _ => rfl
      map_add' := fun _ _ => rfl
      commutes' := fun _ => rfl }
  have H : IsIntegral F Œ± := IsGalois.integral F Œ±
  have h_sep : IsSeparable F Œ± := IsGalois.separable F Œ±
  have h_splits : (minpoly F Œ±).Splits (algebraMap F E) := IsGalois.splits F Œ±
  replace h_splits : Polynomial.Splits (algebraMap F F‚üÆŒ±‚üØ) (minpoly F Œ±) := by
    simpa using
      Polynomial.splits_comp_of_splits (algebraMap F E) iso.symm.toAlgHom.toRingHom h_splits
  rw [‚Üê LinearEquiv.finrank_eq iso.toLinearEquiv]
  rw [‚Üê IntermediateField.AdjoinSimple.card_aut_eq_finrank F E H h_sep h_splits]
  apply Fintype.card_congr
  apply Equiv.mk (fun œï => iso.trans (œï.trans iso.symm)) fun œï => iso.symm.trans (œï.trans iso)
  ¬∑ intro œï; ext1; simp only [trans_apply, apply_symm_apply]
  ¬∑ intro œï; ext1; simp only [trans_apply, symm_apply_apply]"
Mathlib/NumberTheory/Bertrand.lean,bertrand_main_inequality,bertrand_main_inequality,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_nat_cast]
  have n_pos : 0 < n := (by decide : 0 < 512).trans_le n_large
  have n2_pos : 1 ‚â§ 2 * n := mul_pos (by decide) n_pos
  refine' _root_.trans (mul_le_mul _ _ _ _)
      (Bertrand.real_main_inequality (by exact_mod_cast n_large))
  ¬∑ refine' mul_le_mul_of_nonneg_left _ (Nat.cast_nonneg _)
    refine' Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast n2_pos) _
    exact_mod_cast Real.nat_sqrt_le_real_sqrt
  ¬∑ exact Real.rpow_le_rpow_of_exponent_le (by norm_num1) (cast_div_le.trans (by norm_cast))
  ¬∑ exact Real.rpow_nonneg_of_nonneg (by norm_num1) _
  ¬∑ refine' mul_nonneg (Nat.cast_nonneg _) _
    exact Real.rpow_nonneg_of_nonneg (mul_nonneg zero_le_two (Nat.cast_nonneg _)) _","warning:  `Real.rpow_nat_cast` has been deprecated, use `Real.rpow_natCast` instead
error:  unknown constant 'Real.rpow_nonneg_of_nonneg'
error:  unknown constant 'Real.rpow_nonneg_of_nonneg'","theorem bertrand_main_inequality {n : ‚Ñï} (n_large : 512 ‚â§ n) :
    n * (2 * n) ^ sqrt (2 * n) * 4 ^ (2 * n / 3) ‚â§ 4 ^ n ",":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_natCast]
  refine _root_.trans ?_ (Bertrand.real_main_inequality (by exact_mod_cast n_large))
  gcongr
  ¬∑ have n2_pos : 0 < 2 * n := by positivity
    exact mod_cast n2_pos
  ¬∑ exact_mod_cast Real.nat_sqrt_le_real_sqrt
  ¬∑ norm_num1
  ¬∑ exact cast_div_le.trans (by norm_cast)",":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_natCast]
  have n_pos : 0 < n := (by decide : 0 < 512).trans_le n_large
  have n2_pos : 1 ‚â§ 2 * n := mul_pos (by decide) n_pos
  refine _root_.trans (mul_le_mul _ _ _ _)
      (Bertrand.real_main_inequality (by exact_mod_cast n_large))
  ¬∑ refine mul_le_mul_of_nonneg_left ?_ (Nat.cast_nonneg _)
    refine Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast n2_pos) ?_
    exact_mod_cast Real.natCast_sqrt_le_real_sqrt
  ¬∑ exact Real.rpow_le_rpow_of_exponent_le (by norm_num1) (cast_div_le.trans (by norm_cast))
  ¬∑ exact Real.rpow_nonneg_of_nonneg (by norm_num1) _
  ¬∑ refine mul_nonneg (Nat.cast_nonneg _) ?_
    exact Real.rpow_nonneg_of_nonneg (mul_nonneg zero_le_two (Nat.cast_nonneg _)) _"
Mathlib/Topology/OmegaCompletePartialOrder.lean,Scott.IsOpen.isUpperSet,IsOpen.isUpperSet,0c1dd9cbd45d804e559a743f61a0763f683221f0,:= hs.monotone,"error:  invalid field 'monotone', the environment does not contain 'Scott.IsOpen.monotone'
  hs
has type
  IsOpen Œ± s
error:  invalid field 'monotone', the environment does not contain 'OmegaCompletePartialOrder.Continuous'.monotone'
  hs
has type
  Continuous' fun x ‚Ü¶ x ‚àà s
error:  invalid field 'monotone', the environment does not contain 'Exists.monotone'
  hs
has type
  ‚àÉ (hf : Monotone fun x ‚Ü¶ x ‚àà s), OmegaCompletePartialOrder.Continuous { toFun := fun x ‚Ü¶ x ‚àà s, monotone' := hf }",theorem IsOpen.isUpperSet {s : Set Œ±} (hs : IsOpen Œ± s) : IsUpperSet s ,:= hs.fst,:= hs.monotone
Mathlib/Order/CompactlyGenerated/Basic.lean,CompleteLattice.independent_iff_supIndep_of_injOn,CompleteLattice.independent_iff_supIndep_of_injOn,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  refine ‚ü®fun h ‚Ü¶ h.supIndep', fun h ‚Ü¶ CompleteLattice.independent_def'.mpr fun i ‚Ü¶ ?_‚ü©
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, ‚Üê disjoint_iff]
  intro s hs
  classical
  rw [‚Üê Finset.sup_erase_bot]
  set t := s.erase ‚ä•
  replace hf : InjOn f (f ‚Åª¬π' t) := fun i hi j _ hij ‚Ü¶ by refine hf ?_ ?_ hij <;> aesop
  have : (Finset.erase (insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image]
    refine ‚ü®by aesop, fun ‚ü®ha, has‚ü© ‚Ü¶ ?_‚ü©
    obtain ‚ü®j, hj, rfl‚ü© := hs has
    exact ‚ü®j, ‚ü®hj, ha, has‚ü©, rfl‚ü©
  rw [‚Üê this, Finset.sup_image]
  specialize h (insert i (t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  Quot.lift (fun l ‚Ü¶ a ‚àà l) ‚ãØ t.val
error:  no goals to be solved","lemma CompleteLattice.independent_iff_supIndep_of_injOn {Œπ : Type*} {f : Œπ ‚Üí Œ±}
    (hf : InjOn f {i | f i ‚â† ‚ä•}) :
    CompleteLattice.Independent f ‚Üî ‚àÄ (s : Finset Œπ), s.SupIndep f ",":= by
  refine ‚ü®fun h ‚Ü¶ h.supIndep', fun h ‚Ü¶ CompleteLattice.independent_def'.mpr fun i ‚Ü¶ ?_‚ü©
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, ‚Üê disjoint_iff]
  intro s hs
  classical
  rw [‚Üê Finset.sup_erase_bot]
  set t := s.erase ‚ä•
  replace hf : InjOn f (f ‚Åª¬π' t) := fun i hi j _ hij ‚Ü¶ by
    refine hf ?_ ?_ hij <;> aesop (add norm simp [t])
  have : (Finset.erase (insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image, t]
    refine ‚ü®by aesop, fun ‚ü®ha, has‚ü© ‚Ü¶ ?_‚ü©
    obtain ‚ü®j, hj, rfl‚ü© := hs has
    exact ‚ü®j, ‚ü®hj, ha, has‚ü©, rfl‚ü©
  rw [‚Üê this, Finset.sup_image]
  specialize h (insert i (t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)",":= by
  refine ‚ü®fun h ‚Ü¶ h.supIndep', fun h ‚Ü¶ CompleteLattice.independent_def'.mpr fun i ‚Ü¶ ?_‚ü©
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, ‚Üê disjoint_iff]
  intro s hs
  classical
  rw [‚Üê Finset.sup_erase_bot]
  set t := s.erase ‚ä•
  replace hf : InjOn f (f ‚Åª¬π' t) := fun i hi j _ hij ‚Ü¶ by refine hf ?_ ?_ hij <;> aesop
  have : (Finset.erase insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image]
    refine ‚ü®by aesop, fun ‚ü®ha, has‚ü© ‚Ü¶ ?_‚ü©
    obtain ‚ü®j, hj, rfl‚ü© := hs has
    exact ‚ü®j, ‚ü®hj, ha, has‚ü©, rfl‚ü©
  rw [‚Üê this, Finset.sup_image]
  specialize h (insert i (t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)"
Mathlib/GroupTheory/SpecificGroups/Alternating.lean,alternatingGroup.isConj_swap_mul_swap_of_cycleType_two,isConj_swap_mul_swap_of_cycleType_two,e194c75699f5107c3020dd83bb1dc00cf62f62aa,":= by
  have h := g.support.card_le_univ
  rw [‚Üê Multiset.eq_replicate_card] at h2
  rw [‚Üê sum_cycleType, h2, Multiset.sum_replicate, smul_eq_mul] at h
  have h : Multiset.card g.cycleType ‚â§ 3 :=
    le_of_mul_le_mul_right (le_trans h (by simp only [card_fin])) (by simp)
  rw [mem_alternatingGroup, sign_of_cycleType, h2] at ha
  norm_num at ha
  rw [pow_add, pow_mul, Int.units_pow_two, one_mul, Units.ext_iff, Units.val_one,
    Units.val_pow_eq_pow_val, Units.coe_neg_one, neg_one_pow_eq_one_iff_even _] at ha
  swap; ¬∑ decide
  rw [isConj_iff_cycleType_eq, h2]
  interval_cases h_1 : Multiset.card g.cycleType
  ¬∑ exact (h1 (card_cycleType_eq_zero.1 h_1)).elim
  ¬∑ contrapose! ha
    simp [h_1]
  ¬∑ have h04 : (0 : Fin 5) ‚â† 4 := by decide
    have h13 : (1 : Fin 5) ‚â† 3 := by decide
    rw [Disjoint.cycleType, (isCycle_swap h04).cycleType, (isCycle_swap h13).cycleType,
      card_support_swap h04, card_support_swap h13]
    ¬∑ rfl
    ¬∑ rw [disjoint_iff_disjoint_support, support_swap h04, support_swap h13]
      decide
  ¬∑ contrapose! ha
    simp [h_1]","warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  unsolved goals
Œ± : Type u_1
inst‚úù¬π : Fintype Œ±
inst‚úù : DecidableEq Œ±
g : Perm (Fin 5)
ha : g ‚àà alternatingGroup (Fin 5)
h1 : g ‚â† 1
h2 : g.cycleType = Multiset.replicate (Multiset.card g.cycleType) 2
h : Multiset.card g.cycleType * 2 ‚â§ card (Fin 5)
‚ä¢ 5 ‚â§ 3 * 2
error:  simp made no progress","theorem isConj_swap_mul_swap_of_cycleType_two {g : Perm (Fin 5)} (ha : g ‚àà alternatingGroup (Fin 5))
    (h1 : g ‚â† 1) (h2 : ‚àÄ n, n ‚àà cycleType (g : Perm (Fin 5)) ‚Üí n = 2) :
    IsConj (swap 0 4 * swap 1 3) g ",":= by
  have h := g.support.card_le_univ
  rw [‚Üê Multiset.eq_replicate_card] at h2
  rw [‚Üê sum_cycleType, h2, Multiset.sum_replicate, smul_eq_mul] at h
  have h : Multiset.card g.cycleType ‚â§ 3 :=
    le_of_mul_le_mul_right (le_trans h (by simp only [card_fin]; ring_nf; decide)) (by simp)
  rw [mem_alternatingGroup, sign_of_cycleType, h2] at ha
  norm_num at ha
  rw [pow_add, pow_mul, Int.units_pow_two, one_mul, neg_one_pow_eq_one_iff_even] at ha
  swap; ¬∑ decide
  rw [isConj_iff_cycleType_eq, h2]
  interval_cases h_1 : Multiset.card g.cycleType
  ¬∑ exact (h1 (card_cycleType_eq_zero.1 h_1)).elim
  ¬∑ simp at ha
  ¬∑ have h04 : (0 : Fin 5) ‚â† 4 := by decide
    have h13 : (1 : Fin 5) ‚â† 3 := by decide
    rw [Disjoint.cycleType, (isCycle_swap h04).cycleType, (isCycle_swap h13).cycleType,
      card_support_swap h04, card_support_swap h13]
    ¬∑ rfl
    ¬∑ rw [disjoint_iff_disjoint_support, support_swap h04, support_swap h13]
      decide
  ¬∑ contradiction",":= by
  have h := g.support.card_le_univ
  rw [‚Üê Multiset.eq_replicate_card] at h2
  rw [‚Üê sum_cycleType, h2, Multiset.sum_replicate, smul_eq_mul] at h
  have h : Multiset.card g.cycleType ‚â§ 3 :=
    le_of_mul_le_mul_right (le_trans h (by simp only [card_fin])) (by simp)
  rw [mem_alternatingGroup, sign_of_cycleType, h2] at ha
  norm_num at ha
  rw [pow_add, pow_mul, Int.units_pow_two, one_mul, Units.ext_iff, Units.val_one,
    Units.val_pow_eq_pow_val, Units.coe_neg_one, neg_one_pow_eq_one_iff_even _] at ha
  swap; ¬∑ decide
  rw [isConj_iff_cycleType_eq, h2]
  interval_cases h_1 : Multiset.card g.cycleType
  ¬∑ exact (h1 (card_cycleType_eq_zero.1 h_1)).elim
  ¬∑ contrapose! ha
    simp [h_1]
  ¬∑ have h04 : (0 : Fin 5) ‚â† 4 := by decide
    rw [Disjoint.cycleType, (isCycle_swap h04).cycleType, (isCycle_swap h13).cycleType,
      card_support_swap h04, card_support_swap h13]
    ¬∑ rfl
    ¬∑ rw [disjoint_iff_disjoint_support, support_swap h04, support_swap h13]
      decide
  ¬∑ contrapose! ha
    simp [h_1]"
Mathlib/Topology/CompactOpen.lean,ContinuousMap.continuous_curry',continuous_curry',847a3fdc5138725139077c1ba700dd4bb54bb91c,":=
  Continuous.comp (continuous_comp f) continuous_coev","warning:  `ContinuousMap.curry'` has been deprecated, use `ContinuousMap.curry` instead
error:  application type mismatch
  Continuous.comp (continuous_comp f)
argument
  continuous_comp f
has type
  Continuous f.comp : Prop
but is expected to have type
  Continuous ‚áëf.curry : Prop","theorem continuous_curry' (f : C(X √ó Y, Z)) : Continuous (curry' f) ",:= (curry f).continuous,":=
  Continuous.comp (continuous_comp f) continuous_coev"
Mathlib/Data/List/TFAE.lean,List.exists_tfae,exists_tfae,c932badd26769438b46c1ea96eb6e2d1fd7e0896,":= by
  simp_rw [TFAE, List.forall_mem_map_iff]
  intros p‚ÇÅ hp‚ÇÅ p‚ÇÇ hp‚ÇÇ
  exact exists_congr fun a ‚Ü¶ H a (p‚ÇÅ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÅ)
    (p‚ÇÇ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÇ)","error:  unknown tactic
error:  unsolved goals
Œ± : Type u_1
l : List (Œ± ‚Üí Prop)
H : ‚àÄ (a : Œ±), (map (fun p ‚Ü¶ p a) l).TFAE
‚ä¢ (map (fun p ‚Ü¶ ‚àÉ a, p a) l).TFAE","theorem exists_tfae {Œ± : Type*} (l : List (Œ± ‚Üí Prop)) (H : ‚àÄ a : Œ±, (l.map (fun p ‚Ü¶ p a)).TFAE) :
    (l.map (fun p ‚Ü¶ ‚àÉ a, p a)).TFAE ",":= by
  simp only [TFAE, List.forall_mem_map_iff]
  intros p‚ÇÅ hp‚ÇÅ p‚ÇÇ hp‚ÇÇ
  exact exists_congr fun a ‚Ü¶ H a (p‚ÇÅ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÅ)
    (p‚ÇÇ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÇ)",":= by
  simp_rw [List.forall_mem_map_iff]
  intros p‚ÇÅ hp‚ÇÅ p‚ÇÇ hp‚ÇÇ
  exact exists_congr fun a ‚Ü¶ H a (p‚ÇÅ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÅ)
    (p‚ÇÇ a) (mem_map_of_mem (fun p ‚Ü¶ p a) hp‚ÇÇ)"
Mathlib/Topology/UrysohnsLemma.lean,exists_continuous_one_zero_of_isCompact_of_isGŒ¥,exists_continuous_one_zero_of_isCompact_of_isGŒ¥,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases h's.eq_iInter_nat with ‚ü®U, U_open, hU‚ü©
  obtain ‚ü®m, m_comp, -, sm, mt‚ü© : ‚àÉ m, IsCompact m ‚àß IsClosed m ‚àß s ‚äÜ interior m ‚àß m ‚äÜ t·∂ú :=
    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left
  have A n : ‚àÉ f : C(X, ‚Ñù), EqOn f 1 s ‚àß EqOn f 0 (U n ‚à© interior m)·∂ú ‚àß HasCompactSupport f
      ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by
    apply exists_continuous_one_zero_of_isCompact hs
      ((U_open n).inter isOpen_interior).isClosed_compl
    rw [disjoint_compl_right_iff_subset]
    exact subset_inter ((hU.subset.trans (iInter_subset U n))) sm
  choose f fs fm _hf f_range using A
  obtain ‚ü®u, u_pos, u_sum, hu‚ü© : ‚àÉ (u : ‚Ñï ‚Üí ‚Ñù), (‚àÄ i, 0 < u i) ‚àß Summable u ‚àß ‚àë' i, u i = 1 :=
    ‚ü®fun n ‚Ü¶ 1/2/2^n, fun n ‚Ü¶ by positivity, summable_geometric_two' 1, tsum_geometric_two' 1‚ü©
  let g : X ‚Üí ‚Ñù := fun x ‚Ü¶ ‚àë' n, u n * f n x
  have hgmc : EqOn g 0 m·∂ú := by
    intro x hx
    have B n : f n x = 0 := by
      have : m·∂ú ‚äÜ (U n ‚à© interior m)·∂ú := by
        simpa using (inter_subset_right _ _).trans interior_subset
      exact fm n (this hx)
    simp [g, B]
  have I n x : u n * f n x ‚â§ u n := mul_le_of_le_one_right (u_pos n).le (f_range n x).2
  have S x : Summable (fun n ‚Ü¶ u n * f n x) := Summable.of_nonneg_of_le
      (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1) (fun n ‚Ü¶ I n x) u_sum
  refine ‚ü®‚ü®g, ?_‚ü©, ?_, hgmc.mono (subset_compl_comm.mp mt), ?_, fun x ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ apply continuous_tsum (fun n ‚Ü¶ continuous_const.mul (f n).continuous) u_sum (fun n x ‚Ü¶ ?_)
    simpa [abs_of_nonneg, (u_pos n).le, (f_range n x).1] using I n x
  ¬∑ apply Subset.antisymm (fun x hx ‚Ü¶ by simp [g, fs _ hx, hu]) ?_
    apply compl_subset_compl.1
    intro x hx
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, x ‚àâ U n := by simpa [hU] using hx
    have fnx : f n x = 0 := fm _ (by simp [hn])
    have : g x < 1 := by
      apply lt_of_lt_of_le ?_ hu.le
      exact tsum_lt_tsum (i := n) (fun i ‚Ü¶ I i x) (by simp [fnx, u_pos n]) (S x) u_sum
    simpa using this.ne
  ¬∑ exact HasCompactSupport.of_support_subset_isCompact m_comp
      (Function.support_subset_iff'.mpr hgmc)
  ¬∑ exact tsum_nonneg (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1)
  ¬∑ apply le_trans _ hu.le
    exact tsum_le_tsum (fun n ‚Ü¶ I n x) (S x) u_sum","error:  function expected at
  inter_subset_right ?m.69203
term has type
  ?m.69202 ‚àà ?m.69201","theorem exists_continuous_one_zero_of_isCompact_of_isGŒ¥ [RegularSpace X] [LocallyCompactSpace X]
    {s t : Set X} (hs : IsCompact s) (h's : IsGŒ¥ s) (ht : IsClosed t) (hd : Disjoint s t) :
    ‚àÉ f : C(X, ‚Ñù), s = f ‚Åª¬π' {1} ‚àß EqOn f 0 t ‚àß HasCompactSupport f
      ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 ",":= by
  rcases h's.eq_iInter_nat with ‚ü®U, U_open, hU‚ü©
  obtain ‚ü®m, m_comp, -, sm, mt‚ü© : ‚àÉ m, IsCompact m ‚àß IsClosed m ‚àß s ‚äÜ interior m ‚àß m ‚äÜ t·∂ú :=
    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left
  have A n : ‚àÉ f : C(X, ‚Ñù), EqOn f 1 s ‚àß EqOn f 0 (U n ‚à© interior m)·∂ú ‚àß HasCompactSupport f
      ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by
    apply exists_continuous_one_zero_of_isCompact hs
      ((U_open n).inter isOpen_interior).isClosed_compl
    rw [disjoint_compl_right_iff_subset]
    exact subset_inter ((hU.subset.trans (iInter_subset U n))) sm
  choose f fs fm _hf f_range using A
  obtain ‚ü®u, u_pos, u_sum, hu‚ü© : ‚àÉ (u : ‚Ñï ‚Üí ‚Ñù), (‚àÄ i, 0 < u i) ‚àß Summable u ‚àß ‚àë' i, u i = 1 :=
    ‚ü®fun n ‚Ü¶ 1/2/2^n, fun n ‚Ü¶ by positivity, summable_geometric_two' 1, tsum_geometric_two' 1‚ü©
  let g : X ‚Üí ‚Ñù := fun x ‚Ü¶ ‚àë' n, u n * f n x
  have hgmc : EqOn g 0 m·∂ú := by
    intro x hx
    have B n : f n x = 0 := by
      have : m·∂ú ‚äÜ (U n ‚à© interior m)·∂ú := by
        simpa using inter_subset_right.trans interior_subset
      exact fm n (this hx)
    simp [g, B]
  have I n x : u n * f n x ‚â§ u n := mul_le_of_le_one_right (u_pos n).le (f_range n x).2
  have S x : Summable (fun n ‚Ü¶ u n * f n x) := Summable.of_nonneg_of_le
      (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1) (fun n ‚Ü¶ I n x) u_sum
  refine ‚ü®‚ü®g, ?_‚ü©, ?_, hgmc.mono (subset_compl_comm.mp mt), ?_, fun x ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ apply continuous_tsum (fun n ‚Ü¶ continuous_const.mul (f n).continuous) u_sum (fun n x ‚Ü¶ ?_)
    simpa [abs_of_nonneg, (u_pos n).le, (f_range n x).1] using I n x
  ¬∑ apply Subset.antisymm (fun x hx ‚Ü¶ by simp [g, fs _ hx, hu]) ?_
    apply compl_subset_compl.1
    intro x hx
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, x ‚àâ U n := by simpa [hU] using hx
    have fnx : f n x = 0 := fm _ (by simp [hn])
    have : g x < 1 := by
      apply lt_of_lt_of_le ?_ hu.le
      exact tsum_lt_tsum (i := n) (fun i ‚Ü¶ I i x) (by simp [fnx, u_pos n]) (S x) u_sum
    simpa using this.ne
  ¬∑ exact HasCompactSupport.of_support_subset_isCompact m_comp
      (Function.support_subset_iff'.mpr hgmc)
  ¬∑ exact tsum_nonneg (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1)
  ¬∑ apply le_trans _ hu.le
    exact tsum_le_tsum (fun n ‚Ü¶ I n x) (S x) u_sum",":= by
  rcases h's.eq_iInter_nat with ‚ü®U, U_open, hU‚ü©
  obtain ‚ü®m, m_comp, -, sm, mt‚ü© : ‚àÉ m, IsCompact m ‚àß IsClosed m ‚àß s ‚äÜ interior m ‚àß m ‚äÜ t·∂ú :=
    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left
  have A n : ‚àÉ f : C(X, ‚Ñù), EqOn f 1 s ‚àß EqOn f 0 (U n ‚à© interior m)·∂ú ‚àß HasCompactSupport f
      ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by
    apply exists_continuous_one_zero_of_isCompact hs
      ((U_open n).inter isOpen_interior).isClosed_compl
    rw [disjoint_compl_right_iff_subset]
    exact subset_inter ((hU.subset.trans iInter_subset U n))) sm
  choose f fs fm _hf f_range using A
  obtain ‚ü®u, u_pos, u_sum, hu‚ü© : ‚àÉ (u : ‚Ñï ‚Üí ‚Ñù), (‚àÄ i, 0 < u i) ‚àß Summable u ‚àß ‚àë' i, u i = 1 :=
    ‚ü®fun n ‚Ü¶ 1/2/2^n, fun n ‚Ü¶ by positivity, summable_geometric_two' 1, tsum_geometric_two' 1‚ü©
  let g : X ‚Üí ‚Ñù := fun x ‚Ü¶ ‚àë' n, u n * f n x
  have hgmc : EqOn g 0 m·∂ú := by
    intro x hx
    have B n : f n x = 0 := by
      have : m·∂ú ‚äÜ (U n ‚à© interior m)·∂ú := by
        simpa using inter_subset_right.trans interior_subset
      exact fm n (this hx)
    simp [g, B]
  have I n x : u n * f n x ‚â§ u n := mul_le_of_le_one_right (u_pos n).le (f_range n x).2
  have S x : Summable (fun n ‚Ü¶ u n * f n x) := Summable.of_nonneg_of_le
      (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1) (fun n ‚Ü¶ I n x) u_sum
  refine ‚ü®‚ü®g, ?_‚ü©, ?_, hgmc.mono (subset_compl_comm.mp mt), ?_, fun x ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ apply continuous_tsum (fun n ‚Ü¶ continuous_const.mul (f n).continuous) u_sum (fun n x ‚Ü¶ ?_)
    simpa [abs_of_nonneg, (u_pos n).le, (f_range n x).1] using I n x
  ¬∑ apply Subset.antisymm (fun x hx ‚Ü¶ by simp [g, fs _ hx, hu]) ?_
    apply compl_subset_compl.1
    intro x hx
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, x ‚àâ U n := by simpa [hU] using hx
    have fnx : f n x = 0 := fm _ (by simp [hn])
    have : g x < 1 := by
      apply lt_of_lt_of_le ?_ hu.le
      exact tsum_lt_tsum (i := n) (fun i ‚Ü¶ I i x) (by simp [fnx, u_pos n]) (S x) u_sum
    simpa using this.ne
  ¬∑ exact HasCompactSupport.of_support_subset_isCompact m_comp
      (Function.support_subset_iff'.mpr hgmc)
  ¬∑ exact tsum_nonneg (fun n ‚Ü¶ mul_nonneg (u_pos n).le, (f_range n x).1] using I n x
  ¬∑ apply Subset.antisymm (fun x hx ‚Ü¶ by simp [g, fs _ hx, hu]) ?_
    apply compl_subset_compl.1
    intro x hx
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, x ‚àâ U n := by simpa [hU] using hx
    have fnx : f n x = 0 := fm _ (by simp [hn])
    have : g x < 1 := by
      apply lt_of_lt_of_le ?_ "
Mathlib/MeasureTheory/Function/Jacobian.lean,exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt,exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt,4968eba95a704a4a58e8b3735dc3733ee6d46c0d,":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine' ‚ü®fun _ => ‚àÖ, fun _ => 0, _, _, _, _‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' x)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine' mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, _‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine' ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, _, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.definition Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine' ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, _‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := (norm_add_le _ _)
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ + ‚Äñf' x - f' z‚Äñ * ‚Äñy - x‚Äñ := by
        refine' add_le_add (hŒ¥ _) (ContinuousLinearMap.le_opNorm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ‚â§ r (f' z) * ‚Äñy - x‚Äñ := by
        rw [‚Üê add_mul, add_comm]
        exact mul_le_mul_of_nonneg_right hŒµ (norm_nonneg _)
  have closure_M_subset : ‚àÄ n z, s ‚à© closure (M n z) ‚äÜ M n z := by
    rintro n z x ‚ü®xs, hx‚ü©
    refine' ‚ü®xs, fun y hy => _‚ü©
    obtain ‚ü®a, aM, a_lim‚ü© : ‚àÉ a : ‚Ñï ‚Üí E, (‚àÄ k, a k ‚àà M n z) ‚àß Tendsto a atTop (ùìù x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ‚Ñï => ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ) atTop
        (ùìù ‚Äñf y - f x - (f' z) (y - x)‚Äñ) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (ùìù (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ‚Ñï => (r (f' z) : ‚Ñù) * ‚Äñy - a k‚Äñ) atTop (ùìù (r (f' z) * ‚Äñy - x‚Äñ)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ‚àÄ·∂† k in atTop, ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ ‚â§ r (f' z) * ‚Äñy - a k‚Äñ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (ùìù (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ‚ü®hy.1, hk‚ü©
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ‚ü®d, hd‚ü©
  let K : ‚Ñï ‚Üí T ‚Üí ‚Ñï ‚Üí Set E := fun n z p => closure (M n z) ‚à© closedBall (d p) (u n / 3)
  have K_approx : ‚àÄ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ‚à© K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ‚àà M n z := closure_M_subset _ _ ‚ü®hy.1, hy.2.1‚ü©
    refine' yM.2 _ ‚ü®hx.1, _‚ü©
    calc
      dist x y ‚â§ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ‚â§ u n / 3 + u n / 3 := (add_le_add hx.2.2 hy.2.2)
      _ < u n := by linarith [u_pos n]
  have K_closed : ‚àÄ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñï ‚Üí ‚Ñï √ó T √ó ‚Ñï, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases hs with ‚ü®x, xs‚ü©
      rcases s_subset x xs with ‚ü®n, z, _‚ü©
      exact ‚ü®z‚ü©
    inhabit ‚Ü•T
    exact ‚ü®_, Encodable.surjective_decode_iget (‚Ñï √ó T √ó ‚Ñï)‚ü©
  refine'
    ‚ü®fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => _, fun q => K_approx _ _ _, fun _ q => ‚ü®(F q).2.1, (F q).2.1.1.2, rfl‚ü©‚ü©
  obtain ‚ü®n, z, hnz‚ü© : ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := s_subset x xs
  obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, x ‚àà closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, d p ‚àà ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ‚ü®p, (mem_ball'.1 hp).le‚ü©
  obtain ‚ü®q, hq‚ü© : ‚àÉ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ‚ü®q, _‚ü©
  simp (config := { zeta := false }) only [K, hq, mem_inter_iff, hp, and_true]
  exact subset_closure hnz","error:  invalid field 'definition', the environment does not contain 'Asymptotics.IsLittleO.definition'
  (hf' x xs).isLittleO
has type
  (fun x' ‚Ü¶ f x' - f x - (f' x) (x' - x)) =o[ùìù[s] x] fun x' ‚Ü¶ x' - x","theorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]
    (f : E ‚Üí F) (s : Set E) (f' : E ‚Üí E ‚ÜíL[‚Ñù] F) (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x)
    (r : (E ‚ÜíL[‚Ñù] F) ‚Üí ‚Ñù‚â•0) (rpos : ‚àÄ A, r A ‚â† 0) :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] F),
      (‚àÄ n, IsClosed (t n)) ‚àß
        (s ‚äÜ ‚ãÉ n, t n) ‚àß
          (‚àÄ n, ApproximatesLinearOn f (A n) (s ‚à© t n) (r (A n))) ‚àß
            (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) ",":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => 0, ?_, ?_, ?_, ?_‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' x)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, ?_‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ + ‚Äñf' x - f' z‚Äñ * ‚Äñy - x‚Äñ := by
        refine add_le_add (hŒ¥ ?_) (ContinuousLinearMap.le_opNorm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ‚â§ r (f' z) * ‚Äñy - x‚Äñ := by
        rw [‚Üê add_mul, add_comm]
        gcongr
  have closure_M_subset : ‚àÄ n z, s ‚à© closure (M n z) ‚äÜ M n z := by
    rintro n z x ‚ü®xs, hx‚ü©
    refine ‚ü®xs, fun y hy => ?_‚ü©
    obtain ‚ü®a, aM, a_lim‚ü© : ‚àÉ a : ‚Ñï ‚Üí E, (‚àÄ k, a k ‚àà M n z) ‚àß Tendsto a atTop (ùìù x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ‚Ñï => ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ) atTop
        (ùìù ‚Äñf y - f x - (f' z) (y - x)‚Äñ) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (ùìù (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ‚Ñï => (r (f' z) : ‚Ñù) * ‚Äñy - a k‚Äñ) atTop (ùìù (r (f' z) * ‚Äñy - x‚Äñ)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ‚àÄ·∂† k in atTop, ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ ‚â§ r (f' z) * ‚Äñy - a k‚Äñ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (ùìù (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ‚ü®hy.1, hk‚ü©
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ‚ü®d, hd‚ü©
  let K : ‚Ñï ‚Üí T ‚Üí ‚Ñï ‚Üí Set E := fun n z p => closure (M n z) ‚à© closedBall (d p) (u n / 3)
  have K_approx : ‚àÄ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ‚à© K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ‚àà M n z := closure_M_subset _ _ ‚ü®hy.1, hy.2.1‚ü©
    refine yM.2 _ ‚ü®hx.1, ?_‚ü©
    calc
      dist x y ‚â§ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ‚â§ u n / 3 + u n / 3 := add_le_add hx.2.2 hy.2.2
      _ < u n := by linarith [u_pos n]
  have K_closed : ‚àÄ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñï ‚Üí ‚Ñï √ó T √ó ‚Ñï, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases hs with ‚ü®x, xs‚ü©
      rcases s_subset x xs with ‚ü®n, z, _‚ü©
      exact ‚ü®z‚ü©
    inhabit ‚Ü•T
    exact ‚ü®_, Encodable.surjective_decode_iget (‚Ñï √ó T √ó ‚Ñï)‚ü©
  refine
    ‚ü®fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => ?_, fun q => K_approx _ _ _, fun _ q => ‚ü®(F q).2.1, (F q).2.1.1.2, rfl‚ü©‚ü©
  obtain ‚ü®n, z, hnz‚ü© : ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := s_subset x xs
  obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, x ‚àà closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, d p ‚àà ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ‚ü®p, (mem_ball'.1 hp).le‚ü©
  obtain ‚ü®q, hq‚ü© : ‚àÉ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ‚ü®q, _‚ü©
  simp (config := { zeta := false }) only [K, hq, mem_inter_iff, hp, and_true]
  exact subset_closure hnz",":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => 0, ?_, ?_, ?_, ?_‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' z)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, ?_‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.definition Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - "
Mathlib/Data/Nat/Log.lean,Nat.pow_le_iff_le_log,pow_le_iff_le_log,41b955aad45c24b4e2c9b0cae45d9ea397306cf5,":= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => exact iff_of_true hy.bot_lt (zero_le _)
  | succ x =>
    rw [log]; split_ifs with h
    ¬∑ have b_pos : 0 < b := zero_le_one.trans_lt hb
      rw [add_le_add_iff_right, ‚Üê
        ih (y / b) (div_lt_self hy.bot_lt hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', mul_comm]
    ¬∑ exact iff_of_false (fun hby => h ‚ü®(le_self_pow x.succ_ne_zero _).trans hby, hb‚ü©)
        (not_succ_le_zero _)","error:  application type mismatch
  iff_of_true (Ne.bot_lt ?m.6914)
argument
  Ne.bot_lt ?m.6914
has type
  ‚ä• < ?m.4897 : Prop
but is expected to have type
  b ^ 0 ‚â§ y : Prop
error:  application type mismatch
  Ne.bot_lt hy
argument
  hy
has type
  y ‚â† 0 : Prop
but is expected to have type
  y ‚â† ‚ä• : Prop
error:  unknown identifier 'zero_le_one.trans_lt'
error:  unknown identifier 'add_le_add_iff_right'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.8211
case pos
b : ‚Ñï
hb : 1 < b
y : ‚Ñï
ih : ‚àÄ m < y, ‚àÄ {x : ‚Ñï}, m ‚â† 0 ‚Üí (b ^ x ‚â§ m ‚Üî x ‚â§ log b m)
hy : y ‚â† 0
x : ‚Ñï
h : b ‚â§ y ‚àß 1 < b
b_pos : 0 < b
‚ä¢ b ^ (x + 1) ‚â§ y ‚Üî x + 1 ‚â§ log b (y / b) + 1","theorem pow_le_iff_le_log {b : ‚Ñï} (hb : 1 < b) {x y : ‚Ñï} (hy : y ‚â† 0) :
    b ^ x ‚â§ y ‚Üî x ‚â§ log b y ",":= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => dsimp; omega
  | succ x =>
    rw [log]; split_ifs with h
    ¬∑ have b_pos : 0 < b := lt_of_succ_lt hb
      rw [Nat.add_le_add_iff_right, ‚Üê ih (y / b) (div_lt_self
        (Nat.pos_iff_ne_zero.2 hy) hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', Nat.mul_comm]
    ¬∑ exact iff_of_false (fun hby => h ‚ü®(le_self_pow x.succ_ne_zero _).trans hby, hb‚ü©)
        (not_succ_le_zero _)",":= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => exact iff_of_true hy.bot_lt (zero_le _)
  | succ x =>
    rw [log]; split_ifs with h
    ¬∑ have b_pos : 0 < b := zero_le_one.trans_lt hb
      rw [add_le_add_iff_right, ‚Üê
        ih (y / b) (div_lt_self hy.bot_lt hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', mul_comm]
    ¬∑ exact iff_of_false (fun hby => h ‚ü®(le_self_pow x.succ_ne_zero _).trans hby, hb‚ü©)
        (not_succ_le_zero _)"
Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean,Polynomial.natTrailingDegree_eq_of_trailingDegree_eq,natTrailingDegree_eq_of_trailingDegree_eq,bc769a9f781a01550bc7da7431e6157f3b3d6c81,":= by
  simp [natTrailingDegree, h]","error:  unsolved goals
R : Type u
S : Type v
a b : R
n‚úù m : ‚Ñï
inst‚úù : Semiring R
p‚úù q r p : R[X]
n : ‚Ñï
h : p.trailingDegree = ‚Üën
‚ä¢ Option.getD (‚Üën) 0 = n","theorem natTrailingDegree_eq_of_trailingDegree_eq_some {p : R[X]} {n : ‚Ñï}
    (h : trailingDegree p = n) : natTrailingDegree p = n ",":=
  have hp0 : p ‚â† 0 := fun hp0 => by rw [hp0] at h; exact Option.noConfusion h
  Option.some_inj.1 <|
    show (natTrailingDegree p : ‚Ñï‚àû) = n by rwa [‚Üê trailingDegree_eq_natTrailingDegree hp0]",":= by
  simp [natTrailingDegree]"
Mathlib/CategoryTheory/Adjunction/Reflective.lean,CategoryTheory.equivEssImageOfReflective_map_counitIso_app_hom,equivEssImageOfReflective_map_counitIso_app_hom,9bc35020058f4a5a844eb7662d9de673056d4dbe,"  (Functor.essImageInclusion i).map (equivEssImageOfReflective_counitIso_app X).hom =
    inv (NatTrans.app (ofRightAdjoint i).unit X.obj) := by
    simp [equivEssImageOfReflective_counitIso_app, asIso]
    rfl","error:  unknown identifier 'ofRightAdjoint'
error:  unknown identifier 'equivEssImageOfReflective_map_counitIso_app_hom'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.31459
case a
C : Type u‚ÇÅ
D : Type u‚ÇÇ
E : Type u‚ÇÉ
inst‚úù¬≥ : Category.{v‚ÇÅ, u‚ÇÅ} C
inst‚úù¬≤ : Category.{v‚ÇÇ, u‚ÇÇ} D
inst‚úù¬π : Category.{v‚ÇÉ, u‚ÇÉ} E
i : D ‚•§ C
inst‚úù : Reflective i
X Y : i.EssImageSubcategory
f : X ‚ü∂ Y
h : (reflectorAdjunction i).unit.app X.obj ‚â´ (reflector i ‚ãô i).map f = f ‚â´ (reflectorAdjunction i).unit.app Y.obj
‚ä¢ i.essImageInclusion.map (((i.essImageInclusion ‚ãô reflector i) ‚ãô i.toEssImage).map f) ‚â´
      i.essImageInclusion.map (equivEssImageOfReflective_counitIso_app Y).hom =
    i.essImageInclusion.map (equivEssImageOfReflective_counitIso_app X).hom ‚â´
      i.essImageInclusion.map ((ùü≠ i.EssImageSubcategory).map f)
error:  unknown identifier 'equivEssImageOfReflective_map_counitIso_app_hom'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.31883
case a
C : Type u‚ÇÅ
D : Type u‚ÇÇ
E : Type u‚ÇÉ
inst‚úù¬≥ : Category.{v‚ÇÅ, u‚ÇÅ} C
inst‚úù¬≤ : Category.{v‚ÇÇ, u‚ÇÇ} D
inst‚úù¬π : Category.{v‚ÇÉ, u‚ÇÉ} E
i : D ‚•§ C
inst‚úù : Reflective i
X : D
‚ä¢ i.essImageInclusion.map
        (i.toEssImage.map
          ((NatIso.ofComponents (fun X ‚Ü¶ (asIso ((reflectorAdjunction i).counit.app X)).symm) ‚ãØ).hom.app X)) ‚â´
      i.essImageInclusion.map
        ((NatIso.ofComponents equivEssImageOfReflective_counitIso_app ‚ãØ).hom.app (i.toEssImage.obj X)) =
    i.essImageInclusion.map (ùüô (i.toEssImage.obj X))","lemma equivEssImageOfReflective_map_counitIso_app_hom [Reflective i]
    (X : Functor.EssImageSubcategory i) :
","  (Functor.essImageInclusion i).map (equivEssImageOfReflective_counitIso_app X).hom =
    inv (NatTrans.app (reflectorAdjunction i).unit X.obj) := by
    simp only [Functor.comp_obj, Functor.essImageInclusion_obj, Functor.toEssImage_obj_obj,
      equivEssImageOfReflective_counitIso_app, asIso, Iso.symm_mk, Functor.essImageInclusion_map,
      Functor.id_obj]
    rfl",":= by
    simp [equivEssImageOfReflective_counitIso_app, asIso]
    rfl"
Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean,WeierstrassCurve.Projective.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,0a4b391b68ce1c32b1ab9ccb77a41ee1c7f8371b,":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
      at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]‚ü©","error:  application type mismatch
  div_mul_cancel ?m.248578 hQ
argument
  hQ
has type
  ¬¨Q 1 = 0 : Prop
but is expected to have type
  ?m.248576 : Type ?u.248575
error:  unsolved goals
R : Type u
inst‚úù¬π : CommRing R
W‚úù : Projective R
F : Type u
inst‚úù : Field F
W : Projective F
P Q : Fin 3 ‚Üí F
hPz : P 2 = 0
hQz : Q 2 = 0
hP : ¬¨P 1 = 0
hQ : ¬¨Q 1 = 0
‚ä¢ ![0, P 1 / Q 1 * Q 1, 0] = ![0, P 1, 0]","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
      at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]‚ü©"
Mathlib/Topology/CompactOpen.lean,ContinuousMap.continuous_comp,continuous_comp,07d28ef76de6fda605a7eb6f6c9ef70c5c90b329,":= by
  simp_rw (config := { instances := true }) [compactOpen_eq, continuous_generateFrom_iff,
    forall_image2_iff, mapsTo']
  rfl","error:  'instances' is not a field of structure 'Lean.Meta.Simp.Config'
error:  cannot evaluate code because 'sorryAx' uses 'sorry' and/or contains errors
warning:  `ContinuousMap.curry'` has been deprecated, use `ContinuousMap.curry` instead","lemma continuous_compactOpen {f : X ‚Üí C(Y, Z)} :
    Continuous f ‚Üî ‚àÄ K, IsCompact K ‚Üí ‚àÄ U, IsOpen U ‚Üí IsOpen {x | MapsTo (f x) K U} ",":=
  continuous_generateFrom_iff.trans forall_image2_iff",":= by
  simp_rw [config := { instances := true }) [compactOpen_eq, continuous_generateFrom_iff,
    forall_image2_iff, mapsTo']"
Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean,MeasureTheory.TendstoInMeasure.exists_seq_tendsto_ae,TendstoInMeasure.exists_seq_tendsto_ae,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  have h_lt_Œµ_real : ‚àÄ (Œµ : ‚Ñù) (_ : 0 < Œµ), ‚àÉ k : ‚Ñï, 2 * (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := by
    intro Œµ hŒµ
    obtain ‚ü®k, h_k‚ü© : ‚àÉ k : ‚Ñï, (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := exists_pow_lt_of_lt_one hŒµ (by norm_num)
    refine' ‚ü®k + 1, (le_of_eq _).trans_lt h_k‚ü©
    rw [pow_add]; ring
  set ns := ExistsSeqTendstoAe.seqTendstoAeSeq hfg
  use ns
  let S := fun k => { x | (2 : ‚Ñù)‚Åª¬π ^ k ‚â§ dist (f (ns k) x) (g x) }
  have hŒºS_le : ‚àÄ k, Œº (S k) ‚â§ (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ k := by
    intro k
    have := ExistsSeqTendstoAe.seqTendstoAeSeq_spec hfg k (ns k) le_rfl
    convert this
  set s := Filter.atTop.limsup S with hs
  have hŒºs : Œº s = 0 := by
    refine' measure_limsup_eq_zero (ne_of_lt <| lt_of_le_of_lt (ENNReal.tsum_le_tsum hŒºS_le) _)
    simp only [ENNReal.tsum_geometric, ENNReal.one_sub_inv_two, inv_inv]
  have h_tendsto : ‚àÄ x ‚àà s·∂ú, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) := by
    refine' fun x hx => Metric.tendsto_atTop.mpr fun Œµ hŒµ => _
    rw [hs, limsup_eq_iInf_iSup_of_nat] at hx
    simp only [Set.iSup_eq_iUnion, Set.iInf_eq_iInter, Set.compl_iInter, Set.compl_iUnion,
      Set.mem_iUnion, Set.mem_iInter, Set.mem_compl_iff, Set.mem_setOf_eq, not_le] at hx
    obtain ‚ü®N, hNx‚ü© := hx
    obtain ‚ü®k, hk_lt_Œµ‚ü© := h_lt_Œµ_real Œµ hŒµ
    refine' ‚ü®max N (k - 1), fun n hn_ge => lt_of_le_of_lt _ hk_lt_Œµ‚ü©
    specialize hNx n ((le_max_left _ _).trans hn_ge)
    have h_inv_n_le_k : (2 : ‚Ñù)‚Åª¬π ^ n ‚â§ 2 * (2 : ‚Ñù)‚Åª¬π ^ k := by
      rw [mul_comm, ‚Üê inv_mul_le_iff' (zero_lt_two' ‚Ñù)]
      conv_lhs =>
        congr
        rw [‚Üê pow_one (2 : ‚Ñù)‚Åª¬π]
      rw [‚Üê pow_add, add_comm]
      exact pow_le_pow_of_le_one (one_div (2 : ‚Ñù) ‚ñ∏ one_half_pos.le) (inv_le_one one_le_two)
        ((le_tsub_add.trans (add_le_add_right (le_max_right _ _) 1)).trans
          (add_le_add_right hn_ge 1))
    exact le_trans hNx.le h_inv_n_le_k
  rw [ae_iff]
  refine' ‚ü®ExistsSeqTendstoAe.seqTendstoAeSeq_strictMono hfg, measure_mono_null (fun x => _) hŒºs‚ü©
  rw [Set.mem_setOf_eq, ‚Üê @Classical.not_not (x ‚àà s), not_imp_not]
  exact h_tendsto x","error:  unsolved goals
Œ± : Type u_1
Œπ : Type u_2
E : Type u_3
m : MeasurableSpace Œ±
Œº : Measure Œ±
inst‚úù : MetricSpace E
f : ‚Ñï ‚Üí Œ± ‚Üí E
g : Œ± ‚Üí E
hfg : TendstoInMeasure Œº f atTop g
h_lt_Œµ_real : ‚àÄ (Œµ : ‚Ñù), 0 < Œµ ‚Üí ‚àÉ k, 2 * 2‚Åª¬π ^ k < Œµ
ns : ‚Ñï ‚Üí ‚Ñï := ExistsSeqTendstoAe.seqTendstoAeSeq hfg
S : ‚Ñï ‚Üí Set Œ± := fun k ‚Ü¶ {x | 2‚Åª¬π ^ k ‚â§ dist (f (ns k) x) (g x)}
hŒºS_le : ‚àÄ (k : ‚Ñï), Œº (S k) ‚â§ 2‚Åª¬π ^ k
s : Set Œ± := limsup S atTop
hs : s = limsup S atTop
‚ä¢ 2 < ‚ä§
error:  invalid field 'le', the environment does not contain 'Not.le'
  hNx
has type
  x ‚àâ S n
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hNx
has type
  x ‚àà S n ‚Üí False","theorem TendstoInMeasure.exists_seq_tendsto_ae (hfg : TendstoInMeasure Œº f atTop g) :
    ‚àÉ ns : ‚Ñï ‚Üí ‚Ñï, StrictMono ns ‚àß ‚àÄ·µê x ‚àÇŒº, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) ",":= by
  have h_lt_Œµ_real : ‚àÄ (Œµ : ‚Ñù) (_ : 0 < Œµ), ‚àÉ k : ‚Ñï, 2 * (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := by
    intro Œµ hŒµ
    obtain ‚ü®k, h_k‚ü© : ‚àÉ k : ‚Ñï, (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := exists_pow_lt_of_lt_one hŒµ (by norm_num)
    refine ‚ü®k + 1, (le_of_eq ?_).trans_lt h_k‚ü©
    rw [pow_add]; ring
  set ns := ExistsSeqTendstoAe.seqTendstoAeSeq hfg
  use ns
  let S := fun k => { x | (2 : ‚Ñù)‚Åª¬π ^ k ‚â§ dist (f (ns k) x) (g x) }
  have hŒºS_le : ‚àÄ k, Œº (S k) ‚â§ (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ k :=
    fun k => ExistsSeqTendstoAe.seqTendstoAeSeq_spec hfg k (ns k) le_rfl
  set s := Filter.atTop.limsup S with hs
  have hŒºs : Œº s = 0 := by
    refine measure_limsup_eq_zero (ne_of_lt <| lt_of_le_of_lt (ENNReal.tsum_le_tsum hŒºS_le) ?_)
    simp only [ENNReal.tsum_geometric, ENNReal.one_sub_inv_two, ENNReal.two_lt_top, inv_inv]
  have h_tendsto : ‚àÄ x ‚àà s·∂ú, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) := by
    refine fun x hx => Metric.tendsto_atTop.mpr fun Œµ hŒµ => ?_
    rw [hs, limsup_eq_iInf_iSup_of_nat] at hx
    simp only [S, Set.iSup_eq_iUnion, Set.iInf_eq_iInter, Set.compl_iInter, Set.compl_iUnion,
      Set.mem_iUnion, Set.mem_iInter, Set.mem_compl_iff, Set.mem_setOf_eq, not_le] at hx
    obtain ‚ü®N, hNx‚ü© := hx
    obtain ‚ü®k, hk_lt_Œµ‚ü© := h_lt_Œµ_real Œµ hŒµ
    refine ‚ü®max N (k - 1), fun n hn_ge => lt_of_le_of_lt ?_ hk_lt_Œµ‚ü©
    specialize hNx n ((le_max_left _ _).trans hn_ge)
    have h_inv_n_le_k : (2 : ‚Ñù)‚Åª¬π ^ n ‚â§ 2 * (2 : ‚Ñù)‚Åª¬π ^ k := by
      rw [mul_comm, ‚Üê inv_mul_le_iff' (zero_lt_two' ‚Ñù)]
      conv_lhs =>
        congr
        rw [‚Üê pow_one (2 : ‚Ñù)‚Åª¬π]
      rw [‚Üê pow_add, add_comm]
      exact pow_le_pow_of_le_one (one_div (2 : ‚Ñù) ‚ñ∏ one_half_pos.le) (inv_le_one one_le_two)
        ((le_tsub_add.trans (add_le_add_right (le_max_right _ _) 1)).trans
          (add_le_add_right hn_ge 1))
    exact le_trans hNx.le h_inv_n_le_k
  rw [ae_iff]
  refine ‚ü®ExistsSeqTendstoAe.seqTendstoAeSeq_strictMono hfg, measure_mono_null (fun x => ?_) hŒºs‚ü©
  rw [Set.mem_setOf_eq, ‚Üê @Classical.not_not (x ‚àà s), not_imp_not]
  exact h_tendsto x",":= by
  have h_lt_Œµ_real : ‚àÄ (Œµ : ‚Ñù) (_ : 0 < Œµ), ‚àÉ k : ‚Ñï, 2 * (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := by
    intro Œµ hŒµ
    obtain ‚ü®k, h_k‚ü© : ‚àÉ k : ‚Ñï, (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := exists_pow_lt_of_lt_one hŒµ (by norm_num)
    refine ‚ü®k + 1, (le_of_eq ?_).trans_lt h_k‚ü©
    rw [pow_add]; ring
  set ns := ExistsSeqTendstoAe.seqTendstoAeSeq hfg
  use ns
  let S := fun k => { x | (2 : ‚Ñù)‚Åª¬π ^ k ‚â§ dist (f (ns k) x) (g x) }
  have hŒºS_le : ‚àÄ k, Œº (S k) ‚â§ (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ k := by
    intro k
    have := ExistsSeqTendstoAe.seqTendstoAeSeq_spec hfg k (ns k) le_rfl
    convert this
  set s := Filter.atTop.limsup S with hs
  have hŒºs : Œº s = 0 := by
    refine measure_limsup_eq_zero (ne_of_lt <| lt_of_le_of_lt (ENNReal.tsum_le_tsum hŒºS_le) ?_)
    simp only [ENNReal.tsum_geometric, ENNReal.one_sub_inv_two, inv_inv]
  have h_tendsto : ‚àÄ x ‚àà s·∂ú, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) := by
    refine fun x hx => Metric.tendsto_atTop.mpr fun Œµ hŒµ => ?_
    rw [hs, limsup_eq_iInf_iSup_of_nat] at hx
    simp only [Set.iSup_eq_iUnion, Set.iInf_eq_iInter, Set.compl_iInter, Set.compl_iUnion,
      Set.mem_iUnion, Set.mem_iInter, Set.mem_compl_iff, Set.mem_setOf_eq, not_le] at hx
    obtain ‚ü®N, hNx‚ü© := hx
    obtain ‚ü®k, hk_lt_Œµ‚ü© := h_lt_Œµ_real Œµ hŒµ
    refine ‚ü®max N (k - 1), fun n hn_ge => lt_of_le_of_lt ?_ hk_lt_Œµ‚ü©
    specialize hNx n ((le_max_left _ _).trans hn_ge)
    have h_inv_n_le_k : (2 : ‚Ñù)‚Åª¬π ^ n ‚â§ 2 * (2 : ‚Ñù)‚Åª¬π ^ k := by
      rw [mul_comm, ‚Üê inv_mul_le_iff' (zero_lt_two' ‚Ñù)]
      conv_lhs =>
        congr
        rw [‚Üê pow_one (2 : ‚Ñù)‚Åª¬π]
      rw [‚Üê pow_add, add_comm]
      exact pow_le_pow_of_le_one (one_div (2 : ‚Ñù) ‚ñ∏ one_half_pos.le) (inv_le_one one_le_two)
        ((le_tsub_add.trans (add_le_add_right (le_max_right _ _) 1)).trans
          (add_le_add_right hn_ge 1))
    exact le_trans hNx.le h_inv_n_le_k
  rw [ae_iff]
  refine ‚ü®ExistsSeqTendstoAe.seqTendstoAeSeq_strictMono hfg, measure_mono_null (fun x => ?_) hŒºs‚ü©
  rw [Set.mem_setOf_eq, ‚Üê @Classical.not_not (x ‚àà s), not_imp_not]
  exact h_tendsto x"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicOn.inv,inv,1df5e9f2d5d2defceda7b95892bf4c4bb80859af,":= by
  rcases hf with ‚ü®m, hf‚ü©
  by_cases h_eq : (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
  ¬∑ 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  ¬∑ 
    obtain ‚ü®n, g, hg_an, hg_ne, hg_eq‚ü© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ùïú x).sub analyticAt_const).pow _
    refine ‚ü®n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_‚ü©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    ¬∑ simp only [sub_self, pow_succ, zero_mul, zero_smul]
    ¬∑ simp_rw [smul_eq_mul] at hfg ‚ä¢
      have aux1 : f z ‚â† 0
      ¬∑ have : (z - x) ^ n * g z ‚â† 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [‚Üê hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ, mul_assoc, hfg]
      ring","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case h.inl
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí ùïú
m n : ‚Ñï
g : ùïú ‚Üí ùïú
z : ùïú
hg_ne' : g z ‚â† 0
hf : AnalyticAt ùïú (fun z_1 ‚Ü¶ (z_1 - z) ^ m ‚Ä¢ f z_1) z
h_eq : ¬¨(fun z_1 ‚Ü¶ (z_1 - z) ^ m ‚Ä¢ f z_1) =·∂†[ùìù z] 0
hg_an : AnalyticAt ùïú g z
hg_ne : g z ‚â† 0
hg_eq : ‚àÄ·∂† (z_1 : ùïú) in ùìù z, (z_1 - z) ^ m ‚Ä¢ f z_1 = (z_1 - z) ^ n ‚Ä¢ g z_1
this : AnalyticAt ùïú (fun z_1 ‚Ü¶ (z_1 - z) ^ (m + 1)) z
hfg : (z - z) ^ m ‚Ä¢ f z = (z - z) ^ n ‚Ä¢ g z
‚ä¢ (0 ^ m * 0) ‚Ä¢ (g z)‚Åª¬π = (0 ^ n * 0) ‚Ä¢ f‚Åª¬π z
error:  unsolved goals
case h.inr
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí ùïú
x : ùïú
m : ‚Ñï
hf : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) x
h_eq : ¬¨(fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
n : ‚Ñï
g : ùïú ‚Üí ùïú
hg_an : AnalyticAt ùïú g x
hg_ne : g x ‚â† 0
hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù x, (z - x) ^ m ‚Ä¢ f z = (z - x) ^ n ‚Ä¢ g z
this : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x
z : ùïú
hfg : (z - x) ^ m * f z = (z - x) ^ n * g z
hg_ne' : g z ‚â† 0
hz_ne : z ‚â† x
aux1 : f z ‚â† 0
‚ä¢ (z - x) ^ (m + 1) * (g z)‚Åª¬π = (z - x) ^ (n + 1) * f‚Åª¬π z",lemma inv {f : ùïú ‚Üí ùïú} {x : ùïú} (hf : MeromorphicAt f x) : MeromorphicAt f‚Åª¬π x ,":= by
  rcases hf with ‚ü®m, hf‚ü©
  by_cases h_eq : (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
  ¬∑ 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  ¬∑ 
    obtain ‚ü®n, g, hg_an, hg_ne, hg_eq‚ü© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ùïú x).sub analyticAt_const).pow _
    refine ‚ü®n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_‚ü©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    ¬∑ simp only [sub_self, pow_succ, mul_zero, zero_smul]
    ¬∑ simp_rw [smul_eq_mul] at hfg ‚ä¢
      have aux1 : f z ‚â† 0 := by
        have : (z - x) ^ n * g z ‚â† 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [‚Üê hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ', mul_assoc, hfg]
      ring",":= by
  rcases hf with ‚ü®m, hf‚ü©
  by_cases h_eq : (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
  ¬∑ 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  ¬∑ 
    obtain ‚ü®n, g, hg_an, hg_ne, hg_eq‚ü© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ùïú x).sub analyticAt_const).pow _
    refine ‚ü®n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_‚ü©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    ¬∑ simp only [sub_self, pow_succ, zero_mul, zero_smul]
    ¬∑ simp_rw [smul_eq_mul] at hfg ‚ä¢
      have aux1 : f z ‚â† 0
      ¬∑ have : (z - x) ^ n * g z ‚â† 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [‚Üê hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ, mul_assoc, hfg]
      ring"
Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean,norm_jacobiTheta‚ÇÇ_term_fderiv_le,norm_jacobiTheta‚ÇÇ_term_fderiv_le,cf5995283f32dd2e0ccb43bc9901c4e7ba9fed97,":= by
  have hns (a : ‚ÑÇ) (f : (‚ÑÇ √ó ‚ÑÇ) ‚ÜíL[‚ÑÇ] ‚ÑÇ) : ‚Äña ‚Ä¢ f‚Äñ = ‚Äña‚Äñ * ‚Äñf‚Äñ := norm_smul a f
  rw [jacobiTheta‚ÇÇ_term_fderiv, jacobiTheta‚ÇÇ_term, hns,
    mul_comm _ ‚Äñcexp _‚Äñ, (by norm_num : (3 : ‚Ñù) = 2 + 1), add_mul, add_mul]
  refine mul_le_mul_of_nonneg_left ((norm_add_le _ _).trans (add_le_add ?_ ?_)) (norm_nonneg _)
  ¬∑ simp_rw [hns, norm_mul, ‚Üê ofReal_ofNat, ‚Üê ofReal_int_cast,
      norm_real, norm_of_nonneg zero_le_two, Real.norm_of_nonneg pi_pos.le, norm_I, mul_one,
      Real.norm_eq_abs, Int.cast_abs, mul_assoc]
    refine mul_le_mul_of_nonneg_left (mul_le_mul_of_nonneg_left ?_ pi_pos.le) two_pos.le
    refine le_trans ?_ (?_ : |(n : ‚Ñù)| ‚â§ |(n : ‚Ñù)| ^ 2)
    ¬∑ exact mul_le_of_le_one_right (abs_nonneg _) (ContinuousLinearMap.norm_fst_le ..)
    ¬∑ exact_mod_cast Int.le_self_sq |n|
  ¬∑ simp_rw [hns, norm_mul, one_mul, norm_I, mul_one,
      norm_real, norm_of_nonneg pi_pos.le, ‚Üê ofReal_int_cast, ‚Üê ofReal_pow, norm_real,
      Real.norm_eq_abs, Int.cast_abs, _root_.abs_pow]
    apply mul_le_of_le_one_right (mul_nonneg pi_pos.le (pow_nonneg (abs_nonneg _) _))
    exact ContinuousLinearMap.norm_snd_le ..","error:  unknown identifier 'ofReal_int_cast'
error:  simp made no progress
error:  unknown identifier 'ofReal_int_cast'
error:  simp made no progress","lemma norm_jacobiTheta‚ÇÇ_term_fderiv_le (n : ‚Ñ§) (z œÑ : ‚ÑÇ) :
    ‚ÄñjacobiTheta‚ÇÇ_term_fderiv n z œÑ‚Äñ ‚â§ 3 * œÄ * |n| ^ 2 * ‚ÄñjacobiTheta‚ÇÇ_term n z œÑ‚Äñ ",":= by
  have hns (a : ‚ÑÇ) (f : (‚ÑÇ √ó ‚ÑÇ) ‚ÜíL[‚ÑÇ] ‚ÑÇ) : ‚Äña ‚Ä¢ f‚Äñ = ‚Äña‚Äñ * ‚Äñf‚Äñ := norm_smul a f
  rw [jacobiTheta‚ÇÇ_term_fderiv, jacobiTheta‚ÇÇ_term, hns,
    mul_comm _ ‚Äñcexp _‚Äñ, (by norm_num : (3 : ‚Ñù) = 2 + 1), add_mul, add_mul]
  refine mul_le_mul_of_nonneg_left ((norm_add_le _ _).trans (add_le_add ?_ ?_)) (norm_nonneg _)
  ¬∑ simp_rw [hns, norm_mul, ‚Üê ofReal_ofNat, ‚Üê ofReal_intCast,
      norm_real, norm_of_nonneg zero_le_two, Real.norm_of_nonneg pi_pos.le, norm_I, mul_one,
      Real.norm_eq_abs, Int.cast_abs, mul_assoc]
    refine mul_le_mul_of_nonneg_left (mul_le_mul_of_nonneg_left ?_ pi_pos.le) two_pos.le
    refine le_trans ?_ (?_ : |(n : ‚Ñù)| ‚â§ |(n : ‚Ñù)| ^ 2)
    ¬∑ exact mul_le_of_le_one_right (abs_nonneg _) (ContinuousLinearMap.norm_fst_le ..)
    ¬∑ exact_mod_cast Int.le_self_sq |n|
  ¬∑ simp_rw [hns, norm_mul, one_mul, norm_I, mul_one,
      norm_real, norm_of_nonneg pi_pos.le, ‚Üê ofReal_intCast, ‚Üê ofReal_pow, norm_real,
      Real.norm_eq_abs, Int.cast_abs, _root_.abs_pow]
    apply mul_le_of_le_one_right (mul_nonneg pi_pos.le (pow_nonneg (abs_nonneg _) _))
    exact ContinuousLinearMap.norm_snd_le ..",":= by
  have hns (a : ‚ÑÇ) (f : (‚ÑÇ √ó ‚ÑÇ) ‚ÜíL[‚ÑÇ] ‚ÑÇ) : ‚Äña ‚Ä¢ f‚Äñ = ‚Äña‚Äñ * ‚Äñf‚Äñ := norm_smul a f
  rw [jacobiTheta‚ÇÇ_term_fderiv, jacobiTheta‚ÇÇ_term, hns,
    mul_comm _ ‚Äñcexp _‚Äñ, (by norm_num : (3 : ‚Ñù) = 2 + 1), add_mul, add_mul]
  refine mul_le_mul_of_nonneg_left ((norm_add_le _ _).trans (add_le_add ?_ ?_)) (norm_nonneg _)
  ¬∑ simp_rw [hns, norm_mul, ‚Üê ofReal_ofNat, ‚Üê ofReal_intCast,
      norm_of_nonneg zero_le_two, Real.norm_of_nonneg pi_pos.le, norm_I, mul_one,
      Real.norm_eq_abs, Int.cast_abs, mul_assoc]
    refine mul_le_mul_of_nonneg_left (mul_le_mul_of_nonneg_left ?_ pi_pos.le) two_pos.le
    refine le_trans ?_ (?_ : |(n : ‚Ñù)| ‚â§ |(n : ‚Ñù)| ^ 2)
    ¬∑ exact mul_le_of_le_one_right (abs_nonneg _) (ContinuousLinearMap.norm_fst_le ..)
    ¬∑ exact_mod_cast Int.le_self_sq |n|
  ¬∑ simp_rw [hns, norm_mul, one_mul, norm_I, mul_one,
      norm_real, norm_of_nonneg pi_pos.le, ‚Üê ofReal_intCast, ‚Üê ofReal_pow, norm_real,
      Real.norm_eq_abs, Int.cast_abs, _root_.abs_pow]
    apply mul_le_of_le_one_right (mul_nonneg pi_pos.le (pow_nonneg (abs_nonneg _) _))
    exact ContinuousLinearMap.norm_snd_le .."
Mathlib/NumberTheory/NumberField/Embeddings.lean,NumberField.Embeddings.pow_eq_one_of_norm_eq_one,pow_eq_one_of_norm_eq_one,82c813af13556dfd4f1674ca7e80454403652cd8,":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ ((¬∑ ^ ¬∑) x : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  ¬∑ wlog hlt : b < a
    ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
    refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
    dsimp at h 
    rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
    refine h.resolve_right fun hp => ?_
    specialize hx (IsAlgClosed.lift (NumberField.isAlgebraic K)).toRingHom
    rw [pow_eq_zero hp, map_zero, norm_zero] at hx ; norm_num at hx","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsAlgClosed.lift ?m.50198
has type
  ?m.49380
error:  application type mismatch
  IsAlgClosed.lift ‚ãØ
argument
  NumberField.isAlgebraic K
has type
  Algebra.IsAlgebraic ‚Ñö K : Prop
but is expected to have type
  ?m.49385 : Type ?u.49377","theorem pow_eq_one_of_norm_eq_one {x : K} (hxi : IsIntegral ‚Ñ§ x) (hx : ‚àÄ œÜ : K ‚Üí+* A, ‚ÄñœÜ x‚Äñ = 1) :
    ‚àÉ (n : ‚Ñï) (_ : 0 < n), x ^ n = 1 ",":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ ¬∑ : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  wlog hlt : b < a
  ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
  refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
  rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
  refine h.resolve_right fun hp => ?_
  specialize hx (IsAlgClosed.lift (R := ‚Ñö)).toRingHom
  rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx",":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ ((¬∑ ^ ¬∑) x : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  ¬∑ wlog hlt : b < a
    ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
    refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
    dsimp at h 
    rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
    refine h.resolve_right fun hp => ?_
    specialize hx (IsAlgClosed.lift (NumberField.isAlgebraic K)).toRingHom
    rw [pow_eq_zero hp, map_zero, norm_zero] at hx ; norm_num at hx"
Mathlib/Algebra/Homology/ExactSequence.lean,CategoryTheory.ComposableArrows.exact_of_Œ¥‚ÇÄ,exact_of_Œ¥‚ÇÄ,bf2de5cf8765f1de5345ce008a97874d755ff93e,":= by
  rw [exact_iff_Œ¥‚ÇÄ]
  constructor <;> assumption?","error:  unknown tactic
error:  unsolved goals
case left
C : Type u_1
inst‚úù¬π : Category.{u_2, u_1} C
inst‚úù : HasZeroMorphisms C
n : ‚Ñï
S‚úù : ComposableArrows C n
S : ComposableArrows C (n + 2)
h : (mk‚ÇÇ (S.map' 0 1 ‚ãØ ‚ãØ) (S.map' 1 2 ‚ãØ ‚ãØ)).Exact
h‚ÇÄ : S.Œ¥‚ÇÄ.Exact
‚ä¢ (mk‚ÇÇ (S.map' 0 1 ‚ãØ ‚ãØ) (S.map' 1 2 ‚ãØ ‚ãØ)).Exact

case right
C : Type u_1
inst‚úù¬π : Category.{u_2, u_1} C
inst‚úù : HasZeroMorphisms C
n : ‚Ñï
S‚úù : ComposableArrows C n
S : ComposableArrows C (n + 2)
h : (mk‚ÇÇ (S.map' 0 1 ‚ãØ ‚ãØ) (S.map' 1 2 ‚ãØ ‚ãØ)).Exact
h‚ÇÄ : S.Œ¥‚ÇÄ.Exact
‚ä¢ S.Œ¥‚ÇÄ.Exact","lemma exact_of_Œ¥‚ÇÄ {S : ComposableArrows C (n + 2)}
    (h : (mk‚ÇÇ (S.map' 0 1) (S.map' 1 2)).Exact) (h‚ÇÄ : S.Œ¥‚ÇÄ.Exact) : S.Exact ",":= by
  rw [exact_iff_Œ¥‚ÇÄ]
  constructor <;> assumption",":= by
  rw [exact_iff_Œ¥‚ÇÄ]
  constructor <;> assumption"
Mathlib/CategoryTheory/Triangulated/TStructure/Basic.lean,CategoryTheory.Triangulated.TStructure.exists_triangle,exists_triangle,2b12d78cb9d1886702a99fbd79ca892c82374ba5,":= by
  obtain ‚ü®X, Y, hX, hY, f, g, h, mem‚ü© := t.exists_triangle_zero_one (A‚ü¶n‚ÇÄ‚üß)
  let T := (Triangle.shiftFunctor C (-n‚ÇÄ)).obj (Triangle.mk f g h)
  have e := (shiftEquiv C n‚ÇÄ).unitIso.symm.app A
  have hT' : Triangle.mk (T.mor‚ÇÅ ‚â´ e.hom) (e.inv ‚â´ T.mor‚ÇÇ) T.mor‚ÇÉ ‚àà distTriang C := by
    refine' isomorphic_distinguished _ (Triangle.shift_distinguished _ mem (-n‚ÇÄ)) _ _
    refine' Triangle.isoMk _ _ (Iso.refl _) e.symm (Iso.refl _) _ _ _
    all_goals dsimp ; simp [T]
  exact ‚ü®_, _, t.shift_LE _ _ _ (neg_add_self n‚ÇÄ) _ hX,
    t.shift_GE _ _ _ (by linarith) _ hY, _, _, _, hT'‚ü©","error:  invalid field 'shift_LE', the environment does not contain 'CategoryTheory.Triangulated.TStructure.shift_LE'
  t
has type
  TStructure C
error:  invalid field 'shift_GE', the environment does not contain 'CategoryTheory.Triangulated.TStructure.shift_GE'
  t
has type
  TStructure C","lemma exists_triangle (A : C) (n‚ÇÄ n‚ÇÅ : ‚Ñ§) (h : n‚ÇÄ + 1 = n‚ÇÅ) :
    ‚àÉ (X Y : C) (_ : t.LE n‚ÇÄ X) (_ : t.GE n‚ÇÅ Y) (f : X ‚ü∂ A) (g : A ‚ü∂ Y)
      (h : Y ‚ü∂ X‚ü¶(1 : ‚Ñ§)‚üß), Triangle.mk f g h ‚àà distTriang C ",":= by
  obtain ‚ü®X, Y, hX, hY, f, g, h, mem‚ü© := t.exists_triangle_zero_one (A‚ü¶n‚ÇÄ‚üß)
  let T := (Triangle.shiftFunctor C (-n‚ÇÄ)).obj (Triangle.mk f g h)
  let e := (shiftEquiv C n‚ÇÄ).unitIso.symm.app A
  have hT' : Triangle.mk (T.mor‚ÇÅ ‚â´ e.hom) (e.inv ‚â´ T.mor‚ÇÇ) T.mor‚ÇÉ ‚àà distTriang C := by
    refine isomorphic_distinguished _ (Triangle.shift_distinguished _ mem (-n‚ÇÄ)) _ ?_
    refine Triangle.isoMk _ _ (Iso.refl _) e.symm (Iso.refl _) ?_ ?_ ?_
    all_goals dsimp; simp [T]
  exact ‚ü®_, _, t.LE_shift _ _ _ (neg_add_self n‚ÇÄ) _ hX,
    t.GE_shift _ _ _ (by omega) _ hY, _, _, _, hT'‚ü©",":= by
  obtain ‚ü®X, Y, hX, hY, f, g, h, mem‚ü© := t.exists_triangle_zero_one (A‚ü¶n‚ÇÄ‚üß)
  let T := (Triangle.shiftFunctor C (-n‚ÇÄ)).obj (Triangle.mk f g h)
  have e := (shiftEquiv C n‚ÇÄ).unitIso.symm.app A
  have hT' : Triangle.mk (T.mor‚ÇÅ ‚â´ e.hom) (e.inv ‚â´ T.mor‚ÇÇ) T.mor‚ÇÉ ‚àà distTriang C := by
    refine isomorphic_distinguished _ (Triangle.shift_distinguished _ mem (-n‚ÇÄ)) ?_ ?_
    refine Triangle.isoMk _ _ (Iso.refl _) e.symm (Iso.refl _) ?_ ?_ ?_
    all_goals dsimp ; simp [T]
  exact ‚ü®_, _, t.shift_LE _ _ _ (neg_add_self n‚ÇÄ) _ hX,
    t.shift_GE _ _ _ (by linarith) _ hY, _, _, _, hT'‚ü©"
Mathlib/NumberTheory/SumTwoSquares.lean,ZMod.isSquare_neg_one_iff,ZMod.isSquare_neg_one_iff,40b58304ad9cb6913d2d4e97172b2c306fdb61f2,":= by
  refine' ‚ü®fun H q hqp hqd => hqp.mod_four_ne_three_of_dvd_isSquare_neg_one hqd H, fun H => _‚ü©
  induction' n using induction_on_primes with p n hpp ih
  ¬∑ exact False.elim (hn.ne_zero rfl)
  ¬∑ exact ‚ü®0, by simp only [Fin.zero_mul, neg_eq_zero, Fin.one_eq_zero_iff]‚ü©
  ¬∑ haveI : Fact p.Prime := ‚ü®hpp‚ü©
    have hcp : p.coprime n := by
      by_contra hc
      exact hpp.not_unit (hn p <| mul_dvd_mul_left p <| hpp.dvd_iff_not_coprime.mpr hc)
    have hp‚ÇÅ := ZMod.exists_sq_eq_neg_one_iff.mpr (H hpp (dvd_mul_right p n))
    exact ZMod.isSquare_neg_one_mul hcp hp‚ÇÅ
      (ih hn.of_mul_right fun hqp hqd => H hqp <| dvd_mul_of_dvd_right hqd _)","error:  simp made no progress
error:  invalid field 'coprime', the environment does not contain 'Nat.coprime'
  p
has type
  ‚Ñï","theorem ZMod.isSquare_neg_one_iff {n : ‚Ñï} (hn : Squarefree n) :
    IsSquare (-1 : ZMod n) ‚Üî ‚àÄ {q : ‚Ñï}, q.Prime ‚Üí q ‚à£ n ‚Üí q % 4 ‚â† 3 ",":= by
  refine ‚ü®fun H q hqp hqd => hqp.mod_four_ne_three_of_dvd_isSquare_neg_one hqd H, fun H => ?_‚ü©
  induction' n using induction_on_primes with p n hpp ih
  ¬∑ exact False.elim (hn.ne_zero rfl)
  ¬∑ exact ‚ü®0, by simp only [mul_zero, eq_iff_true_of_subsingleton]‚ü©
  ¬∑ haveI : Fact p.Prime := ‚ü®hpp‚ü©
    have hcp : p.Coprime n := by
      by_contra hc
      exact hpp.not_unit (hn p <| mul_dvd_mul_left p <| hpp.dvd_iff_not_coprime.mpr hc)
    have hp‚ÇÅ := ZMod.exists_sq_eq_neg_one_iff.mpr (H hpp (dvd_mul_right p n))
    exact ZMod.isSquare_neg_one_mul hcp hp‚ÇÅ
      (ih hn.of_mul_right fun hqp hqd => H hqp <| dvd_mul_of_dvd_right hqd _)",":= by
  refine ‚ü®fun H q hqp hqd => hqp.mod_four_ne_three_of_dvd_isSquare_neg_one hqd H, fun H => ?_‚ü©
  induction' n using induction_on_primes with p n hpp ih
  ¬∑ exact False.elim (hn.ne_zero rfl)
  ¬∑ exact ‚ü®0, by simp only [Fin.zero_mul, neg_eq_zero, Fin.one_eq_zero_iff]‚ü©
  ¬∑ haveI : Fact p.Prime := ‚ü®hpp‚ü©
    have hcp : p.coprime n := by
      by_contra hc
      exact hpp.not_unit (hn p <| mul_dvd_mul_left p <| hpp.dvd_iff_not_coprime.mpr hc)
    have hp‚ÇÅ := ZMod.exists_sq_eq_neg_one_iff.mpr (H hpp (dvd_mul_right p n))
    exact ZMod.isSquare_neg_one_mul hcp hp‚ÇÅ
      (ih hn.of_mul_right fun hqp hqd => H hqp <| dvd_mul_of_dvd_right hqd _)"
Mathlib/Analysis/Convolution.lean,MeasureTheory.hasFDerivAt_convolution_right_with_param,hasFDerivAt_convolution_right_with_param,98e78f90ec6f93268c84b413fdae7dce5cbee0e6,":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine' (hasFDerivAt_zero_of_eventually_const 0 _).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_open (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s
      ¬∑ exact Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine' ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, _, _‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C; exact ht.subset_closedBall_lt 0 0
    refine' ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => _‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine' mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), _, _‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine' (HasCompactSupport.convolutionExists_right L _ hf (A _ hp) _).1
    apply isCompact_of_isClosed_subset hk (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_open (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº
  exact hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine' ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, _‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    apply eventually_of_forall
    intro a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    apply eventually_of_forall
    intro a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, id.def, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6","error:  invalid field 'continuousOn_fderiv_of_open', the environment does not contain 'ContDiffOn.continuousOn_fderiv_of_open'
  hg
has type
  ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hg
has type
  ‚àÄ x ‚àà s √óÀ¢ univ, ContDiffWithinAt ùïú 1 (‚Üøg) (s √óÀ¢ univ) x
error:  unknown identifier 'isCompact_of_isClosed_subset'
error:  invalid field 'continuousOn_fderiv_of_open', the environment does not contain 'ContDiffOn.continuousOn_fderiv_of_open'
  hg
has type
  ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hg
has type
  ‚àÄ x ‚àà s √óÀ¢ univ, ContDiffWithinAt ùïú 1 (‚Üøg) (s √óÀ¢ univ) x
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1585025 ‚Üí ?m.1585025
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1585320 ‚Üí ?m.1585320
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  unsolved goals
case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.1 = (_root_.id x).1

case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.2 - a = (_root_.id x).2 - a","theorem hasFDerivAt_convolution_right_with_param {g : P ‚Üí G ‚Üí E'} {s : Set P} {k : Set G}
    (hs : IsOpen s) (hk : IsCompact k) (hgs : ‚àÄ p, ‚àÄ x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0)
    (hf : LocallyIntegrable f Œº) (hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)) (q‚ÇÄ : P √ó G)
    (hq‚ÇÄ : q‚ÇÄ.1 ‚àà s) :
    HasFDerivAt (fun q : P √ó G => (f ‚ãÜ[L, Œº] g q.1) q.2)
      ((f ‚ãÜ[L.precompR (P √ó G), Œº] fun x : G => fderiv ùïú (‚Üøg) (q‚ÇÄ.1, x)) q‚ÇÄ.2) q‚ÇÄ ",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s := Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C := ht.subset_closedBall_lt 0 0
    refine ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => ?_‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), ?_, ?_‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine (HasCompactSupport.convolutionExists_right L ?_ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº :=
    hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, ?_‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    filter_upwards with a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    filter_upwards with a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, _root_.id, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_open (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s
      ¬∑ exact Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le"
Mathlib/FieldTheory/SeparableDegree.lean,minpoly.natSepDegree_eq_one_iff_pow_mem,natSepDegree_eq_one_iff_pow_mem,76620f7bc93be67fe98a87948024801e42a6f815,":= by
  convert_to _ ‚Üî ‚àÉ (n : ‚Ñï) (y : F), Polynomial.aeval x (X ^ q ^ n - C y) = 0
  ¬∑ simp_rw [RingHom.mem_range, map_sub, map_pow, aeval_C, aeval_X, sub_eq_zero, eq_comm]
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®n, y, h‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ obtain ‚ü®n, y, hx‚ü© := (minpoly.natSepDegree_eq_one_iff_eq_X_pow_sub_C q).1 h
    exact ‚ü®n, y, hx ‚ñ∏ aeval F x‚ü©
  have hnezero := X_pow_sub_C_ne_zero (expChar_pow_pos F q n) y
  refine ((natSepDegree_le_of_dvd _ _ (minpoly.dvd F x h) hnezero).trans_eq <|
    natSepDegree_X_pow_char_sub_C q n y).antisymm ?_
  rw [Nat.one_le_iff_ne_zero, natSepDegree_ne_zero_iff, ‚Üê Nat.one_le_iff_ne_zero]
  exact minpoly.natDegree_pos <| IsAlgebraic.isIntegral ‚ü®_, hnezero, h‚ü©",error:  unknown identifier 'natSepDegree_X_pow_char_sub_C',"theorem natSepDegree_eq_one_iff_pow_mem : (minpoly F x).natSepDegree = 1 ‚Üî
    ‚àÉ n : ‚Ñï, x ^ q ^ n ‚àà (algebraMap F E).range ",":= by
  convert_to _ ‚Üî ‚àÉ (n : ‚Ñï) (y : F), Polynomial.aeval x (X ^ q ^ n - C y) = 0
  ¬∑ simp_rw [RingHom.mem_range, map_sub, map_pow, aeval_C, aeval_X, sub_eq_zero, eq_comm]
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®n, y, h‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ obtain ‚ü®n, y, hx‚ü© := (minpoly.natSepDegree_eq_one_iff_eq_X_pow_sub_C q).1 h
    exact ‚ü®n, y, hx ‚ñ∏ aeval F x‚ü©
  have hnezero := X_pow_sub_C_ne_zero (expChar_pow_pos F q n) y
  refine ((natSepDegree_le_of_dvd _ _ (minpoly.dvd F x h) hnezero).trans_eq <|
    natSepDegree_X_pow_char_pow_sub_C q n y).antisymm ?_
  rw [Nat.one_le_iff_ne_zero, natSepDegree_ne_zero_iff, ‚Üê Nat.one_le_iff_ne_zero]
  exact minpoly.natDegree_pos <| IsAlgebraic.isIntegral ‚ü®_, hnezero, h‚ü©",":= by
  convert_to _ ‚Üî ‚àÉ (n : ‚Ñï) (y : F), Polynomial.aeval x (X ^ q ^ n - C y) = 0
  ¬∑ simp_rw [RingHom.mem_range, map_sub, map_pow, aeval_C, aeval_X, sub_eq_zero, eq_comm]
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®n, y, h‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ obtain ‚ü®n, y, hx‚ü© := (minpoly.natSepDegree_eq_one_iff_eq_X_pow_sub_C q).1 h
    exact ‚ü®n, y, hx ‚ñ∏ aeval F x‚ü©
  have hnezero := X_pow_sub_C_ne_zero (expChar_pow_pos F q n) y
  refine ((natSepDegree_le_of_dvd _ _ (minpoly.dvd F x h) hnezero).trans_eq <|
    natSepDegree_X_pow_char_sub_C q n y).antisymm ?_
  rw [Nat.one_le_iff_ne_zero, natSepDegree_ne_zero_iff, ‚Üê Nat.one_le_iff_ne_zero]
  exact minpoly.natDegree_pos <| IsAlgebraic.isIntegral ‚ü®_, hnezero, h‚ü©"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,aestronglyMeasurable_of_tendsto_ae,_root_.aestronglyMeasurable_of_tendsto_ae,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  borelize Œ≤
  refine' aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®_, _‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà Œº.ae := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ‚ü®closure (‚ãÉ i, t i), .closure <| .iUnion t_sep, ?_‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)","error:  invalid field 'ae', the environment does not contain 'MeasureTheory.Measure.ae'
  Œº
has type
  Measure Œ±","theorem _root_.aestronglyMeasurable_of_tendsto_ae {Œπ : Type*} [PseudoMetrizableSpace Œ≤]
    (u : Filter Œπ) [NeBot u] [IsCountablyGenerated u] {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}
    (hf : ‚àÄ i, AEStronglyMeasurable (f i) Œº) (lim : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) u (ùìù (g x))) :
    AEStronglyMeasurable g Œº ",":= by
  borelize Œ≤
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®?_, ?_‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà ae Œº := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ‚ü®closure (‚ãÉ i, t i), .closure <| .iUnion t_sep, ?_‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)",":= by
  borelize Œ≤
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®?_, ?_‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà Œº.ae := fun n =>
      (aestronglyMeasurable_iff_aemeasurable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ‚ü®closure (‚ãÉ i, t i), .closure <| .iUnion t_sep, ?_‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)"
Mathlib/Analysis/SpecialFunctions/Stirling.lean,Stirling.stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq,stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq,277dea952df34759a39b00abcc615238ae32c506,":= by
  have : 4 = 2 * 2 := by rfl
  rw [stirlingSeq, this, pow_mul, stirlingSeq, Wallis.W_eq_factorial_ratio]
  simp_rw [div_pow, mul_pow]
  rw [sq_sqrt, sq_sqrt]
  any_goals positivity
  have : (n : ‚Ñù) ‚â† 0 := cast_ne_zero.mpr hn
  have : exp 1 ‚â† 0 := exp_ne_zero 1
  have : ((2 * n)! : ‚Ñù) ‚â† 0 := cast_ne_zero.mpr (factorial_ne_zero (2 * n))
  have : 2 * (n : ‚Ñù) + 1 ‚â† 0 := by norm_cast; exact succ_ne_zero (2 * n)
  field_simp
  simp only [mul_pow, mul_comm 2 n, mul_comm 4 n, pow_mul]
  ring","error:  no goals to be solved
info:  Try this: ring_nf
error:  unsolved goals
n : ‚Ñï
hn : n ‚â† 0
this‚úù¬≥ : 4 = 2 * 2
this‚úù¬≤ : ‚Üën ‚â† 0
this‚úù¬π : rexp 1 ‚â† 0
this‚úù : ‚Üë(2 * n)! ‚â† 0
this : 2 * ‚Üën + 1 ‚â† 0
‚ä¢ ‚Üën ! ^ 4 * rexp ‚Üën ^ 4 * ‚Üën ^ 2 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * 2 ^ (n * 4) * 4 +
      ‚Üën ! ^ 4 * rexp ‚Üën ^ 4 * ‚Üën ^ 3 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * 2 ^ (n * 4) * 8 =
    ‚Üën ! ^ 4 * ‚Üën ^ 2 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * rexp (‚Üën * 2) ^ 2 * 2 ^ (n * 4) * 4 +
      ‚Üën ! ^ 4 * ‚Üën ^ 3 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * rexp (‚Üën * 2) ^ 2 * 2 ^ (n * 4) * 8","theorem stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq (n : ‚Ñï) (hn : n ‚â† 0) :
    stirlingSeq n ^ 4 / stirlingSeq (2 * n) ^ 2 * (n / (2 * n + 1)) = Wallis.W n ",":= by
  have : 4 = 2 * 2 := by rfl
  rw [stirlingSeq, this, pow_mul, stirlingSeq, Wallis.W_eq_factorial_ratio]
  simp_rw [div_pow, mul_pow]
  rw [sq_sqrt, sq_sqrt]
  any_goals positivity
  field_simp [‚Üê exp_nsmul]
  ring_nf",":= by
  have : 4 = 2 * 2 := by rfl
  rw [stirlingSeq, this, pow_mul, stirlingSeq, Wallis.W_eq_factorial_ratio]
  simp_rw [div_pow, mul_pow]
  rw [sq_sqrt, sq_sqrt]
  any_goals positivity
  have : (n : ‚Ñù) ‚â† 0 := cast_ne_zero.mpr hn
  have : exp 1 ‚â† 0 := exp_ne_zero 1
  have : ((2 * n)! : ‚Ñù) ‚â† 0 := cast_ne_zero.mpr (factorial_ne_zero (2 * n))
  have : 2 * (n : ‚Ñù) + 1 ‚â† 0 := by norm_cast; exact succ_ne_zero (2 * n)
  field_simp
  simp only [mul_pow, mul_comm 2 n, mul_comm 4 n, pow_mul]"
Mathlib/Algebra/Homology/QuasiIso.lean,quasiIso_of_comp_left,quasiIso_of_comp_left,4773ba7abb162ea632c1ff5810cd5f45a1289422,  quasiIso n := quasiIsoAt_of_comp_left œÜ œÜ' n,"error:  function expected at
  QuasiIso œÜ'
term has type
  Prop
error:  unknown identifier 'n'","lemma quasiIso_of_comp_left (œÜ : K ‚ü∂ L) (œÜ' : L ‚ü∂ M) [‚àÄ i, K.HasHomology i]
    [‚àÄ i, L.HasHomology i] [‚àÄ i, M.HasHomology i]
    [hœÜ : QuasiIso œÜ] [hœÜœÜ' : QuasiIso (œÜ ‚â´ œÜ')] :
    QuasiIso œÜ' ",":= by
  rw [‚Üê quasiIso_iff_comp_left œÜ œÜ']
  infer_instance",:= quasiIsoAt_of_comp_left
Mathlib/Geometry/Euclidean/Angle/Sphere.lean,EuclideanGeometry.Cospherical.two_zsmul_oangle_eq,Cospherical.two_zsmul_oangle_eq,51a5ef1cda5da86f2874f1cacc8625b3ebd1a370,":= by
  obtain ‚ü®s, hs‚ü© := cospherical_iff_exists_sphere.1 h
  simp_rw [Set.insert_subset, Set.singleton_subset_iff, Sphere.mem_coe] at hs
  exact Sphere.two_zsmul_oangle_eq hs.1 hs.2.1 hs.2.2.1 hs.2.2.2 hp‚ÇÇp‚ÇÅ hp‚ÇÇp‚ÇÑ hp‚ÇÉp‚ÇÅ hp‚ÇÉp‚ÇÑ",error:  simp made no progress,"theorem Cospherical.two_zsmul_oangle_eq {p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P}
    (h : Cospherical ({p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P)) (hp‚ÇÇp‚ÇÅ : p‚ÇÇ ‚â† p‚ÇÅ) (hp‚ÇÇp‚ÇÑ : p‚ÇÇ ‚â† p‚ÇÑ)
    (hp‚ÇÉp‚ÇÅ : p‚ÇÉ ‚â† p‚ÇÅ) (hp‚ÇÉp‚ÇÑ : p‚ÇÉ ‚â† p‚ÇÑ) : (2 : ‚Ñ§) ‚Ä¢ ‚à° p‚ÇÅ p‚ÇÇ p‚ÇÑ = (2 : ‚Ñ§) ‚Ä¢ ‚à° p‚ÇÅ p‚ÇÉ p‚ÇÑ ",":= by
  obtain ‚ü®s, hs‚ü© := cospherical_iff_exists_sphere.1 h
  simp_rw [Set.insert_subset_iff, Set.singleton_subset_iff, Sphere.mem_coe] at hs
  exact Sphere.two_zsmul_oangle_eq hs.1 hs.2.1 hs.2.2.1 hs.2.2.2 hp‚ÇÇp‚ÇÅ hp‚ÇÇp‚ÇÑ hp‚ÇÉp‚ÇÅ hp‚ÇÉp‚ÇÑ",":= by
  obtain ‚ü®s, hs‚ü© := cospherical_iff_exists_sphere.1 h
  simp_rw [Set.insert_subset, Set.singleton_subset_iff, Sphere.mem_coe] at hs
  exact Sphere.two_zsmul_oangle_eq hs.1 hs.2.1 hs.2.2.1 hs.2.2.2 hp‚ÇÇp‚ÇÅ hp‚ÇÇp‚ÇÑ hp‚ÇÉp‚ÇÑ"
Mathlib/CategoryTheory/Localization/Predicate.lean,CategoryTheory.Functor.IsLocalization.of_iso,of_iso,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have h := Localization.inverts L‚ÇÅ W
  rw [MorphismProperty.IsInvertedBy.iff_of_iso W e] at h
  let F‚ÇÅ := Localization.Construction.lift L‚ÇÅ (Localization.inverts L‚ÇÅ W)
  let F‚ÇÇ := Localization.Construction.lift L‚ÇÇ h
  exact
    { inverts := h
      nonempty_isEquivalence :=
        Nonempty.intro (IsEquivalence.ofIso (liftNatIso W.Q W L‚ÇÅ L‚ÇÇ F‚ÇÅ F‚ÇÇ e) inferInstance) }",error:  'nonempty_isEquivalence' is not a field of structure 'CategoryTheory.Functor.IsLocalization',theorem of_iso {L‚ÇÅ L‚ÇÇ : C ‚•§ D} (e : L‚ÇÅ ‚âÖ L‚ÇÇ) [L‚ÇÅ.IsLocalization W] : L‚ÇÇ.IsLocalization W ,":= by
  have h := Localization.inverts L‚ÇÅ W
  rw [MorphismProperty.IsInvertedBy.iff_of_iso W e] at h
  let F‚ÇÅ := Localization.Construction.lift L‚ÇÅ (Localization.inverts L‚ÇÅ W)
  let F‚ÇÇ := Localization.Construction.lift L‚ÇÇ h
  exact
    { inverts := h
      isEquivalence := Functor.isEquivalence_of_iso (liftNatIso W.Q W L‚ÇÅ L‚ÇÇ F‚ÇÅ F‚ÇÇ e) }",":= by
  have h := Localization.inverts L‚ÇÅ W
  rw [MorphismProperty.IsInvertedBy.iff_of_iso W e] at h
  let F‚ÇÅ := Localization.Construction.lift L‚ÇÅ (Localization.inverts L‚ÇÅ W)
  let F‚ÇÇ := Localization.Construction.lift L‚ÇÇ h
  exact
    { inverts := h
      nonempty_isEquivalence :=
        Nonempty.intro (IsEquivalence.ofIso (liftNatIso W.Q W L‚ÇÅ L‚ÇÇ F‚ÇÅ F‚ÇÇ e) inferInstance) }"
Mathlib/Data/Set/Finite.lean,Directed.exists_mem_subset_of_finset_subset_biUnion,Directed.exists_mem_subset_of_finset_subset_biUnion,22e37aafc149169745794a3927e2697dd02700d2,":= by
  induction s using Finset.cons_induction with
  | empty => simp
  | cons hbt iht =>
    simp only [Finset.coe_cons, Set.insert_subset_iff, Set.mem_iUnion] at hs ‚ä¢
    rcases hs.imp_right iht with ‚ü®‚ü®i, hi‚ü©, j, hj‚ü©
    rcases h i j with ‚ü®k, hik, hjk‚ü©
    exact ‚ü®k, hik hi, hj.trans hjk‚ü©","error:  application type mismatch
  And.imp_right iht
argument
  iht
has type
  Finset Œ± : Type u_1
but is expected to have type
  ?m.201986 ‚Üí ?m.201987 : Prop
error:  rcases tactic failed: right‚úù : ?m.201987 is not an inductive datatype","lemma Directed.exists_mem_subset_of_finset_subset_biUnion {Œ± Œπ : Type*} [Nonempty Œπ]
    {f : Œπ ‚Üí Set Œ±} (h : Directed (¬∑ ‚äÜ ¬∑) f) {s : Finset Œ±} (hs : (s : Set Œ±) ‚äÜ ‚ãÉ i, f i) :
    ‚àÉ i, (s : Set Œ±) ‚äÜ f i ",":= by
  induction s using Finset.cons_induction with
  | empty => simp
  | cons b t hbt iht =>
    simp only [Finset.coe_cons, Set.insert_subset_iff, Set.mem_iUnion] at hs ‚ä¢
    rcases hs.imp_right iht with ‚ü®‚ü®i, hi‚ü©, j, hj‚ü©
    rcases h i j with ‚ü®k, hik, hjk‚ü©
    exact ‚ü®k, hik hi, hj.trans hjk‚ü©",":= by
  induction s using Finset.cons_induction with
  | empty => simp
  | cons hbt iht =>
    simp only [Finset.coe_cons, Set.insert_subset_iff, Set.mem_iUnion] at hs ‚ä¢
    rcases hs.imp_right iht with ‚ü®‚ü®i, hi‚ü©, j, hj‚ü©
    rcases h i j with ‚ü®k, hik, hjk‚ü©
    exact ‚ü®k, hik hi, hj.trans hjk‚ü©"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,df1f699fcf985d4906f4984a974c473b3bf5d238,":= by
  refine' ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, _‚ü©, rfl‚ü©, _‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := isIntegral_sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_x_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)","error:  function expected at
  le_integralClosure_iff_isIntegral.mp (adjoin_le_integralClosure (IsPrimitiveRoot.isIntegral hŒ∂ (PNat.pos (p ^ k))))
term has type
  Algebra.IsIntegral ‚Ñ§ ‚Ü•(adjoin ‚Ñ§ {Œ∂})
error:  unknown identifier 'isIntegral_sub'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë(?m ^ ?n)
case refine'_1.intro.intro
p : ‚Ñï+
k : ‚Ñï
K : Type u
inst‚úù¬π : Field K
inst‚úù : CharZero K
Œ∂ : K
hp : Fact (Nat.Prime ‚Üëp)
hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)
x : K
h : IsIntegral ‚Ñ§ x
B : PowerBasis ‚Ñö K := IsPrimitiveRoot.subOnePowerBasis ‚Ñö hŒ∂
hint : IsIntegral ‚Ñ§ B.gen
this : FiniteDimensional ‚Ñö K := finiteDimensional {p ^ k} ‚Ñö K
u : ‚Ñ§À£
n : ‚Ñï
hun : Algebra.discr ‚Ñö ‚áë(IsPrimitiveRoot.subOnePowerBasis ‚Ñö hŒ∂).basis = ‚Üë‚Üëu * ‚Üë‚Üëp ^ n
H : ‚Üë‚Üëp ^ n ‚Ä¢ x ‚àà adjoin ‚Ñ§ {B.gen}
‚ä¢ x ‚àà adjoin ‚Ñ§ {Œ∂}","theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)) : IsIntegralClosure (adjoin ‚Ñ§ ({Œ∂} : Set K)) ‚Ñ§ K ",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := isIntegral_sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_x_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_singleton _)"
Mathlib/RingTheory/Finiteness.lean,Submodule.fg_of_fg_map_of_fg_inf_ker,fg_of_fg_map_of_fg_inf_ker,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  haveI := Classical.decEq R
  haveI := Classical.decEq M
  haveI := Classical.decEq P
  cases' hs1 with t1 ht1
  cases' hs2 with t2 ht2
  have : ‚àÄ y ‚àà t1, ‚àÉ x ‚àà s, f x = y := by
    intro y hy
    have : y ‚àà s.map f := by
      rw [‚Üê ht1]
      exact subset_span hy
    rcases mem_map.1 this with ‚ü®x, hx1, hx2‚ü©
    exact ‚ü®x, hx1, hx2‚ü©
  have : ‚àÉ g : P ‚Üí M, ‚àÄ y ‚àà t1, g y ‚àà s ‚àß f (g y) = y := by
    choose g hg1 hg2 using this
    exists fun y => if H : y ‚àà t1 then g y H else 0
    intro y H
    constructor
    ¬∑ simp only [dif_pos H]
      apply hg1
    ¬∑ simp only [dif_pos H]
      apply hg2
  cases' this with g hg
  clear this
  exists t1.image g ‚à™ t2
  rw [Finset.coe_union, span_union, Finset.coe_image]
  apply le_antisymm
  ¬∑ refine sup_le (span_le.2 <| image_subset_iff.2 ?_) (span_le.2? _)
    ¬∑ intro y hy
      exact (hg y hy).1
    ¬∑ intro x hx
      have : x ‚àà span R t2 := subset_span hx
      rw [ht2] at this
      exact this.1
  intro x hx
  have : f x ‚àà s.map f := by
    rw [mem_map]
    exact ‚ü®x, hx, rfl‚ü©
  rw [‚Üê ht1, ‚Üê Set.image_id (t1 : Set P), Finsupp.mem_span_image_iff_total] at this
  rcases this with ‚ü®l, hl1, hl2‚ü©
  refine
    mem_sup.2
      ‚ü®(Finsupp.total M M R id).toFun ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), ?_,
        x - Finsupp.total M M R id ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), ?_,
        add_sub_cancel _ _‚ü©
  ¬∑ rw [‚Üê Set.image_id (g '' ‚Üët1), Finsupp.mem_span_image_iff_total]
    refine ‚ü®_, ?_, rfl‚ü©
    haveI : Inhabited P := ‚ü®0‚ü©
    rw [‚Üê Finsupp.lmapDomain_supported _ _ g, mem_map]
    refine ‚ü®l, hl1, ?_‚ü©
    rfl
  rw [ht2, mem_inf]
  constructor
  ¬∑ apply s.sub_mem hx
    rw [Finsupp.total_apply, Finsupp.lmapDomain_apply, Finsupp.sum_mapDomain_index]
    ¬∑ refine s.sum_mem ?_
      intro y hy
      exact s.smul_mem _ (hg y (hl1 hy)).1
    ¬∑ exact zero_smul _
    ¬∑ exact fun _ _ _ => add_smul _ _ _
  ¬∑ rw [LinearMap.mem_ker, f.map_sub, ‚Üê hl2]
    rw [Finsupp.total_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply]
    rw [Finsupp.sum_mapDomain_index, Finsupp.sum, Finsupp.sum, map_sum]
    ¬∑ rw [sub_eq_zero]
      refine Finset.sum_congr rfl fun y hy => ?_
      unfold id
      rw [f.map_smul, (hg y (hl1 hy)).2]
    ¬∑ exact zero_smul _
    ¬∑ exact fun _ _ _ => add_smul _ _ _","error:  unexpected token '?'; expected ')', ',' or ':'
error:  unsolved goals
case intro.intro.intro.a
R‚úù : Type u_1
M‚úù : Type u_2
inst‚úù‚Åπ : Semiring R‚úù
inst‚úù‚Å∏ : AddCommMonoid M‚úù
inst‚úù‚Å∑ : Module R‚úù M‚úù
P‚úù : Type u_3
inst‚úù‚Å∂ : AddCommMonoid P‚úù
inst‚úù‚Åµ : Module R‚úù P‚úù
f‚úù : M‚úù ‚Üí‚Çó[R‚úù] P‚úù
R : Type u_4
M : Type u_5
P : Type u_6
inst‚úù‚Å¥ : Ring R
inst‚úù¬≥ : AddCommGroup M
inst‚úù¬≤ : Module R M
inst‚úù¬π : AddCommGroup P
inst‚úù : Module R P
f : M ‚Üí‚Çó[R] P
s : Submodule R M
this‚úù¬π : DecidableEq R
this‚úù : DecidableEq M
this : DecidableEq P
t1 : Finset P
ht1 : span R ‚Üët1 = map f s
t2 : Finset M
ht2 : span R ‚Üët2 = s ‚äì LinearMap.ker f
g : P ‚Üí M
hg : ‚àÄ y ‚àà t1, g y ‚àà s ‚àß f (g y) = y
‚ä¢ s ‚â§ span R (g '' ‚Üët1) ‚äî span R ‚Üët2
warning:  Module.Finite does not have a doc string","theorem fg_of_fg_map_of_fg_inf_ker {R M P : Type*} [Ring R] [AddCommGroup M] [Module R M]
    [AddCommGroup P] [Module R P] (f : M ‚Üí‚Çó[R] P) {s : Submodule R M}
    (hs1 : (s.map f).FG)
    (hs2 : (s ‚äì LinearMap.ker f).FG) : s.FG ",":= by
  haveI := Classical.decEq R
  haveI := Classical.decEq M
  haveI := Classical.decEq P
  cases' hs1 with t1 ht1
  cases' hs2 with t2 ht2
  have : ‚àÄ y ‚àà t1, ‚àÉ x ‚àà s, f x = y := by
    intro y hy
    have : y ‚àà s.map f := by
      rw [‚Üê ht1]
      exact subset_span hy
    rcases mem_map.1 this with ‚ü®x, hx1, hx2‚ü©
    exact ‚ü®x, hx1, hx2‚ü©
  have : ‚àÉ g : P ‚Üí M, ‚àÄ y ‚àà t1, g y ‚àà s ‚àß f (g y) = y := by
    choose g hg1 hg2 using this
    exists fun y => if H : y ‚àà t1 then g y H else 0
    intro y H
    constructor
    ¬∑ simp only [dif_pos H]
      apply hg1
    ¬∑ simp only [dif_pos H]
      apply hg2
  cases' this with g hg
  clear this
  exists t1.image g ‚à™ t2
  rw [Finset.coe_union, span_union, Finset.coe_image]
  apply le_antisymm
  ¬∑ refine sup_le (span_le.2 <| image_subset_iff.2 ?_) (span_le.2 ?_)
    ¬∑ intro y hy
      exact (hg y hy).1
    ¬∑ intro x hx
      have : x ‚àà span R t2 := subset_span hx
      rw [ht2] at this
      exact this.1
  intro x hx
  have : f x ‚àà s.map f := by
    rw [mem_map]
    exact ‚ü®x, hx, rfl‚ü©
  rw [‚Üê ht1, ‚Üê Set.image_id (t1 : Set P), Finsupp.mem_span_image_iff_total] at this
  rcases this with ‚ü®l, hl1, hl2‚ü©
  refine
    mem_sup.2
      ‚ü®(Finsupp.total M M R id).toFun ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), ?_,
        x - Finsupp.total M M R id ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), ?_,
        add_sub_cancel _ _‚ü©
  ¬∑ rw [‚Üê Set.image_id (g '' ‚Üët1), Finsupp.mem_span_image_iff_total]
    refine ‚ü®_, ?_, rfl‚ü©
    haveI : Inhabited P := ‚ü®0‚ü©
    rw [‚Üê Finsupp.lmapDomain_supported _ _ g, mem_map]
    refine ‚ü®l, hl1, ?_‚ü©
    rfl
  rw [ht2, mem_inf]
  constructor
  ¬∑ apply s.sub_mem hx
    rw [Finsupp.total_apply, Finsupp.lmapDomain_apply, Finsupp.sum_mapDomain_index]
    ¬∑ refine s.sum_mem ?_
      intro y hy
      exact s.smul_mem _ (hg y (hl1 hy)).1
    ¬∑ exact zero_smul _
    ¬∑ exact fun _ _ _ => add_smul _ _ _
  ¬∑ rw [LinearMap.mem_ker, f.map_sub, ‚Üê hl2]
    rw [Finsupp.total_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply]
    rw [Finsupp.sum_mapDomain_index, Finsupp.sum, Finsupp.sum, map_sum]
    ¬∑ rw [sub_eq_zero]
      refine Finset.sum_congr rfl fun y hy => ?_
      unfold id
      rw [f.map_smul, (hg y (hl1 hy)).2]
    ¬∑ exact zero_smul _
    ¬∑ exact fun _ _ _ => add_smul _ _ _",":= by
  haveI := Classical.decEq R
  haveI := Classical.decEq M
  haveI := Classical.decEq P
  cases' hs1 with t1 ht1
  cases' hs2 with t2 ht2
  have : ‚àÄ y ‚àà t1, ‚àÉ x ‚àà s, f x = y := by
    intro y hy
    have : y ‚àà s.map f := by
      rw [‚Üê ht1]
      exact subset_span hy
    rcases mem_map.1 this with ‚ü®x, hx1, hx2‚ü©
    exact ‚ü®x, hx1, hx2‚ü©
  have : ‚àÉ g : P ‚Üí M, ‚àÄ y ‚àà t1, g y ‚àà s ‚àß f (g y) = y := by
    choose g hg1 hg2 using this
    exists fun y => if H : y ‚àà t1 then g y H else 0
    intro y H
    constructor
    ¬∑ simp only [dif_pos H]
      apply hg1
    ¬∑ simp only [dif_pos H]
      apply hg2
  cases' this with g hg
  clear this
  exists t1.image g ‚à™ t2
  rw [Finset.coe_union, span_union, Finset.coe_image]
  apply le_antisymm
  ¬∑ refine sup_le (span_le.2 <| image_subset_iff.2 ?_) (span_le.2 ?_)
    ¬∑ intro y hy
      exact (hg y hy).1
    ¬∑ intro x hx
      have : x ‚àà span R t2 := subset_span hx
      rw [ht2] at this
      exact this.1
  intro x hx
  have : f x ‚àà s.map f := by
    rw [mem_map]
    exact ‚ü®x, hx, rfl‚ü©
  rw [‚Üê ht1, ‚Üê Set.image_id (t1 : Set P), Finsupp.mem_span_image_iff_total] at this
  rcases this with ‚ü®l, hl1, hl2‚ü©
  refine
    mem_sup.2
      ‚ü®(Finsupp.total M M R id).toFun ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), ?_,
        x - Finsupp.total M M R id ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), ?_,
        add_sub_cancel _ _‚ü©
  ¬∑ rw [‚Üê Set.image_id (g '' ‚Üët1), Finsupp.mem_span_image_iff_total]
    refine ‚ü®_, ?_, rfl‚ü©
    haveI : Inhabited P := ‚ü®0‚ü©
    rw [‚Üê Finsupp.lmapDomain_supported _ _ g, mem_map]
    refine ‚ü®l, hl1, ?_‚ü©
    rfl
  rw [ht2, mem_inf]
  constructor
  ¬∑ apply s.sub_mem hx
    rw [Finsupp.total_apply, Finsupp.lmapDomain_apply, Finsupp.sum_mapDomain_index]
    ¬∑ refine s.sum_mem ?_
      intro y hy
      exact s.smul_mem _ (hg y (hl1 hy)).1
    ¬∑ exact zero_smul _
    ¬∑ exact fun _ _ _ => add_smul _ _ _
  ¬∑ rw [LinearMap.mem_ker, f.map_sub, ‚Üê hl2]
    rw [Finsupp.total_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply]
    rw [Finsupp.sum_mapDomain_index, Finsupp.sum, Finsupp.sum, Finsupp.sum, map_sum]
    ¬∑ rw [sub_eq_zero]
      refine Finset.sum_congr rfl fun y hy => ?_
      unfold id
      rw [f.map_smul, (hg y (hl1 hy)).2]
      unfold id
      rw [f.map_smul, (hg y (hl1 hy)).2]
      unfold id
      rw [f.map_smul, (hg y (hl1 hy)).2]
      unfold id
      rw [f.map_smul, (hg y (hl1 hy)).2]
      unfold id
      rw [f.map_smul, (hg y (hl1 hy))."
Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean,gramSchmidt_orthogonal,gramSchmidt_orthogonal,9ff3bbdccfe0666edb16cd12dc14aaabdb7eca30,":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ ha
    ¬∑ rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply WellFounded.induction (@IsWellFounded.wf Œπ (¬∑ < ¬∑) _) b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    ¬∑ rw [IsROrC.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ","error:  unknown identifier 'IsROrC.ofReal_pow'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.51226
case neg
ùïú : Type u_1
E : Type u_2
inst‚úù‚Åµ : RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : InnerProductSpace ùïú E
Œπ : Type u_3
inst‚úù¬≤ : LinearOrder Œπ
inst‚úù¬π : LocallyFiniteOrderBot Œπ
inst‚úù : IsWellOrder Œπ fun x x_1 ‚Ü¶ x < x_1
f : Œπ ‚Üí E
b‚úù b : Œπ
ih : ‚àÄ y < b, ‚àÄ a < y, ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f y‚ü´_ùïú = 0
a : Œπ
h‚ÇÄ : a < b
h : ¬¨gramSchmidt ùïú f a = 0
‚ä¢ ‚ü™gramSchmidt ùïú f a, f b‚ü´_ùïú -
      ‚ü™gramSchmidt ùïú f a, f b‚ü´_ùïú / ‚Üë(‚ÄñgramSchmidt ùïú f a‚Äñ ^ 2) * ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f a‚ü´_ùïú =
    0","theorem gramSchmidt_orthogonal (f : Œπ ‚Üí E) {a b : Œπ} (h‚ÇÄ : a ‚â† b) :
    ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 ",":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ ha
    ¬∑ rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply wellFounded_lt.induction b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    ¬∑ rw [RCLike.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel‚ÇÄ, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ",":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ ha
    ¬∑ rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply WellFounded.induction (@IsWellFounded.wf Œπ (¬∑ < ¬∑) _) b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    ¬∑ rw [IsROrC.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.Mem‚Ñíp.snorm_indicator_norm_ge_pos_le,Mem‚Ñíp.snorm_indicator_norm_ge_pos_le,ff33d25c791a3fac407c782b49018fcb63700d0d,":= by
  obtain ‚ü®M, hM‚ü© := hf.snorm_indicator_norm_ge_le Œº hmeas hŒµ
  refine'
    ‚ü®max M 1, lt_of_lt_of_le zero_lt_one (le_max_right _ _), le_trans (snorm_mono fun x => _) hM‚ü©
  rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]
  refine' Set.indicator_le_indicator_of_subset (fun x hx => _) (fun x => norm_nonneg (f x)) x
  rw [Set.mem_setOf_eq] at hx 
  exact (max_le_iff.1 hx).1","error:  application type mismatch
  @snorm_indicator_norm_ge_le Œ± Œ≤ m Œº inst‚úù p f hf Œº
argument
  Œº
has type
  Measure Œ± : Type u_1
but is expected to have type
  StronglyMeasurable f : Prop
error:  rcases tactic failed: x‚úù : ?m.69023 is not an inductive datatype","theorem Mem‚Ñíp.snorm_indicator_norm_ge_pos_le (hf : Mem‚Ñíp f p Œº) (hmeas : StronglyMeasurable f)
    {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :
    ‚àÉ M : ‚Ñù, 0 < M ‚àß snorm ({ x | M ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f) p Œº ‚â§ ENNReal.ofReal Œµ ",":= by
  obtain ‚ü®M, hM‚ü© := hf.snorm_indicator_norm_ge_le hmeas hŒµ
  refine
    ‚ü®max M 1, lt_of_lt_of_le zero_lt_one (le_max_right _ _), le_trans (snorm_mono fun x => ?_) hM‚ü©
  rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]
  refine Set.indicator_le_indicator_of_subset (fun x hx => ?_) (fun x => norm_nonneg (f x)) x
  rw [Set.mem_setOf_eq] at hx 
  exact (max_le_iff.1 hx).1",":= by
  obtain ‚ü®M, hM‚ü© := hf.snorm_indicator_norm_ge_le Œº hmeas hŒµ
  refine ‚ü®max M 1, lt_of_lt_of_le zero_lt_one (le_max_right _ _), le_trans (snorm_mono fun x => ?_) hM‚ü©
  rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]
  refine Set.indicator_le_indicator_of_subset (fun x hx => ?_) (fun x => norm_nonneg (f x)) x
  rw [Set.mem_setOf_eq] at hx 
  exact (max_le_iff.1 hx).1"
Mathlib/Algebra/Order/Archimedean.lean,existsUnique_zsmul_near_of_pos,existsUnique_zsmul_near_of_pos,e2b81ba84dbe04d1922bf2fe517ab39d55326d72,":= by
  let s : Set ‚Ñ§ := { n : ‚Ñ§ | n ‚Ä¢ a ‚â§ g }
  obtain ‚ü®k, hk : -g ‚â§ k ‚Ä¢ a‚ü© := Archimedean.arch (-g) ha
  have h_ne : s.Nonempty := ‚ü®-k, by simpa using neg_le_neg hk‚ü©
  obtain ‚ü®k, hk‚ü© := Archimedean.arch g ha
  have h_bdd : ‚àÄ n ‚àà s, n ‚â§ (k : ‚Ñ§) := by
    intro n hn
    apply (zsmul_le_zsmul_iff ha).mp
    rw [‚Üê coe_nat_zsmul] at hk
    exact le_trans hn hk
  obtain ‚ü®m, hm, hm'‚ü© := Int.exists_greatest_of_bdd ‚ü®k, h_bdd‚ü© h_ne
  have hm'' : g < (m + 1) ‚Ä¢ a := by
    contrapose! hm'
    exact ‚ü®m + 1, hm', lt_add_one _‚ü©
  refine' ‚ü®m, ‚ü®hm, hm''‚ü©, fun n hn => (hm' n hn.1).antisymm <| Int.le_of_lt_add_one _‚ü©
  rw [‚Üê zsmul_lt_zsmul_iff ha]
  exact lt_of_le_of_lt hm hn.2","error:  type mismatch
  h‚úù
has type
  -(k ‚Ä¢ a) ‚â§ g : Prop
but is expected to have type
  -‚Üëk ‚àà s : Prop
warning:  `coe_nat_zsmul` has been deprecated, use `natCast_zsmul` instead","theorem existsUnique_zsmul_near_of_pos {a : Œ±} (ha : 0 < a) (g : Œ±) :
    ‚àÉ! k : ‚Ñ§, k ‚Ä¢ a ‚â§ g ‚àß g < (k + 1) ‚Ä¢ a ",":= by
  let s : Set ‚Ñ§ := { n : ‚Ñ§ | n ‚Ä¢ a ‚â§ g }
  obtain ‚ü®k, hk : -g ‚â§ k ‚Ä¢ a‚ü© := Archimedean.arch (-g) ha
  have h_ne : s.Nonempty := ‚ü®-k, by simpa [s] using neg_le_neg hk‚ü©
  obtain ‚ü®k, hk‚ü© := Archimedean.arch g ha
  have h_bdd : ‚àÄ n ‚àà s, n ‚â§ (k : ‚Ñ§) := by
    intro n hn
    apply (zsmul_le_zsmul_iff ha).mp
    rw [‚Üê natCast_zsmul] at hk
    exact le_trans hn hk
  obtain ‚ü®m, hm, hm'‚ü© := Int.exists_greatest_of_bdd ‚ü®k, h_bdd‚ü© h_ne
  have hm'' : g < (m + 1) ‚Ä¢ a := by
    contrapose! hm'
    exact ‚ü®m + 1, hm', lt_add_one _‚ü©
  refine ‚ü®m, ‚ü®hm, hm''‚ü©, fun n hn => (hm' n hn.1).antisymm <| Int.le_of_lt_add_one ?_‚ü©
  rw [‚Üê zsmul_lt_zsmul_iff ha]
  exact lt_of_le_of_lt hm hn.2",":= by
  let s : Set ‚Ñ§ := { n : ‚Ñ§ | n ‚Ä¢ a ‚â§ g }
  obtain ‚ü®k, hk : -g ‚â§ k ‚Ä¢ a‚ü© := Archimedean.arch (-g) ha
  have h_ne : s.Nonempty := ‚ü®-k, by simpa using neg_le_neg hk‚ü©
  obtain ‚ü®k, hk‚ü© := Archimedean.arch g ha
  have h_bdd : ‚àÄ n ‚àà s, n ‚â§ (k : ‚Ñ§) := by
    intro n hn
    apply (zsmul_le_zsmul_iff ha).mp
    rw [‚Üê coe_natCast] at hk
    exact le_trans hn hk
  obtain ‚ü®m, hm, hm'‚ü© := Int.exists_greatest_of_bdd ‚ü®k, h_bdd‚ü© h_ne
  have hm'' : g < (m + 1) ‚Ä¢ a := by
    contrapose! hm'
    exact ‚ü®m + 1, hm', lt_add_one _‚ü©
  refine ‚ü®m, ‚ü®hm, hm''‚ü©, fun n hn => (hm' n hn.1).antisymm <| Int.le_of_lt_add_one ?_‚ü©
  rw [‚Üê zsmul_lt_zsmul_iff ha]
  exact lt_of_le_of_lt hm hn.2"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.exists_of_mem_join,exists_of_mem_join,f65ea6003256aa64f88a6f1c658c9128345b3ab7,":= by
  suffices
    ‚àÄ ss : WSeq Œ±,
      a ‚àà ss ‚Üí ‚àÄ s S, append s (join S) = ss ‚Üí a ‚àà append s (join S) ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)
  intro ss h; apply mem_rec_on h <;> [intro b ss o; intro ss IH] <;> intro s S
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp? at m ‚ä¢ says simp only [cons_append, mem_cons_iff] at m ‚ä¢
    cases' o with e IH
    ¬∑ simp [e]
    cases' m with e m
    ¬∑ simp [e]
    exact Or.imp_left Or.inr (IH _ _ rfl m)
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;> simp at this <;>
      subst ss
    ¬∑ apply Or.inr
      simp [-exists_eq_or_imp] at m ‚ä¢
      cases' IH s S rfl m with as ex
      ¬∑ exact ‚ü®s, Or.inl rfl, as‚ü©
      ¬∑ rcases ex with ‚ü®s', sS, as‚ü©
        exact ‚ü®s', Or.inr sS, as‚ü©
    ¬∑ apply Or.inr
      simp? at m says simp only [join_think, nil_append, mem_think] at m
      rcases (IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with ‚ü®s, sS, as‚ü©
      exact ‚ü®s, by simp [sS], as‚ü©
    ¬∑ simp only [think_append, mem_think] at m IH ‚ä¢
      apply IH _ _ rfl m","error:  unknown identifier 'this'
error:  unknown identifier 'this'
error:  unknown identifier 'this'
error:  unknown identifier 'this'
error:  unknown identifier 'this'
error:  unknown identifier 'this'
error:  tactic 'induction' failed, major premise type is not an inductive type 
  ?m.109228
case h1.h1.h1
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
a : Œ±
ss‚úù : WSeq Œ±
h : a ‚àà ss‚úù
b : Œ±
ss : WSeq Œ±
o : a = b ‚à® ‚àÄ (s : WSeq Œ±) (S : WSeq (WSeq Œ±)), s.append S.join = ss ‚Üí a ‚àà s.append S.join ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
m : a ‚àà nil.append nil.join
ej : nil = cons b ss
x‚úù : ?m.109228
‚ä¢ a ‚àà nil ‚à® ‚àÉ s, s ‚àà nil ‚àß a ‚àà s
error:  unknown identifier 'this'
error:  unknown identifier 'this'
error:  unknown identifier 'this'
error:  unknown identifier 'this'
error:  unknown identifier 'this'
error:  tactic 'subst' failed, did not find equation for eliminating 'ss'
case h2.h1.h1
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
a : Œ±
ss‚úù : WSeq Œ±
h : a ‚àà ss‚úù
ss : WSeq Œ±
IH : ‚àÄ (s : WSeq Œ±) (S : WSeq (WSeq Œ±)), s.append S.join = ss ‚Üí a ‚àà s.append S.join ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
m : a ‚àà nil.append nil.join
ej : nil = ss.think
‚ä¢ a ‚àà nil ‚à® ‚àÉ s, s ‚àà nil ‚àß a ‚àà s
error:  tactic 'subst' failed, did not find equation for eliminating 'ss'
case h2.h1.h2
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
a : Œ±
ss‚úù : WSeq Œ±
h : a ‚àà ss‚úù
ss : WSeq Œ±
IH : ‚àÄ (s : WSeq Œ±) (S : WSeq (WSeq Œ±)), s.append S.join = ss ‚Üí a ‚àà s.append S.join ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
s : WSeq Œ±
S : WSeq (WSeq Œ±)
m : a ‚àà nil.append (cons s S).join
ej : (s.append S.join).think = ss.think
‚ä¢ a ‚àà nil ‚à® ‚àÉ s_1, s_1 ‚àà cons s S ‚àß a ‚àà s_1
error:  tactic 'subst' failed, did not find equation for eliminating 'ss'
case h2.h1.h3
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
a : Œ±
ss‚úù : WSeq Œ±
h : a ‚àà ss‚úù
ss : WSeq Œ±
IH : ‚àÄ (s : WSeq Œ±) (S : WSeq (WSeq Œ±)), s.append S.join = ss ‚Üí a ‚àà s.append S.join ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
S : WSeq (WSeq Œ±)
m : a ‚àà nil.append S.think.join
ej : S.join.think = ss.think
‚ä¢ a ‚àà nil ‚à® ‚àÉ s, s ‚àà S.think ‚àß a ‚àà s
error:  tactic 'subst' failed, did not find equation for eliminating 'ss'
case h2.h2
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
a : Œ±
ss‚úù : WSeq Œ±
h : a ‚àà ss‚úù
ss : WSeq Œ±
IH : ‚àÄ (s : WSeq Œ±) (S : WSeq (WSeq Œ±)), s.append S.join = ss ‚Üí a ‚àà s.append S.join ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
S : WSeq (WSeq Œ±)
b' : Œ±
s : WSeq Œ±
m : a ‚àà (cons b' s).append S.join
ej : cons b' (s.append S.join) = ss.think
‚ä¢ a ‚àà cons b' s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
error:  tactic 'subst' failed, did not find equation for eliminating 'ss'
case h2.h3
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
a : Œ±
ss‚úù : WSeq Œ±
h : a ‚àà ss‚úù
ss : WSeq Œ±
IH : ‚àÄ (s : WSeq Œ±) (S : WSeq (WSeq Œ±)), s.append S.join = ss ‚Üí a ‚àà s.append S.join ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
S : WSeq (WSeq Œ±)
s : WSeq Œ±
m : a ‚àà s.think.append S.join
ej : (s.append S.join).think = ss.think
‚ä¢ a ‚àà s.think ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
error:  unknown identifier 's'
error:  unknown identifier 'S'
error:  unknown identifier 's'
error:  unsolved goals
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
a : Œ±
ss‚úù : WSeq Œ±
h : a ‚àà ss‚úù
ss : WSeq Œ±
IH : ‚àÄ (s : WSeq Œ±) (S : WSeq (WSeq Œ±)), s.append S.join = ss ‚Üí a ‚àà s.append S.join ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
s : WSeq Œ±
S : WSeq (WSeq Œ±)
ej : (s.append S.join).think = ss.think
m : a ‚àà (cons s S).join
‚ä¢ S.join = ss
error:  unsolved goals
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
a : Œ±
ss‚úù : WSeq Œ±
h : a ‚àà ss‚úù
ss : WSeq Œ±
IH : ‚àÄ (s : WSeq Œ±) (S : WSeq (WSeq Œ±)), s.append S.join = ss ‚Üí a ‚àà s.append S.join ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
s : WSeq Œ±
S : WSeq (WSeq Œ±)
ej : (s.append S.join).think = ss.think
m : a ‚àà (cons s S).join
‚ä¢ a ‚àà S.join
error:  application type mismatch
  IH ?m.110961 ?m.110962 rfl
argument
  rfl
has type
  ?m.110961.append ?m.110962.join = ?m.110961.append ?m.110962.join : Prop
but is expected to have type
  ?m.110961.append ?m.110962.join = ss : Prop
error:  unsolved goals
case h2.h2
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
a : Œ±
ss‚úù : WSeq Œ±
h : a ‚àà ss‚úù
ss : WSeq Œ±
IH : ‚àÄ (s : WSeq Œ±) (S : WSeq (WSeq Œ±)), s.append S.join = ss ‚Üí a ‚àà s.append S.join ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
S : WSeq (WSeq Œ±)
b' : Œ±
s : WSeq Œ±
m : a ‚àà (cons b' s).append S.join
ej : cons b' (s.append S.join) = ss.think
‚ä¢ a ‚àà cons b' s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s

case h2.h3
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
a : Œ±
ss‚úù : WSeq Œ±
h : a ‚àà ss‚úù
ss : WSeq Œ±
IH : ‚àÄ (s : WSeq Œ±) (S : WSeq (WSeq Œ±)), s.append S.join = ss ‚Üí a ‚àà s.append S.join ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
S : WSeq (WSeq Œ±)
s : WSeq Œ±
m : a ‚àà s.think.append S.join
ej : (s.append S.join).think = ss.think
‚ä¢ a ‚àà s.think ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s","theorem exists_of_mem_join {a : Œ±} : ‚àÄ {S : WSeq (WSeq Œ±)}, a ‚àà join S ‚Üí ‚àÉ s, s ‚àà S ‚àß a ‚àà s ",":= by
  suffices
    ‚àÄ ss : WSeq Œ±,
      a ‚àà ss ‚Üí ‚àÄ s S, append s (join S) = ss ‚Üí a ‚àà append s (join S) ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)
  intro ss h; apply mem_rec_on h <;> [intro b ss o; intro ss IH] <;> intro s S
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp? at m ‚ä¢ says simp only [cons_append, mem_cons_iff] at m ‚ä¢
    cases' o with e IH
    ¬∑ simp [e]
    cases' m with e m
    ¬∑ simp [e]
    exact Or.imp_left Or.inr (IH _ _ rfl m)
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq.destruct ej <;> simp at this <;>
      subst ss
    ¬∑ apply Or.inr
      simp [-exists_eq_or_imp] at m ‚ä¢
      cases' IH s S rfl m with as ex
      ¬∑ exact ‚ü®s, Or.inl rfl, as‚ü©
      ¬∑ rcases ex with ‚ü®s', sS, as‚ü©
        exact ‚ü®s', Or.inr sS, as‚ü©
    ¬∑ apply Or.inr
      simp? at m says simp only [join_think, nil_append, mem_think] at m
      rcases (IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with ‚ü®s, sS, as‚ü©
      exact ‚ü®s, by simp [sS], as‚ü©
    ¬∑ simp only [think_append, mem_think] at m IH ‚ä¢
      apply IH _ _ rfl m",":= by
  suffices
    ‚àÄ ss : WSeq Œ±,
      a ‚àà ss ‚Üí ‚àÄ s S, append s (join S) = ss ‚Üí a ‚àà append s (join S) ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)
  intro ss h; apply mem_rec_on h <;> [intro b ss o; intro ss IH] <;> intro s S
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp? at m ‚ä¢ says simp only [cons_append, mem_cons_iff] at m ‚ä¢
    cases' o with e IH
    ¬∑ simp [e]
    cases' m with e m
    ¬∑ simp [e]
    exact Or.imp_left Or.inr (IH _ _ rfl m)
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp? at m ‚ä¢ says simp only [cons_append, mem_cons_iff] at m ‚ä¢
    cases' o with e IH
    ¬∑ simp [e]
    cases' m with e m
    ¬∑ simp [e]
    exact Or.imp_left Or.inr (IH _ _ rfl m)
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;> simp at this <;>
      subst ss
    ¬∑ apply Or.inr
      simp? at m says simp only [join_think, nil_append, mem_think] at m
      rcases (IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with ‚ü®s, sS, as‚ü©
      exact ‚ü®s, by simp [sS], as‚ü©
    ¬∑ simp only [think_append, mem_think] at m IH ‚ä¢
      apply IH _ _ rfl m"
Mathlib/Algebra/BigOperators/Finsupp.lean,Finsupp.prod_mapRange_index,prod_mapRange_index,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.prod_mapRange_index h0",error:  unknown identifier 'DFinsupp.prod_mapRange_index',"theorem prod_mapRange_index {f : M ‚Üí M'} {hf : f 0 = 0} {g : Œ± ‚Üí‚ÇÄ M} {h : Œ± ‚Üí M' ‚Üí N}
    (h0 : ‚àÄ a, h a 0 = 1) : (mapRange f hf g).prod h = g.prod fun a b => h a (f b) ",":=
  Finset.prod_subset support_mapRange fun _ _ H => by rw [not_mem_support_iff.1 H, h0]",":=
  Finsupp.prod_mapRange_index h0"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicAt.order_eq_int_iff,order_eq_int_iff,b0772359d09d1bb8ac5abff43f4728c85dc365ea,":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_nat, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel', zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©","warning:  `WithTop.coe_nat` has been deprecated, use `WithTop.coe_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚ä§ - ‚Üë?m.79514
case pos
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí E
x : ùïú
hf : MeromorphicAt f x
n : ‚Ñ§
h : ‚ãØ.order = ‚ä§
‚ä¢ ‚ä§ - ‚Üë‚Üë(Exists.choose hf) = ‚Üën ‚Üî ‚àÉ g, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z
warning:  `WithTop.coe_nat` has been deprecated, use `WithTop.coe_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë?m.80098 - ‚Üë?m.80099
case neg.intro
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí E
x : ùïú
hf : MeromorphicAt f x
n : ‚Ñ§
h‚úù : ¬¨‚ãØ.order = ‚ä§
m : ‚Ñï
h : ‚Üëm = ‚ãØ.order
‚ä¢ ‚Üë‚Üëm - ‚Üë‚Üë(Exists.choose hf) = ‚Üën ‚Üî ‚àÉ g, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z","lemma order_eq_int_iff {f : ùïú ‚Üí E} {x : ùïú} (hf : MeromorphicAt f x) (n : ‚Ñ§) : hf.order = n ‚Üî
    ‚àÉ g : ùïú ‚Üí E, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z ",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_natCast, ‚Üê coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_nat, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel', zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©"
Mathlib/Topology/Category/Stonean/Limits.lean,Stonean.Sigma.openEmbedding_Œπ,Sigma.openEmbedding_Œπ,7d5d6eb658906f2c7b67de823bc202579000fb2e,":= by
  refine OpenEmbedding.of_comp _
    (CompHausLike.homeoOfIso (coproductIsoCoproduct Z).symm).openEmbedding ?_
  convert finiteCoproduct.openEmbedding_Œπ Z a
  ext x
  change ((Sigma.Œπ Z a) ‚â´ (coproductIsoCoproduct Z).inv) x = _
  simp [coproductIsoCoproduct]","error:  unknown identifier 'CompHausLike.homeoOfIso'
error:  unsolved goals
Œ±‚úù : Type
inst‚úù¬π : Finite Œ±‚úù
B : Stonean
X : Œ±‚úù ‚Üí Stonean
Œ± : Type
inst‚úù : Finite Œ±
Z : Œ± ‚Üí Stonean
a : Œ±
‚ä¢ OpenEmbedding ‚áë(Sigma.Œπ Z a)","lemma Sigma.openEmbedding_Œπ {Œ± : Type} [Finite Œ±] (Z : Œ± ‚Üí Stonean.{u}) (a : Œ±) :
    OpenEmbedding (Sigma.Œπ Z a) ",":= by
  refine OpenEmbedding.of_comp _ (homeoOfIso (coproductIsoCoproduct Z).symm).openEmbedding ?_
  convert finiteCoproduct.openEmbedding_Œπ Z a
  ext x
  change ((Sigma.Œπ Z a) ‚â´ (coproductIsoCoproduct Z).inv) x = _
  simp [coproductIsoCoproduct]",":= by
  refine OpenEmbedding.of_comp ?_
    (CompHausLike.homeoOfIso (coproductIsoCoproduct Z).symm).openEmbedding ?_
  convert finiteCoproduct.openEmbedding_Œπ Z a
  ext x
  change ((Sigma.Œπ Z a) ‚â´ (coproductIsoCoproduct Z).inv) x = _"
Mathlib/Probability/ConditionalProbability.lean,ProbabilityTheory.cond_cond_eq_cond_inter',cond_cond_eq_cond_inter',05c4c02a126a220762b13df794c36c771e2fbb7d,":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 := measure_mono_null (Set.inter_subset_left _ _) hst
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (Œº.toOuterMeasure.pos_of_subset_ne_zero (Set.inter_subset_left _ _) hst).ne'
    simp [*, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Œº s)‚Åª¬π]","warning:  @cond does not have a doc string
warning:  @cond does not have a doc string
error:  function expected at
  inter_subset_left ?m.28019
term has type
  ?m.28018 ‚àà ?m.28016
warning:  `MeasureTheory.OuterMeasure.pos_of_subset_ne_zero` has been deprecated, use `MeasureTheory.measure_pos_of_superset` instead
error:  function expected at
  inter_subset_left ?m.30432
term has type
  ?m.30431 ‚àà ?m.30429","lemma cond_cond_eq_cond_inter' (hms : MeasurableSet s) (hmt : MeasurableSet t) (hcs : Œº s ‚â† ‚àû) :
    Œº[|s][|t] = Œº[|s ‚à© t] ",":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (measure_pos_of_superset Set.inter_subset_left hst).ne'
    simp [*, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Œº s)‚Åª¬π]",":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (Œº.toOuterMeasure.pos_of_subset_ne_zero Set.inter_subset_left hst).ne'
    simp [*, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Œº s)‚Åª¬π]"
Mathlib/Data/Int/GCD.lean,Nat.gcdB_zero_right,gcdB_zero_right,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  unfold gcdB xgcd
  obtain ‚ü®s, rfl‚ü© := Nat.exists_eq_succ_of_ne_zero h
  rw [xgcdAux_succ]
  rfl","error:  unknown identifier 'xgcdAux_succ'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.8708
case intro
s : ‚Ñï
h : s.succ ‚â† 0
‚ä¢ (s.succ.xgcdAux 1 0 0 0 1).2.2 = 0",theorem gcdB_zero_right {s : ‚Ñï} (h : s ‚â† 0) : gcdB s 0 = 0 ,":= by
  unfold gcdB xgcd
  obtain ‚ü®s, rfl‚ü© := Nat.exists_eq_succ_of_ne_zero h
  rw [xgcdAux]
  simp",":= by
  unfold gcdB xgcd
  obtain ‚ü®s, rfl‚ü© := Nat.exists_eq_succ_of_ne_zero h
  rw [xgcdAux_succ]
  rfl"
Mathlib/MeasureTheory/Measure/Typeclasses.lean,MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top,countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only []
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine' countable_iUnion fun n => Finite.countable _
  exact finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite",error:  simp made no progress,"theorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ {Œπ : Type*} {_ : MeasurableSpace Œ±}
    (Œº : Measure Œ±) {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, NullMeasurableSet (As i) Œº)
    (As_disj : Pairwise (AEDisjoint Œº on As)) (Union_As_finite : Œº (‚ãÉ i, As i) ‚â† ‚àû) :
    Set.Countable { i : Œπ | 0 < Œº (As i) } ",":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only [fairmeas]
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable ?_
  exact finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite",":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only []
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable ?_
  exact finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.aemeasurable_fderivWithin,aemeasurable_fderivWithin,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, _‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
              (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine' ‚ü®g, g_meas.aemeasurable, _‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n ‚Ü¶ Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine' ae_sum_iff.2 fun n => _
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono (inter_subset_left _ _)
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono (inter_subset_right _ _) le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1","error:  function expected at
  inter_subset_left ?m.375907
term has type
  ?m.375906 ‚àà ?m.375904
error:  function expected at
  inter_subset_left ?m.377059
term has type
  ?m.377058 ‚àà ?m.377056
error:  function expected at
  inter_subset_right ?m.377638
term has type
  ?m.377637 ‚àà ?m.377636","theorem aemeasurable_fderivWithin (hs : MeasurableSet s)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (Œº.restrict s) ",":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, _‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
              (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ‚ü®g, g_meas.aemeasurable, ?_‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n ‚Ü¶ Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1",":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, ?_‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
             (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ‚ü®g, g_meas.aemeasurable, ?_‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n ‚Ü¶ Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1"
Mathlib/RingTheory/IntegralDomain.lean,sum_hom_units,sum_hom_units,9db546a81b334ba30d74fed40766bcdeffb50e5f,":= by
  classical
    obtain ‚ü®x, hx‚ü© :
      ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0  
    exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u : RÀ£ in univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u : RÀ£ in univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum'.symm
      _ = c ‚Ä¢ (0 : R) := (congr_arg‚ÇÇ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n in range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only [mem_univ, forall_true_iff])
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
            (fun m n hm hn => pow_injOn_Iio_orderOf (by simpa only [mem_range] using hm)
                (by simpa only [mem_range] using hn))
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ‚ä¢; rw [pow_mod_orderOf, hn]‚ü©)
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]","error:  unexpected identifier; expected '|'
error:  unsolved goals
case intro
R : Type u_1
G : Type u_2
inst‚úù¬≥ : CommRing R
inst‚úù¬≤ : IsDomain R
inst‚úù¬π : Group G
inst‚úù : Fintype G
f : G ‚Üí* R
hf : f ‚â† 1
x : ‚Ü•f.toHomUnits.range
hx : ‚àÄ (y : ‚Ü•f.toHomUnits.range), y ‚àà Submonoid.powers x
hx1 : ‚Üë‚Üëx - 1 ‚â† 0
‚ä¢ ‚àë g : G, f g = 0","theorem sum_hom_units_eq_zero (f : G ‚Üí* R) (hf : f ‚â† 1) : ‚àë g : G, f g = 0 ",":= by
  classical
    obtain ‚ü®x, hx‚ü© : ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u ‚àà univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u ‚àà univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := congr_arg‚ÇÇ _ rfl ?_
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n ‚àà range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ ¬∑) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ‚ä¢; rw [pow_mod_orderOf, hn]‚ü©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]",":= by
  classical
    obtain ‚ü®x, hx‚ü© :
      ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0 := fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u : RÀ£ ‚àà univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u : RÀ£ ‚àà univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f."
Mathlib/NumberTheory/ClassNumber/Finite.lean,ClassGroup.norm_le,norm_le,eea6f6ac82db7f7e78ea88b5d9ce972184397fe9,":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  rw [‚Üê LinearMap.det_toMatrix bS]
  convert Matrix.det_sum_smul_le (n := Œπ) Finset.univ _ hy using 3
  ¬∑ simp; rfl
  ¬∑ rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  LinearMap.det ?f
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
inst‚úù¬π‚Å¥ : EuclideanDomain R
inst‚úù¬π¬≥ : CommRing S
inst‚úù¬π¬≤ : IsDomain S
inst‚úù¬π¬π : Field K
inst‚úù¬π‚Å∞ : Field L
inst‚úù‚Åπ : Algebra R K
inst‚úù‚Å∏ : IsFractionRing R K
inst‚úù‚Å∑ : Algebra K L
inst‚úù‚Å∂ : FiniteDimensional K L
inst‚úù‚Åµ : IsSeparable K L
algRL : Algebra R L
inst‚úù‚Å¥ : IsScalarTower R K L
inst‚úù¬≥ : Algebra R S
inst‚úù¬≤ : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R ‚Ñ§
Œπ : Type u_5
inst‚úù¬π : DecidableEq Œπ
inst‚úù : Fintype Œπ
bS : Basis Œπ R S
a : S
y : ‚Ñ§
hy : ‚àÄ (k : Œπ), abv ((bS.repr a) k) ‚â§ y
‚ä¢ abv (‚àë x : Œπ, (bS.repr a) x ‚Ä¢ (LinearMap.toMatrix bS bS) ((Algebra.lmul R S) (bS x))).det ‚â§
    (Fintype.card Œπ).factorial ‚Ä¢
      (Fintype.card Œπ ‚Ä¢
          ((Finset.image (fun ijk ‚Ü¶ abv ((Algebra.leftMulMatrix bS) (bS ijk.1) ijk.2.1 ijk.2.2)) Finset.univ).max' ‚ãØ *
            y)) ^
        Fintype.card Œπ","theorem norm_le (a : S) {y : ‚Ñ§} (hy : ‚àÄ k, abv (bS.repr a k) ‚â§ y) :
    abv (Algebra.norm R a) ‚â§ normBound abv bS * y ^ Fintype.card Œπ ",":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  convert Matrix.det_sum_smul_le Finset.univ _ hy using 3
  ¬∑ rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©",":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  rw [‚Üê LinearMap.det_toMatrix bS]
  convert Matrix.det_sum_smul_le (n := Œπ) Finset.univ _ hy using 3
  ¬∑ simp; rfl
  ¬∑ rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©"
Mathlib/Data/Set/Card.lean,Set.exists_superset_subset_encard_eq,exists_superset_subset_encard_eq,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  obtain (hs | hs) := eq_or_ne s.encard ‚ä§
  ¬∑ rw [hs, top_le_iff] at hsk; subst hsk; exact ‚ü®s, Subset.rfl, hst, hs‚ü©
  obtain ‚ü®k, rfl‚ü© := exists_add_of_le hsk
  obtain ‚ü®k', hk'‚ü© := exists_add_of_le hkt
  have hk : k ‚â§ encard (t \ s) := by
    rw [‚Üê encard_diff_add_encard_of_subset hst, add_comm] at hkt
    exact WithTop.le_of_add_le_add_right hs hkt
  obtain ‚ü®r', hr', rfl‚ü© := exists_subset_encard_eq hk
  refine' ‚ü®s ‚à™ r', subset_union_left _ _, union_subset hst (hr'.trans (diff_subset _ _)), _‚ü©
  rw [encard_union_eq (disjoint_of_subset_right hr' disjoint_sdiff_right)]","error:  function expected at
  subset_union_left ?m.99161
term has type
  ?m.99160 ‚àà ?m.99158 ‚à™ ?m.99159
error:  function expected at
  diff_subset ?m.99262
term has type
  ?m.99261 ‚àà ?m.99259","theorem exists_superset_subset_encard_eq {k : ‚Ñï‚àû}
    (hst : s ‚äÜ t) (hsk : s.encard ‚â§ k) (hkt : k ‚â§ t.encard) :
    ‚àÉ r, s ‚äÜ r ‚àß r ‚äÜ t ‚àß r.encard = k ",":= by
  obtain (hs | hs) := eq_or_ne s.encard ‚ä§
  ¬∑ rw [hs, top_le_iff] at hsk; subst hsk; exact ‚ü®s, Subset.rfl, hst, hs‚ü©
  obtain ‚ü®k, rfl‚ü© := exists_add_of_le hsk
  obtain ‚ü®k', hk'‚ü© := exists_add_of_le hkt
  have hk : k ‚â§ encard (t \ s) := by
    rw [‚Üê encard_diff_add_encard_of_subset hst, add_comm] at hkt
    exact WithTop.le_of_add_le_add_right hs hkt
  obtain ‚ü®r', hr', rfl‚ü© := exists_subset_encard_eq hk
  refine ‚ü®s ‚à™ r', subset_union_left, union_subset hst (hr'.trans diff_subset), ?_‚ü©
  rw [encard_union_eq (disjoint_of_subset_right hr' disjoint_sdiff_right)]",":= by
  obtain (hs | hs) := eq_or_ne s.encard ‚ä§
  ¬∑ rw [hs, top_le_iff] at hsk; subst hsk; exact ‚ü®s, Subset.rfl, hst, hs‚ü©
  obtain ‚ü®k, rfl‚ü© := exists_add_of_le hsk
  obtain ‚ü®k', hk'‚ü© := exists_add_of_le hkt
  have hk : k ‚â§ encard (t \ s) := by
    rw [‚Üê encard_diff_add_encard_of_subset hst, add_comm] at hkt
    exact WithTop.le_of_add_le_add_right hs hkt
  obtain ‚ü®r', hr', rfl‚ü© := exists_subset_encard_eq hk
  refine ‚ü®s ‚à™ r', subset_union_left, union_subset hst (hr'.trans diff_subset), ?_‚ü©
  rw [encard_union_eq (disjoint_of_subset_right hr' disjoint_sdiff_right)]"
Mathlib/NumberTheory/FermatPsp.lean,Nat.exists_infinite_pseudoprimes,exists_infinite_pseudoprimes,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by linarith
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by linarith) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by linarith
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact ‚ü®fermatPsp_base_one (by linarith) this, by linarith‚ü©","error:  application type mismatch
  Nat.le_mul_of_pos_right h‚ÇÉ
argument
  h‚ÇÉ
has type
  0 < b ^ 2 - 1 : Prop
but is expected to have type
  ‚Ñï : Type
error:  unsolved goals
b : ‚Ñï
h : 1 ‚â§ b
m : ‚Ñï
b_ge_two : ¬¨2 ‚â§ b
h‚ÇÅ : b = 1
‚ä¢ ¬¨m + 2 = 1","theorem exists_infinite_pseudoprimes {b : ‚Ñï} (h : 1 ‚â§ b) (m : ‚Ñï) :
    ‚àÉ n : ‚Ñï, FermatPsp n b ‚àß m ‚â§ n ",":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by omega
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by omega) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by omega
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by omega) (by omega)
    exact ‚ü®fermatPsp_base_one (by omega) this, by omega‚ü©",":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by linarith
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by linarith) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by linarith
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact ‚ü®fermatPsp_base_one (by linarith) this, by linarith‚ü©"
Mathlib/RingTheory/RootsOfUnity/Basic.lean,IsPrimitiveRoot.nthRoots_one_eq_biUnion_primitiveRoots,nthRoots_one_eq_biUnion_primitiveRoots,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  symm
  apply Finset.eq_of_subset_of_card_le
  ¬∑ intro x
    simp only [nthRootsFinset, ‚Üê Multiset.toFinset_eq (nthRoots_one_nodup h), exists_prop,
      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,
      Nat.mem_divisors, and_true_iff, Ne.def, PNat.ne_zero, PNat.pos, not_false_iff]
    rintro ‚ü®a, ‚ü®d, hd‚ü©, ha‚ü©
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, zero_mul]
      exact n.ne_zero
    rw [mem_primitiveRoots hazero] at ha
    rw [hd, pow_mul, ha.pow_eq_one, one_pow]
  ¬∑ apply le_of_eq
    rw [h.card_nthRootsFinset, Finset.card_biUnion]
    ¬∑ nth_rw 1 [‚Üê Nat.sum_totient n]
      refine' sum_congr rfl _
      simp only [Nat.mem_divisors]
      rintro k ‚ü®‚ü®d, hd‚ü©, -‚ü©
      rw [mul_comm] at hd
      rw [(h.pow n.pos hd).card_primitiveRoots]
    ¬∑ intro i _ j _ hdiff
      exact disjoint hdiff","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.276236 ‚Üí ?m.276236 ‚Üí Prop
error:  type mismatch
  PNat.ne_zero n
has type
  ‚Üën ‚â† 0 : Prop
but is expected to have type
  ‚Üën = 0 : Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  False
case h.intro.intro.intro
M : Type u_1
N : Type u_2
G : Type u_3
R : Type u_4
S : Type u_5
F : Type u_6
inst‚úù‚Å¥ : CommMonoid M
inst‚úù¬≥ : CommMonoid N
inst‚úù¬≤ : DivisionCommMonoid G
k l : ‚Ñï
inst‚úù¬π : CommRing R
Œ∂‚úù : RÀ£
h‚úù : IsPrimitiveRoot Œ∂‚úù k
inst‚úù : IsDomain R
Œ∂ : R
n : ‚Ñï+
h : IsPrimitiveRoot Œ∂ ‚Üën
x : R
a : ‚Ñï
ha : IsPrimitiveRoot x a
d : a ‚à£ ‚Üën
hd : ‚Üën ‚â† 0
hazero : 0 < a
‚ä¢ x ^ ‚Üën = 1","theorem nthRoots_one_eq_biUnion_primitiveRoots' {Œ∂ : R} {n : ‚Ñï+} (h : IsPrimitiveRoot Œ∂ n) :
    nthRootsFinset n R = (Nat.divisors ‚Üën).biUnion fun i => primitiveRoots i R ",":= by
  symm
  apply Finset.eq_of_subset_of_card_le
  ¬∑ intro x
    simp only [nthRootsFinset, ‚Üê Multiset.toFinset_eq (nthRoots_one_nodup h), exists_prop,
      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,
      Nat.mem_divisors, and_true_iff, Ne, PNat.ne_zero, PNat.pos, not_false_iff]
    rintro ‚ü®a, ‚ü®d, hd‚ü©, ha‚ü©
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, zero_mul]
      exact n.ne_zero
    rw [mem_primitiveRoots hazero] at ha
    rw [hd, pow_mul, ha.pow_eq_one, one_pow]
  ¬∑ apply le_of_eq
    rw [h.card_nthRootsFinset, Finset.card_biUnion]
    ¬∑ nth_rw 1 [‚Üê Nat.sum_totient n]
      refine sum_congr rfl ?_
      simp only [Nat.mem_divisors]
      rintro k ‚ü®‚ü®d, hd‚ü©, -‚ü©
      rw [mul_comm] at hd
      rw [(h.pow n.pos hd).card_primitiveRoots]
    ¬∑ intro i _ j _ hdiff
      exact disjoint hdiff",":= by
  symm
  apply Finset.eq_of_subset_of_card_le
  ¬∑ intro x
    simp only [nthRootsFinset, ‚Üê Multiset.toFinset_eq (nthRoots_one_nodup h), exists_prop,
      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,
      Nat.mem_divisors, and_true_iff, Ne, PNat.ne_zero, PNat.pos, not_false_iff]
    rintro ‚ü®a, ‚ü®d, hd‚ü©, ha‚ü©
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, zero_mul]
      exact n.ne_zero
    rw [mem_primitiveRoots hazero] at ha
    rw [hd, pow_mul, ha.pow_eq_one, one_pow]
  ¬∑ apply le_of_eq
    rw [h.card_nthRootsFinset, Finset.card_biUnion]
    ¬∑ nth_rw 1 [‚Üê Nat.sum_totient n]
      refine sum_congr rfl ?_
      simp only [Nat.mem_divisors]
      rintro k ‚ü®‚ü®d, hd‚ü©, -‚ü©
      rw [mul_comm] at hd
      rw [(h.pow n.pos hd).card_primitiveRoots]
    ¬∑ intro i _ j _ hdiff
      exact disjoint hdiff"
Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean,FiniteField.isSquare_two_iff,FiniteField.isSquare_two_iff,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  classical
  by_cases hF : ringChar F = 2
  focus
    have h := FiniteField.even_card_of_char_two hF
    simp only [FiniteField.isSquare_of_char_two hF, true_iff_iff]
  rotate_left
  focus
    have h := FiniteField.odd_card_of_char_ne_two hF
    rw [‚Üê quadraticChar_one_iff_isSquare (Ring.two_ne_zero hF), quadraticChar_two hF,
      œá‚Çà_nat_eq_if_mod_eight]
    simp only [h, Nat.one_ne_zero, if_false, ite_eq_left_iff, Ne.def, (by decide : (-1 : ‚Ñ§) ‚â† 1),
      imp_false, Classical.not_not]
  all_goals
    rw [‚Üê Nat.mod_mod_of_dvd _ (by norm_num : 2 ‚à£ 8)] at h
    have h‚ÇÅ := Nat.mod_lt (Fintype.card F) (by decide : 0 < 8)
    revert h‚ÇÅ h
    generalize Fintype.card F % 8 = n
    intros; interval_cases n <;> simp_all ","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.9728 ‚Üí ?m.9728 ‚Üí Prop","theorem FiniteField.isSquare_two_iff :
    IsSquare (2 : F) ‚Üî Fintype.card F % 8 ‚â† 3 ‚àß Fintype.card F % 8 ‚â† 5 ",":= by
  classical
  by_cases hF : ringChar F = 2
  ¬∑ have h := FiniteField.even_card_of_char_two hF
    simp only [FiniteField.isSquare_of_char_two hF, true_iff_iff]
    omega
  ¬∑ have h := FiniteField.odd_card_of_char_ne_two hF
    rw [‚Üê quadraticChar_one_iff_isSquare (Ring.two_ne_zero hF), quadraticChar_two hF,
      œá‚Çà_nat_eq_if_mod_eight]
    omega",":= by
  classical
  by_cases hF : ringChar F = 2
  focus
    have h := FiniteField.even_card_of_char_two hF
    simp only [FiniteField.isSquare_of_char_two hF, true_iff_iff]
  rotate_left
  focus
    have h := FiniteField.odd_card_of_char_ne_two hF
    rw [‚Üê quadraticChar_one_iff_isSquare (Ring.two_ne_zero hF), quadraticChar_two hF,
      œá‚Çà_nat_eq_if_mod_eight]
    simp only [h, Nat.one_ne_zero, if_false, ite_eq_left_iff, Ne, (by decide : (-1 : ‚Ñ§) ‚â† 1),
      imp_false, Classical.not_not]
  all_goals
    rw [‚Üê Nat.mod_mod_of_dvd _ (by norm_num : 2 ‚à£ 8)] at h
    have h‚ÇÅ := Nat.mod_lt (Fintype.card F) (by decide : 0 < 8)
    revert h‚ÇÅ h
    generalize Fintype.card F % 8 = n
    intros; interval_cases n <;> simp_all"
Mathlib/Topology/MetricSpace/Polish.lean,IsClosed.isClopenable,_root_.IsClosed.isClopenable,1851e611668b90ebb2d0265b8242736ebc1ac256,":= by
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫ := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    simp [f, preimage_preimage]","error:  failed to synthesize
  DecidablePred fun x ‚Ü¶ x ‚àà s
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  And.intro continuous_subtype_val
argument
  continuous_subtype_val
has type
  Continuous Subtype.val : Prop
but is expected to have type
  Continuous (‚áëf ‚àò Sum.inl) : Prop
error:  unsolved goals
case refine_2
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : TopologicalSpace Œ±
inst‚úù : PolishSpace Œ±
s : Set Œ±
hs : IsClosed s
this‚úù : PolishSpace ‚Üës
t : Set Œ± := s·∂ú
this : PolishSpace ‚Üët
f : ‚Üës ‚äï ‚Üët ‚âÉ Œ± := sorryAx (‚Üës ‚äï ‚Üët ‚âÉ Œ±) true
hle : coinduced (‚áëf) instTopologicalSpaceSum ‚â§ inst‚úù¬π
‚ä¢ IsOpen ((fun x ‚Ü¶ (sorryAx (‚Üës ‚äï ‚Üët ‚âÉ Œ±) true) (Sum.inl x)) ‚Åª¬π' s) ‚àß
    IsOpen ((fun x ‚Ü¶ (sorryAx (‚Üës ‚äï ‚Üët ‚âÉ Œ±) true) (Sum.inr x)) ‚Åª¬π' s)","theorem _root_.IsClosed.isClopenable [TopologicalSpace Œ±] [PolishSpace Œ±] {s : Set Œ±}
    (hs : IsClosed s) : IsClopenable s ",":= by
  classical
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫ := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    simp [f, preimage_preimage]",":= by
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫ := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    simp [f, preimage_preimage]"
Mathlib/Analysis/Fourier/AddCircle.lean,hasSum_fourier_series_of_summable,hasSum_fourier_series_of_summable,738ad0b1a96ead61d11b270ccd006461d3eb7397,":= by
  have sum_L2 := hasSum_fourier_series_L2 (toLp (E := ‚ÑÇ) 2 haarAddCircle ‚ÑÇ f)
  simp_rw [fourierCoeff_toLp] at sum_L2
  refine' ContinuousMap.hasSum_of_hasSum_Lp (summable_of_summable_norm _) sum_L2
  simp_rw [norm_smul, fourier_norm, mul_one, summable_norm_iff]
  exact h","error:  unknown identifier 'summable_of_summable_norm'
error:  no goals to be solved","theorem hasSum_fourier_series_of_summable (h : Summable (fourierCoeff f)) :
    HasSum (fun i => fourierCoeff f i ‚Ä¢ fourier i) f ",":= by
  have sum_L2 := hasSum_fourier_series_L2 (toLp (E := ‚ÑÇ) 2 haarAddCircle ‚ÑÇ f)
  simp_rw [fourierCoeff_toLp] at sum_L2
  refine ContinuousMap.hasSum_of_hasSum_Lp (.of_norm ?_) sum_L2
  simp_rw [norm_smul, fourier_norm, mul_one]
  exact h.norm",":= by
  have sum_L2 := hasSum_fourier_series_L2 (toLp (E := ‚ÑÇ) 2 haarAddCircle ‚ÑÇ f)
  simp_rw [fourierCoeff_toLp] at sum_L2
  refine ContinuousMap.hasSum_of_hasSum_Lp (summable_of_summable_norm _) sum_L2
  simp_rw [norm_smul, fourier_norm, mul_one, summable_norm_iff]
  exact h"
Mathlib/Data/Finset/Basic.lean,Finset.toList_cons,toList_cons,818337c6bd6587795f69dffefeeae7988f4bdba8,":=
  (List.perm_ext (nodup_toList _) (by simp [h, nodup_toList s])).2 fun x => by
    simp only [List.mem_cons, Finset.mem_toList, Finset.mem_cons]",error:  unknown constant 'List.perm_ext',theorem toList_cons {a : Œ±} {s : Finset Œ±} (h : a ‚àâ s) : (cons a s h).toList ~ a :: s.toList ,":=
  (List.perm_ext_iff_of_nodup (nodup_toList _) (by simp [h, nodup_toList s])).2 fun x => by
    simp only [List.mem_cons, Finset.mem_toList, Finset.mem_cons]",":=
  (List.perm_ext (nodup_toList _) (by simp [h, nodup_toList s])).2 fun x => by
    simp only [List.mem_cons, Finset.mem_toList, Finset.mem_cons]"
Mathlib/Algebra/MvPolynomial/Derivation.lean,MvPolynomial.leibniz_iff_X,leibniz_iff_X,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  refine ‚ü®fun H p i => H _ _, fun H => ?_‚ü©
  have hC : ‚àÄ r, D (C r) = 0 := by intro r; rw [C_eq_smul_one, D.map_smul, h‚ÇÅ, smul_zero]
  have : ‚àÄ p i, D (p * X i) = p ‚Ä¢ D (X i) + (X i : MvPolynomial œÉ R) ‚Ä¢ D p := by
    intro p i
    induction' p using MvPolynomial.induction_on' with s r p q hp hq
    ¬∑ rw [‚Üê mul_one r, ‚Üê C_mul_monomial, mul_assoc, C_mul', D.map_smul, H, C_mul', smul_assoc,
        smul_add, D.map_smul, smul_comm r (X i)]
    ¬∑ rw [add_mul, map_add, map_add, hp, hq, add_smul, smul_add, add_add_add_comm]
  intro p q
  induction q with
  | h_C c =>
    rw [mul_comm, C_mul', hC, smul_zero, zero_add, D.map_smul, C_eq_smul_one, smul_one_smul]
  | h_add q‚ÇÅ q‚ÇÇ h‚ÇÅ h‚ÇÇ => simp only [mul_add, map_add, h‚ÇÅ, h‚ÇÇ, smul_add, add_smul]; abel
  | h_X q i hq =>
    simp only [this, ‚Üê mul_assoc, hq, mul_smul, smul_add, add_assoc]
    rw [smul_comm (X i), smul_comm (X i)]",error:  invalid alternative name 'h_C',"theorem leibniz_iff_X (D : MvPolynomial œÉ R ‚Üí‚Çó[R] A) (h‚ÇÅ : D 1 = 0) :
    (‚àÄ p q, D (p * q) = p ‚Ä¢ D q + q ‚Ä¢ D p) ‚Üî ‚àÄ s i, D (monomial s 1 * X i) =
    (monomial s 1 : MvPolynomial œÉ R) ‚Ä¢ D (X i) + (X i : MvPolynomial œÉ R) ‚Ä¢ D (monomial s 1) ",":= by
  refine ‚ü®fun H p i => H _ _, fun H => ?_‚ü©
  have hC : ‚àÄ r, D (C r) = 0 := by intro r; rw [C_eq_smul_one, D.map_smul, h‚ÇÅ, smul_zero]
  have : ‚àÄ p i, D (p * X i) = p ‚Ä¢ D (X i) + (X i : MvPolynomial œÉ R) ‚Ä¢ D p := by
    intro p i
    induction' p using MvPolynomial.induction_on' with s r p q hp hq
    ¬∑ rw [‚Üê mul_one r, ‚Üê C_mul_monomial, mul_assoc, C_mul', D.map_smul, H, C_mul', smul_assoc,
        smul_add, D.map_smul, smul_comm r (X i)]
    ¬∑ rw [add_mul, map_add, map_add, hp, hq, add_smul, smul_add, add_add_add_comm]
  intro p q
  induction q using MvPolynomial.induction_on with
  | h_C c =>
    rw [mul_comm, C_mul', hC, smul_zero, zero_add, D.map_smul, C_eq_smul_one, smul_one_smul]
  | h_add q‚ÇÅ q‚ÇÇ h‚ÇÅ h‚ÇÇ => simp only [mul_add, map_add, h‚ÇÅ, h‚ÇÇ, smul_add, add_smul]; abel
  | h_X q i hq =>
    simp only [this, ‚Üê mul_assoc, hq, mul_smul, smul_add, add_assoc]
    rw [smul_comm (X i), smul_comm (X i)]",":= by
  refine ‚ü®fun H p i => H _ _, fun H => ?_‚ü©
  have hC : ‚àÄ r, D (C r) = 0 := by intro r; rw [C_eq_smul_one, D.map_smul, h‚ÇÅ, smul_zero]
  have : ‚àÄ p i, D (p * X i) = p ‚Ä¢ D (X i) + (X i : MvPolynomial œÉ R) ‚Ä¢ D p := by
    intro p i
    induction' p using MvPolynomial.induction_on' with s r p q hp hq
    ¬∑ rw [‚Üê mul_one r, ‚Üê C_mul_monomial, mul_assoc, C_mul', D.map_smul, H, C_mul', smul_assoc,
        smul_add, D.map_smul, smul_comm r (X i)]
    ¬∑ rw [add_mul, map_add, map_add, hp, hq, add_smul, smul_add, add_add_add_comm]
  intro p q
  induction q with
  | h_C c =>
    rw [mul_comm, C_mul', hC, smul_zero, zero_add, D.map_smul, C_eq_smul_one, smul_one_smul]
  | h_add q‚ÇÅ q‚ÇÇ h‚ÇÅ h‚ÇÇ => simp only [mul_add, map_add, h‚ÇÅ, h‚ÇÇ, smul_add, add_smul]; abel
  | h_X q i hq =>
    simp only [this, ‚Üê mul_assoc, hq, mul_smul, smul_add, add_assoc]
    rw [smul_comm (X i), smul_comm (X i)]"
Mathlib/Topology/UniformSpace/Basic.lean,symm_of_uniformity,symm_of_uniformity,f33a8c19a1c116af0ea9bb6af0c85b1ef25cb15f,":=
  have : preimage Prod.swap s ‚àà ùì§ Œ± := symm_le_uniformity hs
  ‚ü®s ‚à© preimage Prod.swap s, inter_mem hs this, fun _ _ ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©, inter_subset_left _ _‚ü©","warning:  @compRel does not have a doc string
warning:  uniformity does not have a doc string
error:  function expected at
  inter_subset_left ?m.41194
term has type
  ?m.41193 ‚àà ?m.41191","theorem symm_of_uniformity {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) :
    ‚àÉ t ‚àà ùì§ Œ±, (‚àÄ a b, (a, b) ‚àà t ‚Üí (b, a) ‚àà t) ‚àß t ‚äÜ s ",":=
  have : preimage Prod.swap s ‚àà ùì§ Œ± := symm_le_uniformity hs
  ‚ü®s ‚à© preimage Prod.swap s, inter_mem hs this, fun _ _ ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©, inter_subset_left‚ü©",":=
  have : preimage Prod.swap s ‚àà ùì§ Œ± := symm_le_uniformity hs
  ‚ü®s ‚à© preimage Prod.swap s, inter_mem hs this, fun _ _ ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©, inter_subset_left‚ü©"
Mathlib/Data/List/Cycle.lean,List.next_getLast_cons,next_getLast_cons,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [next, get, ‚Üê dropLast_append_getLast (cons_ne_nil y l), hx, nextOr_concat]
  subst hx
  intro H
  obtain ‚ü®‚ü®_ | k, hk‚ü©, hk'‚ü© := get_of_mem H
  ¬∑ rw [‚Üê Option.some_inj] at hk'
    rw [‚Üê get?_eq_get, dropLast_eq_take, get?_take, get?_zero, head?_cons,
      Option.some_inj] at hk'
    ¬∑ exact hy (Eq.symm hk')
    rw [Nat.zero_eq, length_cons, Nat.pred_succ]
    exact length_pos_of_mem (by assumption)
  suffices k.succ = l.length by simp [this] at hk
  cases' l with hd tl
  ¬∑ simp at hk
  ¬∑ rw [nodup_iff_injective_get] at hl
    rw [length, Nat.succ_inj']
    refine Fin.val_eq_of_eq <| @hl ‚ü®k, Nat.lt_of_succ_lt <| by simpa using hk‚ü©
      ‚ü®tl.length, by simp‚ü© ?_
    rw [‚Üê Option.some_inj] at hk'
    rw [‚Üê get?_eq_get, dropLast_eq_take, get?_take, get?, get?_eq_get, Option.some_inj] at hk'
    ¬∑ rw [hk']
      simp only [getLast_eq_get, length_cons, ge_iff_le, Nat.succ_sub_succ_eq_sub,
        nonpos_iff_eq_zero, add_eq_zero_iff, and_false, tsub_zero, get_cons_succ]
    simpa using hk","warning:  `List.get?_take` has been deprecated, use `List.getElem?_take` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case h.intro.mk.zero
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
l : List Œ±
y : Œ±
hl : l.Nodup
h‚úù : (y :: l).getLast ‚ãØ ‚àà l
h : (y :: l).getLast ‚ãØ ‚àà y :: l
hy : (y :: l).getLast ‚ãØ ‚â† y
H : (y :: l).getLast ‚ãØ ‚àà (y :: l).dropLast
hk : 0 < (y :: l).dropLast.length
hk' : (take (y :: l).length.pred (y :: l)).get? 0 = some ((y :: l).getLast ‚ãØ)
‚ä¢ 0 < (y :: l).length.pred
error:  unsolved goals
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
l : List Œ±
y : Œ±
hl : l.Nodup
h‚úù : (y :: l).getLast ‚ãØ ‚àà l
h : (y :: l).getLast ‚ãØ ‚àà y :: l
hy : (y :: l).getLast ‚ãØ ‚â† y
H : (y :: l).getLast ‚ãØ ‚àà (y :: l).dropLast
k : ‚Ñï
hk‚úù : k + 1 < (y :: l).dropLast.length
hk' : (y :: l).dropLast.get ‚ü®k + 1, hk‚úù‚ü© = (y :: l).getLast ‚ãØ
this : k.succ = l.length
hk : k + 1 < l.length
‚ä¢ False
warning:  `List.get?_take` has been deprecated, use `List.getElem?_take` instead
error:  unsolved goals
case h.intro.mk.succ.cons
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
y : Œ±
k : ‚Ñï
hd : Œ±
tl : List Œ±
hl : Function.Injective (hd :: tl).get
h‚úù : (y :: hd :: tl).getLast ‚ãØ ‚àà hd :: tl
h : (y :: hd :: tl).getLast ‚ãØ ‚àà y :: hd :: tl
hy : (y :: hd :: tl).getLast ‚ãØ ‚â† y
H : (y :: hd :: tl).getLast ‚ãØ ‚àà (y :: hd :: tl).dropLast
hk : k + 1 < (y :: hd :: tl).dropLast.length
hk'‚úù : (hd :: tl).get? k = some ((y :: hd :: tl).getLast ‚ãØ)
hk' : (hd :: tl).get ‚ü®k, ‚ãØ‚ü© = (y :: hd :: tl).getLast ‚ãØ
‚ä¢ (y :: hd :: tl).get ‚ü®tl.length + 1 - 0, ‚ãØ‚ü© = (hd :: tl).get ‚ü®tl.length, ‚ãØ‚ü©
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead","theorem next_getLast_cons (h : x ‚àà l) (y : Œ±) (h : x ‚àà y :: l) (hy : x ‚â† y)
    (hx : x = getLast (y :: l) (cons_ne_nil _ _)) (hl : Nodup l) : next (y :: l) x h = y ",":= by
  rw [next, get, ‚Üê dropLast_append_getLast (cons_ne_nil y l), hx, nextOr_concat]
  subst hx
  intro H
  obtain ‚ü®‚ü®_ | k, hk‚ü©, hk'‚ü© := get_of_mem H
  ¬∑ rw [‚Üê Option.some_inj] at hk'
    rw [‚Üê get?_eq_get, dropLast_eq_take, get?_eq_getElem?, getElem?_take, getElem?_cons_zero,
      Option.some_inj] at hk'
    ¬∑ exact hy (Eq.symm hk')
    rw [length_cons, Nat.pred_succ]
    exact length_pos_of_mem (by assumption)
  suffices k + 1 = l.length by simp [this] at hk
  cases' l with hd tl
  ¬∑ simp at hk
  ¬∑ rw [nodup_iff_injective_get] at hl
    rw [length, Nat.succ_inj']
    refine Fin.val_eq_of_eq <| @hl ‚ü®k, Nat.lt_of_succ_lt <| by simpa using hk‚ü©
      ‚ü®tl.length, by simp‚ü© ?_
    rw [‚Üê Option.some_inj] at hk'
    rw [‚Üê get?_eq_get, dropLast_eq_take, get?_eq_getElem?, getElem?_take, getElem?_cons_succ,
      getElem?_eq_getElem, Option.some_inj] at hk'
    ¬∑ rw [get_eq_getElem, hk']
      simp only [getLast_eq_get, length_cons, Nat.succ_eq_add_one, Nat.succ_sub_succ_eq_sub,
        Nat.sub_zero, get_eq_getElem, getElem_cons_succ]
    simpa using hk",":= by
  rw [next, get, ‚Üê dropLast_append_getLast (cons_ne_nil y l), hx, nextOr_concat]
  subst hx
  intro H
  obtain ‚ü®‚ü®_ | k, hk‚ü©, hk'‚ü© := get_of_mem H
  ¬∑ rw [‚Üê Option.some_inj] at hk'
    rw [‚Üê get?_eq_get, dropLast_eq_take, get?_take, get?_zero, head?_cons,
      Option.some_inj] at hk'
    ¬∑ exact hy (Eq.symm hk')
    rw [Nat.zero_eq, length_cons, Nat.pred_succ]
    exact length_pos_of_mem (by assumption)
  suffices k.succ = l.length by simp [this] at hk
  cases' l with hd tl
  ¬∑ simp at hk
  ¬∑ rw [nodup_iff_injective_get] at hl
    rw [length, Nat.succ_inj']
    refine Fin.val_eq_of_eq <| @hl ‚ü®k, Nat.lt_of_succ_lt <| by simpa using hk‚ü©
      ‚ü®tl.length, by simp‚ü© ?_
    rw [‚Üê Option.some_inj] at hk'
    rw [‚Üê get?_eq_get, dropLast_eq_take, get?_take, get?_eq_get, Option.some_inj] at hk'
    ¬∑ rw [hk']
      simp only [getLast_eq_get, length_cons, ge_iff_le, Nat.succ_sub_succ_eq_sub,
        nonpos_iff_eq_zero, add_eq_zero_iff, and_false, tsub_zero, get_cons_succ]
    simpa using hk"
Mathlib/Topology/Order/ScottTopology.lean,Topology.IsScott.isClosed_Iic,isClosed_Iic,86046116b1f3be130d519aa69b2f2ae5b69e5093,":=
  isClosed_iff_isLowerSet_and_dirSupClosed.2 ‚ü®isLowerSet_Iic _, dirSupClosedOn_Iic _‚ü©",error:  unknown identifier 'dirSupClosedOn_Iic',lemma isClosed_Iic : IsClosed (Iic a) ,":=
  isClosed_iff_isLowerSet_and_dirSupClosed.2 ‚ü®isLowerSet_Iic _, dirSupClosed_Iic _‚ü©",":=
  isClosed_iff_isLowerSet_and_dirSupClosed.2 ‚ü®isLowerSet_Iic, dirSupClosedOn_Iic _‚ü©"
Mathlib/Analysis/Fourier/RiemannLebesgueLemma.lean,tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support,tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support,7dc162787d2a79bf721a83a87f641ace70251b17,":= by
  refine' NormedAddCommGroup.tendsto_nhds_zero.mpr fun Œµ hŒµ => _
  suffices ‚àÉ T : ‚Ñù, ‚àÄ w : V, T ‚â§ ‚Äñw‚Äñ ‚Üí ‚Äñ‚à´ v : V, ùêû (-‚ü™v, w‚ü´) ‚Ä¢ f v‚Äñ < Œµ by
    simp_rw [‚Üê comap_dist_left_atTop_eq_cocompact (0 : V), eventually_comap, eventually_atTop,
      dist_eq_norm', sub_zero]
    exact
      let ‚ü®T, hT‚ü© := this
      ‚ü®T, fun b hb v hv => hT v (hv.symm ‚ñ∏ hb)‚ü©
  obtain ‚ü®R, -, hR_bd‚ü© : ‚àÉ R : ‚Ñù, 0 < R ‚àß ‚àÄ x : V, R ‚â§ ‚Äñx‚Äñ ‚Üí f x = 0 := hf2.exists_pos_le_norm
  let A := {v : V | ‚Äñv‚Äñ ‚â§ R + 1}
  have mA : MeasurableSet A := by
    suffices A = Metric.closedBall (0 : V) (R + 1) by
      rw [this]
      exact Metric.isClosed_ball.measurableSet
    simp_rw [Metric.closedBall, dist_eq_norm, sub_zero]
  obtain ‚ü®B, hB_pos, hB_vol‚ü© : ‚àÉ B : ‚Ñù‚â•0, 0 < B ‚àß volume A ‚â§ B := by
    have hc : IsCompact A := by
      simpa only [Metric.closedBall, dist_eq_norm, sub_zero] using isCompact_closedBall (0 : V) _
    let B‚ÇÄ := volume A
    replace hc : B‚ÇÄ < ‚ä§ := hc.measure_lt_top
    refine' ‚ü®B‚ÇÄ.toNNReal + 1, add_pos_of_nonneg_of_pos B‚ÇÄ.toNNReal.coe_nonneg one_pos, _‚ü©
    rw [ENNReal.coe_add, ENNReal.coe_one, ENNReal.coe_toNNReal hc.ne]
    exact le_self_add
  obtain ‚ü®Œ¥, hŒ¥1, hŒ¥2‚ü© :=
    Metric.uniformContinuous_iff.mp (hf2.uniformContinuous_of_continuous hf1) (Œµ / B)
      (div_pos hŒµ hB_pos)
  refine' ‚ü®1 / 2 + 1 / (2 * Œ¥), fun w hw_bd => _‚ü©
  have hw_ne : w ‚â† 0 := by
    contrapose! hw_bd; rw [hw_bd, norm_zero]
    exact add_pos one_half_pos (one_div_pos.mpr <| mul_pos two_pos hŒ¥1)
  have hw'_nm : ‚Äñi w‚Äñ = 1 / (2 * ‚Äñw‚Äñ) := by
    rw [norm_smul, norm_div, Real.norm_of_nonneg (mul_nonneg two_pos.le <| sq_nonneg _), norm_one,
      sq, ‚Üê div_div, ‚Üê div_div, ‚Üê div_div, div_mul_cancel‚ÇÄ _ (norm_eq_zero.not.mpr hw_ne)]
  have : ‚Äñ(1 / 2 : ‚ÑÇ)‚Äñ = 2‚Åª¬π := by norm_num
  rw [fourier_integral_eq_half_sub_half_period_translate hw_ne
      (hf1.integrable_of_hasCompactSupport hf2),
    norm_smul, this, inv_mul_eq_div, div_lt_iff' two_pos]
  refine' lt_of_le_of_lt (norm_integral_le_integral_norm _) _
  simp_rw [norm_circle_smul]
  have int_A : ‚à´ v : V, ‚Äñf v - f (v + i w)‚Äñ = ‚à´ v in A, ‚Äñf v - f (v + i w)‚Äñ := by
    refine' (set_integral_eq_integral_of_forall_compl_eq_zero fun v hv => _).symm
    dsimp only [A] at hv
    simp only [mem_setOf, not_le] at hv
    rw [hR_bd v _, hR_bd (v + i w) _, sub_zero, norm_zero]
    ¬∑ rw [‚Üê sub_neg_eq_add]
      refine' le_trans _ (norm_sub_norm_le _ _)
      rw [le_sub_iff_add_le, norm_neg]
      refine' le_trans _ hv.le
      rw [add_le_add_iff_left, hw'_nm, ‚Üê div_div]
      refine' (div_le_one <| norm_pos_iff.mpr hw_ne).mpr _
      refine' le_trans (le_add_of_nonneg_right <| one_div_nonneg.mpr <| _) hw_bd
      exact (mul_pos (zero_lt_two' ‚Ñù) hŒ¥1).le
    ¬∑ exact (le_add_of_nonneg_right zero_le_one).trans hv.le
  rw [int_A]; clear int_A
  have bdA : ‚àÄ v : V, v ‚àà A ‚Üí ‚Äñ‚Äñf v - f (v + i w)‚Äñ‚Äñ ‚â§ Œµ / B := by
    simp_rw [norm_norm]
    simp_rw [dist_eq_norm] at hŒ¥2
    refine' fun x _ => (hŒ¥2 _).le
    rw [sub_add_cancel_left, norm_neg, hw'_nm, ‚Üê div_div, div_lt_iff (norm_pos_iff.mpr hw_ne), ‚Üê
      div_lt_iff' hŒ¥1, div_div]
    exact (lt_add_of_pos_left _ one_half_pos).trans_le hw_bd
  have bdA2 := norm_set_integral_le_of_norm_le_const (hB_vol.trans_lt ENNReal.coe_lt_top) bdA ?_
  swap
  ¬∑ apply Continuous.aestronglyMeasurable
    exact
      continuous_norm.comp <|
        Continuous.sub hf1 <| Continuous.comp hf1 <| continuous_id'.add continuous_const
  have : ‚Äñ_‚Äñ = ‚à´ v : V in A, ‚Äñf v - f (v + i w)‚Äñ :=
    Real.norm_of_nonneg (set_integral_nonneg mA fun x _ => norm_nonneg _)
  rw [this] at bdA2
  refine' bdA2.trans_lt _
  rw [div_mul_eq_mul_div, div_lt_iff (NNReal.coe_pos.mpr hB_pos), mul_comm (2 : ‚Ñù), mul_assoc,
    mul_lt_mul_left hŒµ]
  rw [‚Üê ENNReal.toReal_le_toReal] at hB_vol
  ¬∑ refine' hB_vol.trans_lt _
    rw [(by rfl : (‚ÜëB : ENNReal).toReal = ‚ÜëB), two_mul]
    exact lt_add_of_pos_left _ hB_pos
  exacts [(hB_vol.trans_lt ENNReal.coe_lt_top).ne, ENNReal.coe_lt_top.ne]","error:  unknown identifier 'fourier_integral_eq_half_sub_half_period_translate'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.94353
case intro.intro.intro.intro.intro.intro
E : Type u_1
V : Type u_2
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ‚ÑÇ E
f : V ‚Üí E
inst‚úù‚Åµ : NormedAddCommGroup V
inst‚úù‚Å¥ : MeasurableSpace V
inst‚úù¬≥ : BorelSpace V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : FiniteDimensional ‚Ñù V
inst‚úù : CompleteSpace E
hf1 : Continuous f
hf2 : HasCompactSupport f
Œµ : ‚Ñù
hŒµ : Œµ > 0
R : ‚Ñù
hR_bd : ‚àÄ (x : V), R ‚â§ ‚Äñx‚Äñ ‚Üí f x = 0
A : Set V := {v | ‚Äñv‚Äñ ‚â§ R + 1}
mA : MeasurableSet A
B : ‚Ñù‚â•0
hB_pos : 0 < B
hB_vol : volume A ‚â§ ‚ÜëB
Œ¥ : ‚Ñù
hŒ¥1 : Œ¥ > 0
hŒ¥2 : ‚àÄ {a b : V}, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ / ‚ÜëB
w : V
hw_bd : 1 / 2 + 1 / (2 * Œ¥) ‚â§ ‚Äñw‚Äñ
hw_ne : w ‚â† 0
hw'_nm : ‚Äñi w‚Äñ = 1 / (2 * ‚Äñw‚Äñ)
this : ‚Äñ1 / 2‚Äñ = 2‚Åª¬π
‚ä¢ ‚Äñ‚à´ (v : V), ùêû (-‚ü™v, w‚ü´_‚Ñù) ‚Ä¢ f v‚Äñ < Œµ","theorem tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support (hf1 : Continuous f)
    (hf2 : HasCompactSupport f) :
    Tendsto (fun w : V => ‚à´ v : V, ùêû (-‚ü™v, w‚ü´) ‚Ä¢ f v) (cocompact V) (ùìù 0) ",":= by
  refine NormedAddCommGroup.tendsto_nhds_zero.mpr fun Œµ hŒµ => ?_
  suffices ‚àÉ T : ‚Ñù, ‚àÄ w : V, T ‚â§ ‚Äñw‚Äñ ‚Üí ‚Äñ‚à´ v : V, ùêû (-‚ü™v, w‚ü´) ‚Ä¢ f v‚Äñ < Œµ by
    simp_rw [‚Üê comap_dist_left_atTop_eq_cocompact (0 : V), eventually_comap, eventually_atTop,
      dist_eq_norm', sub_zero]
    exact
      let ‚ü®T, hT‚ü© := this
      ‚ü®T, fun b hb v hv => hT v (hv.symm ‚ñ∏ hb)‚ü©
  obtain ‚ü®R, -, hR_bd‚ü© : ‚àÉ R : ‚Ñù, 0 < R ‚àß ‚àÄ x : V, R ‚â§ ‚Äñx‚Äñ ‚Üí f x = 0 := hf2.exists_pos_le_norm
  let A := {v : V | ‚Äñv‚Äñ ‚â§ R + 1}
  have mA : MeasurableSet A := by
    suffices A = Metric.closedBall (0 : V) (R + 1) by
      rw [this]
      exact Metric.isClosed_ball.measurableSet
    simp_rw [Metric.closedBall, dist_eq_norm, sub_zero]
  obtain ‚ü®B, hB_pos, hB_vol‚ü© : ‚àÉ B : ‚Ñù‚â•0, 0 < B ‚àß volume A ‚â§ B := by
    have hc : IsCompact A := by
      simpa only [Metric.closedBall, dist_eq_norm, sub_zero] using isCompact_closedBall (0 : V) _
    let B‚ÇÄ := volume A
    replace hc : B‚ÇÄ < ‚ä§ := hc.measure_lt_top
    refine ‚ü®B‚ÇÄ.toNNReal + 1, add_pos_of_nonneg_of_pos B‚ÇÄ.toNNReal.coe_nonneg one_pos, ?_‚ü©
    rw [ENNReal.coe_add, ENNReal.coe_one, ENNReal.coe_toNNReal hc.ne]
    exact le_self_add
  obtain ‚ü®Œ¥, hŒ¥1, hŒ¥2‚ü© :=
    Metric.uniformContinuous_iff.mp (hf2.uniformContinuous_of_continuous hf1) (Œµ / B)
      (div_pos hŒµ hB_pos)
  refine ‚ü®1 / 2 + 1 / (2 * Œ¥), fun w hw_bd => ?_‚ü©
  have hw_ne : w ‚â† 0 := by
    contrapose! hw_bd; rw [hw_bd, norm_zero]
    exact add_pos one_half_pos (one_div_pos.mpr <| mul_pos two_pos hŒ¥1)
  have hw'_nm : ‚Äñi w‚Äñ = 1 / (2 * ‚Äñw‚Äñ) := by
    rw [norm_smul, norm_div, Real.norm_of_nonneg (mul_nonneg two_pos.le <| sq_nonneg _), norm_one,
      sq, ‚Üê div_div, ‚Üê div_div, ‚Üê div_div, div_mul_cancel‚ÇÄ _ (norm_eq_zero.not.mpr hw_ne)]
  have : ‚Äñ(1 / 2 : ‚ÑÇ)‚Äñ = 2‚Åª¬π := by norm_num
  rw [fourierIntegral_eq_half_sub_half_period_translate hw_ne
      (hf1.integrable_of_hasCompactSupport hf2),
    norm_smul, this, inv_mul_eq_div, div_lt_iff' two_pos]
  refine lt_of_le_of_lt (norm_integral_le_integral_norm _) ?_
  simp_rw [norm_circle_smul]
  have int_A : ‚à´ v : V, ‚Äñf v - f (v + i w)‚Äñ = ‚à´ v in A, ‚Äñf v - f (v + i w)‚Äñ := by
    refine (setIntegral_eq_integral_of_forall_compl_eq_zero fun v hv => ?_).symm
    dsimp only [A] at hv
    simp only [mem_setOf, not_le] at hv
    rw [hR_bd v _, hR_bd (v + i w) _, sub_zero, norm_zero]
    ¬∑ rw [‚Üê sub_neg_eq_add]
      refine le_trans ?_ (norm_sub_norm_le _ _)
      rw [le_sub_iff_add_le, norm_neg]
      refine le_trans ?_ hv.le
      rw [add_le_add_iff_left, hw'_nm, ‚Üê div_div]
      refine (div_le_one <| norm_pos_iff.mpr hw_ne).mpr ?_
      refine le_trans (le_add_of_nonneg_right <| one_div_nonneg.mpr <| ?_) hw_bd
      exact (mul_pos (zero_lt_two' ‚Ñù) hŒ¥1).le
    ¬∑ exact (le_add_of_nonneg_right zero_le_one).trans hv.le
  rw [int_A]; clear int_A
  have bdA : ‚àÄ v : V, v ‚àà A ‚Üí ‚Äñ‚Äñf v - f (v + i w)‚Äñ‚Äñ ‚â§ Œµ / B := by
    simp_rw [norm_norm]
    simp_rw [dist_eq_norm] at hŒ¥2
    refine fun x _ => (hŒ¥2 ?_).le
    rw [sub_add_cancel_left, norm_neg, hw'_nm, ‚Üê div_div, div_lt_iff (norm_pos_iff.mpr hw_ne), ‚Üê
      div_lt_iff' hŒ¥1, div_div]
    exact (lt_add_of_pos_left _ one_half_pos).trans_le hw_bd
  have bdA2 := norm_setIntegral_le_of_norm_le_const (hB_vol.trans_lt ENNReal.coe_lt_top) bdA ?_
  swap
  ¬∑ apply Continuous.aestronglyMeasurable
    exact
      continuous_norm.comp <|
        Continuous.sub hf1 <| Continuous.comp hf1 <| continuous_id'.add continuous_const
  have : ‚Äñ_‚Äñ = ‚à´ v : V in A, ‚Äñf v - f (v + i w)‚Äñ :=
    Real.norm_of_nonneg (setIntegral_nonneg mA fun x _ => norm_nonneg _)
  rw [this] at bdA2
  refine bdA2.trans_lt ?_
  rw [div_mul_eq_mul_div, div_lt_iff (NNReal.coe_pos.mpr hB_pos), mul_comm (2 : ‚Ñù), mul_assoc,
    mul_lt_mul_left hŒµ]
  rw [‚Üê ENNReal.toReal_le_toReal] at hB_vol
  ¬∑ refine hB_vol.trans_lt ?_
    rw [(by rfl : (‚ÜëB : ENNReal).toReal = ‚ÜëB), two_mul]
    exact lt_add_of_pos_left _ hB_pos
  exacts [(hB_vol.trans_lt ENNReal.coe_lt_top).ne, ENNReal.coe_lt_top.ne]",":= by
  refine NormedAddCommGroup.tendsto_nhds_zero.mpr fun Œµ hŒµ => ?_
  suffices ‚àÉ T : ‚Ñù, ‚àÄ w : V, T ‚â§ ‚Äñw‚Äñ ‚Üí ‚Äñ‚à´ v : V, ùêû (-‚ü™v, w‚ü´) ‚Ä¢ f v‚Äñ < Œµ by
    simp_rw [‚Üê comap_dist_left_atTop_eq_cocompact (0 : V), eventually_comap, eventually_atTop,
      dist_eq_norm', sub_zero]
    exact
      let ‚ü®T, hT‚ü© := this
      ‚ü®T, fun b hb v hv => hT v (hv.symm ‚ñ∏ hb)‚ü©
  obtain ‚ü®R, -, hR_bd‚ü© : ‚àÉ R : ‚Ñù, 0 < R ‚àß ‚àÄ x : V, R ‚â§ ‚Äñx‚Äñ ‚Üí f x = 0 := hf2.exists_pos_le_norm
  let A := {v : V | ‚Äñv‚Äñ ‚â§ R + 1}
  have mA : MeasurableSet A := by
    suffices A = Metric.closedBall (0 : V) (R + 1) by
      rw [this]
      exact Metric.isClosed_ball.measurableSet
    simp_rw [Metric.closedBall, dist_eq_norm, sub_zero]
  obtain ‚ü®B, hB_pos, hB_vol‚ü© : ‚àÉ B : ‚Ñù‚â•0, 0 < B ‚àß volume A ‚â§ B := by
    have hc : IsCompact A := by
      simpa only [Metric.closedBall, dist_eq_norm, sub_zero] using isCompact_closedBall (0 : V) _
    let B‚ÇÄ := volume A
    replace hc : B‚ÇÄ < ‚ä§ := hc.measure_lt_top
    refine ‚ü®B‚ÇÄ.toNNReal + 1, add_pos_of_nonneg_of_pos B‚ÇÄ.toNNReal.coe_nonneg one_pos, ?_‚ü©
    rw [ENNReal.coe_add, ENNReal.coe_one, ENNReal.coe_toNNReal hc.ne]
    exact le_self_add
  obtain ‚ü®Œ¥, hŒ¥1, hŒ¥2‚ü© :=
    Metric.uniformContinuous_iff.mp (hf2.uniformContinuous_of_continuous hf1) (Œµ / B)
      (div_pos hŒµ hB_pos)
  refine ‚ü®1 / 2 + 1 / (2 * Œ¥), fun w hw_bd => ?_‚ü©
  have hw_ne : w ‚â† 0 := by
    contrapose! hw_bd; rw [hw_bd, norm_zero]
    exact add_pos one_half_pos (one_div_pos.mpr <| mul_pos two_pos hŒ¥1)
  have hw'_nm : ‚Äñi w‚Äñ = 1 / (2 * ‚Äñw‚Äñ) := by
    rw [norm_smul, norm_div, Real.norm_of_nonneg (mul_nonneg two_pos.le <| sq_nonneg _), norm_one,
      sq, ‚Üê div_div, ‚Üê div_div, ‚Üê div_div, div_mul_cancel‚ÇÄ _ (norm_eq_zero.not.mpr hw_ne)]
  have : ‚Äñ(1 / 2 : ‚ÑÇ)‚Äñ = 2‚Åª¬π := by norm_num
  rw [fourier_integral_eq_half_sub_half_period_translate hw_ne
      (hf1.integrable_of_hasCompactSupport hf2),
    norm_smul, this, inv_mul_eq_div, div_lt_iff' two_pos]
  refine lt_of_le_of_lt (norm_integral_le_integral_norm _) ?_
  simp_rw [norm_circle_smul]
  have int_A : ‚à´ v : V, ‚Äñf v - f (v + i w)‚Äñ = ‚à´ v in A, ‚Äñf v - f (v + i w)‚Äñ := by
    refine (setIntegral_eq_integral_of_forall_compl_eq_zero fun v hv => ?_).symm
    dsim"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,a8a39f2a9556ea47ea96518d2df01a0c62fc8289,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg ((¬∑ * ¬∑) œÅ) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finran"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding',exists_extension_norm_eq_of_closedEmbedding',161c69c1dbf66cf3c7ec4f648a61551d044a43e4,":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel', pow_succ, mul_assoc]
      refine' (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel']
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := (mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine' tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 _)
    refine' squeeze_zero (fun _ => dist_nonneg) hgf _
    rw [‚Üê zero_mul ‚Äñf‚Äñ]
    refine' (tendsto_pow_atTop_nhds_0_of_lt_1 _ _).mul tendsto_const_nhds <;> norm_num1
  refine' ‚ü®limUnder atTop g, le_antisymm _ _, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine'
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq _
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  application type mismatch
  LE.le.trans (hF_dist (f - (g n).compContinuous e)) (mul_le_mul_of_nonneg_left ?m.115481 ?m.115895)
argument
  mul_le_mul_of_nonneg_left ?m.115481 ?m.115895
has type
  2 / 3 * ‚Äñf - (g n).compContinuous e‚Äñ ‚â§ 2 / 3 * ?m.115476 : Prop
but is expected to have type
  2 / 3 * ‚Äñf - (g n).compContinuous e‚Äñ ‚â§ (2 / 3) ^ n * (2 / 3 * ‚Äñf‚Äñ) : Prop
error:  no goals to be solved
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
warning:  `tendsto_pow_atTop_nhds_0_of_lt_1` has been deprecated, use `tendsto_pow_atTop_nhds_zero_of_lt_one` instead","theorem exists_extension_norm_eq_of_closedEmbedding' (f : X ‚Üí·µá ‚Ñù) (e : C(X, Y))
    (he : ClosedEmbedding e) : ‚àÉ g : Y ‚Üí·µá ‚Ñù, ‚Äñg‚Äñ = ‚Äñf‚Äñ ‚àß g.compContinuous e = f ",":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [‚Üê zero_mul ‚Äñf‚Äñ]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ‚ü®limUnder atTop g, le_antisymm ?_ ?_, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _",":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel', pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel']
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [‚Üê zero_mul ‚Äñf‚Äñ]
    refine (tendsto_pow_atTop_nhds_0_of_lt_1 ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ‚ü®limUnder atTop g, le_antisymm ?_ ?_, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _"
Mathlib/Algebra/BigOperators/Finprod.lean,finprod_mul_distrib,finprod_mul_distrib,f909ab9f9febceb93de8511363cdcc9b1a0d7525,":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset _ hf (Finset.subset_union_left _ _),
      finprod_eq_prod_of_mulSupport_toFinset_subset _ hg (Finset.subset_union_right _ _), ‚Üê
      Finset.prod_mul_distrib]
    refine finprod_eq_prod_of_mulSupport_subset _ ?_
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf, hg‚ü©
    simp [hf, hg]","error:  function expected at
  Finset.subset_union_left ?m.86793
term has type
  ?m.86792 ‚àà ?m.86790 ‚à™ ?m.86791
error:  function expected at
  Finset.subset_union_right ?m.86952
term has type
  ?m.86951 ‚àà ?m.86949 ‚à™ ?m.86950
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
Œπ : Type u_3
G : Type u_4
M : Type u_5
N : Type u_6
inst‚úù¬π : CommMonoid M
inst‚úù : CommMonoid N
f g : Œ± ‚Üí M
a b : Œ±
s t : Set Œ±
hf : (mulSupport f).Finite
hg : (mulSupport g).Finite
‚ä¢ ‚àè·∂† (i : Œ±), f i * g i = ‚àè x ‚àà ?m.87159, f x * g x","theorem finprod_mul_distrib (hf : (mulSupport f).Finite) (hg : (mulSupport g).Finite) :
    ‚àè·∂† i, f i * g i = (‚àè·∂† i, f i) * ‚àè·∂† i, g i ",":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset f hf Finset.subset_union_left,
      finprod_eq_prod_of_mulSupport_toFinset_subset g hg Finset.subset_union_right, ‚Üê
      Finset.prod_mul_distrib]
    refine finprod_eq_prod_of_mulSupport_subset _ ?_
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf, hg‚ü©
    simp [hf, hg]",":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset _ hf (Finset.subset_union_left),
      finprod_eq_prod_of_mulSupport_toFinset_subset _ hg (Finset.subset_union_right), ‚Üê
      Finset.prod_mul_distrib]
    refine finprod_eq_prod_of_mulSupport_subset _ ?_
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf, hg‚ü©
    simp [hf, hg]"
Mathlib/LinearAlgebra/Span.lean,Submodule.finset_span_isCompactElement,finset_span_isCompactElement,ffc60767f0046e59bbedcfc87ae91dab4309f9e1,":= by
  rw [span_eq_iSup_of_singleton_spans]
  simp only [Finset.mem_coe]
  rw [‚Üê Finset.sup_eq_iSup]
  exact
    CompleteLattice.finset_sup_compact_of_compact S fun x _ => singleton_span_isCompactElement x",error:  unknown constant 'CompleteLattice.finset_sup_compact_of_compact',"theorem finset_span_isCompactElement (S : Finset M) :
    CompleteLattice.IsCompactElement (span R S : Submodule R M) ",":= by
  rw [span_eq_iSup_of_singleton_spans]
  simp only [Finset.mem_coe]
  rw [‚Üê Finset.sup_eq_iSup]
  exact
    CompleteLattice.isCompactElement_finsetSup S fun x _ => singleton_span_isCompactElement x",":= by
  rw [span_eq_iSup_of_singleton_spans]
  simp only [Finset.mem_coe]
  rw [‚Üê Finset.sup_eq_iSup]
  exact
    CompleteLattice.finset_sup_compact_of_compact S fun x _ => singleton_span_isCompactElement x"
Mathlib/Algebra/DirectSum/Module.lean,DirectSum.linearMap_ext,linearMap_ext,5068808d2b4c25cf905cf7fee10ded8e447c2346,":=
  Dfinsupp.lhom_ext' H",error:  unknown identifier 'Dfinsupp.lhom_ext'',"theorem linearMap_ext ‚¶Éœà œà' : (‚®Å i, M i) ‚Üí‚Çó[R] N‚¶Ñ
    (H : ‚àÄ i, œà.comp (lof R Œπ M i) = œà'.comp (lof R Œπ M i)) : œà = œà' ",":=
  DFinsupp.lhom_ext' H",":=
  linearMap_ext' H"
Mathlib/Topology/Bases.lean,TopologicalSpace.IsTopologicalBasis.diff_empty,IsTopologicalBasis.diff_empty,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine ‚ü®?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq],? _‚ü©
  ¬∑ rintro t‚ÇÅ ‚ü®h‚ÇÅ, -‚ü© t‚ÇÇ ‚ü®h‚ÇÇ, -‚ü© x hx
    obtain ‚ü®t‚ÇÉ, h‚ÇÉ, hs‚ü© := h.exists_subset_inter _ h‚ÇÅ _ h‚ÇÇ x hx
    exact ‚ü®t‚ÇÉ, ‚ü®h‚ÇÉ, Nonempty.ne_empty ‚ü®x, hs.1‚ü©‚ü©, hs‚ü©
  ¬∑ rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti <| diff_subset s _) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t ‚àÖ
    ¬∑ exact @isOpen_empty _ (generateFrom _)
    ¬∑ exact .basic t ‚ü®ht, he‚ü©","error:  application type mismatch
  diff_subset s
argument
  s
has type
  Set (Set Œ±) : Type u
but is expected to have type
  ?m.1865 ‚àà ?m.1863 \ ?m.1864 : Prop","theorem IsTopologicalBasis.diff_empty {s : Set (Set Œ±)} (h : IsTopologicalBasis s) :
    IsTopologicalBasis (s \ {‚àÖ}) ",":= by
  refine ‚ü®?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_‚ü©
  ¬∑ rintro t‚ÇÅ ‚ü®h‚ÇÅ, -‚ü© t‚ÇÇ ‚ü®h‚ÇÇ, -‚ü© x hx
    obtain ‚ü®t‚ÇÉ, h‚ÇÉ, hs‚ü© := h.exists_subset_inter _ h‚ÇÅ _ h‚ÇÇ x hx
    exact ‚ü®t‚ÇÉ, ‚ü®h‚ÇÉ, Nonempty.ne_empty ‚ü®x, hs.1‚ü©‚ü©, hs‚ü©
  ¬∑ rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti diff_subset) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t ‚àÖ
    ¬∑ exact @isOpen_empty _ (generateFrom _)
    ¬∑ exact .basic t ‚ü®ht, he‚ü©",":= by
  refine ‚ü®?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_‚ü©
  ¬∑ rintro t‚ÇÅ ‚ü®h‚ÇÅ, -‚ü© t‚ÇÇ ‚ü®h‚ÇÇ, -‚ü© x hx
    obtain ‚ü®t‚ÇÉ, h‚ÇÉ, hs‚ü© := h.exists_subset_inter _ h‚ÇÅ _ h‚ÇÇ x hx
    exact ‚ü®t‚ÇÉ, ‚ü®h‚ÇÉ, Nonempty.ne_empty ‚ü®x, hs.1‚ü©‚ü©, hs‚ü©
  ¬∑ rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti <| diff_subset s _) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t ‚àÖ
    ¬∑ exact @isOpen_empty _ (generateFrom _)
    ¬∑ exact .basic t ‚ü®ht, he‚ü©"
Mathlib/Algebra/Polynomial/Eval.lean,Polynomial.eval‚ÇÇ_eq_eval_map,eval‚ÇÇ_eq_eval_map,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction p with
  | h_add p q hp hq =>
    simp [hp, hq]
  | h_monomial n r =>
    simp","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  invalid alternative name 'h_add'",theorem eval‚ÇÇ_eq_eval_map {x : S} : p.eval‚ÇÇ f x = (p.map f).eval x ,":= by
  induction p using Polynomial.induction_on' with
  | h_add p q hp hq =>
    simp [hp, hq]
  | h_monomial n r =>
    simp",":= by
  induction p using Subtype.induction_on with
  | h_add p q hp hq =>
    simp [hp, hq]
  | h_monomial n r =>
    simp"
Mathlib/MeasureTheory/OuterMeasure/Basic.lean,MeasureTheory.measure_diff_null,measure_diff_null,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  (measure_mono <| diff_subset _ _).antisymm <| calc
    Œº s ‚â§ Œº (s ‚à© t) + Œº (s \ t) := measure_le_inter_add_diff _ _ _
    _ ‚â§ Œº t + Œº (s \ t) := by gcongr; apply inter_subset_right
    _ = Œº (s \ t) := by simp [ht]","error:  function expected at
  diff_subset ?m.39824
term has type
  ?m.39823 ‚àà ?m.39821",theorem measure_diff_null (ht : Œº t = 0) : Œº (s \ t) = Œº s ,":=
  (measure_mono diff_subset).antisymm <| calc
    Œº s ‚â§ Œº (s ‚à© t) + Œº (s \ t) := measure_le_inter_add_diff _ _ _
    _ ‚â§ Œº t + Œº (s \ t) := by gcongr; apply inter_subset_right
    _ = Œº (s \ t) := by simp [ht]",":=
  (measure_mono diff_subset).antisymm <| calc
    Œº s ‚â§ Œº (s ‚à© t) + Œº (s \ t) := measure_le_inter_add_diff _ _ _
    _ ‚â§ Œº t + Œº (s \ t) := gcongr; apply inter_subset_right
    _ = Œº (s \ t) := by simp [ht]"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.mul_le_addHaar_image_of_lt_det,mul_le_addHaar_image_of_lt_det,9e34a191034458a56331f976ff7400a26407c888,":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, MulZeroClass.zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases(this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, MulZeroClass.zero_mul] using tendsto_const_nhds
      refine' Tendsto.mul (tendsto_const_nhds.mul _) tendsto_id
      refine' (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ _
      simpa only [tsub_zero, inv_eq_zero, Ne.def] using H
    simp only [MulZeroClass.mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toLocalEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target
  ¬∑ change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne.def] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne.def, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)","error:  unexpected token '¬∑'; expected 'by' or 'from'
error:  unsolved goals
case h
E : Type u_1
F : Type u_2
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : FiniteDimensional ‚Ñù E
inst‚úù‚Å¥ : NormedAddCommGroup F
inst‚úù¬≥ : NormedSpace ‚Ñù F
s‚úù : Set E
f‚úù : E ‚Üí E
f' : E ‚Üí E ‚ÜíL[‚Ñù] E
inst‚úù¬≤ : MeasurableSpace E
inst‚úù¬π : BorelSpace E
Œº : Measure E
inst‚úù : Œº.IsAddHaarMeasure
A : E ‚ÜíL[‚Ñù] E
m : ‚Ñù‚â•0
hm : ‚Üëm < ENNReal.ofReal |A.det|
mpos : 0 < m
hA : A.det ‚â† 0
B : E ‚âÉL[‚Ñù] E := A.toContinuousLinearEquivOfDetNeZero hA
I : ENNReal.ofReal |(‚ÜëB.symm).det| < ‚Üëm‚Åª¬π
Œ¥‚ÇÄ : ‚Ñù‚â•0
Œ¥‚ÇÄpos : 0 < Œ¥‚ÇÄ
hŒ¥‚ÇÄ : ‚àÄ (t : Set E) (g : E ‚Üí E), ApproximatesLinearOn g (‚ÜëB.symm) t Œ¥‚ÇÄ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t
L1 : ‚àÄ·∂† (Œ¥ : ‚Ñù‚â•0) in ùìù 0, Subsingleton E ‚à® Œ¥ < ‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π
L2 : ‚àÄ·∂† (Œ¥ : ‚Ñù‚â•0) in ùìù 0, ‚Äñ‚ÜëB.symm‚Äñ‚Çä * (‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ
Œ¥ : ‚Ñù‚â•0
h1Œ¥ : Subsingleton E ‚à® Œ¥ < ‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π
h2Œ¥ : ‚Äñ‚ÜëB.symm‚Äñ‚Çä * (‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ
s : Set E
f : E ‚Üí E
hf : ApproximatesLinearOn f A s Œ¥
hf' : ApproximatesLinearOn f (‚ÜëB) s Œ¥
‚ä¢ ‚Üëm * Œº s ‚â§ Œº (f '' s)","theorem mul_le_addHaar_image_of_lt_det (A : E ‚ÜíL[‚Ñù] E) {m : ‚Ñù‚â•0}
    (hm : (m : ‚Ñù‚â•0‚àû) < ENNReal.ofReal |A.det|) :
    ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù‚â•0),
      ‚àÄ (s : Set E) (f : E ‚Üí E), ApproximatesLinearOn f A s Œ¥ ‚Üí (m : ‚Ñù‚â•0‚àû) * Œº s ‚â§ Œº (f '' s) ",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ filter_upwards
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_eq_zero, Ne] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toPartialEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target by
    change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, MulZeroClass.zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, MulZeroClass.zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [H, MulZeroClass.zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [H, MulZeroClass.zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [H, MulZeroClass.zero_mul] using tendsto_const_nhds
      refine Te"
Mathlib/RingTheory/AdicCompletion/Functoriality.lean,AdicCompletion.sumInv_comp_sum,sumInv_comp_sum,7781a9ef072274dd65ef707f9c2c26fa2420df42,":= by
  ext j x
  apply DirectSum.ext R (fun i ‚Ü¶ ?_)
  ext n
  simp
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  ¬∑ next h => subst h; simp
  ¬∑ simp","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (component ?R ?Œπ ?M ?i) ((lof ?R ?Œπ ?M ?j) ?b)
case h
R : Type u_1
inst‚úù¬π¬≤ : CommRing R
I : Ideal R
M‚úù : Type u_2
inst‚úù¬π¬π : AddCommGroup M‚úù
inst‚úù¬π‚Å∞ : Module R M‚úù
N : Type u_3
inst‚úù‚Åπ : AddCommGroup N
inst‚úù‚Å∏ : Module R N
P : Type u_4
inst‚úù‚Å∑ : AddCommGroup P
inst‚úù‚Å∂ : Module R P
T : Type u_5
inst‚úù‚Åµ : AddCommGroup T
inst‚úù‚Å¥ : Module (AdicCompletion I R) T
Œπ : Type u_6
inst‚úù¬≥ : DecidableEq Œπ
M : Œπ ‚Üí Type u_7
inst‚úù¬≤ : (i : Œπ) ‚Üí AddCommGroup (M i)
inst‚úù¬π : (i : Œπ) ‚Üí Module R (M i)
inst‚úù : Fintype Œπ
j : Œπ
x : AdicCauchySequence I (M j)
i : Œπ
n : ‚Ñï
‚ä¢ ‚Üë((component R Œπ (fun i ‚Ü¶ AdicCompletion I (M i)) i)
          ((sumInv I M) ((mk I (‚®Å (i : Œπ), M i)) ((AdicCauchySequence.map I (lof R Œπ M j)) x))))
      n =
    ‚Üë((component R Œπ (fun i ‚Ü¶ AdicCompletion I (M i)) i)
          ((lof (AdicCompletion I R) Œπ (fun i ‚Ü¶ AdicCompletion I (M i)) j) ((mk I (M j)) x)))
      n",theorem sumInv_comp_sum : sumInv I M ‚àò‚Çó sum I M = LinearMap.id ,":= by
  ext j x
  apply DirectSum.ext (AdicCompletion I R) (fun i ‚Ü¶ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, map_mk, component_sumInv,
    mk_apply_coe, AdicCauchySequence.map_apply_coe, Submodule.mkQ_apply, LinearMap.id_comp]
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  ¬∑ next h => subst h; simp
  ¬∑ simp",":= by
  ext j x
  apply DirectSum.ext R (fun i ‚Ü¶ ?_)
  ext n
  simp
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  ¬∑ next h => subst h; simp"
Mathlib/Analysis/InnerProductSpace/Projection.lean,norm_eq_iInf_iff_real_inner_le_zero,norm_eq_iInf_iff_real_inner_le_zero,1507c181c67dcc2ca8a6c4b34934872edf50bf0f,":=
  Iff.intro
    (by
      intro eq w hw
      let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
      let p := ‚ü™u - v, w - v‚ü´_‚Ñù
      let q := ‚Äñw - v‚Äñ ^ 2
      letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
      have : 0 ‚â§ Œ¥
      apply le_ciInf
      intro
      exact norm_nonneg _
      have Œ¥_le : ‚àÄ w : K, Œ¥ ‚â§ ‚Äñu - w‚Äñ
      intro w
      apply ciInf_le
      use (0 : ‚Ñù)
      rintro _ ‚ü®_, rfl‚ü©
      exact norm_nonneg _
      have Œ¥_le' : ‚àÄ w ‚àà K, Œ¥ ‚â§ ‚Äñu - w‚Äñ := fun w hw => Œ¥_le ‚ü®w, hw‚ü©
      have : ‚àÄ Œ∏ : ‚Ñù, 0 < Œ∏ ‚Üí Œ∏ ‚â§ 1 ‚Üí 2 * p ‚â§ Œ∏ * q
      intro Œ∏ hŒ∏‚ÇÅ hŒ∏‚ÇÇ
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc
          ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts[le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel'_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                  absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
                ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) :=
        by abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v))
      ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
      by_cases hq : q = 0
      ¬∑ rw [hq] at this
        have : p ‚â§ 0
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
        exact this
      ¬∑ have q_pos : 0 < q
        apply lt_of_le_of_ne
        exact sq_nonneg _
        intro h
        exact hq h.symm
        by_contra hp
        rw [not_le] at hp
        let Œ∏ := min (1 : ‚Ñù) (p / q)
        have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
          calc
            Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
            _ = p := div_mul_cancel _ hq

        have : 2 * p ‚â§ p :=
          calc
            2 * p ‚â§ Œ∏ * q := by
              refine' this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num)
            _ ‚â§ p := eq‚ÇÅ

        linarith)
    (by
      intro h
      letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
      apply le_antisymm
      ¬∑ apply le_ciInf
        intro w
        apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
        have := h w w.2
        calc
          ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
          _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
            rw [sq]
            refine' le_add_of_nonneg_right _
            exact sq_nonneg _
          _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
          _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
            have : u - v - (w - v) = u - w
            abel
            rw [this, sq]

      ¬∑ show (‚®Ö w : K, ‚Äñu - w‚Äñ) ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
        apply ciInf_le
        use 0
        rintro y ‚ü®z, rfl‚ü©
        exact norm_nonneg _)",error:  unexpected identifier; expected '|',"theorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ‚Ñù K) {u : F} {v : F}
    (hv : v ‚àà K) : (‚Äñu - v‚Äñ = ‚®Ö w : K, ‚Äñu - w‚Äñ) ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0 ",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel‚ÇÄ _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            exact this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num [Œ∏])
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine le_add_of_nonneg_right ?_
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _",":=
  Iff.intro
    (by
      intro eq w hw
      let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
      let p := ‚ü™u - v, w - v‚ü´_‚Ñù
      let q := ‚Äñw - v‚Äñ ^ 2
      letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
      have : 0 ‚â§ Œ¥
      apply le_ciInf
      intro
      exact norm_nonneg _
      have Œ¥_le : ‚àÄ w : K, Œ¥ ‚â§ ‚Äñu - w‚Äñ
      intro w
      apply ciInf_le
      use (0 : ‚Ñù)
      rintro _ ‚ü®_, rfl‚ü©
      exact norm_nonneg _
      have Œ¥_le : ‚àÄ w : K, Œ¥ ‚â§ ‚Äñu - w‚Äñ
      intro w
      apply ciInf_le
      use (0 : ‚Ñù)
      rintro _ ‚ü®_, rfl‚ü©
      exact norm_nonneg _
      have Œ¥_le : ‚àÄ w : K, Œ¥ ‚â§ ‚Äñu - w‚Äñ := fun w hw => Œ¥_le ‚ü®w, hw‚ü©
      have : ‚àÄ Œ∏ : ‚Ñù, 0 < Œ∏ ‚Üí Œ∏ ‚â§ 1 ‚Üí 2 * p ‚â§ Œ∏ * q
      intro Œ∏ hŒ∏‚ÇÅ hŒ∏‚ÇÇ
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
           simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
             rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
           ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) :=
        by abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ"
Mathlib/Combinatorics/Enumerative/Catalan.lean,Tree.mem_treesOfNumNodesEq,mem_treesOfNumNodesEq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction x using Tree.unitRecOn generalizing n <;> cases n <;>
    simp [treesOfNumNodesEq_succ, Nat.succ_eq_add_one, *]
  exact (Nat.succ_ne_zero _).symm",error:  no goals to be solved,"theorem mem_treesOfNumNodesEq {x : Tree Unit} {n : ‚Ñï} :
    x ‚àà treesOfNumNodesEq n ‚Üî x.numNodes = n ",":= by
  induction x using Tree.unitRecOn generalizing n <;> cases n <;>
    simp [treesOfNumNodesEq_succ, *]",":= by
  induction x using Tree.unitRecOn generalizing n <;> cases n <;>
    simp [treesOfNumNodesEq_succ, Nat.succ_eq_add_one]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,norm_eq_iInf_iff_real_inner_le_zero,norm_eq_iInf_iff_real_inner_le_zero,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel'_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            refine' this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num)
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine' le_add_of_nonneg_right _
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _","warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
error:  type mismatch
  div_mul_cancel p ?m.225193
has type
  p / ?m.225193 * ?m.225193 = p : Prop
but is expected to have type
  p / q * q = p : Prop","theorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ‚Ñù K) {u : F} {v : F}
    (hv : v ‚àà K) : (‚Äñu - v‚Äñ = ‚®Ö w : K, ‚Äñu - w‚Äñ) ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0 ",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel‚ÇÄ _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            exact this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num [Œ∏])
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine le_add_of_nonneg_right ?_
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
         _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
           simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
             rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
             rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                   absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this"
Mathlib/RingTheory/ChainOfDivisors.lean,DivisorChain.element_of_chain_eq_pow_second_of_chain,element_of_chain_eq_pow_second_of_chain,ec25cca0630aff3805accd410e27691c8e6c4315,":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine'
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine' ‚ü®‚ü®i, _‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine' Set.injOn_of_injective (fun m m' h => Fin.ext _) _
      refine'
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) _ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine' dvd_trans _ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2","error:  type mismatch
  Set.injOn_of_injective (fun m m' h ‚Ü¶ Fin.ext (?m.30170 m m' h)) ?m.30176
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Fin ?m.30169‚¶Ñ, x‚ÇÇ ‚àà ?m.30174 ‚Üí ?m.30152 ?m.30175 = ?m.30152 x‚ÇÇ ‚Üí ?m.30175 = x‚ÇÇ : Prop
but is expected to have type
  Set.InjOn (fun m ‚Ü¶ c 1 ^ ‚Üëm) ‚ÜëFinset.univ : Prop","theorem element_of_chain_eq_pow_second_of_chain {q r : Associates M} {n : ‚Ñï} (hn : n ‚â† 0)
    {c : Fin (n + 1) ‚Üí Associates M} (h‚ÇÅ : StrictMono c) (h‚ÇÇ : ‚àÄ {r}, r ‚â§ q ‚Üî ‚àÉ i, r = c i)
    (hr : r ‚à£ q) (hq : q ‚â† 0) : ‚àÉ i : Fin (n + 1), r = c 1 ^ (i : ‚Ñï) ",":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ‚ü®‚ü®i, ?_‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_)
      refine
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) ?_ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine dvd_trans ?_ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2",":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ‚ü®‚ü®i, _‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_) ?_
      refine
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) ?_ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine dvd_trans ?_ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2"
Mathlib/Data/Multiset/Antidiagonal.lean,Multiset.antidiagonal_eq_map_powerset,antidiagonal_eq_map_powerset,ddffab96a653674eaf6ec54e6415f6fa7c2a49f7,":= by
  induction' s with a s hs
  ¬∑ simp only [antidiagonal_zero, powerset_zero, zero_tsub, map_singleton]
  ¬∑ simp_rw [antidiagonal_cons, powerset_cons, map_add, hs, map_map, Function.comp, Prod.map_mk,
      id, sub_cons, erase_cons_head]
    rw [add_comm]
    congr 1
    refine' Multiset.map_congr rfl fun x hx ‚Ü¶ _
    rw [cons_sub_of_le _ (mem_powerset.mp hx)]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù : DecidableEq Œ±
s : Multiset Œ±
‚ä¢ s.antidiagonal = map (fun t ‚Ü¶ (s - t, t)) s.powerset","theorem antidiagonal_eq_map_powerset [DecidableEq Œ±] (s : Multiset Œ±) :
    s.antidiagonal = s.powerset.map fun t ‚Ü¶ (s - t, t) ",":= by
  induction' s using Multiset.induction_on with a s hs
  ¬∑ simp only [antidiagonal_zero, powerset_zero, zero_tsub, map_singleton]
  ¬∑ simp_rw [antidiagonal_cons, powerset_cons, map_add, hs, map_map, Function.comp, Prod.map_mk,
      id, sub_cons, erase_cons_head]
    rw [add_comm]
    congr 1
    refine Multiset.map_congr rfl fun x hx ‚Ü¶ ?_
    rw [cons_sub_of_le _ (mem_powerset.mp hx)]",":= by
  induction' s using Multiset.induction_on with a s hs
  ¬∑ simp only [antidiagonal_zero, powerset_zero, zero_tsub, map_singleton]
  ¬∑ simp_rw [antidiagonal_cons, powerset_cons, map_add, hs, map_map, Function.comp, Prod.map_mk,
      id, sub_cons, erase_cons_head]
    rw [add_comm]
    congr 1
    refine Multiset.map_congr rfl fun x hx ‚Ü¶ ?_
    rw [cons_sub_of_le _ (mem_powerset.mp hx)]"
Mathlib/Analysis/SpecialFunctions/Integrals.lean,intervalIntegral.intervalIntegrable_rpow',intervalIntegrable_rpow',c480a87bf98e8eb1bd5a2eec1b3b1369bfff595d,":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg_of_nonneg hx.1.le
    ¬∑ refine' (continuousOn_id.rpow_const _).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine' m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]
    rw [Pi.smul_apply]
    simp [rpow_def_of_pos hx.1]
    apply Or.inl
    ac_rfl","error:  no goals to be solved
warning:  `rpow_nonneg_of_nonneg` has been deprecated, use `Real.rpow_nonneg` instead
error:  no goals to be solved","theorem intervalIntegrable_rpow' {r : ‚Ñù} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg_of_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const _).div_const ?_; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]
    rw [Pi.smul_apply]
    simp [rpow_def_of_pos hx.1]
    apply Or.inl
    ac_rfl"
Mathlib/Data/Real/Cardinality.lean,Cardinal.mk_Iio_real,mk_Iio_real,e24d0042f0fd176848590f8a296e5c675237f634,":= by
  refine' le_antisymm (mk_real ‚ñ∏ mk_set_le _) _
  have h2 : (fun x => a + a - x) '' Iio a = Ioi a := by
    simp only [image_const_sub_Iio, add_sub_cancel]
  exact mk_Ioi_real a ‚ñ∏ h2 ‚ñ∏ mk_image_le","error:  unsolved goals
c : ‚Ñù
f g : ‚Ñï ‚Üí Bool
n : ‚Ñï
a : ‚Ñù
‚ä¢ Ioi (a + a - a) = Ioi a",theorem mk_Iio_real (a : ‚Ñù) : #(Iio a) = ùî† ,":= by
  refine le_antisymm (mk_real ‚ñ∏ mk_set_le _) ?_
  have h2 : (fun x => a + a - x) '' Iio a = Ioi a := by
    simp only [image_const_sub_Iio, add_sub_cancel_right]
  exact mk_Ioi_real a ‚ñ∏ h2 ‚ñ∏ mk_image_le",":= by
  refine le_antisymm (mk_real ‚ñ∏ mk_set_le _) ?_
  have h2 : (fun x => a + a - x) '' Iio a = Ioi a := by
    simp only [image_const_sub_Iio, add_sub_cancel]
  exact mk_Ioi_real a ‚ñ∏ h2 ‚ñ∏ mk_image_le"
Mathlib/CategoryTheory/Localization/Triangulated.lean,CategoryTheory.Functor.contractible_mem_essImageDistTriang,contractible_mem_essImageDistTriang,660d4d5e85504851f32fdcb363260a8048d0609c,:= by,"error:  unexpected token 'lemma'; expected '{' or tactic
error:  unsolved goals
C : Type u_1
D : Type u_2
inst‚úù¬π¬≤ : Category.{u_3, u_1} C
inst‚úù¬π¬π : Category.{u_4, u_2} D
L : C ‚•§ D
inst‚úù¬π‚Å∞ : HasShift C ‚Ñ§
inst‚úù‚Åπ : Preadditive C
inst‚úù‚Å∏ : HasZeroObject C
inst‚úù‚Å∑ : ‚àÄ (n : ‚Ñ§), (shiftFunctor C n).Additive
inst‚úù‚Å∂ : Pretriangulated C
inst‚úù‚Åµ : HasShift D ‚Ñ§
inst‚úù‚Å¥ : L.CommShift ‚Ñ§
inst‚úù¬≥ : L.EssSurj
inst‚úù¬≤ : HasZeroObject D
inst‚úù¬π : HasZeroMorphisms D
inst‚úù : L.PreservesZeroMorphisms
X : D
‚ä¢ contractibleTriangle X ‚àà L.essImageDistTriang","lemma contractible_mem_essImageDistTriang [EssSurj L] [HasZeroObject D]
    [HasZeroMorphisms D] [L.PreservesZeroMorphisms] (X : D) :
    contractibleTriangle X ‚àà L.essImageDistTriang ",":= by
  refine ‚ü®contractibleTriangle (L.objPreimage X), ?_, contractible_distinguished _‚ü©
  exact ((contractibleTriangleFunctor D).mapIso (L.objObjPreimageIso X)).symm ‚â™‚â´
    Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) L.mapZeroObject.symm (by simp) (by simp) (by simp)",":= by
  contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
    contractibleTriangle X ‚àà L.essImageDistTriang := by
      apply L.essImageDistTriang
      apply L.essImageDistTriang
      apply L.essImageDistTriang
      apply L.essImageDistTriang
      apply L.essImageDistTriang
      apply L"
Mathlib/Data/Matroid/IndepAxioms.lean,Matroid.existsMaximalSubsetProperty_of_bdd,_root_.Matroid.existsMaximalSubsetProperty_of_bdd,aede33055710fe967fd079409ce85a4f992ec863,":= by
  obtain ‚ü®n, hP‚ü© := hP
  rintro I hI hIX
  have hfin : Set.Finite (ncard '' {Y | P Y ‚àß I ‚äÜ Y ‚àß Y ‚äÜ X})
  ¬∑ rw [finite_iff_bddAbove, bddAbove_def]
    simp_rw [ENat.le_coe_iff] at hP
    use n
    rintro x ‚ü®Y, ‚ü®hY,-,-‚ü©, rfl‚ü©
    obtain ‚ü®n‚ÇÄ, heq, hle‚ü© := hP Y hY
    rwa [ncard_def, heq, ENat.toNat_coe]
  obtain ‚ü®Y, hY, hY'‚ü© := Finite.exists_maximal_wrt' ncard _ hfin ‚ü®I, hI, rfl.subset, hIX‚ü©
  refine' ‚ü®Y, hY, fun J ‚ü®hJ, hIJ, hJX‚ü© (hYJ : Y ‚äÜ J) ‚Ü¶ (_ : J ‚äÜ Y)‚ü©
  have hJfin := finite_of_encard_le_coe (hP J hJ)
  refine' (eq_of_subset_of_ncard_le hYJ _ hJfin).symm.subset
  rw [hY' J ‚ü®hJ, hIJ, hJX‚ü© (ncard_le_of_subset hYJ hJfin)]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro
Œ± : Type u_1
I‚úù B X‚úù : Set Œ±
P : Set Œ± ‚Üí Prop
X : Set Œ±
n : ‚Ñï
hP : ‚àÄ (Y : Set Œ±), P Y ‚Üí Y.encard ‚â§ ‚Üën
I : Set Œ±
hI : P I
hIX : I ‚äÜ X
hfin : (ncard '' {Y | P Y ‚àß I ‚äÜ Y ‚àß Y ‚äÜ X}).Finite
‚ä¢ (maximals (fun x x_1 ‚Ü¶ x ‚äÜ x_1) {Y | P Y ‚àß I ‚äÜ Y ‚àß Y ‚äÜ X}).Nonempty","theorem _root_.Matroid.existsMaximalSubsetProperty_of_bdd {P : Set Œ± ‚Üí Prop}
    (hP : ‚àÉ (n : ‚Ñï), ‚àÄ Y, P Y ‚Üí Y.encard ‚â§ n) (X : Set Œ±) : ExistsMaximalSubsetProperty P X ",":= by
  obtain ‚ü®n, hP‚ü© := hP
  rintro I hI hIX
  have hfin : Set.Finite (ncard '' {Y | P Y ‚àß I ‚äÜ Y ‚àß Y ‚äÜ X}) := by
    rw [finite_iff_bddAbove, bddAbove_def]
    simp_rw [ENat.le_coe_iff] at hP
    use n
    rintro x ‚ü®Y, ‚ü®hY,-,-‚ü©, rfl‚ü©
    obtain ‚ü®n‚ÇÄ, heq, hle‚ü© := hP Y hY
    rwa [ncard_def, heq, ENat.toNat_coe]
  obtain ‚ü®Y, hY, hY'‚ü© := Finite.exists_maximal_wrt' ncard _ hfin ‚ü®I, hI, rfl.subset, hIX‚ü©
  refine ‚ü®Y, hY, fun J ‚ü®hJ, hIJ, hJX‚ü© (hYJ : Y ‚äÜ J) ‚Ü¶ (?_ : J ‚äÜ Y)‚ü©
  have hJfin := finite_of_encard_le_coe (hP J hJ)
  refine (eq_of_subset_of_ncard_le hYJ ?_ hJfin).symm.subset
  rw [hY' J ‚ü®hJ, hIJ, hJX‚ü© (ncard_le_ncard hYJ hJfin)]",":= by
  obtain ‚ü®n, hP‚ü© := hP
  rintro I hI hIX
  have hfin : Set.Finite (ncard '' {Y | P Y ‚àß I ‚äÜ Y ‚àß Y ‚äÜ X})
  ¬∑ rw [finite_iff_bddAbove, bddAbove_def]
    simp_rw [ENat.le_coe_iff] at hP
    use n
    rintro x ‚ü®Y, ‚ü®hY,-,-‚ü©, rfl‚ü©
    obtain ‚ü®n‚ÇÄ, heq, hle‚ü© := hP Y hY
    rwa [ncard_def, heq, ENat.toNat_coe]
  obtain ‚ü®Y, hY, hY'‚ü© := Finite.exists_maximal_wrt' ncard _ hfin ‚ü®I, hI, rfl.subset, hIX‚ü©
  refine ‚ü®Y, hY, fun J ‚ü®hJ, hIJ, hJX‚ü© (hYJ : Y ‚äÜ J) ‚Ü¶ (_ : J ‚äÜ Y)‚ü©
  have hJfin := finite_of_encard_le_coe (hP J hJ)
  refine (eq_of_subset_of_ncard_le hYJ ?_ hJfin).symm.subset
  rw [hY' J ‚ü®hJ, hIJ, hJX‚ü© (ncard_le_of_subset hYJ hJfin)]"
Mathlib/Data/Finset/Basic.lean,Finset.union_subset_left,union_subset_left,48bda060b08a3013f32897b125fe26068de43109,":=
  (subset_union_left _ _).trans h","error:  function expected at
  subset_union_left ?m.84978
term has type
  ?m.84977 ‚àà ?m.84975 ‚à™ ?m.84976",theorem union_subset_left (h : s ‚à™ t ‚äÜ u) : s ‚äÜ u ,":=
  subset_union_left.trans h",":=
  (subset_union_left).trans h"
Mathlib/LinearAlgebra/Semisimple.lean,Module.End.IsSemisimple.of_mem_adjoin_pair,IsSemisimple.of_mem_adjoin_pair,5d0763f72671b8fa3427057def8acaeba830c1a9,":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R := (AdjoinRoot.powerBasis' <| minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral g).map _).finite
  have : IsScalarTower K R S := .of_algebraMap_eq (S := R) fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ, ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.comp_apply, minpoly.aeval, œÜ.map_zero]","error:  function expected at
  isIntegral
term has type
  Algebra.IsIntegral ?m.165678 (End ?m.165678 ?m.165680)
error:  function expected at
  isIntegral
term has type
  Algebra.IsIntegral ?m.168378 (End ?m.168378 ?m.168380)","theorem IsSemisimple.of_mem_adjoin_pair {a : End K M} (ha : a ‚àà Algebra.adjoin K {f, g}) :
    a.IsSemisimple ",":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R :=
    (AdjoinRoot.powerBasis' <| minpoly.monic <| Algebra.IsIntegral.isIntegral f).finite
  have : Finite R S :=
    (AdjoinRoot.powerBasis' <| (minpoly.monic <| Algebra.IsIntegral.isIntegral g).map _).finite
  set_option maxSynthPendingDepth 2 in
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ, ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.comp_apply, minpoly.aeval, œÜ.map_zero]",":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R := (AdjoinRoot.powerBasis' <| minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral g).map _).finite
  have : IsScalarTower K R S := .of_algebraMap_eq (S := R) fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ', ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.comp_apply, minpoly.aeval, œÜ.map_zero]"
Mathlib/Data/Nat/Factorization/Root.lean,Nat.ceilRoot_ne_zero,ceilRoot_ne_zero,c380edce4efb3cf743c9ca0d4c4a149715da1978,":= by
  simp (config := { contextual := true }) [ceilRoot, not_imp_not, not_or]","error:  unsolved goals
a b n : ‚Ñï
‚ä¢ ¬¨n = 0 ‚Üí ¬¨a = 0 ‚Üí ‚àÄ (x : ‚Ñï), Prime x ‚Üí x ‚à£ a ‚Üí x = 0 ‚Üí (n - 1) / n = 0",lemma ceilRoot_ne_zero : ceilRoot n a ‚â† 0 ‚Üî n ‚â† 0 ‚àß a ‚â† 0 ,":= by
  simp (config := { contextual := true }) [ceilRoot_def, not_imp_not, not_or]",":= by
  simp [config := { contextual := true }]"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine mem_shadow_iff.2
        ‚ü®(t ‚äî u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right _ _, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) ?_
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 ‚àà ?m.92170 ‚à™ ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 ‚àà ?m.92636 ‚à™ ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 ‚àà ?m.94503 ‚à™ ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 ‚àà ?m.97297 ‚à™ ?m.97298
error:  function expected at
  subset_union_left ?m.98875
term has type
  ?m.98874 ‚àà ?m.98872 ‚à™ ?m.98873","theorem shadow_compression_subset_compression_shadow (u v : Finset Œ±)
    (huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú) :
    ‚àÇ (ùìí u v ùíú) ‚äÜ ùìí u v (‚àÇ ùíú) ",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine mem_shadow_iff.2
        ‚ü®(t ‚äî u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) ?_
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine mem_shadow_iff.2
        ‚ü®(t ‚äî u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
 "
Mathlib/NumberTheory/FLT/Basic.lean,FermatLastTheoremFor.mono,FermatLastTheoremFor.mono,e6ad86eaadea16fd24ab57fad33a02288669fb7b,":= by
  exact FermatLastTheoremWithSolutionZero.mono hmn hm",error:  unknown identifier 'FermatLastTheoremWithSolutionZero.mono',"lemma FermatLastTheoremFor.mono (hmn : m ‚à£ n) (hm : FermatLastTheoremFor m) :
    FermatLastTheoremFor n ",":= by
  exact FermatLastTheoremWith.mono hmn hm",":= by
  exact FermatLastTheoremWithSolutionZero.mono hmn hm"
Mathlib/LinearAlgebra/BilinearForm/Properties.lean,LinearMap.BilinForm.apply_dualBasis_right,apply_dualBasis_right,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [sym, apply_dualBasis_left]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (RingHom.id K) ((B ?x) ?y)
R : Type u_1
M : Type u_2
inst‚úù¬π‚Å∑ : CommSemiring R
inst‚úù¬π‚Å∂ : AddCommMonoid M
inst‚úù¬π‚Åµ : Module R M
R‚ÇÅ : Type u_3
M‚ÇÅ : Type u_4
inst‚úù¬π‚Å¥ : CommRing R‚ÇÅ
inst‚úù¬π¬≥ : AddCommGroup M‚ÇÅ
inst‚úù¬π¬≤ : Module R‚ÇÅ M‚ÇÅ
V : Type u_5
K : Type u_6
inst‚úù¬π¬π : Field K
inst‚úù¬π‚Å∞ : AddCommGroup V
inst‚úù‚Åπ : Module K V
M'‚úù : Type u_7
M'' : Type u_8
inst‚úù‚Å∏ : AddCommMonoid M'‚úù
inst‚úù‚Å∑ : AddCommMonoid M''
inst‚úù‚Å∂ : Module R M'‚úù
inst‚úù‚Åµ : Module R M''
B‚úù : BilinForm R M
B‚ÇÅ : BilinForm R‚ÇÅ M‚ÇÅ
M' : Type u_9
inst‚úù‚Å¥ : AddCommMonoid M'
inst‚úù¬≥ : Module R M'
inst‚úù¬≤ : FiniteDimensional K V
Œπ : Type u_10
inst‚úù¬π : DecidableEq Œπ
inst‚úù : Finite Œπ
B : BilinForm K V
hB : B.Nondegenerate
sym : B.IsSymm
b : Basis Œπ K V
i j : Œπ
‚ä¢ (B (b i)) ((B.dualBasis hB b) j) = if i = j then 1 else 0","theorem apply_dualBasis_right (B : BilinForm K V) (hB : B.Nondegenerate) (sym : B.IsSymm)
    (b : Basis Œπ K V) (i j) : B (b i) (B.dualBasis hB b j) = if i = j then 1 else 0 ",":= by
  rw [sym.eq, apply_dualBasis_left]",":= by
  rw [apply_dualBasis_left]"
Mathlib/Algebra/GroupWithZero/Units/Basic.lean,div_eq_div_iff_div_eq_div',div_eq_div_iff_div_eq_div',031f5489446cf55630d0efe44cc757d7a8aa007a,":= by
  conv_lhs => rw [‚Üê mul_left_inj' hb, div_mul_cancel _ hb]
  conv_rhs => rw [‚Üê mul_left_inj' hc, div_mul_cancel _ hc]
  rw [mul_comm _ c, div_mul_eq_mul_div, mul_div_assoc]","warning:  `IsUnit.div_mul_left` has been deprecated, use `div_mul_cancel_right` instead
warning:  `IsUnit.div_mul_right` has been deprecated, use `div_mul_cancel_left` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.41875 / ?m.41889 * ?m.41889
Œ± : Type u_1
M‚ÇÄ : Type u_2
G‚ÇÄ : Type u_3
M‚ÇÄ' : Type u_4
G‚ÇÄ' : Type u_5
F : Type u_6
F' : Type u_7
inst‚úù¬π : MonoidWithZero M‚ÇÄ
inst‚úù : CommGroupWithZero G‚ÇÄ
a b c d : G‚ÇÄ
hb : b ‚â† 0
hc : c ‚â† 0
| a / b * b = c / d * b",lemma div_eq_div_iff_div_eq_div' (hb : b ‚â† 0) (hc : c ‚â† 0) : a / b = c / d ‚Üî a / c = b / d ,":= by
  conv_lhs => rw [‚Üê mul_left_inj' hb, div_mul_cancel‚ÇÄ _ hb]
  conv_rhs => rw [‚Üê mul_left_inj' hc, div_mul_cancel‚ÇÄ _ hc]
  rw [mul_comm _ c, div_mul_eq_mul_div, mul_div_assoc]",":= by
  conv_lhs => rw [‚Üê mul_left_inj' hb, div_mul_cancel _ hb]
  conv_rhs => rw [‚Üê mul_left_inj' hc, div_mul_cancel _ hc]
  rw [mul_comm _ c, div_mul_eq_mul_div, mul_div_assoc]"
Mathlib/Combinatorics/SetFamily/Shadow.lean,Finset.mem_upShadow_iff_exists_sdiff,mem_upShadow_iff_exists_sdiff,9f6d33884de569540c527b667d1573e1b97e1347,":= by
  simp_rw [mem_upShadow_iff, ‚Üê covby_iff_card_sdiff_eq_one, covby_iff_exists_insert]","warning:  @shadow does not have a doc string
warning:  @upShadow does not have a doc string
error:  unknown identifier 'covby_iff_card_sdiff_eq_one'
error:  simp made no progress","lemma mem_upShadow_iff_exists_sdiff : t ‚àà ‚àÇ‚Å∫ ùíú ‚Üî ‚àÉ s ‚àà ùíú, s ‚äÜ t ‚àß (t \ s).card = 1 ",":= by
  simp_rw [mem_upShadow_iff, ‚Üê covBy_iff_card_sdiff_eq_one, covBy_iff_exists_insert]",":= by
  simp_rw [covBy_iff_card_sdiff_eq_one, covBy_iff_exists_insert]"
Mathlib/Algebra/Polynomial/Roots.lean,Polynomial.Monic.irreducible_iff_degree_lt,Monic.irreducible_iff_degree_lt,ede0480e17a20274bfc92c1bb86c545f2389270c,":= by
  simp only [p_monic.irreducible_iff_lt_natDegree_lt p_1, Finset.mem_Ioc, and_imp,
    natDegree_pos_iff_degree_pos, natDegree_le_iff_degree_le]
  constructor
  ¬∑ rintro h q deg_le dvd
    by_contra q_unit
    have := degree_pos_of_not_isUnit_of_dvd_monic q_unit dvd p_monic
    have hu := p_monic.isUnit_leadingCoeff_of_dvd dvd
    refine (h _ (monic_of_isUnit_leadingCoeff_inv_smul hu) ?_ ?_ (dvd_trans ?_ dvd)).elim
    ¬∑ rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    ¬∑ rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    ¬∑ rw [Units.smul_def, Polynomial.smul_eq_C_mul, (isUnit_C.mpr (Units.isUnit _)).mul_left_dvd]
  ¬∑ rintro h q _ deg_pos deg_le dvd
    exact deg_pos.ne' <| degree_eq_zero_of_isUnit (h q deg_le dvd)","error:  application type mismatch
  degree_pos_of_not_isUnit_of_dvd_monic q_unit
argument
  q_unit
has type
  ¬¨IsUnit q : Prop
but is expected to have type
  ?m.254336.Monic : Prop","theorem Monic.irreducible_iff_degree_lt {p : R[X]} (p_monic : Monic p) (p_1 : p ‚â† 1) :
    Irreducible p ‚Üî ‚àÄ q, degree q ‚â§ ‚Üë(p.natDegree / 2) ‚Üí q ‚à£ p ‚Üí IsUnit q ",":= by
  simp only [p_monic.irreducible_iff_lt_natDegree_lt p_1, Finset.mem_Ioc, and_imp,
    natDegree_pos_iff_degree_pos, natDegree_le_iff_degree_le]
  constructor
  ¬∑ rintro h q deg_le dvd
    by_contra q_unit
    have := degree_pos_of_not_isUnit_of_dvd_monic p_monic q_unit dvd
    have hu := p_monic.isUnit_leadingCoeff_of_dvd dvd
    refine (h _ (monic_of_isUnit_leadingCoeff_inv_smul hu) ?_ ?_ (dvd_trans ?_ dvd)).elim
    ¬∑ rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    ¬∑ rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    ¬∑ rw [Units.smul_def, Polynomial.smul_eq_C_mul, (isUnit_C.mpr (Units.isUnit _)).mul_left_dvd]
  ¬∑ rintro h q _ deg_pos deg_le dvd
    exact deg_pos.ne' <| degree_eq_zero_of_isUnit (h q deg_le dvd)",":= by
  simp only [p_monic.irreducible_iff_lt_natDegree_lt p_1, Finset.mem_Ioc, and_imp,
    natDegree_pos_iff_degree_pos, natDegree_le_iff_degree_le]
  constructor
  ¬∑ rintro h q deg_le dvd
    by_contra q_unit
    have := degree_pos_of_not_isUnit_of_dvd_monic q_unit dvd p_monic
    have hu := p_monic.isUnit_leadingCoeff_of_dvd dvd
    refine (h _ (monic_of_isUnit_leadingCoeff_inv_smul hu) ?_ ?_ (dvd_trans ?_ dvd)).elim
    ¬∑ rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    ¬∑ rw [Units.smul_def, Polynomial.smul_eq_C_mul, (isUnit_C.mpr (Units.isUnit _)).mul_left_dvd]
  ¬∑ rintro h q _ deg_pos deg_le dvd
    exact deg_pos.ne' <| degree_eq_zero_of_isUnit (h q deg_le dvd)"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, _‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine'
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_ ‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right _ _, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) _
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 ‚àà ?m.92170 ‚à™ ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 ‚àà ?m.92636 ‚à™ ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 ‚àà ?m.94503 ‚à™ ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 ‚àà ?m.97297 ‚à™ ?m.97298
error:  ambiguous, possible interpretations 
  _root_.not_imp : ¬¨(?m.97719 ‚Üí ?m.97720) ‚Üî ?m.97719 ‚àß ¬¨?m.97720
  
  Classical.not_imp : ¬¨(?m.97721 ‚Üí ?m.97722) ‚Üî ?m.97721 ‚àß ¬¨?m.97722
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.97724
case neg
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
ùíú : Finset (Finset Œ±)
u‚úù v‚úù a : Finset Œ±
r : ‚Ñï
u v : Finset Œ±
huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú
ùíú' : Finset (Finset Œ±) := ùìí u v ùíú
s : Finset Œ±
hsùíú' : s ‚àà ‚àÇ ùíú'
hsùíú : s ‚àâ ‚àÇ ùíú
m : ‚àÄ y ‚àâ s, insert y s ‚àâ ùíú
x : Œ±
left‚úù : x ‚àâ s
right‚úù : insert x s ‚àà ùíú'
hus‚úù : u ‚äÜ insert x s
hvs : Disjoint v (insert x s)
this‚úù¬≤ : (insert x s ‚à™ v) \ u ‚àà ùíú
hsv : Disjoint s v
hvu : Disjoint v u
hxv : x ‚àâ v
this‚úù¬π : v \ u = v
this‚úù : x ‚àâ u
hus : u ‚äÜ s
w : Œ±
hwB : ¬¨(w ‚àà s ‚à™ v ‚àß w ‚àâ u)
hwùíú' : insert w ((s ‚à™ v) \ u) ‚àà ùíú'
this : v ‚äÜ insert w ((s ‚à™ v) \ u)
hwu : w ‚àâ u
‚ä¢ False","theorem shadow_compression_subset_compression_shadow (u v : Finset Œ±)
    (huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú) :
    ‚àÇ (ùìí u v ùíú) ‚äÜ ùìí u v (‚àÇ ùíú) ",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine mem_shadow_iff.2
        ‚ü®(t ‚äî u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) ?_
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
           sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx "
Mathlib/Data/Matrix/Basis.lean,Matrix.mem_range_scalar_of_commute_stdBasisMatrix,mem_range_scalar_of_commute_stdBasisMatrix,8514323f4f60b0f0325e64c814dbd4505fa999f3,":= by
  cases isEmpty_or_nonempty n
  ¬∑ exact ‚ü®0, Subsingleton.elim _ _‚ü©
  obtain ‚ü®i‚ü© := ‚ÄπNonempty n‚Ä∫
  refine ‚ü®M i i, Matrix.ext fun j k => ?_‚ü©
  simp only [scalar_apply]
  obtain rfl | hkl := Decidable.eq_or_ne j k
  ¬∑ rw [diagonal_apply_eq]
    obtain rfl | hij := Decidable.eq_or_ne i j
    ¬∑ rfl
    ¬∑ exact diag_eq_of_commute_stdBasisMatrix (hM hij)
  ¬∑ push_neg at hkl
    rw [diagonal_apply_ne _ hkl]
    obtain rfl | hij := Decidable.eq_or_ne i j
    ¬∑ rw [col_eq_zero_of_commute_stdBasisMatrix (hM hkl.symm) hkl]
    ¬∑ rw [row_eq_zero_of_commute_stdBasisMatrix (hM hij) hkl.symm]",error:  push_neg made no progress,"theorem mem_range_scalar_of_commute_stdBasisMatrix {M : Matrix n n Œ±}
    (hM : Pairwise fun i j => Commute (stdBasisMatrix i j 1) M) :
    M ‚àà Set.range (Matrix.scalar n) ",":= by
  cases isEmpty_or_nonempty n
  ¬∑ exact ‚ü®0, Subsingleton.elim _ _‚ü©
  obtain ‚ü®i‚ü© := ‚ÄπNonempty n‚Ä∫
  refine ‚ü®M i i, Matrix.ext fun j k => ?_‚ü©
  simp only [scalar_apply]
  obtain rfl | hkl := Decidable.eq_or_ne j k
  ¬∑ rw [diagonal_apply_eq]
    obtain rfl | hij := Decidable.eq_or_ne i j
    ¬∑ rfl
    ¬∑ exact diag_eq_of_commute_stdBasisMatrix (hM hij)
  ¬∑ rw [diagonal_apply_ne _ hkl]
    obtain rfl | hij := Decidable.eq_or_ne i j
    ¬∑ rw [col_eq_zero_of_commute_stdBasisMatrix (hM hkl.symm) hkl]
    ¬∑ rw [row_eq_zero_of_commute_stdBasisMatrix (hM hij) hkl.symm]",":= by
  cases isEmpty_or_nonempty n
  ¬∑ exact ‚ü®0, Subsingleton.elim _ _‚ü©
  obtain ‚ü®i‚ü© := ‚ÄπNonempty n‚Ä∫
  refine ‚ü®M i i, Matrix.ext fun j k => ?_‚ü©
  simp only [scalar_apply]
  obtain rfl | hkl := Decidable.eq_or_ne j k
  ¬∑ rw [diagonal_apply_eq]
    obtain rfl | hij := Decidable.eq_or_ne i j
    ¬∑ rfl
    ¬∑ exact diag_eq_of_commute_stdBasisMatrix (hM hij)
  ¬∑ push_neg at hkl
    rw [diagonal_apply_ne _ hkl]
    obtain rfl | hij := Decidable.eq_or_ne i j
    ¬∑ rfl
    ¬∑ exact diag_eq_of_commute_stdBasisMatrix (hM hij)
  ¬∑ push_neg at hkl
    rw [diagonal_apply_ne _ hkl]
    obtain rfl | hij := Decidable.eq_or_ne i j
    ¬∑ rfl
    ¬∑ exact diag_eq_of_commute_stdBasisMatrix (hM hij)
  ¬∑ push_neg at hkl
    rw [diagonal_apply_ne _ hkl]
    obtain rfl | hij := Decidable.eq_or_ne i j
    ¬∑ rw [col_eq_zero_of_commute_stdBasisMatrix (hM hij) hkl]
    ¬∑ rw [row_eq_zero_of_commute_stdBasisMatrix (hM hij) hkl.symm]"
Mathlib/MeasureTheory/Integral/CircleIntegral.lean,circleIntegral.norm_integral_lt_of_norm_le_const_of_lt,norm_integral_lt_of_norm_le_const_of_lt,e92ad7acc4d771729f70601a74a3c091f330e507,":= by
  rw [‚Üê _root_.abs_of_pos hR, ‚Üê image_circleMap_Ioc] at hlt
  rcases hlt with ‚ü®_, ‚ü®Œ∏‚ÇÄ, hmem, rfl‚ü©, hlt‚ü©
  calc
    ‚Äñ‚àÆ z in C(c, R), f z‚Äñ ‚â§ ‚à´ Œ∏ in [0:2 * œÄ], ‚Äñderiv (circleMap c R) Œ∏ ‚Ä¢ f (circleMap c R Œ∏)‚Äñ :=
      intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le
    _ < ‚à´ _ in [0:2 * œÄ], R * C := by
      simp only [norm_smul, deriv_circleMap, norm_eq_abs, map_mul, abs_I, mul_one,
        abs_circleMap_zero, abs_of_pos hR]
      refine' intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt
          Real.two_pi_pos _ continuousOn_const (fun Œ∏ _ => _) ‚ü®Œ∏‚ÇÄ, Ioc_subset_Icc_self hmem, _‚ü©
      ¬∑ exact continuousOn_const.mul (hc.comp (continuous_circleMap _ _).continuousOn fun Œ∏ _ =>
          circleMap_mem_sphere _ hR.le _).norm
      ¬∑ exact mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere _ hR.le _) hR.le
      ¬∑ exact (mul_lt_mul_left hR).2 hlt
    _ = 2 * œÄ * R * C := by simp [mul_assoc]; ring","error:  type mismatch
  2 * œÄ
has type
  ‚Ñù : outParam Type
but is expected to have type
  ‚Ñï : Type
error:  type mismatch
  2 * œÄ
has type
  ‚Ñù : outParam Type
but is expected to have type
  ‚Ñï : Type
info:  Try this: ring_nf
error:  unsolved goals
E : Type u_1
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚ÑÇ E
inst‚úù : CompleteSpace E
f : ‚ÑÇ ‚Üí E
c : ‚ÑÇ
R C : ‚Ñù
hR : 0 < R
hc : ContinuousOn f (sphere c R)
hf : ‚àÄ z ‚àà sphere c R, ‚Äñf z‚Äñ ‚â§ C
Œ∏‚ÇÄ : ‚Ñù
hmem : Œ∏‚ÇÄ ‚àà Ioc 0 (2 * œÄ)
hlt : ‚Äñf (circleMap c R Œ∏‚ÇÄ)‚Äñ < C
‚ä¢ (volume (sorryAx (Set (sorryAx (Type ?u.153827) true)) true)).toReal * R * C = R * C * œÄ * 2","theorem norm_integral_lt_of_norm_le_const_of_lt {f : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {R C : ‚Ñù} (hR : 0 < R)
    (hc : ContinuousOn f (sphere c R)) (hf : ‚àÄ z ‚àà sphere c R, ‚Äñf z‚Äñ ‚â§ C)
    (hlt : ‚àÉ z ‚àà sphere c R, ‚Äñf z‚Äñ < C) : ‚Äñ‚àÆ z in C(c, R), f z‚Äñ < 2 * œÄ * R * C ",":= by
  rw [‚Üê _root_.abs_of_pos hR, ‚Üê image_circleMap_Ioc] at hlt
  rcases hlt with ‚ü®_, ‚ü®Œ∏‚ÇÄ, hmem, rfl‚ü©, hlt‚ü©
  calc
    ‚Äñ‚àÆ z in C(c, R), f z‚Äñ ‚â§ ‚à´ Œ∏ in (0)..2 * œÄ, ‚Äñderiv (circleMap c R) Œ∏ ‚Ä¢ f (circleMap c R Œ∏)‚Äñ :=
      intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le
    _ < ‚à´ _ in (0)..2 * œÄ, R * C := by
      simp only [norm_smul, deriv_circleMap, norm_eq_abs, map_mul, abs_I, mul_one,
        abs_circleMap_zero, abs_of_pos hR]
      refine intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt
          Real.two_pi_pos ?_ continuousOn_const (fun Œ∏ _ => ?_) ‚ü®Œ∏‚ÇÄ, Ioc_subset_Icc_self hmem, ?_‚ü©
      ¬∑ exact continuousOn_const.mul (hc.comp (continuous_circleMap _ _).continuousOn fun Œ∏ _ =>
          circleMap_mem_sphere _ hR.le _).norm
      ¬∑ exact mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere _ hR.le _) hR.le
      ¬∑ exact (mul_lt_mul_left hR).2 hlt
    _ = 2 * œÄ * R * C := by simp [mul_assoc]; ring",":= by
  rw [‚Üê _root_.abs_of_pos hR, ‚Üê image_circleMap_Ioc] at hlt
  rcases hlt with ‚ü®_, ‚ü®Œ∏‚ÇÄ, hmem, rfl‚ü©, hlt‚ü©
  calc
    ‚Äñ‚àÆ z in C(c, R), f z‚Äñ ‚â§ ‚à´ Œ∏ in [0:2 * œÄ], ‚Äñderiv (circleMap c R) Œ∏ ‚Ä¢ f (circleMap c R Œ∏)‚Äñ :=
      intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le
    _ < ‚à´ _ in [0:2 * œÄ], R * C := by
      simp only [norm_smul, deriv_circleMap, norm_eq_abs, map_mul, abs_I, mul_one,
        abs_circleMap_zero, abs_of_pos hR]
      refine intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt
          Real.two_pi_pos _ continuousOn_const (fun Œ∏ _ => ?_) ‚ü®Œ∏‚ÇÄ, Ioc_subset_Icc_self hmem, ?_‚ü©
      ¬∑ exact continuousOn_const.mul (hc.comp (continuous_circleMap _ _).continuousOn fun Œ∏ _ =>
          circleMap_mem_sphere _ hR.le _).norm
      ¬∑ exact mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere _ hR.le _) hR.le
      ¬∑ exact (mul_lt_mul_left hR).2 hlt
    _ = 2 * œÄ * R * C := by simp [mul_assoc]; ring"
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,1aadd4f4012334f6f1cd811e685b9c75a27ee9ed,":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x)
  ¬∑ simp_rw [inversion, dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π
    ¬∑ rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  unexpected token '¬∑'; expected '|'
error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ F ‚ÜíL[‚Ñù] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x ‚Ü¶ c + x) x) c) ^ 2 ‚Ä¢
      ‚Üë{ toLinearEquiv := (reflection (Submodule.span ‚Ñù {(fun x ‚Ü¶ c + x) x - c})·óÆ).toLinearEquiv, continuous_toFun := ‚ãØ,
          continuous_invFun := ‚ãØ })
    ((fun x ‚Ü¶ c + x) x)","theorem hasFDerivAt_inversion (hx : x ‚â† c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 ‚Ä¢ (reflection (‚Ñù ‚àô (x - c))·óÆ : F ‚ÜíL[‚Ñù] F)) x ",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (?_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x)
  ¬∑ simp_rw [inversion, dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π
    ¬∑ rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]"
Mathlib/GroupTheory/Exponent.lean,Monoid.exponent_prod,Monoid.exponent_prod,554c20d1eb6d2f1f6a5b53ccd3a727a93147a4de,":= by
  refine dvd_antisymm ?_ (lcm_dvd ?_ ?_)
  ¬∑ refine exponent_dvd_of_forall_pow_eq_one _ _ fun g ‚Ü¶ ?_
    ext1
    ¬∑ rw [Prod.pow_fst, Prod.fst_one, ‚Üê orderOf_dvd_iff_pow_eq_one]
      exact dvd_trans (Monoid.order_dvd_exponent (g.1)) <| dvd_lcm_left _ _
    ¬∑ rw [Prod.pow_snd, Prod.snd_one, ‚Üê orderOf_dvd_iff_pow_eq_one]
      exact dvd_trans (Monoid.order_dvd_exponent (g.2)) <| dvd_lcm_right _ _
  ¬∑ exact MonoidHom.exponent_dvd (f := MonoidHom.fst M‚ÇÅ M‚ÇÇ) Prod.fst_surjective
  ¬∑ exact MonoidHom.exponent_dvd (f := MonoidHom.snd M‚ÇÅ M‚ÇÇ) Prod.snd_surjective","error:  function expected at
  exponent_dvd_of_forall_pow_eq_one ?m.101884
term has type
  exponent ?m.101881 ‚à£ ?m.101883
error:  no goals to be solved","theorem Monoid.exponent_prod {M‚ÇÅ M‚ÇÇ : Type*} [Monoid M‚ÇÅ] [Monoid M‚ÇÇ] :
    exponent (M‚ÇÅ √ó M‚ÇÇ) = lcm (exponent M‚ÇÅ) (exponent M‚ÇÇ) ",":= by
  refine dvd_antisymm ?_ (lcm_dvd ?_ ?_)
  ¬∑ refine exponent_dvd_of_forall_pow_eq_one fun g ‚Ü¶ ?_
    ext1
    ¬∑ rw [Prod.pow_fst, Prod.fst_one, ‚Üê orderOf_dvd_iff_pow_eq_one]
      exact dvd_trans (Monoid.order_dvd_exponent (g.1)) <| dvd_lcm_left _ _
    ¬∑ rw [Prod.pow_snd, Prod.snd_one, ‚Üê orderOf_dvd_iff_pow_eq_one]
      exact dvd_trans (Monoid.order_dvd_exponent (g.2)) <| dvd_lcm_right _ _
  ¬∑ exact MonoidHom.exponent_dvd (f := MonoidHom.fst M‚ÇÅ M‚ÇÇ) Prod.fst_surjective
  ¬∑ exact MonoidHom.exponent_dvd (f := MonoidHom.snd M‚ÇÅ M‚ÇÇ) Prod.snd_surjective",":= by
  refine dvd_antisymm ?_ (lcm_dvd ?_ ?_)
  ¬∑ refine exponent_dvd_of_forall_pow_eq_one _ _ fun g ‚Ü¶ ?_
    ext1
    ¬∑ rw [Prod.pow_fst, Prod.fst_one, ‚Üê orderOf_dvd_iff_pow_eq_one]
      exact dvd_trans (Monoid.order_dvd_exponent (g.1)) <| dvd_lcm_left _ _
    ¬∑ rw [Prod.pow_snd, Prod.snd_one, ‚Üê orderOf_dvd_iff_pow_eq_one]
      exact dvd_trans (Monoid.order_dvd_exponent (g.2)) <| dvd_lcm_left _ _
    ¬∑ rw [Prod.pow_snd, Prod.snd_one, ‚Üê orderOf_dvd_iff_pow_eq_one]
      exact dvd_trans (Monoid.order_dvd_exponent (g.2)) <| dvd_lcm_right _ _
  ¬∑ exact MonoidHom.exponent_dvd (f := MonoidHom.fst M‚ÇÅ M‚ÇÇ) Prod.snd_surjective"
Mathlib/Logic/Function/Basic.lean,Function.cantor_injective,cantor_injective,ef3c9bcd07782b044027916a64e925f3e4951707,"  | i => cantor_surjective (fun a ‚Ü¶ {b | ‚àÄ U, a = f U ‚Üí U.toPred b}) <|
         RightInverse.surjective (fun U ‚Ü¶ Set.ext fun _ ‚Ü¶ ‚ü®fun h ‚Ü¶ h U rfl, fun h _ e ‚Ü¶ i e ‚ñ∏ h‚ü©)","error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  U
has type
  Set Œ±
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  U
has type
  Œ± ‚Üí Prop
warning:  @HasUncurry.uncurry does not have a doc string","theorem cantor_injective {Œ± : Type*} (f : Set Œ± ‚Üí Œ±) : ¬¨Injective f
","  | i => cantor_surjective (fun a ‚Ü¶ {b | ‚àÄ U, a = f U ‚Üí U b}) <|
         RightInverse.surjective (fun U ‚Ü¶ Set.ext fun _ ‚Ü¶ ‚ü®fun h ‚Ü¶ h U rfl, fun h _ e ‚Ü¶ i e ‚ñ∏ h‚ü©)",":=
  | i => cantor_surjective (fun a ‚Ü¶ {b | ‚àÄ U, a = f U ‚Üí U.toPred b}) <|
        RightInverse.surjective (fun U ‚Ü¶ Set.ext fun _ ‚Ü¶ ‚ü®fun h ‚Ü¶ h U rfl, fun h _ e ‚Ü¶ i e ‚ñ∏ h)"
Mathlib/Data/Nat/Factorial/Cast.lean,Nat.cast_descFactorial_two,cast_descFactorial_two,0c15e4238484dc82267246469e9c01f5f42f2ccb,":= by
  rw [cast_descFactorial]
  cases a
  ¬∑ simp
  ¬∑ rw [succ_sub_succ, tsub_zero, cast_succ, add_sub_cancel, ascPochhammer_succ_right,
      ascPochhammer_one, Polynomial.X_mul, Polynomial.eval_mul_X, Polynomial.eval_add,
      Polynomial.eval_X, cast_one, Polynomial.eval_one]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
case succ
S : Type u_1
inst‚úù : Ring S
b n‚úù : ‚Ñï
‚ä¢ Polynomial.eval (‚Üën‚úù) (ascPochhammer S 2) = (‚Üën‚úù + 1) * (‚Üën‚úù + 1 - 1)",theorem cast_descFactorial_two : (a.descFactorial 2 : S) = a * (a - 1) ,":= by
  rw [cast_descFactorial]
  cases a
  ¬∑ simp
  ¬∑ rw [succ_sub_succ, tsub_zero, cast_succ, add_sub_cancel_right, ascPochhammer_succ_right,
      ascPochhammer_one, Polynomial.X_mul, Polynomial.eval_mul_X, Polynomial.eval_add,
      Polynomial.eval_X, cast_one, Polynomial.eval_one]",":= by
  rw [cast_descFactorial]
  cases a
  ¬∑ simp
  ¬∑ rw [succ_sub_succ, tsub_zero, cast_succ, add_sub_cancel_right,
      ascPochhammer_one, Polynomial.X_mul, Polynomial.eval_mul_X, Polynomial.eval_add,
      Polynomial.eval_X, cast_one, Polynomial.eval_one]"
Mathlib/Data/List/Indexes.lean,List.map_enumFrom_eq_zipWith,map_enumFrom_eq_zipWith,dc0b2fb410ce57ee8ea5b9ce5b357ce030465e7a,":= by
  intro l
  generalize e : l.length = len
  revert l
  induction' len with len ih <;> intros l e n f
  ¬∑ have : l = [] := by
      cases l
      ¬∑ rfl
      ¬∑ contradiction
    rw [this]; rfl
  ¬∑ cases' l with head tail
    ¬∑ contradiction
    ¬∑ simp only [map, uncurry_apply_pair, range_succ_eq_map, zipWith, Nat.zero_add,
        zipWith_map_left]
      rw [ih]
      ¬∑ suffices (fun i ‚Ü¶ f (i + (n + 1))) = ((fun i ‚Ü¶ f (i + n)) ‚àò Nat.succ) by
          rw [this]
          rfl
        funext n' a
        simp only [comp, ‚Üê Nat.add_assoc', Nat.add_comm, Nat.add_succ]
      simp only [length_cons, Nat.succ.injEq] at e; exact e","error:  unknown constant 'Nat.add_assoc''
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem map_enumFrom_eq_zipWith : ‚àÄ (l : List Œ±) (n : ‚Ñï) (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤),
    map (uncurry f) (enumFrom n l) = zipWith (fun i ‚Ü¶ f (i + n)) (range (length l)) l ",":= by
  intro l
  generalize e : l.length = len
  revert l
  induction' len with len ih <;> intros l e n f
  ¬∑ have : l = [] := by
      cases l
      ¬∑ rfl
      ¬∑ contradiction
    rw [this]; rfl
  ¬∑ cases' l with head tail
    ¬∑ contradiction
    ¬∑ simp only [map, uncurry_apply_pair, range_succ_eq_map, zipWith, Nat.zero_add,
        zipWith_map_left]
      rw [ih]
      ¬∑ suffices (fun i ‚Ü¶ f (i + (n + 1))) = ((fun i ‚Ü¶ f (i + n)) ‚àò Nat.succ) by
          rw [this]
          rfl
        funext n' a
        simp only [comp, Nat.add_assoc, Nat.add_comm, Nat.add_succ]
      simp only [length_cons, Nat.succ.injEq] at e; exact e",":= by
  intro l
  generalize e : l.length = len
  revert l
  induction' len with len ih <;> intros l e n f
  ¬∑ have : l = [] := by
      cases l
      ¬∑ rfl
      ¬∑ contradiction
    rw [this]; rfl
  ¬∑ cases' l with head tail
    ¬∑ contradiction
    ¬∑ simp only [map, uncurry_apply_pair, range_succ_eq_map, zipWith, Nat.zero_add,
        zipWith_map_left]
      rw [ih]
      ¬∑ suffices (fun i ‚Ü¶ f (i + (n + 1))) = ((fun i ‚Ü¶ f (i + n)) ‚àò Nat.succ) by
          rw [this]
          rfl
        funext n' a
        simp only [comp, ‚Üê Nat.add_assoc, Nat.add_comm, Nat.add_succ]
      simp only [length_cons, Nat.succ.injEq] at e; exact e"
Mathlib/Analysis/Convolution.lean,MeasureTheory.hasFDerivAt_convolution_right_with_param,hasFDerivAt_convolution_right_with_param,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine' (hasFDerivAt_zero_of_eventually_const 0 _).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_open (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s
      ¬∑ exact Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine' ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, _, _‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C; exact ht.subset_closedBall_lt 0 0
    refine' ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => _‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine' mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), _, _‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine' (HasCompactSupport.convolutionExists_right L _ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_open (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº
  exact hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine' ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, _‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    apply eventually_of_forall
    intro a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    apply eventually_of_forall
    intro a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, id.def, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6","error:  invalid field 'continuousOn_fderiv_of_open', the environment does not contain 'ContDiffOn.continuousOn_fderiv_of_open'
  hg
has type
  ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hg
has type
  ‚àÄ x ‚àà s √óÀ¢ univ, ContDiffWithinAt ùïú 1 (‚Üøg) (s √óÀ¢ univ) x
error:  invalid field 'continuousOn_fderiv_of_open', the environment does not contain 'ContDiffOn.continuousOn_fderiv_of_open'
  hg
has type
  ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hg
has type
  ‚àÄ x ‚àà s √óÀ¢ univ, ContDiffWithinAt ùïú 1 (‚Üøg) (s √óÀ¢ univ) x
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1585924 ‚Üí ?m.1585924
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1586219 ‚Üí ?m.1586219
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  unsolved goals
case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.1 = (_root_.id x).1

case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.2 - a = (_root_.id x).2 - a","theorem hasFDerivAt_convolution_right_with_param {g : P ‚Üí G ‚Üí E'} {s : Set P} {k : Set G}
    (hs : IsOpen s) (hk : IsCompact k) (hgs : ‚àÄ p, ‚àÄ x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0)
    (hf : LocallyIntegrable f Œº) (hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)) (q‚ÇÄ : P √ó G)
    (hq‚ÇÄ : q‚ÇÄ.1 ‚àà s) :
    HasFDerivAt (fun q : P √ó G => (f ‚ãÜ[L, Œº] g q.1) q.2)
      ((f ‚ãÜ[L.precompR (P √ó G), Œº] fun x : G => fderiv ùïú (‚Üøg) (q‚ÇÄ.1, x)) q‚ÇÄ.2) q‚ÇÄ ",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s := Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C := ht.subset_closedBall_lt 0 0
    refine ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => ?_‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), ?_, ?_‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine (HasCompactSupport.convolutionExists_right L ?_ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº :=
    hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, ?_‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    filter_upwards with a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    filter_upwards with a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, _root_.id, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_open (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s
      ¬∑ exact Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le"
Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean,MeasureTheory.TendstoInMeasure.exists_seq_tendsto_ae,TendstoInMeasure.exists_seq_tendsto_ae,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  have h_lt_Œµ_real : ‚àÄ (Œµ : ‚Ñù) (_ : 0 < Œµ), ‚àÉ k : ‚Ñï, 2 * (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := by
    intro Œµ hŒµ
    obtain ‚ü®k, h_k‚ü© : ‚àÉ k : ‚Ñï, (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := exists_pow_lt_of_lt_one hŒµ (by norm_num)
    refine' ‚ü®k + 1, (le_of_eq _).trans_lt h_k‚ü©
    rw [pow_add]; ring
  set ns := ExistsSeqTendstoAe.seqTendstoAeSeq hfg
  use ns
  let S := fun k => { x | (2 : ‚Ñù)‚Åª¬π ^ k ‚â§ dist (f (ns k) x) (g x) }
  have hŒºS_le : ‚àÄ k, Œº (S k) ‚â§ (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ k :=
    fun k => ExistsSeqTendstoAe.seqTendstoAeSeq_spec hfg k (ns k) le_rfl
  set s := Filter.atTop.limsup S with hs
  have hŒºs : Œº s = 0 := by
    refine' measure_limsup_eq_zero (ne_of_lt <| lt_of_le_of_lt (ENNReal.tsum_le_tsum hŒºS_le) _)
    simp only [ENNReal.tsum_geometric, ENNReal.one_sub_inv_two, inv_inv]
  have h_tendsto : ‚àÄ x ‚àà s·∂ú, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) := by
    refine' fun x hx => Metric.tendsto_atTop.mpr fun Œµ hŒµ => _
    rw [hs, limsup_eq_iInf_iSup_of_nat] at hx
    simp only [Set.iSup_eq_iUnion, Set.iInf_eq_iInter, Set.compl_iInter, Set.compl_iUnion,
      Set.mem_iUnion, Set.mem_iInter, Set.mem_compl_iff, Set.mem_setOf_eq, not_le] at hx
    obtain ‚ü®N, hNx‚ü© := hx
    obtain ‚ü®k, hk_lt_Œµ‚ü© := h_lt_Œµ_real Œµ hŒµ
    refine' ‚ü®max N (k - 1), fun n hn_ge => lt_of_le_of_lt _ hk_lt_Œµ‚ü©
    specialize hNx n ((le_max_left _ _).trans hn_ge)
    have h_inv_n_le_k : (2 : ‚Ñù)‚Åª¬π ^ n ‚â§ 2 * (2 : ‚Ñù)‚Åª¬π ^ k := by
      rw [mul_comm, ‚Üê inv_mul_le_iff' (zero_lt_two' ‚Ñù)]
      conv_lhs =>
        congr
        rw [‚Üê pow_one (2 : ‚Ñù)‚Åª¬π]
      rw [‚Üê pow_add, add_comm]
      exact pow_le_pow_of_le_one (one_div (2 : ‚Ñù) ‚ñ∏ one_half_pos.le) (inv_le_one one_le_two)
        ((le_tsub_add.trans (add_le_add_right (le_max_right _ _) 1)).trans
          (add_le_add_right hn_ge 1))
    exact le_trans hNx.le h_inv_n_le_k
  rw [ae_iff]
  refine' ‚ü®ExistsSeqTendstoAe.seqTendstoAeSeq_strictMono hfg, measure_mono_null (fun x => _) hŒºs‚ü©
  rw [Set.mem_setOf_eq, ‚Üê @Classical.not_not (x ‚àà s), not_imp_not]
  exact h_tendsto x","error:  unsolved goals
Œ± : Type u_1
Œπ : Type u_2
E : Type u_3
m : MeasurableSpace Œ±
Œº : Measure Œ±
inst‚úù : MetricSpace E
f : ‚Ñï ‚Üí Œ± ‚Üí E
g : Œ± ‚Üí E
hfg : TendstoInMeasure Œº f atTop g
h_lt_Œµ_real : ‚àÄ (Œµ : ‚Ñù), 0 < Œµ ‚Üí ‚àÉ k, 2 * 2‚Åª¬π ^ k < Œµ
ns : ‚Ñï ‚Üí ‚Ñï := ExistsSeqTendstoAe.seqTendstoAeSeq hfg
S : ‚Ñï ‚Üí Set Œ± := fun k ‚Ü¶ {x | 2‚Åª¬π ^ k ‚â§ dist (f (ns k) x) (g x)}
hŒºS_le : ‚àÄ (k : ‚Ñï), Œº (S k) ‚â§ 2‚Åª¬π ^ k
s : Set Œ± := limsup S atTop
hs : s = limsup S atTop
‚ä¢ 2 < ‚ä§
error:  invalid field 'le', the environment does not contain 'Not.le'
  hNx
has type
  x ‚àâ S n
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hNx
has type
  x ‚àà S n ‚Üí False","theorem TendstoInMeasure.exists_seq_tendsto_ae (hfg : TendstoInMeasure Œº f atTop g) :
    ‚àÉ ns : ‚Ñï ‚Üí ‚Ñï, StrictMono ns ‚àß ‚àÄ·µê x ‚àÇŒº, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) ",":= by
  have h_lt_Œµ_real : ‚àÄ (Œµ : ‚Ñù) (_ : 0 < Œµ), ‚àÉ k : ‚Ñï, 2 * (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := by
    intro Œµ hŒµ
    obtain ‚ü®k, h_k‚ü© : ‚àÉ k : ‚Ñï, (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := exists_pow_lt_of_lt_one hŒµ (by norm_num)
    refine ‚ü®k + 1, (le_of_eq ?_).trans_lt h_k‚ü©
    rw [pow_add]; ring
  set ns := ExistsSeqTendstoAe.seqTendstoAeSeq hfg
  use ns
  let S := fun k => { x | (2 : ‚Ñù)‚Åª¬π ^ k ‚â§ dist (f (ns k) x) (g x) }
  have hŒºS_le : ‚àÄ k, Œº (S k) ‚â§ (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ k :=
    fun k => ExistsSeqTendstoAe.seqTendstoAeSeq_spec hfg k (ns k) le_rfl
  set s := Filter.atTop.limsup S with hs
  have hŒºs : Œº s = 0 := by
    refine measure_limsup_eq_zero (ne_of_lt <| lt_of_le_of_lt (ENNReal.tsum_le_tsum hŒºS_le) ?_)
    simp only [ENNReal.tsum_geometric, ENNReal.one_sub_inv_two, ENNReal.two_lt_top, inv_inv]
  have h_tendsto : ‚àÄ x ‚àà s·∂ú, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) := by
    refine fun x hx => Metric.tendsto_atTop.mpr fun Œµ hŒµ => ?_
    rw [hs, limsup_eq_iInf_iSup_of_nat] at hx
    simp only [S, Set.iSup_eq_iUnion, Set.iInf_eq_iInter, Set.compl_iInter, Set.compl_iUnion,
      Set.mem_iUnion, Set.mem_iInter, Set.mem_compl_iff, Set.mem_setOf_eq, not_le] at hx
    obtain ‚ü®N, hNx‚ü© := hx
    obtain ‚ü®k, hk_lt_Œµ‚ü© := h_lt_Œµ_real Œµ hŒµ
    refine ‚ü®max N (k - 1), fun n hn_ge => lt_of_le_of_lt ?_ hk_lt_Œµ‚ü©
    specialize hNx n ((le_max_left _ _).trans hn_ge)
    have h_inv_n_le_k : (2 : ‚Ñù)‚Åª¬π ^ n ‚â§ 2 * (2 : ‚Ñù)‚Åª¬π ^ k := by
      rw [mul_comm, ‚Üê inv_mul_le_iff' (zero_lt_two' ‚Ñù)]
      conv_lhs =>
        congr
        rw [‚Üê pow_one (2 : ‚Ñù)‚Åª¬π]
      rw [‚Üê pow_add, add_comm]
      exact pow_le_pow_of_le_one (one_div (2 : ‚Ñù) ‚ñ∏ one_half_pos.le) (inv_le_one one_le_two)
        ((le_tsub_add.trans (add_le_add_right (le_max_right _ _) 1)).trans
          (add_le_add_right hn_ge 1))
    exact le_trans hNx.le h_inv_n_le_k
  rw [ae_iff]
  refine ‚ü®ExistsSeqTendstoAe.seqTendstoAeSeq_strictMono hfg, measure_mono_null (fun x => ?_) hŒºs‚ü©
  rw [Set.mem_setOf_eq, ‚Üê @Classical.not_not (x ‚àà s), not_imp_not]
  exact h_tendsto x",":= by
  have h_lt_Œµ_real : ‚àÄ (Œµ : ‚Ñù) (_ : 0 < Œµ), ‚àÉ k : ‚Ñï, 2 * (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := by
    intro Œµ hŒµ
    obtain ‚ü®k, h_k‚ü© : ‚àÉ k : ‚Ñï, (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := exists_pow_lt_of_lt_one hŒµ (by norm_num)
    refine ‚ü®k + 1, (le_of_eq ?_).trans_lt h_k‚ü©
    rw [pow_add]; ring
  set ns := ExistsSeqTendstoAe.seqTendstoAeSeq hfg
  use ns
  let S := fun k => { x | (2 : ‚Ñù)‚Åª¬π ^ k ‚â§ dist (f (ns k) x) (g x) }
  have hŒºS_le : ‚àÄ k, Œº (S k) ‚â§ (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ k :=
    fun k => ExistsSeqTendstoAe.seqTendstoAeSeq_spec hfg k (ns k) le_rfl
  set s := Filter.atTop.limsup S with hs
  have hŒºs : Œº s = 0 := by
    refine measure_limsup_eq_zero (ne_of_lt <| lt_of_le_of_lt (ENNReal.tsum_le_tsum hŒºS_le) ?_)
    simp only [ENNReal.tsum_geometric, ENNReal.one_sub_inv_two, inv_inv]
  have h_tendsto : ‚àÄ x ‚àà s·∂ú, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) := by
    refine fun x hx => Metric.tendsto_atTop.mpr fun Œµ hŒµ => ?_
    rw [hs, limsup_eq_iInf_iSup_of_nat] at hx
    simp only [Set.iSup_eq_iUnion, Set.iInf_eq_iInter, Set.compl_iInter, Set.compl_iUnion,
      Set.mem_iUnion, Set.mem_iInter, Set.mem_compl_iff, Set.mem_setOf_eq, not_le] at hx
    obtain ‚ü®N, hNx‚ü© := hx
    obtain ‚ü®k, hk_lt_Œµ‚ü© := h_lt_Œµ_real Œµ hŒµ
    refine ‚ü®max N (k - 1), fun n hn_ge => lt_of_le_of_lt ?_ hk_lt_Œµ‚ü©
    specialize hNx n ((le_max_left _ _).trans hn_ge)
    have h_inv_n_le_k : (2 : ‚Ñù)‚Åª¬π ^ n ‚â§ 2 * (2 : ‚Ñù)‚Åª¬π ^ k := by
      rw [mul_comm, ‚Üê inv_mul_le_iff' (zero_lt_two' ‚Ñù)]
      conv_lhs =>
        congr
        rw [‚Üê pow_one (2 : ‚Ñù)‚Åª¬π]
      rw [‚Üê pow_add, add_comm]
      exact pow_le_pow_of_le_one (one_div (2 : ‚Ñù) ‚ñ∏ one_half_pos.le) (inv_le_one one_le_two)
        ((le_tsub_add.trans (add_le_add_right (le_max_right _ _) 1)).trans
          (add_le_add_right hn_ge 1))
    exact le_trans hNx.le h_inv_n_le_k
  rw [ae_iff]
  refine ‚ü®ExistsSeqTendstoAe.seqTendstoAeSeq_strictMono hfg, measure_mono_null (fun x => ?_) hŒºs‚ü©
  rw [Set.mem_setOf_eq, ‚Üê @Classical.not_not (x ‚àà s), not_imp_not]
  exact h_tendsto x"
Mathlib/MeasureTheory/Measure/WithDensity.lean,MeasureTheory.ae_withDensity_iff_ae_restrict,ae_withDensity_iff_ae_restrict,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  rw [ae_withDensity_iff' hf, ae_restrict_iff'‚ÇÄ]
  ¬∑ simp only [mem_setOf]
  ¬∑ rcases hf with ‚ü®g, hg, hfg‚ü©
    have nonneg_eq_ae : {x | g x ‚â† 0}.toPred =·µê[Œº] {x | f x ‚â† 0}.toPred := by
      filter_upwards [hfg] with a ha
      simp only [eq_iff_iff]
      exact ‚ü®fun (h : g a ‚â† 0) ‚Ü¶ by rwa [‚Üê ha] at h,
             fun (h : f a ‚â† 0) ‚Ü¶ by rwa [ha] at h‚ü©
    exact NullMeasurableSet.congr
      (MeasurableSet.nullMeasurableSet
        <| hg (measurableSet_singleton _)).compl
      nonneg_eq_ae","error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  {x | g x ‚â† 0}
has type
  Set Œ±
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  {x | g x ‚â† 0}
has type
  Œ± ‚Üí Prop
error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  {x | f x ‚â† 0}
has type
  Set Œ±
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  {x | f x ‚â† 0}
has type
  Œ± ‚Üí Prop","theorem ae_withDensity_iff_ae_restrict' {p : Œ± ‚Üí Prop} {f : Œ± ‚Üí ‚Ñù‚â•0‚àû}
    (hf : AEMeasurable f Œº) :
    (‚àÄ·µê x ‚àÇŒº.withDensity f, p x) ‚Üî ‚àÄ·µê x ‚àÇŒº.restrict { x | f x ‚â† 0 }, p x ",":= by
  rw [ae_withDensity_iff' hf, ae_restrict_iff'‚ÇÄ]
  ¬∑ simp only [mem_setOf]
  ¬∑ rcases hf with ‚ü®g, hg, hfg‚ü©
    have nonneg_eq_ae : {x | g x ‚â† 0} =·µê[Œº] {x | f x ‚â† 0} := by
      filter_upwards [hfg] with a ha
      simp only [eq_iff_iff]
      exact ‚ü®fun (h : g a ‚â† 0) ‚Ü¶ by rwa [‚Üê ha] at h,
             fun (h : f a ‚â† 0) ‚Ü¶ by rwa [ha] at h‚ü©
    exact NullMeasurableSet.congr
      (MeasurableSet.nullMeasurableSet
        <| hg (measurableSet_singleton _)).compl
      nonneg_eq_ae",":= by
  rw [ae_withDensity_iff' hf, ae_restrict_iff'‚ÇÄ]
  ¬∑ simp only [mem_setOf]
  ¬∑ rcases hf with ‚ü®g, hg, hfg‚ü©
    have nonneg_eq_ae : {x | g x ‚â† 0}.toPred =·µê[Œº] {x | f x ‚â† 0}.toPred := by
      filter_upwards [hfg] with a ha
      simp only [eq_iff_iff]
      exact ‚ü®fun (h : g a ‚â† 0) ‚Ü¶ by rwa [‚Üê ha] at h,
             fun (h : f a ‚â† 0) ‚Ü¶ by rwa [ha] at h‚ü©
    exact NullMeasurableSet.congr
      (MeasurableSet.nullMeasurableSet
        <| hg (measurableSet_singleton _)).compl
      nonneg_eq_ae"
Mathlib/CategoryTheory/Sites/Sheafification.lean,CategoryTheory.isIso_toSheafify,isIso_toSheafify,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine ‚ü®(sheafificationAdjunction J D |>.counit.app ‚ü®P, hP‚ü©).val, ?_, ?_‚ü©
  ¬∑ change _ = (ùüô (sheafToPresheaf J D ‚ãô ùü≠ (C·µí·µñ ‚•§ D)) : _).app ‚ü®P, hP‚ü©
    rw [‚Üê sheafificationAdjunction J D |>.right_triangle]
    rfl
  ¬∑ change (sheafToPresheaf _ _).map _ ‚â´ _ = _
    change _ ‚â´ (sheafificationAdjunction J D).unit.app ((sheafToPresheaf J D).obj ‚ü®P, hP‚ü©) = _
    erw [‚Üê inv_counit_map (sheafificationAdjunction J D) (X := ‚ü®P, hP‚ü©), comp_inv_eq_id]","error:  unknown identifier 'inv_counit_map'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.22344
case refine_2
C : Type u‚ÇÅ
inst‚úù¬≥ : Category.{v‚ÇÅ, u‚ÇÅ} C
J : GrothendieckTopology C
A : Type u‚ÇÇ
inst‚úù¬≤ : Category.{v‚ÇÇ, u‚ÇÇ} A
D : Type u_1
inst‚úù¬π : Category.{u_2, u_1} D
inst‚úù : HasWeakSheafify J D
P : C·µí·µñ ‚•§ D
hP : Presheaf.IsSheaf J P
‚ä¢ (sheafToPresheaf J D).map ((sheafificationAdjunction J D).counit.app { val := P, cond := hP }) ‚â´
      (sheafificationAdjunction J D).unit.app ((sheafToPresheaf J D).obj { val := P, cond := hP }) =
    ùüô (sheafify J P)",theorem isIso_toSheafify {P : C·µí·µñ ‚•§ D} (hP : Presheaf.IsSheaf J P) : IsIso (toSheafify J P) ,":= by
  refine ‚ü®(sheafificationAdjunction J D |>.counit.app ‚ü®P, hP‚ü©).val, ?_, ?_‚ü©
  ¬∑ change _ = (ùüô (sheafToPresheaf J D ‚ãô ùü≠ (C·µí·µñ ‚•§ D)) : _).app ‚ü®P, hP‚ü©
    rw [‚Üê sheafificationAdjunction J D |>.right_triangle]
    rfl
  ¬∑ change (sheafToPresheaf _ _).map _ ‚â´ _ = _
    change _ ‚â´ (sheafificationAdjunction J D).unit.app ((sheafToPresheaf J D).obj ‚ü®P, hP‚ü©) = _
    erw [‚Üê (sheafificationAdjunction J D).inv_counit_map  (X := ‚ü®P, hP‚ü©), comp_inv_eq_id]",":= by
  refine ‚ü®(sheafificationAdjunction J D |>.counit.app ‚ü®P, hP‚ü©).val, ?_, ?_‚ü©
  ¬∑ change _ = (ùüô (sheafToPresheaf J D ‚ãô ùü≠ (C·µí·µñ ‚•§ D)) : _).app ‚ü®P, hP‚ü©
    rw [‚Üê sheafificationAdjunction J D |>.right_triangle]
    rfl
  ¬∑ change (sheafToPresheaf _ _).map _ ‚â´ _ = _
    change _ ‚â´ (sheafificationAdjunction J D).unit.app ((sheafToPresheaf J D).obj ‚ü®P, hP‚ü©) = _
    erw [‚Üê inv_counit_map (sheafificationAdjunction J D) (X := ‚ü®P, hP‚ü©), comp_inv_eq_id]"
Mathlib/MeasureTheory/Measure/Typeclasses.lean,IsCompact.exists_open_superset_measure_lt_top,exists_open_superset_measure_lt_top,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine IsCompact.induction_on h ?_ ?_? _? _
  ¬∑ use ‚àÖ
    simp [Superset]
  ¬∑ rintro s t hst ‚ü®U, htU, hUo, hU‚ü©
    exact ‚ü®U, hst.trans htU, hUo, hU‚ü©
  ¬∑ rintro s t ‚ü®U, hsU, hUo, hU‚ü© ‚ü®V, htV, hVo, hV‚ü©
    refine'
      ‚ü®U ‚à™ V, union_subset_union hsU htV, hUo.union hVo,
        (measure_union_le _ _).trans_lt <| ENNReal.add_lt_top.2 ‚ü®hU, hV‚ü©‚ü©
  ¬∑ intro x hx
    rcases (hŒº x hx).exists_mem_basis (nhds_basis_opens _) with ‚ü®U, ‚ü®hx, hUo‚ü©, hU‚ü©
    exact ‚ü®U, nhdsWithin_le_nhds (hUo.mem_nhds hx), U, Subset.rfl, hUo, hU‚ü©","error:  unknown identifier '_?'
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
Œ¥ : Type u_3
Œπ : Type u_4
inst‚úù¬π : TopologicalSpace Œ±
inst‚úù : MeasurableSpace Œ±
Œº : Measure Œ±
s : Set Œ±
h : IsCompact s
hŒº : ‚àÄ x ‚àà s, Œº.FiniteAtFilter (ùìù x)
‚ä¢ ‚àÉ U ‚äá s, IsOpen U ‚àß Œº U < ‚ä§","theorem exists_open_superset_measure_lt_top' (h : IsCompact s)
    (hŒº : ‚àÄ x ‚àà s, Œº.FiniteAtFilter (ùìù x)) : ‚àÉ U ‚äá s, IsOpen U ‚àß Œº U < ‚àû ",":= by
  refine IsCompact.induction_on h ?_ ?_ ?_ ?_
  ¬∑ use ‚àÖ
    simp [Superset]
  ¬∑ rintro s t hst ‚ü®U, htU, hUo, hU‚ü©
    exact ‚ü®U, hst.trans htU, hUo, hU‚ü©
  ¬∑ rintro s t ‚ü®U, hsU, hUo, hU‚ü© ‚ü®V, htV, hVo, hV‚ü©
    refine
      ‚ü®U ‚à™ V, union_subset_union hsU htV, hUo.union hVo,
        (measure_union_le _ _).trans_lt <| ENNReal.add_lt_top.2 ‚ü®hU, hV‚ü©‚ü©
  ¬∑ intro x hx
    rcases (hŒº x hx).exists_mem_basis (nhds_basis_opens _) with ‚ü®U, ‚ü®hx, hUo‚ü©, hU‚ü©
    exact ‚ü®U, nhdsWithin_le_nhds (hUo.mem_nhds hx), U, Subset.rfl, hUo, hU‚ü©",":= by
  refine IsCompact.induction_on h ?_ ?_ ?_ ?_
  ¬∑ use ‚àÖ
    simp [Superset]
  ¬∑ rintro s t hst ‚ü®U, htU, hUo, hU‚ü©
    exact ‚ü®U, hst.trans htU, hUo, hU‚ü©
  ¬∑ rintro s t ‚ü®U, hsU, hUo, hU‚ü© ‚ü®V, htV, hVo, hV‚ü©
    refine
      ‚ü®U ‚à™ V, union_subset_union hsU htV, hUo.union hVo,
        (measure_union_le _ _).trans_lt <| ENNReal.add_lt_top.2 ‚ü®hU, hV‚ü©‚ü©
  ¬∑ intro x hx
    rcases (hŒº x hx).exists_mem_basis nhds_basis_opens _) with ‚ü®U, ‚ü®hx, hUo‚ü©, hU‚ü©
    exact ‚ü®U, nhdsWithin_le_nhds (hUo.mem_nhds hx), U, Subset.rfl, hUo, hU‚ü©"
Mathlib/Data/Fin/Basic.lean,Fin.succ_ne_last_of_lt,succ_ne_last_of_lt,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases n
  ¬∑ exact i.elim0
  ¬∑ rw [succ_ne_last_iff]
    exact ((le_last _).trans_lt' h).ne","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  failed to synthesize
  Preorder (Fin (n‚úù + 1))
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  Preorder (Fin (n‚úù + 1))
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  LE.le.trans_lt' ?m.34716 h
argument
  h
has type
  @LT.lt (Fin (n‚úù + 1)) instLTFin i p : Prop
but is expected to have type
  @LT.lt (Fin (n‚úù + 1)) Preorder.toLT i p : Prop",theorem succ_ne_last_of_lt {p i : Fin n} (h : i < p) : succ i ‚â† last n ,":= by
  cases n
  ¬∑ exact i.elim0
  ¬∑ rw [succ_ne_last_iff, Ne, ext_iff]
    exact ((le_last _).trans_lt' h).ne",":= by
  cases n
  ¬∑ exact i.elim0
  ¬∑ rw [succ_ne_last_iff]
    exact ((le_last _).trans_lt' h).ne"
Mathlib/Analysis/InnerProductSpace/OfNorm.lean,InnerProductSpaceable.inner_.conj_symm,inner_.conj_symm,04be4bbbcadfe3614915c9734fe17dc5503a6635,":= by
  simp only [inner_]
  have h4 : conj (4‚Åª¬π : ùïú) = 4‚Åª¬π := by norm_num
  rw [map_mul, h4]
  congr 1
  simp only [map_sub, map_add, conj_ofReal, map_mul, conj_I]
  rw [add_comm y x, norm_sub_rev]
  by_cases hI : (I : ùïú) = 0
  ¬∑ simp only [hI, neg_zero, zero_mul]
  have : ‚Äñ(I : ùïú)‚Äñ = 1 := by
    rw [‚Üê mul_self_inj_of_nonneg (norm_nonneg I) zero_le_one, one_mul, ‚Üê norm_mul,
      I_mul_I_of_nonzero hI, norm_neg, norm_one]
  have h‚ÇÅ : ‚Äñ(I : ùïú) ‚Ä¢ y - x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x + y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ ((I : ùïú) ‚Ä¢ y - x)‚Äñ
    ¬∑ rw [norm_smul, this, one_mul]
    ¬∑ rw [smul_sub, smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, ‚Üê neg_add', add_comm, norm_neg]
  have h‚ÇÇ : ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ ((I : ùïú) ‚Ä¢ y + x)‚Äñ
    ¬∑ rw [norm_smul, this, one_mul]
    ¬∑ rw [smul_add, smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, ‚Üê neg_add_eq_sub]
  rw [h‚ÇÅ, h‚ÇÇ, ‚Üê sub_add_eq_add_sub]
  simp only [neg_mul, sub_eq_add_neg, neg_neg]","error:  unsolved goals
case pos
ùïú : Type u_1
inst‚úù¬≤ : RCLike ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
x y : E
h4 : (starRingEnd ùïú) 4‚Åª¬π = 4‚Åª¬π
hI : I = 0
‚ä¢ (starRingEnd ùïú) (ùìö ‚Äñx + y‚Äñ) * (starRingEnd ùïú) (ùìö ‚Äñx + y‚Äñ) -
          (starRingEnd ùïú) (ùìö ‚Äñx - y‚Äñ) * (starRingEnd ùïú) (ùìö ‚Äñx - y‚Äñ) +
        0 -
      0 =
    ùìö ‚Äñx + y‚Äñ * ùìö ‚Äñx + y‚Äñ - ùìö ‚Äñx - y‚Äñ * ùìö ‚Äñx - y‚Äñ + 0 - 0
error:  unsolved goals
case neg
ùïú : Type u_1
inst‚úù¬≤ : RCLike ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
x y : E
h4 : (starRingEnd ùïú) 4‚Åª¬π = 4‚Åª¬π
hI : ¬¨I = 0
this : ‚ÄñI‚Äñ = 1
h‚ÇÅ : ‚ÄñI ‚Ä¢ y - x‚Äñ = ‚ÄñI ‚Ä¢ x + y‚Äñ
h‚ÇÇ : ‚ÄñI ‚Ä¢ y + x‚Äñ = ‚ÄñI ‚Ä¢ x - y‚Äñ
‚ä¢ (starRingEnd ùïú) (ùìö ‚Äñx + y‚Äñ) * (starRingEnd ùïú) (ùìö ‚Äñx + y‚Äñ) +
          -((starRingEnd ùïú) (ùìö ‚Äñx + -y‚Äñ) * (starRingEnd ùïú) (ùìö ‚Äñx + -y‚Äñ)) +
        I * (starRingEnd ùïú) (ùìö ‚ÄñI ‚Ä¢ x + y‚Äñ) * (starRingEnd ùïú) (ùìö ‚ÄñI ‚Ä¢ x + y‚Äñ) +
      -(I * (starRingEnd ùïú) (ùìö ‚ÄñI ‚Ä¢ x + -y‚Äñ) * (starRingEnd ùïú) (ùìö ‚ÄñI ‚Ä¢ x + -y‚Äñ)) =
    ùìö ‚Äñx + y‚Äñ * ùìö ‚Äñx + y‚Äñ + -(ùìö ‚Äñx + -y‚Äñ * ùìö ‚Äñx + -y‚Äñ) + I * ùìö ‚ÄñI ‚Ä¢ x + y‚Äñ * ùìö ‚ÄñI ‚Ä¢ x + y‚Äñ +
      -(I * ùìö ‚ÄñI ‚Ä¢ x + -y‚Äñ * ùìö ‚ÄñI ‚Ä¢ x + -y‚Äñ)",theorem inner_.conj_symm (x y : E) : conj (inner_ ùïú y x) = inner_ ùïú x y ,":= by
  simp only [inner_]
  have h4 : conj (4‚Åª¬π : ùïú) = 4‚Åª¬π := by norm_num
  rw [map_mul, h4]
  congr 1
  simp only [map_sub, map_add, algebraMap_eq_ofReal, ‚Üê ofReal_mul, conj_ofReal, map_mul, conj_I]
  rw [add_comm y x, norm_sub_rev]
  by_cases hI : (I : ùïú) = 0
  ¬∑ simp only [hI, neg_zero, zero_mul]
  have : ‚Äñ(I : ùïú)‚Äñ = 1 := by
    rw [‚Üê mul_self_inj_of_nonneg (norm_nonneg I) zero_le_one, one_mul, ‚Üê norm_mul,
      I_mul_I_of_nonzero hI, norm_neg, norm_one]
  have h‚ÇÅ : ‚Äñ(I : ùïú) ‚Ä¢ y - x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x + y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ ((I : ùïú) ‚Ä¢ y - x)‚Äñ
    ¬∑ rw [norm_smul, this, one_mul]
    ¬∑ rw [smul_sub, smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, ‚Üê neg_add', add_comm, norm_neg]
  have h‚ÇÇ : ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ ((I : ùïú) ‚Ä¢ y + x)‚Äñ
    ¬∑ rw [norm_smul, this, one_mul]
    ¬∑ rw [smul_add, smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, ‚Üê neg_add_eq_sub]
  rw [h‚ÇÅ, h‚ÇÇ, ‚Üê sub_add_eq_add_sub]
  simp only [neg_mul, sub_eq_add_neg, neg_neg]",":= by
  simp only [inner_]
  have h4 : conj (4‚Åª¬π : ùïú) = 4‚Åª¬π := by norm_num
  rw [map_mul, h4]
  congr 1
  simp only [map_sub, map_add, conj_ofReal, map_mul, conj_I]
  rw [add_comm y x, norm_sub_rev]
  by_cases hI : (I : ùïú) = 0
  ¬∑ simp only [hI, neg_zero, zero_mul]
  have : ‚Äñ(I : ùïú)‚Äñ = 1 := by
    rw [‚Üê mul_self_inj_of_nonneg (norm_nonneg I) zero_le_one, one_mul, ‚Üê norm_mul,
      I_mul_I_of_nonzero hI, norm_neg, norm_one]
  have h‚ÇÅ : ‚Äñ(I : ùïú) ‚Ä¢ y - x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x + y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ ((I : ùïú) ‚Ä¢ y - x)‚Äñ
    ¬∑ rw [norm_smul, this, one_mul]
    ¬∑ rw [smul_add, smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, ‚Üê neg_add', add_comm, norm_neg]
  have h‚ÇÇ : ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ ((I : ùïú) ‚Ä¢ y + x)‚Äñ
    ¬∑ rw [norm_smul, this, one_mul]
    ¬∑ rw [smul_add, smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, ‚Üê neg_add', add_comm, norm_neg]
  have h‚ÇÇ : ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ ((I : ùïú) ‚Ä¢ y + x)‚Äñ
    ¬∑ rw [norm_smul, this, one_mul]
    ¬∑ rw [smul_add, smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, ‚Üê neg_add', add_comm, norm_neg]
  have h‚ÇÇ : ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    trans ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by"
Mathlib/Combinatorics/SimpleGraph/Operations.lean,SimpleGraph.adj_replaceVertex_iff_of_ne_left,adj_replaceVertex_iff_of_ne_left,f61a485edf966de0b09bd70c1edc7f254cd1b0ae,:= by simp [hw],error:  simp made no progress,"lemma adj_replaceVertex_iff_of_ne_left {w : V} (hw : w ‚â† t) :
    (G.replaceVertex s t).Adj s w ‚Üî G.Adj s w ",":= by simp [replaceVertex, hw]",:= by simp [hw]
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.OuterMeasure.mkMetric'.trim_pre,trim_pre,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  refine le_antisymm (le_pre.2 fun s hs => _) (le_trim _)
  rw [trim_eq_iInf]
  refine iInf_le_of_le (closure s) <| iInf_le_of_le subset_closure <|
    iInf_le_of_le measurableSet_closure ((pre_le _).trans_eq (hcl _))
  rwa [diam_closure]","error:  don't know how to synthesize placeholder
context:
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬≥ : EMetricSpace X
inst‚úù¬≤ : EMetricSpace Y
m‚úù : Set X ‚Üí ‚Ñù‚â•0‚àû
r‚úù : ‚Ñù‚â•0‚àû
Œº : OuterMeasure X
s‚úù : Set X
inst‚úù¬π : MeasurableSpace X
inst‚úù : OpensMeasurableSpace X
m : Set X ‚Üí ‚Ñù‚â•0‚àû
hcl : ‚àÄ (s : Set X), m (closure s) = m s
r : ‚Ñù‚â•0‚àû
s : Set X
hs : diam s ‚â§ r
‚ä¢ (pre m r).trim s ‚â§ m s
error:  unsolved goals
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬≥ : EMetricSpace X
inst‚úù¬≤ : EMetricSpace Y
m‚úù : Set X ‚Üí ‚Ñù‚â•0‚àû
r‚úù : ‚Ñù‚â•0‚àû
Œº : OuterMeasure X
s : Set X
inst‚úù¬π : MeasurableSpace X
inst‚úù : OpensMeasurableSpace X
m : Set X ‚Üí ‚Ñù‚â•0‚àû
hcl : ‚àÄ (s : Set X), m (closure s) = m s
r : ‚Ñù‚â•0‚àû
‚ä¢ (pre m r).trim = pre m r","theorem trim_pre [MeasurableSpace X] [OpensMeasurableSpace X] (m : Set X ‚Üí ‚Ñù‚â•0‚àû)
    (hcl : ‚àÄ s, m (closure s) = m s) (r : ‚Ñù‚â•0‚àû) : (pre m r).trim = pre m r ",":= by
  refine le_antisymm (le_pre.2 fun s hs => ?_) (le_trim _)
  rw [trim_eq_iInf]
  refine iInf_le_of_le (closure s) <| iInf_le_of_le subset_closure <|
    iInf_le_of_le measurableSet_closure ((pre_le ?_).trans_eq (hcl _))
  rwa [diam_closure]",":= by
  refine le_antisymm (le_pre.2 fun s hs => ?_) (le_trim _)
  rw [trim_eq_iInf]
  refine iInf_le_of_le (closure s) <| iInf_le_of_le subset_closure <|
    iInf_le_of_le measurableSet_closure ((pre_le _).trans_eq (hcl _))
  rwa [diam_closure]"
Mathlib/GroupTheory/GroupAction/Period.lean,MulAction.period_pos_of_fixed,period_pos_of_fixed,cef8a766d74101e505f17c2cc18209448b2f6a44,":= by
  rw [fixed_iff_isPeriodicPt] at fixed
  rw [period_eq_minimalPeriod]
  exact Function.IsPeriodicPt.minimalPeriod_pos n_pos fixed","error:  unknown identifier 'fixed_iff_isPeriodicPt'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.5329
Œ± : Type v
G : Type u
inst‚úù¬≥ : Group G
inst‚úù¬≤ : MulAction G Œ±
M : Type u
inst‚úù¬π : Monoid M
inst‚úù : MulAction M Œ±
m : M
a : Œ±
n : ‚Ñï
n_pos : 0 < n
fixed : m ^ n ‚Ä¢ a = a
‚ä¢ 0 < period m a","theorem period_pos_of_fixed {m : M} {a : Œ±} {n : ‚Ñï} (n_pos : 0 < n) (fixed : m ^ n ‚Ä¢ a = a) :
    0 < period m a ",":=
  (isPeriodicPt_smul_iff.mpr fixed).minimalPeriod_pos n_pos",":= by
  rw [fixed_iff_isPeriodicPt] at fixed
  rw [period_eq_minimalPeriod]
  exact Function.IsPeriodicPt.minimalPeriod_pos n_pos fixed"
Mathlib/NumberTheory/EulerProduct/Basic.lean,EulerProduct.eulerProduct_tprod,eulerProduct_tprod,19cfe36a7ab0262701db2043cd019a1861daadc8,:= sorry,"warning:  declaration uses 'sorry'
error:  application type mismatch
  eulerProduct_tprod hf.left
argument
  hf.left
has type
  f 1 = 1 : Prop
but is expected to have type
  Summable fun x ‚Ü¶ ‚Äñ?m.37925 x‚Äñ : Prop","theorem eulerProduct_tprod (hsum : Summable (‚Äñf ¬∑‚Äñ)) (hf‚ÇÄ : f 0 = 0) :
    ‚àè' p : Primes, ‚àë' e, f (p ^ e) = ‚àë' n, f n ",":=
  (eulerProduct_hasProd hf‚ÇÅ hmul hsum hf‚ÇÄ).tprod_eq",":= by
  have : ‚àÄ p : Primes, ‚àë' e, f (p ^ e) = ‚àë' n, f n := fun p => by
    intro p hp
    simp only [norm_eq_abs, abs_tsum_eq_tsum_of_norm_eq_tsum_of_norm_eq_tsum_of_norm_eq_tsum_of_norm_eq_tsum_of_norm_eq_tsum_of_norm_eq_tsum_of_norm_eq_tsum_of_norm_eq_tsum_of_norm_eq_tsum_norm]"
Mathlib/LinearAlgebra/AffineSpace/Combination.lean,Finset.weightedVSubOfPoint_const_smul,weightedVSubOfPoint_const_smul,9db546a81b334ba30d74fed40766bcdeffb50e5f,":= by
  simp_rw [weightedVSubOfPoint_apply, smul_sum', Pi.smul_apply, smul_smul, smul_eq_mul]","error:  unknown identifier 'smul_sum''
error:  simp made no progress","theorem weightedVSubOfPoint_const_smul (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) (b : P) (c : k) :
    s.weightedVSubOfPoint p b (c ‚Ä¢ w) = c ‚Ä¢ s.weightedVSubOfPoint p b w ",":= by
  simp_rw [weightedVSubOfPoint_apply, smul_sum, Pi.smul_apply, smul_smul, smul_eq_mul]",":= by
  simp_rw [weightedVSubOfPoint_apply, smul_sum]"
Mathlib/Data/Nat/Factorization/Basic.lean,Nat.factors_count_eq,factors_count_eq,754ba19de1471fd928c4fa0cc102d1f06f90e902,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization_def _ pp]
  apply _root_.le_antisymm
  ¬∑ rw [le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm
  ¬∑ rw [‚Üê lt_add_one_iff, lt_iff_not_ge, ge_iff_le,
      le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this","error:  unknown identifier 'lt_add_one_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.7217
case inr.a
a b m n‚úù p‚úù n p : ‚Ñï
hn0 : n > 0
pp : Prime p
‚ä¢ padicValNat p n ‚â§ count p n.factors",theorem factors_count_eq {n p : ‚Ñï} : n.factors.count p = n.factorization p ,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization_def _ pp]
  apply _root_.le_antisymm
  ¬∑ rw [le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm
  ¬∑ rw [‚Üê Nat.lt_add_one_iff, lt_iff_not_ge, ge_iff_le,
      le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this",":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm
  ¬∑ rw [‚Üê lt_add_one_iff, lt_iff_not_ge, ge_iff_le,
      le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this"
Mathlib/Algebra/Homology/TotalComplex.lean,HomologicalComplex‚ÇÇ.D‚ÇÅ_D‚ÇÅ,D‚ÇÅ_D‚ÇÅ,10f63baf7e1660a2ffa3e891eef40812f434a38f,":= by
  by_cases h‚ÇÅ : c‚ÇÅ‚ÇÇ.Rel i‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ'
  ¬∑ by_cases h‚ÇÇ : c‚ÇÅ‚ÇÇ.Rel i‚ÇÅ‚ÇÇ' i‚ÇÅ‚ÇÇ''
    ¬∑ ext ‚ü®i‚ÇÅ, i‚ÇÇ‚ü© h
      simp only [Œπ_D‚ÇÅ_assoc, comp_zero]
      by_cases h‚ÇÉ : c‚ÇÅ.Rel i‚ÇÅ (c‚ÇÅ.next i‚ÇÅ)
      ¬∑ rw [K.d‚ÇÅ_eq c‚ÇÅ‚ÇÇ h‚ÇÉ i‚ÇÇ i‚ÇÅ‚ÇÇ']; swap
        ¬∑ rw [‚Üê ComplexShape.next_œÄ‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ h‚ÇÉ i‚ÇÇ, ‚Üê c‚ÇÅ‚ÇÇ.next_eq' h‚ÇÅ, h]
        simp only [Linear.units_smul_comp, assoc, Œπ_D‚ÇÅ]
        by_cases h‚ÇÑ : c‚ÇÅ.Rel (c‚ÇÅ.next i‚ÇÅ) (c‚ÇÅ.next (c‚ÇÅ.next i‚ÇÅ))
        ¬∑ rw [K.d‚ÇÅ_eq c‚ÇÅ‚ÇÇ h‚ÇÑ i‚ÇÇ i‚ÇÅ‚ÇÇ'', Linear.comp_units_smul,
            d_f_comp_d_f_assoc, zero_comp, smul_zero, smul_zero]
          rw [‚Üê ComplexShape.next_œÄ‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ h‚ÇÑ, ‚Üê ComplexShape.next_œÄ‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ h‚ÇÉ,
            h, c‚ÇÅ‚ÇÇ.next_eq' h‚ÇÅ, c‚ÇÅ‚ÇÇ.next_eq' h‚ÇÇ]
        ¬∑ rw [K.d‚ÇÅ_eq_zero _ _ _ _ h‚ÇÑ, comp_zero, smul_zero]
      ¬∑ rw [K.d‚ÇÅ_eq_zero c‚ÇÅ‚ÇÇ _ _ _ h‚ÇÉ, zero_comp]
    ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÅ, zero_comp]","error:  unknown identifier 'Œπ_D‚ÇÅ_assoc'
error:  invalid field 'd‚ÇÅ_eq', the environment does not contain 'HomologicalComplex‚ÇÇ.d‚ÇÅ_eq'
  K
has type
  HomologicalComplex‚ÇÇ C c‚ÇÅ c‚ÇÇ
error:  invalid field 'd‚ÇÅ_eq', the environment does not contain 'HomologicalComplex.d‚ÇÅ_eq'
  K
has type
  HomologicalComplex (HomologicalComplex C c‚ÇÇ) c‚ÇÅ
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.34277
case pos
C : Type u_1
inst‚úù‚Å¥ : Category.{u_5, u_1} C
inst‚úù¬≥ : Preadditive C
I‚ÇÅ : Type u_2
I‚ÇÇ : Type u_3
I‚ÇÅ‚ÇÇ : Type u_4
c‚ÇÅ : ComplexShape I‚ÇÅ
c‚ÇÇ : ComplexShape I‚ÇÇ
K L M : HomologicalComplex‚ÇÇ C c‚ÇÅ c‚ÇÇ
œÜ : K ‚ü∂ L
e : K ‚âÖ L
œà : L ‚ü∂ M
c‚ÇÅ‚ÇÇ : ComplexShape I‚ÇÅ‚ÇÇ
inst‚úù¬≤ : DecidableEq I‚ÇÅ‚ÇÇ
inst‚úù¬π : TotalComplexShape c‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ
inst‚úù : K.HasTotal c‚ÇÅ‚ÇÇ
i‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ' i‚ÇÅ‚ÇÇ'' : I‚ÇÅ‚ÇÇ
h‚ÇÅ : c‚ÇÅ‚ÇÇ.Rel i‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ'
h‚ÇÇ : c‚ÇÅ‚ÇÇ.Rel i‚ÇÅ‚ÇÇ' i‚ÇÅ‚ÇÇ''
i‚ÇÅ : I‚ÇÅ
i‚ÇÇ : I‚ÇÇ
h : c‚ÇÅ.œÄ c‚ÇÇ c‚ÇÅ‚ÇÇ (i‚ÇÅ, i‚ÇÇ) = i‚ÇÅ‚ÇÇ
h‚ÇÉ : c‚ÇÅ.Rel i‚ÇÅ (c‚ÇÅ.next i‚ÇÅ)
‚ä¢ K.toGradedObject.ŒπMapObj (c‚ÇÅ.œÄ c‚ÇÇ c‚ÇÅ‚ÇÇ) (i‚ÇÅ, i‚ÇÇ) i‚ÇÅ‚ÇÇ h ‚â´ K.D‚ÇÅ c‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ' ‚â´ K.D‚ÇÅ c‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ' i‚ÇÅ‚ÇÇ'' = 0
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  K.d‚ÇÅ c‚ÇÅ‚ÇÇ i‚ÇÅ ?m.34332 ?m.34333
case neg
C : Type u_1
inst‚úù‚Å¥ : Category.{u_5, u_1} C
inst‚úù¬≥ : Preadditive C
I‚ÇÅ : Type u_2
I‚ÇÇ : Type u_3
I‚ÇÅ‚ÇÇ : Type u_4
c‚ÇÅ : ComplexShape I‚ÇÅ
c‚ÇÇ : ComplexShape I‚ÇÇ
K L M : HomologicalComplex‚ÇÇ C c‚ÇÅ c‚ÇÇ
œÜ : K ‚ü∂ L
e : K ‚âÖ L
œà : L ‚ü∂ M
c‚ÇÅ‚ÇÇ : ComplexShape I‚ÇÅ‚ÇÇ
inst‚úù¬≤ : DecidableEq I‚ÇÅ‚ÇÇ
inst‚úù¬π : TotalComplexShape c‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ
inst‚úù : K.HasTotal c‚ÇÅ‚ÇÇ
i‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ' i‚ÇÅ‚ÇÇ'' : I‚ÇÅ‚ÇÇ
h‚ÇÅ : c‚ÇÅ‚ÇÇ.Rel i‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ'
h‚ÇÇ : c‚ÇÅ‚ÇÇ.Rel i‚ÇÅ‚ÇÇ' i‚ÇÅ‚ÇÇ''
i‚ÇÅ : I‚ÇÅ
i‚ÇÇ : I‚ÇÇ
h : c‚ÇÅ.œÄ c‚ÇÇ c‚ÇÅ‚ÇÇ (i‚ÇÅ, i‚ÇÇ) = i‚ÇÅ‚ÇÇ
h‚ÇÉ : ¬¨c‚ÇÅ.Rel i‚ÇÅ (c‚ÇÅ.next i‚ÇÅ)
‚ä¢ K.toGradedObject.ŒπMapObj (c‚ÇÅ.œÄ c‚ÇÇ c‚ÇÅ‚ÇÇ) (i‚ÇÅ, i‚ÇÇ) i‚ÇÅ‚ÇÇ h ‚â´ K.D‚ÇÅ c‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ' ‚â´ K.D‚ÇÅ c‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ' i‚ÇÅ‚ÇÇ'' = 0",lemma D‚ÇÅ_D‚ÇÅ (i‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ' i‚ÇÅ‚ÇÇ'' : I‚ÇÅ‚ÇÇ) : K.D‚ÇÅ c‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ' ‚â´ K.D‚ÇÅ c‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ' i‚ÇÅ‚ÇÇ'' = 0 ,":= by
  by_cases h‚ÇÅ : c‚ÇÅ‚ÇÇ.Rel i‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ'
  ¬∑ by_cases h‚ÇÇ : c‚ÇÅ‚ÇÇ.Rel i‚ÇÅ‚ÇÇ' i‚ÇÅ‚ÇÇ''
    ¬∑ ext ‚ü®i‚ÇÅ, i‚ÇÇ‚ü© h
      simp only [totalAux.ŒπMapObj_D‚ÇÅ_assoc, comp_zero]
      by_cases h‚ÇÉ : c‚ÇÅ.Rel i‚ÇÅ (c‚ÇÅ.next i‚ÇÅ)
      ¬∑ rw [totalAux.d‚ÇÅ_eq K c‚ÇÅ‚ÇÇ h‚ÇÉ i‚ÇÇ i‚ÇÅ‚ÇÇ']; swap
        ¬∑ rw [‚Üê ComplexShape.next_œÄ‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ h‚ÇÉ i‚ÇÇ, ‚Üê c‚ÇÅ‚ÇÇ.next_eq' h‚ÇÅ, h]
        simp only [Linear.units_smul_comp, assoc, totalAux.ŒπMapObj_D‚ÇÅ]
        by_cases h‚ÇÑ : c‚ÇÅ.Rel (c‚ÇÅ.next i‚ÇÅ) (c‚ÇÅ.next (c‚ÇÅ.next i‚ÇÅ))
        ¬∑ rw [totalAux.d‚ÇÅ_eq K c‚ÇÅ‚ÇÇ h‚ÇÑ i‚ÇÇ i‚ÇÅ‚ÇÇ'', Linear.comp_units_smul,
            d_f_comp_d_f_assoc, zero_comp, smul_zero, smul_zero]
          rw [‚Üê ComplexShape.next_œÄ‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ h‚ÇÑ, ‚Üê ComplexShape.next_œÄ‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ h‚ÇÉ,
            h, c‚ÇÅ‚ÇÇ.next_eq' h‚ÇÅ, c‚ÇÅ‚ÇÇ.next_eq' h‚ÇÇ]
        ¬∑ rw [K.d‚ÇÅ_eq_zero _ _ _ _ h‚ÇÑ, comp_zero, smul_zero]
      ¬∑ rw [K.d‚ÇÅ_eq_zero c‚ÇÅ‚ÇÇ _ _ _ h‚ÇÉ, zero_comp]
    ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÅ, zero_comp]",":= by
  by_cases h‚ÇÅ : c‚ÇÅ‚ÇÇ.Rel i‚ÇÅ‚ÇÇ i‚ÇÅ‚ÇÇ'
  ¬∑ by_cases h‚ÇÇ : c‚ÇÅ‚ÇÇ.Rel i‚ÇÅ‚ÇÇ' i‚ÇÅ‚ÇÇ''
    ¬∑ ext ‚ü®i‚ÇÅ, i‚ÇÇ‚ü© h
      simp only [Œπ_D‚ÇÅ_assoc, comp_zero]
      by_cases h‚ÇÉ : c‚ÇÅ.Rel i‚ÇÅ (c‚ÇÅ.next i‚ÇÅ)
      ¬∑ rw [K.d‚ÇÅ_eq c‚ÇÅ‚ÇÇ h‚ÇÉ i‚ÇÇ i‚ÇÅ‚ÇÇ']; swap
        ¬∑ rw [‚Üê ComplexShape.next_œÄ‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ h‚ÇÉ i‚ÇÇ, ‚Üê c‚ÇÅ‚ÇÇ.next_eq' h‚ÇÅ, h]
        simp only [Linear.units_smul_comp, assoc, Œπ_D‚ÇÅ]
        by_cases h‚ÇÑ : c‚ÇÅ.Rel (c‚ÇÅ.next i‚ÇÅ) (c‚ÇÅ.next (c‚ÇÅ.next i‚ÇÅ))
        ¬∑ rw [K.d‚ÇÅ_eq c‚ÇÅ‚ÇÇ h‚ÇÑ i‚ÇÇ i‚ÇÅ‚ÇÇ'', Linear.comp_units_smul,
            d_f_comp_d_f_assoc, zero_comp, smul_zero, smul_zero]
          rw [‚Üê ComplexShape.next_œÄ‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ h‚ÇÑ, ‚Üê ComplexShape.next_œÄ‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ h‚ÇÉ,
            h, c‚ÇÅ‚ÇÇ.next_eq' h‚ÇÅ, c‚ÇÅ‚ÇÇ.next_eq' h‚ÇÇ]
        ¬∑ rw [K.d‚ÇÅ_eq_zero _ _ _ _ h‚ÇÉ, zero_comp]
    ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h‚ÇÇ, comp_zero]
  ¬∑ rw [K.D‚ÇÅ_shape c‚ÇÅ‚ÇÇ _ _ h"
Mathlib/Geometry/RingedSpace/Basic.lean,AlgebraicGeometry.RingedSpace.isUnit_of_isUnit_germ,isUnit_of_isUnit_germ,5c6b5a4c50c73942f6fcbc02eebf983c6e667b79,":= by
  choose V iVU m h_unit using fun x : U => X.isUnit_res_of_isUnit_germ U f x (h x)
  have hcover : U ‚â§ iSup V
  ¬∑ intro x hxU
    erw [Opens.mem_iSup]
    exact ‚ü®‚ü®x, hxU‚ü©, m ‚ü®x, hxU‚ü©‚ü©
  choose g hg using fun x : U => IsUnit.exists_right_inv (h_unit x)
  have ic : IsCompatible (sheaf X).val V g
  ¬∑ intro x y
    apply section_ext X.sheaf (V x ‚äì V y)
    rintro ‚ü®z, hzVx, hzVy‚ü©
    erw [germ_res_apply, germ_res_apply]
    apply (IsUnit.mul_right_inj (h ‚ü®z, (iVU x).le hzVx‚ü©)).mp
    rw [‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
      X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
      X.presheaf.germ_res_apply (iVU x) ‚ü®z, hzVx‚ü© f]
    change X.presheaf.germ ‚ü®z, hzVx‚ü© _ * (X.presheaf.germ ‚ü®z, hzVx‚ü© _) =
      X.presheaf.germ ‚ü®z, hzVx‚ü© _ * X.presheaf.germ ‚ü®z, hzVy‚ü© (g y)
    rw [‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVx‚ü© : V x)) (hg x),
      show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVy‚ü© (X.presheaf.map (iVU y).op f) =
          X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
          X.presheaf.germ_res_apply (iVU y) ‚ü®z, hzVy‚ü© f,
      ‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVy‚ü© : V y)) (hg y), RingHom.map_one, RingHom.map_one]
  obtain ‚ü®gl, gl_spec, -‚ü© := X.sheaf.existsUnique_gluing' V U iVU hcover g ic
  apply isUnit_of_mul_eq_one f gl
  apply X.sheaf.eq_of_locally_eq' V U iVU hcover
  intro i
  rw [RingHom.map_one, RingHom.map_mul, gl_spec]
  exact hg i","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
X : RingedSpace
U : Opens ‚Üë‚ÜëX.toPresheafedSpace
f : ‚Üë(X.presheaf.obj { unop := U })
h : ‚àÄ (x : ‚Ü•U), IsUnit ((X.presheaf.germ x) f)
V : ‚Ü•U ‚Üí Opens ‚Üë‚ÜëX.toPresheafedSpace
iVU : (x : ‚Ü•U) ‚Üí V x ‚ü∂ U
m : ‚àÄ (x : ‚Ü•U), ‚Üëx ‚àà V x
h_unit : ‚àÄ (x : ‚Ü•U), IsUnit ((X.presheaf.map (iVU x).op) f)
hcover : U ‚â§ iSup V
‚ä¢ IsUnit f","theorem isUnit_of_isUnit_germ (U : Opens X) (f : X.presheaf.obj (op U))
    (h : ‚àÄ x : U, IsUnit (X.presheaf.germ x f)) : IsUnit f ",":= by
  choose V iVU m h_unit using fun x : U => X.isUnit_res_of_isUnit_germ U f x (h x)
  have hcover : U ‚â§ iSup V := by
    intro x hxU
    erw [Opens.mem_iSup]
    exact ‚ü®‚ü®x, hxU‚ü©, m ‚ü®x, hxU‚ü©‚ü©
  choose g hg using fun x : U => IsUnit.exists_right_inv (h_unit x)
  have ic : IsCompatible (sheaf X).val V g := by
    intro x y
    apply section_ext X.sheaf (V x ‚äì V y)
    rintro ‚ü®z, hzVx, hzVy‚ü©
    erw [germ_res_apply, germ_res_apply]
    apply (IsUnit.mul_right_inj (h ‚ü®z, (iVU x).le hzVx‚ü©)).mp
    rw [‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
      X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
      X.presheaf.germ_res_apply (iVU x) ‚ü®z, hzVx‚ü© f]
    change X.presheaf.germ ‚ü®z, hzVx‚ü© _ * (X.presheaf.germ ‚ü®z, hzVx‚ü© _) =
      X.presheaf.germ ‚ü®z, hzVx‚ü© _ * X.presheaf.germ ‚ü®z, hzVy‚ü© (g y)
    rw [‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVx‚ü© : V x)) (hg x),
      show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVy‚ü© (X.presheaf.map (iVU y).op f) =
          X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
          X.presheaf.germ_res_apply (iVU y) ‚ü®z, hzVy‚ü© f,
      ‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVy‚ü© : V y)) (hg y), RingHom.map_one, RingHom.map_one]
  obtain ‚ü®gl, gl_spec, -‚ü© := X.sheaf.existsUnique_gluing' V U iVU hcover g ic
  apply isUnit_of_mul_eq_one f gl
  apply X.sheaf.eq_of_locally_eq' V U iVU hcover
  intro i
  rw [RingHom.map_one, RingHom.map_mul, gl_spec]
  exact hg i",":= by
  choose V iVU m h_unit using fun x : U => X.isUnit_res_of_isUnit_germ U f x (h x)
  have hcover : U ‚â§ iSup V
  ¬∑ intro x hxU
    erw [Opens.mem_iSup]
    exact ‚ü®‚ü®x, hxU‚ü©, m ‚ü®x, hxU‚ü©‚ü©
  choose g hg using fun x : U => IsUnit.exists_right_inv (h_unit x)
  have ic : IsCompatible (sheaf X).val V g
  ¬∑ intro x y
    apply section_ext X.sheaf (V x ‚äì V y)
    rintro ‚ü®z, hzVx, hzVy‚ü©
    erw [germ_res_apply, germ_res_apply]
    apply (IsUnit.mul_right_inj (h ‚ü®z, (iVU x).le hzVx‚ü©)).mp
    rw [‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
      X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
      X.presheaf.germ_res_apply (iVU x) ‚ü®z, hzVx‚ü© f]
    change X.presheaf.germ ‚ü®z, hzVx‚ü© _ * (X.presheaf.germ ‚ü®z, hzVx‚ü© _) =
      X.presheaf.germ ‚ü®z, hzVx‚ü© _ * X.presheaf.germ ‚ü®z, hzVx‚ü© (g y)
    rw [‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVx‚ü© : V x)) (hg x),
      show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
        X.presheaf.germ_res_apply (iVU x) ‚ü®z, hzVx‚ü© f]
    change X.presheaf.germ ‚ü®z, hzVx‚ü© _ * (X.presheaf.germ ‚ü®z, hzVx‚ü© _) =
      X.presheaf.germ ‚ü®z, hzVx‚ü© _ * X.presheaf.germ ‚ü®z, hzVx‚ü© (g y)
    rw [‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVx‚ü© : V x)) (hg x),
      show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU y).op f) =
          X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU y).op f) =
          X.preshea"
Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean,integrable_one_add_norm,integrable_one_add_norm,54daa04dd4fe92d1b3b2a82be4c246b43c601cab,":= by
  constructor
  ¬∑ apply Measurable.aestronglyMeasurable (by fun_prop)
  have : (‚à´‚Åª a : E, ‚Äñ(1 + ‚Äña‚Äñ) ^ (-r)‚Äñ‚Çä ‚àÇŒº) = ‚à´‚Åª a : E, ENNReal.ofReal ((1 + ‚Äña‚Äñ) ^ (-r)) ‚àÇŒº :=
    lintegral_nnnorm_eq_of_nonneg fun _ => rpow_nonneg (by positivity) _
  rw [HasFiniteIntegral, this]
  exact finite_integral_one_add_norm hnr","error:  `fun_prop` was unable to prove `Measurable fun x ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ (-r)`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `HPow.hPow` in order to prove Measurable fun x ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ (-r)
  No theorems found for `HPow.hPow` in order to prove Measurable fun a ‚Ü¶ a ^ (-r)
  Failed to synthesize instance NontriviallyNormedField ?ùïú when applying theorem DifferentiableOn.continuousOn.
  No theorems found for `HPow.hPow` in order to prove IsProperMap fun a ‚Ü¶ a ^ (-r)
  Failed to synthesize instance NontriviallyNormedField ?ùïú when applying theorem Differentiable.continuous.
  Failed to synthesize instance DiscreteTopology ‚Ñù when applying theorem continuous_of_discreteTopology.
  Failed to prove necessary assumption 0 ‚â§ -r when applying theorem Real.continuous_rpow_const.
  No theorems found for `HPow.hPow` in order to prove IsProperMap fun a ‚Ü¶ a ^ (-r)
  Failed to synthesize instance NontriviallyNormedField ?ùïú when applying theorem Differentiable.continuous.
  Failed to synthesize instance DiscreteTopology ‚Ñù when applying theorem continuous_of_discreteTopology.
  Failed to prove necessary assumption 0 ‚â§ -r when applying theorem Real.continuous_rpow_const.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`","theorem integrable_one_add_norm {r : ‚Ñù} (hnr : (finrank ‚Ñù E : ‚Ñù) < r) :
    Integrable (fun x ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ (-r)) Œº ",":= by
  constructor
  ¬∑ measurability
  have : (‚à´‚Åª a : E, ‚Äñ(1 + ‚Äña‚Äñ) ^ (-r)‚Äñ‚Çä ‚àÇŒº) = ‚à´‚Åª a : E, ENNReal.ofReal ((1 + ‚Äña‚Äñ) ^ (-r)) ‚àÇŒº :=
    lintegral_nnnorm_eq_of_nonneg fun _ => rpow_nonneg (by positivity) _
  rw [HasFiniteIntegral, this]
  exact finite_integral_one_add_norm hnr",":= by
  constructor
  ¬∑ apply Measurable.aestronglyMeasurable (by fun_prop)
  have : (‚à´‚Åª a : E, ‚Äñ(1 + ‚Äña‚Äñ) ^ (-r)‚Äñ‚Çä ‚àÇŒº) = ‚à´‚Åª a : E, ENNReal.ofReal ((1 + ‚Äña‚Äñ) ^ (-r)) ‚àÇŒº :=
    lintegral_nnnorm_eq_of_nonneg fun _ => rpow_nonneg (by positivity) _
  rw [HasFiniteIntegral, this]
  exact finite_integral_one_add_norm hnr"
Mathlib/RingTheory/ChainOfDivisors.lean,DivisorChain.element_of_chain_eq_pow_second_of_chain,element_of_chain_eq_pow_second_of_chain,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine'
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ‚ü®‚ü®i, ?_‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine' Set.injOn_of_injective (fun m m' h => Fin.ext _) _
      refine'
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) _ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine' dvd_trans _ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2","error:  type mismatch
  Set.injOn_of_injective (fun m m' h ‚Ü¶ Fin.ext (?m.30170 m m' h)) ?m.30176
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Fin ?m.30169‚¶Ñ, x‚ÇÇ ‚àà ?m.30174 ‚Üí ?m.30152 ?m.30175 = ?m.30152 x‚ÇÇ ‚Üí ?m.30175 = x‚ÇÇ : Prop
but is expected to have type
  Set.InjOn (fun m ‚Ü¶ c 1 ^ ‚Üëm) ‚ÜëFinset.univ : Prop","theorem element_of_chain_eq_pow_second_of_chain {q r : Associates M} {n : ‚Ñï} (hn : n ‚â† 0)
    {c : Fin (n + 1) ‚Üí Associates M} (h‚ÇÅ : StrictMono c) (h‚ÇÇ : ‚àÄ {r}, r ‚â§ q ‚Üî ‚àÉ i, r = c i)
    (hr : r ‚à£ q) (hq : q ‚â† 0) : ‚àÉ i : Fin (n + 1), r = c 1 ^ (i : ‚Ñï) ",":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ‚ü®‚ü®i, ?_‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_)
      refine
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) ?_ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine dvd_trans ?_ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2",":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ‚ü®‚ü®i, ?_‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_) ?_
      refine
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) ?_ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine dvd_trans ?_ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2"
Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean,WeierstrassCurve.Projective.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,61f440df94983ae756aa6a0cd1afe07a37060d59,":= by
  rw [‚Üê fin3_def P, hPz] at hP ‚ä¢
  rw [‚Üê fin3_def Q, hQz] at hQ ‚ä¢
  simp only [nonsingular_iff, equation_iff, fin3_def_ext, zero_pow two_ne_zero,
    zero_pow three_ne_zero, mul_zero, add_zero, sub_zero, @eq_comm F 0,
    pow_eq_zero_iff three_ne_zero] at hP hQ
  simp only [hP, hQ, true_and, zero_pow two_ne_zero, mul_zero, ne_self_iff_false, false_or,
    zero_mul, add_zero, pow_ne_zero_iff two_ne_zero] at hP hQ ‚ä¢
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ![P 0, P 1, P 2]
R : Type u
inst‚úù¬π : CommRing R
W‚úù : Projective R
F : Type u
inst‚úù : Field F
W : Projective F
P Q : Fin 3 ‚Üí F
hP : W.Nonsingular P
hQ : W.Nonsingular Q
hPz : P 2 = 0
hQz : Q 2 = 0
‚ä¢ P ‚âà Q","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©",":= by
  rw [‚Üê fin3_def P, hPz] at hP ‚ä¢
  rw [‚Üê fin3_def Q, hQz] at hQ ‚ä¢
  simp only [nonsingular_iff, equation_iff, fin3_def_ext, zero_pow two_ne_zero,
    zero_pow three_ne_zero, mul_zero, add_zero, sub_zero, @eq_comm F 0,
    pow_eq_zero_iff three_ne_zero] at hP hQ
  simp only [hP, hQ, true_and, zero_pow two_ne_zero, mul_zero, ne_self_iff_false, false_or,
    zero_mul, add_zero, pow_ne_zero_iff two_ne_zero] at hP hQ ‚ä¢
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©"
Mathlib/Algebra/Polynomial/Roots.lean,Polynomial.Monic.irreducible_iff_degree_lt,Monic.irreducible_iff_degree_lt,89d8f573bd7b4e12f519ba5206164e7ec40edb94,":= by
  simp only [p_monic.irreducible_iff_lt_natDegree_lt p_1, Finset.mem_Ioc, and_imp,
    natDegree_pos_iff_degree_pos, natDegree_le_iff_degree_le]
  constructor
  ¬∑ rintro h q deg_le dvd
    by_contra q_unit
    have := degree_pos_of_not_isUnit_of_dvd_monic q_unit dvd p_monic
    have hu := p_monic.isUnit_leadingCoeff_of_dvd dvd
    refine (h _ (monic_of_isUnit_leadingCoeff_inv_smul hu) ?_ ?_ (dvd_trans ?_ dvd)).elim
    ¬∑ rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    ¬∑ rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    ¬∑ rw [Units.smul_def, Polynomial.smul_eq_C_mul, (isUnit_C.mpr (Units.isUnit _)).mul_left_dvd]
      rfl
  ¬∑ rintro h q _ deg_pos deg_le dvd
    exact deg_pos.ne' <| degree_eq_zero_of_isUnit (h q deg_le dvd)","error:  application type mismatch
  degree_pos_of_not_isUnit_of_dvd_monic q_unit
argument
  q_unit
has type
  ¬¨IsUnit q : Prop
but is expected to have type
  ?m.254336.Monic : Prop","theorem Monic.irreducible_iff_degree_lt {p : R[X]} (p_monic : Monic p) (p_1 : p ‚â† 1) :
    Irreducible p ‚Üî ‚àÄ q, degree q ‚â§ ‚Üë(p.natDegree / 2) ‚Üí q ‚à£ p ‚Üí IsUnit q ",":= by
  simp only [p_monic.irreducible_iff_lt_natDegree_lt p_1, Finset.mem_Ioc, and_imp,
    natDegree_pos_iff_degree_pos, natDegree_le_iff_degree_le]
  constructor
  ¬∑ rintro h q deg_le dvd
    by_contra q_unit
    have := degree_pos_of_not_isUnit_of_dvd_monic p_monic q_unit dvd
    have hu := p_monic.isUnit_leadingCoeff_of_dvd dvd
    refine (h _ (monic_of_isUnit_leadingCoeff_inv_smul hu) ?_ ?_ (dvd_trans ?_ dvd)).elim
    ¬∑ rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    ¬∑ rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    ¬∑ rw [Units.smul_def, Polynomial.smul_eq_C_mul, (isUnit_C.mpr (Units.isUnit _)).mul_left_dvd]
  ¬∑ rintro h q _ deg_pos deg_le dvd
    exact deg_pos.ne' <| degree_eq_zero_of_isUnit (h q deg_le dvd)",":= by
  simp only [p_monic.irreducible_iff_lt_natDegree_lt p_1, Finset.mem_Ioc, and_imp,
    natDegree_pos_iff_degree_pos, natDegree_le_iff_degree_le]
  constructor
  ¬∑ rintro h q deg_le dvd
    by_contra q_unit
    have := degree_pos_of_not_isUnit_of_dvd_monic q_unit dvd p_monic
    have hu := p_monic.isUnit_leadingCoeff_of_dvd dvd
    refine (h _ (monic_of_isUnit_leadingCoeff_inv_smul hu) ?_ ?_ (dvd_trans ?_ dvd)).elim
    ¬∑ rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    ¬∑ rw [Units.smul_def, Polynomial.smul_eq_C_mul, (isUnit_C.mpr (Units.isUnit _)).mul_left_dvd]
      rfl
  ¬∑ rintro h q _ deg_pos deg_le dvd
    exact deg_pos.ne' <| degree_eq_zero_of_isUnit (h q deg_le dvd)"
Mathlib/RingTheory/RootsOfUnity/Minpoly.lean,IsPrimitiveRoot.minpoly_dvd_expand,minpoly_dvd_expand,db4b2acc70490f6bcea6872fdf1d716949f8c1e7,":= by
  rcases n.eq_zero_or_pos with (rfl | hpos)
  ¬∑ simp_all
  letI : IsIntegrallyClosed ‚Ñ§ ‚Ñö := GCDMonoid.toIsIntegrallyClosed
  refine' minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos) _
  ¬∑ rw [aeval_def, coe_expand, ‚Üê comp, eval‚ÇÇ_eq_eval_map, map_comp, Polynomial.map_pow, map_X,
      eval_comp, eval_pow, eval_X, ‚Üê eval‚ÇÇ_eq_eval_map, ‚Üê aeval_def]
    exact minpoly.aeval _ _","error:  function expected at
  IsIntegrallyClosed ‚Ñ§
term has type
  Prop","theorem minpoly_dvd_expand {p : ‚Ñï} (hdiv : ¬¨p ‚à£ n) :
    minpoly ‚Ñ§ Œº ‚à£ expand ‚Ñ§ p (minpoly ‚Ñ§ (Œº ^ p)) ",":= by
  rcases n.eq_zero_or_pos with (rfl | hpos)
  ¬∑ simp_all
  letI : IsIntegrallyClosed ‚Ñ§ := GCDMonoid.toIsIntegrallyClosed
  refine minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos) ?_
  rw [aeval_def, coe_expand, ‚Üê comp, eval‚ÇÇ_eq_eval_map, map_comp, Polynomial.map_pow, map_X,
    eval_comp, eval_pow, eval_X, ‚Üê eval‚ÇÇ_eq_eval_map, ‚Üê aeval_def]
  exact minpoly.aeval _ _",":= by
  rcases n.eq_zero_or_pos with (rfl | hpos)
  ¬∑ simp_all
  let : IsIntegrallyClosed ‚Ñ§ ‚Ñö := GCDMonoid.toIsIntegrallyClosed
  refine minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos) ?_
  ¬∑ rw [aeval_def, coe_expand, ‚Üê comp, eval‚ÇÇ_eq_eval_map, map_comp, Polynomial.map_pow, map_X,
      eval_comp, eval_pow, eval_X, ‚Üê eval‚ÇÇ_eq_eval_map, ‚Üê aeval_def]
    exact minpoly.aeval _ _"
Mathlib/Topology/Separation.lean,loc_compact_Haus_tot_disc_of_zero_dim,loc_compact_Haus_tot_disc_of_zero_dim,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.1) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := ((‚Üë) : s ‚Üí H) ‚Åª¬π' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, VisClopen, Vx, V_sub‚ü© := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine' ‚ü®_, comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.2‚ü©
    let v : Set u := ((‚Üë) : u ‚Üí s) ‚Åª¬π' V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine' ‚ü®f0, _‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_left interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.1.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  refine' ‚ü®(‚Üë) '' V, VisClopen', by simp [Vx], Subset.trans _ sU‚ü©
  simp","error:  type mismatch
  hu.left
has type
  IsClosed u : Prop
but is expected to have type
  IsOpen u : Prop
error:  application type mismatch
  (ClosedEmbedding.closed_iff_image_closed (IsClosed.closedEmbedding_subtype_val (IsCompact.isClosed comp))).mp
    VisClopen.right
argument
  VisClopen.right
has type
  IsOpen V : Prop
but is expected to have type
  IsClosed ?m.221264 : Prop
error:  tactic 'apply' failed, failed to unify
  interior ?m.223599 ‚à© ?m.223599 = interior ?m.223599
with
  s ‚à© interior s = interior s
X : Type u_1
Y : Type u_2
inst‚úù‚Å¥ : TopologicalSpace X
H : Type u_3
inst‚úù¬≥ : TopologicalSpace H
inst‚úù¬≤ : LocallyCompactSpace H
inst‚úù¬π : T2Space H
inst‚úù : TotallyDisconnectedSpace H
U : Set H
hU : IsOpen U
s : Set H
comp : IsCompact s
sU : s ‚äÜ U
u : Set ‚Üës := Subtype.val ‚Åª¬π' interior s
u_open_in_s : IsOpen u
x : { x // x ‚àà s }
memU : ‚Üëx ‚àà U
xs : ‚Üëx ‚àà interior s
this‚úù : CompactSpace ‚Üës
V : Set ‚Üës
VisClopen : IsClopen V
Vx : x ‚àà V
V_sub : V ‚äÜ u
v : Set ‚Üëu := Subtype.val ‚Åª¬π' V
this : (fun x ‚Ü¶ ‚Üë‚Üëx) = Subtype.val ‚àò Subtype.val
f0 : _root_.Embedding fun x ‚Ü¶ ‚Üë‚Üëx
‚ä¢ s ‚à© interior s = interior s
error:  type mismatch
  IsClosed.preimage continuous_subtype_val VisClopen.left
has type
  IsClosed (Subtype.val ‚Åª¬π' V) : Prop
but is expected to have type
  IsOpen v : Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  V ‚à© u
X : Type u_1
Y : Type u_2
inst‚úù‚Å¥ : TopologicalSpace X
H : Type u_3
inst‚úù¬≥ : TopologicalSpace H
inst‚úù¬≤ : LocallyCompactSpace H
inst‚úù¬π : T2Space H
inst‚úù : TotallyDisconnectedSpace H
U : Set H
hU : IsOpen U
s : Set H
comp : IsCompact s
sU : s ‚äÜ U
u : Set ‚Üës := Subtype.val ‚Åª¬π' interior s
u_open_in_s : IsOpen u
x : { x // x ‚àà s }
memU : ‚Üëx ‚àà U
xs : ‚Üëx ‚àà interior s
this‚úù : CompactSpace ‚Üës
V : Set ‚Üës
VisClopen : IsClopen V
Vx : x ‚àà V
V_sub : V ‚äÜ u
v : Set ‚Üëu := Subtype.val ‚Åª¬π' V
this : (fun x ‚Ü¶ ‚Üë‚Üëx) = Subtype.val ‚àò Subtype.val
f0 : _root_.Embedding fun x ‚Ü¶ ‚Üë‚Üëx
f1 : OpenEmbedding fun x ‚Ü¶ ‚Üë‚Üëx
f2 : IsOpen v
‚ä¢ Subtype.val '' V = Subtype.val '' (u ‚à© V)
error:  tactic 'apply' failed, failed to unify
  IsOpen ((fun x ‚Ü¶ ‚Üë‚Üëx) '' v)
with
  IsClosed ((fun x ‚Ü¶ ‚Üë‚Üëx) '' v)
X : Type u_1
Y : Type u_2
inst‚úù‚Å¥ : TopologicalSpace X
H : Type u_3
inst‚úù¬≥ : TopologicalSpace H
inst‚úù¬≤ : LocallyCompactSpace H
inst‚úù¬π : T2Space H
inst‚úù : TotallyDisconnectedSpace H
U : Set H
hU : IsOpen U
s : Set H
comp : IsCompact s
sU : s ‚äÜ U
u : Set ‚Üës := Subtype.val ‚Åª¬π' interior s
u_open_in_s : IsOpen u
x : { x // x ‚àà s }
memU : ‚Üëx ‚àà U
xs : ‚Üëx ‚àà interior s
this‚úù : CompactSpace ‚Üës
V : Set ‚Üës
VisClopen : IsClopen V
Vx : x ‚àà V
V_sub : V ‚äÜ u
v : Set ‚Üëu := Subtype.val ‚Åª¬π' V
this : (fun x ‚Ü¶ ‚Üë‚Üëx) = Subtype.val ‚àò Subtype.val
f0 : _root_.Embedding fun x ‚Ü¶ ‚Üë‚Üëx
f1 : OpenEmbedding fun x ‚Ü¶ ‚Üë‚Üëx
f2 : IsOpen v
f3 : Subtype.val '' V = (fun x ‚Ü¶ ‚Üë‚Üëx) '' v
‚ä¢ IsClosed ((fun x ‚Ü¶ ‚Üë‚Üëx) '' v)","theorem loc_compact_Haus_tot_disc_of_zero_dim [TotallyDisconnectedSpace H] :
    IsTopologicalBasis { s : Set H | IsClopen s } ",":= by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.2) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := ((‚Üë) : s ‚Üí H) ‚Åª¬π' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, VisClopen, Vx, V_sub‚ü© := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine ‚ü®comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.1, ?_‚ü©
    let v : Set u := ((‚Üë) : u ‚Üí s) ‚Åª¬π' V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine ‚ü®f0, ?_‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_right interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.2.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_right V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  use (‚Üë) '' V, VisClopen', by simp [Vx], Subset.trans (by simp) sU",":= by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.1) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := ((‚Üë) : s ‚Üí H) ‚Åª¬π' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, VisClopen, Vx, V_sub‚ü© := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine ‚ü®_, comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.2‚ü©
    let v : Set u := ((‚Üë) : u ‚Üí s) ‚Åª¬π' V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine ‚ü®f0, ?_‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_left interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.1.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  refine ‚ü®(‚Üë) '' V, VisClopen', by simp [Vx], Subset.trans ?_ sU‚ü©
  simp"
Mathlib/Order/CompactlyGenerated/Basic.lean,CompleteLattice.independent_iff_supIndep_of_injOn,CompleteLattice.independent_iff_supIndep_of_injOn,ccc27e7ac9e260c68eb4566eddafc1ab1d22d6e1,":= by
  refine ‚ü®fun h ‚Ü¶ h.supIndep', fun h ‚Ü¶ CompleteLattice.independent_def'.mpr fun i ‚Ü¶ ?_‚ü©
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, ‚Üê disjoint_iff]
  intro s hs
  classical
  rw [‚Üê Finset.sup_erase_bot]
  set t := s.erase ‚ä•
  replace hf : InjOn f (f ‚Åª¬π' t) := fun i hi j _ hij ‚Ü¶ by
    refine hf ?_ ?_ hij <;> aesop (add norm simp [t])
  have : (Finset.erase (insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image, t]
    refine ‚ü®by aesop, fun ‚ü®ha, has‚ü© ‚Ü¶ ?_‚ü©
    obtain ‚ü®j, hj, rfl‚ü© := hs has
    exact ‚ü®j, ‚ü®hj, ha, has‚ü©, rfl‚ü©
  change Disjoint (f i) (Finset.sup __t id)
  rw [‚Üê this, Finset.sup_image]
  specialize h (insert i (__t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)","error:  unknown identifier '__t'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  t
Œπ‚úù : Sort u_1
Œ± : Type u_2
inst‚úù¬≤ : CompleteLattice Œ±
f‚úù : Œπ‚úù ‚Üí Œ±
inst‚úù¬π : CompleteLattice Œ±
inst‚úù : IsCompactlyGenerated Œ±
a b : Œ±
s‚úù : Set Œ±
Œπ : Type u_3
f : Œπ ‚Üí Œ±
h : ‚àÄ (s : Finset Œπ), s.SupIndep f
i : Œπ
s : Finset Œ±
hs : ‚Üës ‚äÜ f '' {j | j ‚â† i}
t : Finset Œ± := s.erase ‚ä•
hf : InjOn f (f ‚Åª¬π' ‚Üët)
this : Finset.image f ((insert i (t.preimage f hf)).erase i) = t
‚ä¢ Disjoint (f i) ((sorryAx (Finset Œ±) true).sup id)","lemma CompleteLattice.independent_iff_supIndep_of_injOn {Œπ : Type*} {f : Œπ ‚Üí Œ±}
    (hf : InjOn f {i | f i ‚â† ‚ä•}) :
    CompleteLattice.Independent f ‚Üî ‚àÄ (s : Finset Œπ), s.SupIndep f ",":= by
  refine ‚ü®fun h ‚Ü¶ h.supIndep', fun h ‚Ü¶ CompleteLattice.independent_def'.mpr fun i ‚Ü¶ ?_‚ü©
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, ‚Üê disjoint_iff]
  intro s hs
  classical
  rw [‚Üê Finset.sup_erase_bot]
  set t := s.erase ‚ä•
  replace hf : InjOn f (f ‚Åª¬π' t) := fun i hi j _ hij ‚Ü¶ by
    refine hf ?_ ?_ hij <;> aesop (add norm simp [t])
  have : (Finset.erase (insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image, t]
    refine ‚ü®by aesop, fun ‚ü®ha, has‚ü© ‚Ü¶ ?_‚ü©
    obtain ‚ü®j, hj, rfl‚ü© := hs has
    exact ‚ü®j, ‚ü®hj, ha, has‚ü©, rfl‚ü©
  rw [‚Üê this, Finset.sup_image]
  specialize h (insert i (t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)",":= by
  refine ‚ü®fun h ‚Ü¶ h.supIndep', fun h ‚Ü¶ CompleteLattice.independent_def'.mpr fun i ‚Ü¶ ?_‚ü©
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, ‚Üê disjoint_iff]
  intro s hs
  classical
  rw [‚Üê Finset.sup_erase_bot]
  set t := s.erase ‚ä•
  replace hf : InjOn f (f ‚Åª¬π' t) := fun i hi j _ hij ‚Ü¶ by
    refine hf ?_ ?_ hij <;> aesop (add norm simp [t])
  have : (Finset.erase insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image, t]
    refine ‚ü®by aesop, fun ‚ü®ha, has‚ü© ‚Ü¶ ?_‚ü©
    obtain ‚ü®j, hj, rfl‚ü© := hs has
    exact ‚ü®j, ‚ü®hj, ha, has‚ü©, rfl‚ü©
  change Disjoint (f i) (Finset.sup __t id)
  rw [‚Üê this, Finset.sup_image]
  specialize h (insert i (__t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)"
Mathlib/CategoryTheory/Preadditive/HomOrthogonal.lean,CategoryTheory.HomOrthogonal.equiv_of_iso,equiv_of_iso,9b5d788d575748c82ffdfc08ef4aaf0a3c6023f0,":= by
  refine ‚ü®Equiv.ofPreimageEquiv ?_, fun a => Equiv.ofPreimageEquiv_map ?_ _‚ü©
  intro c
  apply Nonempty.some
  apply Cardinal.eq.1
  cases nonempty_fintype Œ±; cases nonempty_fintype Œ≤
  simp only [Cardinal.mk_fintype, Nat.cast_inj]
  exact
    Matrix.square_of_invertible (o.matrixDecomposition i.inv c) (o.matrixDecomposition i.hom c)
      (by
        rw [‚Üê o.matrixDecomposition_comp]
        simp)
      (by
        rw [‚Üê o.matrixDecomposition_comp]
        simp)","error:  type mismatch
  Equiv.ofPreimageEquiv_map ?m.61391 ?m.61392
has type
  g ((Equiv.ofPreimageEquiv ?m.61391) ?m.61392) = ?m.61389 ?m.61392 : Prop
but is expected to have type
  g ((Equiv.ofPreimageEquiv ?m.61379) a) = f a : Prop","theorem equiv_of_iso (o : HomOrthogonal s) {Œ± Œ≤ : Type} [Finite Œ±] [Finite Œ≤] {f : Œ± ‚Üí Œπ}
    {g : Œ≤ ‚Üí Œπ} (i : (‚®Å fun a => s (f a)) ‚âÖ ‚®Å fun b => s (g b)) :
    ‚àÉ e : Œ± ‚âÉ Œ≤, ‚àÄ a, g (e a) = f a ",":= by
  refine ‚ü®Equiv.ofPreimageEquiv ?_, fun a => Equiv.ofPreimageEquiv_map _ _‚ü©
  intro c
  apply Nonempty.some
  apply Cardinal.eq.1
  cases nonempty_fintype Œ±; cases nonempty_fintype Œ≤
  simp only [Cardinal.mk_fintype, Nat.cast_inj]
  exact
    Matrix.square_of_invertible (o.matrixDecomposition i.inv c) (o.matrixDecomposition i.hom c)
      (by
        rw [‚Üê o.matrixDecomposition_comp]
        simp)
      (by
        rw [‚Üê o.matrixDecomposition_comp]
        simp)",":= by
  refine ‚ü®Equiv.ofPreimageEquiv ?_, fun a => Equiv.ofPreimageEquiv_map ?_ ?_‚ü©
  intro c
  apply Nonempty.some
  apply Cardinal.eq.1
  cases nonempty_fintype Œ±; cases nonempty_fintype Œ≤
  simp only [Cardinal.mk_fintype, Nat.cast_inj]
  exact
    Matrix.square_of_invertible (o.matrixDecomposition i.inv c) (o.matrixDecomposition i.hom c)
      (by
        rw [‚Üê o.matrixDecomposition_comp]
        simp)"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,6861d9247d1a06a093e444c3a0319e5ec45263c2,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      apply reflection_mem_subspace_eq_self
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      apply reflection_mem_subspace_eq_self
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
    rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'"
Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean,ProbabilityMeasure.toFiniteMeasure_normalize_eq_self,_root_.ProbabilityMeasure.toFiniteMeasure_normalize_eq_self,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  apply ProbabilityMeasure.eq_of_forall_apply_eq
  intro s _s_mble
  rw [Œº.toFiniteMeasure.normalize_eq_of_nonzero Œº.toFiniteMeasure_nonzero s]
  simp only [ProbabilityMeasure.mass_toFiniteMeasure, inv_one, one_mul]
  congr","error:  unsolved goals
case h.h.e_1
Œ© : Type u_1
inst‚úù : Nonempty Œ©
m0‚úù : MeasurableSpace Œ©
Œº‚úù : FiniteMeasure Œ©
m0 : MeasurableSpace Œ©
Œº : ProbabilityMeasure Œ©
s : Set Œ©
_s_mble : MeasurableSet s
‚ä¢ FiniteMeasure Œ© = ProbabilityMeasure Œ©

case h.h.e_4
Œ© : Type u_1
inst‚úù : Nonempty Œ©
m0‚úù : MeasurableSpace Œ©
Œº‚úù : FiniteMeasure Œ©
m0 : MeasurableSpace Œ©
Œº : ProbabilityMeasure Œ©
s : Set Œ©
_s_mble : MeasurableSet s
‚ä¢ HEq instFunLike ProbabilityMeasure.instFunLike

case h.h.e_5
Œ© : Type u_1
inst‚úù : Nonempty Œ©
m0‚úù : MeasurableSpace Œ©
Œº‚úù : FiniteMeasure Œ©
m0 : MeasurableSpace Œ©
Œº : ProbabilityMeasure Œ©
s : Set Œ©
_s_mble : MeasurableSet s
‚ä¢ HEq Œº.toFiniteMeasure Œº","theorem _root_.ProbabilityMeasure.toFiniteMeasure_normalize_eq_self {m0 : MeasurableSpace Œ©}
    (Œº : ProbabilityMeasure Œ©) : Œº.toFiniteMeasure.normalize = Œº ",":= by
  apply ProbabilityMeasure.eq_of_forall_apply_eq
  intro s _s_mble
  rw [Œº.toFiniteMeasure.normalize_eq_of_nonzero Œº.toFiniteMeasure_nonzero s]
  simp only [ProbabilityMeasure.mass_toFiniteMeasure, inv_one, one_mul, Œº.coeFn_toFiniteMeasure]",":= by
  intro s _s_mble
  rw [Œº.toFiniteMeasure.normalize_eq_of_nonzero Œº.toFiniteMeasure_nonzero s]
  simp only [ProbabilityMeasure.mass_toFiniteMeasure, inv_one, one_mul]
  congr"
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      refine' ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      refine' ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine' ‚ü®U, {j}, _, _‚ü©
    ¬∑ rintro i h
      rw [Finset.mem_singleton] at h
      dsimp
      rw [dif_pos h]
      subst h
      exact hV
    ¬∑ dsimp
      simp
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ (e) (_he : e ‚àà G), j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine' ‚ü®j, V, _, _‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine' this _ _ _ (univ _) (inter _) _
      intro e he
      dsimp
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      rw [‚Üêcoe_comp, D.w]
      rfl","error:  unknown identifier 'isTopologicalBasis_iInf'
error:  no goals to be solved","theorem isTopologicalBasis_cofiltered_limit (T : ‚àÄ j, Set (Set (F.obj j)))
    (hT : ‚àÄ j, IsTopologicalBasis (T j)) (univ : ‚àÄ i : J, Set.univ ‚àà T i)
    (inter : ‚àÄ (i) (U1 U2 : Set (F.obj i)), U1 ‚àà T i ‚Üí U2 ‚àà T i ‚Üí U1 ‚à© U2 ‚àà T i)
    (compat : ‚àÄ (i j : J) (f : i ‚ü∂ j) (V : Set (F.obj j)) (_hV : V ‚àà T j), F.map f ‚Åª¬π' V ‚àà T i) :
    IsTopologicalBasis
      {U : Set C.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = C.œÄ.app j ‚Åª¬π' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [‚Üê coe_comp, D.w] 
      rfl",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      refine ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      refine ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ rintro i h
      rw [Finset.mem_singleton] at h
      dsimp
      rw [dif_pos h]
      subst h
      exact hV
    ¬∑ dsimp
      simp
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ (e) (_he : e ‚àà G), j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
        exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
        exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
        exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
        exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
        exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ ("
Mathlib/Data/Int/Order/Lemmas.lean,Int.eq_zero_of_abs_lt_dvd,eq_zero_of_abs_lt_dvd,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  by_cases hm : m = 0
  ¬∑ subst m
    exact zero_dvd_iff.mp h1
  rcases h1 with ‚ü®d, rfl‚ü©
  apply mul_eq_zero_of_right
  rw [‚Üê abs_lt_one_iff, ‚Üê mul_lt_iff_lt_one_right (abs_pos.mpr hm), ‚Üê abs_mul]
  exact lt_of_lt_of_le h2 (le_abs_self m)",error:  unknown identifier 'zero_dvd_iff.mp',theorem eq_zero_of_abs_lt_dvd {m x : ‚Ñ§} (h1 : m ‚à£ x) (h2 : |x| < m) : x = 0 ,":= by
  obtain rfl | hm := eq_or_ne m 0
  ¬∑ exact Int.zero_dvd.1 h1
  rcases h1 with ‚ü®d, rfl‚ü©
  apply mul_eq_zero_of_right
  rw [‚Üê abs_lt_one_iff, ‚Üê mul_lt_iff_lt_one_right (abs_pos.mpr hm), ‚Üê abs_mul]
  exact lt_of_lt_of_le h2 (le_abs_self m)",":= by
  by_cases hm : m = 0
  ¬∑ subst m
    exact zero_dvd_iff.mp h1
  rcases h1 with ‚ü®d, rfl‚ü©
  apply mul_eq_zero_of_right
  rw [‚Üê abs_lt_one_iff, ‚Üê mul_lt_iff_lt_one_right abs_pos.mpr hm, ‚Üê abs_mul]
  exact lt_of_lt_of_le h2 (le_abs_self m)"
Mathlib/LinearAlgebra/Semisimple.lean,Module.End.IsSemisimple.of_mem_adjoin_pair,IsSemisimple.of_mem_adjoin_pair,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R := (AdjoinRoot.powerBasis' <| minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral g).map _).finite
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ, ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.comp_apply, minpoly.aeval, œÜ.map_zero]","error:  function expected at
  isIntegral
term has type
  Algebra.IsIntegral ?m.165678 (End ?m.165678 ?m.165680)
error:  function expected at
  isIntegral
term has type
  Algebra.IsIntegral ?m.168378 (End ?m.168378 ?m.168380)
error:  type mismatch
  IsScalarTower.of_algebraMap_eq fun x ‚Ü¶ rfl
has type
  IsScalarTower K K ?m.178372 : Prop
but is expected to have type
  IsScalarTower K R S : Prop
error:  application type mismatch
  of_mem_adjoin_pair comm
argument
  comm
has type
  Commute f g : Prop
but is expected to have type
  ?m.183134 ‚àà Algebra.adjoin ?m.183129 {?m.183132, ?m.183133} : Prop
error:  application type mismatch
  of_mem_adjoin_pair comm
argument
  comm
has type
  Commute f g : Prop
but is expected to have type
  ?m.185695 ‚àà Algebra.adjoin ?m.185690 {?m.185693, ?m.185694} : Prop
error:  application type mismatch
  of_mem_adjoin_pair comm
argument
  comm
has type
  Commute f g : Prop
but is expected to have type
  ?m.188237 ‚àà Algebra.adjoin ?m.188232 {?m.188235, ?m.188236} : Prop","theorem IsSemisimple.of_mem_adjoin_pair {a : End K M} (ha : a ‚àà Algebra.adjoin K {f, g}) :
    a.IsSemisimple ",":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R :=
    (AdjoinRoot.powerBasis' <| minpoly.monic <| Algebra.IsIntegral.isIntegral f).finite
  have : Finite R S :=
    (AdjoinRoot.powerBasis' <| (minpoly.monic <| Algebra.IsIntegral.isIntegral g).map _).finite
  set_option maxSynthPendingDepth 2 in
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ, ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.comp_apply, minpoly.aeval, œÜ.map_zero]",":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R := (AdjoinRoot.powerBasis' <| minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral g).map _).finite
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ', ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.c"
Mathlib/NumberTheory/Pell.lean,Pell.Solution‚ÇÅ.exists_pos_of_not_isSquare,exists_pos_of_not_isSquare,2edc8bf32ccf16fde8f412b6f759abedf7011157,":= by
  obtain ‚ü®x, y, h, hy‚ü© := exists_of_not_isSquare h‚ÇÄ hd
  refine' ‚ü®mk (|x|) (|y|) (by rwa [sq_abs, sq_abs]), _, abs_pos.mpr hy‚ü©
  rw [x_mk, ‚Üê one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]
  exact mul_pos h‚ÇÄ (sq_pos_of_ne_zero y hy)","error:  application type mismatch
  sq_pos_of_ne_zero y
argument
  y
has type
  ‚Ñ§ : Type
but is expected to have type
  ?m.135767 ‚â† 0 : Prop","theorem exists_pos_of_not_isSquare (h‚ÇÄ : 0 < d) (hd : ¬¨IsSquare d) :
    ‚àÉ a : Solution‚ÇÅ d, 1 < a.x ‚àß 0 < a.y ",":= by
  obtain ‚ü®x, y, h, hy‚ü© := exists_of_not_isSquare h‚ÇÄ hd
  refine ‚ü®mk |x| |y| (by rwa [sq_abs, sq_abs]), ?_, abs_pos.mpr hy‚ü©
  rw [x_mk, ‚Üê one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]
  exact mul_pos h‚ÇÄ (sq_pos_of_ne_zero hy)",":= by
  obtain ‚ü®x, y, h, hy‚ü© := exists_of_not_isSquare h‚ÇÄ hd
  refine ‚ü®mk (|x|) (|y|) (by omega), ?_, abs_pos.mpr hy‚ü©
  rw [x_mk, ‚Üê one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]
  exact mul_pos h‚ÇÄ (sq_pos_of_ne_zero y hy)"
Mathlib/NumberTheory/EllipticDivisibilitySequence.lean,normEDS_two,normEDS_two,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  erw [normEDS, Int.cast_one, one_mul, normEDS'_two]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë1
R : Type u
S : Type v
inst‚úù¬π : CommRing R
inst‚úù : CommRing S
W : ‚Ñ§ ‚Üí R
f : R ‚Üí+* S
b c d : R
‚ä¢ (preNormEDS (b ^ 4) c d 2 * if Even 2 then b else 1) = b",lemma normEDS_two : normEDS b c d 2 = b ,":= by
  erw [normEDS_ofNat, preNormEDS'_two, one_mul, if_pos even_two]",":= by
  erw [normEDS, Int.cast_one, one_mul]"
Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean,CircleDeg1Lift.translationNumber_mono,translationNumber_mono,746edd99decd559e5b12437d37d2a05ac880319f,":= fun f g h =>
  le_of_tendsto_of_tendsto' f.tendsto_translation_number‚ÇÄ g.tendsto_translation_number‚ÇÄ fun _ ‚Ü¶ by
    gcongr","error:  unsolved goals
case hab
f‚úù g‚úù f g : CircleDeg1Lift
h : f ‚â§ g
x‚úù : ‚Ñï
‚ä¢ (f ^ x‚úù) 0 ‚â§ (g ^ x‚úù) 0",theorem translationNumber_mono : Monotone œÑ ,":= fun f g h =>
  le_of_tendsto_of_tendsto' f.tendsto_translation_number‚ÇÄ g.tendsto_translation_number‚ÇÄ fun n => by
    gcongr; exact pow_mono h _ _",":= fun f g h =>
  le_of_tendsto_of_tendsto' f.tendsto_translation_number‚ÇÄ fun _ ‚Ü¶ by
    gcongr"
Mathlib/Data/Set/Pointwise/Finite.lean,Set.finite_mul,finite_mul,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  finite_image2  (fun _ _ ‚Ü¶ (mul_left_injective _).injOn _)
    fun _ _ ‚Ü¶ (mul_right_injective _).injOn _","error:  type mismatch
  Function.Injective.injOn (mul_left_injective ?m.6098) ?m.6166
has type
  ‚àÄ ‚¶Éx‚ÇÇ : ?m.6156‚¶Ñ, x‚ÇÇ ‚àà ?m.6164 ‚Üí ?m.6165 * ?m.6098 = x‚ÇÇ * ?m.6098 ‚Üí ?m.6165 = x‚ÇÇ : Prop
but is expected to have type
  InjOn (fun x ‚Ü¶ x * x‚úù¬π) s : Prop
error:  type mismatch
  Function.Injective.injOn (mul_right_injective ?m.6436) ?m.6504
has type
  ‚àÄ ‚¶Éx‚ÇÇ : ?m.6494‚¶Ñ, x‚ÇÇ ‚àà ?m.6502 ‚Üí ?m.6436 * ?m.6503 = ?m.6436 * x‚ÇÇ ‚Üí ?m.6503 = x‚ÇÇ : Prop
but is expected to have type
  InjOn (fun x ‚Ü¶ x‚úù¬π * x) t : Prop",lemma finite_mul : (s * t).Finite ‚Üî s.Finite ‚àß t.Finite ‚à® s = ‚àÖ ‚à® t = ‚àÖ ,":=
  finite_image2  (fun _ _ ‚Ü¶ (mul_left_injective _).injOn)
    fun _ _ ‚Ü¶ (mul_right_injective _).injOn",":=
  finite_image2 fun _ _ ‚Ü¶ (mul_left_injective _).injOn"
Mathlib/Topology/Perfect.lean,exists_perfect_nonempty_of_isClosed_of_not_countable,exists_perfect_nonempty_of_isClosed_of_not_countable,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with ‚ü®V, D, Vct, Dperf, VD‚ü©
  refine' ‚ü®D, ‚ü®Dperf, _‚ü©‚ü©
  constructor
  ¬∑ rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right _ _","error:  function expected at
  subset_union_right ?m.8728
term has type
  ?m.8727 ‚àà ?m.8725 ‚à™ ?m.8726","theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology Œ±]
    (hclosed : IsClosed C) (hunc : ¬¨C.Countable) : ‚àÉ D : Set Œ±, Perfect D ‚àß D.Nonempty ‚àß D ‚äÜ C ",":= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with ‚ü®V, D, Vct, Dperf, VD‚ü©
  refine ‚ü®D, ‚ü®Dperf, ?_‚ü©‚ü©
  constructor
  ¬∑ rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right",":= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with ‚ü®V, D, Vct, Dperf, VD‚ü©
  refine ‚ü®D, ‚ü®Dperf, ?_‚ü©‚ü©
  constructor
  ¬∑ rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right"
Mathlib/Algebra/Lie/Engel.lean,Function.Surjective.isEngelian,Function.Surjective.isEngelian,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  intro M _i1 _i2 _i3 _i4 h'
  letI : LieRingModule L M := LieRingModule.compLieHom M f
  letI : LieModule R L M := compLieHom M f
  have hnp : ‚àÄ x, IsNilpotent (toEndomorphism R L M x) := fun x => h' (f x)
  have surj_id : Function.Surjective (LinearMap.id : M ‚Üí‚Çó[R] M) := Function.surjective_id
  haveI : LieModule.IsNilpotent R L M := h M hnp
  apply hf.lieModuleIsNilpotent surj_id
  intros; simp only [LinearMap.id_coe, id_eq]; rfl",error:  unknown identifier 'toEndomorphism',"theorem Function.Surjective.isEngelian {f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (hf : Function.Surjective f)
    (h : LieAlgebra.IsEngelian.{u‚ÇÅ, u‚ÇÇ, u‚ÇÑ} R L) : LieAlgebra.IsEngelian.{u‚ÇÅ, u‚ÇÉ, u‚ÇÑ} R L‚ÇÇ ",":= by
  intro M _i1 _i2 _i3 _i4 h'
  letI : LieRingModule L M := LieRingModule.compLieHom M f
  letI : LieModule R L M := compLieHom M f
  have hnp : ‚àÄ x, IsNilpotent (toEnd R L M x) := fun x => h' (f x)
  have surj_id : Function.Surjective (LinearMap.id : M ‚Üí‚Çó[R] M) := Function.surjective_id
  haveI : LieModule.IsNilpotent R L M := h M hnp
  apply hf.lieModuleIsNilpotent surj_id
  intros; simp only [LinearMap.id_coe, id_eq]; rfl",":= by
  intro M _i1 _i2 _i3 _i4 h'
  letI : LieRingModule L M := LieHom M f
  have hnp : ‚àÄ x, IsNilpotent (toEnd R L M x) := fun x => h' (f x)
  have surj_id : Function.Surjective (LinearMap.id : M ‚Üí‚Çó[R] M) := Function.surjective_id
  haveI : LieModule.IsNilpotent R L M := h M hnp
  apply hf.lieModuleIsNilpotent surj_id
  intros; simp only [LinearMap.id_coe, id_eq]; rfl"
Mathlib/Combinatorics/Schnirelmann.lean,schnirelmannDensity_le_of_not_mem,schnirelmannDensity_le_of_not_mem,441b6cef620844aa6bcf947d63af335383e5dfdf,":= by
  rcases k.eq_zero_or_pos with rfl | hk'
  ¬∑ simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [‚Üê one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw [‚Üê Nat.cast_pred hk', Nat.cast_le]
  suffices : (Ioc 0 k).filter (¬∑ ‚àà A) ‚äÜ Ioo 0 k; exact (card_le_of_subset this).trans_eq (by simp)
  rw [‚Üê Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _",error:  unexpected token ':'; expected term,"lemma schnirelmannDensity_le_of_not_mem {k : ‚Ñï} (hk : k ‚àâ A) :
    schnirelmannDensity A ‚â§ 1 - (k‚Åª¬π : ‚Ñù) ",":= by
  rcases k.eq_zero_or_pos with rfl | hk'
  ¬∑ simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [‚Üê one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  gcongr
  rw [‚Üê Nat.cast_pred hk', Nat.cast_le]
  suffices (Ioc 0 k).filter (¬∑ ‚àà A) ‚äÜ Ioo 0 k from (card_le_card this).trans_eq (by simp)
  rw [‚Üê Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _",":= by
  rcases k.eq_zero_or_pos with rfl | hk'
  ¬∑ simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [‚Üê one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw [‚Üê Nat.cast_pred hk', Nat.cast_le]
  suffices (Ioc 0 k).filter (¬∑ ‚àà A) ‚äÜ Ioo 0 k from (card_le_of_subset this).trans_eq (by simp)
  rw [‚Üê Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _"
Mathlib/Data/PNat/Xgcd.lean,PNat.gcdA'_coe,gcdA'_coe,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp [gcdA', gcdX, gcdW, XgcdType.w]
  rw [Nat.succ_eq_add_one, Nat.succ_eq_add_one, add_right_comm]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
a b : ‚Ñï+
‚ä¢ (a.xgcd b).wp + (a.xgcd b).x + 1 = (a.xgcd b).wp + 1 + (a.xgcd b).x",theorem gcdA'_coe : (gcdA' a b : ‚Ñï) = gcdW a b + gcdX a b ,":= by
  dsimp [gcdA', gcdX, gcdW, XgcdType.w]
  rw [add_right_comm]",":= by
  dsimp [gcdA', gcdX, gcdW, XgcdType.w]
  rw [Nat.succ_eq_add_one, Nat.succ_eq_add_one, add_right_comm]"
Mathlib/SetTheory/Ordinal/Arithmetic.lean,Ordinal.limitRecOn_limit,limitRecOn_limit,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rw [limitRecOn, lt_wf.fix_eq, dif_neg h.1, dif_neg (not_succ_of_isLimit h)]; rfl","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  lt_wf.fix ?F ?x
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
r : Œ± ‚Üí Œ± ‚Üí Prop
s : Œ≤ ‚Üí Œ≤ ‚Üí Prop
t : Œ≥ ‚Üí Œ≥ ‚Üí Prop
C : Ordinal.{u_4} ‚Üí Sort u_5
o : Ordinal.{u_4}
H‚ÇÅ : C 0
H‚ÇÇ : (o : Ordinal.{u_4}) ‚Üí C o ‚Üí C (succ o)
H‚ÇÉ : (o : Ordinal.{u_4}) ‚Üí o.IsLimit ‚Üí ((o' : Ordinal.{u_4}) ‚Üí o' < o ‚Üí C o') ‚Üí C o
h : o.IsLimit
‚ä¢ (SuccOrder.limitRecOn o (fun o x ‚Ü¶ H‚ÇÇ o) fun o hl ‚Ü¶ if h : o = 0 then fun x ‚Ü¶ ‚ãØ ‚ñ∏ H‚ÇÅ else H‚ÇÉ o ‚ãØ) =
    H‚ÇÉ o h fun x _h ‚Ü¶ x.limitRecOn H‚ÇÅ H‚ÇÇ H‚ÇÉ","theorem limitRecOn_limit {C} (o H‚ÇÅ H‚ÇÇ H‚ÇÉ h) :
    @limitRecOn C o H‚ÇÅ H‚ÇÇ H‚ÇÉ = H‚ÇÉ o h fun x _h => @limitRecOn C x H‚ÇÅ H‚ÇÇ H‚ÇÉ ",":= by
  simp_rw [limitRecOn, SuccOrder.limitRecOn_limit _ _ h.isSuccLimit, dif_neg h.1]",":= by
  rw [limitRecOn, lt_wf.fix_eq, dif_neg h.1, dif_neg h.1]; rfl"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/Logic/Equiv/Set.lean,Equiv.swap_bijOn_self,Equiv.swap_bijOn_self,7517f38ed8672b95cb4dd3df959ccd3f6d36c011,":= by
  refine ‚ü®fun x hx ‚Ü¶ ?_, (Equiv.injective _).injOn _, fun x hx ‚Ü¶ ?_‚ü©
  ¬∑ obtain (rfl | hxa) := eq_or_ne x a
    ¬∑ rwa [swap_apply_left, ‚Üê hs]
    obtain (rfl | hxb) := eq_or_ne x b
    ¬∑ rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a
  ¬∑ simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b
  ¬∑ simp [hs.2 hx]
  exact ‚ü®x, hx, swap_apply_of_ne_of_ne hxa hxb‚ü©","error:  application type mismatch
  And.intro (Injective.injOn (Equiv.injective ?m.64892) ?m.64914)
argument
  Injective.injOn (Equiv.injective ?m.64892) ?m.64914
has type
  ‚àÄ ‚¶Éx‚ÇÇ : ?m.64905‚¶Ñ, x‚ÇÇ ‚àà ?m.64912 ‚Üí ?m.64892 ?m.64913 = ?m.64892 x‚ÇÇ ‚Üí ?m.64913 = x‚ÇÇ : Prop
but is expected to have type
  InjOn (‚áë(swap a b)) s : Prop",theorem Equiv.swap_bijOn_self (hs : a ‚àà s ‚Üî b ‚àà s) : BijOn (Equiv.swap a b) s s ,":= by
  refine ‚ü®fun x hx ‚Ü¶ ?_, (Equiv.injective _).injOn, fun x hx ‚Ü¶ ?_‚ü©
  ¬∑ obtain (rfl | hxa) := eq_or_ne x a
    ¬∑ rwa [swap_apply_left, ‚Üê hs]
    obtain (rfl | hxb) := eq_or_ne x b
    ¬∑ rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a
  ¬∑ simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b
  ¬∑ simp [hs.2 hx]
  exact ‚ü®x, hx, swap_apply_of_ne_of_ne hxa hxb‚ü©",":= by
  refine ‚ü®fun x hx ‚Ü¶ ?_, (Equiv.injective _).injOn ?_, fun x hx ‚Ü¶ ?_‚ü©
  ¬∑ obtain (rfl | hxa) := eq_or_ne x a
    ¬∑ rwa [swap_apply_left, ‚Üê hs]
    obtain (rfl | hxb) := eq_or_ne x b
    ¬∑ rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a
  ¬∑ simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b
  ¬∑ simp [hs.2 hx]
  exact ‚ü®x, hx, swap_apply_of_ne_of_ne hxa hxb‚ü©"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.mem_of_mem_tail,mem_of_mem_tail,88f252d9ef6777980e9cb4396094e178f3ed4acb,":= by
  intro h; have := h; cases' h with n e; revert s
  induction' n with n IH <;> intro s <;> induction' s using WSeq.recOn' with x s s <;>
    simp <;> intro m e <;>
    injections
  ¬∑ exact Or.inr m
  ¬∑ exact Or.inr m
  ¬∑ apply IH m
    rw [e]","error:  unknown constant 'Stream'.WSeq.recOn''
error:  unknown constant 'Stream'.WSeq.recOn''
error:  type mismatch
  Or.inr m
has type
  ?m.46055 ‚à® a ‚àà s.tail : Prop
but is expected to have type
  a ‚àà s : Prop
error:  type mismatch
  Or.inr m
has type
  ?m.46057 ‚à® a ‚àà s.tail : Prop
but is expected to have type
  a ‚àà s : Prop
error:  no goals to be solved",theorem mem_of_mem_tail {s : WSeq Œ±} {a} : a ‚àà tail s ‚Üí a ‚àà s ,":= by
  intro h; have := h; cases' h with n e; revert s; simp only [Stream'.get]
  induction' n with n IH <;> intro s <;> induction' s using WSeq.recOn with x s s <;>
    simp <;> intro m e <;>
    injections
  ¬∑ exact Or.inr m
  ¬∑ exact Or.inr m
  ¬∑ apply IH m
    rw [e]
    cases tail s
    rfl",":= by
  intro h; have := h; cases' h with n e; revert s
  induction' n with n IH <;> intro s <;> induction' s using WSeq.recOn' with x s s <;>
    simp <;> intro m e <;>
    injections
  ¬∑ exact Or.inr m
  ¬∑ exact Or.inr m
  ¬∑ apply IH m
    rw [e]"
Mathlib/Data/Set/Function.lean,Equiv.bijOn',bijOn',ac36b28ef3759cb65a7f386f3b7e15ee0ac1b4c9,:=,error:  unexpected token 'protected'; expected term,lemma bijOn' (h‚ÇÅ : MapsTo e s t) (h‚ÇÇ : MapsTo e.symm t s) : BijOn e s t ,":=
  ‚ü®h‚ÇÅ, e.injective.injOn, fun b hb ‚Ü¶ ‚ü®e.symm b, h‚ÇÇ hb, apply_symm_apply _ _‚ü©‚ü©",":=
  bijOn_iff.2 ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero, Nat.zero_eq,
          Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120388 ‚Üí ?m.120388
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.123472 ‚Üí ?m.123472
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà u 0, closedBall p.1 p.2) ‚â§ Œº s
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1` has been deprecated, use `ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one` instead
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133159 ‚Üí ?m.133159 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133295 ‚Üí ?m.133295 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/MeasureTheory/Measure/Portmanteau.lean,MeasureTheory.tendsto_of_forall_isOpen_le_liminf,tendsto_of_forall_isOpen_le_liminf,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine ProbabilityMeasure.tendsto_iff_forall_integral_tendsto.mpr ?_
  apply tendsto_integral_of_forall_integral_le_liminf_integral
  intro f f_nn
  apply integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure (f := f) f_nn
  intro G G_open
  specialize h_opens G G_open
  simp only at h_opens
  have aux : ENNReal.ofNNReal (liminf (fun i ‚Ü¶ ENNReal.toNNReal ((Œºs i : Measure Œ©) G)) atTop) =
          liminf (ENNReal.ofNNReal ‚àò fun i ‚Ü¶ (ENNReal.toNNReal ((Œºs i : Measure Œ©) G))) atTop := by
    refine Monotone.map_liminf_of_continuousAt (F := atTop) ENNReal.coe_mono (Œºs ¬∑ G) ?_ ?_ ?_
    ¬∑ apply ENNReal.continuous_coe.continuousAt
    ¬∑ use 1
      simp only [eventually_map, ProbabilityMeasure.apply_le_one, eventually_atTop, ge_iff_le,
        implies_true, forall_const, exists_const]
    ¬∑ use 0
      simp only [zero_le, eventually_map, eventually_atTop, ge_iff_le, implies_true, forall_const,
        exists_const]
  have obs := ENNReal.coe_mono h_opens
  simp only [ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure, aux] at obs
  convert obs
  simp only [Function.comp_apply, ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure]",error:  simp made no progress,"theorem tendsto_of_forall_isOpen_le_liminf {Œº : ProbabilityMeasure Œ©}
    {Œºs : ‚Ñï ‚Üí ProbabilityMeasure Œ©}
    (h_opens : ‚àÄ G, IsOpen G ‚Üí Œº G ‚â§ atTop.liminf (fun i ‚Ü¶ Œºs i G)) :
    atTop.Tendsto (fun i ‚Ü¶ Œºs i) (ùìù Œº) ",":= by
  refine ProbabilityMeasure.tendsto_iff_forall_integral_tendsto.mpr ?_
  apply tendsto_integral_of_forall_integral_le_liminf_integral
  intro f f_nn
  apply integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure (f := f) f_nn
  intro G G_open
  specialize h_opens G G_open
  have aux : ENNReal.ofNNReal (liminf (fun i ‚Ü¶ Œºs i G) atTop) =
          liminf (ENNReal.ofNNReal ‚àò fun i ‚Ü¶ Œºs i G) atTop := by
    refine Monotone.map_liminf_of_continuousAt (F := atTop) ENNReal.coe_mono (Œºs ¬∑ G) ?_ ?_ ?_
    ¬∑ apply ENNReal.continuous_coe.continuousAt
    ¬∑ use 1
      simp only [eventually_map, ProbabilityMeasure.apply_le_one, eventually_atTop, ge_iff_le,
        implies_true, forall_const, exists_const]
    ¬∑ use 0
      simp only [zero_le, eventually_map, eventually_atTop, ge_iff_le, implies_true, forall_const,
        exists_const]
  have obs := ENNReal.coe_mono h_opens
  simp only [ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure, aux] at obs
  convert obs
  simp only [Function.comp_apply, ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure]",":= by
  refine ProbabilityMeasure.tendsto_iff_forall_integral_tendsto.mpr ?_
  apply tendsto_integral_of_forall_integral_le_liminf_integral
  intro f f_nn
  apply integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure (f := f) f_nn
  intro G G_open
  specialize h_opens G G_open
  simp only at h_opens
  have aux : ENNReal.ofNNReal (liminf (fun i ‚Ü¶ ENNReal.toNNReal ((Œºs i : Measure Œ©) G)) atTop) =
          liminf (ENNReal.ofNNReal ‚àò fun i ‚Ü¶ (ENNReal.toNNReal ((Œºs i : Measure Œ©) G))) atTop := by
    refine Monotone.map_liminf_of_continuousAt (F := atTop) ENNReal.coe_mono (Œºs ¬∑ G) ?_ ?_ ?_
    ¬∑ apply ENNReal.continuous_coe.continuousAt
    ¬∑ use 1
      simp only [eventually_map, ProbabilityMeasure.apply_le_one, eventually_atTop, ge_iff_le,
        implies_true, forall_const, exists_const]
    ¬∑ use 0
      simp only [zero_le, eventually_map, eventually_atTop, ge_iff_le, implies_true, forall_const,
        exists_const]
  have obs := ENNReal.coe_mono h_opens
  simp only [ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure, aux] at obs
  convert obs
  simp only [Function.comp_apply, ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure]"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpi_tfae,effectiveEpi_tfae,df6d9dfd71b46903e969bf2377a41d5a74ade252,":= by
  tfae_have 1 ‚Üí 2
  | _ => inferInstance
  tfae_have 2 ‚Üî 3 := epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1 := fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish","error:  unsolved goals
case tfae_1_to_2
B X : Profinite
œÄ : X ‚ü∂ B
‚ä¢ EffectiveEpi œÄ ‚Üí Epi œÄ

B X : Profinite
œÄ : X ‚ü∂ B
tfae_1_to_2 : EffectiveEpi œÄ ‚Üí Epi œÄ
‚ä¢ [EffectiveEpi œÄ, Epi œÄ, Function.Surjective ‚áëœÄ].TFAE
error:  unexpected token '|'; expected command","theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (œÄ : X ‚ü∂ B) :
    TFAE
    [ EffectiveEpi œÄ
    , Epi œÄ
    , Function.Surjective œÄ
    ] ",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",":= by
  tfae_have 1 ‚Üí 2
  | _ => inferInstance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,65f7857d510e130142dbb111786341d695ac399b,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",error:  simp made no progress,"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.null_of_frequently_le_of_frequently_ge,null_of_frequently_le_of_frequently_ge,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  apply null_of_locally_null s fun x _ => ?_
  obtain ‚ü®o, xo, o_open, Œºo‚ü© : ‚àÉ o : Set Œ±, x ‚àà o ‚àß IsOpen o ‚àß Œº o < ‚àû :=
    Measure.exists_isOpen_measure_lt_top Œº x
  refine' ‚ü®s ‚à© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), _‚ü©
  let s' := s ‚à© o
  by_contra h
  apply lt_irrefl (œÅ s')
  calc
    œÅ s' ‚â§ c * Œº s' := v.measure_le_of_frequently_le (c ‚Ä¢ Œº) hœÅ s' fun x hx => hc x hx.1
    _ < d * Œº s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono (inter_subset_right _ _)) Œºo).ne
    _ ‚â§ œÅ s' :=
      v.measure_le_of_frequently_le œÅ ((Measure.AbsolutelyContinuous.refl Œº).smul d) s' fun x hx =>
        hd x hx.1","warning:  `MeasureTheory.null_of_locally_null` has been deprecated, use `MeasureTheory.measure_null_of_locally_null` instead
error:  function expected at
  inter_subset_right ?m.58097
term has type
  ?m.58096 ‚àà ?m.58095","theorem null_of_frequently_le_of_frequently_ge {c d : ‚Ñù‚â•0} (hcd : c < d) (s : Set Œ±)
    (hc : ‚àÄ x ‚àà s, ‚àÉ·∂† a in v.filterAt x, œÅ a ‚â§ c * Œº a)
    (hd : ‚àÄ x ‚àà s, ‚àÉ·∂† a in v.filterAt x, (d : ‚Ñù‚â•0‚àû) * Œº a ‚â§ œÅ a) : Œº s = 0 ",":= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ‚ü®o, xo, o_open, Œºo‚ü© : ‚àÉ o : Set Œ±, x ‚àà o ‚àß IsOpen o ‚àß Œº o < ‚àû :=
    Measure.exists_isOpen_measure_lt_top Œº x
  refine ‚ü®s ‚à© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_‚ü©
  let s' := s ‚à© o
  by_contra h
  apply lt_irrefl (œÅ s')
  calc
    œÅ s' ‚â§ c * Œº s' := v.measure_le_of_frequently_le (c ‚Ä¢ Œº) hœÅ s' fun x hx => hc x hx.1
    _ < d * Œº s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono inter_subset_right) Œºo).ne
    _ ‚â§ œÅ s' :=
      v.measure_le_of_frequently_le œÅ ((Measure.AbsolutelyContinuous.refl Œº).smul d) s' fun x hx =>
        hd x hx.1",":= by
  apply null_of_locally_null s fun x _ => ?_
  obtain ‚ü®o, xo, o_open, Œºo‚ü© : ‚àÉ o : Set Œ±, x ‚àà o ‚àß IsOpen o ‚àß Œº o < ‚àû :=
    Measure.exists_isOpen_measure_lt_top Œº x
  refine ‚ü®s ‚à© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_‚ü©
  let s' := s ‚à© o
  by_contra h
  apply lt_irrefl (œÅ s')
  calc
    œÅ s' ‚â§ c * Œº s' := v.measure_le_of_frequently_le (c ‚Ä¢ Œº) hœÅ s' fun x hx => hc x hx.1
    _ < d * Œº s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt inter_subset_right) Œºo).ne
    _ ‚â§ œÅ s' :=
      v.measure_le_of_frequently_le œÅ ((Measure.AbsolutelyContinuous.refl Œº).smul d) s' fun x hx =>
        hd x hx.1"
Mathlib/LinearAlgebra/BilinearForm/Properties.lean,LinearMap.BilinForm.Nondegenerate.flip,Nondegenerate.flip,31c261277bc3e8a52b74d248691ef6b40c75b452,":=
  LinearMap.BilinForm.SeparatingLeft.flip (B := (BilinForm.toLin B)) hB",error:  unknown constant 'LinearMap.BilinForm.SeparatingLeft.flip',"lemma Nondegenerate.flip {B : BilinForm K V} (hB : B.Nondegenerate) :
    B.flip.Nondegenerate ",":= by
  intro x hx
  apply (Module.evalEquiv K V).injective
  ext f
  obtain ‚ü®y, rfl‚ü© := (B.toDual hB).surjective f
  simpa using hx y",":=
  LinearMap.BilinForm.SeparatingLeft"
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Œ¥_comp_œÉ_of_gt,Œ¥_comp_œÉ_of_gt,2009db69c1211eafea457d1c3902f31370dac23f,":= by
  ext ‚ü®k, hk‚ü©
  rcases i with ‚ü®i, hi‚ü©
  rcases j with ‚ü®j, hj‚ü©
  simp at H hk
  dsimp [Œ¥, œÉ, Fin.predAbove, Fin.succAbove]
  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, ge_iff_le,
    Fin.coe_castLT, dite_eq_ite, Fin.coe_castSucc, Fin.val_succ]
  split_ifs
  all_goals try simp <;> linarith
  all_goals cases k <;> simp at * <;> linarith","error:  linarith failed to find a contradiction
case neg.zero.h1.h
n i : ‚Ñï
hi : i < n + 2
j : ‚Ñï
hj : j < n + 1
H : j < i
hk : 0 < n + 1 + 1
h‚úù¬π : 0 < i + 1
h‚úù : ¬¨j < 0
a‚úù : 0 < if 0 < i then 0 else 1
‚ä¢ False
failed
error:  linarith failed to find a contradiction
case neg.succ.h1.h
n i : ‚Ñï
hi : i < n + 2
j : ‚Ñï
hj : j < n + 1
H : j < i
n‚úù : ‚Ñï
hk : n‚úù + 1 < n + 1 + 1
h‚úù¬π : n‚úù + 1 < i + 1
h‚úù : ¬¨j < n‚úù + 1
a‚úù : n‚úù + 1 < if n‚úù + 1 < i then n‚úù + 1 else n‚úù + 1 + 1
‚ä¢ False
failed
error:  unsolved goals
case neg.zero
n i : ‚Ñï
hi : i < n + 2
j : ‚Ñï
hj : j < n + 1
H : j < i
hk : 0 < n + 1 + 1
h‚úù¬π : 0 < i + 1
h‚úù : ¬¨j < 0
‚ä¢ 0 = if 0 < i then 0 else 1

case neg.succ
n i : ‚Ñï
hi : i < n + 2
j : ‚Ñï
hj : j < n + 1
H : j < i
n‚úù : ‚Ñï
hk : n‚úù + 1 < n + 1 + 1
h‚úù¬π : n‚úù + 1 < i + 1
h‚úù : ¬¨j < n‚úù + 1
‚ä¢ n‚úù + 1 = if n‚úù + 1 < i then n‚úù + 1 else n‚úù + 1 + 1","theorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Œ¥ i.succ ‚â´ œÉ (Fin.castSucc j) = œÉ j ‚â´ Œ¥ i ",":= by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]",":= by
  ext ‚ü®k, hk‚ü©
  rcases i with ‚ü®i, hi‚ü©
  rcases j with ‚ü®j, hj‚ü©
  simp at H hk
  dsimp [Œ¥, œÉ, Fin.predAbove, Fin.succAbove]
  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, ge_iff_le,
    Fin.coe_castLT, dite_eq_ite, Fin.coe_castSucc, Fin.val_succ]
  split_ifs
  all_goals try simp <;> linarith
  all_goals cases k <;> simp at * <;> linarith"
Mathlib/Analysis/Convolution.lean,MeasureTheory.hasFDerivAt_convolution_right_with_param,hasFDerivAt_convolution_right_with_param,6eab74639023015a7887e2f82e153907286e3801,":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine' (hasFDerivAt_zero_of_eventually_const 0 _).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß Bounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_open (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_bounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s
      ¬∑ exact Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine' ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, _, _‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C; exact ht.subset_ball_lt 0 0
    refine' ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => _‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine' mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), _, _‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine' (HasCompactSupport.convolutionExists_right L _ hf (A _ hp) _).1
    apply isCompact_of_isClosed_subset hk (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_open (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº
  exact hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine' ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, _‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    apply eventually_of_forall
    intro a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    apply eventually_of_forall
    intro a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, id.def, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6","error:  application type mismatch
  IsOpen t ‚àß Bounded ?m.1514491
argument
  Bounded ?m.1514491
has type
  Set ?m.1513019 ‚Üí Prop : Type ?u.1513018
but is expected to have type
  Prop : Type
error:  invalid field 'continuousOn_fderiv_of_open', the environment does not contain 'ContDiffOn.continuousOn_fderiv_of_open'
  hg
has type
  ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hg
has type
  ‚àÄ x ‚àà s √óÀ¢ univ, ContDiffWithinAt ùïú 1 (‚Üøg) (s √óÀ¢ univ) x
error:  unknown identifier 'exists_isOpen_bounded_image_of_isCompact_of_continuousOn'
error:  application type mismatch
  Bounded (g' '' t)
argument
  g' '' t
has type
  Set (P √ó G ‚ÜíL[ùïú] E') : Type (max (max uE' uG) uP)
but is expected to have type
  ?m.1513019 ‚Üí ?m.1513019 ‚Üí Prop : Type ?u.1513018
error:  unknown identifier 'isCompact_of_isClosed_subset'
error:  invalid field 'continuousOn_fderiv_of_open', the environment does not contain 'ContDiffOn.continuousOn_fderiv_of_open'
  hg
has type
  ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hg
has type
  ‚àÄ x ‚àà s √óÀ¢ univ, ContDiffWithinAt ùïú 1 (‚Üøg) (s √óÀ¢ univ) x
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1585397 ‚Üí ?m.1585397
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1585692 ‚Üí ?m.1585692
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  unsolved goals
case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.1 = (_root_.id x).1

case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.2 - a = (_root_.id x).2 - a","theorem hasFDerivAt_convolution_right_with_param {g : P ‚Üí G ‚Üí E'} {s : Set P} {k : Set G}
    (hs : IsOpen s) (hk : IsCompact k) (hgs : ‚àÄ p, ‚àÄ x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0)
    (hf : LocallyIntegrable f Œº) (hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)) (q‚ÇÄ : P √ó G)
    (hq‚ÇÄ : q‚ÇÄ.1 ‚àà s) :
    HasFDerivAt (fun q : P √ó G => (f ‚ãÜ[L, Œº] g q.1) q.2)
      ((f ‚ãÜ[L.precompR (P √ó G), Œº] fun x : G => fderiv ùïú (‚Üøg) (q‚ÇÄ.1, x)) q‚ÇÄ.2) q‚ÇÄ ",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s := Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C := ht.subset_closedBall_lt 0 0
    refine ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => ?_‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), ?_, ?_‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine (HasCompactSupport.convolutionExists_right L ?_ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº :=
    hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, ?_‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    filter_upwards with a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    filter_upwards with a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, _root_.id, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß Bounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_open (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_bounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s
      ¬∑ exact Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (thickening_mo"
Mathlib/Data/Nat/Factorization/Basic.lean,Nat.factors_count_eq,factors_count_eq,8e91a9b411b4073ac3256f6caebb2b6107088e61,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  by_cases pp : p.Prime; swap
  ¬∑ rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization, coe_mk, pp, if_true]
  rw [‚Üê PartENat.natCast_inj, padicValNat_def' pp.ne_one hn0,
    UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors pp hn0.ne']
  simp [factors_eq]","error:  unknown identifier 'UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.7120
case pos
a b m n‚úù p‚úù n p : ‚Ñï
hn0 : n > 0
pp : Prime p
‚ä¢ ‚Üë(count p n.factors) = multiplicity p n",theorem factors_count_eq {n p : ‚Ñï} : n.factors.count p = n.factorization p ,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization_def _ pp]
  apply _root_.le_antisymm
  ¬∑ rw [le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm
  ¬∑ rw [‚Üê Nat.lt_add_one_iff, lt_iff_not_ge, ge_iff_le,
      le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this",":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  by_cases pp : p.Prime; swap
  ¬∑ rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization, coe_mk, pp, if_true]
  rw [‚Üê PartENat.natCast_inj, padicValNat_def' pp.ne_one hn0,
    UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors pp hn0.ne']"
Mathlib/RingTheory/Localization/Basic.lean,Localization.neg_mk,neg_mk,e8b31359b48045c7bc8570e6e21659333f48f568,:= OreLocalization.neg_def _ _,"warning:  @map_units' does not have a doc string
warning:  @surj' does not have a doc string
warning:  @exists_of_eq does not have a doc string
error:  type mismatch
  OreLocalization.neg_def ?m.471113 ?m.471114
has type
  -(?m.471113 /‚Çí ?m.471114) = -?m.471113 /‚Çí ?m.471114 : Prop
but is expected to have type
  -mk a b = mk (-a) b : Prop
error:  stuck at solving universe constraint
  u_1 =?= max ?u.471104 ?u.471105
while trying to unify
  @Eq.{max (?u.471105 + 1) (?u.471104 + 1)} : {Œ± : Type (max ?u.471105 ?u.471104)} ‚Üí Œ± ‚Üí Œ± ‚Üí Prop
with
  @Eq : {Œ± : Type u_1} ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",theorem neg_mk (a b) : -(mk a b : Localization M) = mk (-a) b ,":= by
  show Localization.neg (mk a b) = mk (-a) b
  rw [Localization.neg_def]
  apply liftOn_mk",:= OreLocalization.neg_def _ _
Mathlib/Order/Filter/Lift.lean,Filter.HasBasis.mem_lift_iff,HasBasis.mem_lift_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine (mem_biInf_of_directed ?_ ‚ü®univ, univ_sets _‚ü©).trans ?_
  ¬∑ intro t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ
    exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm <| inter_subset_left _ _, gm <| inter_subset_right _ _‚ü©
  ¬∑ simp only [‚Üê (hg _).mem_iff]
    exact hf.exists_iff fun t‚ÇÅ t‚ÇÇ ht H => gm ht H","error:  function expected at
  inter_subset_left ?m.2034
term has type
  ?m.2033 ‚àà ?m.2031
error:  function expected at
  inter_subset_right ?m.2080
term has type
  ?m.2079 ‚àà ?m.2078","theorem HasBasis.mem_lift_iff {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {f : Filter Œ±}
    (hf : f.HasBasis p s) {Œ≤ : Œπ ‚Üí Type*} {pg : ‚àÄ i, Œ≤ i ‚Üí Prop} {sg : ‚àÄ i, Œ≤ i ‚Üí Set Œ≥}
    {g : Set Œ± ‚Üí Filter Œ≥} (hg : ‚àÄ i, (g <| s i).HasBasis (pg i) (sg i)) (gm : Monotone g)
    {s : Set Œ≥} : s ‚àà f.lift g ‚Üî ‚àÉ i, p i ‚àß ‚àÉ x, pg i x ‚àß sg i x ‚äÜ s ",":= by
  refine (mem_biInf_of_directed ?_ ‚ü®univ, univ_sets _‚ü©).trans ?_
  ¬∑ intro t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ
    exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm inter_subset_left, gm inter_subset_right‚ü©
  ¬∑ simp only [‚Üê (hg _).mem_iff]
    exact hf.exists_iff fun t‚ÇÅ t‚ÇÇ ht H => gm ht H",":= by
  refine (mem_biInf_of_directed ?_ ‚ü®univ, univ_sets _‚ü©).trans ?_
  ¬∑ intro t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ
    exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm <| inter_subset_left, gm <| inter_subset_right‚ü©
  ¬∑ simp only [‚Üê (hg _).mem_iff]
    exact hf.exists_iff fun t‚ÇÅ t‚ÇÇ ht H => gm ht H"
Mathlib/NumberTheory/NumberField/CanonicalEmbedding/Basic.lean,NumberField.mixedEmbedding.commMap_canonical_eq_mixed,commMap_canonical_eq_mixed,45c652ea0d1ef0a45000968c46b39861e6e4f2a2,":= by
  simp only [canonicalEmbedding, commMap, LinearMap.coe_mk, AddHom.coe_mk, Pi.ringHom_apply,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq]
  exact rfl","error:  type mismatch
  rfl
has type
  ?m.110243 = ?m.110243 : Prop
but is expected to have type
  (fun w ‚Ü¶ ((‚Üëw).embedding x).re) = (Pi.ringHom fun w ‚Ü¶ embedding_of_isReal ‚ãØ) x ‚àß
    (fun w ‚Ü¶ (‚Üëw).embedding x) = (Pi.ringHom fun w ‚Ü¶ (‚Üëw).embedding) x : Prop","theorem commMap_canonical_eq_mixed (x : K) :
    commMap K (canonicalEmbedding K x) = mixedEmbedding K x ",":= by
  simp only [canonicalEmbedding, commMap, LinearMap.coe_mk, AddHom.coe_mk, Pi.ringHom_apply,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq]
  exact ‚ü®rfl, rfl‚ü©",":= by
  simp only [canonicalEmbedding, commMap, AddHom.coe_mk, Pi.ringHom_apply,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq]
  exact rfl"
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ F ‚ÜíL[‚Ñù] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x ‚Ü¶ c + x) x) c) ^ 2 ‚Ä¢
      ‚Üë{ toLinearEquiv := (reflection (Submodule.span ‚Ñù {(fun x ‚Ü¶ c + x) x - c})·óÆ).toLinearEquiv, continuous_toFun := ‚ãØ,
          continuous_invFun := ‚ãØ })
    ((fun x ‚Ü¶ c + x) x)","theorem hasFDerivAt_inversion (hx : x ‚â† c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 ‚Ä¢ (reflection (‚Ñù ‚àô (x - c))·óÆ : F ‚ÜíL[‚Ñù] F)) x ",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (?_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]"
Mathlib/NumberTheory/SumTwoSquares.lean,ZMod.isSquare_neg_one_iff',ZMod.isSquare_neg_one_iff',d664a4757e1d5d6999ae3ca588b989e1039faee2,":= by
  have help : ‚àÄ a b : ZMod 4, a ‚â† 3 ‚Üí b ‚â† 3 ‚Üí a * b ‚â† 3 := by decide
  rw [ZMod.isSquare_neg_one_iff hn]
  refine' ‚ü®_, fun H q _ => H‚ü©
  intro H
  refine' @induction_on_primes _ _ _ (fun p q hp hq hpq => _)
  ¬∑ exact fun _ => by norm_num
  ¬∑ exact fun _ => by norm_num
  ¬∑ replace hp := H hp (dvd_of_mul_right_dvd hpq)
    replace hq := hq (dvd_of_mul_left_dvd hpq)
    rw [show 3 = 3 % 4 by norm_num, Ne.def, ‚Üê ZMod.nat_cast_eq_nat_cast_iff'] at hp hq ‚ä¢
    rw [Nat.cast_mul]
    exact help p q hp hq","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29098 ‚Üí ?m.29098 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.29100
case refine'_3
n : ‚Ñï
hn : Squarefree n
help : ‚àÄ (a b : ZMod 4), a ‚â† 3 ‚Üí b ‚â† 3 ‚Üí a * b ‚â† 3
H : ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q ‚à£ n ‚Üí q % 4 ‚â† 3
p q : ‚Ñï
hpq : p * q ‚à£ n
hp : p % 4 ‚â† 3 % 4
hq : q % 4 ‚â† 3 % 4
‚ä¢ p * q % 4 ‚â† 3 % 4","theorem ZMod.isSquare_neg_one_iff' {n : ‚Ñï} (hn : Squarefree n) :
    IsSquare (-1 : ZMod n) ‚Üî ‚àÄ {q : ‚Ñï}, q ‚à£ n ‚Üí q % 4 ‚â† 3 ",":= by
  have help : ‚àÄ a b : ZMod 4, a ‚â† 3 ‚Üí b ‚â† 3 ‚Üí a * b ‚â† 3 := by decide
  rw [ZMod.isSquare_neg_one_iff hn]
  refine ‚ü®?_, fun H q _ => H‚ü©
  intro H
  refine @induction_on_primes _ ?_ ?_ (fun p q hp hq hpq => ?_)
  ¬∑ exact fun _ => by norm_num
  ¬∑ exact fun _ => by norm_num
  ¬∑ replace hp := H hp (dvd_of_mul_right_dvd hpq)
    replace hq := hq (dvd_of_mul_left_dvd hpq)
    rw [show 3 = 3 % 4 by norm_num, Ne, ‚Üê ZMod.natCast_eq_natCast_iff'] at hp hq ‚ä¢
    rw [Nat.cast_mul]
    exact help p q hp hq",":= by
  have help : ‚àÄ a b : ZMod 4, a ‚â† 3 ‚Üí b ‚â† 3 ‚Üí a * b ‚â† 3 := by decide
  rw [ZMod.isSquare_neg_one_iff hn]
  refine ‚ü®_, fun H q _ => H‚ü©
  intro H
  refine @induction_on_primes _ _ _ (fun p q hp hq hpq => ?_)
  ¬∑ exact fun _ => by norm_num
  ¬∑ exact fun _ => by norm_num
  ¬∑ replace hp := H hp (dvd_of_mul_right_dvd hpq)
    replace hq := hq (dvd_of_mul_left_dvd hpq)
    rw [show 3 = 3 % 4 by norm_num, Ne, ‚Üê ZMod.natCast_eq_natCast_iff'] at hp hq ‚ä¢
    rw [Nat.cast_mul]
    exact help p q hp hq"
Mathlib/Analysis/InnerProductSpace/PiL2.lean,Orthonormal.exists_orthonormalBasis_extension,Orthonormal.exists_orthonormalBasis_extension,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.setFinite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_,? _?, _‚ü©
  ¬∑ simpa [u] using hu‚ÇÄ_max
  ¬∑ simpa [u] using hu‚ÇÄs
  ¬∑ simp","error:  don't know how to synthesize placeholder for argument 'right'
context:
Œπ : Type u_1
Œπ' : Type u_2
ùïú : Type u_3
inst‚úù¬π‚Å∞ : _root_.RCLike ùïú
E : Type u_4
inst‚úù‚Åπ : NormedAddCommGroup E
inst‚úù‚Å∏ : InnerProductSpace ùïú E
E' : Type u_5
inst‚úù‚Å∑ : NormedAddCommGroup E'
inst‚úù‚Å∂ : InnerProductSpace ùïú E'
F : Type u_6
inst‚úù‚Åµ : NormedAddCommGroup F
inst‚úù‚Å¥ : InnerProductSpace ‚Ñù F
F' : Type u_7
inst‚úù¬≥ : NormedAddCommGroup F'
inst‚úù¬≤ : InnerProductSpace ‚Ñù F'
inst‚úù¬π : Fintype Œπ
v : Set E
A : Œπ ‚Üí Submodule ùïú E
inst‚úù : FiniteDimensional ùïú E
hv : Orthonormal ùïú Subtype.val
u‚ÇÄ : Set E
hu‚ÇÄs : u‚ÇÄ ‚äá v
hu‚ÇÄ : Orthonormal ùïú Subtype.val
hu‚ÇÄ_max : (span ùïú u‚ÇÄ)·óÆ = ‚ä•
hu‚ÇÄ_finite : u‚ÇÄ.Finite
u : Finset E := hu‚ÇÄ_finite.toFinset
fu : { x // x ‚àà u } ‚âÉ ‚Üëu‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
hu : Orthonormal ùïú Subtype.val
‚ä¢ ‚áë(OrthonormalBasis.mkOfOrthogonalEqBot hu ?m.586650) = Subtype.val
error:  unsolved goals
case intro.intro.intro
Œπ : Type u_1
Œπ' : Type u_2
ùïú : Type u_3
inst‚úù¬π‚Å∞ : _root_.RCLike ùïú
E : Type u_4
inst‚úù‚Åπ : NormedAddCommGroup E
inst‚úù‚Å∏ : InnerProductSpace ùïú E
E' : Type u_5
inst‚úù‚Å∑ : NormedAddCommGroup E'
inst‚úù‚Å∂ : InnerProductSpace ùïú E'
F : Type u_6
inst‚úù‚Åµ : NormedAddCommGroup F
inst‚úù‚Å¥ : InnerProductSpace ‚Ñù F
F' : Type u_7
inst‚úù¬≥ : NormedAddCommGroup F'
inst‚úù¬≤ : InnerProductSpace ‚Ñù F'
inst‚úù¬π : Fintype Œπ
v : Set E
A : Œπ ‚Üí Submodule ùïú E
inst‚úù : FiniteDimensional ùïú E
hv : Orthonormal ùïú Subtype.val
u‚ÇÄ : Set E
hu‚ÇÄs : u‚ÇÄ ‚äá v
hu‚ÇÄ : Orthonormal ùïú Subtype.val
hu‚ÇÄ_max : (span ùïú u‚ÇÄ)·óÆ = ‚ä•
hu‚ÇÄ_finite : u‚ÇÄ.Finite
u : Finset E := hu‚ÇÄ_finite.toFinset
fu : { x // x ‚àà u } ‚âÉ ‚Üëu‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
hu : Orthonormal ùïú Subtype.val
‚ä¢ ‚àÉ u b, v ‚äÜ ‚Üëu ‚àß ‚áëb = Subtype.val","theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal ùïú ((‚Üë) : v ‚Üí E)) :
    ‚àÉ (u : Finset E) (b : OrthonormalBasis u ùïú E), v ‚äÜ u ‚àß ‚áëb = ((‚Üë) : u ‚Üí E) ",":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.setFinite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_‚ü©
  ¬∑ simpa [u] using hu‚ÇÄ_max
  ¬∑ simpa [u] using hu‚ÇÄs
  ¬∑ simp",":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.setFinite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_‚ü©
  ¬∑ simpa [u] using hu‚ÇÄ_max
  ¬∑ simpa [u] using hu‚ÇÄs
  ¬∑ simp"
Mathlib/Topology/MetricSpace/Polish.lean,IsClosed.isClopenable,_root_.IsClosed.isClopenable,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫
  ¬∑ simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    convert And.intro (isOpen_univ (Œ± := s)) (isOpen_empty (Œ± := (s·∂ú : Set Œ±)))
      <;> ext ‚ü®x, hx‚ü© <;> simpa using hx","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : TopologicalSpace Œ±
inst‚úù : PolishSpace Œ±
s : Set Œ±
hs : IsClosed s
this‚úù : PolishSpace ‚Üës
t : Set Œ± := s·∂ú
this : PolishSpace ‚Üët
f : ‚Üës ‚äï ‚Üët ‚âÉ Œ± := sorryAx (‚Üës ‚äï ‚Üët ‚âÉ Œ±) true
hle : coinduced (‚áëf) instTopologicalSpaceSum ‚â§ inst‚úù¬π
‚ä¢ IsClopenable s","theorem _root_.IsClosed.isClopenable [TopologicalSpace Œ±] [PolishSpace Œ±] {s : Set Œ±}
    (hs : IsClosed s) : IsClopenable s ",":= by
  classical
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫ := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    simp [f, preimage_preimage]",":= by
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫
  ¬∑ simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    convert And.intro (isOpen_univ (Œ± := s)) (isOpen_empty (Œ± := (s·∂ú : Set Œ±)))
      <;> ext ‚ü®x, hx‚ü© <;> simpa using hx"
Mathlib/GroupTheory/MonoidLocalization.lean,Localization.mk_one,mk_one,f7d2420463796edab0b4f526fd8c96d19b328dd9,:= OreLocalization.one_def,"error:  type mismatch
  OreLocalization.one_def
has type
  1 = 1 /‚Çí 1 : Prop
but is expected to have type
  mk 1 1 = 1 : Prop",theorem mk_one : mk 1 (1 : S) = 1 ,":=
  show mk _ _ = .one S by rw [Localization.one]; rfl",:= OreLocalization.one_def
Mathlib/NumberTheory/EllipticDivisibilitySequence.lean,normEDS_two,normEDS_two,9abf5def655e0d44fd16e9b8b243b67025e7776f,":= by
  erw [normEDS_ofNat, normEDS'_two]","error:  unknown identifier 'normEDS'_two'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.113699
R : Type u
S : Type v
inst‚úù¬π : CommRing R
inst‚úù : CommRing S
W : ‚Ñ§ ‚Üí R
f : R ‚Üí+* S
b c d : R
‚ä¢ (preNormEDS' (b ^ 4) c d 2 * if Even 2 then b else 1) = b",lemma normEDS_two : normEDS b c d 2 = b ,":= by
  erw [normEDS_ofNat, preNormEDS'_two, one_mul, if_pos even_two]",":= by
  erw [normEDS_ofNat, normEDS_two]"
Mathlib/LinearAlgebra/BilinearForm/Properties.lean,LinearMap.BilinForm.dualBasis_dualBasis,dualBasis_dualBasis,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ‚Ü¶ ?_))
  rw [toLin_apply, apply_dualBasis_left, toLin_apply, ‚Üê B.flip_apply (R‚ÇÇ := K),
    apply_dualBasis_left]
  simp_rw [@eq_comm _ i j]","error:  unknown identifier 'toLin_apply'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.470137
case a
R : Type u_1
M : Type u_2
inst‚úù¬π‚Åπ : CommSemiring R
inst‚úù¬π‚Å∏ : AddCommMonoid M
inst‚úù¬π‚Å∑ : Module R M
R‚ÇÅ : Type u_3
M‚ÇÅ : Type u_4
inst‚úù¬π‚Å∂ : CommRing R‚ÇÅ
inst‚úù¬π‚Åµ : AddCommGroup M‚ÇÅ
inst‚úù¬π‚Å¥ : Module R‚ÇÅ M‚ÇÅ
V : Type u_5
K : Type u_6
inst‚úù¬π¬≥ : Field K
inst‚úù¬π¬≤ : AddCommGroup V
inst‚úù¬π¬π : Module K V
M'‚úù : Type u_7
M'' : Type u_8
inst‚úù¬π‚Å∞ : AddCommMonoid M'‚úù
inst‚úù‚Åπ : AddCommMonoid M''
inst‚úù‚Å∏ : Module R M'‚úù
inst‚úù‚Å∑ : Module R M''
B‚úù : BilinForm R M
B‚ÇÅ : BilinForm R‚ÇÅ M‚ÇÅ
M' : Type u_9
inst‚úù‚Å∂ : AddCommMonoid M'
inst‚úù‚Åµ : Module R M'
inst‚úù‚Å¥ : FiniteDimensional K V
Œπ‚úù : Type u_10
inst‚úù¬≥ : DecidableEq Œπ‚úù
inst‚úù¬≤ : Finite Œπ‚úù
B : BilinForm K V
hB : B.Nondegenerate
Œπ : Type u_11
inst‚úù¬π : Finite Œπ
inst‚úù : DecidableEq Œπ
b : Basis Œπ K V
i j : Œπ
‚ä¢ (B ((B.dualBasis hB (B.flip.dualBasis ‚ãØ b)) i)) ((B.flip.dualBasis ‚ãØ b) j) = (B (b i)) ((B.flip.dualBasis ‚ãØ b) j)","lemma dualBasis_dualBasis_flip (B : BilinForm K V) (hB : B.Nondegenerate) {Œπ}
    [Finite Œπ] [DecidableEq Œπ] (b : Basis Œπ K V) :
    B.dualBasis hB (B.flip.dualBasis hB.flip b) = b ",":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ‚Ü¶ ?_))
  simp_rw [apply_dualBasis_left, ‚Üê B.flip_apply, apply_dualBasis_left, @eq_comm _ i j]",":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ‚Ü¶ ?_))
  rw [toLin_apply, apply_dualBasis_left, toLin_apply, ‚Üê B.flip_apply (R‚ÇÇ := K),
    apply_dualBasis_left]"
Mathlib/SetTheory/Ordinal/NaturalOps.lean,Ordinal.add_le_nadd,add_le_nadd,25e538f3a737a71314ac143929711e67d0b14d73,":= by
  induction b with
  | H‚ÇÅ => simp
  | H‚ÇÇ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | H‚ÇÉ c hc H =>
    simp_rw [‚Üê IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)","warning:  Ordinal.nadd does not have a doc string
warning:  Ordinal.nmul does not have a doc string
error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
a b c : Ordinal.{u}
‚ä¢ a + b ‚â§ a ‚ôØ b",theorem add_le_nadd : a + b ‚â§ a ‚ôØ b ,":= by
  induction b using limitRecOn with
  | H‚ÇÅ => simp
  | H‚ÇÇ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | H‚ÇÉ c hc H =>
    simp_rw [‚Üê IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)",":= by
  induction b using Polynomial.induction_on with
  | H‚ÇÅ => simp
  | H‚ÇÇ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | H‚ÇÉ c hc H =>
    simp_rw [‚Üê IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)"
Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean,TopCat.range_pullback_map,range_pullback_map,c0d29a577c3ac349c365bc3efc469237662049c4,":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range, ‚Üê comp_apply, limit.lift_œÄ,
      PullbackCone.mk_pt, PullbackCone.mk_œÄ_app]
    simp only [comp_apply, exists_apply_eq_apply, and_self]
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    simp only [‚Üê comp_apply, eq‚ÇÅ, eq‚ÇÇ]
    simp only [comp_apply, hx‚ÇÅ, hx‚ÇÇ]
    simp only [‚Üê comp_apply, pullback.condition]
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  sorry","error:  simp made no progress
error:  simp made no progress","theorem range_pullback_map {W X Y Z S T : TopCat} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) (g‚ÇÅ : Y ‚ü∂ T)
    (g‚ÇÇ : Z ‚ü∂ T) (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T) [H‚ÇÉ : Mono i‚ÇÉ] (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ)
    (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) :
    Set.range (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) =
      (pullback.fst : pullback g‚ÇÅ g‚ÇÇ ‚ü∂ _) ‚Åª¬π' Set.range i‚ÇÅ ‚à©
        (pullback.snd : pullback g‚ÇÅ g‚ÇÇ ‚ü∂ _) ‚Åª¬π' Set.range i‚ÇÇ ",":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range]
    erw [‚Üê comp_apply, ‚Üê comp_apply] 
    simp only [limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app, comp_apply]
    exact ‚ü®exists_apply_eq_apply _ _, exists_apply_eq_apply _ _‚ü©
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    erw [‚Üê comp_apply, eq‚ÇÅ, ‚Üê comp_apply, eq‚ÇÇ, 
      comp_apply, comp_apply, hx‚ÇÅ, hx‚ÇÇ, ‚Üê comp_apply, pullback.condition]
    rfl 
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  change (forget TopCat).map _ _ = _
  apply Concrete.limit_ext
  rintro (_ | _ | _) <;>
  erw [‚Üê comp_apply, ‚Üê comp_apply] 
  simp only [Category.assoc, limit.lift_œÄ, PullbackCone.mk_œÄ_app_one]
  ¬∑ simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [pullbackFst_apply, hx‚ÇÅ]
    rw [‚Üê limit.w _ WalkingCospan.Hom.inl, cospan_map_inl, comp_apply (g := g‚ÇÅ)]
    rfl 
  ¬∑ simp only [cospan_left, limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,
      pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [hx‚ÇÅ] 
    rfl 
  ¬∑ simp only [cospan_right, limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,
      pullbackIsoProdSubtype_inv_snd_assoc, comp_apply]
    erw [hx‚ÇÇ] 
    rfl ",":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range, ‚Üê comp_apply, limit.lift_œÄ,
      PullbackCone.mk_pt, PullbackCone.mk_œÄ_app]
    simp only [comp_apply, exists_apply_eq_apply, and_self]
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    simp only [‚Üê comp_apply, eq‚ÇÅ, eq‚ÇÇ]
    simp only [comp_apply, condition]
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  sorry"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.mul_measure_le_of_subset_lt_limRatioMeas,mul_measure_le_of_subset_lt_limRatioMeas,8c8242bc14c6eb4639762e675985d5599fb35a5c,":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº t·∂ú = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t);
  exact
    calc
      (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
      _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := (measure_union_le _ _)
      _ ‚â§ œÅ (s ‚à© t) + (q ‚Ä¢ Œº) t·∂ú := by gcongr; apply inter_subset_right
      _ = œÅ (s ‚à© t) := by simp [A]
      _ ‚â§ œÅ s := by gcongr; apply inter_subset_left
  refine' v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ _
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le",error:  unexpected token ';'; expected 'by' or 'from',"theorem mul_measure_le_of_subset_lt_limRatioMeas {q : ‚Ñù‚â•0} {s : Set Œ±}
    (h : s ‚äÜ {x | (q : ‚Ñù‚â•0‚àû) < v.limRatioMeas hœÅ x}) : (q : ‚Ñù‚â•0‚àû) * Œº s ‚â§ œÅ s ",":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº t·∂ú = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t) by calc
    (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
    _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := measure_union_le _ _
    _ ‚â§ œÅ (s ‚à© t) + (q ‚Ä¢ Œº) t·∂ú := by gcongr; apply inter_subset_right
    _ = œÅ (s ‚à© t) := by simp [A]
    _ ‚â§ œÅ s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ ?_
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le",":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº t·∂ú = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t) by
    calc
      (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
      _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := (measure_union_le _ _)
      _ ‚â§ œÅ (s ‚à© t) + (q ‚Ä¢ Œº) t·∂ú := by gcongr; apply inter_subset_right
      _ = œÅ (s ‚à© t) := by simp [A]
      _ ‚â§ œÅ s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) ?_ ?_
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le"
Mathlib/MeasureTheory/Measure/Sub.lean,MeasureTheory.Measure.sub_apply,sub_apply,5c9c13df4643f68468a0f50fc217a3216ae6f8cc,":= by
  let measure_sub : Measure Œ± := MeasureTheory.Measure.ofMeasurable
    (fun (t : Set Œ±) (_ : MeasurableSet t) => Œº t - ŒΩ t) (by simp)
    (by
      intro g h_meas h_disj; simp only; rw [ENNReal.tsum_sub]
      repeat' rw [‚Üê MeasureTheory.measure_iUnion h_disj h_meas]
      exacts [MeasureTheory.measure_ne_top _ _, fun i => h‚ÇÇ _ (h_meas _)])
  have h_measure_sub_add : ŒΩ + measure_sub = Œº := by
    ext1 t h_t_measurable_set
    simp only [Pi.add_apply, coe_add]
    rw [MeasureTheory.Measure.ofMeasurable_apply _ h_t_measurable_set, add_comm,
      tsub_add_cancel_of_le (h‚ÇÇ t h_t_measurable_set)]
  have h_measure_sub_eq : Œº - ŒΩ = measure_sub := by
    rw [MeasureTheory.Measure.sub_def]
    apply le_antisymm
    ¬∑ apply sInf_le
      simp [le_refl, add_comm, h_measure_sub_add]
    apply le_sInf
    intro d h_d
    rw [‚Üê h_measure_sub_add, mem_setOf_eq, add_comm d] at h_d
    apply Measure.le_of_add_le_add_left h_d
  rw [h_measure_sub_eq]
  apply Measure.ofMeasurable_apply _ h‚ÇÅ","error:  application type mismatch
  h‚ÇÇ ?m.5237 (h_meas ?m.5238)
argument
  h_meas ?m.5238
has type
  MeasurableSet (g ?m.5238) : Prop
but is expected to have type
  NNReal : Type
error:  application type mismatch
  h‚ÇÇ t h_t_measurable_set
argument
  h_t_measurable_set
has type
  MeasurableSet t : Prop
but is expected to have type
  NNReal : Type","theorem sub_apply [IsFiniteMeasure ŒΩ] (h‚ÇÅ : MeasurableSet s) (h‚ÇÇ : ŒΩ ‚â§ Œº) :
    (Œº - ŒΩ) s = Œº s - ŒΩ s ",":= by
  let measure_sub : Measure Œ± := MeasureTheory.Measure.ofMeasurable
    (fun (t : Set Œ±) (_ : MeasurableSet t) => Œº t - ŒΩ t) (by simp)
    (fun g h_meas h_disj ‚Ü¶ by
      simp only [measure_iUnion h_disj h_meas]
      rw [ENNReal.tsum_sub _ (h‚ÇÇ <| g ¬∑)]
      rw [‚Üê measure_iUnion h_disj h_meas]
      apply measure_ne_top)
  have h_measure_sub_add : ŒΩ + measure_sub = Œº := by
    ext1 t h_t_measurable_set
    simp only [Pi.add_apply, coe_add]
    rw [MeasureTheory.Measure.ofMeasurable_apply _ h_t_measurable_set, add_comm,
      tsub_add_cancel_of_le (h‚ÇÇ t)]
  have h_measure_sub_eq : Œº - ŒΩ = measure_sub := by
    rw [MeasureTheory.Measure.sub_def]
    apply le_antisymm
    ¬∑ apply sInf_le
      simp [le_refl, add_comm, h_measure_sub_add]
    apply le_sInf
    intro d h_d
    rw [‚Üê h_measure_sub_add, mem_setOf_eq, add_comm d] at h_d
    apply Measure.le_of_add_le_add_left h_d
  rw [h_measure_sub_eq]
  apply Measure.ofMeasurable_apply _ h‚ÇÅ",":= by
  let measure_sub : Measure Œ± := MeasureTheory.Measure.ofMeasurable
    (fun (t : Set Œ±) (_ : MeasurableSet t) => Œº t - ŒΩ t) (by simp)
    (by
      intro g h_meas h_disj; simp only; rw [ENNReal.tsum_sub]
      repeat' rw [‚Üê MeasureTheory.measure_iUnion h_disj h_meas]
      exacts [MeasureTheory.measure_ne_top _ _, fun i => h‚ÇÇ _ (h_meas _)])
  have h_measure_sub_add : ŒΩ + measure_sub = Œº := by
    ext1 t h_t_measurable_set
    simp only [Pi.add_apply, coe_add]
    rw [MeasureTheory.Measure.ofMeasurable_apply _ h_t_measurable_set, add_comm,
      tsub_add_cancel_of_le (h‚ÇÇ t h_t_measurable_set)]
  have h_measure_sub_eq : Œº - ŒΩ = measure_sub := by
    rw [MeasureTheory.Measure.sub_def]
    apply le_antisymm
    ¬∑ apply sInf_le
      simp [le_refl, add_comm, h_measure_sub_add]
    apply le_sInf
    intro d h_d
    rw [‚Üê h_measure_sub_add, mem_setOf_eq, add_comm d] at h_d
    apply Measure.le_of_add_le_add_left h_d
  rw [h_measure_sub_eq]
  apply Measure.ofMeasurable_apply _ h‚ÇÅ"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,d61c95e1653dffe3f92c8927a905826929f50bce,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogon"
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Œ¥_comp_œÉ_of_gt,Œ¥_comp_œÉ_of_gt,1b5c1d10be0ae07fd997c78515f4ed4561b92535,":= by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_below _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_below _ _ (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_below _ _ hjk, Fin.succAbove_below, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_above _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_above _ _ hjk, Fin.succAbove_below, Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_above _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_above _ _ hjk, Fin.predAbove_above _ _ (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_above, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]","error:  unknown constant 'Fin.succAbove_below'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.77527
case a.h.h.inl
n : ‚Ñï
i : Fin (n + 2)
j : Fin (n + 1)
H : j.castSucc < i
k : Fin ([n + 1].len + 1)
hik : k ‚â§ i
‚ä¢ j.castSucc.predAbove (i.succ.succAbove k) = i.succAbove (j.predAbove k)
error:  unknown constant 'Fin.succAbove_above'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.77529
case a.h.h.inr
n : ‚Ñï
i : Fin (n + 2)
j : Fin (n + 1)
H : j.castSucc < i
k : Fin ([n + 1].len + 1)
hik : i < k
‚ä¢ j.castSucc.predAbove (i.succ.succAbove k) = i.succAbove (j.predAbove k)","theorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Œ¥ i.succ ‚â´ œÉ (Fin.castSucc j) = œÉ j ‚â´ Œ¥ i ",":= by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]",":= by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_below _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_below _ _ (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_below _ _ hjk, Fin.succAbove_below, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_above _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_above _ _ hjk, Fin.succAbove_below, Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_above _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove _ _ hjk, Fin.predAbove_above _ _ (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_above, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]"
Mathlib/Probability/Martingale/Upcrossing.lean,MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part,Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part,82ddb54f6cb64f727e412a60ecaa99a9dafaec2a,":= by
  by_cases hab : a < b
  ¬∑ simp_rw [upcrossings]
    have : ‚àÄ N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº = ENNReal.ofReal (‚à´ œâ, (f N œâ - a)‚Å∫ ‚àÇŒº) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      ¬∑ exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      ¬∑ exact eventually_of_forall fun œâ => LatticeOrderedGroup.pos_nonneg _
    rw [lintegral_iSup']
    ¬∑ simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          ‚à´‚Åª œâ, upcrossingsBefore a b f N œâ ‚àÇŒº = ‚à´‚Åª œâ, ‚Üë(upcrossingsBefore a b f N œâ : ‚Ñù‚â•0) ‚àÇŒº),
        lintegral_coe_eq_integral, ‚Üê ENNReal.ofReal_mul (sub_pos.2 hab).le]
      ¬∑ simp_rw [NNReal.coe_nat_cast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Œ± := ‚Ñù‚â•0‚àû) _ N)
      ¬∑ simp only [NNReal.coe_nat_cast, hf.adapted.integrable_upcrossingsBefore hab]
    ¬∑ exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    ¬∑ refine' eventually_of_forall fun œâ N M hNM => _
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM œâ
  ¬∑ rw [not_lt, ‚Üê sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]
    exact zero_le _","error:  unknown identifier 'LatticeOrderedGroup.pos_nonneg'
warning:  `NNReal.coe_nat_cast` has been deprecated, use `NNReal.coe_natCast` instead
warning:  `NNReal.coe_nat_cast` has been deprecated, use `NNReal.coe_natCast` instead","theorem Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part [IsFiniteMeasure Œº] (a b : ‚Ñù)
    (hf : Submartingale f ‚Ñ± Œº) : ENNReal.ofReal (b - a) * ‚à´‚Åª œâ, upcrossings a b f œâ ‚àÇŒº ‚â§
      ‚®Ü N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº ",":= by
  by_cases hab : a < b
  ¬∑ simp_rw [upcrossings]
    have : ‚àÄ N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº = ENNReal.ofReal (‚à´ œâ, (f N œâ - a)‚Å∫ ‚àÇŒº) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      ¬∑ exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      ¬∑ exact eventually_of_forall fun œâ => posPart_nonneg _
    rw [lintegral_iSup']
    ¬∑ simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          ‚à´‚Åª œâ, upcrossingsBefore a b f N œâ ‚àÇŒº = ‚à´‚Åª œâ, ‚Üë(upcrossingsBefore a b f N œâ : ‚Ñù‚â•0) ‚àÇŒº),
        lintegral_coe_eq_integral, ‚Üê ENNReal.ofReal_mul (sub_pos.2 hab).le]
      ¬∑ simp_rw [NNReal.coe_natCast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Œ± := ‚Ñù‚â•0‚àû) _ N)
      ¬∑ simp only [NNReal.coe_natCast, hf.adapted.integrable_upcrossingsBefore hab]
    ¬∑ exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    ¬∑ filter_upwards with œâ N M hNM
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM œâ
  ¬∑ rw [not_lt, ‚Üê sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]
    exact zero_le _",":= by
  by_cases hab : a < b
  ¬∑ simp_rw [upcrossings]
    have : ‚àÄ N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº = ENNReal.ofReal (‚à´ œâ, (f N œâ - a)‚Å∫ ‚àÇŒº) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      ¬∑ exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      ¬∑ exact eventually_of_forall fun œâ => LatticeOrderedGroup.pos_nonneg _
    rw [lintegral_iSup']
    ¬∑ simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          ‚à´‚Åª œâ, upcrossingsBefore a b f N œâ ‚àÇŒº = ‚à´‚Åª œâ, ‚Üë(upcrossingsBefore a b f N œâ : ‚Ñù‚â•0) ‚àÇŒº),
        lintegral_coe_eq_integral, ‚Üê ENNReal.ofReal_mul (sub_pos.2 hab).le]
      ¬∑ simp_rw [NNReal.coe_natCast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Œ± := ‚Ñù‚â•0‚àû) _ N)
      ¬∑ simp only [NNReal.coe_natCast, hf.adapted.integrable_upcrossingsBefore hab]
    ¬∑ exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    ¬∑ refine eventually_of_forall fun œâ N M hNM => ?_
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM œâ
  ¬∑ rw [not_lt, ‚Üê sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]
    exact zero_le _"
Mathlib/Data/Nat/Choose/Central.lean,Nat.four_pow_le_two_mul_self_mul_centralBinom,four_pow_le_two_mul_self_mul_centralBinom,9f6d33884de569540c527b667d1573e1b97e1347,"  | 0, pr => (Nat.not_lt_zero _ pr).elim
  | 1, _ => by norm_num [centralBinom, choose]
  | 2, _ => by norm_num [centralBinom, choose]
  | 3, _ => by norm_num [centralBinom, choose]
  | n + 4, _ =>
    calc
      4 ^ (n+4) ‚â§ (n+4) * centralBinom (n+4) := (four_pow_lt_mul_centralBinom _ le_add_self).le
      _ ‚â§ 2 * (n+4) * centralBinom (n+4) := by
        rw [mul_assoc]; refine' le_mul_of_pos_left zero_lt_two",error:  unknown identifier 'le_mul_of_pos_left',"theorem four_pow_le_two_mul_self_mul_centralBinom :
    ‚àÄ (n : ‚Ñï) (_ : 0 < n), 4 ^ n ‚â§ 2 * n * centralBinom n
","  | 0, pr => (Nat.not_lt_zero _ pr).elim
  | 1, _ => by norm_num [centralBinom, choose]
  | 2, _ => by norm_num [centralBinom, choose]
  | 3, _ => by norm_num [centralBinom, choose]
  | n + 4, _ =>
    calc
      4 ^ (n+4) ‚â§ (n+4) * centralBinom (n+4) := (four_pow_lt_mul_centralBinom _ le_add_self).le
      _ ‚â§ 2 * (n+4) * centralBinom (n+4) := by
        rw [mul_assoc]; refine Nat.le_mul_of_pos_left _ zero_lt_two",":= by
  | 0, pr => (Nat.not_lt_zero _ pr).elim
  | 1, _ => by norm_num [centralBinom, choose]
  | 2, _ => by norm_num [centralBinom, choose]
  | 3, _ => by norm_num [centralBinom, choose]
  | n + 4, _ =>
    calc
      4 ^ (n+4) ‚â§ (n+4) * centralBinom (n+4) := (four_pow_lt_mul_centralBinom _ le_add_self).le
      _ ‚â§ 2 * (n+4) * centralBinom (n+4) := by
        rw [mul_assoc]; refine le_mul_of_pos_left zero_lt_two"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpi_tfae,effectiveEpi_tfae,62c2d6a1d2ffdbe5bcaa653b84d3602a209e4c8c,":= by
  tfae_have : 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have : 2 ‚Üî 3 := epi_iff_surjective œÄ
  tfae_have : 3 ‚Üí 1 := fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (œÄ : X ‚ü∂ B) :
    TFAE
    [ EffectiveEpi œÄ
    , Epi œÄ
    , Function.Surjective œÄ
    ] ",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish"
Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean,collinear_iff_of_mem,collinear_iff_of_mem,28f34517ea07a4ecc94b3d55041dd0ca1152a2a8,":= by
  simp_rw [collinear_iff_rank_le_one, rank_submodule_le_one_iff', Submodule.le_span_singleton_iff]
  constructor
  ¬∑ rintro ‚ü®v‚ÇÄ, hv‚ü©
    use v‚ÇÄ
    intro p hp
    obtain ‚ü®r, hr‚ü© := hv (p -·µ• p‚ÇÄ) (vsub_mem_vectorSpan k hp h)
    use r
    rw [eq_vadd_iff_vsub_eq]
    exact hr.symm
  ¬∑ rintro ‚ü®v, hp‚ÇÄv‚ü©
    use v
    intro w hw
    have hs : vectorSpan k s ‚â§ k ‚Ä¢ v := by
      rw [vectorSpan_eq_span_vsub_set_right k h, Submodule.span_le, Set.subset_def]
      intro x hx
      rw [SetLike.mem_coe, Submodule.mem_span_singleton]
      rw [Set.mem_image] at hx
      rcases hx with ‚ü®p, hp, rfl‚ü©
      rcases hp‚ÇÄv p hp with ‚ü®r, rfl‚ü©
      use r
      simp
    have hw' := SetLike.le_def.1 hs hw
    rwa [Submodule.mem_span_singleton] at hw'","error:  failed to synthesize
  HSMul (Type u_1) V ?m.202447
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  vectorSpan k s
k : Type u_1
V : Type u_2
P : Type u_3
Œπ : Type u_4
inst‚úù¬≥ : DivisionRing k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
s : Set P
p‚ÇÄ : P
h : p‚ÇÄ ‚àà s
v : V
hp‚ÇÄv : ‚àÄ p ‚àà s, ‚àÉ r, p = r ‚Ä¢ v +·µ• p‚ÇÄ
w : V
hw : w ‚àà vectorSpan k s
‚ä¢ sorryAx (Sort ?u.200967) true","theorem collinear_iff_of_mem {s : Set P} {p‚ÇÄ : P} (h : p‚ÇÄ ‚àà s) :
    Collinear k s ‚Üî ‚àÉ v : V, ‚àÄ p ‚àà s, ‚àÉ r : k, p = r ‚Ä¢ v +·µ• p‚ÇÄ ",":= by
  simp_rw [collinear_iff_rank_le_one, rank_submodule_le_one_iff', Submodule.le_span_singleton_iff]
  constructor
  ¬∑ rintro ‚ü®v‚ÇÄ, hv‚ü©
    use v‚ÇÄ
    intro p hp
    obtain ‚ü®r, hr‚ü© := hv (p -·µ• p‚ÇÄ) (vsub_mem_vectorSpan k hp h)
    use r
    rw [eq_vadd_iff_vsub_eq]
    exact hr.symm
  ¬∑ rintro ‚ü®v, hp‚ÇÄv‚ü©
    use v
    intro w hw
    have hs : vectorSpan k s ‚â§ k ‚àô v := by
      rw [vectorSpan_eq_span_vsub_set_right k h, Submodule.span_le, Set.subset_def]
      intro x hx
      rw [SetLike.mem_coe, Submodule.mem_span_singleton]
      rw [Set.mem_image] at hx
      rcases hx with ‚ü®p, hp, rfl‚ü©
      rcases hp‚ÇÄv p hp with ‚ü®r, rfl‚ü©
      use r
      simp
    have hw' := SetLike.le_def.1 hs hw
    rwa [Submodule.mem_span_singleton] at hw'",":= by
  simp_rw [collinear_iff_rank_le_one, rank_submodule_le_one_iff, Submodule.le_span_singleton_iff]
  constructor
  ¬∑ rintro ‚ü®v‚ÇÄ, hv‚ü©
    use v‚ÇÄ
    intro p hp
    obtain ‚ü®r, hr‚ü© := hv (p -·µ• p‚ÇÄ) (vsub_mem_vectorSpan k hp h)
    use r
    rw [eq_vadd_iff_vsub_eq]
    exact hr.symm
  ¬∑ rintro ‚ü®v, hp‚ÇÄv‚ü©
    use v
    intro w hw
    have hs : vectorSpan k s ‚â§ k ‚Ä¢ v := by
      rw [vectorSpan_eq_span_vsub_set_right k h, Submodule.span_le, Set.subset_def]
      intro x hx
      rw [SetLike.mem_coe, Submodule.mem_span_singleton]
      rw [Set.mem_image] at hx
      rcases hx with ‚ü®p, hp, rfl‚ü©
      rcases hp‚ÇÄv p hp with ‚ü®r, rfl‚ü©
      use r
      simp
    have hw' := SetLike.le_def.1 hs hw
    rwa [Submodule.mem_span_singleton] at hw'"
Mathlib/Topology/Homotopy/HomotopyGroup.lean,GenLoop.homotopicFrom,homotopicFrom,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine' Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, _, _‚ü©, _‚ü©
  pick_goal 3
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ rw [H.eq_fst]; exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    first
    | rw [H.apply_zero]
    | rw [H.apply_one]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv","warning:  GenLoop does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (?t, ?x)
case refine'_3.intro.inl
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
p q : ‚Üë(Œ©^ N X x)
t : ‚ÜëI
y : N ‚Üí ‚ÜëI
j : N
jH : y j = 0 ‚à® y j = 1
H : Path.Homotopy (toLoop j p) (toLoop j q)
‚ä¢ Function.uncurry (fun x_1 y ‚Ü¶ Function.uncurry (fun x_2 y ‚Ü¶ ‚Üë(H (x_1, x_2)) y) y)
      (Prod.map id ‚áë(Cube.splitAt j).toContinuousMap (t, y)) =
    ‚Üëp y
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (1, ?x)
case refine'_1
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
i : N
p q : ‚Üë(Œ©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
x‚úù : N ‚Üí ‚ÜëI
‚ä¢ Function.uncurry (fun x_1 y ‚Ü¶ Function.uncurry (fun x_2 y ‚Ü¶ ‚Üë(H (x_1, x_2)) y) y)
      (Prod.map id ‚áë(Cube.splitAt i).toContinuousMap (0, x‚úù)) =
    ‚Üëp x‚úù
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (1, ?x)
case refine'_2
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
i : N
p q : ‚Üë(Œ©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
x‚úù : N ‚Üí ‚ÜëI
‚ä¢ Function.uncurry (fun x_1 y ‚Ü¶ Function.uncurry (fun x_2 y ‚Ü¶ ‚Üë(H (x_1, x_2)) y) y)
      (Prod.map id ‚áë(Cube.splitAt i).toContinuousMap (1, x‚úù)) =
    ‚Üëq x‚úù
error:  unsolved goals
case refine'_1
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
i : N
p q : ‚Üë(Œ©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
‚ä¢ ‚àÄ (x_1 : N ‚Üí ‚ÜëI), (homotopyFrom i H).toFun (0, x_1) = ‚Üëp x_1

case refine'_2
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
i : N
p q : ‚Üë(Œ©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
‚ä¢ ‚àÄ (x_1 : N ‚Üí ‚ÜëI), (homotopyFrom i H).toFun (1, x_1) = ‚Üëq x_1","theorem homotopicFrom (i : N) {p q : Œ©^ N X x} :
    (toLoop i p).Homotopic (toLoop i q) ‚Üí Homotopic p q ",":= by
  refine Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, ?_, ?_‚ü©, ?_‚ü©
  pick_goal 3
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
        Function.uncurry_apply_pair]
      rw [H.eq_fst]
      exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
      Function.uncurry_apply_pair, ContinuousMap.HomotopyWith.apply_zero,
      ContinuousMap.HomotopyWith.apply_one, ne_eq, Path.coe_toContinuousMap, toLoop_apply_coe,
      ContinuousMap.curry_apply, ContinuousMap.comp_apply]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv",":= by
  refine Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, ?_, ?_‚ü©, ?_‚ü©
  pick_goal 3
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ rw [H.eq_fst]; exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    first
    | rw [H.apply_zero]
    | rw [H.apply_one]
    first
    | apply congr_arg p
    | apply congr_arg q => apply (Cube.splitAt i).left_inv"
Mathlib/Algebra/BigOperators/Finprod.lean,finprod_mem_finset_product,finprod_mem_finset_product,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  have :
    ‚àÄ a,
      (‚àè i : Œ≤ in (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i)) =
        (Finset.filter (fun ab => Prod.fst ab = a) s).prod f := by
    refine' fun a => Finset.prod_bij (fun b _ => (a, b)) _ _ _ _ <;> simp
    suffices ‚àÄ a' b, (a', b) ‚àà s ‚Üí a' = a ‚Üí (a, b) ‚àà s ‚àß a' = a by simpa
    rintro a' b hp rfl
    exact ‚ü®hp, rfl‚ü©
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ‚Üê Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image, Prod.mk.eta]
  exact fun x hx => ‚ü®x, hx, rfl‚ü©","error:  tactic 'assumption' failed
Œ± : Type u_1
Œ≤ : Type u_2
Œπ : Type u_3
G : Type u_4
M : Type u_5
N : Type u_6
inst‚úù¬≥ : CommMonoid M
inst‚úù¬≤ : CommMonoid N
f‚úù g : Œ± ‚Üí M
a‚úù b : Œ±
s‚úù t : Set Œ±
inst‚úù¬π : DecidableEq Œ±
inst‚úù : DecidableEq Œ≤
s : Finset (Œ± √ó Œ≤)
f : Œ± √ó Œ≤ ‚Üí M
a : Œ±
this : ‚àÄ (a' : Œ±) (b : Œ≤), (a', b) ‚àà s ‚Üí a' = a ‚Üí (a, b) ‚àà s ‚àß a' = a
‚ä¢ ‚àÄ (a_1 : Œ±) (b : Œ≤), (a_1, b) ‚àà s ‚Üí a_1 = a ‚Üí (a, b) ‚àà s ‚àß a = a_1","theorem finprod_mem_finset_product' [DecidableEq Œ±] [DecidableEq Œ≤] (s : Finset (Œ± √ó Œ≤))
    (f : Œ± √ó Œ≤ ‚Üí M) :
    (‚àè·∂† (ab) (_ : ab ‚àà s), f ab) =
      ‚àè·∂† (a) (b) (_ : b ‚àà (s.filter fun ab => Prod.fst ab = a).image Prod.snd), f (a, b) ",":= by
  have (a) :
      ‚àè i ‚àà (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i) =
        (s.filter (Prod.fst ¬∑ = a)).prod f := by
    refine Finset.prod_nbij' (fun b ‚Ü¶ (a, b)) Prod.snd ?_ ?_ ?_ ?_ ?_ <;> aesop
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ‚Üê Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image]
  exact fun x hx => ‚ü®x, hx, rfl‚ü©",":= by
  have :
    ‚àÄ a,
      (‚àè i : Œ≤ in (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i)) =
        (Finset.filter (fun ab => Prod.fst ab = a) s).prod f := by
    refine fun a => Finset.prod_bij (fun b _ => (a, b)) ?_ ?_ ?_ <;> simp
    suffices ‚àÄ a' b, (a', b) ‚àà s ‚Üí a' = a ‚Üí (a, b) ‚àà s ‚àß a' = a by simpa
    rintro a' b hp rfl
    exact ‚ü®hp, rfl‚ü©
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ‚Üê Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image, Prod.mk.eta]
  exact fun x hx => ‚ü®x, hx, rfl‚ü©"
Mathlib/Computability/Primrec.lean,Primrec.nat_double,nat_double,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  nat_mul.comp‚ÇÇ (const _) Primrec.id","error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ nat_mul (const ?m.115206)
argument
  const ?m.115206
has type
  Primrec fun x ‚Ü¶ ?m.115206 : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.114563 : Prop",theorem nat_double : Primrec (fun n : ‚Ñï => 2 * n) ,":=
  nat_mul.comp (const _) Primrec.id",":=
  natCast_double"
Mathlib/Analysis/BoundedVariation.lean,eVariationOn.lowerSemicontinuous_uniformOn,lowerSemicontinuous_uniformOn,96cf974eb3910f8af599dab3fd734ea72d5614ad,":= fun f ‚Ü¶ by
  rw [lowerSemicontinuousAt_iff_eventually_lt]
  apply @lowerSemicontinuous_aux _ _ _ _ (UniformOnFun Œ± E {s}) id (ùìù f) f s _
  have := @tendsto_id _ (ùìù f)
  rw [UniformOnFun.tendsto_iff_tendstoUniformlyOn] at this
  simp_rw [‚Üê tendstoUniformlyOn_singleton_iff_tendsto]
  exact fun x xs => (this s rfl).mono (singleton_subset_iff.mpr xs)","error:  unknown identifier 'lowerSemicontinuousAt_iff_eventually_lt'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.31448
Œ± : Type u_1
inst‚úù¬π : LinearOrder Œ±
E : Type u_2
inst‚úù : PseudoEMetricSpace E
s : Set Œ±
f : Œ± ‚Üí·µ§[{s}] E
‚ä¢ LowerSemicontinuousAt (fun f ‚Ü¶ eVariationOn f s) f","theorem lowerSemicontinuous_uniformOn (s : Set Œ±) :
    LowerSemicontinuous fun f : Œ± ‚Üí·µ§[{s}] E => eVariationOn f s ",":= fun f ‚Ü¶ by
  apply @lowerSemicontinuous_aux _ _ _ _ (UniformOnFun Œ± E {s}) id (ùìù f) f s _
  have := @tendsto_id _ (ùìù f)
  rw [UniformOnFun.tendsto_iff_tendstoUniformlyOn] at this
  simp_rw [‚Üê tendstoUniformlyOn_singleton_iff_tendsto]
  exact fun x xs => (this s rfl).mono (singleton_subset_iff.mpr xs)",":= fun f ‚Ü¶ by
  rw [lowerSemicontinuousAt_iff_eventually_lt]
  apply @lowerSemicontinuous_aux _ _ _ _ (UniformOnFun Œ± E {s}) id (ùìù f) f s _
  have := @tendsto_id _ (ùìù f)
  rw [UniformOnFun.tendsto_iff_tendstoUniformlyOn] at this
  simp_rw [‚Üê tendstoUniformlyOn_singleton_iff_tendsto]
  exact fun x xs => (this s rfl).mono (singleton_subset_iff.mpr xs)"
Mathlib/RingTheory/WittVector/Verschiebung.lean,WittVector.aeval_verschiebung_poly',aeval_verschiebung_poly',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases' n with n
  ¬∑ simp only [verschiebungPoly, Nat.zero_eq, ge_iff_le, tsub_eq_zero_of_le, ite_true, map_zero,
    verschiebungFun_coeff_zero]
  ¬∑ rw [verschiebungPoly, verschiebungFun_coeff_succ, if_neg n.succ_ne_zero, aeval_X,
      Nat.succ_eq_add_one, add_tsub_cancel_right]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
p : ‚Ñï
R : Type u_1
S : Type u_2
hp : Fact (Nat.Prime p)
inst‚úù¬π : CommRing R
inst‚úù : CommRing S
x : ùïé R
n : ‚Ñï
‚ä¢ x.coeff (n + 1 - 1) = x.coeff n","theorem aeval_verschiebung_poly' (x : ùïé R) (n : ‚Ñï) :
    aeval x.coeff (verschiebungPoly n) = (verschiebungFun x).coeff n ",":= by
  cases' n with n
  ¬∑ simp only [verschiebungPoly, Nat.zero_eq, ge_iff_le, tsub_eq_zero_of_le, ite_true, map_zero,
    verschiebungFun_coeff_zero]
  ¬∑ rw [verschiebungPoly, verschiebungFun_coeff_succ, if_neg n.succ_ne_zero, aeval_X,
      add_tsub_cancel_right]",":= by
  cases' n with n
  ¬∑ simp only [verschiebungPoly, Nat.zero_eq, ge_iff_le, tsub_eq_zero_of_le, ite_true, map_zero,
    verschiebungFun_coeff_zero]
  ¬∑ rw [verschiebungPoly, verschiebungFun_coeff_succ, if_neg n.succ_ne_zero, aeval_X,
      Nat.succ_eq_add_one, add_tsub_cancel_right]"
Mathlib/MeasureTheory/Measure/WithDensityFinite.lean,MeasureTheory.toFinite_apply,toFinite_apply,4bc787e4cd27d5ae2ed300af7ae9e9f1c8480840,:= rfl,"error:  type mismatch
  rfl
has type
  Œº.toFinite s = Œº.toFinite s : Prop
but is expected to have type
  Œº.toFinite s = (Œº.toFiniteAux Set.univ)‚Åª¬π * Œº.toFiniteAux s : Prop","lemma toFinite_apply (Œº : Measure Œ±) [SFinite Œº] (s : Set Œ±) :
    Œº.toFinite s = (Œº.toFiniteAux Set.univ)‚Åª¬π * Œº.toFiniteAux s ",":= by
  rw [Measure.toFinite, ProbabilityTheory.cond_apply _ MeasurableSet.univ, Set.univ_inter]",:= rfl
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt,mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  induction' n with n hn
  ¬∑ simpa using hz
  ¬∑ rw [_root_.pow_succ, mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)","error:  application type mismatch
  mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (IsIntegral.smul (p ^ n) hzint) hz
argument
  hz
has type
  p ^ n ‚Ä¢ p ‚Ä¢ z ‚àà adjoin R {B.gen} : Prop
but is expected to have type
  p ‚Ä¢ p ^ n ‚Ä¢ z ‚àà adjoin R {B.gen} : Prop","theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ‚Ñï} {z : L} (hzint : IsIntegral R z)
    (hz : p ^ n ‚Ä¢ z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) :
    z ‚àà adjoin R ({B.gen} : Set L) ",":= by
  induction' n with n hn
  ¬∑ simpa using hz
  ¬∑ rw [_root_.pow_succ', mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)",":= by
  induction' n with n hn
  ¬∑ simpa using hz
  ¬∑ rw [_root_.pow_succ] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,7c8956d2555c8b18a57db0639fdd3f1eaa146759,":= by
  refine' ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, _‚ü©, rfl‚ü©, _‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)","error:  function expected at
  le_integralClosure_iff_isIntegral.mp (adjoin_le_integralClosure (IsPrimitiveRoot.isIntegral hŒ∂ (PNat.pos (p ^ k))))
term has type
  Algebra.IsIntegral ‚Ñ§ ‚Ü•(adjoin ‚Ñ§ {Œ∂})
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë(?m ^ ?n)
case refine'_1.intro.intro
p : ‚Ñï+
k : ‚Ñï
K : Type u
inst‚úù¬π : Field K
inst‚úù : CharZero K
Œ∂ : K
hp : Fact (Nat.Prime ‚Üëp)
hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)
x : K
h : IsIntegral ‚Ñ§ x
B : PowerBasis ‚Ñö K := IsPrimitiveRoot.subOnePowerBasis ‚Ñö hŒ∂
hint : IsIntegral ‚Ñ§ B.gen
this : FiniteDimensional ‚Ñö K := finiteDimensional {p ^ k} ‚Ñö K
u : ‚Ñ§À£
n : ‚Ñï
hun : Algebra.discr ‚Ñö ‚áë(IsPrimitiveRoot.subOnePowerBasis ‚Ñö hŒ∂).basis = ‚Üë‚Üëu * ‚Üë‚Üëp ^ n
H : ‚Üë‚Üëp ^ n ‚Ä¢ x ‚àà adjoin ‚Ñ§ {B.gen}
‚ä¢ x ‚àà adjoin ‚Ñ§ {Œ∂}","theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)) : IsIntegralClosure (adjoin ‚Ñ§ ({Œ∂} : Set K)) ‚Ñ§ K ",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton _)"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,7dc162787d2a79bf721a83a87f641ace70251b17,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_ortho"
Mathlib/RepresentationTheory/Basic.lean,Representation.ofMulAction_single,ofMulAction_single,3653352683804f7807e57f2b646e31b313359cff,":= by
  simp",error:  simp made no progress,"theorem ofMulAction_single (g : G) (x : H) (r : k) :
    ofMulAction k G H g (Finsupp.single x r) = Finsupp.single (g ‚Ä¢ x) r ",":=
  Finsupp.mapDomain_single",":= by
  simp"
Mathlib/Algebra/FreeAlgebra.lean,FreeAlgebra.induction,induction,acf51aa5213fe1533e7b3b5b6ec403b3b329cede,":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [Subtype.coind]
  suffices : a = lift R of a
  ¬∑ rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a","error:  unexpected token ':'; expected term
error:  unsolved goals
case w.h
R : Type u_1
inst‚úù : CommSemiring R
X : Type u_2
C : FreeAlgebra R X ‚Üí Prop
h_grade0 : ‚àÄ (r : R), C ((algebraMap R (FreeAlgebra R X)) r)
h_grade1 : ‚àÄ (x : X), C (Œπ R x)
h_mul : ‚àÄ (a b : FreeAlgebra R X), C a ‚Üí C b ‚Üí C (a * b)
h_add : ‚àÄ (a b : FreeAlgebra R X), C a ‚Üí C b ‚Üí C (a + b)
a : FreeAlgebra R X
s : Subalgebra R (FreeAlgebra R X) :=
  { carrier := C, mul_mem' := ‚ãØ, one_mem' := ‚ãØ, add_mem' := ‚ãØ, zero_mem' := ‚ãØ, algebraMap_mem' := h_grade0 }
of : X ‚Üí ‚Ü•s := Subtype.coind (Œπ R) h_grade1
x‚úù : X
‚ä¢ Œπ R x‚úù = ‚Üë(of x‚úù)","theorem induction {C : FreeAlgebra R X ‚Üí Prop}
    (h_grade0 : ‚àÄ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ‚àÄ x, C (Œπ R x))
    (h_mul : ‚àÄ a b, C a ‚Üí C b ‚Üí C (a * b)) (h_add : ‚àÄ a b, C a ‚Üí C b ‚Üí C (a + b))
    (a : FreeAlgebra R X) : C a ",":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a",":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [Subtype.coind]
  suffices a = lift R of a from this
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a"
Mathlib/RingTheory/Polynomial/Chebyshev.lean,Polynomial.Chebyshev.mul_T,mul_T,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  induction k using Polynomial.Chebyshev.induct with
  | zero => simp [two_mul]
  | one => rw [T_add_one, T_one]; ring
  | add_two k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + k)
    have h‚ÇÇ := T_sub_two R (m - k)
    have h‚ÇÉ := T_add_two R k
    linear_combination (norm : = ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + (-k - 1))
    have h‚ÇÇ := T_sub_two R (m - (-k - 1))
    have h‚ÇÉ := T_add_two R (-k - 1)
    linear_combination (norm : = ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X : R[X]) * ih1",error:  unexpected token '='; expected ')' or term,theorem mul_T (m k : ‚Ñ§) : 2 * T R m * T R k = T R (m + k) + T R (m - k) ,":= by
  induction k using Polynomial.Chebyshev.induct with
  | zero => simp [two_mul]
  | one => rw [T_add_one, T_one]; ring
  | add_two k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + k)
    have h‚ÇÇ := T_sub_two R (m - k)
    have h‚ÇÉ := T_add_two R k
    linear_combination (norm := ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X:R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + (-k - 1))
    have h‚ÇÇ := T_sub_two R (m - (-k - 1))
    have h‚ÇÉ := T_add_two R (-k - 1)
    linear_combination (norm := ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X:R[X]) * ih1",":= by
  induction k using Polynomial.Chebyshev.induct with
  | zero => simp [two_mul]
  | one => rw [T_add_one, T_one]; ring
  | add_two k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + k)
    have h‚ÇÇ := T_sub_two R (m - k)
    have h‚ÇÉ := T_add_two R k
    linear_combination (norm : = ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + (-k - 1))
    have h‚ÇÇ := T_sub_two R (m - (-k - 1))
    have h‚ÇÉ := T_add_two R (-k - 1)
    linear_combination (norm : = ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + (-k - 1))
    have h‚ÇÇ := T_sub_two R (m - (-k - 1))
    have h‚ÇÉ := T_add_two R (-k - 1)
    linear_combination (norm : = ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + (-k - 1))
    have h‚ÇÇ := T_sub_two R (m - (-k - 1))
    have h‚ÇÉ := T_add_two R (-k - 1)
    linear_combination (norm : = ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + (-k - 1))
    have h‚ÇÇ := T_sub_two R (m - (-k - 1))
    have h‚ÇÉ := T_add_two R (-k - 1)
    linear_combination (norm : = ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + (-k - 1))
    have h‚ÇÇ := T_sub_two R (m - (-k - 1))
    have h‚ÇÉ := T_add_two R (-k - 1)
    linear_combination (norm : = ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + (-k - 1))
    have h‚ÇÇ := T_sub_two R (m - (-k - 1))
    have h‚ÇÉ := T_add_two R (-k - 1)
    linear_combination (norm : = ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + (-k - 1))
    have h‚ÇÇ := T_sub_two R (m - (-k - 1))
    have h‚ÇÉ := T_add_two R (-k - 1)
    linear_combination (norm : = ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + (-k - 1))
    have h‚ÇÇ := T_sub_two R (m - (-k - 1))
    have h‚ÇÉ := T_add_two R (-k - 1)
    linear_combination (norm : = ring_nf) 2 * T R m * h‚ÇÉ - h‚ÇÇ - h‚ÇÅ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h‚ÇÅ := T_add_two R (m + (-k - 1))
    have h‚ÇÇ := T_sub_two R (m - (-k - 1))
    have h‚ÇÉ := T_add_two R ("
Mathlib/Analysis/Convolution.lean,MeasureTheory.hasFDerivAt_convolution_right_with_param,hasFDerivAt_convolution_right_with_param,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine' (hasFDerivAt_zero_of_eventually_const 0 _).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s
      ¬∑ exact Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine' ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, _, _‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C; exact ht.subset_closedBall_lt 0 0
    refine' ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => _‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine' mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), _, _‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine' (HasCompactSupport.convolutionExists_right L _ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº
  exact hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine' ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, _‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    apply eventually_of_forall
    intro a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    apply eventually_of_forall
    intro a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, id.def, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6","error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1586848 ‚Üí ?m.1586848
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1587143 ‚Üí ?m.1587143
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  unsolved goals
case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.1 = (_root_.id x).1

case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.2 - a = (_root_.id x).2 - a","theorem hasFDerivAt_convolution_right_with_param {g : P ‚Üí G ‚Üí E'} {s : Set P} {k : Set G}
    (hs : IsOpen s) (hk : IsCompact k) (hgs : ‚àÄ p, ‚àÄ x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0)
    (hf : LocallyIntegrable f Œº) (hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)) (q‚ÇÄ : P √ó G)
    (hq‚ÇÄ : q‚ÇÄ.1 ‚àà s) :
    HasFDerivAt (fun q : P √ó G => (f ‚ãÜ[L, Œº] g q.1) q.2)
      ((f ‚ãÜ[L.precompR (P √ó G), Œº] fun x : G => fderiv ùïú (‚Üøg) (q‚ÇÄ.1, x)) q‚ÇÄ.2) q‚ÇÄ ",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s := Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C := ht.subset_closedBall_lt 0 0
    refine ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => ?_‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), ?_, ?_‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine (HasCompactSupport.convolutionExists_right L ?_ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº :=
    hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, ?_‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    filter_upwards with a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    filter_upwards with a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, _root_.id, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t
      ¬∑ exact A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s
      ¬∑ exact Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_"
Mathlib/Algebra/BigOperators/Finprod.lean,finprod_mem_finset_product,finprod_mem_finset_product,8bcfd78dbb0250a0a2e98eb49afa253d8fdf6aeb,":= by
  have :
    ‚àÄ a,
      (‚àè i : Œ≤ in (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i)) =
        (Finset.filter (fun ab => Prod.fst ab = a) s).prod f := by
    refine' fun a => Finset.prod_bij (fun b _ => (a, b)) _ _ _ _ <;>
      try simp; done
    suffices ‚àÄ a' b, (a', b) ‚àà s ‚Üí a' = a ‚Üí (a, b) ‚àà s ‚àß a' = a by simpa
    rintro a' b hp rfl
    exact ‚ü®hp, rfl‚ü©
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ‚Üê Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image, Prod.mk.eta]
  exact fun x hx => ‚ü®x, hx, rfl‚ü©","error:  tactic 'assumption' failed
Œ± : Type u_1
Œ≤ : Type u_2
Œπ : Type u_3
G : Type u_4
M : Type u_5
N : Type u_6
inst‚úù¬≥ : CommMonoid M
inst‚úù¬≤ : CommMonoid N
f‚úù g : Œ± ‚Üí M
a‚úù b : Œ±
s‚úù t : Set Œ±
inst‚úù¬π : DecidableEq Œ±
inst‚úù : DecidableEq Œ≤
s : Finset (Œ± √ó Œ≤)
f : Œ± √ó Œ≤ ‚Üí M
a : Œ±
this : ‚àÄ (a' : Œ±) (b : Œ≤), (a', b) ‚àà s ‚Üí a' = a ‚Üí (a, b) ‚àà s ‚àß a' = a
‚ä¢ ‚àÄ (a_1 : Œ±) (b : Œ≤), (a_1, b) ‚àà s ‚Üí a_1 = a ‚Üí (a, b) ‚àà s ‚àß a = a_1","theorem finprod_mem_finset_product' [DecidableEq Œ±] [DecidableEq Œ≤] (s : Finset (Œ± √ó Œ≤))
    (f : Œ± √ó Œ≤ ‚Üí M) :
    (‚àè·∂† (ab) (_ : ab ‚àà s), f ab) =
      ‚àè·∂† (a) (b) (_ : b ‚àà (s.filter fun ab => Prod.fst ab = a).image Prod.snd), f (a, b) ",":= by
  have (a) :
      ‚àè i ‚àà (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i) =
        (s.filter (Prod.fst ¬∑ = a)).prod f := by
    refine Finset.prod_nbij' (fun b ‚Ü¶ (a, b)) Prod.snd ?_ ?_ ?_ ?_ ?_ <;> aesop
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ‚Üê Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image]
  exact fun x hx => ‚ü®x, hx, rfl‚ü©",":= by
  have :
    ‚àÄ a,
      (‚àè i : Œ≤ in (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i)) =
        (Finset.filter (fun ab => Prod.fst ab = a) s).prod f := by
    refine fun a => Finset.prod_bij (fun b _ => (a, b)) ?_ ?_ ?_ <;>
      try simp; done
    suffices ‚àÄ a' b, (a', b) ‚àà s ‚Üí a' = a ‚Üí (a, b) ‚àà s ‚àß a' = a by simpa
    rintro a' b hp rfl
    exact ‚ü®hp, rfl‚ü©
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ‚Üê Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image, Prod.mk.eta]
  exact fun x hx => ‚ü®x, hx, rfl‚ü©"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,65f7857d510e130142dbb111786341d695ac399b,":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, _‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine'
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' ‚ü®hus, hsv.symm, ‚ü®x, _, _‚ü©, _‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right _ _, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) _
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 ‚àà ?m.92170 ‚à™ ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 ‚àà ?m.92636 ‚à™ ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 ‚àà ?m.94503 ‚à™ ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 ‚àà ?m.97297 ‚à™ ?m.97298
error:  ambiguous, possible interpretations 
  _root_.not_imp : ¬¨(?m.97719 ‚Üí ?m.97720) ‚Üî ?m.97719 ‚àß ¬¨?m.97720
  
  Classical.not_imp : ¬¨(?m.97721 ‚Üí ?m.97722) ‚Üî ?m.97721 ‚àß ¬¨?m.97722
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.97724
case neg
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
ùíú : Finset (Finset Œ±)
u‚úù v‚úù a : Finset Œ±
r : ‚Ñï
u v : Finset Œ±
huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú
ùíú' : Finset (Finset Œ±) := ùìí u v ùíú
s : Finset Œ±
hsùíú' : s ‚àà ‚àÇ ùíú'
hsùíú : s ‚àâ ‚àÇ ùíú
m : ‚àÄ y ‚àâ s, insert y s ‚àâ ùíú
x : Œ±
left‚úù : x ‚àâ s
right‚úù : insert x s ‚àà ùíú'
hus‚úù : u ‚äÜ insert x s
hvs : Disjoint v (insert x s)
this‚úù¬≤ : (insert x s ‚à™ v) \ u ‚àà ùíú
hsv : Disjoint s v
hvu : Disjoint v u
hxv : x ‚àâ v
this‚úù¬π : v \ u = v
this‚úù : x ‚àâ u
hus : u ‚äÜ s
w : Œ±
hwB : ¬¨(w ‚àà s ‚à™ v ‚àß w ‚àâ u)
hwùíú' : insert w ((s ‚à™ v) \ u) ‚àà ùíú'
this : v ‚äÜ insert w ((s ‚à™ v) \ u)
hwu : w ‚àâ u
‚ä¢ False","theorem shadow_compression_subset_compression_shadow (u v : Finset Œ±)
    (huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú) :
    ‚àÇ (ùìí u v ùíú) ‚äÜ ùìí u v (‚àÇ ùíú) ",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine mem_shadow_iff.2
        ‚ü®(t ‚äî u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) ?_
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
           sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx "
Mathlib/Analysis/Calculus/MeanValue.lean,strictMono_of_deriv_pos,strictMono_of_deriv_pos,0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":=
  strictMonoOn_univ.1 <| convex_univ.strictMonoOn_of_deriv_pos (fun z _ =>
    (differentiableAt_of_deriv_ne_zero (hf' z).ne').differentiableWithinAt.continuousWithinAt)
    fun x _ => hf' x","error:  invalid field 'strictMonoOn_of_deriv_pos', the environment does not contain 'Convex.strictMonoOn_of_deriv_pos'
  convex_univ
has type
  Convex ?m.279725 univ
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  convex_univ
has type
  ?m.280049 ‚àà univ ‚Üí StarConvex ?m.279725 ?m.280049 univ","theorem strictMono_of_deriv_pos {f : ‚Ñù ‚Üí ‚Ñù} (hf' : ‚àÄ x, 0 < deriv f x) : StrictMono f ",":=
  strictMonoOn_univ.1 <| strictMonoOn_of_deriv_pos convex_univ (fun z _ =>
    (differentiableAt_of_deriv_ne_zero (hf' z).ne').differentiableWithinAt.continuousWithinAt)
    fun x _ => hf' x",":=
  strictMonoOn_univ.1 <| convex_univ.strictMonoOn_of_deriv_pos (fun z _ =>
    (differentiableAt_of_deriv_ne_zero (hf' z).ne').differentiableWithinAt)
    fun x _ => hf' x"
Mathlib/Geometry/Euclidean/Angle/Sphere.lean,Affine.Triangle.inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_circumcenter,inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_circumcenter,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  Sphere.inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center (t.mem_circumsphere _)
    (t.mem_circumsphere _) (t.mem_circumsphere _) (t.Independent.injective.ne h‚ÇÅ‚ÇÇ)
    (t.Independent.injective.ne h‚ÇÅ‚ÇÉ) (t.Independent.injective.ne h‚ÇÇ‚ÇÉ)","error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle ‚Ñù P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex ‚Ñù P 2
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle ‚Ñù P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex ‚Ñù P 2
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle ‚Ñù P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex ‚Ñù P 2","theorem inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_circumcenter (t : Triangle ‚Ñù P)
    {i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3} (h‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ) (h‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ) (h‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ) :
    ((Real.Angle.tan (‚à° (t.points i‚ÇÅ) (t.points i‚ÇÇ) (t.points i‚ÇÉ)))‚Åª¬π / 2) ‚Ä¢
      o.rotation (œÄ / 2 : ‚Ñù) (t.points i‚ÇÉ -·µ• t.points i‚ÇÅ) +·µ•
        midpoint ‚Ñù (t.points i‚ÇÅ) (t.points i‚ÇÉ) = t.circumcenter ",":=
  Sphere.inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center (t.mem_circumsphere _)
    (t.mem_circumsphere _) (t.mem_circumsphere _) (t.independent.injective.ne h‚ÇÅ‚ÇÇ)
    (t.independent.injective.ne h‚ÇÅ‚ÇÉ) (t.independent.injective.ne h‚ÇÇ‚ÇÉ)",":=
  Sphere.inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center (t.mem_circumsphere _)
    (t.mem_circumsphere _) (t.mem_circumsphere _) (t.Independent.injective.ne h‚ÇÇ‚ÇÉ)"
Mathlib/Data/Nat/Factorization/Basic.lean,Nat.factorization_pow,factorization_pow,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' k with k ih; ¬∑ simp
  rcases eq_or_ne n 0 with (rfl | hn)
  ¬∑ simp
  rw [Nat.pow_succ, mul_comm, factorization_mul hn (pow_ne_zero _ hn), ih, succ_eq_one_add,
    add_smul, one_smul]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ.inr
a b m n‚úù p n k : ‚Ñï
ih : (n ^ k).factorization = k ‚Ä¢ n.factorization
hn : n ‚â† 0
‚ä¢ n.factorization + k ‚Ä¢ n.factorization = (k + 1) ‚Ä¢ n.factorization",theorem factorization_pow (n k : ‚Ñï) : factorization (n ^ k) = k ‚Ä¢ n.factorization ,":= by
  induction' k with k ih; ¬∑ simp
  rcases eq_or_ne n 0 with (rfl | hn)
  ¬∑ simp
  rw [Nat.pow_succ, mul_comm, factorization_mul hn (pow_ne_zero _ hn), ih,
    add_smul, one_smul, add_comm]",":= by
  induction' k with k ih; ¬∑ simp
  rcases eq_or_ne n 0 with (rfl | hn)
  ¬∑ simp
  rw [Nat.pow_succ, mul_comm, factorization_mul hn (pow_ne_zero _ hn), ih, succ_eq_one_add,
    add_smul, one_smul]"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Œµ hŒµ).mono fun y hy => _
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_op_norm (n.2 - x)",error:  unexpected token ';'; expected '|',"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tend"
Mathlib/Data/NNRat/Lemmas.lean,NNRat.num_div_den,num_div_den,bb997ebae7d037781f6e811e46f3f898622a1536,":= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, ‚Üê Int.cast_natCast,
    Int.natAbs_of_nonneg (Rat.num_nonneg.2 q.prop)]
  exact Rat.num_div_den q","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë(‚Üëq).num.natAbs
case a
p q‚úù q : ‚Ñö‚â•0
‚ä¢ ‚Üë‚Üë(‚Üëq).num.natAbs / ‚Üëq.den = ‚Üëq",lemma num_div_den (q : ‚Ñö‚â•0) : (q.num : ‚Ñö‚â•0) / q.den = q ,":= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, ‚Üê Int.cast_natCast,
    Int.natAbs_of_nonneg (Rat.num_nonneg.2 q.cast_nonneg)]
  exact Rat.num_div_den q",":= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, ‚Üê Int.cast_natCast,
    Int.natAbs_of_nonneg (Rat.num_nonneg.2 q.prop)]
  exact Rat.num_div_den q"
Mathlib/Topology/UrysohnsLemma.lean,exists_continuous_one_zero_of_isCompact_of_isGŒ¥,exists_continuous_one_zero_of_isCompact_of_isGŒ¥,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  rcases h's.eq_iInter_nat with ‚ü®U, U_open, hU‚ü©
  obtain ‚ü®m, m_comp, -, sm, mt‚ü© : ‚àÉ m, IsCompact m ‚àß IsClosed m ‚àß s ‚äÜ interior m ‚àß m ‚äÜ t·∂ú :=
    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left
  have A n : ‚àÉ f : C(X, ‚Ñù), EqOn f 1 s ‚àß EqOn f 0 (U n ‚à© interior m)·∂ú ‚àß HasCompactSupport f
      ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by
    apply exists_continuous_one_zero_of_isCompact hs
      ((U_open n).inter isOpen_interior).isClosed_compl
    rw [disjoint_compl_right_iff_subset]
    exact subset_inter ((hU.subset.trans (iInter_subset U n))) sm
  choose f fs fm _hf f_range using A
  obtain ‚ü®u, u_pos, u_sum, hu‚ü© : ‚àÉ (u : ‚Ñï ‚Üí ‚Ñù), (‚àÄ i, 0 < u i) ‚àß Summable u ‚àß ‚àë' i, u i = 1 :=
    ‚ü®fun n ‚Ü¶ 1/2/2^n, fun n ‚Ü¶ by positivity, summable_geometric_two' 1, tsum_geometric_two' 1‚ü©
  let g : X ‚Üí ‚Ñù := fun x ‚Ü¶ ‚àë' n, u n * f n x
  have hgmc : EqOn g 0 m·∂ú := by
    intro x hx
    have B n : f n x = 0 := by
      have : m·∂ú ‚äÜ (U n ‚à© interior m)·∂ú := by
        simpa using (inter_subset_right _ _).trans interior_subset
      exact fm n (this hx)
    simp [B]
  have I n x : u n * f n x ‚â§ u n := mul_le_of_le_one_right (u_pos n).le (f_range n x).2
  have S x : Summable (fun n ‚Ü¶ u n * f n x) := Summable.of_nonneg_of_le
      (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1) (fun n ‚Ü¶ I n x) u_sum
  refine ‚ü®‚ü®g, ?_‚ü©, ?_, hgmc.mono (subset_compl_comm.mp mt), ?_, fun x ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ apply continuous_tsum (fun n ‚Ü¶ continuous_const.mul (f n).continuous) u_sum (fun n x ‚Ü¶ ?_)
    simpa [abs_of_nonneg, (u_pos n).le, (f_range n x).1] using I n x
  ¬∑ apply Subset.antisymm (fun x hx ‚Ü¶ by simp [fs _ hx, hu]) ?_
    apply compl_subset_compl.1
    intro x hx
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, x ‚àâ U n := by simpa [hU] using hx
    have fnx : f n x = 0 := fm _ (by simp [hn])
    have : g x < 1 := by
      apply lt_of_lt_of_le ?_ hu.le
      exact tsum_lt_tsum (i := n) (fun i ‚Ü¶ I i x) (by simp [fnx, u_pos n]) (S x) u_sum
    simpa using this.ne
  ¬∑ exact HasCompactSupport.of_support_subset_isCompact m_comp
      (Function.support_subset_iff'.mpr hgmc)
  ¬∑ exact tsum_nonneg (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1)
  ¬∑ apply le_trans _ hu.le
    exact tsum_le_tsum (fun n ‚Ü¶ I n x) (S x) u_sum","error:  function expected at
  inter_subset_right ?m.69203
term has type
  ?m.69202 ‚àà ?m.69201
error:  unsolved goals
X : Type u_1
inst‚úù¬≤ : TopologicalSpace X
inst‚úù¬π : RegularSpace X
inst‚úù : LocallyCompactSpace X
s t : Set X
hs : IsCompact s
h's : IsGŒ¥ s
ht : IsClosed t
hd : Disjoint s t
U : ‚Ñï ‚Üí Set X
U_open : ‚àÄ (n : ‚Ñï), IsOpen (U n)
hU : s = ‚ãÇ n, U n
m : Set X
m_comp : IsCompact m
sm : s ‚äÜ interior m
mt : m ‚äÜ t·∂ú
f : ‚Ñï ‚Üí C(X, ‚Ñù)
fs : ‚àÄ (n : ‚Ñï), EqOn (‚áë(f n)) 1 s
fm : ‚àÄ (n : ‚Ñï), EqOn (‚áë(f n)) 0 (U n ‚à© interior m)·∂ú
_hf : ‚àÄ (n : ‚Ñï), HasCompactSupport ‚áë(f n)
f_range : ‚àÄ (n : ‚Ñï) (x : X), (f n) x ‚àà Icc 0 1
u : ‚Ñï ‚Üí ‚Ñù
u_pos : ‚àÄ (i : ‚Ñï), 0 < u i
u_sum : Summable u
hu : ‚àë' (i : ‚Ñï), u i = 1
g : X ‚Üí ‚Ñù := fun x ‚Ü¶ ‚àë' (n : ‚Ñï), u n * (f n) x
x : X
hx : x ‚àà m·∂ú
B : ‚àÄ (n : ‚Ñï), (f n) x = 0
‚ä¢ g x = 0
error:  unsolved goals
X : Type u_1
inst‚úù¬≤ : TopologicalSpace X
inst‚úù¬π : RegularSpace X
inst‚úù : LocallyCompactSpace X
s t : Set X
hs : IsCompact s
h's : IsGŒ¥ s
ht : IsClosed t
hd : Disjoint s t
U : ‚Ñï ‚Üí Set X
U_open : ‚àÄ (n : ‚Ñï), IsOpen (U n)
hU : s = ‚ãÇ n, U n
m : Set X
m_comp : IsCompact m
sm : s ‚äÜ interior m
mt : m ‚äÜ t·∂ú
f : ‚Ñï ‚Üí C(X, ‚Ñù)
fs : ‚àÄ (n : ‚Ñï), EqOn (‚áë(f n)) 1 s
fm : ‚àÄ (n : ‚Ñï), EqOn (‚áë(f n)) 0 (U n ‚à© interior m)·∂ú
_hf : ‚àÄ (n : ‚Ñï), HasCompactSupport ‚áë(f n)
f_range : ‚àÄ (n : ‚Ñï) (x : X), (f n) x ‚àà Icc 0 1
u : ‚Ñï ‚Üí ‚Ñù
u_pos : ‚àÄ (i : ‚Ñï), 0 < u i
u_sum : Summable u
hu : ‚àë' (i : ‚Ñï), u i = 1
g : X ‚Üí ‚Ñù := fun x ‚Ü¶ ‚àë' (n : ‚Ñï), u n * (f n) x
hgmc : EqOn g 0 m·∂ú
I : ‚àÄ (n : ‚Ñï) (x : X), u n * (f n) x ‚â§ u n
S : ‚àÄ (x : X), Summable fun n ‚Ü¶ u n * (f n) x
x : X
hx : x ‚àà s
‚ä¢ g x = 1","theorem exists_continuous_one_zero_of_isCompact_of_isGŒ¥ [RegularSpace X] [LocallyCompactSpace X]
    {s t : Set X} (hs : IsCompact s) (h's : IsGŒ¥ s) (ht : IsClosed t) (hd : Disjoint s t) :
    ‚àÉ f : C(X, ‚Ñù), s = f ‚Åª¬π' {1} ‚àß EqOn f 0 t ‚àß HasCompactSupport f
      ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 ",":= by
  rcases h's.eq_iInter_nat with ‚ü®U, U_open, hU‚ü©
  obtain ‚ü®m, m_comp, -, sm, mt‚ü© : ‚àÉ m, IsCompact m ‚àß IsClosed m ‚àß s ‚äÜ interior m ‚àß m ‚äÜ t·∂ú :=
    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left
  have A n : ‚àÉ f : C(X, ‚Ñù), EqOn f 1 s ‚àß EqOn f 0 (U n ‚à© interior m)·∂ú ‚àß HasCompactSupport f
      ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by
    apply exists_continuous_one_zero_of_isCompact hs
      ((U_open n).inter isOpen_interior).isClosed_compl
    rw [disjoint_compl_right_iff_subset]
    exact subset_inter ((hU.subset.trans (iInter_subset U n))) sm
  choose f fs fm _hf f_range using A
  obtain ‚ü®u, u_pos, u_sum, hu‚ü© : ‚àÉ (u : ‚Ñï ‚Üí ‚Ñù), (‚àÄ i, 0 < u i) ‚àß Summable u ‚àß ‚àë' i, u i = 1 :=
    ‚ü®fun n ‚Ü¶ 1/2/2^n, fun n ‚Ü¶ by positivity, summable_geometric_two' 1, tsum_geometric_two' 1‚ü©
  let g : X ‚Üí ‚Ñù := fun x ‚Ü¶ ‚àë' n, u n * f n x
  have hgmc : EqOn g 0 m·∂ú := by
    intro x hx
    have B n : f n x = 0 := by
      have : m·∂ú ‚äÜ (U n ‚à© interior m)·∂ú := by
        simpa using inter_subset_right.trans interior_subset
      exact fm n (this hx)
    simp [g, B]
  have I n x : u n * f n x ‚â§ u n := mul_le_of_le_one_right (u_pos n).le (f_range n x).2
  have S x : Summable (fun n ‚Ü¶ u n * f n x) := Summable.of_nonneg_of_le
      (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1) (fun n ‚Ü¶ I n x) u_sum
  refine ‚ü®‚ü®g, ?_‚ü©, ?_, hgmc.mono (subset_compl_comm.mp mt), ?_, fun x ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ apply continuous_tsum (fun n ‚Ü¶ continuous_const.mul (f n).continuous) u_sum (fun n x ‚Ü¶ ?_)
    simpa [abs_of_nonneg, (u_pos n).le, (f_range n x).1] using I n x
  ¬∑ apply Subset.antisymm (fun x hx ‚Ü¶ by simp [g, fs _ hx, hu]) ?_
    apply compl_subset_compl.1
    intro x hx
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, x ‚àâ U n := by simpa [hU] using hx
    have fnx : f n x = 0 := fm _ (by simp [hn])
    have : g x < 1 := by
      apply lt_of_lt_of_le ?_ hu.le
      exact tsum_lt_tsum (i := n) (fun i ‚Ü¶ I i x) (by simp [fnx, u_pos n]) (S x) u_sum
    simpa using this.ne
  ¬∑ exact HasCompactSupport.of_support_subset_isCompact m_comp
      (Function.support_subset_iff'.mpr hgmc)
  ¬∑ exact tsum_nonneg (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1)
  ¬∑ apply le_trans _ hu.le
    exact tsum_le_tsum (fun n ‚Ü¶ I n x) (S x) u_sum",":= by
  rcases h's.eq_iInter_nat with ‚ü®U, U_open, hU‚ü©
  obtain ‚ü®m, m_comp, -, sm, mt‚ü© : ‚àÉ m, IsCompact m ‚àß IsClosed m ‚àß s ‚äÜ interior m ‚àß m ‚äÜ t·∂ú :=
    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left
  have A n : ‚àÉ f : C(X, ‚Ñù), EqOn f 1 s ‚àß EqOn f 0 (U n ‚à© interior m)·∂ú ‚àß HasCompactSupport f
      ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by
    apply exists_continuous_one_zero_of_isCompact hs
      ((U_open n).inter isOpen_interior).isClosed_compl
    rw [disjoint_compl_right_iff_subset]
    exact subset_inter ((hU.subset.trans iInter_subset U n))) sm
  choose f fs fm _hf f_range using A
  obtain ‚ü®u, u_pos, u_sum, hu‚ü© : ‚àÉ (u : ‚Ñï ‚Üí ‚Ñù), (‚àÄ i, 0 < u i) ‚àß Summable u ‚àß ‚àë' i, u i = 1 :=
    ‚ü®fun n ‚Ü¶ 1/2/2^n, fun n ‚Ü¶ by positivity, summable_geometric_two' 1, tsum_geometric_two' 1‚ü©
  let g : X ‚Üí ‚Ñù := fun x ‚Ü¶ ‚àë' n, u n * f n x
  have hgmc : EqOn g 0 m·∂ú := by
    intro x hx
    have B n : f n x = 0 := by
      have : m·∂ú ‚äÜ (U n ‚à© interior m)·∂ú := by
        simpa using inter_subset_right.trans interior_subset
      exact fm n (this hx)
    simp [B]
  have I n x : u n * f n x ‚â§ u n := mul_le_of_le_one_right (u_pos n).le (f_range n x).2
  have S x : Summable (fun n ‚Ü¶ u n * f n x) := Summable.of_nonneg_of_le
      (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1) (fun n ‚Ü¶ I n x) u_sum
  refine ‚ü®‚ü®g, ?_‚ü©, ?_, hgmc.mono (subset_compl_comm.mp mt), ?_, fun x ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ apply continuous_tsum (fun n ‚Ü¶ continuous_const.mul (f n).continuous) u_sum (fun n x ‚Ü¶ ?_)
    simpa [abs_of_nonneg, (u_pos n).le, (f_range n x).1] using I n x
  ¬∑ apply Subset.antisymm (fun x hx ‚Ü¶ by simp [fs _ hx, hu]) ?_
    apply compl_subset_compl.1
    intro x hx
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, x ‚àâ U n := by simpa [hU] using hx
    have fnx : f n x = 0 := fm _ (by simp [hn])
    have : g x < 1 := by
      apply lt_of_lt_of_le ?_ hu.le
      exact tsum_lt_tsum (i := n) (fun i ‚Ü¶ I i x) (by simp [fnx, u_pos n]) (S x) u_sum
    simpa using this.ne
  ¬∑ exact HasCompactSupport.of_support_subset_isCompact m_comp
      (Function.support_subset_iff'.mpr hgmc)
  ¬∑ exact tsum_nonneg (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1) (fun n ‚Ü¶ I n x) u_sum
  refine ‚ü®‚ü®g, ?_‚ü©, ?_, hgmc.mono (subset_compl_comm.mp mt), ?_, fun x ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ apply continuous_tsum (fun n ‚Ü¶ continuous_const.mul (f n).continuous) u_sum (fun n x ‚Ü¶ ?_)
    simpa [abs_of_nonneg, (u_pos n).le, (f_range n x).1] using I n x
  ¬∑ apply Subset"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Œµ hŒµ).mono fun y hy => _
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  simp made no progress
warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metri"
Mathlib/LinearAlgebra/FiniteDimensional.lean,Submodule.eq_top_of_finrank_eq,_root_.Submodule.eq_top_of_finrank_eq,76e6a78efcb1b11e117600191db6d147aeeeb85d,":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V).incl :=
    @LinearIndependent.image_subtype _ _ _ _ _ _ _ _ _ (Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent (by simpa using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_val, ‚Üê this,
    ‚ÜêSubmodule.coeSubtype, span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_val] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]","error:  invalid field 'incl', the environment does not contain 'Set.incl'
  ?m.77824 '' Basis.ofVectorSpaceIndex K ‚Ü•S
has type
  Set V
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  ?m.77824 '' Basis.ofVectorSpaceIndex K ‚Ü•S
has type
  V ‚Üí Prop
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information","theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ‚ä§ ",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V).incl :=
    @LinearIndependent.image_subtype _ _ _ _ _ _ _ _ (Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
             finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_val, ‚Üê this,
    ‚ÜêSubmodule.coeSubtype, span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_val] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]"
Mathlib/Topology/Algebra/InfiniteSum/Basic.lean,Function.Injective.tprod_eq,Function.Injective.tprod_eq,3b0baa425c7f4e18fdeeb7271bf104ecfee0d57a,":= by
  have : mulSupport f = g '' mulSupport (f ‚àò g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [‚Üê Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  ¬∑ have hfg_fin : (mulSupport (f ‚àò g)).Finite := hf_fin.preimage hg.injOn
    lift g to Œ≥ ‚Ü™ Œ≤ using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ‚Üê Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ‚Ü¶ rfl
    simp [this]
  ¬∑ have hf_fin' : ¬¨ Set.Finite (mulSupport (f ‚àò g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      hg.hasProd_iff (mulSupport_subset_iff'.1 hf)]","error:  unsolved goals
case neg
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œ¥ : Type u_4
inst‚úù¬π : CommMonoid Œ±
inst‚úù : TopologicalSpace Œ±
f‚úù g‚úù : Œ≤ ‚Üí Œ±
a a‚ÇÅ a‚ÇÇ : Œ±
g : Œ≥ ‚Üí Œ≤
hg : Injective g
f : Œ≤ ‚Üí Œ±
hf : mulSupport f ‚äÜ Set.range g
this : mulSupport f = g '' mulSupport (f ‚àò g)
hf_fin : ¬¨(mulSupport f).Finite
hf_fin' : ¬¨(mulSupport (f ‚àò g)).Finite
‚ä¢ (if h : ‚àÉ a, HasProd f a then Exists.choose ‚ãØ else 1) =
    if h : ‚àÉ a, HasProd (fun b ‚Ü¶ f b) a then Exists.choose ‚ãØ else 1","theorem Function.Injective.tprod_eq {g : Œ≥ ‚Üí Œ≤} (hg : Injective g) {f : Œ≤ ‚Üí Œ±}
    (hf : mulSupport f ‚äÜ Set.range g) : ‚àè' c, f (g c) = ‚àè' b, f b ",":= by
  have : mulSupport f = g '' mulSupport (f ‚àò g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [‚Üê Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  ¬∑ have hfg_fin : (mulSupport (f ‚àò g)).Finite := hf_fin.preimage hg.injOn
    lift g to Œ≥ ‚Ü™ Œ≤ using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ‚Üê Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ‚Ü¶ rfl
    simp [this]
  ¬∑ have hf_fin' : ¬¨ Set.Finite (mulSupport (f ‚àò g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      funext fun a => propext <| hg.hasProd_iff (mulSupport_subset_iff'.1 hf) (a := a)]",":= by
  have : mulSupport f = g '' mulSupport (f ‚àò g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [‚Üê Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  ¬∑ have hfg_fin : (mulSupport (f ‚àò g)).Finite := hf_fin.preimage hg.injOn
    lift g to Œ≥ ‚Ü™ Œ≤ using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ‚Üê Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ‚Ü¶ rfl
    simp [this]
  ¬∑ have hf_fin' : ¬¨ Set.Finite (mulSupport (f ‚àò g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      hg.hasProd_iff mulSupport_subset_iff'.1 hf]"
Mathlib/Data/Fin/Tuple/Basic.lean,Fin.isSome_find_iff,isSome_find_iff,b57ede590c8e21e71ba026c0b434dec2631ccd28,"  | 0, p, _ => iff_of_false (fun h ‚Ü¶ Bool.noConfusion h) fun ‚ü®i, _‚ü© ‚Ü¶ Fin.elim0' i
  | n + 1, p, _ =>
    ‚ü®fun h ‚Ü¶ by
      rw [Option.isSome_iff_exists] at h
      cases' h with i hi
      exact ‚ü®i, find_spec _ hi‚ü©, fun ‚ü®‚ü®i, hin‚ü©, hi‚ü© ‚Ü¶ by
      dsimp [find]
      cases' h : find fun i : Fin n ‚Ü¶ p (i.castLt (Nat.lt_succ_of_lt i.2)) with j
      ¬∑ split_ifs with hl
        ¬∑ exact Option.isSome_some
        ¬∑ have := (@isSome_find_iff n (fun x ‚Ü¶ p (x.castLt (Nat.lt_succ_of_lt x.2))) _).2
              ‚ü®‚ü®i, lt_of_le_of_ne (Nat.le_of_lt_succ hin) fun h ‚Ü¶ by cases h; exact hl hi‚ü©, hi‚ü©
          rw [h] at this
          exact this
      ¬∑ simp‚ü©","error:  unknown constant 'Fin.elim0''
error:  invalid field 'castLt', the environment does not contain 'Fin.castLt'
  i
has type
  Fin n
error:  type mismatch
  Option.isSome_some
has type
  (some ?m.111999).isSome = true : Prop
but is expected to have type
  (Option.rec (some (last n)) (fun val ‚Ü¶ some (val.castLT ‚ãØ)) (find fun i ‚Ü¶ p (i.castLT ‚ãØ))).isSome = true : Prop
error:  invalid field 'castLt', the environment does not contain 'Fin.castLt'
  x
has type
  Fin n
error:  type mismatch
  this
has type
  none.isSome = true : Prop
but is expected to have type
  (Option.rec none (fun val ‚Ü¶ some (val.castLT ‚ãØ)) (find fun i ‚Ü¶ p (i.castLT ‚ãØ))).isSome = true : Prop
error:  simp made no progress","theorem isSome_find_iff :
    ‚àÄ {n : ‚Ñï} {p : Fin n ‚Üí Prop} [DecidablePred p], (find p).isSome ‚Üî ‚àÉ i, p i
","  | 0, p, _ => iff_of_false (fun h ‚Ü¶ Bool.noConfusion h) fun ‚ü®i, _‚ü© ‚Ü¶ Fin.elim0 i
  | n + 1, p, _ =>
    ‚ü®fun h ‚Ü¶ by
      rw [Option.isSome_iff_exists] at h
      cases' h with i hi
      exact ‚ü®i, find_spec _ hi‚ü©, fun ‚ü®‚ü®i, hin‚ü©, hi‚ü© ‚Ü¶ by
      dsimp [find]
      cases' h : find fun i : Fin n ‚Ü¶ p (i.castLT (Nat.lt_succ_of_lt i.2)) with j
      ¬∑ split_ifs with hl
        ¬∑ exact Option.isSome_some
        ¬∑ have := (@isSome_find_iff n (fun x ‚Ü¶ p (x.castLT (Nat.lt_succ_of_lt x.2))) _).2
              ‚ü®‚ü®i, lt_of_le_of_ne (Nat.le_of_lt_succ hin) fun h ‚Ü¶ by cases h; exact hl hi‚ü©, hi‚ü©
          rw [h] at this
          exact this
      ¬∑ simp‚ü©",":= by
  | 0, p, _ => iff_of_false (fun h ‚Ü¶ Bool.noConfusion h) fun ‚ü®i, _‚ü© ‚Ü¶ Fin.elim0' i
  | n + 1, p, _ =>
    ‚ü®fun h ‚Ü¶ by
      rw [Option.isSome_iff_exists] at h
      cases' h with i hi
      exact ‚ü®i, find_spec _ hi‚ü©, fun ‚ü®‚ü®i, hin‚ü©, hi‚ü© ‚Ü¶ by
      dsimp [find]
      cases' h : find fun i : Fin n ‚Ü¶ p (i.castLt (Nat.lt_succ_of_lt i.2)) with j
      ¬∑ split_ifs with hl
        ¬∑ exact Option.isSome_some
        ¬∑ have := (@isSome_find_iff n (fun x ‚Ü¶ p (x.castLt (Nat.lt_succ_of_lt x.2))) _).2
              ‚ü®‚ü®i, lt_of_le_of_ne (Nat.le_of_lt_succ hin) fun h ‚Ü¶ by cases h; exact hl hi‚ü©, hi‚ü©
          rw [h] at this
          exact this
      ¬∑ simp‚ü©"
Mathlib/Algebra/Lie/Sl2.lean,IsSl2Triple.HasPrimitiveVectorWith.lie_e_pow_succ_toEnd_f,lie_e_pow_succ_toEnd_f,a85667469c48905c0ce3d6913968a001d5d43a18,":= by
  induction' n with n ih
  ¬∑ simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, sub_zero, one_mul,
      pow_zero, LinearMap.one_apply, leibniz_lie e, t.lie_e_f, P.lie_e, P.lie_h, lie_zero,
      add_zero]
  ¬∑ rw [pow_succ', LinearMap.mul_apply, toEnd_apply_apply, leibniz_lie e, t.lie_e_f,
      lie_h_pow_toEnd_f P, ih, lie_smul, lie_f_pow_toEnd_f, ‚Üê add_smul,
      Nat.cast_add, Nat.cast_one]
    congr
    ring","warning:  unused variable `P`
note: this linter can be disabled with `set_option linter.unusedVariables false`
error:  unsolved goals
case succ.P
R : Type u_1
L : Type u_2
M : Type u_3
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : LieRing L
inst‚úù‚Å¥ : LieAlgebra R L
inst‚úù¬≥ : AddCommGroup M
inst‚úù¬≤ : Module R M
inst‚úù¬π : LieRingModule L M
inst‚úù : LieModule R L M
h e f : L
m : M
Œº : R
t : IsSl2Triple h e f
P : t.HasPrimitiveVectorWith m Œº
n : ‚Ñï
ih : ‚ÅÖe, ((toEnd R L M) f ^ (n + 1)) m‚ÅÜ = ((‚Üën + 1) * (Œº - ‚Üën)) ‚Ä¢ ((toEnd R L M) f ^ n) m
‚ä¢ ?m.66709.HasPrimitiveVectorWith m ?m.66708

R : Type u_1
L : Type u_2
M : Type u_3
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : LieRing L
inst‚úù‚Å¥ : LieAlgebra R L
inst‚úù¬≥ : AddCommGroup M
inst‚úù¬≤ : Module R M
inst‚úù¬π : LieRingModule L M
inst‚úù : LieModule R L M
h e f : L
m : M
Œº : R
t : IsSl2Triple h e f
P : t.HasPrimitiveVectorWith m Œº
n : ‚Ñï
ih : ‚ÅÖe, ((toEnd R L M) f ^ (n + 1)) m‚ÅÜ = ((‚Üën + 1) * (Œº - ‚Üën)) ‚Ä¢ ((toEnd R L M) f ^ n) m
‚ä¢ L

R : Type u_1
L : Type u_2
M : Type u_3
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : LieRing L
inst‚úù‚Å¥ : LieAlgebra R L
inst‚úù¬≥ : AddCommGroup M
inst‚úù¬≤ : Module R M
inst‚úù¬π : LieRingModule L M
inst‚úù : LieModule R L M
h e f : L
m : M
Œº : R
t : IsSl2Triple h e f
P : t.HasPrimitiveVectorWith m Œº
n : ‚Ñï
ih : ‚ÅÖe, ((toEnd R L M) f ^ (n + 1)) m‚ÅÜ = ((‚Üën + 1) * (Œº - ‚Üën)) ‚Ä¢ ((toEnd R L M) f ^ n) m
‚ä¢ L

R : Type u_1
L : Type u_2
M : Type u_3
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : LieRing L
inst‚úù‚Å¥ : LieAlgebra R L
inst‚úù¬≥ : AddCommGroup M
inst‚úù¬≤ : Module R M
inst‚úù¬π : LieRingModule L M
inst‚úù : LieModule R L M
h e f : L
m : M
Œº : R
t : IsSl2Triple h e f
P : t.HasPrimitiveVectorWith m Œº
n : ‚Ñï
ih : ‚ÅÖe, ((toEnd R L M) f ^ (n + 1)) m‚ÅÜ = ((‚Üën + 1) * (Œº - ‚Üën)) ‚Ä¢ ((toEnd R L M) f ^ n) m
‚ä¢ R

R : Type u_1
L : Type u_2
M : Type u_3
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : LieRing L
inst‚úù‚Å¥ : LieAlgebra R L
inst‚úù¬≥ : AddCommGroup M
inst‚úù¬≤ : Module R M
inst‚úù¬π : LieRingModule L M
inst‚úù : LieModule R L M
h e f : L
m : M
Œº : R
t : IsSl2Triple h e f
P : t.HasPrimitiveVectorWith m Œº
n : ‚Ñï
ih : ‚ÅÖe, ((toEnd R L M) f ^ (n + 1)) m‚ÅÜ = ((‚Üën + 1) * (Œº - ‚Üën)) ‚Ä¢ ((toEnd R L M) f ^ n) m
‚ä¢ IsSl2Triple ?m.66704 ?m.66705 f","lemma lie_e_pow_succ_toEnd_f (n : ‚Ñï) :
    ‚ÅÖe, œà (n + 1)‚ÅÜ = ((n + 1) * (Œº - n)) ‚Ä¢ œà n ",":= by
  induction' n with n ih
  ¬∑ simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, sub_zero, one_mul,
      pow_zero, LinearMap.one_apply, leibniz_lie e, t.lie_e_f, P.lie_e, P.lie_h, lie_zero,
      add_zero]
  ¬∑ rw [pow_succ', LinearMap.mul_apply, toEnd_apply_apply, leibniz_lie e, t.lie_e_f,
      lie_h_pow_toEnd_f P, ih, lie_smul, lie_f_pow_toEnd_f P, ‚Üê add_smul,
      Nat.cast_add, Nat.cast_one]
    congr
    ring",":= by
  induction' n with n ih
  ¬∑ simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, sub_zero, one_mul,
      pow_zero, LinearMap.one_apply, leibniz_lie e, t.lie_e_f, P.lie_e, P.lie_h, lie_zero,
      add_zero]
  ¬∑ rw [pow_succ', LinearMap.mul_apply, toEnd_apply_apply, leibniz_lie e, t.lie_e_f,
      lie_h_pow_toEnd_f P, ih, lie_smul, lie_f_pow_toEnd_f, ‚Üê add_smul,
      Nat.cast_add, Nat.cast_one]
    congr
    ring"
Mathlib/Topology/Order/ScottTopology.lean,Topology.IsScott.lowerClosure_subset_closure,lowerClosure_subset_closure,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  convert closure.mono (@upperSet_le_scott Œ± _)
  ¬∑ rw [@IsUpperSet.closure_eq_lowerClosure Œ± _ (upperSet Œ±) ?_ s]
    exact instIsUpperSetUpperSet
  ¬∑ exact topology_eq Œ±",error:  unknown identifier 'instIsUpperSetUpperSet',lemma lowerClosure_subset_closure : ‚Üë(lowerClosure s) ‚äÜ closure s ,":= by
  convert closure.mono (@upperSet_le_scott Œ± _)
  ¬∑ rw [@IsUpperSet.closure_eq_lowerClosure Œ± _ (upperSet Œ±) ?_ s]
    infer_instance
  ¬∑ exact topology_eq Œ±",":= by
  convert closure.mono (@upperSet_le_scott Œ± _)
  ¬∑ rw [@IsUpperSet.closure_eq_lowerClosure Œ± _ (upperSet Œ±) ?_ s]
    exact instIsUpperSetUpperSet"
Mathlib/Algebra/Homology/QuasiIso.lean,quasiIsoAt_iff,quasiIsoAt_iff,4773ba7abb162ea632c1ff5810cd5f45a1289422,:= by,"error:  unexpected token 'instance'; expected '{' or tactic
error:  unsolved goals
Œπ‚úù : Type u_1
Œπ : Type u_2
C : Type u
inst‚úù¬≥ : Category.{v, u} C
inst‚úù¬≤ : HasZeroMorphisms C
c : ComplexShape Œπ
K L M K' L' : HomologicalComplex C c
f : K ‚ü∂ L
i : Œπ
inst‚úù¬π : K.HasHomology i
inst‚úù : L.HasHomology i
‚ä¢ QuasiIsoAt f i ‚Üî ShortComplex.QuasiIso ((shortComplexFunctor C c i).map f)","lemma quasiIsoAt_iff (f : K ‚ü∂ L) (i : Œπ) [K.HasHomology i] [L.HasHomology i] :
    QuasiIsoAt f i ‚Üî
      ShortComplex.QuasiIso ((shortComplexFunctor C c i).map f) ",":= by
  constructor
  ¬∑ intro h
    exact h.quasiIso
  ¬∑ intro h
    exact ‚ü®h‚ü©",":= by
  rw [quasiIsoAt_iff_isZero_homology]"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,2a90eb4867f981311713f9efea480617e45964b9,":= by
  refine' ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, _‚ü©, rfl‚ü©, _‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := isIntegral_sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)","error:  function expected at
  le_integralClosure_iff_isIntegral.mp (adjoin_le_integralClosure (IsPrimitiveRoot.isIntegral hŒ∂ (PNat.pos (p ^ k))))
term has type
  Algebra.IsIntegral ‚Ñ§ ‚Ü•(adjoin ‚Ñ§ {Œ∂})
error:  unknown identifier 'isIntegral_sub'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë(?m ^ ?n)
case refine'_1.intro.intro
p : ‚Ñï+
k : ‚Ñï
K : Type u
inst‚úù¬π : Field K
inst‚úù : CharZero K
Œ∂ : K
hp : Fact (Nat.Prime ‚Üëp)
hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)
x : K
h : IsIntegral ‚Ñ§ x
B : PowerBasis ‚Ñö K := IsPrimitiveRoot.subOnePowerBasis ‚Ñö hŒ∂
hint : IsIntegral ‚Ñ§ B.gen
this : FiniteDimensional ‚Ñö K := finiteDimensional {p ^ k} ‚Ñö K
u : ‚Ñ§À£
n : ‚Ñï
hun : Algebra.discr ‚Ñö ‚áë(IsPrimitiveRoot.subOnePowerBasis ‚Ñö hŒ∂).basis = ‚Üë‚Üëu * ‚Üë‚Üëp ^ n
H : ‚Üë‚Üëp ^ n ‚Ä¢ x ‚àà adjoin ‚Ñ§ {B.gen}
‚ä¢ x ‚àà adjoin ‚Ñ§ {Œ∂}","theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)) : IsIntegralClosure (adjoin ‚Ñ§ ({Œ∂} : Set K)) ‚Ñ§ K ",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := isIntegral_sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adj"
Mathlib/Algebra/Category/ModuleCat/Free.lean,ModuleCat.linearIndependent_leftExact,linearIndependent_leftExact,06295115e02029d99354c51425dc11539f40347b,":=
  linearIndependent_sum.mpr
  ‚ü®(congr_arg (fun f ‚Ü¶ LinearIndependent R f) huv).mpr
    ((LinearMap.linearIndependent_iff (f : N ‚Üí‚Çó[R] M)
    (LinearMap.ker_eq_bot.mpr ((mono_iff_injective _).mp hm))).mpr hv),
    LinearIndependent.of_comp g hw, disjoint_span_sum hw he huv‚ü©","error:  unknown identifier 'N'
error:  unknown identifier 'M'
error:  unknown identifier 'f'
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'linearIndependent_leftExact'
error:  application type mismatch
  linearIndependent_shortExact hS'
argument
  hS'
has type
  S.ShortExact : Prop
but is expected to have type
  LinearIndependent ?m.67223 ?m.67227 : Prop",theorem linearIndependent_leftExact : LinearIndependent R u ,":= by
  rw [linearIndependent_sum]
  refine ‚ü®?_, LinearIndependent.of_comp S.g hw, disjoint_span_sum hS hw huv‚ü©
  rw [huv, LinearMap.linearIndependent_iff S.f]; swap
  ¬∑ rw [LinearMap.ker_eq_bot, ‚Üê mono_iff_injective]
    infer_instance
  exact hv",":=
  linearIndependent_sum.mpr
  ‚ü®(congr_arg (fun f ‚Ü¶ LinearIndependent R f) huv).mpr
    ((LinearMap.linearIndependent_iff (f : N ‚Üí‚Çó[R] M))).mpr hv),
    LinearIndependent.of_comp g hw, disjoint_span_sum hw he huv‚ü©"
Mathlib/Geometry/Manifold/VectorBundle/Basic.lean,Bundle.contMDiffWithinAt_totalSpace,contMDiffWithinAt_totalSpace,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp, LocalEquiv.trans_apply,
    LocalEquiv.prod_coe, LocalEquiv.refl_coe, extChartAt_self_apply, modelWithCornersSelf_coe,
    id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, LocalHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]","error:  unknown identifier 'LocalEquiv.trans_apply'
error:  simp made no progress","theorem contMDiffWithinAt_totalSpace (f : M ‚Üí TotalSpace F E) {s : Set M} {x‚ÇÄ : M} :
    ContMDiffWithinAt IM (IB.prod ùìò(ùïú, F)) n f s x‚ÇÄ ‚Üî
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s x‚ÇÄ ‚àß
      ContMDiffWithinAt IM ùìò(ùïú, F) n (fun x ‚Ü¶ (trivializationAt F E (f x‚ÇÄ).proj (f x)).2) s x‚ÇÄ ",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,
    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, ‚Üê chartedSpaceSelf_prod]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp, LocalEquiv.trans_apply,
    LocalEquiv.prod_coe, LocalEquiv.refl_coe, extChartAt_self_apply, modelWithCornersSelf_coe,
    id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, LocalHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]"
Mathlib/Data/Set/Pointwise/Finite.lean,Set.finite_mul,finite_mul,0050ac58975fb70b2cce3bfd5ac6fdf88f1900a0,":=
  finite_image2 (fun _ _ ‚Ü¶ (mul_left_injective _).injOn _)
    fun _ _ ‚Ü¶ (mul_right_injective _).injOn _","error:  type mismatch
  Function.Injective.injOn (mul_left_injective ?m.6098) ?m.6166
has type
  ‚àÄ ‚¶Éx‚ÇÇ : ?m.6156‚¶Ñ, x‚ÇÇ ‚àà ?m.6164 ‚Üí ?m.6165 * ?m.6098 = x‚ÇÇ * ?m.6098 ‚Üí ?m.6165 = x‚ÇÇ : Prop
but is expected to have type
  InjOn (fun x ‚Ü¶ x * x‚úù¬π) s : Prop
error:  type mismatch
  Function.Injective.injOn (mul_right_injective ?m.6436) ?m.6504
has type
  ‚àÄ ‚¶Éx‚ÇÇ : ?m.6494‚¶Ñ, x‚ÇÇ ‚àà ?m.6502 ‚Üí ?m.6436 * ?m.6503 = ?m.6436 * x‚ÇÇ ‚Üí ?m.6503 = x‚ÇÇ : Prop
but is expected to have type
  InjOn (fun x ‚Ü¶ x‚úù¬π * x) t : Prop",lemma finite_mul : (s * t).Finite ‚Üî s.Finite ‚àß t.Finite ‚à® s = ‚àÖ ‚à® t = ‚àÖ ,":=
  finite_image2  (fun _ _ ‚Ü¶ (mul_left_injective _).injOn)
    fun _ _ ‚Ü¶ (mul_right_injective _).injOn",":=
  finite_image2 (fun _ _ ‚Ü¶ (mul_left_injective _).injOn)
  fun _ _ ‚Ü¶ (mul_right_injective _).injOn"
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.evaln_prim,evaln_prim,ad88a031b67d9f51d39379f0e5f82a31c1929202,":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.get?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        cases evaln k cg n <;> rfl
      ¬∑ cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      ¬∑ cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      ¬∑ have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to‚ÇÇ).of_eq
    fun ‚ü®‚ü®k, c‚ü©, n‚ü© => by simp [evaln_map]","warning:  `List.map_congr` has been deprecated, use `List.map_congr_left` instead
error:  unknown identifier 'lt_succ_iff'
warning:  `List.get?_range` has been deprecated, use `List.getElem?_range` instead
error:  unsolved goals
x‚úù : Unit
p n : ‚Ñï
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
c : Code
k' : ‚Ñï
k : ‚Ñï := k' + 1
nk : n < k' + 1
k‚ÇÅ : ‚Ñï
c‚ÇÅ : Code
n‚ÇÅ : ‚Ñï
hl : Nat.pair k‚ÇÅ (encode c‚ÇÅ) < Nat.pair k (encode c)
‚ä¢ ((Option.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
          (List.range (Nat.pair k (encode c)))[Nat.pair k‚ÇÅ (encode c‚ÇÅ)]?).bind
      fun a ‚Ü¶ a[n‚ÇÅ]?.bind fun a ‚Ü¶ a) =
    evaln k‚ÇÅ c‚ÇÅ n‚ÇÅ
error:  unknown identifier 'cf'
error:  unknown identifier 'cg'
error:  unknown identifier 'cf'
error:  unknown identifier 'cg'
error:  unknown identifier 'cf'
error:  unknown identifier 'cg'
error:  unknown identifier 'cf'
error:  unsolved goals
case succ.pair
x‚úù : Unit
p n : ‚Ñï
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
k' : ‚Ñï
k : ‚Ñï := k' + 1
nk : n < k' + 1
cf cg : Code
hg :
  ‚àÄ {k' : ‚Ñï} {c' : Code} {n : ‚Ñï},
    Nat.pair k' (encode c') < Nat.pair k (encode (cf.pair cg)) ‚Üí
      Nat.Partrec.Code.lup
          (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair k (encode (cf.pair cg)))))
          (k', c') n =
        evaln k' c' n
‚ä¢ ((Nat.Partrec.Code.lup
          (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair (k' + 1) (encode (cf.pair cg)))))
          (k' + 1, cf) n).bind
      fun a ‚Ü¶
      (Nat.Partrec.Code.lup
            (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
              (List.range (Nat.pair (k' + 1) (encode (cf.pair cg)))))
            (k' + 1, cg) n).bind
        fun y ‚Ü¶ some (Nat.pair a y)) =
    (guard (n ‚â§ k')).bind fun a ‚Ü¶
      (Option.map Nat.pair (evaln (k' + 1) cf n)).bind fun a ‚Ü¶ Option.map a (evaln (k' + 1) cg n)

case succ.comp
x‚úù : Unit
p n : ‚Ñï
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
k' : ‚Ñï
k : ‚Ñï := k' + 1
nk : n < k' + 1
cf cg : Code
hg :
  ‚àÄ {k' : ‚Ñï} {c' : Code} {n : ‚Ñï},
    Nat.pair k' (encode c') < Nat.pair k (encode (cf.comp cg)) ‚Üí
      Nat.Partrec.Code.lup
          (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair k (encode (cf.comp cg)))))
          (k', c') n =
        evaln k' c' n
‚ä¢ ((Nat.Partrec.Code.lup
          (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair (k' + 1) (encode (cf.comp cg)))))
          (k' + 1, cg) n).bind
      fun x ‚Ü¶
      Nat.Partrec.Code.lup
        (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
          (List.range (Nat.pair (k' + 1) (encode (cf.comp cg)))))
        (k' + 1, cf) x) =
    (guard (n ‚â§ k')).bind fun a ‚Ü¶ (evaln (k' + 1) cg n).bind fun x ‚Ü¶ evaln (k' + 1) cf x

case succ.prec
x‚úù : Unit
p n : ‚Ñï
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
k' : ‚Ñï
k : ‚Ñï := k' + 1
nk : n < k' + 1
cf cg : Code
hg :
  ‚àÄ {k' : ‚Ñï} {c' : Code} {n : ‚Ñï},
    Nat.pair k' (encode c') < Nat.pair k (encode (cf.prec cg)) ‚Üí
      Nat.Partrec.Code.lup
          (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair k (encode (cf.prec cg)))))
          (k', c') n =
        evaln k' c' n
‚ä¢ Nat.rec
      (Nat.Partrec.Code.lup
        (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
          (List.range (Nat.pair (k' + 1) (encode (cf.prec cg)))))
        (k' + 1, cf) (unpair n).1)
      (fun n_1 n_ih ‚Ü¶
        (Nat.Partrec.Code.lup
              (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
                (List.range (Nat.pair (k' + 1) (encode (cf.prec cg)))))
              (k', cf.prec cg) (Nat.pair (unpair n).1 n_1)).bind
          fun i ‚Ü¶
          Nat.Partrec.Code.lup
            (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
              (List.range (Nat.pair (k' + 1) (encode (cf.prec cg)))))
            (k' + 1, cg) (Nat.pair (unpair n).1 (Nat.pair n_1 i)))
      (unpair n).2 =
    (guard (n ‚â§ k')).bind fun a ‚Ü¶
      Nat.rec (evaln (k' + 1) cf (unpair n).1)
        (fun n_1 n_ih ‚Ü¶
          (evaln k' (cf.prec cg) (Nat.pair (unpair n).1 n_1)).bind fun i ‚Ü¶
            evaln (k' + 1) cg (Nat.pair (unpair n).1 (Nat.pair n_1 i)))
        (unpair n).2

case succ.rfind'
x‚úù : Unit
p n : ‚Ñï
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
k' : ‚Ñï
k : ‚Ñï := k' + 1
nk : n < k' + 1
cf : Code
hg :
  ‚àÄ {k' : ‚Ñï} {c' : Code} {n : ‚Ñï},
    Nat.pair k' (encode c') < Nat.pair k (encode cf.rfind') ‚Üí
      Nat.Partrec.Code.lup
          (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair k (encode cf.rfind'))))
          (k', c') n =
        evaln k' c' n
‚ä¢ ((Nat.Partrec.Code.lup
          (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair (k' + 1) (encode cf.rfind'))))
          (k' + 1, cf) n).bind
      fun x ‚Ü¶
      Nat.rec (some (unpair n).2)
        (fun n_1 n_ih ‚Ü¶
          Nat.Partrec.Code.lup
            (List.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
              (List.range (Nat.pair (k' + 1) (encode cf.rfind'))))
            (k', cf.rfind') (Nat.pair (unpair n).1 ((unpair n).2 + 1)))
        x) =
    (guard (n ‚â§ k')).bind fun a ‚Ü¶
      (evaln (k' + 1) cf n).bind fun a ‚Ü¶
        if a = 0 then some (unpair n).2 else evaln k' cf.rfind' (Nat.pair (unpair n).1 ((unpair n).2 + 1))",theorem evaln_prim : Primrec fun a : (‚Ñï √ó Code) √ó ‚Ñï => evaln a.1.1 a.1.2 a.2 ,":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr_left fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.getElem?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        cases evaln k cg n <;> rfl
      ¬∑ cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      ¬∑ cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      ¬∑ have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to‚ÇÇ).of_eq
    fun ‚ü®‚ü®k, c‚ü©, n‚ü© => by simp [evaln_map]",":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.get?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Opti"
Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean,CochainComplex.HomComplex.Œ¥_shape,Œ¥_shape,2c367bb7cdc3187abec81c2896087d55449d9b24,":= by
  ext ‚ü®p, q, hpq‚ü©
  dsimp [Œ¥, Cochain.v, Cochain.mk]
  rw [F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  . rfl
  all_goals
    change ¬¨ _=_
    rintro h
    apply hnm
    linarith","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case h.ofNat.zero.a
C : Type u
inst‚úù¬≥ : Category.{v, u} C
inst‚úù¬≤ : Preadditive C
R : Type u_1
inst‚úù¬π : Ring R
inst‚úù : Linear R C
F G K L : CochainComplex C ‚Ñ§
n m : ‚Ñ§
hnm : ¬¨n + 1 = m
z : Cochain F G n
q‚úù : ‚Ñ§
hpq‚úù : Int.ofNat 0 + m = q‚úù
‚ä¢ ¬¨(ComplexShape.up ‚Ñ§).Rel (0 + n) q‚úù
error:  unsolved goals
case h.ofNat.succ
C : Type u
inst‚úù¬≥ : Category.{v, u} C
inst‚úù¬≤ : Preadditive C
R : Type u_1
inst‚úù¬π : Ring R
inst‚úù : Linear R C
F G K L : CochainComplex C ‚Ñ§
n m : ‚Ñ§
hnm : ¬¨n + 1 = m
z : Cochain F G n
n‚úù : ‚Ñï
q‚úù : ‚Ñ§
hpq‚úù : Int.ofNat (n‚úù + 1) + m = q‚úù
‚ä¢ (Œ¥ n m z).v (Int.ofNat (n‚úù + 1)) q‚úù hpq‚úù = Cochain.v 0 (Int.ofNat (n‚úù + 1)) q‚úù hpq‚úù

case h.negSucc
C : Type u
inst‚úù¬≥ : Category.{v, u} C
inst‚úù¬≤ : Preadditive C
R : Type u_1
inst‚úù¬π : Ring R
inst‚úù : Linear R C
F G K L : CochainComplex C ‚Ñ§
n m : ‚Ñ§
hnm : ¬¨n + 1 = m
z : Cochain F G n
a‚úù : ‚Ñï
q‚úù : ‚Ñ§
hpq‚úù : Int.negSucc a‚úù + m = q‚úù
‚ä¢ (Œ¥ n m z).v (Int.negSucc a‚úù) q‚úù hpq‚úù = Cochain.v 0 (Int.negSucc a‚úù) q‚úù hpq‚úù",lemma Œ¥_shape (hnm : ¬¨ n + 1 = m) (z : Cochain F G n) : Œ¥ n m z = 0 ,":= by
  ext p q hpq
  dsimp only [Œ¥]
  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  all_goals
    simp only [ComplexShape.up_Rel]
    exact fun _ => hnm (by omega)",":= by
  ext ‚ü®p, q, hpq‚ü©
  dsimp [Œ¥, Cochain.v, Cochain.mk]
  rw [F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  ¬∑ rfl
  all_goals
    change ¬¨ _=>
    rintro h
    apply hnm
    linarith"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  refine' ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, _‚ü©, rfl‚ü©, _‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := IsIntegral.sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)","error:  function expected at
  le_integralClosure_iff_isIntegral.mp (adjoin_le_integralClosure (IsPrimitiveRoot.isIntegral hŒ∂ (PNat.pos (p ^ k))))
term has type
  Algebra.IsIntegral ‚Ñ§ ‚Ü•(adjoin ‚Ñ§ {Œ∂})
error:  unknown constant 'StrictOrderedSemiring.to_charZero'","theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)) : IsIntegralClosure (adjoin ‚Ñ§ ({Œ∂} : Set K)) ‚Ñ§ K ",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := IsIntegral.sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjoin"
Mathlib/Probability/Martingale/Upcrossing.lean,MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part,Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part,9e34a191034458a56331f976ff7400a26407c888,":= by
  by_cases hab : a < b
  ¬∑ simp_rw [upcrossings]
    have : ‚àÄ N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº = ENNReal.ofReal (‚à´ œâ, (f N œâ - a)‚Å∫ ‚àÇŒº) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      ¬∑ exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      ¬∑ exact eventually_of_forall fun œâ => LatticeOrderedGroup.pos_nonneg _
    rw [lintegral_iSup']
    ¬∑ simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          ‚à´‚Åª œâ, upcrossingsBefore a b f N œâ ‚àÇŒº = ‚à´‚Åª œâ, ‚Üë(upcrossingsBefore a b f N œâ : ‚Ñù‚â•0) ‚àÇŒº),
        lintegral_coe_eq_integral, ‚Üê ENNReal.ofReal_mul (sub_pos.2 hab).le]
      ¬∑ simp_rw [NNReal.coe_nat_cast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Œ± := ‚Ñù‚â•0‚àû) _ N)
      ¬∑ simp only [NNReal.coe_nat_cast, hf.adapted.integrable_upcrossingsBefore hab]
    ¬∑ exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    ¬∑ refine' eventually_of_forall fun œâ N M hNM => _
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM œâ
  ¬∑ rw [not_lt, ‚Üê sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, MulZeroClass.zero_mul]
    exact zero_le _","error:  unknown identifier 'LatticeOrderedGroup.pos_nonneg'
warning:  `NNReal.coe_nat_cast` has been deprecated, use `NNReal.coe_natCast` instead
warning:  `NNReal.coe_nat_cast` has been deprecated, use `NNReal.coe_natCast` instead","theorem Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part [IsFiniteMeasure Œº] (a b : ‚Ñù)
    (hf : Submartingale f ‚Ñ± Œº) : ENNReal.ofReal (b - a) * ‚à´‚Åª œâ, upcrossings a b f œâ ‚àÇŒº ‚â§
      ‚®Ü N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº ",":= by
  by_cases hab : a < b
  ¬∑ simp_rw [upcrossings]
    have : ‚àÄ N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº = ENNReal.ofReal (‚à´ œâ, (f N œâ - a)‚Å∫ ‚àÇŒº) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      ¬∑ exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      ¬∑ exact eventually_of_forall fun œâ => posPart_nonneg _
    rw [lintegral_iSup']
    ¬∑ simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          ‚à´‚Åª œâ, upcrossingsBefore a b f N œâ ‚àÇŒº = ‚à´‚Åª œâ, ‚Üë(upcrossingsBefore a b f N œâ : ‚Ñù‚â•0) ‚àÇŒº),
        lintegral_coe_eq_integral, ‚Üê ENNReal.ofReal_mul (sub_pos.2 hab).le]
      ¬∑ simp_rw [NNReal.coe_natCast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Œ± := ‚Ñù‚â•0‚àû) _ N)
      ¬∑ simp only [NNReal.coe_natCast, hf.adapted.integrable_upcrossingsBefore hab]
    ¬∑ exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    ¬∑ filter_upwards with œâ N M hNM
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM œâ
  ¬∑ rw [not_lt, ‚Üê sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]
    exact zero_le _",":= by
  by_cases hab : a < b
  ¬∑ simp_rw [upcrossings]
    have : ‚àÄ N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº = ENNReal.ofReal (‚à´ œâ, (f N œâ - a)‚Å∫ ‚àÇŒº) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      ¬∑ exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      ¬∑ exact eventually_of_forall fun œâ => LatticeOrderedGroup.pos_nonneg _
    rw [lintegral_iSup']
    ¬∑ simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          ‚à´‚Åª œâ, upcrossingsBefore a b f N œâ ‚àÇŒº = ‚à´‚Åª œâ, ‚Üë(upcrossingsBefore a b f N œâ : ‚Ñù‚â•0) ‚àÇŒº),
        lintegral_coe_eq_integral, ‚Üê ENNReal.ofReal_mul (sub_pos.2 hab).le]
      ¬∑ simp_rw [NNReal.coe_natCast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Œ± := ‚Ñù‚â•0‚àû) _ N)
      ¬∑ simp only [NNReal.coe_natCast, hf.adapted.integrable_upcrossingsBefore hab]
    ¬∑ exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    ¬∑ refine eventually_of_forall fun œâ N M hNM => ?_
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM œâ
  ¬∑ rw [not_lt, ‚Üê sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, MulZeroClass.zero_mul]
    exact zero_le _"
Mathlib/Analysis/InnerProductSpace/Projection.lean,norm_eq_iInf_iff_real_inner_le_zero,norm_eq_iInf_iff_real_inner_le_zero,62d9043180b905be3831b04ec3a951cd1adb5c31,":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel'_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v))
      ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            refine' this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num)
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine' le_add_of_nonneg_right _
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show (‚®Ö w : K, ‚Äñu - w‚Äñ) ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _","error:  unexpected identifier; expected '|'
error:  unsolved goals
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Å¥ : _root_.RCLike ùïú
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedAddCommGroup F
inst‚úù¬π : InnerProductSpace ùïú E
inst‚úù : InnerProductSpace ‚Ñù F
K : Set F
h : Convex ‚Ñù K
u v : F
hv : v ‚àà K
this‚úù : Nonempty ‚ÜëK := Nonempty.intro ‚ü®v, hv‚ü©
eq : ‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ
w : F
hw : w ‚àà K
Œ¥ : ‚Ñù := ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ
p : ‚Ñù := ‚ü™u - v, w - v‚ü´_‚Ñù
q : ‚Ñù := ‚Äñw - v‚Äñ ^ 2
Œ¥_le : ‚àÄ (w : ‚ÜëK), Œ¥ ‚â§ ‚Äñu - ‚Üëw‚Äñ
Œ¥_le' : ‚àÄ w ‚àà K, Œ¥ ‚â§ ‚Äñu - w‚Äñ
Œ∏ : ‚Ñù
hŒ∏‚ÇÅ : 0 < Œ∏
hŒ∏‚ÇÇ : Œ∏ ‚â§ 1
this : 0 ‚â§ Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù
eq‚ÇÅ :
  ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
    ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù)
eq‚ÇÇ : Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù = Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * ‚ü™u - v, w - v‚ü´_‚Ñù)
‚ä¢ 2 * p ‚â§ Œ∏ * q
error:  unsolved goals
case mp
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Å¥ : _root_.RCLike ùïú
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedAddCommGroup F
inst‚úù¬π : InnerProductSpace ùïú E
inst‚úù : InnerProductSpace ‚Ñù F
K : Set F
h : Convex ‚Ñù K
u v : F
hv : v ‚àà K
this‚úù : Nonempty ‚ÜëK := Nonempty.intro ‚ü®v, hv‚ü©
eq : ‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ
w : F
hw : w ‚àà K
Œ¥ : ‚Ñù := ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ
p : ‚Ñù := ‚ü™u - v, w - v‚ü´_‚Ñù
q : ‚Ñù := ‚Äñw - v‚Äñ ^ 2
Œ¥_le : ‚àÄ (w : ‚ÜëK), Œ¥ ‚â§ ‚Äñu - ‚Üëw‚Äñ
Œ¥_le' : ‚àÄ w ‚àà K, Œ¥ ‚â§ ‚Äñu - w‚Äñ
this : ‚àÄ (Œ∏ : ‚Ñù), 0 < Œ∏ ‚Üí Œ∏ ‚â§ 1 ‚Üí 2 * p ‚â§ Œ∏ * q
‚ä¢ ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0
error:  unsolved goals
case mpr
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Å¥ : _root_.RCLike ùïú
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedAddCommGroup F
inst‚úù¬π : InnerProductSpace ùïú E
inst‚úù : InnerProductSpace ‚Ñù F
K : Set F
h : Convex ‚Ñù K
u v : F
hv : v ‚àà K
this : Nonempty ‚ÜëK := Nonempty.intro ‚ü®v, hv‚ü©
‚ä¢ (‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0) ‚Üí ‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ","theorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ‚Ñù K) {u : F} {v : F}
    (hv : v ‚àà K) : (‚Äñu - v‚Äñ = ‚®Ö w : K, ‚Äñu - w‚Äñ) ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0 ",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel‚ÇÄ _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            exact this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num [Œ∏])
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine le_add_of_nonneg_right ?_
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
         _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
           simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
             rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                   absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) ("
Mathlib/Analysis/NormedSpace/MazurUlam.lean,IsometryEquiv.midpoint_fixed,midpoint_fixed,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  set z := midpoint ‚Ñù x y
  set s := { e : PE ‚âÉ·µ¢ PE | e x = x ‚àß e y = y }
  haveI : Nonempty s := ‚ü®‚ü®IsometryEquiv.refl PE, rfl, rfl‚ü©‚ü©
  have h_bdd : BddAbove (range fun e : s => dist ((e : PE ‚âÉ·µ¢ PE) z) z) := by
    refine' ‚ü®dist x z + dist x z, forall_range_iff.2 <| Subtype.forall.2 _‚ü©
    rintro e ‚ü®hx, _‚ü©
    calc
      dist (e z) z ‚â§ dist (e z) x + dist x z := dist_triangle (e z) x z
      _ = dist (e x) (e z) + dist x z := by rw [hx, dist_comm]
      _ = dist x z + dist x z := by erw [e.dist_eq x z]
  set R : PE ‚âÉ·µ¢ PE := (pointReflection ‚Ñù z).toIsometryEquiv
  set f : PE ‚âÉ·µ¢ PE ‚Üí PE ‚âÉ·µ¢ PE := fun e => ((e.trans R).trans e.symm).trans R
  have hf_dist : ‚àÄ e, dist (f e z) z = 2 * dist (e z) z := by
    intro e
    dsimp
    rw [dist_pointReflection_fixed, ‚Üê e.dist_eq, e.apply_symm_apply,
      dist_pointReflection_self_real, dist_comm]
  have hf_maps_to : MapsTo f s s := by
    rintro e ‚ü®hx, hy‚ü©
    constructor <;> simp [hx, hy, e.symm_apply_eq.2 hx.symm, e.symm_apply_eq.2 hy.symm]
  set c := ‚®Ü e : s, dist ((e : PE ‚âÉ·µ¢ PE) z) z
  have : c ‚â§ c / 2 := by
    apply ciSup_le
    rintro ‚ü®e, he‚ü©
    simp only [Subtype.coe_mk, le_div_iff' (zero_lt_two' ‚Ñù), ‚Üê hf_dist]
    exact le_ciSup h_bdd ‚ü®f e, hf_maps_to he‚ü©
  replace : c ‚â§ 0
  ¬∑ linarith
  refine' fun e hx hy => dist_le_zero.1 (le_trans _ this)
  exact le_ciSup h_bdd ‚ü®e, hx, hy‚ü©","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro.left
E : Type u_1
PE : Type u_2
F : Type u_3
PF : Type u_4
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : MetricSpace PE
inst‚úù‚Å¥ : NormedAddTorsor E PE
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : NormedSpace ‚Ñù F
inst‚úù¬π : MetricSpace PF
inst‚úù : NormedAddTorsor F PF
x y : PE
z : PE := midpoint ‚Ñù x y
s : Set (PE ‚âÉ·µ¢ PE) := {e | e x = x ‚àß e y = y}
this : Nonempty ‚Üës
h_bdd : BddAbove (range fun e ‚Ü¶ dist (‚Üëe z) z)
R : PE ‚âÉ·µ¢ PE := (pointReflection ‚Ñù z).toIsometryEquiv
f : PE ‚âÉ·µ¢ PE ‚Üí PE ‚âÉ·µ¢ PE := fun e ‚Ü¶ ((e.trans R).trans e.symm).trans R
hf_dist : ‚àÄ (e : PE ‚âÉ·µ¢ PE), dist ((f e) z) z = 2 * dist (e z) z
e : PE ‚âÉ·µ¢ PE
hx : e x = x
hy : e y = y
‚ä¢ (f e) x = x

case intro.right
E : Type u_1
PE : Type u_2
F : Type u_3
PF : Type u_4
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : MetricSpace PE
inst‚úù‚Å¥ : NormedAddTorsor E PE
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : NormedSpace ‚Ñù F
inst‚úù¬π : MetricSpace PF
inst‚úù : NormedAddTorsor F PF
x y : PE
z : PE := midpoint ‚Ñù x y
s : Set (PE ‚âÉ·µ¢ PE) := {e | e x = x ‚àß e y = y}
this : Nonempty ‚Üës
h_bdd : BddAbove (range fun e ‚Ü¶ dist (‚Üëe z) z)
R : PE ‚âÉ·µ¢ PE := (pointReflection ‚Ñù z).toIsometryEquiv
f : PE ‚âÉ·µ¢ PE ‚Üí PE ‚âÉ·µ¢ PE := fun e ‚Ü¶ ((e.trans R).trans e.symm).trans R
hf_dist : ‚àÄ (e : PE ‚âÉ·µ¢ PE), dist ((f e) z) z = 2 * dist (e z) z
e : PE ‚âÉ·µ¢ PE
hx : e x = x
hy : e y = y
‚ä¢ (f e) y = y
error:  unsolved goals
E : Type u_1
PE : Type u_2
F : Type u_3
PF : Type u_4
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : MetricSpace PE
inst‚úù‚Å¥ : NormedAddTorsor E PE
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : NormedSpace ‚Ñù F
inst‚úù¬π : MetricSpace PF
inst‚úù : NormedAddTorsor F PF
x y : PE
z : PE := midpoint ‚Ñù x y
s : Set (PE ‚âÉ·µ¢ PE) := {e | e x = x ‚àß e y = y}
this‚úù : Nonempty ‚Üës
h_bdd : BddAbove (range fun e ‚Ü¶ dist (‚Üëe z) z)
R : PE ‚âÉ·µ¢ PE := (pointReflection ‚Ñù z).toIsometryEquiv
f : PE ‚âÉ·µ¢ PE ‚Üí PE ‚âÉ·µ¢ PE := fun e ‚Ü¶ ((e.trans R).trans e.symm).trans R
hf_dist : ‚àÄ (e : PE ‚âÉ·µ¢ PE), dist ((f e) z) z = 2 * dist (e z) z
hf_maps_to : MapsTo f s s
c : ‚Ñù := ‚®Ü e, dist (‚Üëe z) z
this : c ‚â§ 0
‚ä¢ ‚àÄ (e : PE ‚âÉ·µ¢ PE), e x = x ‚Üí e y = y ‚Üí e z = z","theorem midpoint_fixed {x y : PE} :
    ‚àÄ e : PE ‚âÉ·µ¢ PE, e x = x ‚Üí e y = y ‚Üí e (midpoint ‚Ñù x y) = midpoint ‚Ñù x y ",":= by
  set z := midpoint ‚Ñù x y
  set s := { e : PE ‚âÉ·µ¢ PE | e x = x ‚àß e y = y }
  haveI : Nonempty s := ‚ü®‚ü®IsometryEquiv.refl PE, rfl, rfl‚ü©‚ü©
  have h_bdd : BddAbove (range fun e : s => dist ((e : PE ‚âÉ·µ¢ PE) z) z) := by
    refine ‚ü®dist x z + dist x z, forall_mem_range.2 <| Subtype.forall.2 ?_‚ü©
    rintro e ‚ü®hx, _‚ü©
    calc
      dist (e z) z ‚â§ dist (e z) x + dist x z := dist_triangle (e z) x z
      _ = dist (e x) (e z) + dist x z := by rw [hx, dist_comm]
      _ = dist x z + dist x z := by erw [e.dist_eq x z]
  set R : PE ‚âÉ·µ¢ PE := (pointReflection ‚Ñù z).toIsometryEquiv
  set f : PE ‚âÉ·µ¢ PE ‚Üí PE ‚âÉ·µ¢ PE := fun e => ((e.trans R).trans e.symm).trans R
  have hf_dist : ‚àÄ e, dist (f e z) z = 2 * dist (e z) z := by
    intro e
    dsimp [f, R]
    rw [dist_pointReflection_fixed, ‚Üê e.dist_eq, e.apply_symm_apply,
      dist_pointReflection_self_real, dist_comm]
  have hf_maps_to : MapsTo f s s := by
    rintro e ‚ü®hx, hy‚ü©
    constructor <;> simp [f, R, z, hx, hy, e.symm_apply_eq.2 hx.symm, e.symm_apply_eq.2 hy.symm]
  set c := ‚®Ü e : s, dist ((e : PE ‚âÉ·µ¢ PE) z) z
  have : c ‚â§ c / 2 := by
    apply ciSup_le
    rintro ‚ü®e, he‚ü©
    simp only [Subtype.coe_mk, le_div_iff' (zero_lt_two' ‚Ñù), ‚Üê hf_dist]
    exact le_ciSup h_bdd ‚ü®f e, hf_maps_to he‚ü©
  replace : c ‚â§ 0 := by linarith
  refine fun e hx hy => dist_le_zero.1 (le_trans ?_ this)
  exact le_ciSup h_bdd ‚ü®e, hx, hy‚ü©",":= by
  set z := midpoint ‚Ñù x y
  set s := { e : PE ‚âÉ·µ¢ PE | e x = x ‚àß e y = y }
  haveI : Nonempty s := ‚ü®‚ü®IsometryEquiv.refl PE, rfl, rfl‚ü©‚ü©
  have h_bdd : BddAbove (range fun e : s => dist ((e : PE ‚âÉ·µ¢ PE) z) z) := by
    refine ‚ü®dist x z + dist x z, forall_range_iff.2 <| Subtype.forall.2 ?_‚ü©
    rintro e ‚ü®hx, _‚ü©
    calc
      dist (e z) z ‚â§ dist (e z) x + dist x z := dist_triangle (e z) x z
      _ = dist (e x) (e z) + dist x z := by rw [hx, dist_comm]
      _ = dist x z + dist x z := by erw [e.dist_eq x z]
  set R : PE ‚âÉ·µ¢ PE := (pointReflection ‚Ñù z).toIsometryEquiv
  set f : PE ‚âÉ·µ¢ PE ‚Üí PE ‚âÉ·µ¢ PE := fun e => ((e.trans R).trans e.symm).trans R
  have hf_dist : ‚àÄ e, dist (f e z) z = 2 * dist (e z) z := by
    intro e
    dsimp
    rw [dist_pointReflection_fixed, ‚Üê e.dist_eq, e.apply_symm_apply,
      dist_pointReflection_self_real, dist_comm]
  have hf_maps_to : MapsTo f s s := by
    rintro e ‚ü®hx, hy‚ü©
    constructor <;> simp [hx, hy, e.symm_apply_eq.2 hx.symm, e.symm_apply_eq.2 hy.symm]
  set c := ‚®Ü e : s, dist ((e : PE ‚âÉ·µ¢ PE) z) z
  have : c ‚â§ c / 2 := by
    apply ciSup_le
    rintro ‚ü®e, he‚ü©
    simp only [Subtype.coe_mk, le_div_iff' (zero_lt_two' ‚Ñù), ‚Üê hf_dist]
    exact le_ciSup h_bdd ‚ü®f e, hf_maps_to he‚ü©
  replace : c ‚â§ 0 := by
    linarith
  refine fun e hx hy => dist_le_zero.1 (le_trans ?_ this)
  exact le_ciSup h_bdd ‚ü®e, hx, hy‚ü©"
Mathlib/FieldTheory/Minpoly/IsIntegrallyClosed.lean,minpoly.isIntegrallyClosed_eq_field_fractions',isIntegrallyClosed_eq_field_fractions',db4b2acc70490f6bcea6872fdf1d716949f8c1e7,":= by
  let L := FractionRing S
  rw [‚Üê isIntegrallyClosed_eq_field_fractions K L hs]
  refine'
    minpoly.eq_of_algebraMap_eq (IsFractionRing.injective S L) (isIntegral_of_isScalarTower hs) rfl",error:  unknown constant 'minpoly.eq_of_algebraMap_eq',"theorem isIntegrallyClosed_eq_field_fractions' [IsDomain S] [Algebra K S] [IsScalarTower R K S]
    {s : S} (hs : IsIntegral R s) : minpoly K s = (minpoly R s).map (algebraMap R K) ",":= by
  let L := FractionRing S
  rw [‚Üê isIntegrallyClosed_eq_field_fractions K L hs, algebraMap_eq (IsFractionRing.injective S L)]",":= by
  let L := FractionRing S
  rw [‚Üê isIntegrallyClosed_eq_field_fractions K L hs]
  refine minpoly.eq_of_algebraMap_eq (IsFractionRing.injective S L) (isIntegral_of_isScalarTower hs) rfl"
Mathlib/Topology/Algebra/Group/Basic.lean,exists_isCompact_isClosed_subset_isCompact_nhds_one,exists_isCompact_isClosed_subset_isCompact_nhds_one,084cfb354233793728fd0ef1054e9b156224e7f6,":= by
  rcases exists_open_nhds_one_mul_subset L1 with ‚ü®V, hVo, hV‚ÇÅ, hVL‚ü©
  have hcVL : closure V ‚äÜ L :=
    calc
      closure V = 1 * closure V := (one_mul _).symm
      _ ‚äÜ V * closure V :=
        mul_subset_mul_right <| singleton_subset_iff.2 hV‚ÇÅ
      _ = V * V := hVo.mul_closure _
      _ ‚äÜ L := hVL
  exact ‚ü®closure V, isCompact_of_isClosed_subset Lcomp isClosed_closure hcVL, isClosed_closure,
    hcVL, mem_of_superset (hVo.mem_nhds hV‚ÇÅ) subset_closure‚ü©",error:  unknown identifier 'isCompact_of_isClosed_subset',"theorem exists_isCompact_isClosed_subset_isCompact_nhds_one
    {L : Set G} (Lcomp : IsCompact L) (L1 : L ‚àà ùìù (1 : G)) :
    ‚àÉ K : Set G, IsCompact K ‚àß IsClosed K ‚àß K ‚äÜ L ‚àß K ‚àà ùìù (1 : G) ",":=
  let ‚ü®K, ‚ü®hK, hK‚ÇÅ, hK‚ÇÇ‚ü©, hKL‚ü© := (Lcomp.isCompact_isClosed_basis_nhds L1).mem_iff.1 L1
  ‚ü®K, hK‚ÇÅ, hK‚ÇÇ, hKL, hK‚ü©",":= by
  rcases exists_open_nhds_one_mul_subset L1 with ‚ü®V, hVo, hV‚ÇÅ, hVL‚ü©
  have hcVL : closure V ‚äÜ L :=
    calc
      closure V = 1 * closure V := one_mul _
      _ ‚äÜ L := hVL
  exact ‚ü®closure V, isCompact_of_isClosed_subset Lcomp isClosed_closure hcVL, isClosed_closure,
    hcVL, mem_of_superset (hVo.mem_nhds hV‚ÇÅ) subset_closure‚ü©"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg ((¬∑ * ¬∑) œÅ) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogon"
Mathlib/MeasureTheory/MeasurableSpace/Basic.lean,MeasurableSet.measurableAtom_of_countable,MeasurableSet.measurableAtom_of_countable,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have : ‚àÄ (y : Œ≤), y ‚àâ measurableAtom x ‚Üí ‚àÉ s, MeasurableSet s ‚àß x ‚àà s ‚àß y ‚àâ s :=
    fun y hy ‚Ü¶ by simpa [measurableAtom] using hy
  choose! s hs using this
  have : measurableAtom x = ‚ãÇ (y ‚àà (measurableAtom x)·∂ú), s y := by
    apply Subset.antisymm
    ¬∑ intro z hz
      simp only [mem_iInter, mem_compl_iff]
      intro i hi
      show z ‚àà s i
      exact mem_of_mem_measurableAtom hz (hs i hi).1 (hs i hi).2.1
    ¬∑ apply compl_subset_compl.1
      intro z hz
      simp only [compl_iInter, mem_iUnion, mem_compl_iff, exists_prop]
      exact ‚ü®z, hz, (hs z hz).2.2‚ü©
  rw [this]
  exact MeasurableSet.biInter (to_countable (measurableAtom x)·∂ú) (fun i hi ‚Ü¶ (hs i hi).1)","error:  type mismatch
  h‚úù
has type
  ‚àÉ x_1, x ‚àà x_1 ‚àß MeasurableSet x_1 ‚àß y ‚àâ x_1 : Prop
but is expected to have type
  ‚àÉ s, MeasurableSet s ‚àß x ‚àà s ‚àß y ‚àâ s : Prop","lemma MeasurableSet.measurableAtom_of_countable [Countable Œ≤] (x : Œ≤) :
    MeasurableSet (measurableAtom x) ",":= by
  have : ‚àÄ (y : Œ≤), y ‚àâ measurableAtom x ‚Üí ‚àÉ s, x ‚àà s ‚àß MeasurableSet s ‚àß y ‚àâ s :=
    fun y hy ‚Ü¶ by simpa [measurableAtom] using hy
  choose! s hs using this
  have : measurableAtom x = ‚ãÇ (y ‚àà (measurableAtom x)·∂ú), s y := by
    apply Subset.antisymm
    ¬∑ intro z hz
      simp only [mem_iInter, mem_compl_iff]
      intro i hi
      show z ‚àà s i
      exact mem_of_mem_measurableAtom hz (hs i hi).2.1 (hs i hi).1
    ¬∑ apply compl_subset_compl.1
      intro z hz
      simp only [compl_iInter, mem_iUnion, mem_compl_iff, exists_prop]
      exact ‚ü®z, hz, (hs z hz).2.2‚ü©
  rw [this]
  exact MeasurableSet.biInter (to_countable (measurableAtom x)·∂ú) (fun i hi ‚Ü¶ (hs i hi).2.1)",":= by
  have : ‚àÄ (y : Œ≤), y ‚àâ measurableAtom x ‚Üí ‚àÉ s, MeasurableSet s ‚àß x ‚àà s ‚àß y ‚àâ s :=
    fun y hy ‚Ü¶ by simpa [measurableAtom] using hy
  choose! s hs using this
  have : measurableAtom x = ‚ãÇ (y ‚àà (measurableAtom x)·∂ú), s y := by
    apply Subset.antisymm
    ¬∑ intro z hz
      simp only [mem_iInter, mem_compl_iff]
      intro i hi
      show z ‚àà s i
      exact mem_of_mem_measurableAtom hz (hs i hi).1 (hs i hi).2.1
    ¬∑ apply compl_subset_compl.1
      intro z hz
      simp only [compl_iInter, mem_iUnion, mem_compl_iff, exists_prop]
      exact ‚ü®z, hz, (hs z hz).2.2‚ü©"
Mathlib/Analysis/InnerProductSpace/Projection.lean,norm_eq_iInf_iff_real_inner_le_zero,norm_eq_iInf_iff_real_inner_le_zero,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel'_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            set_option tactic.skipAssignedInstances false in
            exact this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num [Œ∏])
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine' le_add_of_nonneg_right _
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _","warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
error:  type mismatch
  div_mul_cancel p ?m.225193
has type
  p / ?m.225193 * ?m.225193 = p : Prop
but is expected to have type
  p / q * q = p : Prop","theorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ‚Ñù K) {u : F} {v : F}
    (hv : v ‚àà K) : (‚Äñu - v‚Äñ = ‚®Ö w : K, ‚Äñu - w‚Äñ) ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0 ",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel‚ÇÄ _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            exact this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num [Œ∏])
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine le_add_of_nonneg_right ?_
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
         _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
           simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
             rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
             rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                   absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this"
Mathlib/Topology/Algebra/Group/Basic.lean,IsCompact.locallyCompactSpace_of_mem_nhds_of_group,IsCompact.locallyCompactSpace_of_mem_nhds_of_group,8539229286dc361b2ec76d083f7e1e313d4cb42b,":= by
  refine ‚ü®fun y n hn ‚Ü¶ ?_‚ü©
  have A : (y * x‚Åª¬π) ‚Ä¢ K ‚àà ùìù y := by
    rw [‚Üê preimage_smul_inv]
    exact (continuous_const_smul _).continuousAt.preimage_mem_nhds (by simpa using h)
  rcases exists_mem_nhds_isClosed_subset (inter_mem A hn) with ‚ü®L, hL, L_closed, LK‚ü©
  refine ‚ü®L, hL, LK.trans (inter_subset_right _ _), ?_‚ü©
  exact (hK.smul (y * x‚Åª¬π)).of_isClosed_subset L_closed (LK.trans (inter_subset_left _ _))","error:  function expected at
  inter_subset_right ?m.388733
term has type
  ?m.388732 ‚àà ?m.388731
error:  function expected at
  inter_subset_left ?m.392645
term has type
  ?m.392644 ‚àà ?m.392642","theorem IsCompact.locallyCompactSpace_of_mem_nhds_of_group {K : Set G} (hK : IsCompact K) {x : G}
    (h : K ‚àà ùìù x) : LocallyCompactSpace G ",":= by
  suffices WeaklyLocallyCompactSpace G from inferInstance
  refine ‚ü®fun y ‚Ü¶ ‚ü®(y * x‚Åª¬π) ‚Ä¢ K, ?_, ?_‚ü©‚ü©
  ¬∑ exact hK.smul _
  ¬∑ rw [‚Üê preimage_smul_inv]
    exact (continuous_const_smul _).continuousAt.preimage_mem_nhds (by simpa using h)",":= by
  refine ‚ü®fun y n hn ‚Ü¶ ?_‚ü©
  have A : (y * x‚Åª¬π) ‚Ä¢ K ‚àà ùìù y := by
    rw [‚Üê preimage_smul_inv]
    exact (continuous_const_smul _).continuousAt.preimage_mem_nhds (by simpa using h)
  rcases exists_mem_nhds_isClosed_subset (inter_mem A hn) with ‚ü®L, hL, L_closed, LK‚ü©
  refine ‚ü®L, hL, LK.trans inter_subset_right, ?_‚ü©
  exact (hK.smul (y * x‚Åª¬π)).of_isClosed_subset L_closed (LK.trans inter_subset_left)"
Mathlib/Algebra/Regular/SMul.lean,IsSMulRegular.pow_iff,pow_iff,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  refine' ‚ü®_, pow n‚ü©
  rw [‚Üê Nat.succ_pred_eq_of_pos n0, pow_succ', ‚Üê smul_eq_mul]
  exact of_smul _","error:  typeclass instance problem is stuck, it is often due to metavariables
  IsScalarTower ?m.14579 ?m.14580 ?m.14581",theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a ,":= by
  refine ‚ü®?_, pow n‚ü©
  rw [‚Üê Nat.succ_pred_eq_of_pos n0, pow_succ, ‚Üê smul_eq_mul]
  exact of_smul _",":= by
  refine ‚ü®?_, pow n‚ü©
  rw [‚Üê Nat.pred_eq_of_pos n0, pow_succ', ‚Üê smul_eq_mul]
  exact of_smul _"
Mathlib/Order/Filter/Extr.lean,IsExtrOn.inter,IsExtrOn.inter,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  hf.on_subset (inter_subset_left s t)","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set Œ± : Type u
but is expected to have type
  ?m.5930 ‚àà ?m.5928 ‚à© ?m.5929 : Prop",theorem IsExtrOn.inter (hf : IsExtrOn f s a) (t) : IsExtrOn f (s ‚à© t) a ,":=
  hf.on_subset inter_subset_left",":=
  inter_subset_left"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  simp made no progress
warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff]"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.mul_le_addHaar_image_of_lt_det,mul_le_addHaar_image_of_lt_det,b48d35016dbe6fc567c8edc71f21b3fd344d7ad7,":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases(this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine' Tendsto.mul (tendsto_const_nhds.mul _) tendsto_id
      refine' (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ _
      simpa only [tsub_zero, inv_eq_zero, Ne.def] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toLocalEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target
  ¬∑ change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne.def] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne.def, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)","error:  unexpected token '¬∑'; expected 'by' or 'from'
error:  unsolved goals
case h
E : Type u_1
F : Type u_2
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : FiniteDimensional ‚Ñù E
inst‚úù‚Å¥ : NormedAddCommGroup F
inst‚úù¬≥ : NormedSpace ‚Ñù F
s‚úù : Set E
f‚úù : E ‚Üí E
f' : E ‚Üí E ‚ÜíL[‚Ñù] E
inst‚úù¬≤ : MeasurableSpace E
inst‚úù¬π : BorelSpace E
Œº : Measure E
inst‚úù : Œº.IsAddHaarMeasure
A : E ‚ÜíL[‚Ñù] E
m : ‚Ñù‚â•0
hm : ‚Üëm < ENNReal.ofReal |A.det|
mpos : 0 < m
hA : A.det ‚â† 0
B : E ‚âÉL[‚Ñù] E := A.toContinuousLinearEquivOfDetNeZero hA
I : ENNReal.ofReal |(‚ÜëB.symm).det| < ‚Üëm‚Åª¬π
Œ¥‚ÇÄ : ‚Ñù‚â•0
Œ¥‚ÇÄpos : 0 < Œ¥‚ÇÄ
hŒ¥‚ÇÄ : ‚àÄ (t : Set E) (g : E ‚Üí E), ApproximatesLinearOn g (‚ÜëB.symm) t Œ¥‚ÇÄ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t
L1 : ‚àÄ·∂† (Œ¥ : ‚Ñù‚â•0) in ùìù 0, Subsingleton E ‚à® Œ¥ < ‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π
L2 : ‚àÄ·∂† (Œ¥ : ‚Ñù‚â•0) in ùìù 0, ‚Äñ‚ÜëB.symm‚Äñ‚Çä * (‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ
Œ¥ : ‚Ñù‚â•0
h1Œ¥ : Subsingleton E ‚à® Œ¥ < ‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π
h2Œ¥ : ‚Äñ‚ÜëB.symm‚Äñ‚Çä * (‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ
s : Set E
f : E ‚Üí E
hf : ApproximatesLinearOn f A s Œ¥
hf' : ApproximatesLinearOn f (‚ÜëB) s Œ¥
‚ä¢ ‚Üëm * Œº s ‚â§ Œº (f '' s)","theorem mul_le_addHaar_image_of_lt_det (A : E ‚ÜíL[‚Ñù] E) {m : ‚Ñù‚â•0}
    (hm : (m : ‚Ñù‚â•0‚àû) < ENNReal.ofReal |A.det|) :
    ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù‚â•0),
      ‚àÄ (s : Set E) (f : E ‚Üí E), ApproximatesLinearOn f A s Œ¥ ‚Üí (m : ‚Ñù‚â•0‚àû) * Œº s ‚â§ Œº (f '' s) ",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ filter_upwards
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_eq_zero, Ne] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toPartialEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target by
    change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_zero, inv_zero, inv_zero] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_zero, inv_zero, inv_zero] using tendsto_const_nhds
      refine Te"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,5a786280b45234ae60496d1ed8320b46fcf59034,":= by
  refine' ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, _‚ü©, rfl‚ü©, _‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := isIntegral_sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := OrderedAddCommMonoidWithOne.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)","error:  function expected at
  le_integralClosure_iff_isIntegral.mp (adjoin_le_integralClosure (IsPrimitiveRoot.isIntegral hŒ∂ (PNat.pos (p ^ k))))
term has type
  Algebra.IsIntegral ‚Ñ§ ‚Ü•(adjoin ‚Ñ§ {Œ∂})
error:  unknown identifier 'isIntegral_sub'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë(?m ^ ?n)
case refine'_1.intro.intro
p : ‚Ñï+
k : ‚Ñï
K : Type u
inst‚úù¬π : Field K
inst‚úù : CharZero K
Œ∂ : K
hp : Fact (Nat.Prime ‚Üëp)
hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)
x : K
h : IsIntegral ‚Ñ§ x
B : PowerBasis ‚Ñö K := IsPrimitiveRoot.subOnePowerBasis ‚Ñö hŒ∂
hint : IsIntegral ‚Ñ§ B.gen
this : FiniteDimensional ‚Ñö K := finiteDimensional {p ^ k} ‚Ñö K
u : ‚Ñ§À£
n : ‚Ñï
hun : Algebra.discr ‚Ñö ‚áë(IsPrimitiveRoot.subOnePowerBasis ‚Ñö hŒ∂).basis = ‚Üë‚Üëu * ‚Üë‚Üëp ^ n
H : ‚Üë‚Üëp ^ n ‚Ä¢ x ‚àà adjoin ‚Ñ§ {B.gen}
‚ä¢ x ‚àà adjoin ‚Ñ§ {Œ∂}","theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)) : IsIntegralClosure (adjoin ‚Ñ§ ({Œ∂} : Set K)) ‚Ñ§ K ",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := isIntegral_sub (hŒ∂.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := OrderedAddCommMonoidWithOne.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem _)"
Mathlib/NumberTheory/Modular.lean,ModularGroup.tendsto_normSq_coprime_pair,tendsto_normSq_coprime_pair,916ea595d44124b8bd1c76a5752991acdeb0ae80,":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)","error:  unknown identifier 'ofReal_int_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.22323
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
f_def : ‚áëf = fun p ‚Ü¶ ‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)
x‚úù : Fin 2 ‚Üí ‚Ñ§
‚ä¢ normSq (‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)) = normSq (‚Üë‚Üë(x‚úù 0) * ‚Üëz + ‚Üë‚Üë(x‚úù 1))
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem tendsto_normSq_coprime_pair :
    Filter.Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * z + p 1)) cofinite atTop ",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_intCast, ofReal_intCast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)"
Mathlib/MeasureTheory/Function/Jacobian.lean,exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt,exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt,ac197cdca670f410b4e313b0a220dab452142dff,":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine' ‚ü®fun _ => ‚àÖ, fun _ => 0, _, _, _, _‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' x)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine' mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, _‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine' ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, _, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine' ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, _‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := (norm_add_le _ _)
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ + ‚Äñf' x - f' z‚Äñ * ‚Äñy - x‚Äñ := by
        refine' add_le_add (hŒ¥ _) (ContinuousLinearMap.le_op_norm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ‚â§ r (f' z) * ‚Äñy - x‚Äñ := by
        rw [‚Üê add_mul, add_comm]
        exact mul_le_mul_of_nonneg_right hŒµ (norm_nonneg _)
  have closure_M_subset : ‚àÄ n z, s ‚à© closure (M n z) ‚äÜ M n z := by
    rintro n z x ‚ü®xs, hx‚ü©
    refine' ‚ü®xs, fun y hy => _‚ü©
    obtain ‚ü®a, aM, a_lim‚ü© : ‚àÉ a : ‚Ñï ‚Üí E, (‚àÄ k, a k ‚àà M n z) ‚àß Tendsto a atTop (ùìù x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ‚Ñï => ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ) atTop
        (ùìù ‚Äñf y - f x - (f' z) (y - x)‚Äñ) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (ùìù (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ‚Ñï => (r (f' z) : ‚Ñù) * ‚Äñy - a k‚Äñ) atTop (ùìù (r (f' z) * ‚Äñy - x‚Äñ)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ‚àÄ·∂† k in atTop, ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ ‚â§ r (f' z) * ‚Äñy - a k‚Äñ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (ùìù (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ‚ü®hy.1, hk‚ü©
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ‚ü®d, hd‚ü©
  let K : ‚Ñï ‚Üí T ‚Üí ‚Ñï ‚Üí Set E := fun n z p => closure (M n z) ‚à© closedBall (d p) (u n / 3)
  have K_approx : ‚àÄ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ‚à© K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ‚àà M n z := closure_M_subset _ _ ‚ü®hy.1, hy.2.1‚ü©
    refine' yM.2 _ ‚ü®hx.1, _‚ü©
    calc
      dist x y ‚â§ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ‚â§ u n / 3 + u n / 3 := (add_le_add hx.2.2 hy.2.2)
      _ < u n := by linarith [u_pos n]
  have K_closed : ‚àÄ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñï ‚Üí ‚Ñï √ó T √ó ‚Ñï, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases eq_empty_or_nonempty T with (rfl | hT)
      ¬∑ rcases hs with ‚ü®x, xs‚ü©
        rcases s_subset x xs with ‚ü®n, z, _‚ü©
        exact False.elim z.2
      ¬∑ exact hT.coe_sort
    inhabit ‚Ü•T
    exact ‚ü®_, Encodable.surjective_decode_iget (‚Ñï √ó T √ó ‚Ñï)‚ü©
  refine'
    ‚ü®fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => _, fun q => K_approx _ _ _, fun _ q => ‚ü®(F q).2.1, (F q).2.1.1.2, rfl‚ü©‚ü©
  obtain ‚ü®n, z, hnz‚ü© : ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := s_subset x xs
  obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, x ‚àà closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, d p ‚àà ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ‚ü®p, (mem_ball'.1 hp).le‚ü©
  obtain ‚ü®q, hq‚ü© : ‚àÉ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ‚ü®q, _‚ü©
  simp (config := { zeta := false }) only [K, hq, mem_inter_iff, hp, and_true]
  exact subset_closure hnz","error:  application type mismatch
  IsLittleO.def (hf' x xs)
argument
  hf' x xs
has type
  HasFDerivWithinAt f (f' x) s x : Prop
but is expected to have type
  (fun y ‚Ü¶ f y - f x - (f' x) (y - x)) =o[ùìù[s] x] fun y ‚Ü¶ y - x : Prop
warning:  `ContinuousLinearMap.le_op_norm` has been deprecated, use `ContinuousLinearMap.le_opNorm` instead","theorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]
    (f : E ‚Üí F) (s : Set E) (f' : E ‚Üí E ‚ÜíL[‚Ñù] F) (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x)
    (r : (E ‚ÜíL[‚Ñù] F) ‚Üí ‚Ñù‚â•0) (rpos : ‚àÄ A, r A ‚â† 0) :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] F),
      (‚àÄ n, IsClosed (t n)) ‚àß
        (s ‚äÜ ‚ãÉ n, t n) ‚àß
          (‚àÄ n, ApproximatesLinearOn f (A n) (s ‚à© t n) (r (A n))) ‚àß
            (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) ",":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => 0, ?_, ?_, ?_, ?_‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' x)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, ?_‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ + ‚Äñf' x - f' z‚Äñ * ‚Äñy - x‚Äñ := by
        refine add_le_add (hŒ¥ ?_) (ContinuousLinearMap.le_opNorm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ‚â§ r (f' z) * ‚Äñy - x‚Äñ := by
        rw [‚Üê add_mul, add_comm]
        gcongr
  have closure_M_subset : ‚àÄ n z, s ‚à© closure (M n z) ‚äÜ M n z := by
    rintro n z x ‚ü®xs, hx‚ü©
    refine ‚ü®xs, fun y hy => ?_‚ü©
    obtain ‚ü®a, aM, a_lim‚ü© : ‚àÉ a : ‚Ñï ‚Üí E, (‚àÄ k, a k ‚àà M n z) ‚àß Tendsto a atTop (ùìù x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ‚Ñï => ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ) atTop
        (ùìù ‚Äñf y - f x - (f' z) (y - x)‚Äñ) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (ùìù (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ‚Ñï => (r (f' z) : ‚Ñù) * ‚Äñy - a k‚Äñ) atTop (ùìù (r (f' z) * ‚Äñy - x‚Äñ)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ‚àÄ·∂† k in atTop, ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ ‚â§ r (f' z) * ‚Äñy - a k‚Äñ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (ùìù (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ‚ü®hy.1, hk‚ü©
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ‚ü®d, hd‚ü©
  let K : ‚Ñï ‚Üí T ‚Üí ‚Ñï ‚Üí Set E := fun n z p => closure (M n z) ‚à© closedBall (d p) (u n / 3)
  have K_approx : ‚àÄ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ‚à© K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ‚àà M n z := closure_M_subset _ _ ‚ü®hy.1, hy.2.1‚ü©
    refine yM.2 _ ‚ü®hx.1, ?_‚ü©
    calc
      dist x y ‚â§ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ‚â§ u n / 3 + u n / 3 := add_le_add hx.2.2 hy.2.2
      _ < u n := by linarith [u_pos n]
  have K_closed : ‚àÄ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñï ‚Üí ‚Ñï √ó T √ó ‚Ñï, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases hs with ‚ü®x, xs‚ü©
      rcases s_subset x xs with ‚ü®n, z, _‚ü©
      exact ‚ü®z‚ü©
    inhabit ‚Ü•T
    exact ‚ü®_, Encodable.surjective_decode_iget (‚Ñï √ó T √ó ‚Ñï)‚ü©
  refine
    ‚ü®fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => ?_, fun q => K_approx _ _ _, fun _ q => ‚ü®(F q).2.1, (F q).2.1.1.2, rfl‚ü©‚ü©
  obtain ‚ü®n, z, hnz‚ü© : ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := s_subset x xs
  obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, x ‚àà closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, d p ‚àà ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ‚ü®p, (mem_ball'.1 hp).le‚ü©
  obtain ‚ü®q, hq‚ü© : ‚àÉ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ‚ü®q, _‚ü©
  simp (config := { zeta := false }) only [K, hq, mem_inter_iff, hp, and_true]
  exact subset_closure hnz",":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => 0, ?_, ?_, ?_, ?_‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' z)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, ?_‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñ"
Mathlib/Topology/Order/ScottTopology.lean,Topology.IsScott.isOpen_iff_isUpperSet_and_dirSupInacc,isOpen_iff_isUpperSet_and_dirSupInacc,8b0925372fa04d1a63cab2bd48d77259af9c5245,":= by
  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open]
  refine and_congr_right fun h ‚Ü¶
    ‚ü®@IsScottHausdorff.dirSupInacc_of_isOpen _ _ (scottHausdorff Œ±) _ _,
      fun h' d d‚ÇÅ d‚ÇÇ _ d‚ÇÉ ha ‚Ü¶ ?_‚ü©
  obtain ‚ü®b, hbd, hbu‚ü© := h' (trivial) d‚ÇÅ d‚ÇÇ d‚ÇÉ ha
  exact ‚ü®b, hbd, Subset.trans (inter_subset_left (Ici b) d) (h.Ici_subset hbu)‚ü©","error:  application type mismatch
  h' trivial
argument
  trivial
has type
  True : Prop
but is expected to have type
  ?m.27154.Nonempty : Prop
error:  rcases tactic failed: x‚úù : ?m.27809 is not an inductive datatype",lemma isOpen_iff_isUpperSet_and_dirSupInacc : IsOpen s ‚Üî IsUpperSet s ‚àß DirSupInacc s ,":= by
  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open]
  refine and_congr_right fun h ‚Ü¶
    ‚ü®@IsScottHausdorff.dirSupInacc_of_isOpen _ _ (scottHausdorff Œ±) _ _,
      fun h' d d‚ÇÅ d‚ÇÇ _ d‚ÇÉ ha ‚Ü¶ ?_‚ü©
  obtain ‚ü®b, hbd, hbu‚ü© := h' d‚ÇÅ d‚ÇÇ d‚ÇÉ ha
  exact ‚ü®b, hbd, Subset.trans inter_subset_left (h.Ici_subset hbu)‚ü©",":= by
  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open]
  refine and_congr_right fun h ‚Ü¶
    ‚ü®@IsScottHausdorff.dirSupInacc_of_isOpen _ _ (scottHausdorff Œ±) _ _,
      fun h' d d‚ÇÅ d‚ÇÇ _ d‚ÇÉ ha ‚Ü¶ ?_‚ü©
  obtain ‚ü®b, hbd, hbu‚ü© := h' (trivial) d‚ÇÅ d‚ÇÇ d‚ÇÉ ha
  exact ‚ü®b, hbd, Subset.trans inter_subset_left (Ici b) d) (h.Ici_subset hbu)‚ü©"
Mathlib/NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean,ZMod.Ico_map_valMinAbs_natAbs_eq_Ico_map_id,Ico_map_valMinAbs_natAbs_eq_Ico_map_id,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,
      pos_iff_ne_zero, natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x, ‚àÉ _ : x ‚àà Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine' ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®_, _‚ü©, _‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne.def, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [nat_cast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel‚ÇÄ _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
      ¬∑ erw [mul_neg, mul_div_cancel‚ÇÄ _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,
          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.15005 ‚Üí ?m.15005 ‚Üí Prop
error:  unsolved goals
case refine'_1.a
p : ‚Ñï
hp : Fact (Nat.Prime p)
a : ZMod p
hap : a ‚â† 0
he : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2
hep : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p
hpe : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x
hmem : ‚àÄ x ‚àà Ico 1 (p / 2).succ, (a * ‚Üëx).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ
b : ‚Ñï
hb : b ‚àà Ico 1 (p / 2).succ
‚ä¢ (‚Üëb * a‚Åª¬π).valMinAbs.natAbs ‚â† 0
warning:  `ZMod.nat_cast_natAbs_valMinAbs` has been deprecated, use `ZMod.natCast_natAbs_valMinAbs` instead","theorem Ico_map_valMinAbs_natAbs_eq_Ico_map_id (p : ‚Ñï) [hp : Fact p.Prime] (a : ZMod p)
    (hap : a ‚â† 0) : ((Ico 1 (p / 2).succ).1.map fun (x : ‚Ñï) => (a * x).valMinAbs.natAbs) =
    (Ico 1 (p / 2).succ).1.map fun a => a ",":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,
      pos_iff_ne_zero, natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x, ‚àÉ _ : x ‚àà Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®?_, ?_‚ü©, ?_‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [natCast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel‚ÇÄ _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
      ¬∑ erw [mul_neg, mul_div_cancel‚ÇÄ _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,
          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)",":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,
      pos_iff_ne_zero, natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x, ‚àÉ _ : x ‚àà Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®_, ?_‚ü©, ?_‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [nat_cast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel‚ÇÄ _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)"
Mathlib/LinearAlgebra/QuadraticForm/Real.lean,QuadraticForm.equivalent_one_neg_one_weighted_sum_squared,equivalent_one_neg_one_weighted_sum_squared,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":=
  let ‚ü®w, ‚ü®hw‚ÇÅ‚ü©‚ü© := Q.equivalent_weightedSumSquares_units_of_nondegenerate' hQ
  ‚ü®Real.sign ‚àò ((‚Üë) : ‚ÑùÀ£ ‚Üí ‚Ñù) ‚àò w, fun i => sign_apply_eq_of_ne_zero (w i) (w i).ne_zero,
    ‚ü®hw‚ÇÅ.trans (isometryEquivSignWeightedSumSquares (((‚Üë) : ‚ÑùÀ£ ‚Üí ‚Ñù) ‚àò w))‚ü©‚ü©","error:  unknown constant 'Real.sign'
error:  unknown identifier 'sign_apply_eq_of_ne_zero'","theorem equivalent_one_neg_one_weighted_sum_squared {M : Type*} [AddCommGroup M] [Module ‚Ñù M]
    [FiniteDimensional ‚Ñù M] (Q : QuadraticForm ‚Ñù M) (hQ : (associated (R := ‚Ñù) Q).SeparatingLeft) :
    ‚àÉ w : Fin (FiniteDimensional.finrank ‚Ñù M) ‚Üí ‚Ñù,
      (‚àÄ i, w i = -1 ‚à® w i = 1) ‚àß Equivalent Q (weightedSumSquares ‚Ñù w) ",":=
  let ‚ü®w, hw‚ÇÄ, hw‚ü© := Q.equivalent_sign_ne_zero_weighted_sum_squared hQ
  ‚ü®(w ¬∑), fun i ‚Ü¶ by cases hi : w i <;> simp_all, hw‚ü©",":=
  let ‚ü®w, ‚ü®hw‚ÇÅ‚ü©‚ü© := Q.equivalent_weightedSumSquares_units_of_nondegenerate' hQ
  ‚ü®Real.sign ‚àò ((‚Üë) : ‚ÑùÀ£ ‚Üí ‚Ñù) ‚àò w, fun i => sign_apply_eq_of_ne_zero (w i) (w i).ne_zero,
    ‚ü®hw‚ÇÅ.trans (isometryEquivSignWeightedSumSquares ((‚Üë) : ‚ÑùÀ£ ‚Üí ‚Ñù) ‚àò w))‚ü©‚ü©"
Mathlib/Analysis/InnerProductSpace/PiL2.lean,Orthonormal.exists_orthonormalBasis_extension,Orthonormal.exists_orthonormalBasis_extension,5648120293e005e7ed12dc634bf3094a1835c21b,":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.setFinite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine' ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu _, _, _‚ü©
  ¬∑ simpa using hu‚ÇÄ_max
  ¬∑ simpa using hu‚ÇÄs
  ¬∑ simp","error:  type mismatch
  h‚úù
has type
  span ùïú u‚ÇÄ = ‚ä§ : Prop
but is expected to have type
  span ùïú ‚Üëu = ‚ä§ : Prop
error:  type mismatch
  h‚úù
has type
  u‚ÇÄ ‚äá v : Prop
but is expected to have type
  v ‚äÜ ‚Üëu : Prop","theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal ùïú ((‚Üë) : v ‚Üí E)) :
    ‚àÉ (u : Finset E) (b : OrthonormalBasis u ùïú E), v ‚äÜ u ‚àß ‚áëb = ((‚Üë) : u ‚Üí E) ",":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.setFinite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_‚ü©
  ¬∑ simpa [u] using hu‚ÇÄ_max
  ¬∑ simpa [u] using hu‚ÇÄs
  ¬∑ simp",":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.setFinite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_‚ü©
  ¬∑ simpa using hu‚ÇÄ_max
  ¬∑ simpa using hu‚ÇÄs"
Mathlib/Probability/Kernel/Disintegration/CondCdf.lean,ProbabilityTheory.measurable_measure_condCDF,measurable_measure_condCDF,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  rw [Measure.measurable_measure]
  refine fun s hs => ?_
  refine MeasurableSpace.induction_on_inter
    (C := fun s => Measurable fun b ‚Ü¶ StieltjesFunction.measure (condCDF œÅ b) s)
    (borel_eq_generateFrom_Iic ‚Ñù) isPiSystem_Iic ?_ ?_ ??_ _ hs
  ¬∑ simp only [measure_empty, measurable_const]
  ¬∑ rintro S ‚ü®u, rfl‚ü©
    simp_rw [measure_condCDF_Iic œÅ _ u]
    exact (measurable_condCDF œÅ u).ennreal_ofReal
  ¬∑ intro t ht ht_cd_meas
    have :
      (fun a => (condCDF œÅ a).measure t·∂ú) =
        (fun a => (condCDF œÅ a).measure univ) - fun a => (condCDF œÅ a).measure t := by
      ext1 a
      rw [measure_compl ht (measure_ne_top (condCDF œÅ a).measure _), Pi.sub_apply]
    simp_rw [this, measure_condCDF_univ œÅ]
    exact Measurable.sub measurable_const ht_cd_meas
  ¬∑ intro f hf_disj hf_meas hf_cd_meas
    simp_rw [measure_iUnion hf_disj hf_meas]
    exact Measurable.ennreal_tsum hf_cd_meas",error:  unexpected token '?'; expected '_' or identifier,"theorem measurable_measure_condCDF (œÅ : Measure (Œ± √ó ‚Ñù)) :
    Measurable fun a => (condCDF œÅ a).measure ",":= by
  rw [Measure.measurable_measure]
  refine fun s hs => ?_
  refine MeasurableSpace.induction_on_inter
    (C := fun s => Measurable fun b ‚Ü¶ StieltjesFunction.measure (condCDF œÅ b) s)
    (borel_eq_generateFrom_Iic ‚Ñù) isPiSystem_Iic ?_ ?_ ?_ ?_ hs
  ¬∑ simp only [measure_empty, measurable_const]
  ¬∑ rintro S ‚ü®u, rfl‚ü©
    simp_rw [measure_condCDF_Iic œÅ _ u]
    exact (measurable_condCDF œÅ u).ennreal_ofReal
  ¬∑ intro t ht ht_cd_meas
    have :
      (fun a => (condCDF œÅ a).measure t·∂ú) =
        (fun a => (condCDF œÅ a).measure univ) - fun a => (condCDF œÅ a).measure t := by
      ext1 a
      rw [measure_compl ht (measure_ne_top (condCDF œÅ a).measure _), Pi.sub_apply]
    simp_rw [this, measure_condCDF_univ œÅ]
    exact Measurable.sub measurable_const ht_cd_meas
  ¬∑ intro f hf_disj hf_meas hf_cd_meas
    simp_rw [measure_iUnion hf_disj hf_meas]
    exact Measurable.ennreal_tsum hf_cd_meas",":= by
  rw [Measure.measurable_measure]
  refine fun s hs => ?_
  refine MeasurableSpace.induction_on_inter
    (C := fun s => Measurable fun b ‚Ü¶ StieltjesFunction.measure (condCDF œÅ b) s)
    (borel_eq_generateFrom_Iic ‚Ñù) isPiSystem_Iic ?_ ?_ ?_ ?_ hs
  ¬∑ simp only [measure_empty, measurable_const]
  ¬∑ rintro S ‚ü®u, rfl‚ü©
    simp_rw [measure_condCDF_Iic œÅ _ u]
    exact (measurable_condCDF œÅ u).ennreal_ofReal
  ¬∑ intro t ht ht_cd_meas
    have :
      (fun a => (condCDF œÅ a).measure t·∂ú) =
        (fun a => (condCDF œÅ a).measure univ) - fun a => (condCDF œÅ a).measure t := by
      ext1 a
      rw [measure_compl ht (measure_ne_top (condCDF œÅ a).measure _), Pi.sub_apply]
    simp_rw [this, measure_condCDF_univ œÅ]
    exact Measurable.sub measurable_const ht_cd_meas
  ¬∑ intro f hf_disj hf_meas hf_cd_meas
    simp_rw [measure_iUnion hf_disj hf_meas]
    exact Measurable.ennreal_tsum hf_cd_meas"
Mathlib/NumberTheory/Bertrand.lean,bertrand_main_inequality,bertrand_main_inequality,2009db69c1211eafea457d1c3902f31370dac23f,":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_nat_cast]
  have n_pos : 0 < n := (by decide : 0 < 512).trans_le n_large
  have n2_pos : 1 ‚â§ 2 * n := mul_pos (by decide) n_pos
  refine' _root_.trans (mul_le_mul _ _ _ _)
      (Bertrand.real_main_inequality (mod_cast n_large))
  ¬∑ refine' mul_le_mul_of_nonneg_left _ (Nat.cast_nonneg _)
    refine' Real.rpow_le_rpow_of_exponent_le (mod_cast n2_pos) _
    exact mod_cast Real.nat_sqrt_le_real_sqrt
  ¬∑ exact Real.rpow_le_rpow_of_exponent_le (by norm_num1) (cast_div_le.trans (by norm_cast))
  ¬∑ exact Real.rpow_nonneg_of_nonneg (by norm_num1) _
  ¬∑ refine' mul_nonneg (Nat.cast_nonneg _) _
    exact Real.rpow_nonneg_of_nonneg (mul_nonneg zero_le_two (Nat.cast_nonneg _)) _","warning:  `Real.rpow_nat_cast` has been deprecated, use `Real.rpow_natCast` instead
error:  unknown constant 'Real.rpow_nonneg_of_nonneg'
error:  unknown constant 'Real.rpow_nonneg_of_nonneg'","theorem bertrand_main_inequality {n : ‚Ñï} (n_large : 512 ‚â§ n) :
    n * (2 * n) ^ sqrt (2 * n) * 4 ^ (2 * n / 3) ‚â§ 4 ^ n ",":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_natCast]
  refine _root_.trans ?_ (Bertrand.real_main_inequality (by exact_mod_cast n_large))
  gcongr
  ¬∑ have n2_pos : 0 < 2 * n := by positivity
    exact mod_cast n2_pos
  ¬∑ exact_mod_cast Real.nat_sqrt_le_real_sqrt
  ¬∑ norm_num1
  ¬∑ exact cast_div_le.trans (by norm_cast)",":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_natCast]
  have n_pos : 0 < n := (by decide : 0 < 512).trans_le n_large
  have n2_pos : 1 ‚â§ 2 * n := mul_pos (by decide) n_pos
  refine _root_.trans (mul_le_mul _ _ _ _)
      (Bertrand.real_main_inequality (mod_cast n_large))
  ¬∑ refine mul_le_mul_of_nonneg_left ?_ (Nat.cast_nonneg _)
    refine Real.rpow_le_rpow_of_exponent_le (mod_cast n2_pos) ?_
    exact mod_cast Real.natCast_nonneg (by norm_num1) _
  ¬∑ refine mul_nonneg (Nat.cast_nonneg _) ?_
    exact Real.rpow_nonneg_of_nonneg (mul_nonneg zero_le_two (Nat.cast_nonneg _)) _"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding',exists_extension_norm_eq_of_closedEmbedding',9e34a191034458a56331f976ff7400a26407c888,":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel', pow_succ, mul_assoc]
      refine' (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel']
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := (mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine' tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 _)
    refine' squeeze_zero (fun _ => dist_nonneg) hgf _
    rw [‚Üê MulZeroClass.zero_mul ‚Äñf‚Äñ]
    refine' (tendsto_pow_atTop_nhds_0_of_lt_1 _ _).mul tendsto_const_nhds <;> norm_num1
  refine' ‚ü®limUnder atTop g, le_antisymm _ _, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine'
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq _
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  application type mismatch
  LE.le.trans (hF_dist (f - (g n).compContinuous e)) (mul_le_mul_of_nonneg_left ?m.115481 ?m.115895)
argument
  mul_le_mul_of_nonneg_left ?m.115481 ?m.115895
has type
  2 / 3 * ‚Äñf - (g n).compContinuous e‚Äñ ‚â§ 2 / 3 * ?m.115476 : Prop
but is expected to have type
  2 / 3 * ‚Äñf - (g n).compContinuous e‚Äñ ‚â§ (2 / 3) ^ n * (2 / 3 * ‚Äñf‚Äñ) : Prop
error:  no goals to be solved
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
warning:  `tendsto_pow_atTop_nhds_0_of_lt_1` has been deprecated, use `tendsto_pow_atTop_nhds_zero_of_lt_one` instead","theorem exists_extension_norm_eq_of_closedEmbedding' (f : X ‚Üí·µá ‚Ñù) (e : C(X, Y))
    (he : ClosedEmbedding e) : ‚àÉ g : Y ‚Üí·µá ‚Ñù, ‚Äñg‚Äñ = ‚Äñf‚Äñ ‚àß g.compContinuous e = f ",":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [‚Üê zero_mul ‚Äñf‚Äñ]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ‚ü®limUnder atTop g, le_antisymm ?_ ?_, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _",":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel', pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel']
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [‚Üê MulZeroClass.zero_mul ‚Äñf‚Äñ]
    refine (tendsto_pow_atTop_nhds_0_of_lt_1 ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ‚ü®limUnder atTop g, le_antisymm ?_ ?_, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _"
Mathlib/CategoryTheory/Comma/Presheaf.lean,CategoryTheory.OverPresheafAux.counitForward_naturality‚ÇÇ,counitForward_naturality‚ÇÇ,0d51b85ccc46c1baa5fe11fe1776272539b2e423,":= by
  refine OverArrows.ext <| YonedaCollection.ext (by simp) ?_
  dsimp
  simp only [YonedaCollection.map‚ÇÇ_snd, counitForward_val_snd, op_unop, unop_op,
    CostructuredArrow.mk_left, ‚Üê op_comp, ‚Üê FunctorToTypes.map_comp_apply]
  apply FunctorToTypes.congr_map_apply
  exact Quiver.Hom.unop_inj (by simp)",error:  unknown identifier 'FunctorToTypes.congr_map_apply',"lemma counitForward_naturality‚ÇÇ (s t : (CostructuredArrow yoneda A)·µí·µñ) (f : t ‚ü∂ s) (x : F.obj t) :
    counitForward F s.unop (F.map f x) =
      OverArrows.map‚ÇÇ (counitForward F t.unop x) f.unop.left (by simp) ",":= by
  refine OverArrows.ext <| YonedaCollection.ext (by simp) ?_
  have : (CostructuredArrow.mkPrecomp t.unop.hom f.unop.left).op =
      f ‚â´ eqToHom (by simp [‚Üê CostructuredArrow.eq_mk]) := by
    apply Quiver.Hom.unop_inj
    aesop_cat
  aesop_cat",":= by
  refine OverArrows.ext <| YonedaCollection.ext (by simp) ?_
  dsimp
  simp only [YonedaCollection.map‚ÇÇ_snd, counitForward_val_snd, op_unop, unop_op,
    CostructuredArrow.mk_left, ‚Üê op_comp, ‚Üê FunctorToTypes.map_comp_apply]
  apply FunctorToTypes.congr_map_apply
  exact Quiver.Hom.unop_inj (by simp)"
Mathlib/Topology/Bases.lean,TopologicalSpace.separableSpace_iff_countable,separableSpace_iff_countable,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  simp [SeparableSpace_iff, countable_univ_iff]","error:  unknown identifier 'SeparableSpace_iff'
error:  simp made no progress",theorem separableSpace_iff_countable [DiscreteTopology Œ±] : SeparableSpace Œ± ‚Üî Countable Œ± ,":= by
  simp [separableSpace_iff, countable_univ_iff]",":= by
  simp [SeparableSpace]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,65f7857d510e130142dbb111786341d695ac399b,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_ortho"
Mathlib/Algebra/Lie/Subalgebra.lean,LieSubalgebra.lieSpan_induction,lieSpan_induction,ef3c9bcd07782b044027916a64e925f3e4951707,":=
  let S : LieSubalgebra R L :=
    { carrier := ‚ü®p‚ü©
      add_mem' := add _ _
      zero_mem' := zero
      smul_mem' := smul
      lie_mem' := lie _ _ }
  lieSpan_le.mpr (show s ‚â§ S from mem) h","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  L ‚Üí Prop
error:  type mismatch
  mem
has type
  ‚àÄ x ‚àà s, p x : Prop
but is expected to have type
  s ‚â§ ‚ÜëS : Prop","theorem lieSpan_induction {p : L ‚Üí Prop} {x : L} (h : x ‚àà lieSpan R L s) (mem : ‚àÄ x ‚àà s, p x)
    (zero : p 0) (smul : ‚àÄ (r : R), ‚àÄ {x : L}, p x ‚Üí p (r ‚Ä¢ x))
    (add : ‚àÄ x y, p x ‚Üí p y ‚Üí p (x + y)) (lie : ‚àÄ x y, p x ‚Üí p y ‚Üí p ‚ÅÖx, y‚ÅÜ) : p x ",":=
  let S : LieSubalgebra R L :=
    { carrier := p
      add_mem' := add _ _
      zero_mem' := zero
      smul_mem' := smul
      lie_mem' := lie _ _ }
  lieSpan_le.mpr (show s ‚â§ S from mem) h",":=
  let S : LieSubalgebra R L :=
    { carrier := ‚ü®p‚ü©
      add_mem' := add _ _
      zero_mem' := zero
      smul_mem' := lie _ _ }
  lieSpan_le.mpr (show s ‚â§ S from mem) h"
Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean,Complex.abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le,abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  simp only [abs_exp, Real.exp_le_exp, ofReal_mul_re, add_re, exp_re, neg_im, Real.cos_neg, ‚Üê
    add_mul, mul_assoc, mul_comm (Real.cos b), neg_re, ‚Üê Real.cos_abs z.im]
  have : Real.exp |z.re| ‚â§ Real.exp z.re + Real.exp (-z.re) :=
    apply_abs_le_add_of_nonneg (fun x => (Real.exp_pos x).le) z.re
  refine' mul_le_mul_of_nonpos_left (mul_le_mul this _ _ ((Real.exp_pos _).le.trans this)) ha
  ¬∑ exact
      Real.cos_le_cos_of_nonneg_of_le_pi (_root_.abs_nonneg _)
        (hb.trans <| half_le_self <| Real.pi_pos.le) hz
  ¬∑ refine' Real.cos_nonneg_of_mem_Icc ‚ü®_, hb‚ü©
    exact (neg_nonpos.2 <| Real.pi_div_two_pos.le).trans ((_root_.abs_nonneg _).trans hz)","warning:  Real.pi does not have a doc string
error:  unknown identifier 'ofReal_mul_re'
error:  type mismatch
  mul_le_mul_of_nonpos_left (mul_le_mul this ?m.305697 ?m.305698 (LE.le.trans (LT.lt.le (exp_pos |z.re|)) this)) ha
has type
  a * ((rexp z.re + rexp (-z.re)) * ?m.305522) ‚â§ a * (rexp |z.re| * ?m.305521) : Prop
but is expected to have type
  (‚Üëa * (cexp z + cexp (-z))).re ‚â§ a * (rexp |z.re| * Real.cos b) : Prop","theorem abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le {a b : ‚Ñù} (ha : a ‚â§ 0) {z : ‚ÑÇ} (hz : |z.im| ‚â§ b)
    (hb : b ‚â§ œÄ / 2) :
    abs (exp (a * (exp z + exp (-z)))) ‚â§ Real.exp (a * Real.cos b * Real.exp |z.re|) ",":= by
  simp only [abs_exp, Real.exp_le_exp, re_ofReal_mul, add_re, exp_re, neg_im, Real.cos_neg, ‚Üê
    add_mul, mul_assoc, mul_comm (Real.cos b), neg_re, ‚Üê Real.cos_abs z.im]
  have : Real.exp |z.re| ‚â§ Real.exp z.re + Real.exp (-z.re) :=
    apply_abs_le_add_of_nonneg (fun x => (Real.exp_pos x).le) z.re
  refine mul_le_mul_of_nonpos_left (mul_le_mul this ?_ ?_ ((Real.exp_pos _).le.trans this)) ha
  ¬∑ exact
      Real.cos_le_cos_of_nonneg_of_le_pi (_root_.abs_nonneg _)
        (hb.trans <| half_le_self <| Real.pi_pos.le) hz
  ¬∑ refine Real.cos_nonneg_of_mem_Icc ‚ü®?_, hb‚ü©
    exact (neg_nonpos.2 <| Real.pi_div_two_pos.le).trans ((_root_.abs_nonneg _).trans hz)",":= by
  simp only [abs_exp, Real.exp_le_exp, ofReal_mul_re, add_re, exp_re, neg_im, Real.cos_neg, ‚Üê
    add_mul, mul_assoc, mul_comm (Real.cos b), neg_re, ‚Üê Real.cos_abs z.im]
  have : Real.exp |z.re| ‚â§ Real.exp z.re + Real.exp (-z.re) :=
    apply_abs_le_add_of_nonneg (fun x => (Real.exp_pos x).le) z.re
  refine mul_le_mul_of_nonpos_left (mul_le_mul this _ _ ((Real.exp_pos _).le.trans this)) ha
  ¬∑ exact
      Real.cos_le_cos_of_nonneg_of_le_pi (_root_.abs_nonneg _)
        (hb.trans <| half_le_self <| Real.pi_pos.le) hz
  ¬∑ refine Real.cos_nonneg_of_mem_Icc ‚ü®?_, hb‚ü©
    exact (neg_nonpos.2 <| Real.pi_div_two_pos.le).trans ((_root_.abs_nonneg _).trans hz)"
Mathlib/Data/Set/Card.lean,Set.encard_union_add_encard_inter,encard_union_add_encard_inter,596865180ecc63dcd1d95809202e31027ac3ae38,:=,error:  unexpected token 'theorem'; expected term,"theorem encard_union_add_encard_inter (s t : Set Œ±) :
    (s ‚à™ t).encard + (s ‚à© t).encard = s.encard + t.encard ",":= by
  rw [‚Üê diff_union_self, encard_union_eq disjoint_sdiff_left, add_right_comm,
    encard_diff_add_encard_inter]",":=
  encard_union_add_encard_inter s t"
Mathlib/Data/Set/Basic.lean,Set.ite_subset_union,ite_subset_union,70dcc1355b9ce0a6754f8d809c95a171072d3aac,":=
  union_subset_union (inter_subset_left _ _) (diff_subset _ _)","error:  function expected at
  inter_subset_left ?m.135713
term has type
  ?m.135712 ‚àà ?m.135710
error:  function expected at
  diff_subset ?m.135755
term has type
  ?m.135754 ‚àà ?m.135752",theorem ite_subset_union (t s s' : Set Œ±) : t.ite s s' ‚äÜ s ‚à™ s' ,":=
  union_subset_union inter_subset_left diff_subset",":=
  union_subset_union inter_subset_left diff_subset"
Mathlib/CategoryTheory/Closed/Functor.lean,CategoryTheory.frobeniusMorphism_iso_of_expComparison_iso,frobeniusMorphism_iso_of_expComparison_iso,5de6876e2407407a687bd154709aa9a67f431f5a,":= by
  rw [‚Üê frobeniusMorphism_mate F h] at i
  exact @conjugateEquiv_of_iso _ _ _ _ _ _ _ _ _ _ _ i",error:  unknown identifier 'conjugateEquiv_of_iso',"theorem frobeniusMorphism_iso_of_expComparison_iso (h : L ‚ä£ F) (A : C)
    [i : IsIso (expComparison F A)] : IsIso (frobeniusMorphism F h A) ",":= by
  rw [‚Üê frobeniusMorphism_mate F h] at i
  exact @transferNatTransSelf_of_iso _ _ _ _ _ _ _ _ _ _ _ i",":= by
  rw [‚Üê frobeniusMorphism_mate F h] at i
  exact @conjugateEquiv_of_iso _ _ _ _ _ _ _ _ i"
Mathlib/Probability/Martingale/Upcrossing.lean,MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part,Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  by_cases hab : a < b
  ¬∑ simp_rw [upcrossings]
    have : ‚àÄ N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº = ENNReal.ofReal (‚à´ œâ, (f N œâ - a)‚Å∫ ‚àÇŒº) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      ¬∑ exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      ¬∑ exact eventually_of_forall fun œâ => LatticeOrderedCommGroup.pos_nonneg _
    rw [lintegral_iSup']
    ¬∑ simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          ‚à´‚Åª œâ, upcrossingsBefore a b f N œâ ‚àÇŒº = ‚à´‚Åª œâ, ‚Üë(upcrossingsBefore a b f N œâ : ‚Ñù‚â•0) ‚àÇŒº),
        lintegral_coe_eq_integral, ‚Üê ENNReal.ofReal_mul (sub_pos.2 hab).le]
      ¬∑ simp_rw [NNReal.coe_nat_cast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Œ± := ‚Ñù‚â•0‚àû) _ N)
      ¬∑ simp only [NNReal.coe_nat_cast, hf.adapted.integrable_upcrossingsBefore hab]
    ¬∑ exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    ¬∑ refine' eventually_of_forall fun œâ N M hNM => _
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM œâ
  ¬∑ rw [not_lt, ‚Üê sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, MulZeroClass.zero_mul]
    exact zero_le _","error:  unknown identifier 'LatticeOrderedCommGroup.pos_nonneg'
warning:  `NNReal.coe_nat_cast` has been deprecated, use `NNReal.coe_natCast` instead
warning:  `NNReal.coe_nat_cast` has been deprecated, use `NNReal.coe_natCast` instead","theorem Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part [IsFiniteMeasure Œº] (a b : ‚Ñù)
    (hf : Submartingale f ‚Ñ± Œº) : ENNReal.ofReal (b - a) * ‚à´‚Åª œâ, upcrossings a b f œâ ‚àÇŒº ‚â§
      ‚®Ü N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº ",":= by
  by_cases hab : a < b
  ¬∑ simp_rw [upcrossings]
    have : ‚àÄ N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº = ENNReal.ofReal (‚à´ œâ, (f N œâ - a)‚Å∫ ‚àÇŒº) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      ¬∑ exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      ¬∑ exact eventually_of_forall fun œâ => posPart_nonneg _
    rw [lintegral_iSup']
    ¬∑ simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          ‚à´‚Åª œâ, upcrossingsBefore a b f N œâ ‚àÇŒº = ‚à´‚Åª œâ, ‚Üë(upcrossingsBefore a b f N œâ : ‚Ñù‚â•0) ‚àÇŒº),
        lintegral_coe_eq_integral, ‚Üê ENNReal.ofReal_mul (sub_pos.2 hab).le]
      ¬∑ simp_rw [NNReal.coe_natCast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Œ± := ‚Ñù‚â•0‚àû) _ N)
      ¬∑ simp only [NNReal.coe_natCast, hf.adapted.integrable_upcrossingsBefore hab]
    ¬∑ exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    ¬∑ filter_upwards with œâ N M hNM
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM œâ
  ¬∑ rw [not_lt, ‚Üê sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]
    exact zero_le _",":= by
  by_cases hab : a < b
  ¬∑ simp_rw [upcrossings]
    have : ‚àÄ N, ‚à´‚Åª œâ, ENNReal.ofReal ((f N œâ - a)‚Å∫) ‚àÇŒº = ENNReal.ofReal (‚à´ œâ, (f N œâ - a)‚Å∫ ‚àÇŒº) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      ¬∑ exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      ¬∑ exact eventually_of_forall fun œâ => LatticeOrderedCommGroup.pos_nonneg _
    rw [lintegral_iSup']
    ¬∑ simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          ‚à´‚Åª œâ, upcrossingsBefore a b f N œâ ‚àÇŒº = ‚à´‚Åª œâ, ‚Üë(upcrossingsBefore a b f N œâ : ‚Ñù‚â•0) ‚àÇŒº),
        lintegral_coe_eq_integral, ‚Üê ENNReal.ofReal_mul (sub_pos.2 hab).le]
      ¬∑ simp_rw [NNReal.coe_natCast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Œ± := ‚Ñù‚â•0‚àû) _ N)
      ¬∑ simp only [NNReal.coe_natCast, hf.adapted.integrable_upcrossingsBefore hab]
    ¬∑ exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    ¬∑ refine eventually_of_forall fun œâ N M hNM => ?_
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM œâ
  ¬∑ rw [not_lt, ‚Üê sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, MulZeroClass.zero_mul]
    exact zero_le _"
Mathlib/CategoryTheory/Sites/ConcreteSheafification.lean,CategoryTheory.GrothendieckTopology.Plus.res_mk_eq_mk_pullback,res_mk_eq_mk_pullback,fcf529d7b3138e5580a1be7c6dc3317d3f207d59,":= by
  dsimp [mk, plusObj]
  rw [‚Üê comp_apply (x := (Meq.equiv P S).symm x), Œπ_colimMap_assoc, colimit.Œπ_pre,
    comp_apply (x := (Meq.equiv P S).symm x)]
  apply congr_arg
  apply (Meq.equiv P _).injective
  erw [Equiv.apply_symm_apply]
  ext i
  simp only [Functor.op_obj, unop_op, pullback_obj, diagram_obj, Functor.comp_obj,
    diagramPullback_app, Meq.equiv_apply, Meq.pullback_apply]
  erw [‚Üê comp_apply, Multiequalizer.lift_proj, Meq.equiv_symm_eq_apply]
  cases i; rfl","error:  unknown identifier 'Multiequalizer.lift_proj'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.31688
case h.a.h
C : Type u
inst‚úù‚Åµ : Category.{v, u} C
J : GrothendieckTopology C
D : Type w
inst‚úù‚Å¥ : Category.{max v u, w} D
inst‚úù¬≥ : ConcreteCategory D
inst‚úù¬≤ : PreservesLimits (forget D)
inst‚úù¬π : ‚àÄ (X : C), HasColimitsOfShape (J.Cover X)·µí·µñ D
inst‚úù : ‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)
Y X : C
P : C·µí·µñ ‚•§ D
S : J.Cover X
x : Meq P S
f : Y ‚ü∂ X
i : ((J.pullback f).op.obj { unop := S }).unop.Arrow
‚ä¢ (Multiequalizer.lift ((S.pullback f).index P) (multiequalizer (S.index P))
          (fun I ‚Ü¶ Multiequalizer.Œπ (S.index P) (Cover.Arrow.base I)) ‚ãØ ‚â´
        Multiequalizer.Œπ ((S.pullback f).index P) i)
      ((Meq.equiv P S).symm x) =
    ‚Üëx { Y := i.Y, f := i.f ‚â´ f, hf := ‚ãØ }","theorem res_mk_eq_mk_pullback {Y X : C} {P : C·µí·µñ ‚•§ D} {S : J.Cover X} (x : Meq P S) (f : Y ‚ü∂ X) :
    (J.plusObj P).map f.op (mk x) = mk (x.pullback f) ",":= by
  dsimp [mk, plusObj]
  rw [‚Üê comp_apply (x := (Meq.equiv P S).symm x), Œπ_colimMap_assoc, colimit.Œπ_pre,
    comp_apply (x := (Meq.equiv P S).symm x)]
  apply congr_arg
  apply (Meq.equiv P _).injective
  erw [Equiv.apply_symm_apply]
  ext i
  simp only [Functor.op_obj, unop_op, pullback_obj, diagram_obj, Functor.comp_obj,
    diagramPullback_app, Meq.equiv_apply, Meq.pullback_apply]
  erw [‚Üê comp_apply, Multiequalizer.lift_Œπ, Meq.equiv_symm_eq_apply]
  cases i; rfl",":= by
  dsimp [mk, plusObj]
  rw [‚Üê comp_apply (x := (Meq.equiv P S).symm x), Œπ_colimMap_assoc, colimit.Œπ_pre,
    comp_apply (x := (Meq.equiv P S).symm x)]
  apply congr_arg
  apply (Meq.equiv P _).injective
  erw [Equiv.apply_symm_apply]
  ext i
  simp only [Functor.op_obj, unop_op, pullback_obj, diagram_obj, Functor.comp_obj,
    diagramPullback_app, Meq.equiv_apply, Meq.pullback_apply]
  erw [‚Üê comp_apply, Multiequalizer.lift_proj, Meq.equiv_symm_eq_apply]
  cases i; rfl"
Mathlib/Order/Zorn.lean,IsChain.exists_maxChain,IsChain.exists_maxChain,526ab32ac62f3b2a9004d911c7ead5f3468d13ed,":= by
  have H := zorn_subset_nonempty { s | c ‚äÜ s ‚àß IsChain r s } ?_ c ‚ü®Subset.rfl, hc‚ü©
  ¬∑ obtain ‚ü®M, ‚ü®_, hM‚ÇÄ‚ü©, hM‚ÇÅ, hM‚ÇÇ‚ü© := H
    exact ‚ü®M, ‚ü®hM‚ÇÄ, fun d hd hMd => (hM‚ÇÇ _ ‚ü®hM‚ÇÅ.trans hMd, hd‚ü© hMd).symm‚ü©, hM‚ÇÅ‚ü©
  rintro cs hcs‚ÇÄ hcs‚ÇÅ ‚ü®s, hs‚ü©
  refine'
    ‚ü®‚ãÉ‚ÇÄcs, ‚ü®fun _ ha => Set.mem_union‚Çõ_of_mem ((hcs‚ÇÄ hs).left ha) hs, _‚ü©, fun _ =>
      Set.subset_union‚Çõ_of_mem‚ü©
  rintro y ‚ü®sy, hsy, hysy‚ü© z ‚ü®sz, hsz, hzsz‚ü© hyz
  obtain rfl | hsseq := eq_or_ne sy sz
  ¬∑ exact (hcs‚ÇÄ hsy).right hysy hzsz hyz
  cases' hcs‚ÇÅ hsy hsz hsseq with h h
  ¬∑ exact (hcs‚ÇÄ hsz).right (h hysy) hzsz hyz
  ¬∑ exact (hcs‚ÇÄ hsy).right hysy (h hzsz) hyz","error:  unknown constant 'Set.mem_union‚Çõ_of_mem'
error:  unknown constant 'Set.subset_union‚Çõ_of_mem'","theorem IsChain.exists_maxChain (hc : IsChain r c) : ‚àÉ M, @IsMaxChain _ r M ‚àß c ‚äÜ M ",":= by
  have H := zorn_subset_nonempty { s | c ‚äÜ s ‚àß IsChain r s } ?_ c ‚ü®Subset.rfl, hc‚ü©
  ¬∑ obtain ‚ü®M, ‚ü®_, hM‚ÇÄ‚ü©, hM‚ÇÅ, hM‚ÇÇ‚ü© := H
    exact ‚ü®M, ‚ü®hM‚ÇÄ, fun d hd hMd => (hM‚ÇÇ _ ‚ü®hM‚ÇÅ.trans hMd, hd‚ü© hMd).symm‚ü©, hM‚ÇÅ‚ü©
  rintro cs hcs‚ÇÄ hcs‚ÇÅ ‚ü®s, hs‚ü©
  refine
    ‚ü®‚ãÉ‚ÇÄcs, ‚ü®fun _ ha => Set.mem_sUnion_of_mem ((hcs‚ÇÄ hs).left ha) hs, ?_‚ü©, fun _ =>
      Set.subset_sUnion_of_mem‚ü©
  rintro y ‚ü®sy, hsy, hysy‚ü© z ‚ü®sz, hsz, hzsz‚ü© hyz
  obtain rfl | hsseq := eq_or_ne sy sz
  ¬∑ exact (hcs‚ÇÄ hsy).right hysy hzsz hyz
  cases' hcs‚ÇÅ hsy hsz hsseq with h h
  ¬∑ exact (hcs‚ÇÄ hsz).right (h hysy) hzsz hyz
  ¬∑ exact (hcs‚ÇÄ hsy).right hysy (h hzsz) hyz",":= by
  have H := zorn_subset_nonempty { s | c ‚äÜ s ‚àß IsChain r s } ?_ c ‚ü®Subset.rfl, hc‚ü©
  ¬∑ obtain ‚ü®M, ‚ü®_, hM‚ÇÄ‚ü©, hM‚ÇÅ, hM‚ÇÇ‚ü© := H
    exact ‚ü®M, ‚ü®hM‚ÇÄ, fun d hd hMd => (hM‚ÇÇ _ ‚ü®hM‚ÇÅ.trans hMd, hd‚ü© hMd).symm‚ü©, hM‚ÇÅ‚ü©
  rintro cs hcs‚ÇÄ hcs‚ÇÅ ‚ü®s, hs‚ü©
  refine
    ‚ü®‚ãÉ‚ÇÄcs, ‚ü®fun _ ha => Set.mem_union‚Çõ_of_mem ((hcs‚ÇÄ hs).left ha) hs, ?_‚ü©, fun _ =>
      Set.subset_union‚Çõ_of_mem‚ü©
  rintro y ‚ü®sy, hsy, hysy‚ü© z ‚ü®sz, hsz, hzsz‚ü© hyz
  obtain rfl | hsseq := eq_or_ne sy sz
  ¬∑ exact (hcs‚ÇÄ hsy).right hysy hzsz hyz
  cases' hcs‚ÇÅ hsy hsz hsseq with h h
  ¬∑ exact (hcs‚ÇÄ hsz).right (h hysy) hzsz hyz
  ¬∑ exact (hcs‚ÇÄ hsy).right hysy (h hzsz) hyz"
Mathlib/CategoryTheory/Limits/Final.lean,CategoryTheory.Functor.initial_of_comp_full_faithful,initial_of_comp_full_faithful,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  out d :=
    have := CostructuredArrow.isEquivalencePost d F G
    isConnected_of_equivalent (CostructuredArrow.post F G d).asEquivalence.symm","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  CostructuredArrow
has type
  ?m.255674 ‚•§ ?m.255783 ‚Üí ?m.255783 ‚Üí Type (max ?u.255671 ?u.255672)
error:  invalid occurrence of universe level 'u_1' at 'CategoryTheory.Functor.initial_comp_equivalence', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  initial_of_comp_full_faithful.{v‚ÇÅ, v‚ÇÉ, v‚ÇÇ, u‚ÇÅ, u‚ÇÉ, u‚ÇÇ, u_1} (comp.{v‚ÇÅ, v‚ÇÇ, v‚ÇÉ, u‚ÇÅ, u‚ÇÇ, u‚ÇÉ} F G)
    (inv.{v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G)
at declaration body
  fun {C : Type u‚ÇÅ} [Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ, u‚ÇÇ} D] {E : Type u‚ÇÉ} [Category.{v‚ÇÉ, u‚ÇÉ} E]
      (F : C ‚•§ D) (G : D ‚•§ E) [F.Initial] [G.IsEquivalence] ‚Ü¶
    let i : F ‚âÖ (F ‚ãô G) ‚ãô G.inv := isoWhiskerLeft F G.asEquivalence.unitIso;
    let_fun this : ((F ‚ãô G) ‚ãô G.inv).Initial := initial_of_natIso i;
    initial_of_comp_full_faithful (F ‚ãô G) G.inv
error:  unknown identifier 'initial_comp_equivalence'
error:  invalid occurrence of universe level 'u_1' at 'CategoryTheory.Functor.initial_of_comp_full_faithful'', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  initial_of_comp_full_faithful.{v‚ÇÅ, v‚ÇÇ, v‚ÇÉ, u‚ÇÅ, u‚ÇÇ, u‚ÇÉ, u_1} F G
at declaration body
  fun {C : Type u‚ÇÅ} [Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ, u‚ÇÇ} D] {E : Type u‚ÇÉ} [Category.{v‚ÇÉ, u‚ÇÉ} E]
      (F : C ‚•§ D) (G : D ‚•§ E) [G.Full] [G.Faithful] [(F ‚ãô G).Initial] ‚Ü¶
    let_fun this : F.Initial := initial_of_comp_full_faithful F G;
    initial_of_initial_comp F G
error:  invalid occurrence of universe level 'u_1' at 'CategoryTheory.Functor.initial_iff_comp_initial_full_faithful', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  initial_of_comp_full_faithful.{v‚ÇÅ, v‚ÇÇ, v‚ÇÉ, u‚ÇÅ, u‚ÇÇ, u‚ÇÉ, u_1} F G
at declaration body
  fun {C : Type u‚ÇÅ} [Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ, u‚ÇÇ} D] {E : Type u‚ÇÉ} [Category.{v‚ÇÉ, u‚ÇÉ} E]
      (F : C ‚•§ D) (G : D ‚•§ E) [G.Initial] [G.Full] [G.Faithful] ‚Ü¶
    { mp := fun (x : F.Initial) ‚Ü¶ initial_comp F G,
      mpr := fun (x : (F ‚ãô G).Initial) ‚Ü¶ initial_of_comp_full_faithful F G }","theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ‚ãô G)] : Initial F where
",  out d := isConnected_of_equivalent (CostructuredArrow.post F G d).asEquivalence.symm,":=
    have := CostructuredArrow.isEquivalencePost d F G
    isConnected_of_equivalent (CostructuredArrow.post F G d)"
Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean,CategoryTheory.Limits.hasFiniteLimits_of_hasFiniteLimits_of_size,hasFiniteLimits_of_hasFiniteLimits_of_size,2ac7d87c221020b247729b180bbe2575cceb0700,"  out := fun J hJ hhJ => by
    haveI := h (ULiftHom.{w} (ULift.{w} J)) <| @CategoryTheory.finCategoryUlift J hJ hhJ
    have l : @Equivalence J (ULiftHom (ULift J)) hJ
                          (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) :=
      @ULiftHomULiftCategory.equiv J hJ
    apply @hasLimitsOfShape_of_equivalence (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) C _ J hJ
      (@Equivalence.symm J hJ (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) l) _
    class HasFiniteColimits : Prop where
  out (J : Type) [ùí• : SmallCategory J] [@FinCategory J ùí•] : @HasColimitsOfShape J ùí• C _",error:  'CategoryTheory.Limits.HasFiniteColimits' has already been declared,"theorem hasFiniteLimits_of_hasFiniteLimits_of_size
    (h : ‚àÄ (J : Type w) {ùí• : SmallCategory J} (_ : @FinCategory J ùí•), HasLimitsOfShape J C) :
    HasFiniteLimits C where
","  out := fun J hJ hhJ => by
    haveI := h (ULiftHom.{w} (ULift.{w} J)) <| @CategoryTheory.finCategoryUlift J hJ hhJ
    have l : @Equivalence J (ULiftHom (ULift J)) hJ
                          (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) :=
      @ULiftHomULiftCategory.equiv J hJ
    apply @hasLimitsOfShape_of_equivalence (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) C _ J hJ
      (@Equivalence.symm J hJ (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) l) _
    ",":= fun J hJ hhJ => by
    haveI := h (ULiftHom.{w} (ULift.{w} J)) <| @CategoryTheory.finCategoryUlift J hJ hhJ
    have l : @Equivalence J (ULiftHom (ULift J)) hJ
                         (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) :=
      @ULiftHomULiftCategory.equiv J hJ
    apply @hasLimitsOfShape_of_equivalence (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) C _ J hJ
      (@Equivalence.symm J hJ (ULiftHom (ULift J))
      (@ULiftHom.category J) (@uliftCategory J hJ)) l) _
    class HasFiniteColimits : Prop where
  out (J : Type) [ùí• : SmallCategory J] [@FinCategory J ùí•] : @HasColimitsOfShape J ùí• C _"
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,5fb9beab28702fb284701d494bc9b7c5f52fef53,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      refine' ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      refine' ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine' ‚ü®U, {j}, _, _‚ü©
    ¬∑ rintro i h
      rw [Finset.mem_singleton] at h
      dsimp
      rw [dif_pos h]
      subst h
      exact hV
    ¬∑ dsimp
      simp
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ (e) (_he : e ‚àà G), j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine' ‚ü®j, V, _, _‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine' this _ _ _ (univ _) (inter _) _
      intro e he
      dsimp
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      rw [‚Üê coe_comp, D.w]
      rfl","error:  unknown identifier 'isTopologicalBasis_iInf'
error:  no goals to be solved","theorem isTopologicalBasis_cofiltered_limit (T : ‚àÄ j, Set (Set (F.obj j)))
    (hT : ‚àÄ j, IsTopologicalBasis (T j)) (univ : ‚àÄ i : J, Set.univ ‚àà T i)
    (inter : ‚àÄ (i) (U1 U2 : Set (F.obj i)), U1 ‚àà T i ‚Üí U2 ‚àà T i ‚Üí U1 ‚à© U2 ‚àà T i)
    (compat : ‚àÄ (i j : J) (f : i ‚ü∂ j) (V : Set (F.obj j)) (_hV : V ‚àà T j), F.map f ‚Åª¬π' V ‚àà T i) :
    IsTopologicalBasis
      {U : Set C.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = C.œÄ.app j ‚Åª¬π' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [‚Üê coe_comp, D.w] 
      rfl",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      refine ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      refine ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ rintro i h
      rw [Finset.mem_singleton] at h
      dsimp
      rw [dif_pos h]
      subst h
      exact hV
    ¬∑ dsimp
      simp
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ (e) (_he : e ‚àà G), j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
        exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
        exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
        exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
        exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
        exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ ("
Mathlib/Data/Fin/Basic.lean,Fin.liftFun_iff_succ,liftFun_iff_succ,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  constructor
  ¬∑ intro H i
    exact H i.castSucc_lt_succ
  ¬∑ refine' fun H i => Fin.induction _ _
    ¬∑ exact fun h => (h.not_le (zero_le i)).elim
    ¬∑ intro j ihj hij
      rw [‚Üê le_castSucc_iff] at hij
      rcases hij.eq_or_lt with (rfl | hlt)
      exacts [H j, _root_.trans (ihj hlt) (H j)]","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  typeclass instance problem is stuck, it is often due to metavariables
  Preorder (?m.76708 h)
error:  application type mismatch
  LE.le.eq_or_lt hij
argument
  hij
has type
  @LE.le (Fin (n + 1)) instLEFin i j.castSucc : Prop
but is expected to have type
  @LE.le (Fin (n + 1)) Preorder.toLE i j.castSucc : Prop","theorem liftFun_iff_succ {Œ± : Type*} (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] {f : Fin (n + 1) ‚Üí Œ±} :
    ((¬∑ < ¬∑) ‚áí r) f f ‚Üî ‚àÄ i : Fin n, r (f (castSucc i)) (f i.succ) ",":= by
  constructor
  ¬∑ intro H i
    exact H i.castSucc_lt_succ
  ¬∑ refine fun H i => Fin.induction (fun h ‚Ü¶ ?_) ?_
    ¬∑ simp [le_def] at h
    ¬∑ intro j ihj hij
      rw [‚Üê le_castSucc_iff] at hij
      obtain hij | hij := (le_def.1 hij).eq_or_lt
      ¬∑ obtain rfl := ext hij
        exact H _
      ¬∑ exact _root_.trans (ihj hij) (H j)",":= by
  constructor
  ¬∑ intro H i
    exact H i.castSucc_lt_succ
  ¬∑ refine fun H i => Fin.induction _ ?_
    ¬∑ exact fun h => (h.not_le (zero_le i)).elim
    ¬∑ intro j ihj hij
      rw [‚Üê le_castSucc_iff] at hij
      rcases hij.eq_or_lt with (rfl | hlt)
      exacts [H j, _root_.trans (ihj hlt) (H j)]"
Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean,MeasureTheory.TendstoInMeasure.exists_seq_tendsto_ae,TendstoInMeasure.exists_seq_tendsto_ae,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  have h_lt_Œµ_real : ‚àÄ (Œµ : ‚Ñù) (_ : 0 < Œµ), ‚àÉ k : ‚Ñï, 2 * (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := by
    intro Œµ hŒµ
    obtain ‚ü®k, h_k‚ü© : ‚àÉ k : ‚Ñï, (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := exists_pow_lt_of_lt_one hŒµ (by norm_num)
    refine' ‚ü®k + 1, (le_of_eq _).trans_lt h_k‚ü©
    rw [pow_add]; ring
  set ns := ExistsSeqTendstoAe.seqTendstoAeSeq hfg
  use ns
  let S := fun k => { x | (2 : ‚Ñù)‚Åª¬π ^ k ‚â§ dist (f (ns k) x) (g x) }
  have hŒºS_le : ‚àÄ k, Œº (S k) ‚â§ (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ k :=
    fun k => ExistsSeqTendstoAe.seqTendstoAeSeq_spec hfg k (ns k) le_rfl
  set s := Filter.atTop.limsup S with hs
  have hŒºs : Œº s = 0 := by
    refine' measure_limsup_eq_zero (ne_of_lt <| lt_of_le_of_lt (ENNReal.tsum_le_tsum hŒºS_le) _)
    simp only [ENNReal.tsum_geometric, ENNReal.one_sub_inv_two, ENNReal.two_lt_top, inv_inv]
  have h_tendsto : ‚àÄ x ‚àà s·∂ú, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) := by
    refine' fun x hx => Metric.tendsto_atTop.mpr fun Œµ hŒµ => _
    rw [hs, limsup_eq_iInf_iSup_of_nat] at hx
    simp only [Set.iSup_eq_iUnion, Set.iInf_eq_iInter, Set.compl_iInter, Set.compl_iUnion,
      Set.mem_iUnion, Set.mem_iInter, Set.mem_compl_iff, Set.mem_setOf_eq, not_le] at hx
    obtain ‚ü®N, hNx‚ü© := hx
    obtain ‚ü®k, hk_lt_Œµ‚ü© := h_lt_Œµ_real Œµ hŒµ
    refine' ‚ü®max N (k - 1), fun n hn_ge => lt_of_le_of_lt _ hk_lt_Œµ‚ü©
    specialize hNx n ((le_max_left _ _).trans hn_ge)
    have h_inv_n_le_k : (2 : ‚Ñù)‚Åª¬π ^ n ‚â§ 2 * (2 : ‚Ñù)‚Åª¬π ^ k := by
      rw [mul_comm, ‚Üê inv_mul_le_iff' (zero_lt_two' ‚Ñù)]
      conv_lhs =>
        congr
        rw [‚Üê pow_one (2 : ‚Ñù)‚Åª¬π]
      rw [‚Üê pow_add, add_comm]
      exact pow_le_pow_of_le_one (one_div (2 : ‚Ñù) ‚ñ∏ one_half_pos.le) (inv_le_one one_le_two)
        ((le_tsub_add.trans (add_le_add_right (le_max_right _ _) 1)).trans
          (add_le_add_right hn_ge 1))
    exact le_trans hNx.le h_inv_n_le_k
  rw [ae_iff]
  refine' ‚ü®ExistsSeqTendstoAe.seqTendstoAeSeq_strictMono hfg, measure_mono_null (fun x => _) hŒºs‚ü©
  rw [Set.mem_setOf_eq, ‚Üê @Classical.not_not (x ‚àà s), not_imp_not]
  exact h_tendsto x","error:  invalid field 'le', the environment does not contain 'Not.le'
  hNx
has type
  x ‚àâ S n
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hNx
has type
  x ‚àà S n ‚Üí False","theorem TendstoInMeasure.exists_seq_tendsto_ae (hfg : TendstoInMeasure Œº f atTop g) :
    ‚àÉ ns : ‚Ñï ‚Üí ‚Ñï, StrictMono ns ‚àß ‚àÄ·µê x ‚àÇŒº, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) ",":= by
  have h_lt_Œµ_real : ‚àÄ (Œµ : ‚Ñù) (_ : 0 < Œµ), ‚àÉ k : ‚Ñï, 2 * (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := by
    intro Œµ hŒµ
    obtain ‚ü®k, h_k‚ü© : ‚àÉ k : ‚Ñï, (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := exists_pow_lt_of_lt_one hŒµ (by norm_num)
    refine ‚ü®k + 1, (le_of_eq ?_).trans_lt h_k‚ü©
    rw [pow_add]; ring
  set ns := ExistsSeqTendstoAe.seqTendstoAeSeq hfg
  use ns
  let S := fun k => { x | (2 : ‚Ñù)‚Åª¬π ^ k ‚â§ dist (f (ns k) x) (g x) }
  have hŒºS_le : ‚àÄ k, Œº (S k) ‚â§ (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ k :=
    fun k => ExistsSeqTendstoAe.seqTendstoAeSeq_spec hfg k (ns k) le_rfl
  set s := Filter.atTop.limsup S with hs
  have hŒºs : Œº s = 0 := by
    refine measure_limsup_eq_zero (ne_of_lt <| lt_of_le_of_lt (ENNReal.tsum_le_tsum hŒºS_le) ?_)
    simp only [ENNReal.tsum_geometric, ENNReal.one_sub_inv_two, ENNReal.two_lt_top, inv_inv]
  have h_tendsto : ‚àÄ x ‚àà s·∂ú, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) := by
    refine fun x hx => Metric.tendsto_atTop.mpr fun Œµ hŒµ => ?_
    rw [hs, limsup_eq_iInf_iSup_of_nat] at hx
    simp only [S, Set.iSup_eq_iUnion, Set.iInf_eq_iInter, Set.compl_iInter, Set.compl_iUnion,
      Set.mem_iUnion, Set.mem_iInter, Set.mem_compl_iff, Set.mem_setOf_eq, not_le] at hx
    obtain ‚ü®N, hNx‚ü© := hx
    obtain ‚ü®k, hk_lt_Œµ‚ü© := h_lt_Œµ_real Œµ hŒµ
    refine ‚ü®max N (k - 1), fun n hn_ge => lt_of_le_of_lt ?_ hk_lt_Œµ‚ü©
    specialize hNx n ((le_max_left _ _).trans hn_ge)
    have h_inv_n_le_k : (2 : ‚Ñù)‚Åª¬π ^ n ‚â§ 2 * (2 : ‚Ñù)‚Åª¬π ^ k := by
      rw [mul_comm, ‚Üê inv_mul_le_iff' (zero_lt_two' ‚Ñù)]
      conv_lhs =>
        congr
        rw [‚Üê pow_one (2 : ‚Ñù)‚Åª¬π]
      rw [‚Üê pow_add, add_comm]
      exact pow_le_pow_of_le_one (one_div (2 : ‚Ñù) ‚ñ∏ one_half_pos.le) (inv_le_one one_le_two)
        ((le_tsub_add.trans (add_le_add_right (le_max_right _ _) 1)).trans
          (add_le_add_right hn_ge 1))
    exact le_trans hNx.le h_inv_n_le_k
  rw [ae_iff]
  refine ‚ü®ExistsSeqTendstoAe.seqTendstoAeSeq_strictMono hfg, measure_mono_null (fun x => ?_) hŒºs‚ü©
  rw [Set.mem_setOf_eq, ‚Üê @Classical.not_not (x ‚àà s), not_imp_not]
  exact h_tendsto x",":= by
  have h_lt_Œµ_real : ‚àÄ (Œµ : ‚Ñù) (_ : 0 < Œµ), ‚àÉ k : ‚Ñï, 2 * (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := by
    intro Œµ hŒµ
    obtain ‚ü®k, h_k‚ü© : ‚àÉ k : ‚Ñï, (2 : ‚Ñù)‚Åª¬π ^ k < Œµ := exists_pow_lt_of_lt_one hŒµ (by norm_num)
    refine ‚ü®k + 1, (le_of_eq ?_).trans_lt h_k‚ü©
    rw [pow_add]; ring
  set ns := ExistsSeqTendstoAe.seqTendstoAeSeq hfg
  use ns
  let S := fun k => { x | (2 : ‚Ñù)‚Åª¬π ^ k ‚â§ dist (f (ns k) x) (g x) }
  have hŒºS_le : ‚àÄ k, Œº (S k) ‚â§ (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ k :=
    fun k => ExistsSeqTendstoAe.seqTendstoAeSeq_spec hfg k (ns k) le_rfl
  set s := Filter.atTop.limsup S with hs
  have hŒºs : Œº s = 0 := by
    refine measure_limsup_eq_zero (ne_of_lt <| lt_of_le_of_lt (ENNReal.tsum_le_tsum hŒºS_le) ?_)
    simp only [ENNReal.tsum_geometric, ENNReal.one_sub_inv_two, ENNReal.two_lt_top, inv_inv]
  have h_tendsto : ‚àÄ x ‚àà s·∂ú, Tendsto (fun i => f (ns i) x) atTop (ùìù (g x)) := by
    refine fun x hx => Metric.tendsto_atTop.mpr fun Œµ hŒµ => ?_
    rw [hs, limsup_eq_iInf_iSup_of_nat] at hx
    simp only [Set.iSup_eq_iUnion, Set.iInf_eq_iInter, Set.compl_iInter, Set.compl_iUnion,
      Set.mem_iUnion, Set.mem_iInter, Set.mem_compl_iff, Set.mem_setOf_eq, not_le] at hx
    obtain ‚ü®N, hNx‚ü© := hx
    obtain ‚ü®k, hk_lt_Œµ‚ü© := h_lt_Œµ_real Œµ hŒµ
    refine ‚ü®max N (k - 1), fun n hn_ge => lt_of_le_of_lt ?_ hk_lt_Œµ‚ü©
    specialize hNx n ((le_max_left _ _).trans hn_ge)
    have h_inv_n_le_k : (2 : ‚Ñù)‚Åª¬π ^ n ‚â§ 2 * (2 : ‚Ñù)‚Åª¬π ^ k := by
      rw [mul_comm, ‚Üê inv_mul_le_iff' (zero_lt_two' ‚Ñù)]
      conv_lhs =>
        congr
        rw [‚Üê pow_one (2 : ‚Ñù)‚Åª¬π]
      rw [‚Üê pow_add, add_comm]
      exact pow_le_pow_of_le_one (one_div (2 : ‚Ñù) ‚ñ∏ one_half_pos.le) (inv_le_one one_le_two)
        ((le_tsub_add.trans (add_le_add_right (le_max_right _ _) 1)).trans
          (add_le_add_right hn_ge 1))
    exact le_trans hNx.le h_inv_n_le_k
  rw [ae_iff]
  refine ‚ü®ExistsSeqTendstoAe.seqTendstoAeSeq_strictMono hfg, measure_mono_null (fun x => ?_) hŒºs‚ü©
  rw [Set.mem_setOf_eq, ‚Üê @Classical.not_not (x ‚àà s), not_imp_not]
  exact h_tendsto x"
Mathlib/Data/Matroid/Dual.lean,Matroid.setOf_dual_base_eq,setOf_dual_base_eq,67ee3b7709353762fdc01cfb00722ee8c27ff6a5,":= by
  ext B
  simp only [mem_setOf_eq, mem_image, dual_base_iff']
  refine ‚ü®fun h ‚Ü¶ ‚ü®_, h.1, diff_diff_cancel_left h.2‚ü©,
    fun ‚ü®B', hB', h‚ü© ‚Ü¶ ‚ü®?_,h.symm.trans_subset (diff_subset _ _)‚ü©‚ü©
  rwa [‚Üê h, diff_diff_cancel_left hB'.subset_ground]","error:  function expected at
  diff_subset ?m.25303
term has type
  ?m.25302 ‚àà ?m.25300",theorem setOf_dual_base_eq : {B | M‚ú∂.Base B} = (fun X ‚Ü¶ M.E \ X) '' {B | M.Base B} ,":= by
  ext B
  simp only [mem_setOf_eq, mem_image, dual_base_iff']
  refine ‚ü®fun h ‚Ü¶ ‚ü®_, h.1, diff_diff_cancel_left h.2‚ü©,
    fun ‚ü®B', hB', h‚ü© ‚Ü¶ ‚ü®?_,h.symm.trans_subset diff_subset‚ü©‚ü©
  rwa [‚Üê h, diff_diff_cancel_left hB'.subset_ground]",":= by
  ext B
  simp only [mem_setOf_eq, mem_image, dual_base_iff']
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, h.1, diff_diff_cancel_left h.2‚ü©,
    fun ‚ü®B', hB', h‚ü© ‚Ü¶ ‚ü®?_,h.symm.trans_subset diff_subset‚ü©‚ü©
  rwa [‚Üê h, diff_diff_cancel_left hB'.subset_ground]"
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x)
  ¬∑ simp (config := { unfoldPartialApp := true }) only [inversion]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π
    ¬∑ rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  unexpected token '¬∑'; expected '|'
error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ F ‚ÜíL[‚Ñù] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x ‚Ü¶ c + x) x) c) ^ 2 ‚Ä¢
      ‚Üë{ toLinearEquiv := (reflection (Submodule.span ‚Ñù {(fun x ‚Ü¶ c + x) x - c})·óÆ).toLinearEquiv, continuous_toFun := ‚ãØ,
          continuous_invFun := ‚ãØ })
    ((fun x ‚Ü¶ c + x) x)","theorem hasFDerivAt_inversion (hx : x ‚â† c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 ‚Ä¢ (reflection (‚Ñù ‚àô (x - c))·óÆ : F ‚ÜíL[‚Ñù] F)) x ",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (?_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x)
  ¬∑ simp (config := { unfoldPartialApp := true }) only [inversion]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π
    ¬∑ rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]"
Mathlib/RingTheory/ChainOfDivisors.lean,DivisorChain.element_of_chain_eq_pow_second_of_chain,element_of_chain_eq_pow_second_of_chain,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine'
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ‚ü®‚ü®i, ?_‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_) _
      refine
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) ?_ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine dvd_trans ?_ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2","error:  type mismatch
  Set.injOn_of_injective (fun m m' h ‚Ü¶ Fin.ext (?m.30170 m m' h)) ?m.30176
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Fin ?m.30169‚¶Ñ, x‚ÇÇ ‚àà ?m.30174 ‚Üí ?m.30152 ?m.30175 = ?m.30152 x‚ÇÇ ‚Üí ?m.30175 = x‚ÇÇ : Prop
but is expected to have type
  Set.InjOn (fun m ‚Ü¶ c 1 ^ ‚Üëm) ‚ÜëFinset.univ : Prop","theorem element_of_chain_eq_pow_second_of_chain {q r : Associates M} {n : ‚Ñï} (hn : n ‚â† 0)
    {c : Fin (n + 1) ‚Üí Associates M} (h‚ÇÅ : StrictMono c) (h‚ÇÇ : ‚àÄ {r}, r ‚â§ q ‚Üî ‚àÉ i, r = c i)
    (hr : r ‚à£ q) (hq : q ‚â† 0) : ‚àÉ i : Fin (n + 1), r = c 1 ^ (i : ‚Ñï) ",":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ‚ü®‚ü®i, ?_‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_)
      refine
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) ?_ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine dvd_trans ?_ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2",":= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine
        eq_second_of_chain_of_prime_dvd hn h‚ÇÅ (@fun r' => h‚ÇÇ) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ‚ü®‚ü®i, ?_‚ü©, H‚ü©
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card = i + 1 := by
      conv_rhs => rw [‚Üê Finset.card_fin (i + 1)]
      cases n
      ¬∑ contradiction
      rw [Finset.card_image_iff]
      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_) ?_
      refine
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h‚ÇÅ) ?_ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq)
    suffices H' : ‚àÄ r ‚àà Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï), r ‚â§ q by
      simp only [‚Üê Nat.succ_le_iff, Nat.succ_eq_add_one, ‚Üê this]
      apply card_subset_divisors_le_length_of_chain (@h‚ÇÇ) H'
    simp only [Finset.mem_image]
    rintro r ‚ü®a, _, rfl‚ü©
    refine dvd_trans ?_ hr
    use c 1 ^ (i - (a : ‚Ñï))
    rw [pow_mul_pow_sub (c 1)]
    ¬∑ exact H
    ¬∑ exact Nat.succ_le_succ_iff.mp a.2"
Mathlib/GroupTheory/Perm/Fin.lean,Equiv.Perm.decomposeFin_symm_of_one,Equiv.Perm.decomposeFin_symm_of_one,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  Equiv.Perm.decomposeFin_symm_of_refl p","error:  unsolved goals
case H.h.succ.refine_1
n‚úù : ‚Ñï
i : Fin (n‚úù + 1).succ
‚ä¢ 1 = ‚Üë((decomposeFin.symm (1, finRotate (n‚úù + 1))) 0)","theorem Equiv.Perm.decomposeFin_symm_of_one {n : ‚Ñï} (p : Fin (n + 1)) :
    Equiv.Perm.decomposeFin.symm (p, 1) = swap 0 p ",":=
  Equiv.Perm.decomposeFin_symm_of_refl p",":=
  Equiv.Perm.decomposeFin_symm p"
Mathlib/Geometry/Euclidean/Angle/Sphere.lean,EuclideanGeometry.cospherical_or_collinear_of_two_zsmul_oangle_eq,cospherical_or_collinear_of_two_zsmul_oangle_eq,51a5ef1cda5da86f2874f1cacc8625b3ebd1a370,":= by
  by_cases hc : Collinear ‚Ñù ({p‚ÇÅ, p‚ÇÇ, p‚ÇÑ} : Set P)
  ¬∑ by_cases he : p‚ÇÅ = p‚ÇÑ
    ¬∑ rw [he, Set.insert_eq_self.2
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _)))]
      by_cases hl : Collinear ‚Ñù ({p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P); ¬∑ exact Or.inr hl
      rw [or_iff_left hl]
      let t : Affine.Triangle ‚Ñù P := ‚ü®![p‚ÇÇ, p‚ÇÉ, p‚ÇÑ], affineIndependent_iff_not_collinear_set.2 hl‚ü©
      rw [cospherical_iff_exists_sphere]
      refine' ‚ü®t.circumsphere, _‚ü©
      simp_rw [Set.insert_subset, Set.singleton_subset_iff]
      exact ‚ü®t.mem_circumsphere 0, t.mem_circumsphere 1, t.mem_circumsphere 2‚ü©
    have hc' : Collinear ‚Ñù ({p‚ÇÅ, p‚ÇÉ, p‚ÇÑ} : Set P) := by
      rwa [‚Üê collinear_iff_of_two_zsmul_oangle_eq h]
    refine' Or.inr _
    rw [Set.insert_comm p‚ÇÅ p‚ÇÇ] at hc
    rwa [Set.insert_comm p‚ÇÅ p‚ÇÇ, hc'.collinear_insert_iff_of_ne (Set.mem_insert _ _)
      (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))) he]
  ¬∑ exact Or.inl (cospherical_of_two_zsmul_oangle_eq_of_not_collinear h hc)",error:  simp made no progress,"theorem cospherical_or_collinear_of_two_zsmul_oangle_eq {p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P}
    (h : (2 : ‚Ñ§) ‚Ä¢ ‚à° p‚ÇÅ p‚ÇÇ p‚ÇÑ = (2 : ‚Ñ§) ‚Ä¢ ‚à° p‚ÇÅ p‚ÇÉ p‚ÇÑ) :
    Cospherical ({p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) ‚à® Collinear ‚Ñù ({p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) ",":= by
  by_cases hc : Collinear ‚Ñù ({p‚ÇÅ, p‚ÇÇ, p‚ÇÑ} : Set P)
  ¬∑ by_cases he : p‚ÇÅ = p‚ÇÑ
    ¬∑ rw [he, Set.insert_eq_self.2
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _)))]
      by_cases hl : Collinear ‚Ñù ({p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P); ¬∑ exact Or.inr hl
      rw [or_iff_left hl]
      let t : Affine.Triangle ‚Ñù P := ‚ü®![p‚ÇÇ, p‚ÇÉ, p‚ÇÑ], affineIndependent_iff_not_collinear_set.2 hl‚ü©
      rw [cospherical_iff_exists_sphere]
      refine ‚ü®t.circumsphere, ?_‚ü©
      simp_rw [Set.insert_subset_iff, Set.singleton_subset_iff]
      exact ‚ü®t.mem_circumsphere 0, t.mem_circumsphere 1, t.mem_circumsphere 2‚ü©
    have hc' : Collinear ‚Ñù ({p‚ÇÅ, p‚ÇÉ, p‚ÇÑ} : Set P) := by
      rwa [‚Üê collinear_iff_of_two_zsmul_oangle_eq h]
    refine Or.inr ?_
    rw [Set.insert_comm p‚ÇÅ p‚ÇÇ] at hc
    rwa [Set.insert_comm p‚ÇÅ p‚ÇÇ, hc'.collinear_insert_iff_of_ne (Set.mem_insert _ _)
      (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))) he]
  ¬∑ exact Or.inl (cospherical_of_two_zsmul_oangle_eq_of_not_collinear h hc)",":= by
  by_cases hc : Collinear ‚Ñù ({p‚ÇÅ, p‚ÇÇ, p‚ÇÑ} : Set P)
  ¬∑ by_cases he : p‚ÇÅ = p‚ÇÑ
    ¬∑ rw [he, Set.insert_eq_self.2
        (Set.mem_insert_of_mem _ Set.mem_insert_of_mem _ Set.mem_singleton _))]
      by_cases hl : Collinear ‚Ñù ({p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P); ¬∑ exact Or.inr hl
      rw [or_iff_left hl]
      let t : Affine.Triangle ‚Ñù P := ‚ü®![p‚ÇÇ, p‚ÇÉ, p‚ÇÑ], affineIndependent_iff_not_collinear_set.2 hl‚ü©
      rw [cospherical_iff_exists_sphere]
      refine ‚ü®t.circumsphere, ?_‚ü©
      simp_rw [Set.insert_subset, Set.singleton_subset_iff]
      exact ‚ü®t.mem_circumsphere 0, t.mem_circumsphere 1, t.mem_circumsphere 2‚ü©
    have hc' : Collinear ‚Ñù ({p‚ÇÅ, p‚ÇÉ, p‚ÇÑ} : Set P) := by
      rwa [‚Üê collinear_iff_of_two_zsmul_oangle_eq h]
    refine Or.inr ?_
    rw [Set.insert_comm p‚ÇÅ p‚ÇÇ] at hc
    rwa [Set.insert_comm p‚ÇÅ p‚ÇÇ, hc'.collinear_insert_iff_of_ne (Set.mem_insert _ _)
      (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))) he]
  ¬∑ exact Or.inl (cospherical_of_two_zsmul_oangle_eq_of_not_collinear h hc)"
Mathlib/NumberTheory/Bertrand.lean,bertrand_main_inequality,bertrand_main_inequality,047f73c34cd3e6bae28166f72847965b1a989c70,":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_nat_cast]
  have n_pos : 0 < n := (by decide : 0 < 512).trans_le n_large
  have n2_pos : 1 ‚â§ 2 * n := mul_pos (by decide) n_pos
  refine' trans (mul_le_mul _ _ _ _)
      (Bertrand.real_main_inequality (by exact_mod_cast n_large))
  ¬∑ refine' mul_le_mul_of_nonneg_left _ (Nat.cast_nonneg _)
    refine' Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast n2_pos) _
    exact_mod_cast Real.nat_sqrt_le_real_sqrt
  ¬∑ exact Real.rpow_le_rpow_of_exponent_le (by norm_num1) (cast_div_le.trans (by norm_cast))
  ¬∑ exact Real.rpow_nonneg_of_nonneg (by norm_num1) _
  ¬∑ refine' mul_nonneg (Nat.cast_nonneg _) _
    exact Real.rpow_nonneg_of_nonneg (mul_nonneg zero_le_two (Nat.cast_nonneg _)) _","warning:  `Real.rpow_nat_cast` has been deprecated, use `Real.rpow_natCast` instead
error:  ambiguous, possible interpretations 
  _root_.trans (mul_le_mul ?m.26269 ?m.26270 ?m.26271 ?m.26272)
    (Bertrand.real_main_inequality ?m.26573) : ‚Üën * (‚Üë2 * ‚Üën) ^ ‚Üë(2 * n).sqrt * ‚Üë4 ^ ‚Üë(2 * n / 3) ‚â§ ‚Üë4 ^ ‚Üën
  
  Trans.trans (mul_le_mul ?m.26766 ?m.26767 ?m.26768 ?m.26769)
    (Bertrand.real_main_inequality ?m.26904) : ‚Üën * (‚Üë2 * ‚Üën) ^ ‚Üë(2 * n).sqrt * ‚Üë4 ^ ‚Üë(2 * n / 3) ‚â§ ‚Üë4 ^ ‚Üën
error:  no goals to be solved","theorem bertrand_main_inequality {n : ‚Ñï} (n_large : 512 ‚â§ n) :
    n * (2 * n) ^ sqrt (2 * n) * 4 ^ (2 * n / 3) ‚â§ 4 ^ n ",":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_natCast]
  refine _root_.trans ?_ (Bertrand.real_main_inequality (by exact_mod_cast n_large))
  gcongr
  ¬∑ have n2_pos : 0 < 2 * n := by positivity
    exact mod_cast n2_pos
  ¬∑ exact_mod_cast Real.nat_sqrt_le_real_sqrt
  ¬∑ norm_num1
  ¬∑ exact cast_div_le.trans (by norm_cast)",":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_natCast]
  have n_pos : 0 < n := (by decide : 0 < 512).trans_le n_large
  have n2_pos : 1 ‚â§ 2 * n := mul_pos (by decide) n_pos
  refine trans (mul_le_mul _ _ _ _)
      (Bertrand.real_main_inequality (by exact_mod_cast n_large))
  ¬∑ refine mul_le_mul_of_nonneg_left ?_ (Nat.cast_nonneg _)
    refine Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast n2_pos) ?_
    exact_mod_cast Real.natCast_sqrt_le_real_sqrt
  ¬∑ exact Real.rpow_le_rpow_of_exponent_le (by norm_num1) (cast_div_le.trans (by norm_cast))
  ¬∑ exact Real.rpow_nonneg_of_nonneg (by norm_num1) _
  ¬∑ refine mul_nonneg (Nat.cast_nonneg _) ?_
    exact Real.rpow_nonneg_of_nonneg (mul_nonneg zero_le_two (Nat.cast_nonneg _)) _"
Mathlib/Combinatorics/Enumerative/Composition.lean,Composition.sizeUpTo_index_le,sizeUpTo_index_le,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  by_contra H
  set i := c.index j
  push_neg at H
  have i_pos : (0 : ‚Ñï) < i := by
    by_contra! i_pos
    revert H
    simp [nonpos_iff_eq_zero.1 i_pos, c.sizeUpTo_zero]
  let i‚ÇÅ := (i : ‚Ñï).pred
  have i‚ÇÅ_lt_i : i‚ÇÅ < i := Nat.pred_lt (ne_of_gt i_pos)
  have i‚ÇÅ_succ : i‚ÇÅ.succ = i := Nat.succ_pred_eq_of_pos i_pos
  have := Nat.find_min (c.index_exists j.2) i‚ÇÅ_lt_i
  simp [lt_trans i‚ÇÅ_lt_i (c.index j).2, i‚ÇÅ_succ] at this
  exact Nat.lt_le_asymm H this","error:  application type mismatch
  Nat.lt_le_asymm H this
argument
  this
has type
  c.sizeUpTo (i‚ÇÅ + 1) ‚â§ ‚Üëj : Prop
but is expected to have type
  c.sizeUpTo ‚Üëi ‚â§ ‚Üëj : Prop",theorem sizeUpTo_index_le (j : Fin n) : c.sizeUpTo (c.index j) ‚â§ j ,":= by
  by_contra H
  set i := c.index j
  push_neg at H
  have i_pos : (0 : ‚Ñï) < i := by
    by_contra! i_pos
    revert H
    simp [nonpos_iff_eq_zero.1 i_pos, c.sizeUpTo_zero]
  let i‚ÇÅ := (i : ‚Ñï).pred
  have i‚ÇÅ_lt_i : i‚ÇÅ < i := Nat.pred_lt (ne_of_gt i_pos)
  have i‚ÇÅ_succ : i‚ÇÅ + 1 = i := Nat.succ_pred_eq_of_pos i_pos
  have := Nat.find_min (c.index_exists j.2) i‚ÇÅ_lt_i
  simp [lt_trans i‚ÇÅ_lt_i (c.index j).2, i‚ÇÅ_succ] at this
  exact Nat.lt_le_asymm H this",":= by
  by_contra H
  set i := c.index j
  push_neg at H
  have i_pos : (0 : ‚Ñï) < i := by
    by_contra! i_pos
    revert H
    simp [nonpos_iff_eq_zero.1 i_pos, c.sizeUpTo_zero]
  let i‚ÇÅ := (i : ‚Ñï).pred
  have i‚ÇÅ_lt_i : i‚ÇÅ < i := Nat.pred_lt (ne_of_gt i_pos)
  have i‚ÇÅ_succ : i‚ÇÅ.succ = i := Nat.succ_pred_eq_of_pos i_pos
  have := Nat.find_min (c.index_exists j.2) i‚ÇÅ_lt_i
  simp [lt_trans i‚ÇÅ_lt_i (c.index j).2, i‚ÇÅ_succ] at this
  exact Nat.lt_le_asymm H this"
Mathlib/NumberTheory/Bertrand.lean,bertrand_main_inequality,bertrand_main_inequality,0f24aee7da46f85fee5cacc716172444ce31e582,":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_nat_cast]
  have n_pos : 0 < n := (by decide : 0 < 512).trans_le n_large
  have n2_pos : 1 ‚â§ 2 * n := mul_pos (by decide) n_pos
  refine' _root_.trans (mul_le_mul _ _ _ _)
      (Bertrand.real_main_inequality (mod_cast n_large))
  ¬∑ refine' mul_le_mul_of_nonneg_left _ (Nat.cast_nonneg _)
    refine' Real.rpow_le_rpow_of_exponent_le (mod_cast n2_pos) _
    exact_mod_cast Real.nat_sqrt_le_real_sqrt
  ¬∑ exact Real.rpow_le_rpow_of_exponent_le (by norm_num1) (cast_div_le.trans (by norm_cast))
  ¬∑ exact Real.rpow_nonneg_of_nonneg (by norm_num1) _
  ¬∑ refine' mul_nonneg (Nat.cast_nonneg _) _
    exact Real.rpow_nonneg_of_nonneg (mul_nonneg zero_le_two (Nat.cast_nonneg _)) _","warning:  `Real.rpow_nat_cast` has been deprecated, use `Real.rpow_natCast` instead
error:  unknown constant 'Real.rpow_nonneg_of_nonneg'
error:  unknown constant 'Real.rpow_nonneg_of_nonneg'","theorem bertrand_main_inequality {n : ‚Ñï} (n_large : 512 ‚â§ n) :
    n * (2 * n) ^ sqrt (2 * n) * 4 ^ (2 * n / 3) ‚â§ 4 ^ n ",":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_natCast]
  refine _root_.trans ?_ (Bertrand.real_main_inequality (by exact_mod_cast n_large))
  gcongr
  ¬∑ have n2_pos : 0 < 2 * n := by positivity
    exact mod_cast n2_pos
  ¬∑ exact_mod_cast Real.nat_sqrt_le_real_sqrt
  ¬∑ norm_num1
  ¬∑ exact cast_div_le.trans (by norm_cast)",":= by
  rw [‚Üê @cast_le ‚Ñù]
  simp only [cast_add, cast_one, cast_mul, cast_pow, ‚Üê Real.rpow_natCast]
  have n_pos : 0 < n := (by decide : 0 < 512).trans_le n_large
  have n2_pos : 1 ‚â§ 2 * n := mul_pos (by decide) n_pos
  refine _root_.trans (mul_le_mul _ _ _ _)
      (Bertrand.real_main_inequality (mod_cast n_large))
  ¬∑ refine mul_le_mul_of_nonneg_left ?_ (Nat.cast_nonneg _)
    refine Real.rpow_le_rpow_of_exponent_le (mod_cast n2_pos) ?_
    exact_mod_cast Real.natCast_sqrt_le_real_sqrt
  ¬∑ exact Real.rpow_le_rpow_of_exponent_le (by norm_num1) (cast_div_le.trans (by norm_cast))
  ¬∑ exact Real.rpow_nonneg_of_nonneg (by norm_num1) _
  ¬∑ refine mul_nonneg (Nat.cast_nonneg _) ?_
    exact Real.rpow_nonneg_of_nonneg (mul_nonneg zero_le_two (Nat.cast_nonneg _)) _"
Mathlib/MeasureTheory/Measure/Typeclasses.lean,MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ,countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only []
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine' countable_iUnion fun n => Finite.countable _
  exact finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite",error:  simp made no progress,"theorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ {Œπ : Type*} {_ : MeasurableSpace Œ±}
    (Œº : Measure Œ±) {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, NullMeasurableSet (As i) Œº)
    (As_disj : Pairwise (AEDisjoint Œº on As)) (Union_As_finite : Œº (‚ãÉ i, As i) ‚â† ‚àû) :
    Set.Countable { i : Œπ | 0 < Œº (As i) } ",":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only [fairmeas]
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable ?_
  exact finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite",":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only []
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable ?_
  exact finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite"
Mathlib/Analysis/InnerProductSpace/Projection.lean,OrthogonalFamily.sum_projection_of_mem_iSup,OrthogonalFamily.sum_projection_of_mem_iSup,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  induction hx using Submodule.iSup_induction' with
  | hp i x hx =>
    refine'
      (Finset.sum_eq_single_of_mem i (Finset.mem_univ _) fun j _ hij => _).trans
        (orthogonalProjection_eq_self_iff.mpr hx)
    rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero, Submodule.coe_zero]
    exact hV.isOrtho hij.symm hx
  | h0 =>
    simp_rw [map_zero, Submodule.coe_zero, Finset.sum_const_zero]
  | hadd x y _ _ hx hy =>
    simp_rw [map_add, Submodule.coe_add, Finset.sum_add_distrib]
    exact congr_arg‚ÇÇ (¬∑ + ¬∑) hx hy",error:  invalid alternative name 'hp',"theorem OrthogonalFamily.sum_projection_of_mem_iSup [Fintype Œπ] {V : Œπ ‚Üí Submodule ùïú E}
    [‚àÄ i, CompleteSpace (V i)] (hV : OrthogonalFamily ùïú (fun i => V i) fun i => (V i).subtype‚Çó·µ¢)
    (x : E) (hx : x ‚àà iSup V) : (‚àë i, (orthogonalProjection (V i) x : E)) = x ",":= by
  induction hx using Submodule.iSup_induction' with
  | mem i x hx =>
    refine
      (Finset.sum_eq_single_of_mem i (Finset.mem_univ _) fun j _ hij => ?_).trans
        (orthogonalProjection_eq_self_iff.mpr hx)
    rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero, Submodule.coe_zero]
    exact hV.isOrtho hij.symm hx
  | zero =>
    simp_rw [map_zero, Submodule.coe_zero, Finset.sum_const_zero]
  | add x y _ _ hx hy =>
    simp_rw [map_add, Submodule.coe_add, Finset.sum_add_distrib]
    exact congr_arg‚ÇÇ (¬∑ + ¬∑) hx hy",":= by
  induction hx using Submodule.iSup_induction' with
  | hp i x hx =>
    refine (Finset.sum_eq_single_of_mem i (Finset.mem_univ _) fun j _ hij => ?_).trans
        (orthogonalProjection_eq_self_iff.mpr hx)
    rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero, Submodule.coe_zero]
    exact hV.isOrtho hij.symm hx
  | h0 =>
    simp_rw [map_zero, Submodule.coe_zero, Finset.sum_const_zero]
  | hadd x y _ _ hx hy =>
    simp_rw [map_add, Submodule.coe_add, Finset.sum_add_distrib]
    exact congr_arg‚ÇÇ (¬∑ + ¬∑) hx hy"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,63aaa8cc21050b7a5cb193c6764569918728723b,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Œµ hŒµ).mono fun y hy => _
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  unknown identifier 'IsROrC.norm_ofReal'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.81235
case f.h
Œπ : Type u_1
l : Filter Œπ
E : Type u_2
inst‚úù‚Åµ : NormedAddCommGroup E
ùïú : Type u_3
inst‚úù‚Å¥ : RCLike ùïú
inst‚úù¬≥ : NormedSpace ùïú E
G : Type u_4
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : NormedSpace ùïú G
f : Œπ ‚Üí E ‚Üí G
g : E ‚Üí G
f' : Œπ ‚Üí E ‚Üí E ‚ÜíL[ùïú] G
g' : E ‚Üí E ‚ÜíL[ùïú] G
x : E
inst‚úù : l.NeBot
hf' : TendstoUniformlyOnFilter f' g' l (ùìù x)
hf : ‚àÄ·∂† (n : Œπ √ó E) in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2
hfg : ‚àÄ·∂† (y : E) in ùìù x, Tendsto (fun n ‚Ü¶ f n y) l (ùìù (g y))
x‚úù : Œπ √ó E
| |‚Äñx‚úù.2 - x‚Äñ‚Åª¬π| * ‚Äñg x‚úù.2 - g x - (g' x) (x‚úù.2 - x)‚Äñ","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto"
Mathlib/Algebra/Lie/Weights/Basic.lean,LieModule.map_weightSpace_le,map_weightSpace_le,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [LieSubmodule.map_le_iff_le_comap]
  intro m hm
  simp only [LieSubmodule.mem_comap, mem_weightSpace]
  intro x
  have : (toEndomorphism R L M‚ÇÇ x - œá x ‚Ä¢ ‚Üë1) ‚àò‚Çó f = f ‚àò‚Çó (toEndomorphism R L M x - œá x ‚Ä¢ ‚Üë1) := by
    ext; simp
  obtain ‚ü®k, h‚ü© := (mem_weightSpace _ _ _).mp hm x
  exact ‚ü®k, by simpa [h] using LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute this k) m‚ü©","error:  unknown identifier 'toEndomorphism'
error:  unknown identifier 'toEndomorphism'
error:  failed to synthesize
  HSMul R ‚Ñï ?m.401577
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  HSMul R ‚Ñï ?m.413778
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  LinearMap.comp f
argument
  f
has type
  M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M‚ÇÇ : Type (max u_4 u_5)
but is expected to have type
  ?m.406346 ‚Üí‚Çó[?m.400461] ?m.400192 : Type (max ?u.406337 ?u.400181)","lemma map_weightSpace_le :
    (weightSpace M œá).map f ‚â§ weightSpace M‚ÇÇ œá ",":= by
  rw [LieSubmodule.map_le_iff_le_comap]
  intro m hm
  simp only [LieSubmodule.mem_comap, mem_weightSpace]
  intro x
  have : (toEnd R L M‚ÇÇ x - œá x ‚Ä¢ ‚Üë1) ‚àò‚Çó f = f ‚àò‚Çó (toEnd R L M x - œá x ‚Ä¢ ‚Üë1) := by
    ext; simp
  obtain ‚ü®k, h‚ü© := (mem_weightSpace _ _ _).mp hm x
  exact ‚ü®k, by simpa [h] using LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute this k) m‚ü©",":= by
  rw [LieSubmodule.map_le_iff_le_comap]
  intro m hm
  simp only [LieSubmodule.mem_comap, mem_weightSpace]
  intro x
  have : (toEnd R L M‚ÇÇ x - œá x ‚Ä¢ ‚Üë1) ‚àò‚Çó f = f ‚àò‚Çó (toEnd R L M x - œá x ‚Ä¢ ‚Üë1) := by
    ext; simp
  obtain ‚ü®k, h‚ü© := (mem_weightSpace _ _ _).mp hm x
  exact ‚ü®k, by simpa [h] using LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute this k) m‚ü©"
Mathlib/MeasureTheory/Group/Measure.lean,MeasureTheory.measure_univ_of_isMulLeftInvariant,measure_univ_of_isMulLeftInvariant,079113af31d690223d4821fd5f7a58291d2347e7,":= by
  obtain ‚ü®K, K1, hK, Kclosed‚ü© : ‚àÉ K ‚àà ùìù (1 : G), IsCompact K ‚àß IsClosed K :=
    exists_mem_nhds_isCompact_isClosed 1
  have K_pos : 0 < Œº K := measure_pos_of_mem_nhds Œº K1
  have A : ‚àÄ L : Set G, IsCompact L ‚Üí ‚àÉ g : G, Disjoint L (g ‚Ä¢ K) := fun L hL =>
    exists_disjoint_smul_of_isCompact hL hK
  choose! g hg using A
  set L : ‚Ñï ‚Üí Set G := fun n => (fun T => T ‚à™ g T ‚Ä¢ K)^[n] K
  have Lcompact : ‚àÄ n, IsCompact (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact hK
    ¬∑ simp_rw [L, iterate_succ']
      apply IsCompact.union IH (hK.smul (g (L n)))
  have Lclosed : ‚àÄ n, IsClosed (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [L, iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ simp only [L, one_mul, Nat.cast_one, iterate_zero, id.def, Nat.zero_eq, Nat.zero_add]
    ¬∑ calc
        Œº (L (n + 1)) = Œº (L n) + Œº (g (L n) ‚Ä¢ K) := by
          simp_rw [L, iterate_succ']
          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet
        _ = (n + 1 + 1 : ‚Ñï) * Œº K := by
          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]
  have N : Tendsto (fun n => Œº (L n)) atTop (ùìù (‚àû * Œº K)) := by
    simp_rw [M]
    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)
    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)
  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N
  apply top_le_iff.1
  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.193660 ‚Üí ?m.193660
error:  unsolved goals
case zero
ùïú : Type u_1
G : Type u_2
H : Type u_3
inst‚úù¬π‚Å∞ : MeasurableSpace G
inst‚úù‚Åπ : MeasurableSpace H
inst‚úù‚Å∏ : TopologicalSpace G
inst‚úù‚Å∑ : BorelSpace G
Œº‚úù : Measure G
inst‚úù‚Å∂ : Group G
inst‚úù‚Åµ : TopologicalGroup G
inst‚úù‚Å¥ : Œº‚úù.IsMulLeftInvariant
inst‚úù¬≥ : WeaklyLocallyCompactSpace G
inst‚úù¬≤ : NoncompactSpace G
Œº : Measure G
inst‚úù¬π : Œº.IsOpenPosMeasure
inst‚úù : Œº.IsMulLeftInvariant
K : Set G
K1 : K ‚àà ùìù 1
hK : IsCompact K
Kclosed : IsClosed K
K_pos : 0 < Œº K
g : Set G ‚Üí G
hg : ‚àÄ (L : Set G), IsCompact L ‚Üí Disjoint L (g L ‚Ä¢ K)
L : ‚Ñï ‚Üí Set G := fun n ‚Ü¶ (fun T ‚Ü¶ T ‚à™ g T ‚Ä¢ K)^[n] K
Lcompact : ‚àÄ (n : ‚Ñï), IsCompact (L n)
Lclosed : ‚àÄ (n : ‚Ñï), IsClosed (L n)
‚ä¢ Œº (id K) = Œº K","theorem measure_univ_of_isMulLeftInvariant [WeaklyLocallyCompactSpace G] [NoncompactSpace G]
    (Œº : Measure G) [IsOpenPosMeasure Œº] [Œº.IsMulLeftInvariant] : Œº univ = ‚àû ",":= by
  obtain ‚ü®K, K1, hK, Kclosed‚ü© : ‚àÉ K ‚àà ùìù (1 : G), IsCompact K ‚àß IsClosed K :=
    exists_mem_nhds_isCompact_isClosed 1
  have K_pos : 0 < Œº K := measure_pos_of_mem_nhds Œº K1
  have A : ‚àÄ L : Set G, IsCompact L ‚Üí ‚àÉ g : G, Disjoint L (g ‚Ä¢ K) := fun L hL =>
    exists_disjoint_smul_of_isCompact hL hK
  choose! g hg using A
  set L : ‚Ñï ‚Üí Set G := fun n => (fun T => T ‚à™ g T ‚Ä¢ K)^[n] K
  have Lcompact : ‚àÄ n, IsCompact (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact hK
    ¬∑ simp_rw [L, iterate_succ']
      apply IsCompact.union IH (hK.smul (g (L n)))
  have Lclosed : ‚àÄ n, IsClosed (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [L, iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ simp only [L, one_mul, Nat.cast_one, iterate_zero, id, Nat.zero_eq, Nat.zero_add]
    ¬∑ calc
        Œº (L (n + 1)) = Œº (L n) + Œº (g (L n) ‚Ä¢ K) := by
          simp_rw [L, iterate_succ']
          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet
        _ = (n + 1 + 1 : ‚Ñï) * Œº K := by
          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]
  have N : Tendsto (fun n => Œº (L n)) atTop (ùìù (‚àû * Œº K)) := by
    simp_rw [M]
    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)
    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)
  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N
  apply top_le_iff.1
  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)",":= by
  obtain ‚ü®K, K1, hK, Kclosed‚ü© : ‚àÉ K ‚àà ùìù (1 : G), IsCompact K ‚àß IsClosed K :=
    exists_mem_nhds_isCompact_isClosed 1
  have K_pos : 0 < Œº K := measure_pos_of_mem_nhds Œº K1
  have A : ‚àÄ L : Set G, IsCompact L ‚Üí ‚àÉ g : G, Disjoint L (g ‚Ä¢ K) := fun L hL =>
    exists_disjoint_smul_of_isCompact hL hK
  choose! g hg using A
  set L : ‚Ñï ‚Üí Set G := fun n => (fun T => T ‚à™ g T ‚Ä¢ K)^[n] K
  have Lcompact : ‚àÄ n, IsCompact (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact hK
    ¬∑ simp_rw [L, iterate_succ']
      apply IsCompact.union IH (hK.smul (g (L n)))
  have Lclosed : ‚àÄ n, IsClosed (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [L, iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [L, iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [L, iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [L, iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ simp only [L, one_mul, Nat.cast_one, iterate_zero, id, Nat.zero_eq, Nat.zero_add]
    ¬∑ calc
        Œº (L (n + 1)) = Œº (L n) + Œº (g (L n) ‚Ä¢ K) := by
          simp_rw [L, iterate_succ']
          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet
        _ = (n + 1 + 1 : ‚Ñï) * Œº K := by
          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]
  have N : Tendsto (fun n => Œº (L n)) atTop (ùìù (‚àû * Œº K)) := by
    simp_rw [M]
    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)
    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)
  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N
  apply top_le_iff.1
  exact le_of_tendsto' N fun n => measure_mono subset_univ _"
Mathlib/Combinatorics/SetFamily/Shadow.lean,Finset.mem_shadow_iterate_iff_exists_sdiff,mem_shadow_iterate_iff_exists_sdiff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [mem_shadow_iterate_iff_exists_card]
  constructor
  ¬∑ rintro ‚ü®u, rfl, htu, hsuA‚ü©
    exact ‚ü®_, hsuA, subset_union_left _ _, by rw [union_sdiff_cancel_left htu]‚ü©
  ¬∑ rintro ‚ü®s, hs, hts, rfl‚ü©
    refine ‚ü®s \ t, rfl, disjoint_sdiff, ?_‚ü©
    rwa [union_sdiff_self_eq_union, union_eq_right.2 hts]","warning:  @shadow does not have a doc string
error:  function expected at
  subset_union_left ?m.166763
term has type
  ?m.166762 ‚àà ?m.166760 ‚à™ ?m.166761
warning:  @upShadow does not have a doc string","lemma mem_shadow_iterate_iff_exists_sdiff : t ‚àà ‚àÇ^[k] ùíú ‚Üî ‚àÉ s ‚àà ùíú, t ‚äÜ s ‚àß (s \ t).card = k ",":= by
  rw [mem_shadow_iterate_iff_exists_card]
  constructor
  ¬∑ rintro ‚ü®u, rfl, htu, hsuA‚ü©
    exact ‚ü®_, hsuA, subset_union_left, by rw [union_sdiff_cancel_left htu]‚ü©
  ¬∑ rintro ‚ü®s, hs, hts, rfl‚ü©
    refine ‚ü®s \ t, rfl, disjoint_sdiff, ?_‚ü©
    rwa [union_sdiff_self_eq_union, union_eq_right.2 hts]",":= by
  rw [mem_shadow_iterate_iff_exists_card]
  constructor
  ¬∑ rintro ‚ü®u, rfl, htu, hsuA‚ü©
    exact ‚ü®_, hsuA, subset_union_left, by rw [union_sdiff_cancel_left htu]‚ü©
  ¬∑ rintro ‚ü®s, hs, hts, rfl‚ü©
    refine ‚ü®s \ t, rfl, disjoint_sdiff, ?_‚ü©
    rwa [union_sdiff_self_eq_union, union_eq_right.2 hts]"
Mathlib/Topology/Category/Profinite/Nobeling.lean,Profinite.NobelingProof.GoodProducts.span_iff_products,GoodProducts.span_iff_products,a716898404cb865abf963d7081ebe54c3af39a18,":= by
  refine ‚ü®fun h ‚Ü¶ le_trans h (span_mono (fun a ‚ü®b, hb‚ü© ‚Ü¶ ‚ü®b.val, hb‚ü©)), fun h ‚Ü¶ le_trans h ?_‚ü©
  rw [span_le]
  rintro f ‚ü®l, rfl‚ü©
  let L : Products I ‚Üí Prop := fun m ‚Ü¶ m.eval C ‚àà span ‚Ñ§ (Set.range (GoodProducts.eval C))
  suffices L l by assumption
  apply IsWellFounded.induction (¬∑<¬∑ : Products I ‚Üí Products I ‚Üí Prop)
  intro l h
  dsimp
  by_cases hl : l.isGood C
  ¬∑ apply subset_span
    exact ‚ü®‚ü®l, hl‚ü©, rfl‚ü©
  ¬∑ simp only [Products.isGood, not_not] at hl
    suffices : Products.eval C '' {m | m < l} ‚äÜ span ‚Ñ§ (Set.range (GoodProducts.eval C))
    ¬∑ rw [‚Üê span_le] at this
      exact this hl
    rintro a ‚ü®m, hm, rfl‚ü©
    exact h m hm",error:  unexpected token ':'; expected term,"theorem GoodProducts.span_iff_products : ‚ä§ ‚â§ span ‚Ñ§ (Set.range (eval C)) ‚Üî
    ‚ä§ ‚â§ span ‚Ñ§ (Set.range (Products.eval C)) ",":= by
  refine ‚ü®fun h ‚Ü¶ le_trans h (span_mono (fun a ‚ü®b, hb‚ü© ‚Ü¶ ‚ü®b.val, hb‚ü©)), fun h ‚Ü¶ le_trans h ?_‚ü©
  rw [span_le]
  rintro f ‚ü®l, rfl‚ü©
  let L : Products I ‚Üí Prop := fun m ‚Ü¶ m.eval C ‚àà span ‚Ñ§ (Set.range (GoodProducts.eval C))
  suffices L l by assumption
  apply IsWellFounded.induction (¬∑<¬∑ : Products I ‚Üí Products I ‚Üí Prop)
  intro l h
  dsimp
  by_cases hl : l.isGood C
  ¬∑ apply subset_span
    exact ‚ü®‚ü®l, hl‚ü©, rfl‚ü©
  ¬∑ simp only [Products.isGood, not_not] at hl
    suffices Products.eval C '' {m | m < l} ‚äÜ span ‚Ñ§ (Set.range (GoodProducts.eval C)) by
      rw [‚Üê span_le] at this
      exact this hl
    rintro a ‚ü®m, hm, rfl‚ü©
    exact h m hm",":= by
  refine ‚ü®fun h ‚Ü¶ le_trans h (span_mono (fun a ‚ü®b, hb‚ü© ‚Ü¶ ‚ü®b.val, hb‚ü©)), fun h ‚Ü¶ le_trans h ?_‚ü©
  rw [span_le]
  rintro f ‚ü®l, rfl‚ü©
  let L : Products I ‚Üí Prop := fun m ‚Ü¶ m.eval C ‚àà span ‚Ñ§ (Set.range (GoodProducts.eval C))
  suffices L l by assumption
  apply IsWellFounded.induction (¬∑<¬∑ : Products I ‚Üí Products I ‚Üí Prop)
  intro l h
  dsimp
  by_cases hl : l.isGood C
  ¬∑ apply subset_span
    exact ‚ü®‚ü®l, hl‚ü©, rfl‚ü©
  ¬∑ simp only [Products.isGood, not_not] at hl
    suffices Products.eval C '' {m | m < l} ‚äÜ span ‚Ñ§ (Set.range (GoodProducts.eval C))
    ¬∑ rw [‚Üê span_le] at this
      exact this hl
    rintro a ‚ü®m, hm, rfl‚ü©
    exact h m hm"
Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean,TopCat.range_pullback_map,range_pullback_map,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range, ‚Üê comp_apply, limit.lift_œÄ,
      PullbackCone.mk_pt, PullbackCone.mk_œÄ_app]
    simp only [comp_apply, exists_apply_eq_apply, and_self]
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    simp only [‚Üê comp_apply, eq‚ÇÅ, eq‚ÇÇ]
    simp only [comp_apply, hx‚ÇÅ, hx‚ÇÇ]
    simp only [‚Üê comp_apply, pullback.condition]
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  apply Concrete.limit_ext
  rintro (_ | _ | _) <;>
  simp only [‚Üê comp_apply, Category.assoc, limit.lift_œÄ, PullbackCone.mk_œÄ_app_one]
  ¬∑ simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, comp_apply,
      pullbackFst_apply, hx‚ÇÅ]
    rw [‚Üê limit.w _ WalkingCospan.Hom.inl, cospan_map_inl, comp_apply (g := g‚ÇÅ)]
  ¬∑ simp [hx‚ÇÅ]
  ¬∑ simp [hx‚ÇÇ]","error:  simp made no progress
error:  simp made no progress
error:  tactic 'apply' failed, failed to unify
  ?x = ?y
with
  (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) ((pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®(x‚ÇÅ, x‚ÇÇ), this‚ü©) = x‚úù
case h
J : Type v
inst‚úù : SmallCategory J
X‚úù Y‚úù Z‚úù : TopCat
W X Y Z S T : TopCat
f‚ÇÅ : W ‚ü∂ S
f‚ÇÇ : X ‚ü∂ S
g‚ÇÅ : Y ‚ü∂ T
g‚ÇÇ : Z ‚ü∂ T
i‚ÇÅ : W ‚ü∂ Y
i‚ÇÇ : X ‚ü∂ Z
i‚ÇÉ : S ‚ü∂ T
H‚ÇÉ : Mono i‚ÇÉ
eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ
eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ
x‚úù : ‚Üë(pullback g‚ÇÅ g‚ÇÇ)
x‚ÇÅ : ‚ÜëW
hx‚ÇÅ : i‚ÇÅ x‚ÇÅ = pullback.fst x‚úù
x‚ÇÇ : ‚ÜëX
hx‚ÇÇ : i‚ÇÇ x‚ÇÇ = pullback.snd x‚úù
this : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ
‚ä¢ (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) ((pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®(x‚ÇÅ, x‚ÇÇ), this‚ü©) = x‚úù","theorem range_pullback_map {W X Y Z S T : TopCat} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) (g‚ÇÅ : Y ‚ü∂ T)
    (g‚ÇÇ : Z ‚ü∂ T) (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T) [H‚ÇÉ : Mono i‚ÇÉ] (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ)
    (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) :
    Set.range (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) =
      (pullback.fst : pullback g‚ÇÅ g‚ÇÇ ‚ü∂ _) ‚Åª¬π' Set.range i‚ÇÅ ‚à©
        (pullback.snd : pullback g‚ÇÅ g‚ÇÇ ‚ü∂ _) ‚Åª¬π' Set.range i‚ÇÇ ",":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range]
    erw [‚Üê comp_apply, ‚Üê comp_apply] 
    simp only [limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app, comp_apply]
    exact ‚ü®exists_apply_eq_apply _ _, exists_apply_eq_apply _ _‚ü©
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    erw [‚Üê comp_apply, eq‚ÇÅ, ‚Üê comp_apply, eq‚ÇÇ, 
      comp_apply, comp_apply, hx‚ÇÅ, hx‚ÇÇ, ‚Üê comp_apply, pullback.condition]
    rfl 
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  change (forget TopCat).map _ _ = _
  apply Concrete.limit_ext
  rintro (_ | _ | _) <;>
  erw [‚Üê comp_apply, ‚Üê comp_apply] 
  simp only [Category.assoc, limit.lift_œÄ, PullbackCone.mk_œÄ_app_one]
  ¬∑ simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [pullbackFst_apply, hx‚ÇÅ]
    rw [‚Üê limit.w _ WalkingCospan.Hom.inl, cospan_map_inl, comp_apply (g := g‚ÇÅ)]
    rfl 
  ¬∑ simp only [cospan_left, limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,
      pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [hx‚ÇÅ] 
    rfl 
  ¬∑ simp only [cospan_right, limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,
      pullbackIsoProdSubtype_inv_snd_assoc, comp_apply]
    erw [hx‚ÇÇ] 
    rfl ",":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range, ‚Üê comp_apply, limit.lift_œÄ,
      PullbackCone.mk_pt, PullbackCone.mk_œÄ_app]
    simp only [comp_apply, exists_apply_eq_apply, and_self]
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    simp only [‚Üê comp_apply, eq‚ÇÅ, eq‚ÇÇ]
    simp only [comp_apply, pullback.condition]
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  apply Concrete.limit_ext
  rintro (_ | _ | _) <;>
  simp only [‚Üê comp_apply, Category.assoc, limit.lift_œÄ, PullbackCone.mk_œÄ_app_one]
  ¬∑ simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, comp_apply,
      pullbackFst_apply, hx‚ÇÅ]
    rw [‚Üê limit.w _ WalkingCospan.Hom.inl, cospan_map_inl, comp_apply (g := g‚ÇÅ)]
  ¬∑ simp [hx‚ÇÅ]
  ¬∑ simp [hx‚ÇÇ]"
Mathlib/Analysis/Complex/CauchyIntegral.lean,Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,7fa0a827960832ef960210f51c78c246882fbb79,":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r := ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R := ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine' fun z hz => (hd (g z) ‚ü®_, hz.2‚ü©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  application type mismatch
  mul_div_cancel_left ?m.98568 (circleMap_ne_center (LT.lt.ne' (Real.exp_pos ?m.98571)))
argument
  circleMap_ne_center (LT.lt.ne' (Real.exp_pos ?m.98571))
has type
  circleMap ?m.98569 (rexp ?m.98571) ?m.98601 ‚â† ?m.98569 : Prop
but is expected to have type
  ?m.98566 : Type ?u.98565
error:  tactic 'assumption' failed
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚ÑÇ E
inst‚úù : CompleteSpace E
c : ‚ÑÇ
f : ‚ÑÇ ‚Üí E
s : Set ‚ÑÇ
hs : s.Countable
a : ‚Ñù
h0 : 0 < rexp a
b : ‚Ñù
hle : a ‚â§ b
hd : ‚àÄ z ‚àà (ball c (rexp b) \ closedBall c (rexp a)) \ s, DifferentiableAt ‚ÑÇ f z
A : Set ‚ÑÇ := closedBall c (rexp b) \ ball c (rexp a)
hc : ContinuousOn f A
this : ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, I ‚Ä¢ f (circleMap c (rexp b) Œ∏) = ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, I ‚Ä¢ f (circleMap c (rexp a) Œ∏)
‚ä¢ ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, (circleMap 0 (rexp b) Œ∏ * I / circleMap 0 (rexp b) Œ∏) ‚Ä¢ f (circleMap c (rexp b) Œ∏) =
    ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, (circleMap 0 (rexp a) Œ∏ * I / circleMap 0 (rexp a) Œ∏) ‚Ä¢ f (circleMap c (rexp a) Œ∏)","theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ‚ÑÇ}
    {r R : ‚Ñù} (h0 : 0 < r) (hle : r ‚â§ R) {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ‚àÄ z ‚àà (ball c R \ closedBall c r) \ s, DifferentiableAt ‚ÑÇ f z) :
    (‚àÆ z in C(c, R), (z - c)‚Åª¬π ‚Ä¢ f z) = ‚àÆ z in C(c, r), (z - c)‚Åª¬π ‚Ä¢ f z ",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r := ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R := ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left‚ÇÄ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine fun z hz => (hd (g z) ‚ü®?_, hz.2‚ü©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r := ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R := ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine fun z hz => (hd (g z) ‚ü®?_, hz.2‚ü©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd"
Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean,gramSchmidt_orthogonal,gramSchmidt_orthogonal,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ ha
    ¬∑ rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply wellFounded_lt.induction b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    ¬∑ rw [IsROrC.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel‚ÇÄ, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ","error:  unknown identifier 'IsROrC.ofReal_pow'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.51260
case neg
ùïú : Type u_1
E : Type u_2
inst‚úù‚Åµ : RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : InnerProductSpace ùïú E
Œπ : Type u_3
inst‚úù¬≤ : LinearOrder Œπ
inst‚úù¬π : LocallyFiniteOrderBot Œπ
inst‚úù : IsWellOrder Œπ fun x x_1 ‚Ü¶ x < x_1
f : Œπ ‚Üí E
b‚úù b : Œπ
ih : ‚àÄ y < b, ‚àÄ a < y, ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f y‚ü´_ùïú = 0
a : Œπ
h‚ÇÄ : a < b
h : ¬¨gramSchmidt ùïú f a = 0
‚ä¢ ‚ü™gramSchmidt ùïú f a, f b‚ü´_ùïú -
      ‚ü™gramSchmidt ùïú f a, f b‚ü´_ùïú / ‚Üë(‚ÄñgramSchmidt ùïú f a‚Äñ ^ 2) * ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f a‚ü´_ùïú =
    0","theorem gramSchmidt_orthogonal (f : Œπ ‚Üí E) {a b : Œπ} (h‚ÇÄ : a ‚â† b) :
    ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 ",":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ ha
    ¬∑ rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply wellFounded_lt.induction b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    ¬∑ rw [RCLike.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel‚ÇÄ, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ",":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply wellFounded_lt.induction b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    ¬∑ rw [IsROrC.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel‚ÇÄ, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ"
Mathlib/CategoryTheory/Comma/Presheaf.lean,CategoryTheory.OverPresheafAux.counitForward_naturality‚ÇÇ,counitForward_naturality‚ÇÇ,1b85c004a4cf7c486b555f38bbdce2444377a64b,":= by
  refine OverArrows.ext <| YonedaCollection.ext (by simp) ?_
  have : (CostructuredArrow.homMk'' t.unop.hom f.unop.left).op =
      f ‚â´ eqToHom (by simp [‚Üê CostructuredArrow.eq_mk]) := by
    apply Quiver.Hom.unop_inj
    aesop_cat
  aesop_cat","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  CostructuredArrow
has type
  ?m.166093 ‚•§ ?m.166199 ‚Üí ?m.166199 ‚Üí Type (max ?u.166090 ?u.166091)
error:  simp made no progress
error:  unsolved goals
C : Type u
inst‚úù : Category.{v, u} C
A : C·µí·µñ ‚•§ Type v
F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v
X : C
s t : (CostructuredArrow yoneda A)·µí·µñ
f : t ‚ü∂ s
x : F.obj t
‚ä¢ F.map (eqToHom ‚ãØ) (YonedaCollection.snd ((counitForward F t.unop x).map‚ÇÇ f.unop.left ‚ãØ).val) =
    YonedaCollection.snd (counitForward F s.unop (F.map f x)).val","lemma counitForward_naturality‚ÇÇ (s t : (CostructuredArrow yoneda A)·µí·µñ) (f : t ‚ü∂ s) (x : F.obj t) :
    counitForward F s.unop (F.map f x) =
      OverArrows.map‚ÇÇ (counitForward F t.unop x) f.unop.left (by simp) ",":= by
  refine OverArrows.ext <| YonedaCollection.ext (by simp) ?_
  have : (CostructuredArrow.mkPrecomp t.unop.hom f.unop.left).op =
      f ‚â´ eqToHom (by simp [‚Üê CostructuredArrow.eq_mk]) := by
    apply Quiver.Hom.unop_inj
    aesop_cat
  aesop_cat",":= by
  refine OverArrows.ext <| YonedaCollection.ext (by simp) ?_
  have : (CostructuredArrow.homMk'' t.unop.hom f.unop.left).op =
      f ‚â´ eqToHom (by simp [‚Üê CostructuredArrow.eq_mk]) := by
    apply Quiver.Hom.unop_inj
    aesop_cat
  aesop_cat"
Mathlib/Analysis/Complex/CauchyIntegral.lean,Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,50dac17e96f8a0ddcbd8740f9929f7cf0a85740d,":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r; exact ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R; exact ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R; exact hc.comp hdg.continuous.continuousOn h_maps
  replace hd :
    ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z
  ¬∑ refine' fun z hz => (hd (g z) ‚ü®_, hz.2‚ü©).comp z (hdg _)
    simpa [dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd","error:  unexpected token ';'; expected '|'
error:  unsolved goals
case intro.intro
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚ÑÇ E
inst‚úù : CompleteSpace E
c : ‚ÑÇ
f : ‚ÑÇ ‚Üí E
s : Set ‚ÑÇ
a : ‚Ñù
h0 : 0 < rexp a
b : ‚Ñù
hle : a ‚â§ b
hd : ‚àÄ z ‚àà (ball c (rexp b) \ closedBall c (rexp a)) \ s, DifferentiableAt ‚ÑÇ f z
A : Set ‚ÑÇ := closedBall c (rexp b) \ ball c (rexp a)
R : Set ‚ÑÇ := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
g : ‚ÑÇ ‚Üí ‚ÑÇ := fun x ‚Ü¶ c + cexp x
hdg : Differentiable ‚ÑÇ g
hs : (g ‚Åª¬π' s).Countable
h_maps : MapsTo g R A
hc : ContinuousOn (f ‚àò g) R
‚ä¢ ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, I ‚Ä¢ f (circleMap c (rexp b) Œ∏) = ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, I ‚Ä¢ f (circleMap c (rexp a) Œ∏)","theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ‚ÑÇ}
    {r R : ‚Ñù} (h0 : 0 < r) (hle : r ‚â§ R) {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ‚àÄ z ‚àà (ball c R \ closedBall c r) \ s, DifferentiableAt ‚ÑÇ f z) :
    (‚àÆ z in C(c, R), (z - c)‚Åª¬π ‚Ä¢ f z) = ‚àÆ z in C(c, r), (z - c)‚Åª¬π ‚Ä¢ f z ",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r := ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R := ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left‚ÇÄ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine fun z hz => (hd (g z) ‚ü®?_, hz.2‚ü©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r; exact ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R; exact ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R; exact hc.comp hdg.continuous.continuousOn h_maps
  replace hd :
    ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z
  ¬∑ refine fun z hz => (hd (g z) ‚ü®_, hz.2‚ü©).comp z (hdg _)
    simpa [dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_ortho"
Mathlib/Analysis/NormedSpace/QuaternionExponential.lean,Quaternion.hasSum_expSeries_of_imaginary,hasSum_expSeries_of_imaginary,51d59c1b99e04eb6fe597dd39de4e4fcfa8512d2,":= by
  replace hc := hasSum_coe.mpr hc
  replace hs := (hs.div_const ‚Äñq‚Äñ).smul_const q
  obtain rfl | hq0 := eq_or_ne q 0
  ¬∑ simp_rw [expSeries_apply_zero, norm_zero, div_zero, zero_smul, add_zero]
    simp_rw [norm_zero] at hc
    convert hc using 1
    ext (_ | n) : 1
    ¬∑ rw [pow_zero, Nat.zero_eq, mul_zero, pow_zero, Nat.factorial_zero, Nat.cast_one,
        div_one, one_mul, Pi.single_eq_same, coe_one]
    ¬∑ rw [zero_pow (mul_pos two_pos (Nat.succ_pos _)), mul_zero, zero_div,
        Pi.single_eq_of_ne n.succ_ne_zero, coe_zero]
  simp_rw [expSeries_apply_eq]
  have hq2 : q ^ 2 = -normSq q := sq_eq_neg_normSq.mpr hq
  have hqn := norm_ne_zero_iff.mpr hq0
  refine' HasSum.even_add_odd _ _
  ¬∑ convert hc using 1
    ext n : 1
    letI k : ‚Ñù := ‚Üë(2 * n)!
    calc
      k‚Åª¬π ‚Ä¢ q ^ (2 * n) = k‚Åª¬π ‚Ä¢ (-normSq q) ^ n := by rw [pow_mul, hq2]; norm_cast
      _ = k‚Åª¬π ‚Ä¢ ‚Üë((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n)) := ?_
      _ = ‚Üë((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n) / k) := ?_
    ¬∑ congr 1
      rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq]
      push_cast
      rfl
    ¬∑ rw [‚Üê coe_mul_eq_smul, div_eq_mul_inv]
      norm_cast
      ring_nf
  ¬∑ convert hs using 1
    ext n : 1
    let k : ‚Ñù := ‚Üë(2 * n + 1)!
    calc
      k‚Åª¬π ‚Ä¢ q ^ (2 * n + 1) = k‚Åª¬π ‚Ä¢ ((-normSq q) ^ n * q) := by
        rw [pow_succ', pow_mul, hq2]
        norm_cast
      _ = k‚Åª¬π ‚Ä¢ ((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n)) ‚Ä¢ q := ?_
      _ = ((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n + 1) / k / ‚Äñq‚Äñ) ‚Ä¢ q := ?_
    ¬∑ congr 1
      rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq, ‚Üê coe_mul_eq_smul]
    ¬∑ rw [smul_smul]
      congr 1
      simp_rw [pow_succ', mul_div_assoc, div_div_cancel_left' hqn]
      ring","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case h.e'_5.h.zero
c s : ‚Ñù
hq : re 0 = 0
hs : HasSum (fun z ‚Ü¶ ((-1) ^ z * ‚Äñ0‚Äñ ^ (2 * z + 1) / ‚Üë(2 * z + 1)! / ‚Äñ0‚Äñ) ‚Ä¢ 0) ((s / ‚Äñ0‚Äñ) ‚Ä¢ 0)
hc : HasSum (fun a ‚Ü¶ ‚Üë((-1) ^ a * 0 ^ (2 * a) / ‚Üë(2 * a)!)) ‚Üëc
‚ä¢ Pi.single 0 1 0 = ‚Üë(1 * 0 ^ (2 * 0) / ‚Üë(2 * 0)!)
error:  application type mismatch
  zero_pow (mul_pos ?m.39247 (Nat.succ_pos ?m.39364))
argument
  mul_pos ?m.39247 (Nat.succ_pos ?m.39364)
has type
  0 < ?m.36565 * ?m.39364.succ : Prop
but is expected to have type
  ?m.36562 ‚â† 0 : Prop
error:  no goals to be solved
error:  unsolved goals
q : ‚Ñç
hq : q.re = 0
c s : ‚Ñù
hc : HasSum (fun a ‚Ü¶ ‚Üë((-1) ^ a * ‚Äñq‚Äñ ^ (2 * a) / ‚Üë(2 * a)!)) ‚Üëc
hs : HasSum (fun z ‚Ü¶ ((-1) ^ z * ‚Äñq‚Äñ ^ (2 * z + 1) / ‚Üë(2 * z + 1)! / ‚Äñq‚Äñ) ‚Ä¢ q) ((s / ‚Äñq‚Äñ) ‚Ä¢ q)
hq0 : q ‚â† 0
hq2 : q ^ 2 = -‚Üë(normSq q)
hqn : ‚Äñq‚Äñ ‚â† 0
n : ‚Ñï
k : ‚Ñù := ‚Üë(2 * n + 1)!
‚ä¢ k‚Åª¬π ‚Ä¢ (q * ‚Üë((-normSq q) ^ n)) = k‚Åª¬π ‚Ä¢ (‚Üë((-normSq q) ^ n) * q)
error:  unsolved goals
case h.e'_5.h.calc_1.e_a
q : ‚Ñç
hq : q.re = 0
c s : ‚Ñù
hc : HasSum (fun a ‚Ü¶ ‚Üë((-1) ^ a * ‚Äñq‚Äñ ^ (2 * a) / ‚Üë(2 * a)!)) ‚Üëc
hs : HasSum (fun z ‚Ü¶ ((-1) ^ z * ‚Äñq‚Äñ ^ (2 * z + 1) / ‚Üë(2 * z + 1)! / ‚Äñq‚Äñ) ‚Ä¢ q) ((s / ‚Äñq‚Äñ) ‚Ä¢ q)
hq0 : q ‚â† 0
hq2 : q ^ 2 = -‚Üë(normSq q)
hqn : ‚Äñq‚Äñ ‚â† 0
n : ‚Ñï
k : ‚Ñù := ‚Üë(2 * n + 1)!
‚ä¢ (-1) ^ n * ‚Üë(‚Äñq‚Äñ * ‚Äñq‚Äñ) ^ n * q = ‚Üë((-1) ^ n * (‚Äñq‚Äñ * ‚Äñq‚Äñ) ^ n) * q
error:  simp made no progress","theorem hasSum_expSeries_of_imaginary {q : Quaternion ‚Ñù} (hq : q.re = 0) {c s : ‚Ñù}
    (hc : HasSum (fun n => (-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n) / (2 * n)!) c)
    (hs : HasSum (fun n => (-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n + 1) / (2 * n + 1)!) s) :
    HasSum (fun n => expSeries ‚Ñù (Quaternion ‚Ñù) n fun _ => q) (‚Üëc + (s / ‚Äñq‚Äñ) ‚Ä¢ q) ",":= by
  replace hc := hasSum_coe.mpr hc
  replace hs := (hs.div_const ‚Äñq‚Äñ).smul_const q
  refine HasSum.even_add_odd ?_ ?_
  ¬∑ convert hc using 1
    ext n : 1
    rw [expSeries_even_of_imaginary hq]
  ¬∑ convert hs using 1
    ext n : 1
    rw [expSeries_odd_of_imaginary hq]",":= by
  replace hc := hasSum_coe.mpr hc
  replace hs := (hs.div_const ‚Äñq‚Äñ).smul_const q
  obtain rfl | hq0 := eq_or_ne q 0
  ¬∑ simp_rw [expSeries_apply_zero, norm_zero, div_zero, zero_smul, add_zero]
    simp_rw [norm_zero] at hc
    convert hc using 1
    ext (_ | n) : 1
    ¬∑ rw [pow_zero, Nat.zero_eq, mul_zero, pow_zero, Nat.factorial_zero, Nat.cast_one,
        div_one, one_mul, Pi.single_eq_same, coe_one]
    ¬∑ rw [zero_pow (mul_pos two_pos (Nat.succ_pos _)), mul_zero, zero_div,
        Pi.single_eq_of_ne n.succ_ne_zero, coe_zero]
  simp_rw [expSeries_apply_eq]
  have hq2 : q ^ 2 = -normSq q := sq_eq_neg_normSq.mpr hq
  have hqn := norm_ne_zero_iff.mpr hq0
  refine HasSum.even_add_odd ?_ ?_
  ¬∑ convert hc using 1
    ext n : 1
    letI k : ‚Ñù := ‚Üë(2 * n)!
    calc
      k‚Åª¬π ‚Ä¢ q ^ (2 * n) = k‚Åª¬π ‚Ä¢ (-normSq q) ^ n := by rw [pow_mul, hq2]; norm_cast
      _ = k‚Åª¬π ‚Ä¢ ‚Üë((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n) / k) := ?_
    ¬∑ congr 1
      rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq, ‚Üê coe_mul_eq_smul]
    ¬∑ rw [smul_smul]
      congr 1
      simp_rw [pow_succ', mul_div_assoc, div_div_cancel_left' hqn]
      ring"
Mathlib/Algebra/GroupWithZero/Basic.lean,pow_eq_zero,pow_eq_zero,7b8bf07cc2a20c8dc82ce0858b4824f036e4a88b,"  | _, _, Nat.le.refl, ha => ha
  | _, _, Nat.le.step hmn, ha => by rw [pow_succ, pow_eq_zero_of_le hmn ha, mul_zero]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * 0
Œ± : Type u_1
M‚ÇÄ : Type u_2
G‚ÇÄ : Type u_3
M‚ÇÄ' : Type u_4
G‚ÇÄ' : Type u_5
F : Type u_6
F' : Type u_7
inst‚úù : MonoidWithZero M‚ÇÄ
a : M‚ÇÄ
m n n‚úù m‚úù : ‚Ñï
hmn : n‚úù.le m‚úù
ha : a ^ n‚úù = 0
‚ä¢ 0 * a = 0","lemma pow_eq_zero_of_le : ‚àÄ {m n} (hmn : m ‚â§ n) (ha : a ^ m = 0), a ^ n = 0
","  | _, _, Nat.le.refl, ha => ha
  | _, _, Nat.le.step hmn, ha => by rw [pow_succ, pow_eq_zero_of_le hmn ha, zero_mul]",":= | _, _, Nat.le.refl, ha => ha
  | _, _, Nat.le.step hmn, ha => by rw [pow_succ, pow_eq_zero_of_le hmn ha, mul_zero]"
Mathlib/LinearAlgebra/FiniteDimensional.lean,FiniteDimensional.of_fintype_basis,of_fintype_basis,44d0abee8c9db1dbf8d88d89f61bae7c34234d96,":= by
  cases nonempty_fintype Œπ
  exact ‚ü®‚ü®Finset.univ.image h, by
    convert h.span_eq
    simp‚ü©‚ü©","error:  failed to synthesize
  DecidableEq V
use `set_option diagnostics true` to get diagnostic information
error:  simp made no progress",theorem of_fintype_basis {Œπ : Type w} [Finite Œπ] (h : Basis Œπ K V) : FiniteDimensional K V ,":=
  Module.Finite.of_basis h",":= by
  cases nonempty_fintype Œπ
  exact ‚ü®‚ü®Finset.univ.image h, by
    convert h.span_eq
    simp"
Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean,FiniteField.isSquare_odd_prime_iff,FiniteField.isSquare_odd_prime_iff,8e31b5ac6bed8ba535a30f3442252684d2f151c1,":= by
  classical
  by_cases hFp : ringChar F = p
  ¬∑ rw [show (p : F) = 0 by rw [‚Üê hFp]; exact ringChar.Nat.cast_ringChar]
    simp only [isSquare_zero, Ne.def, true_iff_iff, map_mul]
    obtain ‚ü®n, _, hc‚ü© := FiniteField.card F (ringChar F)
    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm
    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]
    simp only [zero_pow n.pos, mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]
  ¬∑ rw [‚Üê Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),
      quadraticChar_odd_prime hF hp]
    exact hFp","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.37884 ‚Üí ?m.37884 ‚Üí Prop
error:  cannot select argument","theorem FiniteField.isSquare_odd_prime_iff (hF : ringChar F ‚â† 2) {p : ‚Ñï} [Fact p.Prime]
    (hp : p ‚â† 2) :
    IsSquare (p : F) ‚Üî quadraticChar (ZMod p) (œá‚ÇÑ (Fintype.card F) * Fintype.card F) ‚â† -1 ",":= by
  classical
  by_cases hFp : ringChar F = p
  ¬∑ rw [show (p : F) = 0 by rw [‚Üê hFp]; exact ringChar.Nat.cast_ringChar]
    simp only [isSquare_zero, Ne, true_iff_iff, map_mul]
    obtain ‚ü®n, _, hc‚ü© := FiniteField.card F (ringChar F)
    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm
    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]
    simp only [zero_pow n.ne_zero, mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]
  ¬∑ rw [‚Üê Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),
      quadraticChar_odd_prime hF hp]
    exact hFp",":= by
  classical
  by_cases hFp : ringChar F = p
  ¬∑ rw [show (p : F) = 0 by rw [‚Üê hFp]; exact ringChar.Nat.cast_ringChar]
    simp only [isSquare_zero, Ne, true_iff_iff, map_mul]
    obtain ‚ü®n, _, hc‚ü© := FiniteField.card F (ringChar F)
    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm
    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]
    simp only [zero_pow n.pos, mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]
  ¬∑ rw [‚Üê Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),
      quadraticChar_odd_prime hF hp]
    exact hFp"
Mathlib/Data/Sigma/Basic.lean,Sigma.exists',exists',366aa49a421213f1ab22157d84299da19895f452,:=,error:  unexpected token 'lemma'; expected term,"lemma exists' {p : ‚àÄ a, Œ≤ a ‚Üí Prop} : (‚àÉ a b, p a b) ‚Üî ‚àÉ x : Œ£ a, Œ≤ a, p x.1 x.2 ",":=
  (Sigma.exists (p := fun x ‚Ü¶ p x.1 x.2)).symm",":=
  ‚ü®fun ‚ü®x, hx‚ü© ‚Ü¶ ‚ü®x, hx‚ü©, fun ‚ü®x, hx‚ü© ‚Ü¶ ‚ü®x, hx‚ü©, fun ‚ü®x, hx‚ü© ‚Ü¶ ‚ü®x, hx‚ü©‚ü©"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_ortho"
Mathlib/Data/Multiset/Fintype.lean,Multiset.mem_of_mem_toEnumFinset,Multiset.mem_of_mem_toEnumFinset,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  Multiset.count_pos.mp <| pos_of_gt <| (m.mem_toEnumFinset p).mp h","error:  application type mismatch
  count_pos.mp (pos_of_gt ?m.5230)
argument
  pos_of_gt ?m.5230
has type
  @OfNat.ofNat ‚Ñï 0 Zero.toOfNat0 < ?m.5088 : Prop
but is expected to have type
  @OfNat.ofNat ‚Ñï 0 (instOfNatNat 0) < count p.1 m : Prop",theorem Multiset.mem_of_mem_toEnumFinset {p : Œ± √ó ‚Ñï} (h : p ‚àà m.toEnumFinset) : p.1 ‚àà m ,":=
  have := (m.mem_toEnumFinset p).mp h; Multiset.count_pos.mp (by omega)",":=
  Multiset.count_pos.mp <| m.mem_toEnumFinset p).mp h"
Mathlib/CategoryTheory/Monoidal/Bimod.lean,Bimod.RightUnitorBimod.inv_hom_id,inv_hom_id,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp [hom, homAux, inv, invAux]
  apply coequalizer.hom_ext
  slice_lhs 1 2 => rw [coequalizer.œÄ_desc]
  refine' (cancel_epi ((tensorLeft _).map (coequalizer.œÄ _ _))).1 _
  rw [tensorLeft_map]
  slice_lhs 1 3 => rw [id_tensor_œÄ_preserves_coequalizer_inv_desc]
  slice_lhs 3 4 => rw [coequalizer.œÄ_desc]
  slice_lhs 2 4 => rw [œÄ_tensor_id_preserves_coequalizer_inv_desc]
  slice_lhs 1 3 => rw [Iso.inv_hom_id_assoc]
  dsimp only [TensorBimod.X]
  slice_rhs 2 3 => rw [Category.comp_id]","error:  unsolved goals
case h
C : Type u‚ÇÅ
inst‚úù‚Å¥ : Category.{v‚ÇÅ, u‚ÇÅ} C
inst‚úù¬≥ : MonoidalCategory C
A B : Mon_ C
M : Bimod A B
inst‚úù¬≤ : HasCoequalizers C
inst‚úù¬π : (X : C) ‚Üí PreservesColimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (tensorLeft X)
inst‚úù : (X : C) ‚Üí PreservesColimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (tensorRight X)
R S T U : Mon_ C
P : Bimod R S
Q : Bimod S T
L : Bimod T U
‚ä¢ P.X ‚óÅ coequalizer.œÄ (Q.actRight ‚ñ∑ L.X) ((Œ±_ Q.X T.X L.X).hom ‚â´ Q.X ‚óÅ L.actLeft) ‚â´
      coequalizer.œÄ (P.actRight ‚ñ∑ coequalizer (Q.actRight ‚ñ∑ L.X) ((Œ±_ Q.X T.X L.X).hom ‚â´ Q.X ‚óÅ L.actLeft))
        ((Œ±_ P.X S.X (coequalizer (Q.actRight ‚ñ∑ L.X) ((Œ±_ Q.X T.X L.X).hom ‚â´ Q.X ‚óÅ L.actLeft))).hom ‚â´
          P.X ‚óÅ TensorBimod.actLeft Q L) =
    P.X ‚óÅ coequalizer.œÄ (Q.actRight ‚ñ∑ L.X) ((Œ±_ Q.X T.X L.X).hom ‚â´ Q.X ‚óÅ L.actLeft) ‚â´
      coequalizer.œÄ (P.actRight ‚ñ∑ (Q.tensorBimod L).X)
        ((Œ±_ P.X S.X (Q.tensorBimod L).X).hom ‚â´ P.X ‚óÅ (Q.tensorBimod L).actLeft)",theorem inv_hom_id : inv P Q L ‚â´ hom P Q L = ùüô _ ,":= by
  dsimp [hom, homAux, inv, invAux]
  apply coequalizer.hom_ext
  slice_lhs 1 2 => rw [coequalizer.œÄ_desc]
  refine (cancel_epi ((tensorLeft _).map (coequalizer.œÄ _ _))).1 ?_
  rw [tensorLeft_map]
  slice_lhs 1 3 => rw [id_tensor_œÄ_preserves_coequalizer_inv_desc]
  slice_lhs 3 4 => rw [coequalizer.œÄ_desc]
  slice_lhs 2 4 => rw [œÄ_tensor_id_preserves_coequalizer_inv_desc]
  slice_lhs 1 3 => rw [Iso.inv_hom_id_assoc]
  dsimp only [TensorBimod.X]
  slice_rhs 2 3 => rw [Category.comp_id]
  rfl",":= by
  dsimp [hom, homAux, inv, invAux]
  apply coequalizer.hom_ext
  slice_lhs 1 2 => rw [coequalizer.œÄ_desc]
  refine (cancel_epi ((tensorLeft _).map (coequalizer.œÄ _ _))).1 ?_
  rw [tensorLeft_map]
  slice_lhs 1 3 => rw [id_tensor_œÄ_preserves_coequalizer_inv_desc]
  slice_lhs 3 4 => rw [coequalizer.œÄ_desc]
  slice_lhs 2 4 => rw [œÄ_tensor_id_preserves_coequalizer_inv_desc]
  slice_lhs 1 3 => rw [Iso.inv_hom_id_assoc]
  dsimp only [TensorBimod.X]
  slice_rhs 2 3 => rw [Category.comp_id]"
Mathlib/Data/Set/Card.lean,Set.ncard_inter_le_ncard_left,ncard_inter_le_ncard_left,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  ncard_le_ncard (inter_subset_left _ _) hs","error:  function expected at
  inter_subset_left ?m.162416
term has type
  ?m.162415 ‚àà ?m.162413","theorem ncard_inter_le_ncard_left (s t : Set Œ±) (hs : s.Finite := by toFinite_tac) :
    (s ‚à© t).ncard ‚â§ s.ncard ",":=
  ncard_le_ncard inter_subset_left hs",":=
  ncard_le_ncard inter_subset_left"
Mathlib/Analysis/Calculus/MeanValue.lean,Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le,norm_image_sub_le_of_norm_hasFDerivWithin_le,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  letI : NormedSpace ‚Ñù G := RestrictScalars.normedSpace ‚Ñù ùïú G
  set g := (AffineMap.lineMap x y : ‚Ñù ‚Üí E)
  have segm : MapsTo g (Icc 0 1 : Set ‚Ñù) s := hs.mapsTo_lineMap xs ys
  have hD : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1,
      HasDerivWithinAt (f ‚àò g) (f' (g t) (y - x)) (Icc 0 1) t := fun t ht => by
    simpa using ((hf (g t) (segm ht)).restrictScalars ‚Ñù).comp_hasDerivWithinAt _
      AffineMap.hasDerivWithinAt_lineMap segm
  have bound : ‚àÄ t ‚àà Ico (0 : ‚Ñù) 1, ‚Äñf' (g t) (y - x)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ := fun t ht =>
    le_of_op_norm_le _ (bound _ <| segm <| Ico_subset_Icc_self ht) _
  simpa using norm_image_sub_le_of_norm_deriv_le_segment_01' hD bound","warning:  `ContinuousLinearMap.le_of_op_norm_le` has been deprecated, use `ContinuousLinearMap.le_of_opNorm_le` instead
error:  type mismatch
  h‚úù
has type
  ‚Äñf (g 1) - f (g 0)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ : Prop
but is expected to have type
  ‚Äñf y - f x‚Äñ ‚â§ C * ‚Äñy - x‚Äñ : Prop","theorem norm_image_sub_le_of_norm_hasFDerivWithin_le
    (hf : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) (bound : ‚àÄ x ‚àà s, ‚Äñf' x‚Äñ ‚â§ C) (hs : Convex ‚Ñù s)
    (xs : x ‚àà s) (ys : y ‚àà s) : ‚Äñf y - f x‚Äñ ‚â§ C * ‚Äñy - x‚Äñ ",":= by
  letI : NormedSpace ‚Ñù G := RestrictScalars.normedSpace ‚Ñù ùïú G
  set g := (AffineMap.lineMap x y : ‚Ñù ‚Üí E)
  have segm : MapsTo g (Icc 0 1 : Set ‚Ñù) s := hs.mapsTo_lineMap xs ys
  have hD : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1,
      HasDerivWithinAt (f ‚àò g) (f' (g t) (y - x)) (Icc 0 1) t := fun t ht => by
    simpa using ((hf (g t) (segm ht)).restrictScalars ‚Ñù).comp_hasDerivWithinAt _
      AffineMap.hasDerivWithinAt_lineMap segm
  have bound : ‚àÄ t ‚àà Ico (0 : ‚Ñù) 1, ‚Äñf' (g t) (y - x)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ := fun t ht =>
    le_of_opNorm_le _ (bound _ <| segm <| Ico_subset_Icc_self ht) _
  simpa [g] using norm_image_sub_le_of_norm_deriv_le_segment_01' hD bound",":= by
  letI : NormedSpace ‚Ñù G := RestrictScalars.normedSpace ‚Ñù ùïú G
  set g := (AffineMap.lineMap x y : ‚Ñù ‚Üí E)
  have segm : MapsTo g (Icc 0 1 : Set ‚Ñù) s := hs.mapsTo_lineMap xs ys
  have hD : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1,
      HasDerivWithinAt (f ‚àò g) (f' (g t) (y - x)) (Icc 0 1) t := fun t ht => by
    simpa using ((hf (g t) (segm ht)).restrictScalars ‚Ñù).comp_hasDerivWithinAt _
      AffineMap.hasDerivWithinAt_lineMap segm
  have bound : ‚àÄ t ‚àà Ico (0:‚Ñù) 1, ‚Äñf' (g t) (y - x)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ := fun t ht =>
    le_of_op_norm_le _ (bound _ <| segm <| Ico_subset_Icc_self ht) _
  simpa using norm_image_sub_le_of_norm_deriv_le_segment_01' hD bound"
Mathlib/Algebra/DirectLimit.lean,Module.DirectLimit.map_comp,map_comp,af1e1921fa808d9f4d24fd674214116943e9fbb8,":=
  FunLike.ext _ _ fun x ‚Ü¶ (isEmpty_or_nonempty Œπ).elim (fun _ ‚Ü¶ Subsingleton.elim _ _) fun _ ‚Ü¶
    x.induction_on fun i g ‚Ü¶ by simp",error:  unknown constant 'FunLike.ext',"lemma map_comp [IsDirected Œπ (¬∑ ‚â§ ¬∑)]
    (g‚ÇÅ : (i : Œπ) ‚Üí G i ‚Üí‚Çó[R] G' i) (g‚ÇÇ : (i : Œπ) ‚Üí G' i ‚Üí‚Çó[R] G'' i)
    (hg‚ÇÅ : ‚àÄ i j h, g‚ÇÅ j ‚àò‚Çó f i j h = f' i j h ‚àò‚Çó g‚ÇÅ i)
    (hg‚ÇÇ : ‚àÄ i j h, g‚ÇÇ j ‚àò‚Çó f' i j h = f'' i j h ‚àò‚Çó g‚ÇÇ i) :
    (map g‚ÇÇ hg‚ÇÇ ‚àò‚Çó map g‚ÇÅ hg‚ÇÅ :
      DirectLimit G f ‚Üí‚Çó[R] DirectLimit G'' f'') =
    (map (fun i ‚Ü¶ g‚ÇÇ i ‚àò‚Çó g‚ÇÅ i) fun i j h ‚Ü¶ by
        rw [LinearMap.comp_assoc, hg‚ÇÅ i, ‚Üê LinearMap.comp_assoc, hg‚ÇÇ i, LinearMap.comp_assoc] :
      DirectLimit G f ‚Üí‚Çó[R] DirectLimit G'' f'') ",":=
  DFunLike.ext _ _ fun x ‚Ü¶ (isEmpty_or_nonempty Œπ).elim (fun _ ‚Ü¶ Subsingleton.elim _ _) fun _ ‚Ü¶
    x.induction_on fun i g ‚Ü¶ by simp",":=
  FunLike.ext _ _ fun x ‚Ü¶ (isEmpty_or_nonempty Œπ).elim (fun _ ‚Ü¶ Subsingleton.elim _ _) fun _ ‚Ü¶
    x.induction_on fun i g ‚Ü¶ by simp"
Mathlib/RingTheory/Localization/Ideal.lean,IsLocalization.surjective_quotientMap_of_maximal_of_localization,surjective_quotientMap_of_maximal_of_localization,047f73c34cd3e6bae28166f72847965b1a989c70,":= by
  intro s
  obtain ‚ü®s, rfl‚ü© := Ideal.Quotient.mk_surjective s
  obtain ‚ü®r, ‚ü®m, hm‚ü©, rfl‚ü© := mk'_surjective M s
  by_cases hM : (Ideal.Quotient.mk (I.comap (algebraMap R S))) m = 0
  ¬∑ have : I = ‚ä§ := by
      rw [Ideal.eq_top_iff_one]
      rw [Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_comap] at hM
      convert I.mul_mem_right (mk' S (1 : R) ‚ü®m, hm‚ü©) hM
      rw [‚Üê mk'_eq_mul_mk'_one, mk'_self]
    exact ‚ü®0, eq_comm.1 (by simp [Ideal.Quotient.eq_zero_iff_mem, this])‚ü©
  ¬∑ rw [Ideal.Quotient.maximal_ideal_iff_isField_quotient] at hI
    obtain ‚ü®n, hn‚ü© := hI.3 hM
    obtain ‚ü®rn, rfl‚ü© := Ideal.Quotient.mk_surjective n
    refine' ‚ü®(Ideal.Quotient.mk J) (r * rn), _‚ü©
    replace hn := congr_arg (Ideal.quotientMap I (algebraMap R S) le_rfl) hn
    rw [RingHom.map_one, RingHom.map_mul] at hn
    rw [Ideal.quotientMap_mk, ‚Üê sub_eq_zero, ‚Üê RingHom.map_sub, Ideal.Quotient.eq_zero_iff_mem, ‚Üê
      Ideal.Quotient.eq_zero_iff_mem, RingHom.map_sub, sub_eq_zero, mk'_eq_mul_mk'_one]
    simp only [mul_eq_mul_left_iff, RingHom.map_mul]
    refine
      Or.inl
        (mul_left_cancel‚ÇÄ (M‚ÇÄ := S ‚ß∏ I)
          (fun hn =>
            hM
              (Ideal.Quotient.eq_zero_iff_mem.2
                (Ideal.mem_comap.2 (Ideal.Quotient.eq_zero_iff_mem.1 hn))))
          (trans hn ?_))
    refine Eq.trans ?_ (RingHom.map_mul (Ideal.Quotient.mk I) (algebraMap R S m) (mk' S 1 ‚ü®m, hm‚ü©))
    rw [‚Üê mk'_eq_mul_mk'_one, mk'_self, RingHom.map_one]","error:  ambiguous, possible interpretations 
  _root_.trans hn
    ?m.56106 : (Ideal.Quotient.mk I) ((algebraMap R S) m) * (Ideal.Quotient.mk I) ((algebraMap R S) rn) =
    (Ideal.Quotient.mk I) ((algebraMap R S) m) * (Ideal.Quotient.mk I) (mk' S 1 ‚ü®m, hm‚ü©)
  
  Trans.trans hn
    ?m.56301 : (Ideal.Quotient.mk I) ((algebraMap R S) m) * (Ideal.Quotient.mk I) ((algebraMap R S) rn) =
    (Ideal.Quotient.mk I) ((algebraMap R S) m) * (Ideal.Quotient.mk I) (mk' S 1 ‚ü®m, hm‚ü©)
error:  no goals to be solved","theorem surjective_quotientMap_of_maximal_of_localization {I : Ideal S} [I.IsPrime] {J : Ideal R}
    {H : J ‚â§ I.comap (algebraMap R S)} (hI : (I.comap (algebraMap R S)).IsMaximal) :
    Function.Surjective (Ideal.quotientMap I (algebraMap R S) H) ",":= by
  intro s
  obtain ‚ü®s, rfl‚ü© := Ideal.Quotient.mk_surjective s
  obtain ‚ü®r, ‚ü®m, hm‚ü©, rfl‚ü© := mk'_surjective M s
  by_cases hM : (Ideal.Quotient.mk (I.comap (algebraMap R S))) m = 0
  ¬∑ have : I = ‚ä§ := by
      rw [Ideal.eq_top_iff_one]
      rw [Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_comap] at hM
      convert I.mul_mem_right (mk' S (1 : R) ‚ü®m, hm‚ü©) hM
      rw [‚Üê mk'_eq_mul_mk'_one, mk'_self]
    exact ‚ü®0, eq_comm.1 (by simp [Ideal.Quotient.eq_zero_iff_mem, this])‚ü©
  ¬∑ rw [Ideal.Quotient.maximal_ideal_iff_isField_quotient] at hI
    obtain ‚ü®n, hn‚ü© := hI.3 hM
    obtain ‚ü®rn, rfl‚ü© := Ideal.Quotient.mk_surjective n
    refine ‚ü®(Ideal.Quotient.mk J) (r * rn), ?_‚ü©
    replace hn := congr_arg (Ideal.quotientMap I (algebraMap R S) le_rfl) hn
    rw [RingHom.map_one, RingHom.map_mul] at hn
    rw [Ideal.quotientMap_mk, ‚Üê sub_eq_zero, ‚Üê RingHom.map_sub, Ideal.Quotient.eq_zero_iff_mem, ‚Üê
      Ideal.Quotient.eq_zero_iff_mem, RingHom.map_sub, sub_eq_zero, mk'_eq_mul_mk'_one]
    simp only [mul_eq_mul_left_iff, RingHom.map_mul]
    refine
      Or.inl
        (mul_left_cancel‚ÇÄ (M‚ÇÄ := S ‚ß∏ I)
          (fun hn =>
            hM
              (Ideal.Quotient.eq_zero_iff_mem.2
                (Ideal.mem_comap.2 (Ideal.Quotient.eq_zero_iff_mem.1 hn))))
          (_root_.trans hn ?_))
    refine Eq.trans ?_ (RingHom.map_mul (Ideal.Quotient.mk I) (algebraMap R S m) (mk' S 1 ‚ü®m, hm‚ü©))
    rw [‚Üê mk'_eq_mul_mk'_one, mk'_self, RingHom.map_one]",":= by
  intro s
  obtain ‚ü®s, rfl‚ü© := Ideal.Quotient.mk_surjective s
  obtain ‚ü®r, ‚ü®m, hm‚ü©, rfl‚ü© := mk'_surjective M s
  by_cases hM : (Ideal.Quotient.mk (I.comap (algebraMap R S))) m = 0
  ¬∑ have : I = ‚ä§ := by
      rw [Ideal.eq_top_iff_one]
      rw [Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_comap] at hM
      convert I.mul_mem_right (mk' S (1 : R) ‚ü®m, hm‚ü©) hM
      rw [‚Üê mk'_eq_mul_mk'_one, mk'_self]
    exact ‚ü®0, eq_comm.1 (by simp [Ideal.Quotient.eq_zero_iff_mem, this])‚ü©
  ¬∑ rw [Ideal.Quotient.maximal_ideal_iff_isField_quotient] at hI
    obtain ‚ü®n, hn‚ü© := hI.3 hM
    obtain ‚ü®rn, rfl‚ü© := Ideal.Quotient.mk_surjective n
    refine ‚ü®(Ideal.Quotient.mk J) (r * rn), ?_‚ü©
    replace hn := congr_arg (Ideal.quotientMap I (algebraMap R S) le_rfl) hn
    rw [RingHom.map_one, RingHom.map_mul] at hn
    rw [Ideal.quotientMap_mk, ‚Üê sub_eq_zero, ‚Üê RingHom.map_sub, Ideal.Quotient.eq_zero_iff_mem, ‚Üê
      Ideal.Quotient.eq_zero_iff_mem, RingHom.map_sub, sub_eq_zero, mk'_eq_mul_mk'_one]
    simp only [mul_eq_mul_left_iff, RingHom.map_mul]
    refine
      Or.inl
        (mul_left_cancel‚ÇÄ (M‚ÇÄ := S ‚ß∏ I)
          (fun hn =>
             hM
             (Ideal.Quotient.eq_zero_iff_mem.2
                (Ideal.mem_comap.2 (Ideal.Quotient.eq_zero_iff_mem.1 hn))))
          (trans hn ?_))
    refine Eq.trans ?_ (RingHom.map_mul (Ideal.Quotient.mk I) (algebraMap R S m) (mk' S 1 ‚ü®m, hm‚ü©))
    rw [‚Üê mk'_eq_mul_mk'_one, mk'_self, RingHom.map_one]"
Mathlib/Computability/RegularExpressions.lean,RegularExpression.star_rmatch_iff,star_rmatch_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  fun x => by
    have A : ‚àÄ m n : ‚Ñï, n < m + n + 1 := by
      intro m n
      convert add_lt_add_of_le_of_lt (add_le_add (zero_le m) (le_refl n)) zero_lt_one
      simp
    have IH := fun t (_h : List.length t < List.length x) => star_rmatch_iff P t
    clear star_rmatch_iff
    constructor
    ¬∑ cases' x with a x
      ¬∑ intro _h
        use []; dsimp; tauto
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        rintro ‚ü®t, u, hs, ht, hu‚ü©
        have hwf : u.length < (List.cons a x).length := by
          rw [hs, List.length_cons, List.length_append]
          apply A
        rw [IH _ hwf] at hu
        rcases hu with ‚ü®S', hsum, helem‚ü©
        use (a :: t) :: S'
        constructor
        ¬∑ simp [hs, hsum]
        ¬∑ intro t' ht'
          cases ht' with
          | head ht' =>
            simp only [ne_eq, not_false_iff, true_and, rmatch]
            exact ht
          | tail _ ht' => exact helem t' ht'
    ¬∑ rintro ‚ü®S, hsum, helem‚ü©
      cases' x with a x
      ¬∑ rfl
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        cases' S with t' U
        ¬∑ exact ‚ü®[], [], by tauto‚ü©
        ¬∑ cases' t' with b t
          ¬∑ simp only [forall_eq_or_imp, List.mem_cons] at helem
            simp only [eq_self_iff_true, not_true, Ne, false_and_iff] at helem
          simp only [List.join, List.cons_append, List.cons_eq_cons] at hsum
          refine' ‚ü®t, U.join, hsum.2, _, _‚ü©
          ¬∑ specialize helem (b :: t) (by simp)
            rw [rmatch] at helem
            convert helem.2
            exact hsum.1
          ¬∑ have hwf : U.join.length < (List.cons a x).length := by
              rw [hsum.1, hsum.2]
              simp only [List.length_append, List.length_join, List.length]
              apply A
            rw [IH _ hwf]
            refine' ‚ü®U, rfl, fun t h => helem t _‚ü©
            right
            assumption
  termination_by t => (P, t.length)","error:  application type mismatch
  add_le_add (zero_le m) (le_refl n)
argument
  le_refl n
has type
  @LE.le ‚Ñï (@Preorder.toLE ‚Ñï (@PartialOrder.toPreorder ‚Ñï SemilatticeInf.toPartialOrder)) n n : Prop
but is expected to have type
  @LE.le ‚Ñï (@Preorder.toLE ‚Ñï (@PartialOrder.toPreorder ‚Ñï OrderedAddCommMonoid.toPartialOrder)) n n : Prop","theorem star_rmatch_iff (P : RegularExpression Œ±) :
    ‚àÄ x : List Œ±, (star P).rmatch x ‚Üî ‚àÉ S : List (List Œ±), x
          = S.join ‚àß ‚àÄ t ‚àà S, t ‚â† [] ‚àß P.rmatch t ",":=
  fun x => by
    have IH := fun t (_h : List.length t < List.length x) => star_rmatch_iff P t
    clear star_rmatch_iff
    constructor
    ¬∑ cases' x with a x
      ¬∑ intro _h
        use []; dsimp; tauto
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        rintro ‚ü®t, u, hs, ht, hu‚ü©
        have hwf : u.length < (List.cons a x).length := by
          rw [hs, List.length_cons, List.length_append]
          omega
        rw [IH _ hwf] at hu
        rcases hu with ‚ü®S', hsum, helem‚ü©
        use (a :: t) :: S'
        constructor
        ¬∑ simp [hs, hsum]
        ¬∑ intro t' ht'
          cases ht' with
          | head ht' =>
            simp only [ne_eq, not_false_iff, true_and, rmatch]
            exact ht
          | tail _ ht' => exact helem t' ht'
    ¬∑ rintro ‚ü®S, hsum, helem‚ü©
      cases' x with a x
      ¬∑ rfl
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        cases' S with t' U
        ¬∑ exact ‚ü®[], [], by tauto‚ü©
        ¬∑ cases' t' with b t
          ¬∑ simp only [forall_eq_or_imp, List.mem_cons] at helem
            simp only [eq_self_iff_true, not_true, Ne, false_and_iff] at helem
          simp only [List.join, List.cons_append, List.cons_eq_cons] at hsum
          refine ‚ü®t, U.join, hsum.2, ?_, ?_‚ü©
          ¬∑ specialize helem (b :: t) (by simp)
            rw [rmatch] at helem
            convert helem.2
            exact hsum.1
          ¬∑ have hwf : U.join.length < (List.cons a x).length := by
              rw [hsum.1, hsum.2]
              simp only [List.length_append, List.length_join, List.length]
              omega
            rw [IH _ hwf]
            refine ‚ü®U, rfl, fun t h => helem t ?_‚ü©
            right
            assumption
  termination_by t => (P, t.length)",":=
  fun x => by
    have A : ‚àÄ m n : ‚Ñï, n < m + n + 1 := by
      intro m n
      convert add_lt_add_of_le_of_lt (add_le_add (zero_le m) (le_refl n)) zero_lt_one
      simp
    have IH := fun t (_h : List.length t < List.length x) => star_rmatch_iff P t
    clear star_rmatch_iff
    constructor
    ¬∑ cases' x with a x
      ¬∑ intro _h
        use []; dsimp; tauto
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        rintro ‚ü®t, u, hs, ht, hu‚ü©
        have hwf : u.length < (List.cons a x).length := by
          rw [hs, List.length_cons, List.length_append]
          apply A
        rw [IH _ hwf] at hu
        rcases hu with ‚ü®S', hsum, helem‚ü©
        use (a :: t) :: S'
        constructor
        ¬∑ simp [hs, hsum]
        ¬∑ intro t' ht'
          cases ht' with
          | head ht' =>
            simp only [ne_eq, not_false_iff, true_and, rmatch]
            exact ht
           | tail _ ht' => exact helem t' ht'
    ¬∑ rintro ‚ü®S, hsum, helem‚ü©
      cases' x with a x
      ¬∑ rfl
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        cases' S with t' U
        ¬∑ exact ‚ü®[], [], by tauto‚ü©
        ¬∑ cases' t' with b t
          ¬∑ simp only [forall_eq_or_imp, List.mem_cons] at helem
            simp only [eq_self_iff_true, not_true, Ne, false_and_iff] at helem
          simp only [List.join, List.cons_append, List.cons_eq_cons] at hsum
          refine ‚ü®t, U.join, hsum.2, ?_, ?_‚ü©
          ¬∑ specialize helem (b :: t) (by simp)
           rw [rmatch] at helem
            convert helem.2
            exact hsum.1
          ¬∑ have hwf : U.join.length < (List.cons a x).length := by
             rw [hsum.1, hsum.2]
             simp only [List.length_append, List.length_join, List.length]
              apply A
            rw [IH _ hwf]
            refine ‚ü®U, rfl, fun t h => helem t ?_‚ü©
           right
            assumption
  termination_by t => (P, t.length)"
Mathlib/Analysis/InnerProductSpace/Projection.lean,finrank_orthogonal_span_singleton,finrank_orthogonal_span_singleton,e24d0042f0fd176848590f8a296e5c675237f634,":= by
  haveI : FiniteDimensional ùïú E := fact_finiteDimensional_of_finrank_eq_succ n
  exact Submodule.finrank_add_finrank_orthogonal' <| by
    simp [finrank_span_singleton hv, _i.elim, add_comm]",error:  unknown identifier 'fact_finiteDimensional_of_finrank_eq_succ',"theorem finrank_orthogonal_span_singleton {n : ‚Ñï} [_i : Fact (finrank ùïú E = n + 1)] {v : E}
    (hv : v ‚â† 0) : finrank ùïú (ùïú ‚àô v)·óÆ = n ",":= by
  haveI : FiniteDimensional ùïú E := .of_fact_finrank_eq_succ n
  exact Submodule.finrank_add_finrank_orthogonal' <| by
    simp [finrank_span_singleton hv, _i.elim, add_comm]",":= by
  haveI : FiniteDimensional ùïú E := fact_finiteDimensional_of_finrank_eq_succ n
  exact Submodule.finrank_add_finrank_orthogonal' <| by
    simp [finrank_span_singleton hv, _i.elim, add_comm]"
Mathlib/Probability/Kernel/IntegralCompProd.lean,ProbabilityTheory.kernel.continuous_integral_integral,kernel.continuous_integral_integral,9b5d788d575748c82ffdfc08ef4aaf0a3c6023f0,":= by
  rw [continuous_iff_continuousAt]; intro g
  refine
    tendsto_integral_of_L1 _ (L1.integrable_coeFn g).integral_compProd
      (eventually_of_forall fun h => (L1.integrable_coeFn h).integral_compProd) ?_
  simp_rw [‚Üê
    kernel.lintegral_fn_integral_sub (fun x => (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) (L1.integrable_coeFn _)
      (L1.integrable_coeFn g)]
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds ?_ (fun i => zero_le _) ?_
  ¬∑ exact fun i => ‚à´‚Åª x, ‚à´‚Åª y, ‚Äñi (x, y) - g (x, y)‚Äñ‚Çä ‚àÇŒ∑ (a, x) ‚àÇŒ∫ a
  swap; ¬∑ exact fun i => lintegral_mono fun x => ennnorm_integral_le_lintegral_ennnorm _
  show
    Tendsto
      (fun i : Œ≤ √ó Œ≥ ‚Üí‚ÇÅ[(Œ∫ ‚äó‚Çñ Œ∑) a] E => ‚à´‚Åª x, ‚à´‚Åª y : Œ≥, ‚Äñi (x, y) - g (x, y)‚Äñ‚Çä ‚àÇŒ∑ (a, x) ‚àÇŒ∫ a)
      (ùìù g) (ùìù 0)
  have : ‚àÄ i : (MeasureTheory.Lp (Œ± := Œ≤ √ó Œ≥) E 1 (((Œ∫ ‚äó‚Çñ Œ∑) a) : Measure (Œ≤ √ó Œ≥))),
      Measurable fun z => (‚Äñi z - g z‚Äñ‚Çä : ‚Ñù‚â•0‚àû) := fun i =>
    ((Lp.stronglyMeasurable i).sub (Lp.stronglyMeasurable g)).ennnorm
  simp_rw [‚Üê kernel.lintegral_compProd _ _ _ (this _), ‚Üê L1.ofReal_norm_sub_eq_lintegral, ‚Üê
    ofReal_zero]
  refine (continuous_ofReal.tendsto 0).comp ?_
  rw [‚Üê tendsto_iff_norm_sub_tendsto_zero]
  exact tendsto_id","error:  don't know how to synthesize implicit argument 'h'
  @tendsto_of_tendsto_of_tendsto_of_le_of_le ‚Ñù‚â•0‚àû (‚Ü•(Lp E 1 ((Œ∫ ‚äó‚Çñ Œ∑) a))) ENNReal.instTopologicalSpace
    PartialOrder.toPreorder instOrderTopology
    (fun i ‚Ü¶ ‚à´‚Åª (x : Œ≤), ‚Üë‚Äñ‚à´ (y : Œ≥), ‚Üë‚Üëi (x, y) - ‚Üë‚Üëg (x, y) ‚àÇŒ∑ (a, x)‚Äñ‚Çä ‚àÇŒ∫ a) (fun x ‚Ü¶ 0) ?m.59693 (ùìù g) 0
    tendsto_const_nhds ?m.59905 (fun i ‚Ü¶ zero_le (‚à´‚Åª (x : Œ≤), ‚Üë‚Äñ‚à´ (y : Œ≥), ‚Üë‚Üëi (x, y) - ‚Üë‚Üëg (x, y) ‚àÇŒ∑ (a, x)‚Äñ‚Çä ‚àÇŒ∫ a))
    ?m.60063
context:
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
E : Type u_4
mŒ± : MeasurableSpace Œ±
mŒ≤ : MeasurableSpace Œ≤
mŒ≥ : MeasurableSpace Œ≥
inst‚úù‚Å∂ : NormedAddCommGroup E
Œ∫ : ‚Ü•(kernel Œ± Œ≤)
inst‚úù‚Åµ : IsSFiniteKernel Œ∫
Œ∑ : ‚Ü•(kernel (Œ± √ó Œ≤) Œ≥)
inst‚úù‚Å¥ : IsSFiniteKernel Œ∑
a : Œ±
inst‚úù¬≥ : NormedSpace ‚Ñù E
E' : Type u_5
inst‚úù¬≤ : NormedAddCommGroup E'
inst‚úù¬π : CompleteSpace E'
inst‚úù : NormedSpace ‚Ñù E'
g : ‚Ü•(Lp E 1 ((Œ∫ ‚äó‚Çñ Œ∑) a))
‚ä¢ ‚Ü•(Lp E 1 ((Œ∫ ‚äó‚Çñ Œ∑) a)) ‚Üí ‚Ñù‚â•0‚àû
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
E : Type u_4
mŒ± : MeasurableSpace Œ±
mŒ≤ : MeasurableSpace Œ≤
mŒ≥ : MeasurableSpace Œ≥
inst‚úù‚Å∂ : NormedAddCommGroup E
Œ∫ : ‚Ü•(kernel Œ± Œ≤)
inst‚úù‚Åµ : IsSFiniteKernel Œ∫
Œ∑ : ‚Ü•(kernel (Œ± √ó Œ≤) Œ≥)
inst‚úù‚Å¥ : IsSFiniteKernel Œ∑
a : Œ±
inst‚úù¬≥ : NormedSpace ‚Ñù E
E' : Type u_5
inst‚úù¬≤ : NormedAddCommGroup E'
inst‚úù¬π : CompleteSpace E'
inst‚úù : NormedSpace ‚Ñù E'
g : ‚Ü•(Lp E 1 ((Œ∫ ‚äó‚Çñ Œ∑) a))
‚ä¢ Tendsto (fun i ‚Ü¶ ‚à´‚Åª (x : Œ≤), ‚Üë‚Äñ‚à´ (y : Œ≥), ‚Üë‚Üëi (x, y) - ‚Üë‚Üëg (x, y) ‚àÇŒ∑ (a, x)‚Äñ‚Çä ‚àÇŒ∫ a) (ùìù g) (ùìù 0)","theorem kernel.continuous_integral_integral :
    Continuous fun f : (MeasureTheory.Lp (Œ± := Œ≤ √ó Œ≥) E 1 (((Œ∫ ‚äó‚Çñ Œ∑) a) : Measure (Œ≤ √ó Œ≥))) =>
        ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x) ‚àÇŒ∫ a ",":= by
  rw [continuous_iff_continuousAt]; intro g
  refine
    tendsto_integral_of_L1 _ (L1.integrable_coeFn g).integral_compProd
      (eventually_of_forall fun h => (L1.integrable_coeFn h).integral_compProd) ?_
  simp_rw [‚Üê
    kernel.lintegral_fn_integral_sub (fun x => (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) (L1.integrable_coeFn _)
      (L1.integrable_coeFn g)]
  apply tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (fun i => zero_le _) _
  ¬∑ exact fun i => ‚à´‚Åª x, ‚à´‚Åª y, ‚Äñi (x, y) - g (x, y)‚Äñ‚Çä ‚àÇŒ∑ (a, x) ‚àÇŒ∫ a
  swap; ¬∑ exact fun i => lintegral_mono fun x => ennnorm_integral_le_lintegral_ennnorm _
  show
    Tendsto
      (fun i : Œ≤ √ó Œ≥ ‚Üí‚ÇÅ[(Œ∫ ‚äó‚Çñ Œ∑) a] E => ‚à´‚Åª x, ‚à´‚Åª y : Œ≥, ‚Äñi (x, y) - g (x, y)‚Äñ‚Çä ‚àÇŒ∑ (a, x) ‚àÇŒ∫ a)
      (ùìù g) (ùìù 0)
  have : ‚àÄ i : (MeasureTheory.Lp (Œ± := Œ≤ √ó Œ≥) E 1 (((Œ∫ ‚äó‚Çñ Œ∑) a) : Measure (Œ≤ √ó Œ≥))),
      Measurable fun z => (‚Äñi z - g z‚Äñ‚Çä : ‚Ñù‚â•0‚àû) := fun i =>
    ((Lp.stronglyMeasurable i).sub (Lp.stronglyMeasurable g)).ennnorm
  simp_rw [‚Üê kernel.lintegral_compProd _ _ _ (this _), ‚Üê L1.ofReal_norm_sub_eq_lintegral, ‚Üê
    ofReal_zero]
  refine (continuous_ofReal.tendsto 0).comp ?_
  rw [‚Üê tendsto_iff_norm_sub_tendsto_zero]
  exact tendsto_id",":= by
  rw [continuous_iff_continuousAt]; intro g
  refine
    tendsto_integral_of_L1 _ (L1.integrable_coeFn g).integral_compProd
      (eventually_of_forall fun h => (L1.integrable_coeFn h).integral_compProd) ?_
  simp_rw [‚Üê
    kernel.lintegral_fn_integral_sub (fun x => (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) (L1.integrable_coeFn _)
      (L1.integrable_coeFn g)]
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds ?_ (fun i => zero_le _) ?_
  ¬∑ exact fun i => ‚à´‚Åª x, ‚à´‚Åª y, ‚Äñi (x, y) - g (x, y)‚Äñ‚Çä ‚àÇŒ∑ (a, x) ‚àÇŒ∫ a
  swap; ¬∑ exact fun i => lintegral_mono fun x => ennnorm_integral_le_lintegral_ennnorm _
  show
    Tendsto
      (fun i : Œ≤ √ó Œ≥ ‚Üí‚ÇÅ[(Œ∫ ‚äó‚Çñ Œ∑) a] E => ‚à´‚Åª x, ‚à´‚Åª y : Œ≥, ‚Äñi (x, y) - g (x, y)‚Äñ‚Çä ‚àÇŒ∑ (a, x) ‚àÇŒ∫ a)
      (ùìù g) (ùìù 0)
  have : ‚àÄ i : (MeasureTheory.Lp (Œ± := Œ≤ √ó Œ≥) E 1 (((Œ∫ ‚äó‚Çñ Œ∑) a) : Measure (Œ≤ √ó Œ≥))),
      Measurable fun z => (‚Äñi z - g z‚Äñ‚Çä : ‚Ñù‚â•0‚àû) := fun i =>
    ((Lp.stronglyMeasurable i).sub (Lp.stronglyMeasurable g)).ennnorm
  simp_rw [‚Üê kernel.lintegral_compProd _ _ _ (this _), ‚Üê L1.ofReal_norm_sub_eq_lintegral, ‚Üê
    ofReal_zero]
  refine (continuous_ofReal.tendsto 0).comp ?_
  rw [‚Üê tendsto_iff_norm_sub_tendsto_zero]
  exact tendsto_id"
Mathlib/Data/Matroid/IndepAxioms.lean,Matroid.existsMaximalSubsetProperty_of_bdd,_root_.Matroid.existsMaximalSubsetProperty_of_bdd,e9a39a32b654a1485acbad2fc16ec13a695fbc99,":= by
  obtain ‚ü®n, hP‚ü© := hP
  rintro I hI hIX
  have hfin : Set.Finite (ncard '' {Y | P Y ‚àß I ‚äÜ Y ‚àß Y ‚äÜ X})
  ¬∑ rw [finite_iff_bddAbove, bddAbove_def]
    simp_rw [ENat.le_coe_iff] at hP
    use n
    rintro x ‚ü®Y, ‚ü®hY,-,-‚ü©, rfl‚ü©
    obtain ‚ü®n‚ÇÄ, heq, hle‚ü© := hP Y hY
    rwa [ncard_def, heq, ENat.toNat_coe]
  obtain ‚ü®Y, hY, hY'‚ü© := Finite.exists_maximal_wrt' ncard _ hfin ‚ü®I, hI, rfl.subset, hIX‚ü©
  refine' ‚ü®Y, hY, fun J ‚ü®hJ, hIJ, hJX‚ü© (hYJ : Y ‚äÜ J) ‚Ü¶ (_ : J ‚äÜ Y)‚ü©
  have hJfin := finite_of_encard_le_coe (hP J hJ)
  refine' (eq_of_subset_of_ncard_le hYJ _ hJfin).symm.subset
  rw [hY' J ‚ü®hJ, hIJ, hJX‚ü© (ncard_le_ncard hYJ hJfin)]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro
Œ± : Type u_1
I‚úù B X‚úù : Set Œ±
P : Set Œ± ‚Üí Prop
X : Set Œ±
n : ‚Ñï
hP : ‚àÄ (Y : Set Œ±), P Y ‚Üí Y.encard ‚â§ ‚Üën
I : Set Œ±
hI : P I
hIX : I ‚äÜ X
hfin : (ncard '' {Y | P Y ‚àß I ‚äÜ Y ‚àß Y ‚äÜ X}).Finite
‚ä¢ (maximals (fun x x_1 ‚Ü¶ x ‚äÜ x_1) {Y | P Y ‚àß I ‚äÜ Y ‚àß Y ‚äÜ X}).Nonempty","theorem _root_.Matroid.existsMaximalSubsetProperty_of_bdd {P : Set Œ± ‚Üí Prop}
    (hP : ‚àÉ (n : ‚Ñï), ‚àÄ Y, P Y ‚Üí Y.encard ‚â§ n) (X : Set Œ±) : ExistsMaximalSubsetProperty P X ",":= by
  obtain ‚ü®n, hP‚ü© := hP
  rintro I hI hIX
  have hfin : Set.Finite (ncard '' {Y | P Y ‚àß I ‚äÜ Y ‚àß Y ‚äÜ X}) := by
    rw [finite_iff_bddAbove, bddAbove_def]
    simp_rw [ENat.le_coe_iff] at hP
    use n
    rintro x ‚ü®Y, ‚ü®hY,-,-‚ü©, rfl‚ü©
    obtain ‚ü®n‚ÇÄ, heq, hle‚ü© := hP Y hY
    rwa [ncard_def, heq, ENat.toNat_coe]
  obtain ‚ü®Y, hY, hY'‚ü© := Finite.exists_maximal_wrt' ncard _ hfin ‚ü®I, hI, rfl.subset, hIX‚ü©
  refine ‚ü®Y, hY, fun J ‚ü®hJ, hIJ, hJX‚ü© (hYJ : Y ‚äÜ J) ‚Ü¶ (?_ : J ‚äÜ Y)‚ü©
  have hJfin := finite_of_encard_le_coe (hP J hJ)
  refine (eq_of_subset_of_ncard_le hYJ ?_ hJfin).symm.subset
  rw [hY' J ‚ü®hJ, hIJ, hJX‚ü© (ncard_le_ncard hYJ hJfin)]",":= by
  obtain ‚ü®n, hP‚ü© := hP
  rintro I hI hIX
  have hfin : Set.Finite (ncard '' {Y | P Y ‚àß I ‚äÜ Y ‚àß Y ‚äÜ X})
  ¬∑ rw [finite_iff_bddAbove, bddAbove_def]
    simp_rw [ENat.le_coe_iff] at hP
    use n
    rintro x ‚ü®Y, ‚ü®hY,-,-‚ü©, rfl‚ü©
    obtain ‚ü®n‚ÇÄ, heq, hle‚ü© := hP Y hY
    rwa [ncard_def, heq, ENat.toNat_coe]
  obtain ‚ü®Y, hY, hY'‚ü© := Finite.exists_maximal_wrt' ncard _ hfin ‚ü®I, hI, rfl.subset, hIX‚ü©
  refine ‚ü®Y, hY, fun J ‚ü®hJ, hIJ, hJX‚ü© (hYJ : Y ‚äÜ J) ‚Ü¶ (_ : J ‚äÜ Y)‚ü©
  have hJfin := finite_of_encard_le_coe (hP J hJ)
  refine (eq_of_subset_of_ncard_le hYJ ?_ hJfin).symm.subset
  rw [hY' J ‚ü®hJ, hIJ, hJX‚ü© (ncard_le_ncard hYJ hJfin)]"
Mathlib/Combinatorics/SetFamily/Intersecting.lean,Set.Intersecting.is_max_iff_card_eq,Intersecting.is_max_iff_card_eq,e2193fa2a3ac9de816d77eb776ed0fbe2dc6d19c,":= by
  classical
    refine'
      ‚ü®fun h => _, fun h t ht hst =>
        Finset.eq_of_subset_of_card_le hst <|
          le_of_mul_le_mul_left (ht.card_le.trans_eq h.symm) two_pos‚ü©
    suffices s.disjUnion (s.map ‚ü®compl, compl_injective‚ü©) hs.disjoint_map_compl = Finset.univ by
      rw [Fintype.card, ‚Üê this, two_mul, card_disjUnion, card_map]
    rw [‚Üê coe_eq_univ, disjUnion_eq_union, coe_union, coe_map, Function.Embedding.coeFn_mk,
      image_eq_preimage_of_inverse compl_compl compl_compl]
    refine' eq_univ_of_forall fun a => _
    simp_rw [mem_union, mem_preimage]
    by_contra! ha
    refine' s.ne_insert_of_not_mem _ ha.1 (h _ _ <| s.subset_insert _)
    rw [coe_insert]
    refine' hs.insert _ fun b hb hab => ha.2 <| (hs.isUpperSet' h) hab.le_compl_left hb
    rintro rfl
    have := h {‚ä§} (by rw [coe_singleton]; exact intersecting_singleton.2 top_ne_bot)
    rw [compl_bot] at ha
    rw [coe_eq_empty.1 ((hs.isUpperSet' h).not_top_mem.1 ha.2)] at this
    exact Finset.singleton_ne_empty _ (this <| Finset.empty_subset _).symm","error:  unknown identifier 'le_of_mul_le_mul_left'
error:  unknown identifier 'two_mul'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.14181
Œ± : Type u_1
inst‚úù¬≤ : BooleanAlgebra Œ±
inst‚úù¬π : Nontrivial Œ±
inst‚úù : Fintype Œ±
s : Finset Œ±
hs : (‚Üës).Intersecting
h : ‚àÄ (t : Finset Œ±), (‚Üët).Intersecting ‚Üí s ‚äÜ t ‚Üí s = t
this : s.disjUnion (map { toFun := compl, inj' := ‚ãØ } s) ‚ãØ = Finset.univ
‚ä¢ 2 * s.card = (s.disjUnion (map { toFun := compl, inj' := ‚ãØ } s) ‚ãØ).card","theorem Intersecting.is_max_iff_card_eq (hs : (s : Set Œ±).Intersecting) :
    (‚àÄ t : Finset Œ±, (t : Set Œ±).Intersecting ‚Üí s ‚äÜ t ‚Üí s = t) ‚Üî 2 * s.card = Fintype.card Œ± ",":= by
  classical
    refine ‚ü®fun h ‚Ü¶ ?_, fun h t ht hst ‚Ü¶ Finset.eq_of_subset_of_card_le hst <|
      Nat.le_of_mul_le_mul_left (ht.card_le.trans_eq h.symm) Nat.two_pos‚ü©
    suffices s.disjUnion (s.map ‚ü®compl, compl_injective‚ü©) hs.disjoint_map_compl = Finset.univ by
      rw [Fintype.card, ‚Üê this, Nat.two_mul, card_disjUnion, card_map]
    rw [‚Üê coe_eq_univ, disjUnion_eq_union, coe_union, coe_map, Function.Embedding.coeFn_mk,
      image_eq_preimage_of_inverse compl_compl compl_compl]
    refine eq_univ_of_forall fun a => ?_
    simp_rw [mem_union, mem_preimage]
    by_contra! ha
    refine s.ne_insert_of_not_mem _ ha.1 (h _ ?_ <| s.subset_insert _)
    rw [coe_insert]
    refine hs.insert ?_ fun b hb hab => ha.2 <| (hs.isUpperSet' h) hab.le_compl_left hb
    rintro rfl
    have := h {‚ä§} (by rw [coe_singleton]; exact intersecting_singleton.2 top_ne_bot)
    rw [compl_bot] at ha
    rw [coe_eq_empty.1 ((hs.isUpperSet' h).not_top_mem.1 ha.2)] at this
    exact Finset.singleton_ne_empty _ (this <| Finset.empty_subset _).symm",":= by
  classical
    refine
      ‚ü®fun h => ?_, fun h t ht hst =>
        Finset.eq_of_subset_of_card_le hst <|
          le_of_mul_le_mul_left (ht.card_le.trans_eq h.symm) two_pos‚ü©
    suffices s.disjUnion (s.map ‚ü®compl, compl_injective‚ü©) hs.disjoint_map_compl = Finset.univ by
      rw [Fintype.card, ‚Üê this, two_mul, card_disjUnion, card_map]
    rw [‚Üê coe_eq_univ, disjUnion_eq_union, coe_union, coe_map, Function.Embedding.coeFn_mk,
      image_eq_preimage_of_inverse compl_compl compl_compl]
    refine eq_univ_of_forall fun a => ?_
    simp_rw [mem_union, mem_preimage]
    by_contra! ha
    refine s.ne_insert_of_not_mem _ ha.1 (h _ _ <| s.subset_insert ?_)
    rw [coe_insert]
    refine hs.insert _ fun b hb hab => ha.2 <| (hs.isUpperSet' h) hab.le_compl_left hb
    rintro rfl
    have := h {‚ä§} (by rw [coe_singleton]; exact intersecting_singleton.2 top_ne_bot)
    rw [compl_bot] at ha
    rw [coe_eq_empty.1 ((hs.isUpperSet' h).not_top_mem.1 ha.2)] at this
    exact Finset.singleton_ne_empty _ (this <| Finset.empty_subset _).symm"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,9f377843ae74f8ea35a167e1fcc7752e1a90722a,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Module.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg ((¬∑ * ¬∑) œÅ) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Module.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_o"
Mathlib/Algebra/MvPolynomial/Equiv.lean,MvPolynomial.optionEquivLeft_X_some,optionEquivLeft_X_some,7962047919fd0329ddca78b1a70bd94a7b06f8ca,":= by
  simp only [optionEquivLeft_apply, aeval_X]","error:  unsolved goals
R : Type u
S‚ÇÅ : Type v
S‚ÇÇ : Type w
S‚ÇÉ : Type x
œÉ : Type u_1
a a' a‚ÇÅ a‚ÇÇ : R
e : ‚Ñï
s : œÉ ‚Üí‚ÇÄ ‚Ñï
inst‚úù : CommSemiring R
x : S‚ÇÅ
‚ä¢ ((Option.some x).elim Polynomial.X fun s ‚Ü¶ Polynomial.C (X s)) = Polynomial.C (X x)",lemma optionEquivLeft_X_some (x : S‚ÇÅ) : optionEquivLeft R S‚ÇÅ (X (some x)) = Polynomial.C (X x) ,":= by
  simp [optionEquivLeft_apply, aeval_X]",":= by
  simp only [optionEquivLeft_apply]"
Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean,SimpleGraph.ComponentCompl.exists_adj_boundary_pair,exists_adj_boundary_pair,2a87032320c8a6441a601ba5b37374ff532cf9b9,":= by
  refine' ComponentCompl.ind fun v vnK => _
  let C : G.ComponentCompl K := G.componentComplMk vnK
  let dis := Set.disjoint_iff.mp C.disjoint_right
  by_contra' h
  simp only [not_exists, not_and] at h
  suffices Set.univ = (C : Set V) by exact dis ‚ü®hK.choose_spec, this ‚ñ∏ Set.mem_univ hK.some‚ü©
  symm
  rw [Set.eq_univ_iff_forall]
  rintro u
  by_contra unC
  obtain ‚ü®p‚ü© := Gc v u
  obtain ‚ü®‚ü®‚ü®x, y‚ü©, xy‚ü©, -, xC, ynC‚ü© :=
    p.exists_boundary_dart (C : Set V) (G.componentComplMk_mem vnK) unC
  exact ynC (mem_of_adj x y xC (fun yK : y ‚àà K => h ‚ü®x, y‚ü© xC yK xy) xy)","error:  unknown tactic
error:  unsolved goals
V : Type u
G : SimpleGraph V
K L L' M : Set V
Gc : G.Preconnected
hK : K.Nonempty
v : V
vnK : v ‚àâ K
C : G.ComponentCompl K := G.componentComplMk vnK
dis : K ‚à© ‚ÜëC ‚äÜ ‚àÖ := Set.disjoint_iff.mp (ComponentCompl.disjoint_right C)
‚ä¢ ‚àÉ ck, ck.1 ‚àà G.componentComplMk vnK ‚àß ck.2 ‚àà K ‚àß G.Adj ck.1 ck.2","theorem exists_adj_boundary_pair (Gc : G.Preconnected) (hK : K.Nonempty) :
    ‚àÄ C : G.ComponentCompl K, ‚àÉ ck : V √ó V, ck.1 ‚àà C ‚àß ck.2 ‚àà K ‚àß G.Adj ck.1 ck.2 ",":= by
  refine ComponentCompl.ind fun v vnK => ?_
  let C : G.ComponentCompl K := G.componentComplMk vnK
  let dis := Set.disjoint_iff.mp C.disjoint_right
  by_contra! h
  suffices Set.univ = (C : Set V) by exact dis ‚ü®hK.choose_spec, this ‚ñ∏ Set.mem_univ hK.some‚ü©
  symm
  rw [Set.eq_univ_iff_forall]
  rintro u
  by_contra unC
  obtain ‚ü®p‚ü© := Gc v u
  obtain ‚ü®‚ü®‚ü®x, y‚ü©, xy‚ü©, -, xC, ynC‚ü© :=
    p.exists_boundary_dart (C : Set V) (G.componentComplMk_mem vnK) unC
  exact ynC (mem_of_adj x y xC (fun yK : y ‚àà K => h ‚ü®x, y‚ü© xC yK xy) xy)",":= by
  refine ComponentCompl.ind fun v vnK => ?_
  let C : G.ComponentCompl K := G.componentComplMk vnK
  let dis := Set.disjoint_iff.mp C.disjoint_right
  by_contra' h
  simp only [not_exists, not_and] at h
  suffices Set.univ = (C : Set V) by exact dis ‚ü®hK.choose_spec, this ‚ñ∏ Set.mem_univ hK.some‚ü©
  symm
  rw [Set.eq_univ_iff_forall]
  rintro u
  by_contra unC
  obtain ‚ü®p‚ü© := Gc v u
  obtain ‚ü®‚ü®‚ü®x, y‚ü©, xy‚ü©, -, xC, ynC‚ü© :=
    p.exists_boundary_dart (C : Set V) (G.componentComplMk_mem vnK) unC
  exact ynC (mem_of_adj x y xC (fun yK : y ‚àà K => h ‚ü®x, y‚ü© xC yK xy) xy)"
Mathlib/Analysis/SpecialFunctions/Stirling.lean,Stirling.stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq,stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq,01f5513fdd086f366aba4744806e9bf17676ce61,":= by
  have : 4 = 2 * 2 := by rfl
  rw [stirlingSeq, this, pow_mul, stirlingSeq, Wallis.W_eq_factorial_ratio]
  simp_rw [div_pow, mul_pow]
  rw [sq_sqrt, sq_sqrt]
  any_goals positivity
  have : exp 1 ‚â† 0 := exp_ne_zero 1
  have : ((2 * n)! : ‚Ñù) ‚â† 0 := cast_ne_zero.mpr (factorial_ne_zero (2 * n))
  have : 2 * (n : ‚Ñù) + 1 ‚â† 0 := by norm_cast; exact succ_ne_zero (2 * n)
  field_simp
  simp only [mul_pow, mul_comm 2 n, mul_comm 4 n, pow_mul]
  ring","error:  no goals to be solved
info:  Try this: ring_nf
error:  unsolved goals
n : ‚Ñï
hn : n ‚â† 0
this‚úù¬≤ : 4 = 2 * 2
this‚úù¬π : rexp 1 ‚â† 0
this‚úù : ‚Üë(2 * n)! ‚â† 0
this : 2 * ‚Üën + 1 ‚â† 0
‚ä¢ ‚Üën ! ^ 4 * rexp ‚Üën ^ 4 * ‚Üën ^ 2 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * 2 ^ (n * 4) * 4 +
      ‚Üën ! ^ 4 * rexp ‚Üën ^ 4 * ‚Üën ^ 3 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * 2 ^ (n * 4) * 8 =
    ‚Üën ! ^ 4 * ‚Üën ^ 2 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * rexp (‚Üën * 2) ^ 2 * 2 ^ (n * 4) * 4 +
      ‚Üën ! ^ 4 * ‚Üën ^ 3 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * rexp (‚Üën * 2) ^ 2 * 2 ^ (n * 4) * 8","theorem stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq (n : ‚Ñï) (hn : n ‚â† 0) :
    stirlingSeq n ^ 4 / stirlingSeq (2 * n) ^ 2 * (n / (2 * n + 1)) = Wallis.W n ",":= by
  have : 4 = 2 * 2 := by rfl
  rw [stirlingSeq, this, pow_mul, stirlingSeq, Wallis.W_eq_factorial_ratio]
  simp_rw [div_pow, mul_pow]
  rw [sq_sqrt, sq_sqrt]
  any_goals positivity
  field_simp [‚Üê exp_nsmul]
  ring_nf",":= by
  have : 4 = 2 * 2 := by rfl
  rw [stirlingSeq, this, pow_mul, stirlingSeq, Wallis.W_eq_factorial_ratio]
  simp_rw [div_pow, mul_pow]
  rw [sq_sqrt, sq_sqrt]
  any_goals positivity
  have : exp 1 ‚â† 0 := exp_ne_zero 1
  have : ((2 * n)! : ‚Ñù) ‚â† 0 := cast_ne_zero.mpr (factorial_ne_zero (2 * n))
  have : 2 * (n : ‚Ñù) + 1 ‚â† 0 := by norm_cast; exact succ_ne_zero (2 * n)
  field_simp
  simp only [mul_pow, mul_comm 2 n, mul_comm 4 n, pow_mul]"
Mathlib/MeasureTheory/Integral/CircleIntegral.lean,circleIntegral.integral_sub_zpow_of_ne,integral_sub_zpow_of_ne,c7bd9bd10c613e1788107ba753e252f069560f87,":= by
  rcases em (w ‚àà sphere c |R| ‚àß n < -1) with (‚ü®hw, hn‚ü© | H)
  ¬∑ exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : ‚àÄ z, z ‚â† w ‚à® -1 ‚â§ n ‚Üí
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    ¬∑ have hn' : (n + 1 : ‚ÑÇ) ‚â† 0 := by
        rwa [Ne, ‚Üê eq_neg_iff_add_eq_zero, ‚Üê Int.cast_one, ‚Üê Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_left _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine' integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z _).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h ‚ñ∏ hz","error:  application type mismatch
  mul_div_cancel_left ?m.192024 hn'
argument
  hn'
has type
  ‚Üën + 1 ‚â† 0 : Prop
but is expected to have type
  ?m.192022 : Type ?u.192021
error:  unsolved goals
case h.e'_7
E : Type u_1
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚ÑÇ E
inst‚úù : CompleteSpace E
n : ‚Ñ§
hn : n ‚â† -1
c w : ‚ÑÇ
R : ‚Ñù
H : w ‚àà sphere c |R| ‚Üí -1 ‚â§ n
z : ‚ÑÇ
hne : z ‚â† w ‚à® -1 ‚â§ n
hn' : ‚Üën + 1 ‚â† 0
‚ä¢ (z - w) ^ n = (‚Üën + 1) * (z - w) ^ n / (‚Üën + 1)","theorem integral_sub_zpow_of_ne {n : ‚Ñ§} (hn : n ‚â† -1) (c w : ‚ÑÇ) (R : ‚Ñù) :
    (‚àÆ z in C(c, R), (z - w) ^ n) = 0 ",":= by
  rcases em (w ‚àà sphere c |R| ‚àß n < -1) with (‚ü®hw, hn‚ü© | H)
  ¬∑ exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : ‚àÄ z, z ‚â† w ‚à® -1 ‚â§ n ‚Üí
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    ¬∑ have hn' : (n + 1 : ‚ÑÇ) ‚â† 0 := by
        rwa [Ne, ‚Üê eq_neg_iff_add_eq_zero, ‚Üê Int.cast_one, ‚Üê Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_left‚ÇÄ _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z ?_).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h ‚ñ∏ hz",":= by
  rcases em (w ‚àà sphere c |R| ‚àß n < -1) with (‚ü®hw, hn‚ü© | H)
  ¬∑ exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : ‚àÄ z, z ‚â† w ‚à® -1 ‚â§ n ‚Üí
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    ¬∑ have hn' : (n + 1 : ‚ÑÇ) ‚â† 0 := by
        rwa [Ne, ‚Üê eq_neg_iff_add_eq_zero, ‚Üê Int.cast_one, ‚Üê Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_left _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z ?_).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h ‚ñ∏ hz"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.le_mul_withDensity,le_mul_withDensity,9d3887769246754772c178dd6c594378dce58448,":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine' le_trans (measure_mono (inter_subset_right _ _)) (le_trans (le_of_eq _) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono (inter_subset_right _ _)).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ŒΩ, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
          ‚àë' n : ‚Ñ§, (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = (t ‚Ä¢ ŒΩ) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t ‚Ä¢ ŒΩ) f_meas hs ht).symm","error:  function expected at
  inter_subset_right ?m.233065
term has type
  ?m.233064 ‚àà ?m.233063
error:  type mismatch
  measure_limRatioMeas_zero v hœÅ
has type
  œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 : Prop
but is expected to have type
  Set Œ± : Type u_1
error:  function expected at
  inter_subset_right ?m.235353
term has type
  ?m.235352 ‚àà ?m.235351","theorem le_mul_withDensity {s : Set Œ±} (hs : MeasurableSet s) {t : ‚Ñù‚â•0} (ht : 1 < t) :
    œÅ s ‚â§ t * Œº.withDensity (v.limRatioMeas hœÅ) s ",":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ŒΩ, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
          ‚àë' n : ‚Ñ§, (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = (t ‚Ä¢ ŒΩ) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t ‚Ä¢ ŒΩ) f_meas hs ht).symm",":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ŒΩ, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {0}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ "
Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean,MeasureTheory.Measure.rnDeriv_add_right_of_mutuallySingular',rnDeriv_add_right_of_mutuallySingular',54daa04dd4fe92d1b3b2a82be4c246b43c601cab,":= by
  have h_ac : ŒΩ ‚â™ ŒΩ + ŒΩ' := Measure.AbsolutelyContinuous.rfl.add_right _
  rw [haveLebesgueDecomposition_add Œº ŒΩ]
  have h‚ÇÅ := rnDeriv_add' (Œº.singularPart ŒΩ) (ŒΩ.withDensity (Œº.rnDeriv ŒΩ)) (ŒΩ + ŒΩ')
  have h‚ÇÇ := rnDeriv_add' (Œº.singularPart ŒΩ) (ŒΩ.withDensity (Œº.rnDeriv ŒΩ)) ŒΩ
  refine (Filter.EventuallyEq.trans (h_ac.ae_le h‚ÇÅ) ?_).trans h‚ÇÇ.symm
  simp only [Pi.add_apply]
  have h‚ÇÉ := rnDeriv_add_right_of_absolutelyContinuous_of_mutuallySingular
    (withDensity_absolutelyContinuous ŒΩ (Œº.rnDeriv ŒΩ)) hŒΩŒΩ'
  have h‚ÇÑ : (Œº.singularPart ŒΩ).rnDeriv (ŒΩ + ŒΩ') =·µê[ŒΩ] 0 := by
    refine h_ac.ae_eq ?_
    simp only [rnDeriv_eq_zero, MutuallySingular.add_right_iff]
    exact ‚ü®mutuallySingular_singularPart Œº ŒΩ, hŒºŒΩ'.singularPart ŒΩ‚ü©
  have h‚ÇÖ : (Œº.singularPart ŒΩ).rnDeriv ŒΩ =·µê[ŒΩ] 0 := rnDeriv_singularPart Œº ŒΩ
  filter_upwards [h‚ÇÉ, h‚ÇÑ, h‚ÇÖ] with x hx‚ÇÉ hx‚ÇÑ hx‚ÇÖ
  rw [hx‚ÇÉ, hx‚ÇÑ, Pi.add_apply, hx‚ÇÖ]",error:  simp made no progress,"lemma rnDeriv_add_right_of_mutuallySingular' {ŒΩ' : Measure Œ±}
    [SigmaFinite Œº] [SigmaFinite ŒΩ] [SigmaFinite ŒΩ']
    (hŒºŒΩ' : Œº ‚üÇ‚Çò ŒΩ') (hŒΩŒΩ' : ŒΩ ‚üÇ‚Çò ŒΩ') :
    Œº.rnDeriv (ŒΩ + ŒΩ') =·µê[ŒΩ] Œº.rnDeriv ŒΩ ",":= by
  have h_ac : ŒΩ ‚â™ ŒΩ + ŒΩ' := Measure.AbsolutelyContinuous.rfl.add_right _
  rw [haveLebesgueDecomposition_add Œº ŒΩ]
  have h‚ÇÅ := rnDeriv_add' (Œº.singularPart ŒΩ) (ŒΩ.withDensity (Œº.rnDeriv ŒΩ)) (ŒΩ + ŒΩ')
  have h‚ÇÇ := rnDeriv_add' (Œº.singularPart ŒΩ) (ŒΩ.withDensity (Œº.rnDeriv ŒΩ)) ŒΩ
  refine (Filter.EventuallyEq.trans (h_ac.ae_le h‚ÇÅ) ?_).trans h‚ÇÇ.symm
  have h‚ÇÉ := rnDeriv_add_right_of_absolutelyContinuous_of_mutuallySingular
    (withDensity_absolutelyContinuous ŒΩ (Œº.rnDeriv ŒΩ)) hŒΩŒΩ'
  have h‚ÇÑ : (Œº.singularPart ŒΩ).rnDeriv (ŒΩ + ŒΩ') =·µê[ŒΩ] 0 := by
    refine h_ac.ae_eq ?_
    simp only [rnDeriv_eq_zero, MutuallySingular.add_right_iff]
    exact ‚ü®mutuallySingular_singularPart Œº ŒΩ, hŒºŒΩ'.singularPart ŒΩ‚ü©
  have h‚ÇÖ : (Œº.singularPart ŒΩ).rnDeriv ŒΩ =·µê[ŒΩ] 0 := rnDeriv_singularPart Œº ŒΩ
  filter_upwards [h‚ÇÉ, h‚ÇÑ, h‚ÇÖ] with x hx‚ÇÉ hx‚ÇÑ hx‚ÇÖ
  simp only [Pi.add_apply]
  rw [hx‚ÇÉ, hx‚ÇÑ, hx‚ÇÖ]",":= by
  have h_ac : ŒΩ ‚â™ ŒΩ + ŒΩ' := Measure.AbsolutelyContinuous.rfl.add_right
  rw [haveLebesgueDecomposition_add Œº ŒΩ]
  have h‚ÇÅ := rnDeriv_add' (Œº.singularPart ŒΩ) (ŒΩ.withDensity (Œº.rnDeriv ŒΩ)) (ŒΩ + ŒΩ')
  have h‚ÇÇ := rnDeriv_add' (Œº.singularPart ŒΩ) (ŒΩ.withDensity (Œº.rnDeriv ŒΩ)) ŒΩ
  refine (Filter.EventuallyEq.trans (h_ac.ae_le h‚ÇÅ) ?_).trans h‚ÇÇ.symm
  simp only [Pi.add_apply]
  have h‚ÇÉ := rnDeriv_add_right_of_absolutelyContinuous_of_mutuallySingular
    (withDensity_absolutelyContinuous ŒΩ (Œº.rnDeriv ŒΩ)) hŒΩŒΩ'
  have h‚ÇÑ : (Œº.singularPart ŒΩ).rnDeriv (ŒΩ + ŒΩ') =·µê[ŒΩ] 0 := by
    refine h_ac.ae_eq ?_
    simp only [rnDeriv_eq_zero, MutuallySingular.add_right_iff]
    exact ‚ü®mutuallySingular_singularPart Œº ŒΩ, hŒºŒΩ'.singularPart ŒΩ‚ü©
  have h‚ÇÖ : (Œº.singularPart ŒΩ).rnDeriv ŒΩ =·µê[ŒΩ] 0 := rnDeriv_singularPart Œº ŒΩ
  filter_upwards [h‚ÇÉ, h‚ÇÑ, h‚ÇÖ] with x hx‚ÇÉ hx‚ÇÑ hx‚ÇÖ
  rw [hx‚ÇÉ, hx‚ÇÑ, Pi.add_apply, hx‚ÇÖ]"
Mathlib/Order/OrderIsoNat.lean,RelEmbedding.acc_iff_no_decreasing_seq,acc_iff_no_decreasing_seq,5e49fb503ed959b024486b3ac7f5eeb33d1691d9,":= by
  constructor
  ¬∑ refine' fun h => h.recOn fun x _ IH => _
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 :=
      by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    obtain ‚ü®f, h‚ü© := Classical.axiom_of_choice this
    refine' fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => ((f^[n]) ‚ü®x, hx‚ü©).1) fun n => _, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h","error:  unknown identifier 'lt_add_one'
error:  unknown identifier 'Classical.axiom_of_choice'
error:  rcases tactic failed: x‚úù : ?m.2248 is not an inductive datatype","theorem acc_iff_no_decreasing_seq {x} :
    Acc r x ‚Üî IsEmpty { f : ((¬∑ > ¬∑) : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop) ‚Ü™r r // x ‚àà Set.range f } ",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (Nat.lt_succ_self _))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    choose f h using this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, ?_, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 :=
      by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    obtain ‚ü®f, h‚ü© := Classical.axiom_of_choice this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => ((f^[n]) ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h"
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine' ‚ü®U, {j}, _, _‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa
    ¬∑ simp
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine' ‚ü®j, V, _, _‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine' this _ _ _ (univ _) (inter _) _
      intro e he
      dsimp
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      rw [‚Üê coe_comp, D.w]
      rfl","error:  unknown identifier 'isTopologicalBasis_iInf'
error:  no goals to be solved","theorem isTopologicalBasis_cofiltered_limit (T : ‚àÄ j, Set (Set (F.obj j)))
    (hT : ‚àÄ j, IsTopologicalBasis (T j)) (univ : ‚àÄ i : J, Set.univ ‚àà T i)
    (inter : ‚àÄ (i) (U1 U2 : Set (F.obj i)), U1 ‚àà T i ‚Üí U2 ‚àà T i ‚Üí U1 ‚à© U2 ‚àà T i)
    (compat : ‚àÄ (i j : J) (f : i ‚ü∂ j) (V : Set (F.obj j)) (_hV : V ‚àà T j), F.map f ‚Åª¬π' V ‚àà T i) :
    IsTopologicalBasis
      {U : Set C.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = C.œÄ.app j ‚Åª¬π' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [‚Üê coe_comp, D.w] 
      rfl",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa
    ¬∑ simp
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
      dsimp
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he"
Mathlib/Geometry/Manifold/IntegralCurve.lean,IsIntegralCurve.isIntegralCurveAt,IsIntegralCurve.isIntegralCurveAt,7d7a7169c0c35b35c150a198dd8eaa2a47578e1d,":= ‚ü®univ, Filter.univ_mem, fun t _ ‚Ü¶ h t‚ü©","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  (ùìù t).1 {x | (fun t ‚Ü¶ HasMFDerivAt ùìò(‚Ñù, ‚Ñù) I Œ≥ t (ContinuousLinearMap.smulRight 1 (v (Œ≥ t)))) x}","lemma IsIntegralCurve.isIntegralCurveAt (h : IsIntegralCurve Œ≥ v) (t : ‚Ñù) :
    IsIntegralCurveAt Œ≥ v t ",":= isIntegralCurveAt_iff.mpr ‚ü®univ, Filter.univ_mem, fun t _ ‚Ü¶ h t‚ü©",":= ‚ü®univ, Filter.univ_mem‚ü©"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.mapRange_zero,mapRange_zero,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.mapRange_zero (fun _ => f) (fun _ => hf)","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.mapRange_zero'",theorem mapRange_zero {f : M ‚Üí N} {hf : f 0 = 0} : mapRange f hf (0 : Œ± ‚Üí‚ÇÄ M) = 0 ,":=
  ext fun _ => by simp only [hf, zero_apply, mapRange_apply]",":=
  mapRange_zero (fun _ => f) (fun _ => hf)"
Mathlib/CategoryTheory/Abelian/Pseudoelements.lean,CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono,pseudo_injective_of_mono,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  intro abar abar'
  refine Quotient.inductionOn‚ÇÇ abar abar' fun a a' ha => ?_
  apply Quotient.sound
  have : ‚ü¶(a.hom ‚â´ f : Over Q)‚üß = ‚ü¶‚Üë(a'.hom ‚â´ f)‚üß := by convert ha
  have ‚ü®R, p, q, ep, Eq, comm‚ü© := Quotient.exact this
  exact ‚ü®R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact comm‚ü©","error:  don't know how to synthesize implicit argument 'Œ±'
  @Eq (Quotient ?m.42591) ‚ü¶Over.mk (a.hom ‚â´ f)‚üß ‚ü¶Over.mk (a'.hom ‚â´ f)‚üß
context:
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ Type (max u v)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ Setoid (Over Q)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ Setoid (Over Q)
error:  unsolved goals
case a
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ a ‚âà a'",theorem pseudo_injective_of_mono {P Q : C} (f : P ‚ü∂ Q) [Mono f] : Function.Injective f ,":= by
  intro abar abar'
  refine Quotient.inductionOn‚ÇÇ abar abar' fun a a' ha => ?_
  apply Quotient.sound
  have : (‚ü¶(a.hom ‚â´ f : Over Q)‚üß : Quotient (setoid Q)) = ‚ü¶‚Üë(a'.hom ‚â´ f)‚üß := by convert ha
  have ‚ü®R, p, q, ep, Eq, comm‚ü© := Quotient.exact this
  exact ‚ü®R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact comm‚ü©",":= by
  intro abar abar'
  refine Quotient.inductionOn‚ÇÇ abar abar' fun a a' ha => ?_
  apply Quotient.exact this
  exact ‚ü®R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact comm‚ü©"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.Triangle.coyoneda_exact‚ÇÉ,coyoneda_exact‚ÇÉ,8535b08ef59bcdb8a9d09a473f4b6c583f54aef0,":=
  coyoneda_exact‚ÇÇ _ (rot_of_dist_triangle _ hT) f hf","error:  unknown identifier 'rot_of_dist_triangle'
error:  application type mismatch
  Triangle.coyoneda_exact‚ÇÉ ?m.146724 hT
argument
  hT
has type
  T ‚àà distinguishedTriangles : Prop
but is expected to have type
  ?m.146725 ‚ü∂ ?m.146724.obj‚ÇÉ : Type ?u.146719
error:  rcases tactic failed: x‚úù : ?m.151066 is not an inductive datatype
error:  application type mismatch
  Triangle.coyoneda_exact‚ÇÉ ?m.162326 mem
argument
  mem
has type
  Triangle.mk inl snd 0 ‚àà distinguishedTriangles : Prop
but is expected to have type
  ?m.162327 ‚ü∂ ?m.162326.obj‚ÇÉ : Type ?u.162321
error:  rcases tactic failed: x‚úù : ?m.166729 is not an inductive datatype
error:  application type mismatch
  Triangle.coyoneda_exact‚ÇÉ T' hT'
argument
  hT'
has type
  T' ‚àà distinguishedTriangles : Prop
but is expected to have type
  ?m.199748 ‚ü∂ T'.obj‚ÇÉ : Type v
error:  rcases tactic failed: x‚úù : ?m.200681 is not an inductive datatype
error:  application type mismatch
  Triangle.coyoneda_exact‚ÇÉ (T j) (hT j)
argument
  hT j
has type
  T j ‚àà distinguishedTriangles : Prop
but is expected to have type
  ?m.207166 ‚ü∂ (T j).obj‚ÇÉ : Type v","lemma coyoneda_exact‚ÇÉ {X : C} (f : X ‚ü∂ T.obj‚ÇÉ) (hf : f ‚â´ T.mor‚ÇÉ = 0) :
    ‚àÉ (g : X ‚ü∂ T.obj‚ÇÇ), f = g ‚â´ T.mor‚ÇÇ ",":=
  coyoneda_exact‚ÇÇ _ (rot_of_distTriang _ hT) f hf",":=
  coyoneda_exact‚ÇÇ _ (rot_of_distTriang hT) f hf"
Mathlib/MeasureTheory/Function/ContinuousMapDense.lean,MeasureTheory.Mem‚Ñíp.exists_hasCompactSupport_integral_rpow_sub_le,Mem‚Ñíp.exists_hasCompactSupport_integral_rpow_sub_le,611a64b31f2f9df551954217d12578133430d2b6,":= by
  have I : 0 < Œµ ^ (1 / p) := Real.rpow_pos_of_pos hŒµ _
  have A : ENNReal.ofReal (Œµ ^ (1 / p)) ‚â† 0 := by
    simp only [Ne.def, ENNReal.ofReal_eq_zero, not_le, I]
  have B : ENNReal.ofReal p ‚â† 0 := by simpa only [Ne.def, ENNReal.ofReal_eq_zero, not_le] using hp
  rcases hf.exists_hasCompactSupport_snorm_sub_le ENNReal.coe_ne_top A with
    ‚ü®g, g_support, hg, g_cont, g_mem‚ü©
  change snorm _ (ENNReal.ofReal p) _ ‚â§ _ at hg
  refine' ‚ü®g, g_support, _, g_cont, g_mem‚ü©
  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,
    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,
    Real.rpow_le_rpow_iff _ hŒµ.le (inv_pos.2 hp)] at hg
  positivity","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.36991 ‚Üí ?m.36991 ‚Üí Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.37136 ‚Üí ?m.37136 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  0 < p : Prop
but is expected to have type
  ENNReal.ofReal p ‚â† 0 : Prop","theorem Mem‚Ñíp.exists_hasCompactSupport_integral_rpow_sub_le
    [WeaklyLocallyCompactSpace Œ±] [Œº.Regular]
    {p : ‚Ñù} (hp : 0 < p) {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f (ENNReal.ofReal p) Œº) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :
    ‚àÉ g : Œ± ‚Üí E,
      HasCompactSupport g ‚àß
        (‚à´ x, ‚Äñf x - g x‚Äñ ^ p ‚àÇŒº) ‚â§ Œµ ‚àß Continuous g ‚àß Mem‚Ñíp g (ENNReal.ofReal p) Œº ",":= by
  have I : 0 < Œµ ^ (1 / p) := Real.rpow_pos_of_pos hŒµ _
  have A : ENNReal.ofReal (Œµ ^ (1 / p)) ‚â† 0 := by
    simp only [Ne, ENNReal.ofReal_eq_zero, not_le, I]
  have B : ENNReal.ofReal p ‚â† 0 := by simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hp
  rcases hf.exists_hasCompactSupport_snorm_sub_le ENNReal.coe_ne_top A with
    ‚ü®g, g_support, hg, g_cont, g_mem‚ü©
  change snorm _ (ENNReal.ofReal p) _ ‚â§ _ at hg
  refine ‚ü®g, g_support, ?_, g_cont, g_mem‚ü©
  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,
    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,
    Real.rpow_le_rpow_iff _ hŒµ.le (inv_pos.2 hp)] at hg
  positivity",":= by
  have I : 0 < Œµ ^ (1 / p) := Real.rpow_pos_of_pos hŒµ _
  have A : ENNReal.ofReal (Œµ ^ (1 / p)) ‚â† 0 := by
    simp only [Ne, ENNReal.ofReal_eq_zero, not_le, I]
  have B : ENNReal.ofReal p ‚â† 0 := by simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hp
  rcases hf.exists_hasCompactSupport_snorm_sub_le ENNReal.coe_ne_top A with
    ‚ü®g, g_support, hg, g_cont, g_mem‚ü©
  change snorm _ (ENNReal.ofReal p) _ ‚â§ _ at hg
  refine ‚ü®g, g_support, ?_, g_cont, g_mem‚ü©
  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,
    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,
    Real.rpow_le_rpow_iff _ hŒµ.le inv_pos.2 hp)] at hg
  positivity"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,65f7857d510e130142dbb111786341d695ac399b,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",error:  simp made no progress,"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto"
Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean,FiniteField.isSquare_odd_prime_iff,FiniteField.isSquare_odd_prime_iff,0829989fb05c0f3d0ef2ff405811515ae4ea6aa2,":= by
  classical
  by_cases hFp : ringChar F = p
  ¬∑ rw [show (p : F) = 0 by rw [‚Üê hFp]; exact ringChar.Nat.cast_ringChar]
    simp only [isSquare_zero, Ne.def, true_iff_iff, map_mul]
    obtain ‚ü®n, _, hc‚ü© := FiniteField.card F (ringChar F)
    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm
    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]
    simp only [zero_pow n.ne_zero, mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]
  ¬∑ rw [‚Üê Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),
      quadraticChar_odd_prime hF hp]
    exact hFp","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.37884 ‚Üí ?m.37884 ‚Üí Prop
error:  cannot select argument","theorem FiniteField.isSquare_odd_prime_iff (hF : ringChar F ‚â† 2) {p : ‚Ñï} [Fact p.Prime]
    (hp : p ‚â† 2) :
    IsSquare (p : F) ‚Üî quadraticChar (ZMod p) (œá‚ÇÑ (Fintype.card F) * Fintype.card F) ‚â† -1 ",":= by
  classical
  by_cases hFp : ringChar F = p
  ¬∑ rw [show (p : F) = 0 by rw [‚Üê hFp]; exact ringChar.Nat.cast_ringChar]
    simp only [isSquare_zero, Ne, true_iff_iff, map_mul]
    obtain ‚ü®n, _, hc‚ü© := FiniteField.card F (ringChar F)
    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm
    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]
    simp only [zero_pow n.ne_zero, mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]
  ¬∑ rw [‚Üê Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),
      quadraticChar_odd_prime hF hp]
    exact hFp",":= by
  classical
  by_cases hFp : ringChar F = p
  ¬∑ rw [show (p : F) = 0 by rw [‚Üê hFp]; exact ringChar.Nat.cast_ringChar]
    simp only [isSquare_zero, Ne, true_iff_iff, map_mul]
    obtain ‚ü®n, _, hc‚ü© := FiniteField.card F (ringChar F)
    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm
    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]
    simp only [zero_pow n.ne_zero, mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]
  ¬∑ rw [‚Üê Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),
      quadraticChar_odd_prime hF hp]
    exact hFp"
Mathlib/Order/SupClosed.lean,infClosed_iInter,infClosed_iInter,a380f5a603bf5030bc30e58b1aed19567f67b98d,:=,error:  unexpected token 'lemma'; expected term,"lemma infClosed_iInter (hf : ‚àÄ i, InfClosed (f i)) : InfClosed (‚ãÇ i, f i) ",":=
  infClosed_sInter <| forall_mem_range.2 hf",":=
  infClosed_iInter hf"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.Triangle.mor‚ÇÅ_eq_zero_iff_mono‚ÇÇ,mor‚ÇÅ_eq_zero_iff_mono‚ÇÇ,8535b08ef59bcdb8a9d09a473f4b6c583f54aef0,":= by
  constructor
  ¬∑ intro h
    rw [mono_iff_cancel_zero]
    intro X g hg
    obtain ‚ü®f, rfl‚ü© := coyoneda_exact‚ÇÇ T hT g hg
    rw [h, comp_zero]
  ¬∑ intro
    rw [‚Üê cancel_mono T.mor‚ÇÇ, comp_dist_triangle_mor_zero‚ÇÅ‚ÇÇ _ hT, zero_comp]","error:  unknown identifier 'comp_dist_triangle_mor_zero‚ÇÅ‚ÇÇ'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.95452
case mpr
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (CategoryTheory.shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T ‚àà distinguishedTriangles
a‚úù : Mono T.mor‚ÇÇ
‚ä¢ T.mor‚ÇÅ ‚â´ T.mor‚ÇÇ = 0 ‚â´ T.mor‚ÇÇ",lemma mor‚ÇÅ_eq_zero_iff_mono‚ÇÇ : T.mor‚ÇÅ = 0 ‚Üî Mono T.mor‚ÇÇ ,":= by
  constructor
  ¬∑ intro h
    rw [mono_iff_cancel_zero]
    intro X g hg
    obtain ‚ü®f, rfl‚ü© := coyoneda_exact‚ÇÇ T hT g hg
    rw [h, comp_zero]
  ¬∑ intro
    rw [‚Üê cancel_mono T.mor‚ÇÇ, comp_distTriang_mor_zero‚ÇÅ‚ÇÇ _ hT, zero_comp]",":= by
  constructor
  ¬∑ intro h
    rw [mono_iff_cancel_zero]
    intro X g hg
    obtain ‚ü®f, rfl‚ü© := coyoneda_exact‚ÇÇ T hT g hg
    rw [h, comp_zero]
  ¬∑ intro
    rw [‚Üê cancel_mono T.mor‚ÇÇ, comp_distTriang_mor_zero‚ÇÅ‚ÇÇ _ hT, zero_comp]"
Mathlib/Algebra/BigOperators/Associated.lean,Multiset.prod_primes_dvd,Multiset.prod_primes_dvd,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  induction' s with a s induct n primes divs generalizing n
  ¬∑ simp only [Multiset.prod_zero, one_dvd]
  ¬∑ rw [Multiset.prod_cons]
    obtain ‚ü®k, rfl‚ü© : a ‚à£ n := div a (Multiset.mem_cons_self a s)
    apply mul_dvd_mul_left a
    refine induct _ (fun a ha => h a (Multiset.mem_cons_of_mem ha)) (fun b b_in_s => ?_)
      fun a => (Multiset.countP_le_of_le _ (Multiset.le_cons_self _ _)).trans (uniq a)
    have b_div_n := div b (Multiset.mem_cons_of_mem b_in_s)
    have a_prime := h a (Multiset.mem_cons_self a s)
    have b_prime := h b (Multiset.mem_cons_of_mem b_in_s)
    refine (b_prime.dvd_or_dvd b_div_n).resolve_left fun b_div_a => ?_
    have assoc := b_prime.associated_of_dvd a_prime b_div_a
    have := uniq a
    rw [Multiset.countP_cons_of_pos _ (Associated.refl _), Nat.succ_le_succ_iff, ‚Üê not_lt,
      Multiset.countP_pos] at this
    exact this ‚ü®b, b_in_s, assoc.symm‚ü©","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œ¥ : Type u_4
inst‚úù¬π : CancelCommMonoidWithZero Œ±
inst‚úù : (a : Œ±) ‚Üí DecidablePred (Associated a)
s : Multiset Œ±
n : Œ±
h : ‚àÄ a ‚àà s, Prime a
div : ‚àÄ a ‚àà s, a ‚à£ n
uniq : ‚àÄ (a : Œ±), countP (Associated a) s ‚â§ 1
‚ä¢ s.prod ‚à£ n","theorem Multiset.prod_primes_dvd [CancelCommMonoidWithZero Œ±]
    [‚àÄ a : Œ±, DecidablePred (Associated a)] {s : Multiset Œ±} (n : Œ±) (h : ‚àÄ a ‚àà s, Prime a)
    (div : ‚àÄ a ‚àà s, a ‚à£ n) (uniq : ‚àÄ a, s.countP (Associated a) ‚â§ 1) : s.prod ‚à£ n ",":= by
  induction' s using Multiset.induction_on with a s induct n primes divs generalizing n
  ¬∑ simp only [Multiset.prod_zero, one_dvd]
  ¬∑ rw [Multiset.prod_cons]
    obtain ‚ü®k, rfl‚ü© : a ‚à£ n := div a (Multiset.mem_cons_self a s)
    apply mul_dvd_mul_left a
    refine induct _ (fun a ha => h a (Multiset.mem_cons_of_mem ha)) (fun b b_in_s => ?_)
      fun a => (Multiset.countP_le_of_le _ (Multiset.le_cons_self _ _)).trans (uniq a)
    have b_div_n := div b (Multiset.mem_cons_of_mem b_in_s)
    have a_prime := h a (Multiset.mem_cons_self a s)
    have b_prime := h b (Multiset.mem_cons_of_mem b_in_s)
    refine (b_prime.dvd_or_dvd b_div_n).resolve_left fun b_div_a => ?_
    have assoc := b_prime.associated_of_dvd a_prime b_div_a
    have := uniq a
    rw [Multiset.countP_cons_of_pos _ (Associated.refl _), Nat.succ_le_succ_iff, ‚Üê not_lt,
      Multiset.countP_pos] at this
    exact this ‚ü®b, b_in_s, assoc.symm‚ü©",":= by
  induction' s using Multiset.induction_on with a s induct n primes divs generalizing n
  ¬∑ simp only [Multiset.prod_zero, one_dvd]
  ¬∑ rw [Multiset.prod_cons]
    obtain ‚ü®k, rfl‚ü© : a ‚à£ n := div a (Multiset.mem_cons_self a s)
    apply mul_dvd_mul_left a
    refine induct _ (fun a ha => h a (Multiset.mem_cons_of_mem ha)) (fun b b_in_s => ?_)
      fun a => (Multiset.countP_le_of_le _ (Multiset.le_cons_self _ _)).trans (uniq a)
    have b_div_n := div b (Multiset.mem_cons_of_mem b_in_s)
    have a_prime := h a (Multiset.mem_cons_of_mem b_in_s)
    refine (b_prime.dvd_or_dvd b_div_n).resolve_left fun b_div_a => ?_
    have assoc := b_prime.associated_of_dvd a_prime b_div_a
    have := uniq a
    rw [Multiset.countP_cons_of_pos _ (Associated.refl _), Nat.succ_le_succ_iff, ‚Üê not_lt,
      Multiset.countP_pos] at this
    exact this ‚ü®b, b_in_s, assoc.symm‚ü©"
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.prec_prim,prec_prim,6085d5e27552de2d43997b4a52a8d9fcd4686071,":=
  Primrec.ofNat_iff‚ÇÇ.2 <| Primrec.encode_iff.1 <| nat_add.comp‚ÇÇ
    (nat_double_succ.comp <| nat_double.comp <| Primrec.natPair.comp‚ÇÇ
        (encode_iff.2 <| (Primrec.ofNat Code).comp fst)
        (encode_iff.2 <| (Primrec.ofNat Code).comp snd))
    (.const 4)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Primrec
has type
  (?m.128124 ‚Üí ?m.128125) ‚Üí Prop",theorem prec_prim : Primrec‚ÇÇ prec ,":=
  Primrec‚ÇÇ.ofNat_iff.2 <|
    Primrec‚ÇÇ.encode_iff.1 <|
      nat_add.comp
        (nat_double_succ.comp <|
          nat_double.comp <|
            Primrec‚ÇÇ.natPair.comp (encode_iff.2 <| (Primrec.ofNat Code).comp fst)
              (encode_iff.2 <| (Primrec.ofNat Code).comp snd))
        (Primrec‚ÇÇ.const 4)",":=
  Primrec.ofNat_iff‚ÇÇ.2 <| Primrec.encode_iff.1 <| nat_add.comp‚ÇÇ
    (nat_double_succ.comp <| nat_double.comp <| Primrec.natPair.comp‚ÇÇ
        (encode_iff.2 <| (Primrec.ofNat Code).comp fst)
        (encode_iff.2 <| (Primrec.ofNat Code).comp snd))
    (.const 4)"
Mathlib/Algebra/Lie/Weights/Basic.lean,LieModule.disjoint_weightSpaceOf,disjoint_weightSpaceOf,61e05975727e0b1a19d0075b994c53596adb3405,":= by
  rw [LieSubmodule.disjoint_iff_coe_toSubmodule]
  exact Module.End.disjoint_iSup_generalizedEigenspace _ h",error:  unknown constant 'Module.End.disjoint_iSup_generalizedEigenspace',"lemma disjoint_weightSpaceOf [NoZeroSMulDivisors R M] {x : L} {œÜ‚ÇÅ œÜ‚ÇÇ : R} (h : œÜ‚ÇÅ ‚â† œÜ‚ÇÇ) :
    Disjoint (weightSpaceOf M œÜ‚ÇÅ x) (weightSpaceOf M œÜ‚ÇÇ x) ",":= by
  rw [LieSubmodule.disjoint_iff_coe_toSubmodule]
  exact Module.End.disjoint_iSup_genEigenspace _ h",":= by
  rw [LieSubmodule.disjoint_iff_coe_toSubmodule]
  exact Module.End.disjoint_iSup_genEigenspace _ h"
Mathlib/Algebra/BigOperators/Finprod.lean,finprod_mem_finset_product,finprod_mem_finset_product,82ddb54f6cb64f727e412a60ecaa99a9dafaec2a,":= by
  have :
    ‚àÄ a,
      (‚àè i : Œ≤ in (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i)) =
        (Finset.filter (fun ab => Prod.fst ab = a) s).prod f := by
    refine' fun a => Finset.prod_bij (fun b _ => (a, b)) _ _ _ _ <;> simp
    suffices ‚àÄ a' b, (a', b) ‚àà s ‚Üí a' = a ‚Üí (a, b) ‚àà s ‚àß a' = a by simpa
    rintro a' b hp rfl
    exact ‚ü®hp, rfl‚ü©
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ‚Üê Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image]
  exact fun x hx => ‚ü®x, hx, rfl‚ü©","error:  tactic 'assumption' failed
Œ± : Type u_1
Œ≤ : Type u_2
Œπ : Type u_3
G : Type u_4
M : Type u_5
N : Type u_6
inst‚úù¬≥ : CommMonoid M
inst‚úù¬≤ : CommMonoid N
f‚úù g : Œ± ‚Üí M
a‚úù b : Œ±
s‚úù t : Set Œ±
inst‚úù¬π : DecidableEq Œ±
inst‚úù : DecidableEq Œ≤
s : Finset (Œ± √ó Œ≤)
f : Œ± √ó Œ≤ ‚Üí M
a : Œ±
this : ‚àÄ (a' : Œ±) (b : Œ≤), (a', b) ‚àà s ‚Üí a' = a ‚Üí (a, b) ‚àà s ‚àß a' = a
‚ä¢ ‚àÄ (a_1 : Œ±) (b : Œ≤), (a_1, b) ‚àà s ‚Üí a_1 = a ‚Üí (a, b) ‚àà s ‚àß a = a_1","theorem finprod_mem_finset_product' [DecidableEq Œ±] [DecidableEq Œ≤] (s : Finset (Œ± √ó Œ≤))
    (f : Œ± √ó Œ≤ ‚Üí M) :
    (‚àè·∂† (ab) (_ : ab ‚àà s), f ab) =
      ‚àè·∂† (a) (b) (_ : b ‚àà (s.filter fun ab => Prod.fst ab = a).image Prod.snd), f (a, b) ",":= by
  have (a) :
      ‚àè i ‚àà (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i) =
        (s.filter (Prod.fst ¬∑ = a)).prod f := by
    refine Finset.prod_nbij' (fun b ‚Ü¶ (a, b)) Prod.snd ?_ ?_ ?_ ?_ ?_ <;> aesop
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ‚Üê Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image]
  exact fun x hx => ‚ü®x, hx, rfl‚ü©",":= by
  have :
    ‚àÄ a,
      (‚àè i : Œ≤ in (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i)) =
        (Finset.filter (fun ab => Prod.fst ab = a) s).prod f := by
    refine fun a => Finset.prod_bij (fun b _ => (a, b)) ?_ ?_ ?_ <;> simp
    suffices ‚àÄ a' b, (a', b) ‚àà s ‚Üí a' = a ‚Üí (a, b) ‚àà s ‚àß a' = a by simpa
    rintro a' b hp rfl
    exact ‚ü®hp, rfl‚ü©
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ‚Üê Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image]
  exact fun x hx => ‚ü®x, hx, rfl‚ü©"
Mathlib/Data/Fin/Basic.lean,Fin.exists_eq_add_of_lt,exists_eq_add_of_lt,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases n
  ¬∑ cases' a with a ha
    cases' b with b hb
    simp only [Nat.zero_eq, zero_add, Nat.lt_one_iff] at ha hb
    simp [ha, hb] at h
  obtain ‚ü®k, hk‚ü© : ‚àÉ k : ‚Ñï, (b : ‚Ñï) = a + k + 1 := Nat.exists_eq_add_of_lt h
  have hkb : k < b := by
    rw [hk, add_comm _ k, Nat.lt_succ_iff]
    exact le_self_add
  refine' ‚ü®‚ü®k, hkb.trans b.is_lt‚ü©, hkb, _, _‚ü©
  ¬∑ rw [Fin.le_iff_val_le_val, Fin.val_add_one]
    split_ifs <;> simp [Nat.succ_le_iff, hkb]
  simp [Fin.ext_iff, Fin.val_add, ‚Üê hk, Nat.mod_eq_of_lt b.is_lt]","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown identifier 'zero_add'
error:  unsolved goals
case zero.mk.mk
n m a : ‚Ñï
ha : a < 0 + 1
b : ‚Ñï
hb : b < 0 + 1
h : a < b
‚ä¢ ‚àÉ k < ‚ü®b, hb‚ü©, k + 1 ‚â§ ‚ü®b, hb‚ü© ‚àß ‚ü®b, hb‚ü© = ‚ü®a, ha‚ü© + k + 1
error:  unknown identifier 'add_comm'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.81801
n m n‚úù : ‚Ñï
a b : Fin (n‚úù + 1 + 1)
h : a < b
k : ‚Ñï
hk : ‚Üëb = ‚Üëa + k + 1
‚ä¢ k < ‚Üëa + k + 1","theorem exists_eq_add_of_lt {n : ‚Ñï} {a b : Fin (n + 1)} (h : a < b) :
    ‚àÉ k < b, k + 1 ‚â§ b ‚àß b = a + k + 1 ",":= by
  cases n
  ¬∑ cases' a with a ha
    cases' b with b hb
    simp only [Nat.zero_eq, Nat.zero_add, Nat.lt_one_iff] at ha hb
    simp [ha, hb] at h
  obtain ‚ü®k, hk‚ü© : ‚àÉ k : ‚Ñï, (b : ‚Ñï) = a + k + 1 := Nat.exists_eq_add_of_lt h
  have hkb : k < b := by omega
  refine ‚ü®‚ü®k, hkb.trans b.is_lt‚ü©, hkb, ?_, ?_‚ü©
  ¬∑ rw [Fin.le_iff_val_le_val, Fin.val_add_one]
    split_ifs <;> simp [Nat.succ_le_iff, hkb]
  simp [Fin.ext_iff, Fin.val_add, ‚Üê hk, Nat.mod_eq_of_lt b.is_lt]",":= by
  cases n
  ¬∑ cases' a with a ha
    cases' b with b hb
    simp only [zero_add, Nat.lt_one_iff] at ha hb
    simp [ha, hb] at h
  obtain ‚ü®k, hk‚ü© : ‚àÉ k : ‚Ñï, (b : ‚Ñï) = a + k + 1 := Nat.exists_eq_add_of_lt h
  have hkb : k < b := by
    rw [hk, add_comm _ k, Nat.lt_succ_iff]
    exact le_self_add
  refine ‚ü®‚ü®k, hkb.trans b.is_lt‚ü©, hkb, ?_, ?_‚ü©
  ¬∑ rw [Fin.le_iff_val_le_val, Fin.val_add_one]
    split_ifs <;> simp [Nat.succ_le_iff, hkb]
  simp [Fin.ext_iff, Fin.val_add, ‚Üê hk, Nat.mod_eq_of_lt b.is_lt]"
Mathlib/MeasureTheory/Group/GeometryOfNumbers.lean,MeasureTheory.exists_pair_mem_lattice_not_disjoint_vadd,exists_pair_mem_lattice_not_disjoint_vadd,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  contrapose! h
  exact ((fund.measure_eq_tsum _).trans (measure_iUnion‚ÇÄ
    (Pairwise.mono h fun i j hij => (hij.mono inf_le_left inf_le_left).aedisjoint)
      fun _ => (hS.vadd _).inter fund.nullMeasurableSet).symm).trans_le
      (measure_mono <| Set.iUnion_subset fun _ => Set.inter_subset_right _ _)","error:  function expected at
  inter_subset_right ?m.6720
term has type
  ?m.6719 ‚àà ?m.6718","theorem exists_pair_mem_lattice_not_disjoint_vadd [AddCommGroup L] [Countable L] [AddAction L E]
    [MeasurableSpace L] [MeasurableVAdd L E] [VAddInvariantMeasure L E Œº]
    (fund : IsAddFundamentalDomain L F Œº) (hS : NullMeasurableSet s Œº) (h : Œº F < Œº s) :
    ‚àÉ x y : L, x ‚â† y ‚àß ¬¨Disjoint (x +·µ• s) (y +·µ• s) ",":= by
  contrapose! h
  exact ((fund.measure_eq_tsum _).trans (measure_iUnion‚ÇÄ
    (Pairwise.mono h fun i j hij => (hij.mono inf_le_left inf_le_left).aedisjoint)
      fun _ => (hS.vadd _).inter fund.nullMeasurableSet).symm).trans_le
      (measure_mono <| Set.iUnion_subset fun _ => Set.inter_subset_right)",":= by
  contrapose! h
  exact ((fund.measure_eq_tsum _).trans (measure_iUnion‚ÇÄ
    (Pairwise.mono h fun i j hij => (hij.mono inf_le_left inf_le_left).aedisjoint)
      fun _ => (hS.vadd _).inter fund.nullMeasurableSet).symm).trans_le
      (measure_mono Set.iUnion_subset fun _ => Set.inter_subset_right)"
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,66c0098b0b62ad14d9c618b402e7673658137a7e,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine' ‚ü®U, {j}, _, _‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine' ‚ü®j, V, _, _‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine' this _ _ _ (univ _) (inter _) _
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      rw [‚Üê coe_comp, D.w]
      rfl","error:  unknown identifier 'isTopologicalBasis_iInf'
error:  no goals to be solved","theorem isTopologicalBasis_cofiltered_limit (T : ‚àÄ j, Set (Set (F.obj j)))
    (hT : ‚àÄ j, IsTopologicalBasis (T j)) (univ : ‚àÄ i : J, Set.univ ‚àà T i)
    (inter : ‚àÄ (i) (U1 U2 : Set (F.obj i)), U1 ‚àà T i ‚Üí U2 ‚àà T i ‚Üí U1 ‚à© U2 ‚àà T i)
    (compat : ‚àÄ (i j : J) (f : i ‚ü∂ j) (V : Set (F.obj j)) (_hV : V ‚àà T j), F.map f ‚Åª¬π' V ‚àà T i) :
    IsTopologicalBasis
      {U : Set C.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = C.œÄ.app j ‚Åª¬π' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    ¬∑ 
      rw [h2]
      change _ = (D.œÄ.app j)‚Åª¬π' ‚ãÇ (e : J) (_ : e ‚àà G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.œÄ.app e)‚Åª¬π' U e =
        (D.œÄ.app j) ‚Åª¬π' if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
      rw [dif_pos he, ‚Üê Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [‚Üê coe_comp, D.w] 
      rfl",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt ‚âÖ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ‚àÉ (j : _) (V : Set (F.obj j)), V ‚àà T j ‚àß U = D.œÄ.app j ‚Åª¬π' V} by
    convert this.inducing hE
    ext U0
    constructor
    ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
      exact ‚ü®D.œÄ.app j ‚Åª¬π' V, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
    ¬∑ rintro ‚ü®W, ‚ü®j, V, hV, rfl‚ü©, rfl‚ü©
      exact ‚ü®j, V, hV, rfl‚ü©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.œÄ.app j x using 1
  ext U0
  constructor
  ¬∑ rintro ‚ü®j, V, hV, rfl‚ü©
    let U : ‚àÄ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ‚ü®U, {j}, ?_, ?_‚ü©
    ¬∑ simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    ¬∑ simp [U]
  ¬∑ rintro ‚ü®U, G, h1, h2‚ü©
    obtain ‚ü®j, hj‚ü© := IsCofiltered.inf_objs_exists G
    let g : ‚àÄ e ‚àà G, j ‚ü∂ e := fun _ he => (hj he).some
    let Vs : J ‚Üí Set (F.obj j) := fun e => if h : e ‚àà G then F.map (g e h) ‚Åª¬π' U e else Set.univ
    let V : Set (F.obj j) := ‚ãÇ (e : J) (_he : e ‚àà G), Vs e
    refine ‚ü®j, V, ?_, ?_‚ü©
    ¬∑ 
      have :
        ‚àÄ (S : Set (Set (F.obj j))) (E : Finset J) (P : J ‚Üí Set (F.obj j)) (_univ : Set.univ ‚àà S)
          (_inter : ‚àÄ A B : Set (F.obj j), A ‚àà S ‚Üí B ‚àà S ‚Üí A ‚à© B ‚àà S)
          (_cond : ‚àÄ (e : J) (_he : e ‚àà E), P e ‚àà S), (‚ãÇ (e) (_he : e ‚àà E), P e) ‚àà S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ ?_ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) e"
Mathlib/Data/Int/GCD.lean,Nat.xgcdAux_rec,xgcdAux_rec,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain ‚ü®r, rfl‚ü© := Nat.exists_eq_succ_of_ne_zero h.ne'
  rfl","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case intro
s t : ‚Ñ§
r' : ‚Ñï
s' t' : ‚Ñ§
r : ‚Ñï
h : 0 < r.succ
‚ä¢ r.succ.xgcdAux s t r' s' t' = (r' % r.succ).xgcdAux (s' - ‚Üër' / ‚Üër.succ * s) (t' - ‚Üër' / ‚Üër.succ * t) r.succ s t","theorem xgcdAux_rec {r s t r' s' t'} (h : 0 < r) :
    xgcdAux r s t r' s' t' = xgcdAux (r' % r) (s' - r' / r * s) (t' - r' / r * t) r s t ",":= by
  obtain ‚ü®r, rfl‚ü© := Nat.exists_eq_succ_of_ne_zero h.ne'
  simp [xgcdAux]",":= by
  obtain ‚ü®r, rfl‚ü© := Nat.exists_eq_succ_of_ne_zero h"
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.evaln_prim,evaln_prim,754ba19de1471fd928c4fa0cc102d1f06f90e902,":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.get?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        cases evaln k cg n <;> rfl
      ¬∑ cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      ¬∑ cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      ¬∑ have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to‚ÇÇ).of_eq
    fun ‚ü®‚ü®k, c‚ü©, n‚ü© => by simp [evaln_map]","warning:  `List.map_congr` has been deprecated, use `List.map_congr_left` instead
warning:  `List.get?_range` has been deprecated, use `List.getElem?_range` instead
error:  unsolved goals
x‚úù : Unit
p n : ‚Ñï
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
c : Code
k' : ‚Ñï
k : ‚Ñï := k' + 1
nk : n ‚â§ k'
k‚ÇÅ : ‚Ñï
c‚ÇÅ : Code
n‚ÇÅ : ‚Ñï
hl : Nat.pair k‚ÇÅ (encode c‚ÇÅ) < Nat.pair k (encode c)
‚ä¢ ((Option.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
          (List.range (Nat.pair k (encode c)))[Nat.pair k‚ÇÅ (encode c‚ÇÅ)]?).bind
      fun a ‚Ü¶ a[n‚ÇÅ]?.bind fun a ‚Ü¶ a) =
    evaln k‚ÇÅ c‚ÇÅ n‚ÇÅ",theorem evaln_prim : Primrec fun a : (‚Ñï √ó Code) √ó ‚Ñï => evaln a.1.1 a.1.2 a.2 ,":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr_left fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.getElem?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        cases evaln k cg n <;> rfl
      ¬∑ cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      ¬∑ cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      ¬∑ have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to‚ÇÇ).of_eq
    fun ‚ü®‚ü®k, c‚ü©, n‚ü© => by simp [evaln_map]",":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
               (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.get?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ "
Mathlib/NumberTheory/Modular.lean,ModularGroup.tendsto_normSq_coprime_pair,tendsto_normSq_coprime_pair,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * 1
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
x‚úù : Fin 2 ‚Üí ‚Ñù
‚ä¢ f x‚úù = ‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)
error:  unknown identifier 'ofReal_int_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.22080
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
f_def : ‚áëf = fun p ‚Ü¶ ‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)
x‚úù : Fin 2 ‚Üí ‚Ñ§
‚ä¢ normSq (‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)) = normSq (‚Üë‚Üë(x‚úù 0) * ‚Üëz + ‚Üë‚Üë(x‚úù 1))
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem tendsto_normSq_coprime_pair :
    Filter.Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * z + p 1)) cofinite atTop ",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_intCast, ofReal_intCast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)"
Mathlib/LinearAlgebra/QuadraticForm/Basic.lean,QuadraticForm.polar_smul_left_of_tower,polar_smul_left_of_tower,18f1e3ee387a3d040ba88fad8882f979755c163f,":= by
  rw [‚Üê IsScalarTower.algebraMap_smul R a x, polar_smul_left, algebraMap_smul]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (algebraMap ?m.109142 ?A) ?r ‚Ä¢ ?m
S : Type u_1
T : Type u_2
R : Type u_3
M : Type u_4
N : Type u_5
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : AddCommGroup M
inst‚úù‚Å¥ : Module R M
Q : QuadraticForm R M
inst‚úù¬≥ : CommSemiring S
inst‚úù¬≤ : Algebra S R
inst‚úù¬π : Module S M
inst‚úù : IsScalarTower S R M
a : S
x y : M
‚ä¢ (algebraMap S R) a * polar (‚áëQ) x y = a ‚Ä¢ polar (‚áëQ) x y",theorem polar_smul_left_of_tower (a : S) (x y : M) : polar Q (a ‚Ä¢ x) y = a ‚Ä¢ polar Q x y ,":= by
  rw [‚Üê IsScalarTower.algebraMap_smul R a x, polar_smul_left, Algebra.smul_def]",":= by
  rw [‚Üê algebraMap_smul R a x, polar_smul_left, algebraMap_smul]"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,166d0bf5448fdaad518cf95891af45e08a3e9c35,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniforml"
Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean,Ideal.homogeneousCore'_le,Ideal.homogeneousCore'_le,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  Submodule.homogeneousCore'_le ùíú I",error:  unknown constant 'Submodule.homogeneousCore'_le',theorem Ideal.homogeneousCore'_le : I.homogeneousCore' ùíú ‚â§ I ,":=
  Ideal.span_le.2 <| image_preimage_subset _ _",":=
  homogeneousCore'_le ùíú I"
Mathlib/Topology/Bases.lean,TopologicalSpace.IsTopologicalBasis.diff_empty,IsTopologicalBasis.diff_empty,b0906f1a9f950f5731cad2defb88e9843a7e3fc9,":= by
  refine' ‚ü®_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], _‚ü©
  ¬∑ rintro t‚ÇÅ ‚ü®h‚ÇÅ, -‚ü© t‚ÇÇ ‚ü®h‚ÇÇ, -‚ü© x hx
    obtain ‚ü®t‚ÇÉ, h‚ÇÉ, hs‚ü© := h.exists_subset_inter _ h‚ÇÅ _ h‚ÇÇ x hx
    exact ‚ü®t‚ÇÉ, ‚ü®h‚ÇÉ, Nonempty.ne_empty ‚ü®x, hs.1‚ü©‚ü©, hs‚ü©
  ¬∑ rw [h.eq_generateFrom]
    refine' le_antisymm (generateFrom_anti <| diff_subset s _) (le_generateFrom fun t ht => _)
    obtain rfl | he := eq_or_ne t ‚àÖ
    ¬∑ exact @isOpen_empty _ (generateFrom _)
    ¬∑ exact .basic t ‚ü®ht, he‚ü©","error:  application type mismatch
  diff_subset s
argument
  s
has type
  Set (Set Œ±) : Type u
but is expected to have type
  ?m.1865 ‚àà ?m.1863 \ ?m.1864 : Prop","theorem IsTopologicalBasis.diff_empty {s : Set (Set Œ±)} (h : IsTopologicalBasis s) :
    IsTopologicalBasis (s \ {‚àÖ}) ",":= by
  refine ‚ü®?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_‚ü©
  ¬∑ rintro t‚ÇÅ ‚ü®h‚ÇÅ, -‚ü© t‚ÇÇ ‚ü®h‚ÇÇ, -‚ü© x hx
    obtain ‚ü®t‚ÇÉ, h‚ÇÉ, hs‚ü© := h.exists_subset_inter _ h‚ÇÅ _ h‚ÇÇ x hx
    exact ‚ü®t‚ÇÉ, ‚ü®h‚ÇÉ, Nonempty.ne_empty ‚ü®x, hs.1‚ü©‚ü©, hs‚ü©
  ¬∑ rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti diff_subset) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t ‚àÖ
    ¬∑ exact @isOpen_empty _ (generateFrom _)
    ¬∑ exact .basic t ‚ü®ht, he‚ü©",":= by
  refine ‚ü®_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_‚ü©
  ¬∑ rintro t‚ÇÅ ‚ü®h‚ÇÅ, -‚ü© t‚ÇÇ ‚ü®h‚ÇÇ, -‚ü© x hx
    obtain ‚ü®t‚ÇÉ, h‚ÇÉ, hs‚ü© := h.exists_subset_inter _ h‚ÇÅ _ h‚ÇÇ x hx
    exact ‚ü®t‚ÇÉ, ‚ü®h‚ÇÉ, Nonempty.ne_empty ‚ü®x, hs.1‚ü©‚ü©, hs‚ü©
  ¬∑ rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti <| diff_subset s ?_) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t ‚àÖ
    ¬∑ exact @isOpen_empty _ (generateFrom _)
    ¬∑ exact .basic t ‚ü®ht, he‚ü©"
Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean,Complex.continuousAt_ofReal_cpow,continuousAt_ofReal_cpow,e68cc52e8a27c3d4abb7fac34419d5ef5625cb88,":= by
  rcases lt_trichotomy (0 : ‚Ñù) x with (hx | rfl | hx)
  ¬∑ 
    have : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    refine' (continuousAt_cpow (Or.inl _)).comp this
    rwa [ofReal_re]
  ¬∑ 
    have A : ContinuousAt (fun p => p.1 ^ p.2 : ‚ÑÇ √ó ‚ÑÇ ‚Üí ‚ÑÇ) ‚ü®‚Üë(0 : ‚Ñù), y‚ü© := by
      rw [ofReal_zero]
      apply continuousAt_cpow_zero_of_re_pos
      tauto
    have B : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) ‚ü®0, y‚ü© :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    exact ContinuousAt.comp (Œ± := ‚Ñù √ó ‚ÑÇ) (f := fun p => ‚ü®‚Üëp.1, p.2‚ü©) (x := ‚ü®0, y‚ü©) A B
  ¬∑ 
    suffices ContinuousAt (fun p => (-(p.1 : ‚ÑÇ)) ^ p.2 * exp (œÄ * I * p.2) : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine' this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) _)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) :=
      ContinuousAt.prod_map continuous_ofReal.continuousAt.neg continuousAt_id
    apply ContinuousAt.mul
    ¬∑ refine' (continuousAt_cpow (Or.inl _)).comp A
      rwa [neg_re, ofReal_re, neg_pos]
    ¬∑ exact (continuous_exp.comp (continuous_const.mul continuous_snd)).continuousAt","error:  invalid argument name 'Œ±' for function 'ContinuousAt.comp'
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  ?m.62387
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  p
has type
  ?m.62387
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  p
has type
  ?m.62387","theorem continuousAt_ofReal_cpow (x : ‚Ñù) (y : ‚ÑÇ) (h : 0 < y.re ‚à® x ‚â† 0) :
    ContinuousAt (fun p => (p.1 : ‚ÑÇ) ^ p.2 : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) ",":= by
  rcases lt_trichotomy (0 : ‚Ñù) x with (hx | rfl | hx)
  ¬∑ 
    have : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    refine (continuousAt_cpow (Or.inl ?_)).comp this
    rwa [ofReal_re]
  ¬∑ 
    have A : ContinuousAt (fun p => p.1 ^ p.2 : ‚ÑÇ √ó ‚ÑÇ ‚Üí ‚ÑÇ) ‚ü®‚Üë(0 : ‚Ñù), y‚ü© := by
      rw [ofReal_zero]
      apply continuousAt_cpow_zero_of_re_pos
      tauto
    have B : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) ‚ü®0, y‚ü© :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    exact A.comp_of_eq B rfl
  ¬∑ 
    suffices ContinuousAt (fun p => (-(p.1 : ‚ÑÇ)) ^ p.2 * exp (œÄ * I * p.2) : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) :=
      ContinuousAt.prod_map continuous_ofReal.continuousAt.neg continuousAt_id
    apply ContinuousAt.mul
    ¬∑ refine (continuousAt_cpow (Or.inl ?_)).comp A
      rwa [neg_re, ofReal_re, neg_pos]
    ¬∑ exact (continuous_exp.comp (continuous_const.mul continuous_snd)).continuousAt",":= by
  rcases lt_trichotomy (0 : ‚Ñù) x with (hx | rfl | hx)
  ¬∑ 
    have : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    refine (continuousAt_cpow (Or.inl ?_)).comp this
    rwa [ofReal_re]
  ¬∑ 
    have A : ContinuousAt (fun p => p.1 ^ p.2 : ‚ÑÇ √ó ‚ÑÇ ‚Üí ‚ÑÇ) ‚ü®‚Üë(0 : ‚Ñù), y‚ü© := by
      rw [ofReal_zero]
      apply continuousAt_cpow_zero_of_re_pos
      tauto
    have B : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) ‚ü®0, y‚ü© :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    exact ContinuousAt.comp (Œ± := ‚Ñù √ó ‚ÑÇ) (f := fun p => ‚ü®‚Üëp.1, p.2‚ü©) (x := ‚ü®0, y‚ü©) A B
  ¬∑ 
    suffices ContinuousAt (fun p => (-(p.1 : ‚ÑÇ)) ^ p.2 * exp (œÄ * I * p.2) : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üë"
Mathlib/RingTheory/IntegralClosure.lean,RingHom.Finite.to_isIntegral,RingHom.Finite.to_isIntegral,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":=
  letI := f.toSMul
  letI := f.toAlgebra
  fun _ ‚Ü¶ IsIntegral.of_mem_of_fg ‚ä§ h.1 _ trivial","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  R ‚Üí+* S",theorem RingHom.Finite.to_isIntegral (h : f.Finite) : f.IsIntegral ,":=
  letI := f.toAlgebra
  fun _ ‚Ü¶ IsIntegral.of_mem_of_fg ‚ä§ h.1 _ trivial",":=
  letI := f.toAlgebra
  fun _ ‚Ü¶ IsIntegral.of_mem_of_fg ‚ä§ h.1 trivial"
Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean,AlgebraicGeometry.sourceAffineLocally_isLocal,sourceAffineLocally_isLocal,f2d9d382d39668abc853a5430012bde8c3f6587e,":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
      ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
            IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
          exact this _ rfl
        intro V hV
        rw [Scheme.preimage_basicOpen] at hV
        subst hV
        exact U.2.mapRestrictBasicOpen (Scheme.Œì.map f.op r.1)","error:  no goals to be solved
error:  unsolved goals
case ofBasicOpenCover.refine_1
P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí (R ‚Üí+* S) ‚Üí Prop
h‚ÇÅ : RingHom.RespectsIso P
h‚ÇÇ : RingHom.LocalizationPreserves P
h‚ÇÉ : RingHom.OfLocalizationSpan P
X Y : Scheme
inst‚úù : IsAffine Y
f : X ‚ü∂ Y
s : Finset ‚ÜëŒì(Y, ‚ä§)
hs : Ideal.span ‚Üës = ‚ä§
hs' : ‚àÄ (r : { x // x ‚àà s }), sourceAffineLocally P (f ‚à£_ Y.basicOpen ‚Üër)
U : ‚ÜëX.affineOpens
r : ‚Üë‚Üës
‚ä¢ X.ofRestrict ‚ãØ ‚Åª¬π·µÅ ‚ÜëU ‚àà (X ‚à£_·µ§ f ‚Åª¬π·µÅ Y.basicOpen ‚Üër).affineOpens","theorem sourceAffineLocally_isLocal (h‚ÇÅ : RingHom.RespectsIso @P)
    (h‚ÇÇ : RingHom.LocalizationPreserves @P) (h‚ÇÉ : RingHom.OfLocalizationSpan @P) :
    (sourceAffineLocally @P).IsLocal ",":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
    ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
          IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
        exact this _ rfl
      intro V hV
      rw [Scheme.preimage_basicOpen] at hV
      subst hV
      exact U.2.ŒπOpens_basicOpen_preimage (Scheme.Œì.map f.op r.1)",":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
      ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
            IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
          exact this _ rfl
        intro V hV
        rw [Scheme.preimage_basicOpen] at hV
        subst hV
        exact U.2.mapRestrictBasicOpen (Scheme.Œì.map f.op r.1)"
Mathlib/Analysis/Calculus/LHopital.lean,HasDerivAt.lhopital_zero_nhds,lhopital_zero_nhds,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  rw [eventually_iff_exists_mem] at *
  rcases hff' with ‚ü®s‚ÇÅ, hs‚ÇÅ, hff'‚ü©
  rcases hgg' with ‚ü®s‚ÇÇ, hs‚ÇÇ, hgg'‚ü©
  rcases hg' with ‚ü®s‚ÇÉ, hs‚ÇÉ, hg'‚ü©
  let s := s‚ÇÅ ‚à© s‚ÇÇ ‚à© s‚ÇÉ
  have hs : s ‚àà ùìù[>] a := inter_mem (inter_mem hs‚ÇÅ hs‚ÇÇ) hs‚ÇÉ
  rw [mem_nhdsWithin_Ioi_iff_exists_Ioo_subset] at hs
  rcases hs with ‚ü®u, hau, hu‚ü©
  refine lhopital_zero_right_on_Ioo hau ?_ ??_ _ hfa hga hdiv <;> intro x hx <;> apply_assumption <;>
    first | exact (hu hx).1.1 | exact (hu hx).1.2 | exact (hu hx).2",error:  unexpected token '?'; expected '_' or identifier,"theorem lhopital_zero_nhds_right (hff' : ‚àÄ·∂† x in ùìù[>] a, HasDerivAt f (f' x) x)
    (hgg' : ‚àÄ·∂† x in ùìù[>] a, HasDerivAt g (g' x) x) (hg' : ‚àÄ·∂† x in ùìù[>] a, g' x ‚â† 0)
    (hfa : Tendsto f (ùìù[>] a) (ùìù 0)) (hga : Tendsto g (ùìù[>] a) (ùìù 0))
    (hdiv : Tendsto (fun x => f' x / g' x) (ùìù[>] a) l) :
    Tendsto (fun x => f x / g x) (ùìù[>] a) l ",":= by
  rw [eventually_iff_exists_mem] at *
  rcases hff' with ‚ü®s‚ÇÅ, hs‚ÇÅ, hff'‚ü©
  rcases hgg' with ‚ü®s‚ÇÇ, hs‚ÇÇ, hgg'‚ü©
  rcases hg' with ‚ü®s‚ÇÉ, hs‚ÇÉ, hg'‚ü©
  let s := s‚ÇÅ ‚à© s‚ÇÇ ‚à© s‚ÇÉ
  have hs : s ‚àà ùìù[>] a := inter_mem (inter_mem hs‚ÇÅ hs‚ÇÇ) hs‚ÇÉ
  rw [mem_nhdsWithin_Ioi_iff_exists_Ioo_subset] at hs
  rcases hs with ‚ü®u, hau, hu‚ü©
  refine lhopital_zero_right_on_Ioo hau ?_ ?_ ?_ hfa hga hdiv <;>
    intro x hx <;> apply_assumption <;>
    first | exact (hu hx).1.1 | exact (hu hx).1.2 | exact (hu hx).2",":= by
  rw [eventually_iff_exists_mem] at *
  rcases hff' with ‚ü®s‚ÇÅ, hs‚ÇÅ, hff'‚ü©
  rcases hgg' with ‚ü®s‚ÇÇ, hs‚ÇÇ, hgg'‚ü©
  rcases hg' with ‚ü®s‚ÇÉ, hs‚ÇÉ, hg'‚ü©
  let s := s‚ÇÅ ‚à© s‚ÇÇ ‚à© s‚ÇÉ
  have hs : s ‚àà ùìù[>] a := inter_mem (inter_mem hs‚ÇÅ hs‚ÇÇ) hs‚ÇÉ
  rw [mem_nhdsWithin_Ioi_iff_exists_Ioo_subset] at hs
  rcases hs with ‚ü®u, hau, hu‚ü©
  refine lhopital_zero_right_on_Ioo hau ?_ ?_ ?_ hfa hga hdiv <;> intro x hx <;> apply_assumption <;>
    first | exact (hu hx).1.1 | exact (hu hx).1.2 | exact (hu hx).2"
Mathlib/SetTheory/Game/Nim.lean,SetTheory.PGame.grundyValue_nim_add_nim,grundyValue_nim_add_nim,8a77514daeaf3b706a2b617d963d1f46e4504afb,":= by
  induction' n using Nat.strong_induction_on with n hn generalizing m
  induction' m using Nat.strong_induction_on with m hm
  rw [grundyValue_eq_mex_left]
  refine (Ordinal.mex_le_of_ne.{u, u} fun i => ?_).antisymm
    (Ordinal.le_mex_of_forall fun ou hu => ?_)
  ¬∑ apply leftMoves_add_cases i <;>
      ¬∑ 
        refine' fun a => leftMovesNimRecOn a fun ok hk => _
        obtain ‚ü®k, rfl‚ü© := Ordinal.lt_omega.1 (hk.trans (Ordinal.nat_lt_omega _))
        simp only [add_moveLeft_inl, add_moveLeft_inr, moveLeft_nim', Equiv.symm_apply_apply]
        rw [nat_cast_lt] at hk
        first
        | rw [hn _ hk]
        | rw [hm _ hk]
        refine' fun h => hk.ne _
        rw [Ordinal.nat_cast_inj] at h
        first
        | rwa [Nat.xor_left_inj] at h
        | rwa [Nat.xor_right_inj] at h
  ¬∑ 
    obtain ‚ü®u, rfl‚ü© := Ordinal.lt_omega.1 (hu.trans (Ordinal.nat_lt_omega _))
    replace hu := Ordinal.nat_cast_lt.1 hu
    cases' Nat.lt_xor_cases hu with h h
    ¬∑ refine' ‚ü®toLeftMovesAdd (Sum.inl <| toLeftMovesNim ‚ü®_, Ordinal.nat_cast_lt.2 h‚ü©), _‚ü©
      simp [Nat.lxor_cancel_right, hn _ h]
    ¬∑ refine' ‚ü®toLeftMovesAdd (Sum.inr <| toLeftMovesNim ‚ü®_, Ordinal.nat_cast_lt.2 h‚ü©), _‚ü©
      have : n ^^^ (u ^^^ n) = u := by rw [Nat.xor_comm u, Nat.xor_cancel_left]
      simpa [hm _ h] using this","warning:  `Ordinal.nat_cast_lt` has been deprecated, use `Ordinal.natCast_lt` instead
warning:  `Ordinal.nat_cast_inj` has been deprecated, use `Ordinal.natCast_inj` instead
warning:  `Ordinal.nat_cast_lt` has been deprecated, use `Ordinal.natCast_lt` instead
warning:  `Ordinal.nat_cast_inj` has been deprecated, use `Ordinal.natCast_inj` instead
warning:  `Ordinal.nat_cast_lt` has been deprecated, use `Ordinal.natCast_lt` instead
warning:  `Ordinal.nat_cast_lt` has been deprecated, use `Ordinal.natCast_lt` instead
error:  unknown constant 'Nat.lxor_cancel_right'
error:  unsolved goals
case h.h.refine_2.intro.inl
n : ‚Ñï
hn : ‚àÄ m < n, ‚àÄ (m_1 : ‚Ñï), (nim ‚Üëm + nim ‚Üëm_1).grundyValue = ‚Üë(m ^^^ m_1)
m : ‚Ñï
hm : ‚àÄ m_1 < m, (nim ‚Üën + nim ‚Üëm_1).grundyValue = ‚Üë(n ^^^ m_1)
u : ‚Ñï
hu : u < n ^^^ m
h : u ^^^ m < n
‚ä¢ u ^^^ m ^^^ m = u
warning:  `Ordinal.nat_cast_lt` has been deprecated, use `Ordinal.natCast_lt` instead","theorem grundyValue_nim_add_nim (n m : ‚Ñï) :
    grundyValue (nim.{u} n + nim.{u} m) = n ^^^ m ",":= by
  induction' n using Nat.strong_induction_on with n hn generalizing m
  induction' m using Nat.strong_induction_on with m hm
  rw [grundyValue_eq_mex_left]
  refine (Ordinal.mex_le_of_ne.{u, u} fun i => ?_).antisymm
    (Ordinal.le_mex_of_forall fun ou hu => ?_)
  ¬∑ apply leftMoves_add_cases i <;>
      ¬∑ 
        refine fun a => leftMovesNimRecOn a fun ok hk => ?_
        obtain ‚ü®k, rfl‚ü© := Ordinal.lt_omega.1 (hk.trans (Ordinal.nat_lt_omega _))
        simp only [add_moveLeft_inl, add_moveLeft_inr, moveLeft_nim', Equiv.symm_apply_apply]
        rw [natCast_lt] at hk
        first
        | rw [hn _ hk]
        | rw [hm _ hk]
        refine fun h => hk.ne ?_
        rw [Ordinal.natCast_inj] at h
        first
        | rwa [Nat.xor_left_inj] at h
        | rwa [Nat.xor_right_inj] at h
  ¬∑ 
    obtain ‚ü®u, rfl‚ü© := Ordinal.lt_omega.1 (hu.trans (Ordinal.nat_lt_omega _))
    replace hu := Ordinal.natCast_lt.1 hu
    cases' Nat.lt_xor_cases hu with h h
    ¬∑ refine ‚ü®toLeftMovesAdd (Sum.inl <| toLeftMovesNim ‚ü®_, Ordinal.natCast_lt.2 h‚ü©), ?_‚ü©
      simp [Nat.xor_cancel_right, hn _ h]
    ¬∑ refine ‚ü®toLeftMovesAdd (Sum.inr <| toLeftMovesNim ‚ü®_, Ordinal.natCast_lt.2 h‚ü©), ?_‚ü©
      have : n ^^^ (u ^^^ n) = u := by rw [Nat.xor_comm u, Nat.xor_cancel_left]
      simpa [hm _ h] using this",":= by
  induction' n using Nat.strong_induction_on with n hn generalizing m
  induction' m using Nat.strong_induction_on with m hm
  rw [grundyValue_eq_mex_left]
  refine (Ordinal.mex_le_of_ne.{u, u} fun i => ?_).antisymm
    (Ordinal.le_mex_of_forall fun ou hu => ?_)
  ¬∑ apply leftMoves_add_cases i <;>
      ¬∑ 
        refine fun a => leftMovesNimRecOn a fun ok hk => ?_
        obtain ‚ü®k, rfl‚ü© := Ordinal.lt_omega.1 (hk.trans (Ordinal.nat_lt_omega _))
        simp only [add_moveLeft_inl, add_moveLeft_inr, moveLeft_nim', Equiv.symm_apply_apply]
        rw [nat_cast_lt] at hk
        first
        | rwa [Nat.xor_left_inj] at h
        | rwa [Nat.xor_right_inj] at h
  ¬∑ 
    obtain ‚ü®u, rfl‚ü© := Ordinal.lt_omega.1 (hu.trans (Ordinal.nat_lt_omega _))
    replace hu := Ordinal.nat_cast_lt.1 hu
    cases' Nat.lt_xor_cases hu with h h
    ¬∑ refine ‚ü®toLeftMovesAdd (Sum.inl <| toLeftMovesNim ‚ü®_, Ordinal.nat_cast_lt.2 h‚ü©), ?_‚ü©
      have : n ^^^ (u ^^^ n) = u := by rw [Nat.xor_comm u, Nat.xor_cancel_left]
      simpa [hm _ h] using this"
Mathlib/GroupTheory/Torsion.lean,AddMonoid.IsTorsion.module_of_torsion,IsTorsion.module_of_torsion,1d775649ea8e0e1abd5584cd2fe1890edc775880,":=
  fun f =>
  (isOfFinAddOrder_iff_nsmul_eq_zero _).mpr <| by
    obtain ‚ü®n, npos, hn‚ü© := (isOfFinAddOrder_iff_nsmul_eq_zero _).mp (tR 1)
    exact ‚ü®n, npos, by simp only [nsmul_eq_smul_cast R _ f, ‚Üê nsmul_one, hn, zero_smul]‚ü©","error:  function expected at
  isOfFinAddOrder_iff_nsmul_eq_zero
term has type
  IsOfFinAddOrder ?m.12962 ‚Üî ‚àÉ n, 0 < n ‚àß n ‚Ä¢ ?m.12962 = 0",theorem IsTorsion.module_of_torsion [Semiring R] [Module R M] (tR : IsTorsion R) : IsTorsion M ,":=
  fun f =>
  isOfFinAddOrder_iff_nsmul_eq_zero.mpr <| by
    obtain ‚ü®n, npos, hn‚ü© := (tR 1).exists_nsmul_eq_zero
    exact ‚ü®n, npos, by simp only [nsmul_eq_smul_cast R _ f, ‚Üê nsmul_one, hn, zero_smul]‚ü©",":=
  fun f => (isOfFinAddOrder_iff_nsmul_eq_zero _).mpr <| by
    obtain ‚ü®n, npos, hn‚ü© := (isOfFinAddOrder_iff_nsmul_eq_zero _).mp (tR 1)
    exact ‚ü®n, npos, by simp only [nsmul_eq_smul_cast R _ f, ‚Üê nsmul_one, hn, zero_smul]‚ü©"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.erase_add,erase_add,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.erase_add_single a f","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.erase_add_single'",theorem erase_add_single (a : Œ±) (f : Œ± ‚Üí‚ÇÄ M) : f.erase a + single a (f a) = f ,":= by
  rw [‚Üê update_eq_erase_add_single, update_self]",":=
  erase_add_single a f"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  simp made no progress
warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metri"
Mathlib/Analysis/Complex/CauchyIntegral.lean,Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,e92ad7acc4d771729f70601a74a3c091f330e507,":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r; exact ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R; exact ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in [0:2 * œÄ], I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in [0:2 * œÄ], I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (¬∑ + ¬∑) c ‚àò exp
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R; exact hc.comp hdg.continuous.continuousOn h_maps
  replace hd :
    ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z
  ¬∑ refine' fun z hz => (hd (g z) ‚ü®_, hz.2‚ü©).comp z (hdg _)
    simpa [dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd","error:  unexpected token ';'; expected '|'
error:  unsolved goals
case intro.intro
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚ÑÇ E
inst‚úù : CompleteSpace E
c : ‚ÑÇ
f : ‚ÑÇ ‚Üí E
s : Set ‚ÑÇ
a : ‚Ñù
h0 : 0 < rexp a
b : ‚Ñù
hle : a ‚â§ b
hd : ‚àÄ z ‚àà (ball c (rexp b) \ closedBall c (rexp a)) \ s, DifferentiableAt ‚ÑÇ f z
A : Set ‚ÑÇ := closedBall c (rexp b) \ ball c (rexp a)
R : Set ‚ÑÇ := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
g : ‚ÑÇ ‚Üí ‚ÑÇ := (fun x x_1 ‚Ü¶ x + x_1) c ‚àò cexp
hdg : Differentiable ‚ÑÇ g
hs : (g ‚Åª¬π' s).Countable
h_maps : MapsTo g R A
hc : ContinuousOn (f ‚àò g) R
‚ä¢ ‚à´ (Œ∏ : ‚Ñù) in sorryAx (Set ‚Ñù) true, I ‚Ä¢ f (circleMap c (rexp b) Œ∏) =
    ‚à´ (Œ∏ : ‚Ñù) in sorryAx (Set ‚Ñù) true, I ‚Ä¢ f (circleMap c (rexp a) Œ∏)","theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ‚ÑÇ}
    {r R : ‚Ñù} (h0 : 0 < r) (hle : r ‚â§ R) {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ‚àÄ z ‚àà (ball c R \ closedBall c r) \ s, DifferentiableAt ‚ÑÇ f z) :
    (‚àÆ z in C(c, R), (z - c)‚Åª¬π ‚Ä¢ f z) = ‚àÆ z in C(c, r), (z - c)‚Åª¬π ‚Ä¢ f z ",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r := ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R := ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left‚ÇÄ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine fun z hz => (hd (g z) ‚ü®?_, hz.2‚ü©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r; exact ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R; exact ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in [0:2 * œÄ], I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in [0:2 * œÄ], I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (¬∑ + ¬∑) c ‚àò exp
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R; exact hc.comp hdg.continuous.continuousOn h_maps
  replace hd :
    ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z
  ¬∑ refine fun z hz => (hd (g z) ‚ü®_, hz.2‚ü©).comp z (hdg _)
    simpa [dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd"
Mathlib/Data/Setoid/Basic.lean,Setoid.eqvGen_le,eqvGen_le,294082ef61697f884a3de4f53ea12c01eccb0563,:= by rw [eqvGen_eq]; exact inf‚Çõ_le h,error:  unknown identifier 'inf‚Çõ_le',"theorem eqvGen_le {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Setoid Œ±} (h : ‚àÄ x y, r x y ‚Üí s.Rel x y) :
    EqvGen.Setoid r ‚â§ s ",:= by rw [eqvGen_eq]; exact sInf_le h,:= by rw [eqvGen_eq]; exact inf‚Çõ_le h
Mathlib/MeasureTheory/Measure/Haar/OfBasis.lean,parallelepiped_comp_equiv,parallelepiped_comp_equiv,9e34a191034458a56331f976ff7400a26407c888,":= by
  simp only [parallelepiped]
  let K : (Œπ' ‚Üí ‚Ñù) ‚âÉ (Œπ ‚Üí ‚Ñù) := Equiv.piCongrLeft' (fun _a : Œπ' => ‚Ñù) e
  have : Icc (0 : Œπ ‚Üí ‚Ñù) 1 = K '' Icc (0 : Œπ' ‚Üí ‚Ñù) 1 := by
    rw [‚Üê Equiv.preimage_eq_iff_eq_image]
    ext x
    simp only [mem_preimage, mem_Icc, Pi.le_def, Pi.zero_apply, Equiv.piCongrLeft'_apply,
      Pi.one_apply]
    refine'
      ‚ü®fun h => ‚ü®fun i => _, fun i => _‚ü©, fun h =>
        ‚ü®fun i => h.1 (e.symm i), fun i => h.2 (e.symm i)‚ü©‚ü©
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.1 (e i)
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.2 (e i)
  rw [this, ‚Üê image_comp]
  congr 1 with x
  have := fun z : Œπ' ‚Üí ‚Ñù => e.symm.sum_comp fun i => z i ‚Ä¢ v (e i)
  simp_rw [Equiv.apply_symm_apply] at this
  simp_rw [Function.comp_apply, ge_iff_le, zero_le_one, not_true, gt_iff_lt, mem_image, mem_Icc,
    Equiv.piCongrLeft'_apply, this]","error:  type mismatch
  h‚úù
has type
  0 ‚â§ K x (e i) : Prop
but is expected to have type
  0 ‚â§ x i : Prop
error:  type mismatch
  h‚úù
has type
  K x (e i) ‚â§ 1 : Prop
but is expected to have type
  x i ‚â§ 1 : Prop
error:  simp made no progress","theorem parallelepiped_comp_equiv (v : Œπ ‚Üí E) (e : Œπ' ‚âÉ Œπ) :
    parallelepiped (v ‚àò e) = parallelepiped v ",":= by
  simp only [parallelepiped]
  let K : (Œπ' ‚Üí ‚Ñù) ‚âÉ (Œπ ‚Üí ‚Ñù) := Equiv.piCongrLeft' (fun _a : Œπ' => ‚Ñù) e
  have : Icc (0 : Œπ ‚Üí ‚Ñù) 1 = K '' Icc (0 : Œπ' ‚Üí ‚Ñù) 1 := by
    rw [‚Üê Equiv.preimage_eq_iff_eq_image]
    ext x
    simp only [K, mem_preimage, mem_Icc, Pi.le_def, Pi.zero_apply, Equiv.piCongrLeft'_apply,
      Pi.one_apply]
    refine
      ‚ü®fun h => ‚ü®fun i => ?_, fun i => ?_‚ü©, fun h =>
        ‚ü®fun i => h.1 (e.symm i), fun i => h.2 (e.symm i)‚ü©‚ü©
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.1 (e i)
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.2 (e i)
  rw [this, ‚Üê image_comp]
  congr 1 with x
  have := fun z : Œπ' ‚Üí ‚Ñù => e.symm.sum_comp fun i => z i ‚Ä¢ v (e i)
  simp_rw [Equiv.apply_symm_apply] at this
  simp_rw [Function.comp_apply, mem_image, mem_Icc, K, Equiv.piCongrLeft'_apply, this]",":= by
  simp only [parallelepiped]
  let K : (Œπ' ‚Üí ‚Ñù) ‚âÉ (Œπ ‚Üí ‚Ñù) := Equiv.piCongrLeft' (fun _a : Œπ' => ‚Ñù) e
  have : Icc (0 : Œπ ‚Üí ‚Ñù) 1 = K '' Icc (0 : Œπ' ‚Üí ‚Ñù) 1 := by
    rw [‚Üê Equiv.preimage_eq_iff_eq_image]
    ext x
    simp only [mem_preimage, mem_Icc, Pi.le_def, Pi.zero_apply, Equiv.piCongrLeft'_apply,
      Pi.one_apply]
    refine
      ‚ü®fun h => ‚ü®fun i => ?_, fun i => ?_‚ü©, fun h =>
        ‚ü®fun i => h.1 (e.symm i), fun i => h.2 (e.symm i)‚ü©‚ü©
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.1 (e i)
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.1 (e i)
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.2 (e i)
  rw [this, ‚Üê image_comp]
  congr 1 with x
  have := fun z : Œπ' ‚Üí ‚Ñù => e.symm.sum_comp fun i => z i ‚Ä¢ v (e i)
  simp_rw [Equiv.apply_symm_apply] at this
  simp_rw [Function.comp_apply, ge_iff_le, zero_le_one, not_true, gt_iff_lt, mem_image, mem_Icc,
    Equiv.piCongrLeft'_apply, this]"
Mathlib/Analysis/Convex/Mul.lean,convexOn_zpow,convexOn_zpow,54f7158db90360ed2142693f55c501ce19411627,"  | (n : ‚Ñï) => by
    simp_rw [zpow_ofNat]
    exact (convexOn_pow n).subset Ioi_subset_Ici_self (convex_Ioi _)
  | -[n+1] => by
    simp_rw [zpow_negSucc, ‚Üêinv_pow]
    refine (convexOn_iff_forall_pos.2 ‚ü®convex_Ioi _, ?_‚ü©).pow (fun x (hx : 0 < x) ‚Ü¶ by positivity) _
    rintro x (hx : 0 < x) y (hy : 0 < y) a b ha hb hab
    field_simp
    rw [div_le_div_iff, ‚Üêsub_nonneg]
    calc
      0 ‚â§ a * b * (x - y) ^ 2 := by positivity
      _ = _ := by obtain rfl := eq_sub_of_add_eq hab; ring
    all_goals positivity",error:  simp made no progress,"lemma convexOn_zpow : ‚àÄ n : ‚Ñ§, ConvexOn ùïú (Ioi 0) fun x : ùïú ‚Ü¶ x ^ n
","  | (n : ‚Ñï) => by
    simp_rw [zpow_natCast]
    exact (convexOn_pow n).subset Ioi_subset_Ici_self (convex_Ioi _)
  | -[n+1] => by
    simp_rw [zpow_negSucc, ‚Üê inv_pow]
    refine (convexOn_iff_forall_pos.2 ‚ü®convex_Ioi _, ?_‚ü©).pow (fun x (hx : 0 < x) ‚Ü¶ by positivity) _
    rintro x (hx : 0 < x) y (hy : 0 < y) a b ha hb hab
    field_simp
    rw [div_le_div_iff, ‚Üê sub_nonneg]
    ¬∑ calc
        0 ‚â§ a * b * (x - y) ^ 2 := by positivity
        _ = _ := by obtain rfl := eq_sub_of_add_eq hab; ring
    all_goals positivity",":= by
  | (n : ‚Ñï) => by
    simp_rw [zpow_ofNat]
    exact (convexOn_pow n).subset Ioi_subset_Ici_self (convex_Ioi _)
  | -[n+1] => by
    simp_rw [zpow_negSucc, ‚Üê inv_pow]
    refine (convexOn_iff_forall_pos.2 ‚ü®convex_Ioi _, ?_‚ü©).pow (fun x (hx : 0 < x) ‚Ü¶ by positivity) _
    rintro x (hx : 0 < x) y (hy : 0 < y) a b ha hb hab
    field_simp
    rw [div_le_div_iff, ‚Üê sub_nonneg]
    calc
      0 ‚â§ a * b * (x - y) ^ 2 := by positivity
      _ = _ := by obtain rfl := eq_sub_of_add_eq hab; ring
    all_goals positivity"
Mathlib/Data/List/Rotate.lean,List.reverse_rotate,reverse_rotate,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [‚Üê length_reverse l, ‚Üê rotate_eq_iff]
  induction' n with n hn generalizing l
  ¬∑ simp
  ¬∑ cases' l with hd tl
    ¬∑ simp
    ¬∑ rw [rotate_cons_succ, Nat.succ_eq_add_one, ‚Üê rotate_rotate, hn]
      simp","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ.cons
Œ± : Type u
n : ‚Ñï
hn : ‚àÄ (l : List Œ±), (l.rotate n).reverse.rotate n = l.reverse
hd : Œ±
tl : List Œ±
‚ä¢ ((tl ++ [hd]).rotate n).reverse.rotate (n + 1) = (hd :: tl).reverse
warning:  @IsRotated does not have a doc string","theorem reverse_rotate (l : List Œ±) (n : ‚Ñï) :
    (l.rotate n).reverse = l.reverse.rotate (l.length - n % l.length) ",":= by
  rw [‚Üê length_reverse l, ‚Üê rotate_eq_iff]
  induction' n with n hn generalizing l
  ¬∑ simp
  ¬∑ cases' l with hd tl
    ¬∑ simp
    ¬∑ rw [rotate_cons_succ, ‚Üê rotate_rotate, hn]
      simp",":= by
  rw [‚Üê length_reverse l, ‚Üê rotate_eq_iff]
  induction' n with n hn generalizing l
  ¬∑ cases' l with hd tl
    ¬∑ simp
    ¬∑ rw [rotate_cons_succ, Nat.succ_eq_add_one, ‚Üê rotate_rotate, hn]
      simp"
Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean,CategoryTheory.InjectiveResolution.exact‚ÇÄ,exact‚ÇÄ,9072ff84a0d139a344bf9eed4a00c4cd27596c79,:=,error:  unexpected token 'def'; expected term,"lemma exact‚ÇÄ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.Œπ_f_zero_comp_complex_d).Exact ",":=
  ShortComplex.exact_of_f_is_kernel _ I.isLimitKernelFork",":=
  ShortComplex.mk _ _ I.Œπ_f_zero_comp_complex_d"
Mathlib/NumberTheory/SumFourSquares.lean,Nat.euler_four_squares,Nat.euler_four_squares,151eb46ac9da80421706d0822fba0ae70d6ae557,":= by
  rw [‚Üê Int.coe_nat_inj']
  push_cast
  simp only [sq_abs, _root_.euler_four_squares]","error:  unknown constant 'Int.coe_nat_inj''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.20476
a b c d x y z w : ‚Ñï
‚ä¢ (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw).natAbs ^ 2 + (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz).natAbs ^ 2 +
        (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy).natAbs ^ 2 +
      (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx).natAbs ^ 2 =
    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)","theorem Nat.euler_four_squares (a b c d x y z w : ‚Ñï) :
    ((a : ‚Ñ§) * x - b * y - c * z - d * w).natAbs ^ 2 +
      ((a : ‚Ñ§) * y + b * x + c * w - d * z).natAbs ^ 2 +
      ((a : ‚Ñ§) * z - b * w + c * x + d * y).natAbs ^ 2 +
      ((a : ‚Ñ§) * w + b * z - c * y + d * x).natAbs ^ 2 =
      (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) ",":= by
  rw [‚Üê Int.natCast_inj]
  push_cast
  simp only [sq_abs, _root_.euler_four_squares]",":= by
  rw [‚Üê Int.coe_natCast]
  push_cast
  simp only [sq_abs, _root_.euler_four_squares]"
Mathlib/Combinatorics/Schnirelmann.lean,schnirelmannDensity_le_of_not_mem,schnirelmannDensity_le_of_not_mem,bb7a43e4a602b9c4e5cfce963ad6700c7d4c658d,":= by
  rcases k.eq_zero_or_pos with rfl | hk'
  ¬∑ simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [‚Üê one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw [‚Üê Nat.cast_pred hk', Nat.cast_le]
  suffices : (Ioc 0 k).filter (¬∑ ‚àà A) ‚äÜ Ioo 0 k; exact (card_le_card this).trans_eq (by simp)
  rw [‚Üê Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _",error:  unexpected token ':'; expected term,"lemma schnirelmannDensity_le_of_not_mem {k : ‚Ñï} (hk : k ‚àâ A) :
    schnirelmannDensity A ‚â§ 1 - (k‚Åª¬π : ‚Ñù) ",":= by
  rcases k.eq_zero_or_pos with rfl | hk'
  ¬∑ simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [‚Üê one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  gcongr
  rw [‚Üê Nat.cast_pred hk', Nat.cast_le]
  suffices (Ioc 0 k).filter (¬∑ ‚àà A) ‚äÜ Ioo 0 k from (card_le_card this).trans_eq (by simp)
  rw [‚Üê Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _",":= by
  rcases k.eq_zero_or_pos with rfl | hk'
  ¬∑ simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [‚Üê one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw [‚Üê Nat.cast_pred hk', Nat.cast_le]
  suffices (Ioc 0 k).filter (¬∑ ‚àà A) ‚äÜ Ioo 0 k from (card_le_card this).trans_eq (by simp)
  rw [‚Üê Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _"
Mathlib/CategoryTheory/Triangulated/Subcategory.lean,CategoryTheory.Triangulated.Subcategory.ext‚ÇÇ,ext‚ÇÇ,660d4d5e85504851f32fdcb363260a8048d0609c,":= by
  simpa only [S.set.isoClosure_eq_self] using S.ext‚ÇÇ' T hT h‚ÇÅ h‚ÇÉ","error:  invalid field 'set', the environment does not contain 'CategoryTheory.Triangulated.Subcategory.set'
  S
has type
  Subcategory C
error:  type mismatch
  h‚úù
has type
  CategoryTheory.isoClosure S.P T.obj‚ÇÇ : Prop
but is expected to have type
  S.P T.obj‚ÇÇ : Prop","lemma ext‚ÇÇ [ClosedUnderIsomorphisms S.P]
    (T : Triangle C) (hT : T ‚àà distTriang C) (h‚ÇÅ : S.P T.obj‚ÇÅ)
    (h‚ÇÉ : S.P T.obj‚ÇÉ) : S.P T.obj‚ÇÇ ",":= by
  simpa only [isoClosure_eq_self] using S.ext‚ÇÇ' T hT h‚ÇÅ h‚ÇÉ",":= by
  simpa only [S.isoClosure_eq_self] using S.ext‚ÇÇ' T hT h‚ÇÅ h‚ÇÉ"
Mathlib/Data/Int/Log.lean,Int.zpow_lt_iff_lt_clog,zpow_lt_iff_lt_clog,693fd79515903b10b1d31f10dccfc49e633cf7ee,":=
  (@GaloisConnection.lt_iff_lt _ _ _ _ _ _ (clogZpowGi R hb).gc ‚ü®r, hr‚ü© x).symm","error:  unknown identifier 'clogZpowGi'
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  ?m.70095","theorem zpow_lt_iff_lt_clog {b : ‚Ñï} (hb : 1 < b) {x : ‚Ñ§} {r : R} (hr : 0 < r) :
    (b : R) ^ x < r ‚Üî x < clog b r ",":=
  (@GaloisConnection.lt_iff_lt _ _ _ _ _ _ (clogZPowGi R hb).gc ‚ü®r, hr‚ü© x).symm",":=
  (@GaloisConnection.lt_iff_lt _ _ _ _ _ _ (clogZpowGi R hb).gc ‚ü®r, hr‚ü© x).symm"
Mathlib/Analysis/NormedSpace/Star/Spectrum.lean,IsSelfAdjoint.mem_spectrum_eq_re,IsSelfAdjoint.mem_spectrum_eq_re,51d59c1b99e04eb6fe597dd39de4e4fcfa8512d2,":= by
  letI : Algebra ‚Ñö A := RestrictScalars.algebra ‚Ñö ‚ÑÇ A
  have hu := exp_mem_unitary_of_mem_skewAdjoint ‚ÑÇ (ha.smul_mem_skewAdjoint conj_I)
  let Iu := Units.mk0 I I_ne_zero
  have : _root_.exp (I ‚Ä¢ z) ‚àà spectrum ‚ÑÇ (_root_.exp (I ‚Ä¢ a)) := by
    simpa only [Units.smul_def, Units.val_mk0] using
      spectrum.exp_mem_exp (Iu ‚Ä¢ a) (smul_mem_smul_iff.mpr hz)
  exact Complex.ext (ofReal_re _) <| by
    simpa only [‚Üê Complex.exp_eq_exp_‚ÑÇ, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,
      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using
      spectrum.subset_circle_of_unitary hu this","error:  unknown identifier '_root_.exp'
error:  unknown identifier '_root_.exp'
error:  unsolved goals
A : Type u_1
inst‚úù‚Åµ : NormedRing A
inst‚úù‚Å¥ : NormedAlgebra ‚ÑÇ A
inst‚úù¬≥ : CompleteSpace A
inst‚úù¬≤ : StarRing A
inst‚úù¬π : CstarRing A
inst‚úù : StarModule ‚ÑÇ A
a : A
ha : IsSelfAdjoint a
z : ‚ÑÇ
hz : z ‚àà spectrum ‚ÑÇ a
this : Algebra ‚Ñö A := RestrictScalars.algebra ‚Ñö ‚ÑÇ A
hu : NormedSpace.exp ‚ÑÇ (I ‚Ä¢ a) ‚àà unitary A
Iu : ‚ÑÇÀ£ := Units.mk0 I I_ne_zero
‚ä¢ z = ‚Üëz.re","theorem IsSelfAdjoint.mem_spectrum_eq_re [StarModule ‚ÑÇ A] {a : A} (ha : IsSelfAdjoint a) {z : ‚ÑÇ}
    (hz : z ‚àà spectrum ‚ÑÇ a) : z = z.re ",":= by
  have hu := exp_mem_unitary_of_mem_skewAdjoint ‚ÑÇ (ha.smul_mem_skewAdjoint conj_I)
  let Iu := Units.mk0 I I_ne_zero
  have : NormedSpace.exp ‚ÑÇ (I ‚Ä¢ z) ‚àà spectrum ‚ÑÇ (NormedSpace.exp ‚ÑÇ (I ‚Ä¢ a)) := by
    simpa only [Units.smul_def, Units.val_mk0] using
      spectrum.exp_mem_exp (Iu ‚Ä¢ a) (smul_mem_smul_iff.mpr hz)
  exact Complex.ext (ofReal_re _) <| by
    simpa only [‚Üê Complex.exp_eq_exp_‚ÑÇ, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,
      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using
      spectrum.subset_circle_of_unitary hu this",":= by
  letI : Algebra ‚Ñö A := RestrictScalars.algebra ‚Ñö ‚ÑÇ A
  have hu := exp_mem_unitary_of_mem_skewAdjoint ‚ÑÇ (ha.smul_mem_skewAdjoint conj_I)
  let Iu := Units.mk0 I I_ne_zero
  have : _root_.exp (I ‚Ä¢ z) ‚àà spectrum ‚ÑÇ (_root_.exp (I ‚Ä¢ a)) := by
    simpa only [Units.smul_def, Units.val_mk0] using
      exp_mem_exp (Iu ‚Ä¢ a) (smul_mem_smul_iff.mpr hz)
  exact Complex.ext (ofReal_re _) <| by
    simpa only [‚Üê Complex.exp_eq_exp_‚ÑÇ, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,
      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using
      spectrum.subset_circle_of_unitary hu this"
Mathlib/NumberTheory/Padics/PadicNorm.lean,padicNorm.int_eq_one_iff,int_eq_one_iff,c47ebbbece0d449dca95c589513159cdc2bab40d,":= by
  nth_rw 2 [‚Üê pow_one p]
  simp only [dvd_iff_norm_le, Int.cast_ofNat, Nat.cast_one, zpow_neg, zpow_one, not_le]
  constructor
  ¬∑ intro h
    rw [h, inv_lt_one_iff_of_pos] <;> norm_cast
    ¬∑ exact Nat.Prime.one_lt Fact.out
    ¬∑ exact Nat.Prime.pos Fact.out
  ¬∑ simp only [padicNorm]
    split_ifs
    ¬∑ rw [inv_lt_zero, ‚Üê Nat.cast_zero, Nat.cast_lt]
      intro h
      exact (Nat.not_lt_zero p h).elim
    ¬∑ have : 1 < (p : ‚Ñö) := by norm_cast; exact Nat.Prime.one_lt (Fact.out : Nat.Prime p)
      rw [‚Üê zpow_neg_one, zpow_lt_iff_lt this]
      have : 0 ‚â§ padicValRat p m
      simp only [of_int, Nat.cast_nonneg]
      intro h
      rw [‚Üê zpow_zero (p : ‚Ñö), zpow_inj] <;> linarith","error:  unexpected identifier; expected '|'
error:  unsolved goals
case neg
p : ‚Ñï
hp : Fact (Nat.Prime p)
m : ‚Ñ§
h‚úù : ¬¨‚Üëm = 0
this‚úù : 1 < ‚Üëp
this : 0 ‚â§ padicValRat p ‚Üëm
‚ä¢ -1 < -padicValRat p ‚Üëm ‚Üí ‚Üëp ^ (-padicValRat p ‚Üëm) = 1",theorem int_eq_one_iff (m : ‚Ñ§) : padicNorm p m = 1 ‚Üî ¬¨(p : ‚Ñ§) ‚à£ m ,":= by
  nth_rw 2 [‚Üê pow_one p]
  simp only [dvd_iff_norm_le, Int.cast_natCast, Nat.cast_one, zpow_neg, zpow_one, not_le]
  constructor
  ¬∑ intro h
    rw [h, inv_lt_one_iff_of_pos] <;> norm_cast
    ¬∑ exact Nat.Prime.one_lt Fact.out
    ¬∑ exact Nat.Prime.pos Fact.out
  ¬∑ simp only [padicNorm]
    split_ifs
    ¬∑ rw [inv_lt_zero, ‚Üê Nat.cast_zero, Nat.cast_lt]
      intro h
      exact (Nat.not_lt_zero p h).elim
    ¬∑ have : 1 < (p : ‚Ñö) := by norm_cast; exact Nat.Prime.one_lt (Fact.out : Nat.Prime p)
      rw [‚Üê zpow_neg_one, zpow_lt_iff_lt this]
      have : 0 ‚â§ padicValRat p m := by simp only [of_int, Nat.cast_nonneg]
      intro h
      rw [‚Üê zpow_zero (p : ‚Ñö), zpow_inj] <;> linarith",":= by
  nth_rw 2 [‚Üê pow_one p]
  simp only [dvd_iff_norm_le, Int.cast_ofNat, Nat.cast_one, zpow_neg, zpow_one, not_le]
  constructor
  ¬∑ intro h
    rw [h, inv_lt_one_iff_of_pos] <;> norm_cast
    ¬∑ exact Nat.Prime.one_lt Fact.out
    ¬∑ exact Nat.Prime.pos Fact.out
  ¬∑ simp only [padicNorm]
    split_ifs
    ¬∑ rw [inv_lt_zero, ‚Üê Nat.cast_zero, Nat.cast_lt]
      intro h
      exact (Nat.not_lt_zero p h).elim
    ¬∑ have : 1 < (p : ‚Ñö) := by norm_cast; exact Nat.Prime.one_lt (Fact.out : Nat.Prime p)
      rw [‚Üê zpow_neg_one, zpow_lt_iff_lt this]
      have : 0 ‚â§ padicValRat p m
      simp only [of_int, Nat.cast_nonneg]
      intro h
      rw [‚Üê zpow_zero (p : ‚Ñö), zpow_inj] <;> linarith"
Mathlib/RingTheory/NonUnitalSubring/Basic.lean,NonUnitalSubring.mem_iSup_of_directed,mem_iSup_of_directed,1faa648b0b1359dec61956304fa51ac01bdbb219,":= by
  refine ‚ü®?_, fun ‚ü®i, hi‚ü© ‚Ü¶ le_iSup S i hi‚ü©
  let U : NonUnitalSubring R :=
    NonUnitalSubring.mk' (‚ãÉ i, (S i : Set R)) (‚®Ü i, (S i).toSubsemigroup) (‚®Ü i, (S i).toAddSubgroup)
      (Subsemigroup.coe_iSup_of_directed hS) (AddSubgroup.coe_iSup_of_directed hS)
  suffices ‚®Ü i, S i ‚â§ U by simpa using @this x
  exact iSup_le fun i x hx ‚Ü¶ Set.mem_iUnion.2 ‚ü®i, hx‚ü©","error:  type mismatch
  h‚úù
has type
  x ‚àà ‚®Ü i, S i ‚Üí x ‚àà U : Prop
but is expected to have type
  x ‚àà ‚®Ü i, S i ‚Üí ‚àÉ i, x ‚àà S i : Prop","theorem mem_iSup_of_directed {Œπ} [hŒπ : Nonempty Œπ] {S : Œπ ‚Üí NonUnitalSubring R}
    (hS : Directed (¬∑ ‚â§ ¬∑) S) {x : R} : (x ‚àà ‚®Ü i, S i) ‚Üî ‚àÉ i, x ‚àà S i ",":= by
  refine ‚ü®?_, fun ‚ü®i, hi‚ü© ‚Ü¶ le_iSup S i hi‚ü©
  let U : NonUnitalSubring R :=
    NonUnitalSubring.mk' (‚ãÉ i, (S i : Set R)) (‚®Ü i, (S i).toSubsemigroup) (‚®Ü i, (S i).toAddSubgroup)
      (Subsemigroup.coe_iSup_of_directed hS) (AddSubgroup.coe_iSup_of_directed hS)
  suffices ‚®Ü i, S i ‚â§ U by simpa [U] using @this x
  exact iSup_le fun i x hx ‚Ü¶ Set.mem_iUnion.2 ‚ü®i, hx‚ü©",":= by
  refine ‚ü®?_, fun ‚ü®i, hi‚ü© ‚Ü¶ le_iSup S i hi‚ü©
  let U : NonUnitalSubring R :=
    NonUnitalSubring.mk' (‚ãÉ i, (S i : Set R)) (‚®Ü i, (S i).toSubsemigroup) (‚®Ü i, (S i).toAddSubgroup)
      (Subsemigroup.coe_iSup_of_directed hS) (AddSubgroup.coe_iSup_of_directed hS)
  suffices ‚®Ü i, S i ‚â§ U by simpa using @this x
  exact iSup_le fun i x hx ‚Ü¶ Set.mem_iUnion.2 ‚ü®i, hx‚ü©"
Mathlib/Topology/UniformSpace/Basic.lean,ball_inter_left,ball_inter_left,f33a8c19a1c116af0ea9bb6af0c85b1ef25cb15f,":=
  ball_mono (inter_subset_left V W) x","warning:  @compRel does not have a doc string
warning:  uniformity does not have a doc string
error:  application type mismatch
  inter_subset_left V
argument
  V
has type
  Set (Œ≤ √ó Œ≤) : Type ub
but is expected to have type
  ?m.66165 ‚àà ?m.66163 ‚à© ?m.66164 : Prop",theorem ball_inter_left (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x V ,":=
  ball_mono inter_subset_left x",":=
  ball_mono inter_subset_left"
Mathlib/Algebra/Homology/ShortComplex/QuasiIso.lean,CategoryTheory.ShortComplex.quasiIso_of_arrow_mk_iso,quasiIso_of_arrow_mk_iso,d44ca292ff3e253c9a3629e67ad44fc36a50984e,":= by
  let Œ± : S‚ÇÉ ‚ü∂ S‚ÇÅ := e.inv.left
  let Œ≤ : S‚ÇÇ ‚ü∂ S‚ÇÑ := e.hom.right
  suffices œÜ' = Œ± ‚â´ œÜ ‚â´ Œ≤ by
    rw [this]
    infer_instance
  simp only [Arrow.w_mk_right_assoc, Arrow.mk_left, Arrow.mk_right, Arrow.mk_hom,
    ‚Üê Arrow.comp_right, e.inv_hom_id, Arrow.id_right, comp_id]",error:  simp made no progress,"lemma quasiIso_of_arrow_mk_iso (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (œÜ' : S‚ÇÉ ‚ü∂ S‚ÇÑ) (e : Arrow.mk œÜ ‚âÖ Arrow.mk œÜ')
    [hœÜ : QuasiIso œÜ] : QuasiIso œÜ' ",":= by
  let Œ± : S‚ÇÉ ‚ü∂ S‚ÇÅ := e.inv.left
  let Œ≤ : S‚ÇÇ ‚ü∂ S‚ÇÑ := e.hom.right
  suffices œÜ' = Œ± ‚â´ œÜ ‚â´ Œ≤ by
    rw [this]
    infer_instance
  simp only [Œ±, Œ≤, Arrow.w_mk_right_assoc, Arrow.mk_left, Arrow.mk_right, Arrow.mk_hom,
    ‚Üê Arrow.comp_right, e.inv_hom_id, Arrow.id_right, comp_id]",":= by
  let Œ± : S‚ÇÉ ‚ü∂ S‚ÇÅ := e.inv.left
  let Œ≤ : S‚ÇÇ ‚ü∂ S‚ÇÑ := e.hom.right
  suffices œÜ' = Œ± ‚â´ œÜ ‚â´ Œ≤ by
    rw [this]
    infer_instance
  simp only [Arrow.w_mk_right_assoc, Arrow.mk_left, Arrow.mk_right, Arrow.id_right, comp_id]"
Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean,WeierstrassCurve.Projective.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,b999f5fc5a622c176ec2ff740c2226c15d01d750,":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Fin.isValue, nonsingular_iff, equation_iff, Matrix.cons_val_one, Matrix.head_cons,
      Matrix.cons_val_two, Matrix.tail_cons, mul_zero, Matrix.cons_val_zero, add_zero, ne_eq,
      OfNat.ofNat_ne_zero, not_false_eq_true, zero_pow, zero_eq_mul, pow_eq_zero_iff, sub_self,
      not_true_eq_false, false_or] at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, or_true, not_true_eq_false, mul_zero, zero_mul, add_zero, pow_eq_zero_iff, false_or,
      true_and, pow_eq_zero hQ.left.symm] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]‚ü©","error:  application type mismatch
  div_mul_cancel ?m.248490 hQ
argument
  hQ
has type
  ¬¨Q 1 = 0 : Prop
but is expected to have type
  ?m.248488 : Type ?u.248487
error:  unsolved goals
R : Type u
inst‚úù¬π : CommRing R
W‚úù : Projective R
F : Type u
inst‚úù : Field F
W : Projective F
P Q : Fin 3 ‚Üí F
hPz : P 2 = 0
hQz : Q 2 = 0
hP : ¬¨P 1 = 0
hQ : ¬¨Q 1 = 0
‚ä¢ ![0, P 1 / Q 1 * Q 1, 0] = ![0, P 1, 0]","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Fin.isValue, nonsingular_iff, equation_iff, Matrix.cons_val_one, Matrix.head_cons,
      Matrix.cons_val_two, Matrix.tail_cons, mul_zero, Matrix.cons_val_zero, add_zero, ne_eq,
      OfNat.ofNat_ne_zero, not_false_eq_true, zero_pow, zero_eq_mul, pow_eq_zero_iff, sub_self,
      not_true_eq_false, false_or] at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, or_true, not_true_eq_false, mul_zero, zero_mul, add_zero, pow_eq_zero_iff, false_or,
      true_and, pow_eq_zero hQ.left.symm] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]‚ü©"
Mathlib/MeasureTheory/Decomposition/SignedLebesgue.lean,MeasureTheory.SignedMeasure.measurable_rnDeriv,measurable_rnDeriv,1d139ad79ce099e15226e6bbd1cf8e7d24be07d3,":= by
  rw [rnDeriv_def]
  fun_prop","error:  `fun_prop` was unable to prove `Measurable fun x ‚Ü¶
  (s.toJordanDecomposition.posPart.rnDeriv Œº x).toReal - (s.toJordanDecomposition.negPart.rnDeriv Œº x).toReal`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.posPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.posPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.posPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.posPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`",theorem measurable_rnDeriv (s : SignedMeasure Œ±) (Œº : Measure Œ±) : Measurable (rnDeriv s Œº) ,":= by
  rw [rnDeriv_def]
  apply Measurable.add
  ¬∑ exact ((Measure.measurable_rnDeriv _ Œº).ennreal_toNNReal).coe_nnreal_real
  ¬∑ rw [measurable_neg_iff]
    exact (Measure.measurable_rnDeriv _ Œº).ennreal_toNNReal.coe_nnreal_real",":= by
  rw [rnDeriv_def]
  fun_prop"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.rightInvSeq_concat,rightInvSeq_concat,b0663dabc91d2626cefc80c8db6537ea3fe88347,":= by
  induction' œâ with j œâ ih
  ¬∑ simp
  ¬∑ dsimp [rightInvSeq]
    rw [ih]
    simp only [concat_eq_append, wordProd_append, wordProd_cons, wordProd_nil, mul_one, mul_inv_rev,
      simple_inv, cons_append, cons.injEq, and_true]
    group","error:  unknown identifier 'simple_inv'
error:  unsolved goals
case cons
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
i j : B
œâ : List B
ih : cs.rightInvSeq (œâ.concat i) = (List.map (‚áë(MulAut.conj (cs.simple i))) (cs.rightInvSeq œâ)).concat (cs.simple i)
‚ä¢ cs.simple i ^ (-1) * cs.wordProd œâ ^ (-1) * cs.simple j * cs.wordProd œâ * cs.simple i =
    cs.simple i * cs.wordProd œâ ^ (-1) * cs.simple j * cs.wordProd œâ * cs.simple i ^ (-1)","theorem rightInvSeq_concat (œâ : List B) (i : B) :
    ris (œâ.concat i) = (List.map (MulAut.conj (s i)) (ris œâ)).concat (s i) ",":= by
  induction' œâ with j œâ ih
  ¬∑ simp
  ¬∑ dsimp [rightInvSeq]
    rw [ih]
    simp only [concat_eq_append, wordProd_append, wordProd_cons, wordProd_nil, mul_one, mul_inv_rev,
      inv_simple, cons_append, cons.injEq, and_true]
    group",":= by
  induction' œâ with j œâ ih
  ¬∑ simp
  ¬∑ dsimp [rightInvSeq]
    rw [ih]
    simp only [concat_eq_append, wordProd_append, wordProd_cons, wordProd_nil, mul_one, mul_inv_rev,
      simple_inv, cons_append, cons.injEq, and_true]
    group"
Mathlib/NumberTheory/NumberField/Embeddings.lean,NumberField.Embeddings.pow_eq_one_of_norm_eq_one,pow_eq_one_of_norm_eq_one,05c4c02a126a220762b13df794c36c771e2fbb7d,":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ ¬∑ : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  wlog hlt : b < a
  ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
  refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
  rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
  refine h.resolve_right fun hp => ?_
  specialize hx (IsAlgClosed.lift (NumberField.isAlgebraic K)).toRingHom
  rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsAlgClosed.lift ?m.50146
has type
  ?m.49328
error:  application type mismatch
  IsAlgClosed.lift ‚ãØ
argument
  NumberField.isAlgebraic K
has type
  Algebra.IsAlgebraic ‚Ñö K : Prop
but is expected to have type
  ?m.49333 : Type ?u.49325","theorem pow_eq_one_of_norm_eq_one {x : K} (hxi : IsIntegral ‚Ñ§ x) (hx : ‚àÄ œÜ : K ‚Üí+* A, ‚ÄñœÜ x‚Äñ = 1) :
    ‚àÉ (n : ‚Ñï) (_ : 0 < n), x ^ n = 1 ",":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ ¬∑ : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  wlog hlt : b < a
  ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
  refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
  rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
  refine h.resolve_right fun hp => ?_
  specialize hx (IsAlgClosed.lift (R := ‚Ñö)).toRingHom
  rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx",":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ ¬∑ : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  wlog hlt : b < a
  ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
  refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
  rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
  refine h.resolve_right fun hp => ?_
  specialize hx (IsAlgClosed.lift (NumberField.isAlgebraic K)).toRingHom
  rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx"
Mathlib/AlgebraicGeometry/Morphisms/QuasiCompact.lean,AlgebraicGeometry.exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact,exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact,6760b7bac3bfa3ac0abfbd42adefd6be57df857c,":= by
  obtain ‚ü®s, hs, e‚ü© := (isCompactOpen_iff_eq_finset_affine_union U.1).mp ‚ü®hU, U.2‚ü©
  replace e : U = iSup fun i : s => (i : Opens X) := by
    ext1; simpa using e
  have h‚ÇÅ : ‚àÄ i : s, i.1.1 ‚â§ U := by
    intro i
    change (i : Opens X) ‚â§ U
    rw [e]
    exact le_iSup (fun (i : s) => (i : Opens (X.toPresheafedSpace))) _
  have H' := fun i : s =>
    exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isAffineOpen X i.1.2
      (X.presheaf.map (homOfLE (h‚ÇÅ i)).op x) (X.presheaf.map (homOfLE (h‚ÇÅ i)).op f) ?_
  swap
  ¬∑ delta TopCat.Presheaf.restrictOpen TopCat.Presheaf.restrict at H ‚ä¢
    convert congr_arg (X.presheaf.map (homOfLE _).op) H
    ¬∑ rw [‚Üê comp_apply, ‚Üê comp_apply]
      ¬∑ simp only [‚Üê Functor.map_comp]
        rfl
      ¬∑ simp only [Scheme.basicOpen_res, ge_iff_le, inf_le_right]
    ¬∑ rw [map_zero]
  choose n hn using H'
  haveI := hs.to_subtype
  cases nonempty_fintype s
  use Finset.univ.sup n
  suffices ‚àÄ i : s, X.presheaf.map (homOfLE (h‚ÇÅ i)).op (f ^ Finset.univ.sup n * x) = 0 by
    subst e
    apply TopCat.Sheaf.eq_of_locally_eq X.sheaf fun i : s => (i : Opens X)
    intro i
    rw [map_zero]
    apply this
  intro i
  replace hn :=
    congr_arg (fun x => X.presheaf.map (homOfLE (h‚ÇÅ i)).op (f ^ (Finset.univ.sup n - n i)) * x)
      (hn i)
  dsimp at hn
  simp only [‚Üê map_mul, ‚Üê map_pow] at hn
  rwa [mul_zero, ‚Üê mul_assoc, ‚Üê pow_add, tsub_add_cancel_of_le] at hn
  apply Finset.le_sup (Finset.mem_univ i)","error:  no goals to be solved
error:  unsolved goals
case intro.intro.refine_1.convert_1
X‚úù Y : Scheme
f‚úù : X‚úù ‚ü∂ Y
Z X : Scheme
U : Opens ‚Üë‚ÜëX.toPresheafedSpace
hU : IsCompact U.carrier
x f : ‚ÜëŒì(X, U)
H : (X.presheaf.map (homOfLE ‚ãØ).op) x = 0
s : Set ‚ÜëX.affineOpens
hs : s.Finite
e : U = ‚®Ü i, ‚Üë‚Üëi
h‚ÇÅ : ‚àÄ (i : ‚Üës), ‚Üë‚Üëi ‚â§ U
i : ‚Üës
‚ä¢ X.basicOpen ((X.presheaf.map (homOfLE ‚ãØ).op) f) ‚â§ X.basicOpen f","theorem exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact (X : Scheme.{u})
    {U : Opens X} (hU : IsCompact U.1) (x f : Œì(X, U))
    (H : x |_ X.basicOpen f = 0) : ‚àÉ n : ‚Ñï, f ^ n * x = 0 ",":= by
  obtain ‚ü®s, hs, e‚ü© := (isCompactOpen_iff_eq_finset_affine_union U.1).mp ‚ü®hU, U.2‚ü©
  replace e : U = iSup fun i : s => (i : Opens X) := by
    ext1; simpa using e
  have h‚ÇÅ : ‚àÄ i : s, i.1.1 ‚â§ U := by
    intro i
    change (i : Opens X) ‚â§ U
    rw [e]
    exact le_iSup (fun (i : s) => (i : Opens (X.toPresheafedSpace))) _
  have H' := fun i : s =>
    exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isAffineOpen X i.1.2
      (X.presheaf.map (homOfLE (h‚ÇÅ i)).op x) (X.presheaf.map (homOfLE (h‚ÇÅ i)).op f) ?_
  swap
  ¬∑ delta TopCat.Presheaf.restrictOpen TopCat.Presheaf.restrict at H ‚ä¢
    convert congr_arg (X.presheaf.map (homOfLE _).op) H
    ¬∑ rw [‚Üê comp_apply, ‚Üê comp_apply]
      ¬∑ simp only [‚Üê Functor.map_comp]
        rfl
    ¬∑ rw [map_zero]
    ¬∑ simp only [Scheme.basicOpen_res, ge_iff_le, inf_le_right]
  choose n hn using H'
  haveI := hs.to_subtype
  cases nonempty_fintype s
  use Finset.univ.sup n
  suffices ‚àÄ i : s, X.presheaf.map (homOfLE (h‚ÇÅ i)).op (f ^ Finset.univ.sup n * x) = 0 by
    subst e
    apply TopCat.Sheaf.eq_of_locally_eq X.sheaf fun i : s => (i : Opens X)
    intro i
    rw [map_zero]
    apply this
  intro i
  replace hn :=
    congr_arg (fun x => X.presheaf.map (homOfLE (h‚ÇÅ i)).op (f ^ (Finset.univ.sup n - n i)) * x)
      (hn i)
  dsimp at hn
  simp only [‚Üê map_mul, ‚Üê map_pow] at hn
  rwa [mul_zero, ‚Üê mul_assoc, ‚Üê pow_add, tsub_add_cancel_of_le] at hn
  apply Finset.le_sup (Finset.mem_univ i)",":= by
  obtain ‚ü®s, hs, e‚ü© := (isCompactOpen_iff_eq_finset_affine_union U.1).mp ‚ü®hU, U.2‚ü©
  replace e : U = iSup fun i : s => (i : Opens X) := by
    ext1; simpa using e
  have h‚ÇÅ : ‚àÄ i : s, i.1.1 ‚â§ U := by
    intro i
    change (i : Opens X) ‚â§ U
    rw [e]
    exact le_iSup (fun (i : s) => (i : Opens (X.toPresheafedSpace))) _
  have H' := fun i : s =>
    exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isAffineOpen X i.1.2
      (X.presheaf.map (homOfLE (h‚ÇÅ i)).op x) (X.presheaf.map (homOfLE (h‚ÇÅ i)).op f) ?_
  swap
  ¬∑ delta TopCat.Presheaf.restrictOpen TopCat.Presheaf.restrict at H ‚ä¢
    convert congr_arg (X.presheaf.map (homOfLE _).op) H
    ¬∑ rw [‚Üê comp_apply, ‚Üê comp_apply]
      ¬∑ simp only [‚Üê Functor.map_comp]
        rfl
      ¬∑ simp only [Scheme.basicOpen_res, ge_iff_le, inf_le_right]
    ¬∑ rw [map_zero]
  choose n hn using H'
  haveI := hs.to_subtype
  cases nonempty_fintype s
  use Finset.univ.sup n
  suffices ‚àÄ i : s, X.presheaf.map (homOfLE (h‚ÇÅ i)).op (f ^ Finset.univ.sup n * x) = 0 by
    subst e
    apply TopCat.Sheaf.eq_of_locally_eq X.sheaf fun i : s => (i : Opens X)
    intro i
    rw [map_zero]
    apply this
  intro i
  replace hn :=
    congr_arg (fun x => X.presheaf.map (homOfLE (h‚ÇÅ i)).op (f ^ Finset.univ.sup n * x)
      (hn i)
  dsimp at hn
  simp only [‚Üê map_mul, ‚Üê map_pow] at hn
  rwa [mul_zero, ‚Üê mul_assoc, ‚Üê pow_add, tsub_add_cancel_of_le] at hn
  apply Finset.le_sup (Finset.mem_univ i)"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicOn.inv,inv,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  rcases hf with ‚ü®m, hf‚ü©
  by_cases h_eq : (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
  ¬∑ 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  ¬∑ 
    obtain ‚ü®n, g, hg_an, hg_ne, hg_eq‚ü© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ùïú x).sub analyticAt_const).pow _
    refine ‚ü®n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_‚ü©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    ¬∑ simp only [sub_self, pow_succ, zero_mul, zero_smul]
    ¬∑ simp_rw [smul_eq_mul] at hfg ‚ä¢
      have aux1 : f z ‚â† 0 := by
        have : (z - x) ^ n * g z ‚â† 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [‚Üê hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ, mul_assoc, hfg]
      ring","error:  unsolved goals
case h.inl
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí ùïú
m n : ‚Ñï
g : ùïú ‚Üí ùïú
z : ùïú
hg_ne' : g z ‚â† 0
hf : AnalyticAt ùïú (fun z_1 ‚Ü¶ (z_1 - z) ^ m ‚Ä¢ f z_1) z
h_eq : ¬¨(fun z_1 ‚Ü¶ (z_1 - z) ^ m ‚Ä¢ f z_1) =·∂†[ùìù z] 0
hg_an : AnalyticAt ùïú g z
hg_ne : g z ‚â† 0
hg_eq : ‚àÄ·∂† (z_1 : ùïú) in ùìù z, (z_1 - z) ^ m ‚Ä¢ f z_1 = (z_1 - z) ^ n ‚Ä¢ g z_1
this : AnalyticAt ùïú (fun z_1 ‚Ü¶ (z_1 - z) ^ (m + 1)) z
hfg : (z - z) ^ m ‚Ä¢ f z = (z - z) ^ n ‚Ä¢ g z
‚ä¢ (0 ^ m * 0) ‚Ä¢ (g z)‚Åª¬π = (0 ^ n * 0) ‚Ä¢ f‚Åª¬π z
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (z - x) ^ m * f z
case h.inr
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí ùïú
x : ùïú
m : ‚Ñï
hf : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) x
h_eq : ¬¨(fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
n : ‚Ñï
g : ùïú ‚Üí ùïú
hg_an : AnalyticAt ùïú g x
hg_ne : g x ‚â† 0
hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù x, (z - x) ^ m ‚Ä¢ f z = (z - x) ^ n ‚Ä¢ g z
this : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x
z : ùïú
hfg : (z - x) ^ m * f z = (z - x) ^ n * g z
hg_ne' : g z ‚â† 0
hz_ne : z ‚â† x
aux1 : f z ‚â† 0
‚ä¢ (z - x) ^ m * ((z - x) * f z) = (z - x) ^ (n + 1) * g z",lemma inv {f : ùïú ‚Üí ùïú} {x : ùïú} (hf : MeromorphicAt f x) : MeromorphicAt f‚Åª¬π x ,":= by
  rcases hf with ‚ü®m, hf‚ü©
  by_cases h_eq : (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
  ¬∑ 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  ¬∑ 
    obtain ‚ü®n, g, hg_an, hg_ne, hg_eq‚ü© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ùïú x).sub analyticAt_const).pow _
    refine ‚ü®n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_‚ü©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    ¬∑ simp only [sub_self, pow_succ, mul_zero, zero_smul]
    ¬∑ simp_rw [smul_eq_mul] at hfg ‚ä¢
      have aux1 : f z ‚â† 0 := by
        have : (z - x) ^ n * g z ‚â† 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [‚Üê hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ', mul_assoc, hfg]
      ring",":= by
  rcases hf with ‚ü®m, hf‚ü©
  by_cases h_eq : (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
  ¬∑ 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  ¬∑ 
    obtain ‚ü®n, g, hg_an, hg_ne, hg_eq‚ü© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ùïú x).sub analyticAt_const).pow _
    refine ‚ü®n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_‚ü©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    ¬∑ simp only [sub_self, pow_succ, zero_mul, zero_smul]
    ¬∑ simp_rw [smul_eq_mul] at hfg ‚ä¢
      have aux1 : f z ‚â† 0 := by
        have : (z - x) ^ n * g z ‚â† 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [‚Üê hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ, mul_assoc, hfg]
      ring"
Mathlib/Data/Finset/Card.lean,Finset.card_sdiff,card_sdiff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  suffices card (t \ s) = card (t \ s ‚à™ s) - s.card by rwa [sdiff_union_of_subset h] at this
  rw [card_union_of_disjoint sdiff_disjoint, add_tsub_cancel_right]","error:  failed to synthesize
  OrderedSub ‚Ñï
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  ContravariantClass ‚Ñï ‚Ñï (fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
R : Type u_3
s t u : Finset Œ±
f : Œ± ‚Üí Œ≤
n : ‚Ñï
inst‚úù : DecidableEq Œ±
h : s ‚äÜ t
‚ä¢ OrderedSub ‚Ñï

Œ± : Type u_1
Œ≤ : Type u_2
R : Type u_3
s t u : Finset Œ±
f : Œ± ‚Üí Œ≤
n : ‚Ñï
inst‚úù : DecidableEq Œ±
h : s ‚äÜ t
‚ä¢ ContravariantClass ‚Ñï ‚Ñï (fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1",theorem card_sdiff (h : s ‚äÜ t) : card (t \ s) = t.card - s.card ,":= by
  suffices card (t \ s) = card (t \ s ‚à™ s) - s.card by rwa [sdiff_union_of_subset h] at this
  rw [card_union_of_disjoint sdiff_disjoint, Nat.add_sub_cancel_right]",":= by
  suffices card (t \ s) = card (t \ s ‚à™ s) - s.card by rwa [sdiff_union_of_subset h] at this
  rw [card_union_of_disjoint sdiff_disjoint, add_tsub_cancel_left]"
Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean,CochainComplex.HomComplex.Œ¥_shape,Œ¥_shape,fc5d3dffc7c439022141babb13bcb52a72d9f631,":= by
  ext p q hpq
  dsimp [Œ¥, Cochain.v, Cochain.mk]
  rw [F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  . rfl
  all_goals
    change ¬¨ _=_
    rintro h
    apply hnm
    linarith","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case h.a
C : Type u
inst‚úù¬≥ : Category.{v, u} C
inst‚úù¬≤ : Preadditive C
R : Type u_1
inst‚úù¬π : Ring R
inst‚úù : Linear R C
F G K L : CochainComplex C ‚Ñ§
n m : ‚Ñ§
hnm : ¬¨n + 1 = m
z : Cochain F G n
p q : ‚Ñ§
hpq : p + m = q
‚ä¢ ¬¨(ComplexShape.up ‚Ñ§).Rel (p + n) q",lemma Œ¥_shape (hnm : ¬¨ n + 1 = m) (z : Cochain F G n) : Œ¥ n m z = 0 ,":= by
  ext p q hpq
  dsimp only [Œ¥]
  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  all_goals
    simp only [ComplexShape.up_Rel]
    exact fun _ => hnm (by omega)",":= by
  ext p q hpq
  dsimp [Œ¥, Cochain.v, Cochain.mk]
  rw [F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  ¬∑ rfl
  all_goals
    change ¬¨ _=>
    rintro h
    apply hnm
    linarith"
Mathlib/Algebra/BigOperators/Finsupp.lean,Finsupp.univ_sum_single_apply,univ_sum_single_apply,67e80fd089fe45abea632652c43b78eba72d60e3,":= by
  classical rw [Finsupp.single, DFinsupp.single, coe_mk', Finset.sum_pi_single']
  simp","error:  unknown identifier 'DFinsupp.single'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.257040
Œ± : Type u_1
Œπ : Type u_2
Œ≥ : Type u_3
A : Type u_4
B : Type u_5
C : Type u_6
inst‚úù‚Å¥ : AddCommMonoid A
inst‚úù¬≥ : AddCommMonoid B
inst‚úù¬≤ : AddCommMonoid C
t : Œπ ‚Üí A ‚Üí C
h0 : ‚àÄ (i : Œπ), t i 0 = 0
h1 : ‚àÄ (i : Œπ) (x y : A), t i (x + y) = t i x + t i y
s : Finset Œ±
f : Œ± ‚Üí Œπ ‚Üí‚ÇÄ A
i‚úù : Œπ
g : Œπ ‚Üí‚ÇÄ A
k : Œπ ‚Üí A ‚Üí Œ≥ ‚Üí B
x : Œ≥
Œ≤ : Type u_7
M : Type u_8
M' : Type u_9
N : Type u_10
P : Type u_11
G : Type u_12
H : Type u_13
R : Type u_14
S : Type u_15
inst‚úù¬π : AddCommMonoid M
inst‚úù : Fintype Œ±
i : Œ±
m : M
‚ä¢ ‚àë j : Œ±, { support := if m = 0 then ‚àÖ else {i}, toFun := Pi.single i m, mem_support_toFun := ‚ãØ } j = m","theorem univ_sum_single_apply [AddCommMonoid M] [Fintype Œ±] (i : Œ±) (m : M) :
    ‚àë j : Œ±, single i m j = m ",":= by
  classical rw [single, coe_mk, Finset.sum_pi_single']
  simp",":= by
  classical rw [Finsupp.single, DFinsupp.single, Finset.sum_pi_single']
  simp"
Mathlib/NumberTheory/FermatPsp.lean,Nat.exists_infinite_pseudoprimes,exists_infinite_pseudoprimes,a3708498bec5c2641fd86b158487e675e90d687a,":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_of_le_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by linarith
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by linarith) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by linarith
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact ‚ü®fermatPsp_base_one (by linarith) this, by linarith‚ü©","warning:  `pow_le_pow_of_le_left'` has been deprecated, use `pow_le_pow_left'` instead
error:  application type mismatch
  Nat.le_mul_of_pos_right h‚ÇÉ
argument
  h‚ÇÉ
has type
  0 < b ^ 2 - 1 : Prop
but is expected to have type
  ‚Ñï : Type
error:  unsolved goals
b : ‚Ñï
h : 1 ‚â§ b
m : ‚Ñï
b_ge_two : ¬¨2 ‚â§ b
h‚ÇÅ : b = 1
‚ä¢ ¬¨m + 2 = 1","theorem exists_infinite_pseudoprimes {b : ‚Ñï} (h : 1 ‚â§ b) (m : ‚Ñï) :
    ‚àÉ n : ‚Ñï, FermatPsp n b ‚àß m ‚â§ n ",":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by omega
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by omega) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by omega
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by omega) (by omega)
    exact ‚ü®fermatPsp_base_one (by omega) this, by omega‚ü©",":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_of_le_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by linarith
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by linarith) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by linarith
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact ‚ü®fermatPsp_base_one (by linarith) this, by linarith‚ü©"
Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean,Finset.card_mul_pow_le,card_mul_pow_le,d4ee09ebb44515260fada6fe81009f5ed4807a9d,":= by
  obtain rfl | hA := A.eq_empty_or_nonempty
  ¬∑ simp
  induction' n with n ih
  ¬∑ simp
  rw [_root_.pow_succ', ‚Üê mul_assoc, _root_.pow_succ', @mul_assoc ‚Ñö‚â•0, ‚Üê mul_div_right_comm,
    le_div_iff, ‚Üê cast_mul]
  swap
  ¬∑ exact cast_pos.2 hA.card_pos
  refine (cast_le.2 <| mul_pluennecke_petridis _ hAB).trans ?_
  rw [cast_mul]
  gcongr","error:  ambiguous, possible interpretations 
  NNRat.cast_le.mpr ?m.90344 : ‚Üë?m.90138 ‚â§ ‚Üë?m.90139
  
  Nat.cast_le.mpr
    (mul_pluennecke_petridis ?m.90468 hAB) : ‚Üë((A * B * ?m.90468).card * A.card) ‚â§ ‚Üë((A * B).card * (A * ?m.90468).card)
error:  no goals to be solved","theorem card_mul_pow_le (hAB : ‚àÄ A' ‚äÜ A, (A * B).card * A'.card ‚â§ (A' * B).card * A.card)
    (n : ‚Ñï) : (A * B ^ n).card ‚â§ ((A * B).card / A.card : ‚Ñö‚â•0) ^ n * A.card ",":= by
  obtain rfl | hA := A.eq_empty_or_nonempty
  ¬∑ simp
  induction' n with n ih
  ¬∑ simp
  rw [_root_.pow_succ', ‚Üê mul_assoc, _root_.pow_succ', @mul_assoc ‚Ñö‚â•0, ‚Üê mul_div_right_comm,
    le_div_iff, ‚Üê cast_mul]
  swap
  ¬∑ exact cast_pos.2 hA.card_pos
  refine (Nat.cast_le.2 <| mul_pluennecke_petridis _ hAB).trans ?_
  rw [cast_mul]
  gcongr",":= by
  obtain rfl | hA := A.eq_empty_or_nonempty
  ¬∑ simp
  induction' n with n ih
  ¬∑ simp
  rw [_root_.pow_succ', ‚Üê mul_assoc, _root_.pow_succ', @mul_assoc ‚Ñö‚â•0, ‚Üê mul_div_right_comm,
    le_div_iff, ‚Üê cast_mul]
  swap
  ¬∑ exact cast_pos.2 hA.card_pos
  refine (cast_le.2 <| mul_pluennecke_petridis _ hAB).trans ?_
  rw [cast_mul]
  gcongr"
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.evaln_prim,evaln_prim,cc5d7612e75f7412fe4ce8bee7284584b908ad6e,":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp [Nat.lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.get?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        cases evaln k cg n <;> rfl
      ¬∑ cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      ¬∑ cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      ¬∑ have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to‚ÇÇ).of_eq
    fun ‚ü®‚ü®k, c‚ü©, n‚ü© => by simp [evaln_map]","warning:  `List.map_congr` has been deprecated, use `List.map_congr_left` instead
warning:  `List.get?_range` has been deprecated, use `List.getElem?_range` instead
error:  unsolved goals
x‚úù : Unit
p n : ‚Ñï
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
c : Code
k' : ‚Ñï
k : ‚Ñï := k' + 1
nk : n ‚â§ k'
k‚ÇÅ : ‚Ñï
c‚ÇÅ : Code
n‚ÇÅ : ‚Ñï
hl : Nat.pair k‚ÇÅ (encode c‚ÇÅ) < Nat.pair k (encode c)
‚ä¢ ((Option.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
          (List.range (Nat.pair k (encode c)))[Nat.pair k‚ÇÅ (encode c‚ÇÅ)]?).bind
      fun a ‚Ü¶ a[n‚ÇÅ]?.bind fun a ‚Ü¶ a) =
    evaln k‚ÇÅ c‚ÇÅ n‚ÇÅ",theorem evaln_prim : Primrec fun a : (‚Ñï √ó Code) √ó ‚Ñï => evaln a.1.1 a.1.2 a.2 ,":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr_left fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.getElem?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        cases evaln k cg n <;> rfl
      ¬∑ cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      ¬∑ cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      ¬∑ have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to‚ÇÇ).of_eq
    fun ‚ü®‚ü®k, c‚ü©, n‚ü© => by simp [evaln_map]",":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp [Nat.lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.get?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      ¬∑ have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_"
Mathlib/Logic/Equiv/Set.lean,Equiv.swap_bijOn_self,Equiv.swap_bijOn_self,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  refine ‚ü®fun x hx ‚Ü¶ ?_, (Equiv.injective _).injOn _, fun x hx ‚Ü¶ ?_‚ü©
  ¬∑ obtain (rfl | hxa) := eq_or_ne x a; rwa [swap_apply_left, ‚Üê hs]
    obtain (rfl | hxb) := eq_or_ne x b; rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a; simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b; simp [hs.2 hx]
  exact ‚ü®x, hx, swap_apply_of_ne_of_ne hxa hxb‚ü©","error:  application type mismatch
  And.intro (Injective.injOn (Equiv.injective ?m.64892) ?m.64914)
argument
  Injective.injOn (Equiv.injective ?m.64892) ?m.64914
has type
  ‚àÄ ‚¶Éx‚ÇÇ : ?m.64905‚¶Ñ, x‚ÇÇ ‚àà ?m.64912 ‚Üí ?m.64892 ?m.64913 = ?m.64892 x‚ÇÇ ‚Üí ?m.64913 = x‚ÇÇ : Prop
but is expected to have type
  InjOn (‚áë(swap a b)) s : Prop",theorem Equiv.swap_bijOn_self (hs : a ‚àà s ‚Üî b ‚àà s) : BijOn (Equiv.swap a b) s s ,":= by
  refine ‚ü®fun x hx ‚Ü¶ ?_, (Equiv.injective _).injOn, fun x hx ‚Ü¶ ?_‚ü©
  ¬∑ obtain (rfl | hxa) := eq_or_ne x a
    ¬∑ rwa [swap_apply_left, ‚Üê hs]
    obtain (rfl | hxb) := eq_or_ne x b
    ¬∑ rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a
  ¬∑ simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b
  ¬∑ simp [hs.2 hx]
  exact ‚ü®x, hx, swap_apply_of_ne_of_ne hxa hxb‚ü©",":= by
  refine ‚ü®fun x hx ‚Ü¶ ?_, (Equiv.injective _).injOn ?_, fun x hx ‚Ü¶ ?_‚ü©
  ¬∑ obtain (rfl | hxa) := eq_or_ne x a; rwa [swap_apply_left, ‚Üê hs]
    obtain (rfl | hxb) := eq_or_ne x b; rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a; simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b; simp [hs.2 hx]
  exact ‚ü®x, hx, swap_apply_of_ne_of_ne hxa hxb‚ü©"
Mathlib/RingTheory/FreeCommRing.lean,FreeRing.coe_eq,coe_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  funext x
  erw [castFreeCommRing, toFreeCommRing, FreeRing.lift, Equiv.coe_trans, Function.comp,
    FreeAbelianGroup.liftMonoid_coe (FreeMonoid.lift FreeCommRing.of)]
  dsimp [Functor.map]
  rw [‚Üê AddMonoidHom.coe_coe]
  apply FreeAbelianGroup.lift.unique; intro L
  erw [FreeAbelianGroup.lift.of, Function.comp]
  exact
    FreeMonoid.recOn L rfl fun hd tl ih => by
      rw [(FreeMonoid.lift _).map_mul, FreeMonoid.lift_eval_of, ih]
      conv_lhs => reduce","error:  unsolved goals
Œ± : Type u
x : FreeRing Œ±
L : FreeMonoid Œ±
hd : Œ±
tl : FreeMonoid Œ±
ih : (FreeMonoid.lift FreeCommRing.of) tl = (fun x ‚Ü¶ FreeAbelianGroup.of ‚Üëx) tl
‚ä¢ Quot.lift
      (fun L ‚Ü¶
        List.foldl
          (fun x x_1 ‚Ü¶
            Quot.lift
              (fun a‚ÇÅ ‚Ü¶
                Quot.lift
                  (fun y ‚Ü¶
                    Quot.mk
                      (fun a b ‚Ü¶ a ‚àà MulAction.orbit (‚Ü•(commutator (FreeGroup (Multiplicative (Multiset Œ±)))).op) b)
                      (Quot.lift (fun L‚ÇÅ ‚Ü¶ Quot.lift (fun L‚ÇÇ ‚Ü¶ Quot.mk FreeGroup.Red.Step (L‚ÇÅ.append L‚ÇÇ)) ‚ãØ y) ‚ãØ a‚ÇÅ))
                  ‚ãØ x_1)
              ‚ãØ x)
          (Quot.mk (fun a b ‚Ü¶ a ‚àà MulAction.orbit (‚Ü•(commutator (FreeGroup (Multiplicative (Multiset Œ±)))).op) b)
            (Quot.mk FreeGroup.Red.Step []))
          (List.map
            (fun x ‚Ü¶
              (fun motive c h_1 h_2 ‚Ü¶ Bool.rec (h_2 PUnit.unit) (h_1 PUnit.unit) c)
                (fun c ‚Ü¶ Multiplicative (FreeAbelianGroup (Multiplicative (Multiset Œ±)))) x.2
                (fun _ ‚Ü¶
                  Quot.lift
                    (fun L ‚Ü¶
                      List.foldl
                        (fun x x_1 ‚Ü¶
                          Quot.lift
                            (fun a‚ÇÅ ‚Ü¶
                              Quot.lift
                                (fun y ‚Ü¶
                                  Quot.mk
                                    (fun a b ‚Ü¶
                                      a ‚àà
                                        MulAction.orbit (‚Ü•(commutator (FreeGroup (Multiplicative (Multiset Œ±)))).op) b)
                                    (Quot.lift
                                      (fun L‚ÇÅ ‚Ü¶ Quot.lift (fun L‚ÇÇ ‚Ü¶ Quot.mk FreeGroup.Red.Step (L‚ÇÅ.append L‚ÇÇ)) ‚ãØ y) ‚ãØ
                                      a‚ÇÅ))
                                ‚ãØ x_1)
                            ‚ãØ x)
                        (Quot.mk
                          (fun a b ‚Ü¶ a ‚àà MulAction.orbit (‚Ü•(commutator (FreeGroup (Multiplicative (Multiset Œ±)))).op) b)
                          (Quot.mk FreeGroup.Red.Step []))
                        (List.map
                          (fun x_1 ‚Ü¶
                            (fun motive c h_1 h_2 ‚Ü¶ Bool.rec (h_2 PUnit.unit) (h_1 PUnit.unit) c)
                              (fun c ‚Ü¶ Multiplicative (FreeAbelianGroup (Multiplicative (Multiset Œ±)))) x_1.2
                              (fun _ ‚Ü¶
                                Quot.mk
                                  (fun a b ‚Ü¶
                                    a ‚àà MulAction.orbit (‚Ü•(commutator (FreeGroup (Multiplicative (Multiset Œ±)))).op) b)
                                  (Quot.mk FreeGroup.Red.Step
                                    [(Quot.lift (fun a‚ÇÅ ‚Ü¶ Quot.lift (fun l‚ÇÇ ‚Ü¶ Quot.mk List.Perm (a‚ÇÅ.append l‚ÇÇ)) ‚ãØ x.1) ‚ãØ
                                          x_1.1,
                                        true)]))
                              fun _ ‚Ü¶
                              Quot.mk
                                (fun a b ‚Ü¶
                                  a ‚àà MulAction.orbit (‚Ü•(commutator (FreeGroup (Multiplicative (Multiset Œ±)))).op) b)
                                (Quot.mk FreeGroup.Red.Step
                                  [(Quot.lift (fun a‚ÇÅ ‚Ü¶ Quot.lift (fun l‚ÇÇ ‚Ü¶ Quot.mk List.Perm (a‚ÇÅ.append l‚ÇÇ)) ‚ãØ x.1) ‚ãØ
                                        x_1.1,
                                      false)]))
                          L))
                    ‚ãØ (Quot.mk FreeGroup.Red.Step [(Quot.mk List.Perm [hd], true)]))
                fun _ ‚Ü¶
                Quot.lift
                  (fun x ‚Ü¶
                    Quot.mk
                      (fun a b ‚Ü¶ a ‚àà MulAction.orbit (‚Ü•(commutator (FreeGroup (Multiplicative (Multiset Œ±)))).op) b)
                      (Quot.lift
                        (fun x ‚Ü¶
                          Quot.mk FreeGroup.Red.Step
                            ((List.map
                                  (fun g ‚Ü¶
                                    (g.1,
                                      (fun motive c h_1 h_2 ‚Ü¶ Bool.rec (h_2 PUnit.unit) (h_1 PUnit.unit) c)
                                        (fun x ‚Ü¶ Bool) g.2 (fun _ ‚Ü¶ false) fun _ ‚Ü¶ true))
                                  x).reverseAux
                              []))
                        ‚ãØ x))
                  ‚ãØ
                  (Quot.lift
                    (fun L ‚Ü¶
                      List.foldl
                        (fun x x_1 ‚Ü¶
                          Quot.lift
                            (fun a‚ÇÅ ‚Ü¶
                              Quot.lift
                                (fun y ‚Ü¶
                                  Quot.mk
                                    (fun a b ‚Ü¶
                                      a ‚àà
                                        MulAction.orbit (‚Ü•(commutator (FreeGroup (Multiplicative (Multiset Œ±)))).op) b)
                                    (Quot.lift
                                      (fun L‚ÇÅ ‚Ü¶ Quot.lift (fun L‚ÇÇ ‚Ü¶ Quot.mk FreeGroup.Red.Step (L‚ÇÅ.append L‚ÇÇ)) ‚ãØ y) ‚ãØ
                                      a‚ÇÅ))
                                ‚ãØ x_1)
                            ‚ãØ x)
                        (Quot.mk
                          (fun a b ‚Ü¶ a ‚àà MulAction.orbit (‚Ü•(commutator (FreeGroup (Multiplicative (Multiset Œ±)))).op) b)
                          (Quot.mk FreeGroup.Red.Step []))
                        (List.map
                          (fun x_1 ‚Ü¶
                            (fun motive c h_1 h_2 ‚Ü¶ Bool.rec (h_2 PUnit.unit) (h_1 PUnit.unit) c)
                              (fun c ‚Ü¶ Multiplicative (FreeAbelianGroup (Multiplicative (Multiset Œ±)))) x_1.2
                              (fun _ ‚Ü¶
                                Quot.mk
                                  (fun a b ‚Ü¶
                                    a ‚àà MulAction.orbit (‚Ü•(commutator (FreeGroup (Multiplicative (Multiset Œ±)))).op) b)
                                  (Quot.mk FreeGroup.Red.Step
                                    [(Quot.lift (fun a‚ÇÅ ‚Ü¶ Quot.lift (fun l‚ÇÇ ‚Ü¶ Quot.mk List.Perm (a‚ÇÅ.append l‚ÇÇ)) ‚ãØ x.1) ‚ãØ
                                          x_1.1,
                                        true)]))
                              fun _ ‚Ü¶
                              Quot.mk
                                (fun a b ‚Ü¶
                                  a ‚àà MulAction.orbit (‚Ü•(commutator (FreeGroup (Multiplicative (Multiset Œ±)))).op) b)
                                (Quot.mk FreeGroup.Red.Step
                                  [(Quot.lift (fun a‚ÇÅ ‚Ü¶ Quot.lift (fun l‚ÇÇ ‚Ü¶ Quot.mk List.Perm (a‚ÇÅ.append l‚ÇÇ)) ‚ãØ x.1) ‚ãØ
                                        x_1.1,
                                      false)]))
                          L))
                    ‚ãØ (Quot.mk FreeGroup.Red.Step [(Quot.mk List.Perm [hd], true)])))
            L))
      ‚ãØ (Quot.mk FreeGroup.Red.Step [(Quot.mk List.Perm tl, true)]) =
    (fun x ‚Ü¶ FreeAbelianGroup.of ‚Üëx) (FreeMonoid.of hd * tl)","theorem coe_eq : ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) =
    @Functor.map FreeAbelianGroup _ _ _ fun l : List Œ± => (l : Multiset Œ±) ",":= by
  funext x
  erw [castFreeCommRing, toFreeCommRing, FreeRing.lift, Equiv.coe_trans, Function.comp,
    FreeAbelianGroup.liftMonoid_coe (FreeMonoid.lift FreeCommRing.of)]
  dsimp [Functor.map]
  rw [‚Üê AddMonoidHom.coe_coe]
  apply FreeAbelianGroup.lift.unique; intro L
  erw [FreeAbelianGroup.lift.of, Function.comp]
  exact
    FreeMonoid.recOn L rfl fun hd tl ih => by
      rw [(FreeMonoid.lift _).map_mul, FreeMonoid.lift_eval_of, ih]
      conv_lhs => reduce
      rfl",":= by
  funext x
  erw [castFreeCommRing, FreeRing.lift, Equiv.coe_trans, Function.comp,
    FreeAbelianGroup.liftMonoid_coe (FreeMonoid.lift FreeCommRing.of)]
  dsimp [Functor.map]
  rw [‚Üê AddMonoidHom.coe_coe]
  apply FreeAbelianGroup.lift.unique; intro L
  erw [FreeAbelianGroup.lift.of, Function.comp]
  exact
    FreeMonoid.recOn L rfl fun hd tl ih => by
      rw [(FreeMonoid.lift _).map_mul, FreeMonoid.lift_eval_of, ih]
      conv_lhs => reduce"
Mathlib/NumberTheory/FermatPsp.lean,Nat.exists_infinite_pseudoprimes,exists_infinite_pseudoprimes,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_of_le_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by linarith
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by linarith) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by linarith
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact ‚ü®base_one (by linarith) this, by linarith‚ü©","warning:  `pow_le_pow_of_le_left'` has been deprecated, use `pow_le_pow_left'` instead
error:  application type mismatch
  Nat.le_mul_of_pos_right h‚ÇÉ
argument
  h‚ÇÉ
has type
  0 < b ^ 2 - 1 : Prop
but is expected to have type
  ‚Ñï : Type
error:  unsolved goals
b : ‚Ñï
h : 1 ‚â§ b
m : ‚Ñï
b_ge_two : ¬¨2 ‚â§ b
h‚ÇÅ : b = 1
‚ä¢ ¬¨m + 2 = 1
error:  unknown identifier 'base_one'","theorem exists_infinite_pseudoprimes {b : ‚Ñï} (h : 1 ‚â§ b) (m : ‚Ñï) :
    ‚àÉ n : ‚Ñï, FermatPsp n b ‚àß m ‚â§ n ",":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by omega
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by omega) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by omega
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by omega) (by omega)
    exact ‚ü®fermatPsp_base_one (by omega) this, by omega‚ü©",":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_of_le_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by linarith
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by linarith) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by linarith
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact ‚ü®base_one (by linarith) this, by linarith‚ü©"
Mathlib/Data/Sum/Interval.lean,Finset.sumLexLift_eq_empty,sumLexLift_eq_empty,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, ?_, ?_‚ü©, fun h? ‚Ü¶ _‚ü©
  any_goals rintro a b rfl rfl; exact map_eq_empty.1 h
  ¬∑ rintro a b rfl rfl; exact disjSum_eq_empty.1 h
  cases a <;> cases b
  ¬∑ exact map_eq_empty.2 (h.1 _ _ rfl rfl)
  ¬∑ simp [h.2.1 _ _ rfl rfl]
  ¬∑ rfl
  ¬∑ exact map_eq_empty.2 (h.2.2 _ _ rfl rfl)","error:  don't know how to synthesize placeholder
context:
Œ±‚ÇÅ : Type u_1
Œ±‚ÇÇ : Type u_2
Œ≤‚ÇÅ : Type u_3
Œ≤‚ÇÇ : Type u_4
Œ≥‚ÇÅ : Type u_5
Œ≥‚ÇÇ : Type u_6
f‚ÇÅ f‚ÇÅ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ ‚Üí Finset Œ≥‚ÇÅ
f‚ÇÇ f‚ÇÇ' : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÇ
g‚ÇÅ g‚ÇÅ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÅ
g‚ÇÇ g‚ÇÇ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÇ
a : Œ±‚ÇÅ ‚äï Œ±‚ÇÇ
b : Œ≤‚ÇÅ ‚äï Œ≤‚ÇÇ
c : Œ≥‚ÇÅ ‚äï Œ≥‚ÇÇ
h? :
  (‚àÄ (a‚ÇÅ : Œ±‚ÇÅ) (b‚ÇÅ : Œ≤‚ÇÅ), a = inl a‚ÇÅ ‚Üí b = inl b‚ÇÅ ‚Üí f‚ÇÅ a‚ÇÅ b‚ÇÅ = ‚àÖ) ‚àß
    (‚àÄ (a‚ÇÅ : Œ±‚ÇÅ) (b‚ÇÇ : Œ≤‚ÇÇ), a = inl a‚ÇÅ ‚Üí b = inr b‚ÇÇ ‚Üí g‚ÇÅ a‚ÇÅ b‚ÇÇ = ‚àÖ ‚àß g‚ÇÇ a‚ÇÅ b‚ÇÇ = ‚àÖ) ‚àß
      ‚àÄ (a‚ÇÇ : Œ±‚ÇÇ) (b‚ÇÇ : Œ≤‚ÇÇ), a = inr a‚ÇÇ ‚Üí b = inr b‚ÇÇ ‚Üí f‚ÇÇ a‚ÇÇ b‚ÇÇ = ‚àÖ
‚ä¢ sumLexLift f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ a b = ‚àÖ
error:  unsolved goals
Œ±‚ÇÅ : Type u_1
Œ±‚ÇÇ : Type u_2
Œ≤‚ÇÅ : Type u_3
Œ≤‚ÇÇ : Type u_4
Œ≥‚ÇÅ : Type u_5
Œ≥‚ÇÇ : Type u_6
f‚ÇÅ f‚ÇÅ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ ‚Üí Finset Œ≥‚ÇÅ
f‚ÇÇ f‚ÇÇ' : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÇ
g‚ÇÅ g‚ÇÅ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÅ
g‚ÇÇ g‚ÇÇ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÇ
a : Œ±‚ÇÅ ‚äï Œ±‚ÇÇ
b : Œ≤‚ÇÅ ‚äï Œ≤‚ÇÇ
c : Œ≥‚ÇÅ ‚äï Œ≥‚ÇÇ
‚ä¢ sumLexLift f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ a b = ‚àÖ ‚Üî
    (‚àÄ (a‚ÇÅ : Œ±‚ÇÅ) (b‚ÇÅ : Œ≤‚ÇÅ), a = inl a‚ÇÅ ‚Üí b = inl b‚ÇÅ ‚Üí f‚ÇÅ a‚ÇÅ b‚ÇÅ = ‚àÖ) ‚àß
      (‚àÄ (a‚ÇÅ : Œ±‚ÇÅ) (b‚ÇÇ : Œ≤‚ÇÇ), a = inl a‚ÇÅ ‚Üí b = inr b‚ÇÇ ‚Üí g‚ÇÅ a‚ÇÅ b‚ÇÇ = ‚àÖ ‚àß g‚ÇÇ a‚ÇÅ b‚ÇÇ = ‚àÖ) ‚àß
        ‚àÄ (a‚ÇÇ : Œ±‚ÇÇ) (b‚ÇÇ : Œ≤‚ÇÇ), a = inr a‚ÇÇ ‚Üí b = inr b‚ÇÇ ‚Üí f‚ÇÇ a‚ÇÇ b‚ÇÇ = ‚àÖ","lemma sumLexLift_eq_empty :
    sumLexLift f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ a b = ‚àÖ ‚Üî
      (‚àÄ a‚ÇÅ b‚ÇÅ, a = inl a‚ÇÅ ‚Üí b = inl b‚ÇÅ ‚Üí f‚ÇÅ a‚ÇÅ b‚ÇÅ = ‚àÖ) ‚àß
        (‚àÄ a‚ÇÅ b‚ÇÇ, a = inl a‚ÇÅ ‚Üí b = inr b‚ÇÇ ‚Üí g‚ÇÅ a‚ÇÅ b‚ÇÇ = ‚àÖ ‚àß g‚ÇÇ a‚ÇÅ b‚ÇÇ = ‚àÖ) ‚àß
          ‚àÄ a‚ÇÇ b‚ÇÇ, a = inr a‚ÇÇ ‚Üí b = inr b‚ÇÇ ‚Üí f‚ÇÇ a‚ÇÇ b‚ÇÇ = ‚àÖ ",":= by
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, ?_, ?_‚ü©, fun h ‚Ü¶ ?_‚ü©
  any_goals rintro a b rfl rfl; exact map_eq_empty.1 h
  ¬∑ rintro a b rfl rfl; exact disjSum_eq_empty.1 h
  cases a <;> cases b
  ¬∑ exact map_eq_empty.2 (h.1 _ _ rfl rfl)
  ¬∑ simp [h.2.1 _ _ rfl rfl]
  ¬∑ rfl
  ¬∑ exact map_eq_empty.2 (h.2.2 _ _ rfl rfl)",":= by
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, ?_, ?_‚ü©, fun h ‚Ü¶ ?_‚ü©
  any_goals rintro a b rfl rfl; exact map_eq_empty.1 h
  ¬∑ rintro a b rfl rfl; exact disjSum_eq_empty.1 h
  cases a <;> cases b
  ¬∑ exact map_eq_empty.2 (h.1 _ _ rfl rfl)
  ¬∑ simp [h.2.1 _ _ rfl rfl]
  ¬∑ rfl
  ¬∑ exact map_eq_empty.2 (h.2.2 _ _ rfl rfl)"
Mathlib/Data/Nat/Factorial/Basic.lean,Nat.ascFactorial_le_pow_add,ascFactorial_le_pow_add,dc0b2fb410ce57ee8ea5b9ce5b357ce030465e7a,"  | 0 => by rw [ascFactorial_zero, Nat.pow_zero]
  | k + 1 => by
    rw [ascFactorial_succ, Nat.pow_succ, Nat.mul_comm, Nat.add_assoc', Nat.add_right_comm n 1 k]
    exact Nat.mul_le_mul_right _
      (Nat.le_trans (ascFactorial_le_pow_add _ k) (Nat.pow_le_pow_left (le_succ _) _))","error:  unknown constant 'Nat.add_assoc''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.13556
n k : ‚Ñï
‚ä¢ (n + 1).ascFactorial k * (n + 1 + k) ‚â§ (n + (k + 1)) ^ k * (n + (k + 1))","theorem ascFactorial_le_pow_add (n : ‚Ñï) : ‚àÄ k : ‚Ñï, (n+1).ascFactorial k ‚â§ (n + k) ^ k
","  | 0 => by rw [ascFactorial_zero, Nat.pow_zero]
  | k + 1 => by
    rw [ascFactorial_succ, Nat.pow_succ, Nat.mul_comm, ‚Üê Nat.add_assoc, Nat.add_right_comm n 1 k]
    exact Nat.mul_le_mul_right _
      (Nat.le_trans (ascFactorial_le_pow_add _ k) (Nat.pow_le_pow_left (le_succ _) _))",":= by
  | 0 => by rw [ascFactorial_zero, Nat.pow_zero]
  | k + 1 => by
    rw [ascFactorial_succ, Nat.pow_succ', Nat.add_right_comm n 1 k]
    exact Nat.mul_le_mul_right _
      (Nat.le_trans (ascFactorial_le_pow_add _ k) (Nat.pow_le_pow_left (le_succ _) _))"
Mathlib/Topology/Order/Basic.lean,isOpen_gt',isOpen_gt',46d4658f3d53b90e371238cba7834b12e431e312,:= isOpen_Iio,"error:  type mismatch
  isOpen_Iio
has type
  IsOpen (Iio ?m.4761) : Prop
but is expected to have type
  IsOpen {b | b < a} : Prop
error:  failed to synthesize
  LinearOrder Œ±
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  ClosedIciTopology Œ±
use `set_option diagnostics true` to get diagnostic information",theorem isOpen_gt' (a : Œ±) : IsOpen { b : Œ± | b < a } ,":=
  isOpen_iff_generate_intervals.2 <| .basic _ ‚ü®a, .inr rfl‚ü©",:= isOpen_Iio
Mathlib/Topology/UniformSpace/UniformConvergence.lean,UniformCauchySeqOn.prod,UniformCauchySeqOn.prod,66caaeed4dccada03ce195a3f9db1c0009ee8118,":= by
  intro u hu
  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu
  obtain ‚ü®v, hv, w, hw, hvw‚ü© := hu
  simp_rw [mem_prod, Prod.map_apply, and_imp, Prod.forall]
  rw [‚Üê Set.image_subset_iff] at hvw
  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono
  intro x hx a b ha hb
  exact hvw ‚ü®_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl‚ü©",error:  simp made no progress,"theorem UniformCauchySeqOn.prod_map {Œπ' Œ±' Œ≤' : Type*} [UniformSpace Œ≤'] {F' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'}
    {p' : Filter Œπ'} {s' : Set Œ±'} (h : UniformCauchySeqOn F p s)
    (h' : UniformCauchySeqOn F' p' s') :
    UniformCauchySeqOn (fun i : Œπ √ó Œπ' => Prod.map (F i.1) (F' i.2)) (p √óÀ¢ p') (s √óÀ¢ s') ",":= by
  intro u hu
  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu
  obtain ‚ü®v, hv, w, hw, hvw‚ü© := hu
  simp_rw [mem_prod, and_imp, Prod.forall, Prod.map_apply]
  rw [‚Üê Set.image_subset_iff] at hvw
  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono
  intro x hx a b ha hb
  exact hvw ‚ü®_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl‚ü©",":= by
  intro u hu
  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu
  obtain ‚ü®v, hv, w, hw, hvw‚ü© := hu
  simp_rw [mem_prod, Prod.map_apply, and_imp, Prod.forall]
  rw [‚Üê Set.image_subset_iff] at hvw
  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono
  intro x hx a b ha hb
  exact hvw ‚ü®_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl‚ü©"
Mathlib/CategoryTheory/Abelian/Pseudoelements.lean,CategoryTheory.Abelian.Pseudoelement.sub_of_eq_image,sub_of_eq_image,ce15dd9b572bca674c0fa59b4dc29855485fb00f,":=
  Quotient.inductionOn‚ÇÇ x y fun a a' h =>
    match Quotient.exact h with
    | ‚ü®R, p, q, ep, _, comm‚ü© =>
      let a'' : R ‚ü∂ P := ‚Üë(p ‚â´ a.hom) - ‚Üë(q ‚â´ a'.hom)
      ‚ü®a'',
        ‚ü®show ‚ü¶(a'' ‚â´ f : Over Q)‚üß = ‚ü¶‚Üë(0 : Q ‚ü∂ Q)‚üß by
            dsimp at comm
            simp [sub_eq_zero.2 comm],
          fun Z g hh => by
          obtain ‚ü®X, p', q', ep', _, comm'‚ü© := Quotient.exact hh
          have : a'.hom ‚â´ g = 0 := by
            apply (epi_iff_cancel_zero _).1 ep' _ (a'.hom ‚â´ g)
            simpa using comm'
          apply Quotient.sound
          change app g (a'' : Over P) ‚âà app g a
          exact ‚ü®R, ùüô R, p, inferInstance, ep, by simp [sub_eq_add_neg, this]‚ü©‚ü©‚ü©","error:  unsolved goals
C : Type u
inst‚úù¬π : Category.{v, u} C
inst‚úù : Abelian C
P Q : C
f : P ‚ü∂ Q
x y : Pseudoelement P
a a' : Over P
h : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
R : C
p : R ‚ü∂ ((fun g ‚Ü¶ app f g) a).left
q : R ‚ü∂ ((fun g ‚Ü¶ app f g) a').left
ep : Epi p
w‚úù : Epi q
comm : p ‚â´ a.hom ‚â´ f = q ‚â´ a'.hom ‚â´ f
a'' : R ‚ü∂ P := p ‚â´ a.hom - q ‚â´ a'.hom
‚ä¢ ‚ü¶Over.mk (a'' ‚â´ f)‚üß = 0
error:  unsolved goals
C : Type u
inst‚úù¬π : Category.{v, u} C
inst‚úù : Abelian C
P Q : C
f : P ‚ü∂ Q
x y : Pseudoelement P
a a' : Over P
h : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
R : C
p : R ‚ü∂ ((fun g ‚Ü¶ app f g) a).left
q : R ‚ü∂ ((fun g ‚Ü¶ app f g) a').left
ep : Epi p
w‚úù¬π : Epi q
comm : p ‚â´ ((fun g ‚Ü¶ app f g) a).hom = q ‚â´ ((fun g ‚Ü¶ app f g) a').hom
a'' : R ‚ü∂ P := p ‚â´ a.hom - q ‚â´ a'.hom
Z : C
g : P ‚ü∂ Z
hh : pseudoApply g ‚ü¶a'‚üß = 0
X : C
p' : X ‚ü∂ ((fun g_1 ‚Ü¶ app g g_1) a').left
q' : X ‚ü∂ (Over.mk 0).left
ep' : Epi p'
w‚úù : Epi q'
comm' : p' ‚â´ ((fun g_1 ‚Ü¶ app g g_1) a').hom = q' ‚â´ (Over.mk 0).hom
this : a'.hom ‚â´ g = 0
‚ä¢ a'' ‚â´ g = p ‚â´ a.hom ‚â´ g","theorem sub_of_eq_image {P Q : C} (f : P ‚ü∂ Q) (x y : P) :
    f x = f y ‚Üí ‚àÉ z, f z = 0 ‚àß ‚àÄ (R : C) (g : P ‚ü∂ R), (g : P ‚ü∂ R) y = 0 ‚Üí g z = g x ",":=
  Quotient.inductionOn‚ÇÇ x y fun a a' h =>
    match Quotient.exact h with
    | ‚ü®R, p, q, ep, _, comm‚ü© =>
      let a'' : R ‚ü∂ P := ‚Üë(p ‚â´ a.hom) - ‚Üë(q ‚â´ a'.hom)
      ‚ü®a'',
        ‚ü®show ‚ü¶(a'' ‚â´ f : Over Q)‚üß = ‚ü¶‚Üë(0 : Q ‚ü∂ Q)‚üß by
            dsimp at comm
            simp [a'', sub_eq_zero.2 comm],
          fun Z g hh => by
          obtain ‚ü®X, p', q', ep', _, comm'‚ü© := Quotient.exact hh
          have : a'.hom ‚â´ g = 0 := by
            apply (epi_iff_cancel_zero _).1 ep' _ (a'.hom ‚â´ g)
            simpa using comm'
          apply Quotient.sound
          change app g (a'' : Over P) ‚âà app g a
          exact ‚ü®R, ùüô R, p, inferInstance, ep, by simp [a'', sub_eq_add_neg, this]‚ü©‚ü©‚ü©",":=
  Quotient.inductionOn‚ÇÇ x y fun a a' h =>
    match Quotient.exact h with
    | ‚ü®R, p, q, ep, _, comm‚ü© =>
      let a'' : R ‚ü∂ P := ‚Üë(p ‚â´ a.hom) - ‚Üë(q ‚â´ a'.hom)
      ‚ü®a'',
        ‚ü®show ‚ü¶(a'' ‚â´ f : Over Q)‚üß = ‚ü¶‚Üë(0 : Q ‚ü∂ Q)‚üß by
           dsimp at comm
            simp [sub_eq_zero.2 comm],
          fun Z g hh => by
          obtain ‚ü®X, p', q', ep', _, comm'‚ü© := Quotient.exact hh
          have : a'.hom ‚â´ g = 0 := by
            apply (epi_iff_cancel_zero _).1 ep' _ (a'.hom ‚â´ g)
            simpa using comm'
          apply Quotient.sound
          change app g (a'' : Over P) ‚âà app g a
          exact ‚ü®R, ùüô R, p, inferInstance, ep, by simp [sub_eq_add_neg, this]‚ü©‚ü©‚ü©"
Mathlib/MeasureTheory/Measure/Haar/Unique.lean,MeasureTheory.Measure.absolutelyContinuous_isHaarMeasure,absolutelyContinuous_isHaarMeasure,87c5a5a812b43358ca77ed7cb1211985afb5b9b7,":= by
  have K : PositiveCompacts G := Classical.arbitrary _
  have h : haarMeasure K = (haarScalarFactor (haarMeasure K) ŒΩ : ‚Ñù‚â•0‚àû) ‚Ä¢ ŒΩ :=
    isHaarMeasure_eq_smul (haarMeasure K) ŒΩ
  rw [haarMeasure_unique Œº K, h, smul_smul]
  exact AbsolutelyContinuous.smul (Eq.absolutelyContinuous rfl) _","warning:  `MeasureTheory.Measure.isHaarMeasure_eq_smul` has been deprecated, use `MeasureTheory.Measure.isMulLeftInvariant_eq_smul` instead
error:  application type mismatch
  @isHaarMeasure_eq_smul G inst‚úù‚Åπ inst‚úù‚Å∏
argument has type
  AddGroup G
but function has type
  ‚àÄ [inst : Group G] [inst_1 : TopologicalGroup G] [inst_2 : MeasurableSpace G] [inst_3 : BorelSpace G]
    [inst_4 : LocallyCompactSpace G] [inst_5 : SecondCountableTopology G] (Œº' Œº : Measure G) [inst_6 : Œº.IsHaarMeasure]
    [inst_7 : IsFiniteMeasureOnCompacts Œº'] [inst_8 : Œº'.IsMulLeftInvariant], Œº' = Œº'.haarScalarFactor Œº ‚Ä¢ Œº","theorem absolutelyContinuous_isHaarMeasure [LocallyCompactSpace G]
    [SecondCountableTopology G] (Œº ŒΩ : Measure G)
    [SigmaFinite Œº] [IsMulLeftInvariant Œº] [IsHaarMeasure ŒΩ] : Œº ‚â™ ŒΩ ",":= by
  have K : PositiveCompacts G := Classical.arbitrary _
  have h : haarMeasure K = (haarScalarFactor (haarMeasure K) ŒΩ : ‚Ñù‚â•0‚àû) ‚Ä¢ ŒΩ :=
    isMulLeftInvariant_eq_smul (haarMeasure K) ŒΩ
  rw [haarMeasure_unique Œº K, h, smul_smul]
  exact AbsolutelyContinuous.smul (Eq.absolutelyContinuous rfl) _",":= by
  have K : PositiveCompacts G := Classical.arbitrary _
  have h : haarMeasure K = (haarScalarFactor (haarMeasure K) ŒΩ : ‚Ñù‚â•0‚àû) ‚Ä¢ ŒΩ :=
    isHaarMeasure_eq_smul (haarMeasure K) ŒΩ
  rw [haarMeasure_unique Œº K, h, smul_smul]
  exact AbsolutelyContinuous.smul (Eq.absolutelyContinuous rfl) _"
Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean,TopCat.pullback_fst_image_snd_preimage,pullback_fst_image_snd_preimage,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext x
  constructor
  ¬∑ rintro ‚ü®y, hy, rfl‚ü©
    exact
      ‚ü®(pullback.snd : pullback f g ‚ü∂ _) y, hy,
        (ConcreteCategory.congr_hom pullback.condition y).symm‚ü©
  ¬∑ rintro ‚ü®y, hy, eq‚ü©
    exact ‚ü®(TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®_, _‚ü©, eq.symm‚ü©, by simpa, by simp‚ü©","error:  application type mismatch
  ConcreteCategory.congr_hom pullback.condition y
argument
  y
has type
  ‚Üë(pullback f g) : Type u
but is expected to have type
  (forget ?m.266580).obj (pullback ?m.266585 ?m.266586) : Type ?u.266570
error:  tactic 'assumption' failed
J : Type v
inst‚úù : SmallCategory J
X Y Z : TopCat
f : X ‚ü∂ Z
g : Y ‚ü∂ Z
U : Set ‚ÜëY
x : ‚ÜëX
y : ‚ÜëY
hy : y ‚àà U
eq : g y = f x
‚ä¢ pullback.snd ((pullbackIsoProdSubtype f g).inv ‚ü®(x, y), ‚ãØ‚ü©) ‚àà U
error:  unsolved goals
J : Type v
inst‚úù : SmallCategory J
X Y Z : TopCat
f : X ‚ü∂ Z
g : Y ‚ü∂ Z
U : Set ‚ÜëY
x : ‚ÜëX
y : ‚ÜëY
hy : y ‚àà U
eq : g y = f x
‚ä¢ pullback.fst ((pullbackIsoProdSubtype f g).inv ‚ü®(x, y), ‚ãØ‚ü©) = x","theorem pullback_fst_image_snd_preimage (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (U : Set Y) :
    (pullback.fst : pullback f g ‚ü∂ _) '' ((pullback.snd : pullback f g ‚ü∂ _) ‚Åª¬π' U) =
      f ‚Åª¬π' (g '' U) ",":= by
  ext x
  constructor
  ¬∑ rintro ‚ü®(y : (forget TopCat).obj _), hy, rfl‚ü©
    exact
      ‚ü®(pullback.snd : pullback f g ‚ü∂ _) y, hy,
        (ConcreteCategory.congr_hom pullback.condition y).symm‚ü©
  ¬∑ rintro ‚ü®y, hy, eq‚ü©
    refine ‚ü®(TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®_, _‚ü©, eq.symm‚ü©, ?_, ?_‚ü©
    ¬∑ simp only [coe_of, Set.mem_preimage]
      convert hy
      erw [pullbackIsoProdSubtype_inv_snd_apply]
    ¬∑ rw [pullbackIsoProdSubtype_inv_fst_apply]",":= by
  ext x
  constructor
  ¬∑ rintro ‚ü®y, hy, rfl‚ü©
    exact
      ‚ü®(pullback.snd : pullback f g ‚ü∂ _) y, hy,
        (ConcreteCategory.congr_hom pullback.condition y).symm‚ü©
  ¬∑ rintro ‚ü®y, hy, eq‚ü©
    exact ‚ü®(TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®_, _‚ü©, eq.symm‚ü©, by simpa, by simp‚ü©"
Mathlib/RingTheory/AdicCompletion/Functoriality.lean,AdicCompletion.sumInv_comp_sum,sumInv_comp_sum,477166fbcab40069a4fbe62e393a3d09efdb938f,":= by
  ext j x
  apply DirectSum.ext R (fun i ‚Ü¶ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, LinearMap.adicCompletion_mk,
    component_sumInv, mk_apply_coe, LinearMap.adicCauchy_apply_coe, Submodule.mkQ_apply,
    LinearMap.id_comp]
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  ¬∑ next h => subst h; simp
  ¬∑ simp","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.348217 ‚Üí+* ?m.348218) ‚Üí
    (M : Type ?u.348214) ‚Üí
      (M‚ÇÇ : Type ?u.348213) ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          [inst_1 : AddCommMonoid M‚ÇÇ] ‚Üí
            [inst : Module ?m.348217 M] ‚Üí [inst : Module ?m.348218 M‚ÇÇ] ‚Üí Type (max ?u.348214 ?u.348213)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.348447 ‚Üí+* ?m.348448) ‚Üí
    (M : Type ?u.348444) ‚Üí
      (M‚ÇÇ : Type ?u.348443) ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          [inst_1 : AddCommMonoid M‚ÇÇ] ‚Üí
            [inst : Module ?m.348447 M] ‚Üí [inst : Module ?m.348448 M‚ÇÇ] ‚Üí Type (max ?u.348444 ?u.348443)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (component ?R ?Œπ ?M ?i) ((lof ?R ?Œπ ?M ?j) ?b)
case h
R : Type u_1
inst‚úù¬π¬≤ : CommRing R
I : Ideal R
M‚úù : Type u_2
inst‚úù¬π¬π : AddCommGroup M‚úù
inst‚úù¬π‚Å∞ : Module R M‚úù
N : Type u_3
inst‚úù‚Åπ : AddCommGroup N
inst‚úù‚Å∏ : Module R N
P : Type u_4
inst‚úù‚Å∑ : AddCommGroup P
inst‚úù‚Å∂ : Module R P
T : Type u_5
inst‚úù‚Åµ : AddCommGroup T
inst‚úù‚Å¥ : Module (AdicCompletion I R) T
Œπ : Type u_6
inst‚úù¬≥ : DecidableEq Œπ
M : Œπ ‚Üí Type u_7
inst‚úù¬≤ : (i : Œπ) ‚Üí AddCommGroup (M i)
inst‚úù¬π : (i : Œπ) ‚Üí Module R (M i)
inst‚úù : Fintype Œπ
j : Œπ
x : AdicCauchySequence I (M j)
i : Œπ
n : ‚Ñï
‚ä¢ ‚Üë((component R Œπ (fun i ‚Ü¶ AdicCompletion I (M i)) i) ((sumInv I M) ((map I (lof R Œπ M j)) ((mk I (M j)) x)))) n =
    ‚Üë((component R Œπ (fun i ‚Ü¶ AdicCompletion I (M i)) i)
          ((lof (AdicCompletion I R) Œπ (fun i ‚Ü¶ AdicCompletion I (M i)) j) ((mk I (M j)) x)))
      n",theorem sumInv_comp_sum : sumInv I M ‚àò‚Çó sum I M = LinearMap.id ,":= by
  ext j x
  apply DirectSum.ext (AdicCompletion I R) (fun i ‚Ü¶ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, map_mk, component_sumInv,
    mk_apply_coe, AdicCauchySequence.map_apply_coe, Submodule.mkQ_apply, LinearMap.id_comp]
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  ¬∑ next h => subst h; simp
  ¬∑ simp",":= by
  ext j x
  apply DirectSum.ext R (fun i ‚Ü¶ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, LinearMap.adicCompletion_mk,
    component_sumInv, mk_apply_coe, LinearMap.adicCauchy_apply_coe, Submodule.mkQ_apply,
    LinearMap.id_comp]
  split
  ¬∑ next h => subst h; simp
  ¬∑ simp"
Mathlib/Topology/Homotopy/HomotopyGroup.lean,GenLoop.homotopicFrom,homotopicFrom,0ea5bd2e88bc0475765f0292fb709ff692758ac2,":= by
  refine Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, ?_, ?_‚ü©, ?_‚ü©
  pick_goal 3
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ rw [H.eq_fst]; exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    first
    | rw [H.apply_zero]
    | rw [H.apply_one]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv","warning:  GenLoop does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (?t, ?x)
case refine_3.intro.inl
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
p q : ‚Üë(Œ©^ N X x)
t : ‚ÜëI
y : N ‚Üí ‚ÜëI
j : N
jH : y j = 0 ‚à® y j = 1
H : Path.Homotopy (toLoop j p) (toLoop j q)
‚ä¢ Function.uncurry (fun x_1 y ‚Ü¶ Function.uncurry (fun x_2 y ‚Ü¶ ‚Üë(H (x_1, x_2)) y) y)
      (Prod.map id ‚áë(Cube.splitAt j).toContinuousMap (t, y)) =
    ‚Üëp y
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (1, ?x)
case refine_1
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
i : N
p q : ‚Üë(Œ©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
x‚úù : N ‚Üí ‚ÜëI
‚ä¢ Function.uncurry (fun x_1 y ‚Ü¶ Function.uncurry (fun x_2 y ‚Ü¶ ‚Üë(H (x_1, x_2)) y) y)
      (Prod.map id ‚áë(Cube.splitAt i).toContinuousMap (0, x‚úù)) =
    ‚Üëp x‚úù
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (1, ?x)
case refine_2
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
i : N
p q : ‚Üë(Œ©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
x‚úù : N ‚Üí ‚ÜëI
‚ä¢ Function.uncurry (fun x_1 y ‚Ü¶ Function.uncurry (fun x_2 y ‚Ü¶ ‚Üë(H (x_1, x_2)) y) y)
      (Prod.map id ‚áë(Cube.splitAt i).toContinuousMap (1, x‚úù)) =
    ‚Üëq x‚úù
error:  unsolved goals
case refine_1
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
i : N
p q : ‚Üë(Œ©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
‚ä¢ ‚àÄ (x_1 : N ‚Üí ‚ÜëI), (homotopyFrom i H).toFun (0, x_1) = ‚Üëp x_1

case refine_2
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
i : N
p q : ‚Üë(Œ©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
‚ä¢ ‚àÄ (x_1 : N ‚Üí ‚ÜëI), (homotopyFrom i H).toFun (1, x_1) = ‚Üëq x_1","theorem homotopicFrom (i : N) {p q : Œ©^ N X x} :
    (toLoop i p).Homotopic (toLoop i q) ‚Üí Homotopic p q ",":= by
  refine Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, ?_, ?_‚ü©, ?_‚ü©
  pick_goal 3
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
        Function.uncurry_apply_pair]
      rw [H.eq_fst]
      exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
      Function.uncurry_apply_pair, ContinuousMap.HomotopyWith.apply_zero,
      ContinuousMap.HomotopyWith.apply_one, ne_eq, Path.coe_toContinuousMap, toLoop_apply_coe,
      ContinuousMap.curry_apply, ContinuousMap.comp_apply]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv",":= by
  refine Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ rw [H.eq_fst]; exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    first
    | rw [H.apply_zero]
    | rw [H.apply_one]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv"
Mathlib/Algebra/Lie/TraceForm.lean,LieModule.traceForm_eq_sum_finrank_nsmul,traceForm_eq_sum_finrank_nsmul,2d8928f07c222f171d2f9371935aa5b8359f9d44,":= by
  have hxy : ‚àÄ œá : Weight K L M, MapsTo (toEndomorphism K L M x ‚àò‚Çó toEndomorphism K L M y)
      (weightSpace M œá) (weightSpace M œá) :=
    fun œá m hm ‚Ü¶ LieSubmodule.lie_mem _ <| LieSubmodule.lie_mem _ hm
  classical
  have hds := DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top
    (LieSubmodule.independent_iff_coe_toSubmodule.mp <| independent_weightSpace' K L M)
    (LieSubmodule.iSup_eq_top_iff_coe_toSubmodule.mp <| iSup_weightSpace_eq_top' K L M)
  simp_rw [traceForm_apply_apply, LinearMap.trace_eq_sum_trace_restrict hds hxy,
    ‚Üê traceForm_weightSpace_eq K L M _ x y]
  rfl","error:  unknown identifier 'toEndomorphism'
error:  unknown identifier 'toEndomorphism'
error:  application type mismatch
  ?m.509739.lie_mem hm
argument
  hm
has type
  m ‚àà ?m.505992 œá : Prop
but is expected to have type
  m ‚àà (‚Üë?m.509739).carrier : Prop","lemma traceForm_eq_sum_finrank_nsmul_mul (x y : L) :
    traceForm K L M x y = ‚àë œá : Weight K L M, finrank K (weightSpace M œá) ‚Ä¢ (œá x * œá y) ",":= by
  have hxy : ‚àÄ œá : Weight K L M, MapsTo (toEnd K L M x ‚àò‚Çó toEnd K L M y)
      (weightSpace M œá) (weightSpace M œá) :=
    fun œá m hm ‚Ü¶ LieSubmodule.lie_mem _ <| LieSubmodule.lie_mem _ hm
  classical
  have hds := DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top
    (LieSubmodule.independent_iff_coe_toSubmodule.mp <| independent_weightSpace' K L M)
    (LieSubmodule.iSup_eq_top_iff_coe_toSubmodule.mp <| iSup_weightSpace_eq_top' K L M)
  simp_rw [traceForm_apply_apply, LinearMap.trace_eq_sum_trace_restrict hds hxy,
    ‚Üê traceForm_weightSpace_eq K L M _ x y]
  rfl",":= by
  have hxy : ‚àÄ œá : Weight K L M, MapsTo (toEnd K L M x ‚àò‚Çó toEnd K L M y)
      (weightSpace M œá) (weightSpace M œá) :=
    fun œá m hm ‚Ü¶ LieSubmodule.lie_mem _ <| LieSubmodule.lie_mem _ hm
  classical
  have hds := DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top
    (LieSubmodule.independent_iff_coe_toSubmodule.mp <| independent_weightSpace' K L M)
    (LieSubmodule.iSup_eq_top_iff_coe_toSubmodule.mp <| iSup_weightSpace_eq_top' K L M)
  simp_rw [traceForm_apply_apply, LinearMap.trace_eq_sum_trace_restrict hds hxy,
    ‚Üê traceForm_weightSpace_eq K L M _ x y]
  rfl"
Mathlib/RingTheory/Smooth/Basic.lean,Algebra.FormallySmooth.iff_split_surjection,iff_split_surjection,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  constructor
  ¬∑ intro
    have surj : Function.Surjective f.kerSquareLift := fun x =>
      ‚ü®Submodule.Quotient.mk (hf x).choose, (hf x).choose_spec‚ü©
    have sqz : RingHom.ker f.kerSquareLift.toRingHom ^ 2 = 0 := by
      rw [AlgHom.ker_kerSquareLift, Ideal.cotangentIdeal_square, Ideal.zero_eq_bot]
    refine'
      ‚ü®FormallySmooth.lift _ ‚ü®2, sqz‚ü© (Ideal.quotientKerAlgEquivOfSurjective surj).symm.toAlgHom,
        _‚ü©
    ext x
    have :=
      (Ideal.quotientKerAlgEquivOfSurjective surj).toAlgHom.congr_arg
        (FormallySmooth.mk_lift _ ‚ü®2, sqz‚ü©
          (Ideal.quotientKerAlgEquivOfSurjective surj).symm.toAlgHom x)
    erw [AlgEquiv.apply_symm_apply] at this
    conv_rhs => rw [‚Üê this, AlgHom.id_apply]
  ¬∑ rintro ‚ü®g, hg‚ü©; exact FormallySmooth.of_split f g hg","error:  unsolved goals
case mp.H
R S : Type u
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : CommSemiring S
P A : Type u
inst‚úù‚Å¥ : CommRing A
inst‚úù¬≥ : Algebra R A
inst‚úù¬≤ : CommRing P
inst‚úù¬π : Algebra R P
I : Ideal P
f : P ‚Üí‚Çê[R] A
hf : Function.Surjective ‚áëf
inst‚úù : FormallySmooth R P
a‚úù : FormallySmooth R A
surj : Function.Surjective ‚áëf.kerSquareLift
sqz : RingHom.ker f.kerSquareLift.toRingHom ^ 2 = 0
x : A
this :
  ‚Üë(Ideal.quotientKerAlgEquivOfSurjective surj)
      ((Ideal.Quotient.mk (RingHom.ker f.kerSquareLift.toRingHom))
        ((lift (RingHom.ker f.kerSquareLift.toRingHom) ‚ãØ ‚Üë(Ideal.quotientKerAlgEquivOfSurjective surj).symm) x)) =
    x
‚ä¢ (f.kerSquareLift.comp
        (lift (RingHom.ker f.kerSquareLift.toRingHom) ‚ãØ ‚Üë(Ideal.quotientKerAlgEquivOfSurjective surj).symm))
      x =
    ‚Üë(Ideal.quotientKerAlgEquivOfSurjective surj)
      ((Ideal.Quotient.mk (RingHom.ker f.kerSquareLift.toRingHom))
        ((lift (RingHom.ker f.kerSquareLift.toRingHom) ‚ãØ ‚Üë(Ideal.quotientKerAlgEquivOfSurjective surj).symm) x))","theorem iff_split_surjection [FormallySmooth R P] :
    FormallySmooth R A ‚Üî ‚àÉ g, f.kerSquareLift.comp g = AlgHom.id R A ",":= by
  constructor
  ¬∑ intro
    have surj : Function.Surjective f.kerSquareLift := fun x =>
      ‚ü®Submodule.Quotient.mk (hf x).choose, (hf x).choose_spec‚ü©
    have sqz : RingHom.ker f.kerSquareLift.toRingHom ^ 2 = 0 := by
      rw [AlgHom.ker_kerSquareLift, Ideal.cotangentIdeal_square, Ideal.zero_eq_bot]
    refine
      ‚ü®FormallySmooth.lift _ ‚ü®2, sqz‚ü© (Ideal.quotientKerAlgEquivOfSurjective surj).symm.toAlgHom,
        ?_‚ü©
    ext x
    have :=
      (Ideal.quotientKerAlgEquivOfSurjective surj).toAlgHom.congr_arg
        (FormallySmooth.mk_lift _ ‚ü®2, sqz‚ü©
          (Ideal.quotientKerAlgEquivOfSurjective surj).symm.toAlgHom x)
    erw [AlgEquiv.apply_symm_apply] at this
    conv_rhs => rw [‚Üê this, AlgHom.id_apply]
    rfl
  ¬∑ rintro ‚ü®g, hg‚ü©; exact FormallySmooth.of_split f g hg",":= by
  constructor
  ¬∑ intro
    have surj : Function.Surjective f.kerSquareLift := fun x =>
      ‚ü®Submodule.Quotient.mk (hf x).choose, (hf x).choose_spec‚ü©
    have sqz : RingHom.ker f.kerSquareLift.toRingHom ^ 2 = 0 := by
      rw [AlgHom.ker_kerSquareLift, Ideal.cotangentIdeal_square, Ideal.zero_eq_bot]
    refine ‚ü®FormallySmooth.lift _ ‚ü®2, sqz‚ü© (Ideal.quotientKerAlgEquivOfSurjective surj).symm.toAlgHom,
        ?_‚ü©
    ext x
    have :=
      (Ideal.quotientKerAlgEquivOfSurjective surj).toAlgHom.congr_arg
        (FormallySmooth.mk_lift _ ‚ü®2, sqz‚ü©
          (Ideal.quotientKerAlgEquivOfSurjective surj).symm.toAlgHom x)
    erw [AlgEquiv.apply_symm_apply] at this
    conv_rhs => rw [‚Üê this, AlgHom.id_apply]
  ¬∑ rintro ‚ü®g, hg‚ü©; exact FormallySmooth.of_split f g hg"
Mathlib/Geometry/Manifold/VectorBundle/Basic.lean,Bundle.contMDiffWithinAt_totalSpace,contMDiffWithinAt_totalSpace,1398a4f8e73f6556f7596e1792ca741fd88f7ba6,":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe, extChartAt_self_apply,
    modelWithCornersSelf_coe, Function.id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]","error:  typeclass instance problem is stuck, it is often due to metavariables
  ChartedSpace ?m.25494 ?m.25497","theorem contMDiffWithinAt_totalSpace (f : M ‚Üí TotalSpace F E) {s : Set M} {x‚ÇÄ : M} :
    ContMDiffWithinAt IM (IB.prod ùìò(ùïú, F)) n f s x‚ÇÄ ‚Üî
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s x‚ÇÄ ‚àß
      ContMDiffWithinAt IM ùìò(ùïú, F) n (fun x ‚Ü¶ (trivializationAt F E (f x‚ÇÄ).proj (f x)).2) s x‚ÇÄ ",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,
    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, ‚Üê chartedSpaceSelf_prod]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe, extChartAt_self_apply,
    modelWithCornersSelf_coe, Function.id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]"
Mathlib/Topology/Category/TopCat/Limits/Products.lean,TopCat.binaryCofan_isColimit_iff,binaryCofan_isColimit_iff,050597bd179a992452551cc51fe5aea3b4bdaf61,":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine' ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inr, _‚ü©
      erw [Set.range_comp, ‚Üê eq_compl_iff_isCompl, coe_comp, coe_comp, Set.range_comp _ Sum.inr,
        ‚Üê Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
      aesop
    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      have : ‚àÄ x, x ‚àà Set.range c.inl ‚à® x ‚àà Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
        exact fun _ => or_not
      refine' ‚ü®BinaryCofan.IsColimit.mk _ _ _ _ _‚ü©
      ¬∑ intro T f g
        refine' ContinuousMap.mk _ _
        ¬∑ exact fun x =>
            if h : x ‚àà Set.range c.inl then f ((Equiv.ofInjective _ h‚ÇÅ.inj).symm ‚ü®x, h‚ü©)
            else g ((Equiv.ofInjective _ h‚ÇÇ.inj).symm ‚ü®x, (this x).resolve_left h‚ü©)
        rw [continuous_iff_continuousAt]
        intro x
        by_cases h : x ‚àà Set.range c.inl
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            convert_to Continuous (f ‚àò h‚ÇÅ.toEmbedding.toHomeomorph.symm)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_pos hx
            apply Continuous.comp
            ¬∑ exact f.continuous_toFun
            ¬∑ continuity
          ¬∑ exact h‚ÇÅ.isOpen_range
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            have : ‚àÄ a, a ‚àâ Set.range c.inl ‚Üí a ‚àà Set.range c.inr := by
              rintro a (h : a ‚àà (Set.range c.inl)·∂ú)
              rwa [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            convert_to Continuous
                (g ‚àò h‚ÇÇ.toEmbedding.toHomeomorph.symm ‚àò Subtype.map _ this)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_neg hx
            apply Continuous.comp
            ¬∑ exact g.continuous_toFun
            ¬∑ apply Continuous.comp
              ¬∑ continuity
              ¬∑ rw [embedding_subtype_val.toInducing.continuous_iff]
                exact continuous_subtype_val
          ¬∑ change IsOpen (Set.range c.inl)·∂ú
            rw [‚Üê eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            exact h‚ÇÇ.isOpen_range
      ¬∑ intro T f g
        ext x
        refine' (dif_pos _).trans _
        ¬∑ exact ‚ü®x, rfl‚ü©
        ¬∑ dsimp; conv_lhs => erw [Equiv.ofInjective_symm_apply]
      ¬∑ intro T f g
        ext x
        refine' (dif_neg _).trans _
        ¬∑ rintro ‚ü®y, e‚ü©
          have : c.inr x ‚àà Set.range c.inl ‚äì Set.range c.inr := ‚ü®‚ü®_, e‚ü©, ‚ü®_, rfl‚ü©‚ü©
          rwa [disjoint_iff.mp h‚ÇÉ.1] at this
        ¬∑ exact congr_arg g (Equiv.ofInjective_symm_apply _ _)
      ¬∑ rintro T _ _ m rfl rfl
        ext x
        change m x = dite _ _ _
        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ‚ü®_, _‚ü©).symm","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚áë(?f ‚â´ ?g)
case mp.intro
J : Type v
inst‚úù : SmallCategory J
X Y : TopCat
c : BinaryCofan X Y
h : IsColimit c
‚ä¢ ‚áë(h.coconePointUniqueUpToIso (X.binaryCofanIsColimit Y)).inv '' Set.range ‚áë(X.binaryCofan Y).inl =
    (Set.range (‚áë(h.coconePointUniqueUpToIso (X.binaryCofanIsColimit Y)).inv ‚àò ‚áë(X.binaryCofan Y).inr))·∂ú
error:  invalid field 'toHomeomorph', the environment does not contain 'Embedding.toHomeomorph'
  h‚ÇÅ.toEmbedding
has type
  Embedding ‚áëc.inl
error:  tactic 'aesop' failed, failed to prove the goal after exhaustive search.
Initial goal:
  case pos.convert_3.hf
  J : Type v
  inst‚úù : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  h‚ÇÅ : OpenEmbedding ‚áëc.inl
  h‚ÇÇ : OpenEmbedding ‚áëc.inr
  h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
  this :
    ‚àÄ (x : ‚Üë(((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := WalkingPair.left })),
      x ‚àà Set.range ‚áëc.inl ‚à® x ‚àà Set.range ‚áëc.inr
  T : TopCat
  f : X ‚ü∂ T
  g : Y ‚ü∂ T
  ‚ä¢ Continuous (sorryAx (‚Üë(Set.range ‚áëc.inl) ‚Üí ‚ÜëX) true)
Remaining goals after safe rules:
  J : Type v
  inst : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  T : TopCat
  f : X ‚ü∂ T
  g : Y ‚ü∂ T
  h‚ÇÅ : OpenEmbedding ‚áëc.inl
  h‚ÇÇ : OpenEmbedding ‚áëc.inr
  h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
  this : ‚àÄ (x : ‚Üëc.pt), (‚àÉ y, c.inl y = x) ‚à® ‚àÉ y, c.inr y = x
  ‚ä¢ Continuous (sorryAx (‚Üë(Set.range ‚áëc.inl) ‚Üí ‚ÜëX) true)
error:  invalid field 'toHomeomorph', the environment does not contain 'Embedding.toHomeomorph'
  h‚ÇÇ.toEmbedding
has type
  Embedding ‚áëc.inr
error:  tactic 'aesop' failed, failed to prove the goal after exhaustive search.
Initial goal:
  case neg.hf.hg
  J : Type v
  inst‚úù : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  h‚ÇÅ : OpenEmbedding ‚áëc.inl
  h‚ÇÇ : OpenEmbedding ‚áëc.inr
  h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
  this‚úù :
    ‚àÄ (x : ‚Üë(((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := WalkingPair.left })),
      x ‚àà Set.range ‚áëc.inl ‚à® x ‚àà Set.range ‚áëc.inr
  T : TopCat
  f : X ‚ü∂ T
  g : Y ‚ü∂ T
  this : ‚àÄ a ‚àâ Set.range ‚áëc.inl, a ‚àà Set.range ‚áëc.inr
  ‚ä¢ Continuous (sorryAx (Subtype Exists ‚Üí ‚ÜëY) true)
Remaining goals after safe rules:
  J : Type v
  inst : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  T : TopCat
  f : X ‚ü∂ T
  g : Y ‚ü∂ T
  h‚ÇÅ : OpenEmbedding ‚áëc.inl
  h‚ÇÇ : OpenEmbedding ‚áëc.inr
  h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
  this_1 : ‚àÄ (x : ‚Üëc.pt), (‚àÉ y, c.inl y = x) ‚à® ‚àÉ y, c.inr y = x
  this : ‚àÄ (a : ‚Üëc.pt), (‚àÄ (x : ‚ÜëX), ¬¨c.inl x = a) ‚Üí ‚àÉ y, c.inr y = a
  ‚ä¢ Continuous (sorryAx (Subtype Exists ‚Üí ‚ÜëY) true)
error:  type mismatch
  continuous_subtype_val
has type
  Continuous Subtype.val : Prop
but is expected to have type
  Continuous (Subtype.val ‚àò Subtype.map (fun a y ‚Ü¶ c.inr y = a) this) : Prop
error:  unsolved goals
case mpr.intro.intro.refine'_2.w.refine'_2
J : Type v
inst‚úù : SmallCategory J
X Y : TopCat
c : BinaryCofan X Y
h‚ÇÅ : OpenEmbedding ‚áëc.inl
h‚ÇÇ : OpenEmbedding ‚áëc.inr
h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
this :
  ‚àÄ (x : ‚Üë(((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := WalkingPair.left })),
    x ‚àà Set.range ‚áëc.inl ‚à® x ‚àà Set.range ‚áëc.inr
T : TopCat
f : X ‚ü∂ T
g : Y ‚ü∂ T
x : (forget TopCat).obj ((pair X Y).obj { as := WalkingPair.left })
‚ä¢ f x = f x","theorem binaryCofan_isColimit_iff {X Y : TopCat} (c : BinaryCofan X Y) :
    Nonempty (IsColimit c) ‚Üî
      OpenEmbedding c.inl ‚àß OpenEmbedding c.inr ‚àß IsCompl (Set.range c.inl) (Set.range c.inr) ",":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inr, ?_‚ü©
      erw [Set.range_comp, ‚Üê eq_compl_iff_isCompl, Set.range_comp _ Sum.inr,
        ‚Üê Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      have : ‚àÄ x, x ‚àà Set.range c.inl ‚à® x ‚àà Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
        exact fun _ => or_not
      refine ‚ü®BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_‚ü©
      ¬∑ intro T f g
        refine ContinuousMap.mk ?_ ?_
        ¬∑ exact fun x =>
            if h : x ‚àà Set.range c.inl then f ((Equiv.ofInjective _ h‚ÇÅ.inj).symm ‚ü®x, h‚ü©)
            else g ((Equiv.ofInjective _ h‚ÇÇ.inj).symm ‚ü®x, (this x).resolve_left h‚ü©)
        rw [continuous_iff_continuousAt]
        intro x
        by_cases h : x ‚àà Set.range c.inl
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            convert_to Continuous (f ‚àò (Homeomorph.ofEmbedding _ h‚ÇÅ.toEmbedding).symm)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_pos hx
            apply Continuous.comp
            ¬∑ exact f.continuous_toFun
            ¬∑ continuity
          ¬∑ exact h‚ÇÅ.isOpen_range
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            have : ‚àÄ a, a ‚àâ Set.range c.inl ‚Üí a ‚àà Set.range c.inr := by
              rintro a (h : a ‚àà (Set.range c.inl)·∂ú)
              rwa [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            convert_to Continuous
                (g ‚àò (Homeomorph.ofEmbedding _ h‚ÇÇ.toEmbedding).symm ‚àò Subtype.map _ this)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_neg hx
            apply Continuous.comp
            ¬∑ exact g.continuous_toFun
            ¬∑ apply Continuous.comp
              ¬∑ continuity
              ¬∑ rw [embedding_subtype_val.toInducing.continuous_iff]
                exact continuous_subtype_val
          ¬∑ change IsOpen (Set.range c.inl)·∂ú
            rw [‚Üê eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            exact h‚ÇÇ.isOpen_range
      ¬∑ intro T f g
        ext x
        refine (dif_pos ?_).trans ?_
        ¬∑ exact ‚ü®x, rfl‚ü©
        ¬∑ dsimp
          conv_lhs => erw [Equiv.ofInjective_symm_apply]
          rfl 
      ¬∑ intro T f g
        ext x
        refine (dif_neg ?_).trans ?_
        ¬∑ rintro ‚ü®y, e‚ü©
          have : c.inr x ‚àà Set.range c.inl ‚äì Set.range c.inr := ‚ü®‚ü®_, e‚ü©, ‚ü®_, rfl‚ü©‚ü©
          rwa [disjoint_iff.mp h‚ÇÉ.1] at this
        ¬∑ exact congr_arg g (Equiv.ofInjective_symm_apply _ _)
      ¬∑ rintro T _ _ m rfl rfl
        ext x
        change m x = dite _ _ _
        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ‚ü®_, _‚ü©).symm",":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
           (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
           (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
      aesop
    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      have : ‚àÄ x, x ‚àà Set.range c.inl ‚à® x ‚àà Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
        exact fun _ => or_not
      refine ‚ü®BinaryCofan.IsColimit.mk _ _ _ _ ?_‚ü©
      ¬∑ intro T f g
        refine ContinuousMap.mk ?_ ?_
        ¬∑ exact fun x =>
            if h : x ‚àà Set.range c.inl then f ((Equiv.ofInjective _ h‚ÇÅ.inj).symm ‚ü®x, h‚ü©)
            else g ((Equiv.o"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,d925bcb6a40d20ae582767f1a25d9e5251b014c6,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_ad"
Mathlib/SetTheory/Cardinal/Ordinal.lean,Cardinal.mul_eq_self,mul_eq_self,2b42dc7c3f9ebf6e7f17bff850d9c0bc3f1cf75e,":= by
  refine' le_antisymm _ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine' Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => _) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  skip
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine' le_of_forall_lt fun o h => _
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine'
    lt_of_le_of_lt (_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p))))
      _
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } :=
      by
      intro q h
      simp only [Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit
    ¬∑
      exact
        ‚ü®(Set.embeddingOfSubset _ _ this).trans
            ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine' (Equiv.Set.insert _).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein (¬∑ < ¬∑) (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices : (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß
    ¬∑ exact (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type","error:  unexpected token '¬∑'; expected 'by' or 'from'
error:  unsolved goals
case intro.intro.intro.refine'_2
c‚úù : Cardinal.{u_1}
h‚úù : ‚Ñµ‚ÇÄ ‚â§ c‚úù
c : Cardinal.{u_1}
x‚úù : ‚àÄ y < c, Acc (fun x x_1 ‚Ü¶ x < x_1) y
Œ± : Type u_1
IH : ‚àÄ y < ‚ü¶Œ±‚üß, ‚Ñµ‚ÇÄ ‚â§ y ‚Üí y * y ‚â§ y
ol : ‚Ñµ‚ÇÄ ‚â§ ‚ü¶Œ±‚üß
r : Œ± ‚Üí Œ± ‚Üí Prop
wo : IsWellOrder Œ± r
e : (#Œ±).ord = type r
this‚úù¬π : LinearOrder Œ± := linearOrderOfSTO r
this‚úù : IsWellOrder Œ± fun x x_1 ‚Ü¶ x < x_1
g : Œ± √ó Œ± ‚Üí Œ± := fun p ‚Ü¶ max p.1 p.2
f : Œ± √ó Œ± ‚Ü™ Ordinal.{u_1} √ó Œ± √ó Œ± := { toFun := fun p ‚Ü¶ (typein (fun x x_1 ‚Ü¶ x < x_1) (g p), p), inj' := ‚ãØ }
s : Œ± √ó Œ± ‚Üí Œ± √ó Œ± ‚Üí Prop := ‚áëf ‚Åª¬π'o Prod.Lex (fun x x_1 ‚Ü¶ x < x_1) (Prod.Lex (fun x x_1 ‚Ü¶ x < x_1) fun x x_1 ‚Ü¶ x < x_1)
this : IsWellOrder (Œ± √ó Œ±) s
p : Œ± √ó Œ±
h : typein s p < type s
‚ä¢ (succ (typein (fun x x_1 ‚Ü¶ x < x_1) (g p))).card * (succ (typein (fun x x_1 ‚Ü¶ x < x_1) (g p))).card < #Œ±",theorem mul_eq_self {c : Cardinal} (h : ‚Ñµ‚ÇÄ ‚â§ c) : c * c = c ,":= by
  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => ?_) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine le_of_forall_lt fun o h => ?_
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine lt_of_le_of_lt
    (?_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p)))) ?_
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [s, f, Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit from
      ‚ü®(Set.embeddingOfSubset _ _ this).trans
        ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine (Equiv.Set.insert ?_).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein (¬∑ < ¬∑) (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß from (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type",":= by
  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => ?_) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  skip
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine le_of_forall_lt fun o h => ?_
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine
    lt_of_le_of_lt (_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p)))
      ?_
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } :=
      by
      intro q h
      simp only [Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit
    ¬∑
      exact
        ‚ü®(Set.embeddingOfSubset _ _ this).trans
            ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine (Equiv.Set.insert _).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein LT.lt (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß
    ¬∑ exact (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type"
Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean,MeasureTheory.integral_comp_smul_deriv_Ioi,integral_comp_smul_deriv_Ioi,e92ad7acc4d771729f70601a74a3c091f330e507,":= by
  have eq : ‚àÄ b : ‚Ñù, a < b ‚Üí (‚à´ x in [a:b], f' x ‚Ä¢ (g ‚àò f) x) = ‚à´ u in [f a:f b], g u := fun b hb ‚Ü¶ by
    have i1 : Ioo (min a b) (max a b) ‚äÜ Ioi a := by
      rw [min_eq_left hb.le]
      exact Ioo_subset_Ioi_self
    have i2 : [[a, b]] ‚äÜ Ici a := by rw [uIcc_of_le hb.le]; exact Icc_subset_Ici_self
    refine'
      intervalIntegral.integral_comp_smul_deriv''' (hf.mono i2)
        (fun x hx => hff' x <| mem_of_mem_of_subset hx i1) (hg_cont.mono <| image_subset _ _)
        (hg1.mono_set <| image_subset _ _) (hg2.mono_set i2)
    ¬∑ rw [min_eq_left hb.le]; exact Ioo_subset_Ioi_self
    ¬∑ rw [uIcc_of_le hb.le]; exact Icc_subset_Ici_self
  rw [integrableOn_Ici_iff_integrableOn_Ioi] at hg2
  have t2 := intervalIntegral_tendsto_integral_Ioi _ hg2 tendsto_id
  have : Ioi (f a) ‚äÜ f '' Ici a :=
    Ioi_subset_Ici_self.trans <|
      IsPreconnected.intermediate_value_Ici isPreconnected_Ici left_mem_Ici
        (le_principal_iff.mpr <| Ici_mem_atTop _) hf hft
  have t1 := (intervalIntegral_tendsto_integral_Ioi _ (hg1.mono_set this) tendsto_id).comp hft
  exact tendsto_nhds_unique (Tendsto.congr' (eventuallyEq_of_mem (Ioi_mem_atTop a) eq) t2) t1","error:  type mismatch
  a
has type
  ‚Ñù : Type
but is expected to have type
  ‚Ñï : Type
error:  type mismatch
  b
has type
  ‚Ñù : Type
but is expected to have type
  ‚Ñï : Type
error:  type mismatch
  f a
has type
  ‚Ñù : Type
but is expected to have type
  ‚Ñï : Type
error:  type mismatch
  f b
has type
  ‚Ñù : Type
but is expected to have type
  ‚Ñï : Type","theorem integral_comp_smul_deriv_Ioi {f f' : ‚Ñù ‚Üí ‚Ñù} {g : ‚Ñù ‚Üí E} {a : ‚Ñù}
    (hf : ContinuousOn f <| Ici a) (hft : Tendsto f atTop atTop)
    (hff' : ‚àÄ x ‚àà Ioi a, HasDerivWithinAt f (f' x) (Ioi x) x)
    (hg_cont : ContinuousOn g <| f '' Ioi a) (hg1 : IntegrableOn g <| f '' Ici a)
    (hg2 : IntegrableOn (fun x => f' x ‚Ä¢ (g ‚àò f) x) (Ici a)) :
    (‚à´ x in Ioi a, f' x ‚Ä¢ (g ‚àò f) x) = ‚à´ u in Ioi (f a), g u ",":= by
  have eq : ‚àÄ b : ‚Ñù, a < b ‚Üí (‚à´ x in a..b, f' x ‚Ä¢ (g ‚àò f) x) = ‚à´ u in f a..f b, g u := fun b hb ‚Ü¶ by
    have i1 : Ioo (min a b) (max a b) ‚äÜ Ioi a := by
      rw [min_eq_left hb.le]
      exact Ioo_subset_Ioi_self
    have i2 : [[a, b]] ‚äÜ Ici a := by rw [uIcc_of_le hb.le]; exact Icc_subset_Ici_self
    refine
      intervalIntegral.integral_comp_smul_deriv''' (hf.mono i2)
        (fun x hx => hff' x <| mem_of_mem_of_subset hx i1) (hg_cont.mono <| image_subset _ ?_)
        (hg1.mono_set <| image_subset _ ?_) (hg2.mono_set i2)
    ¬∑ rw [min_eq_left hb.le]; exact Ioo_subset_Ioi_self
    ¬∑ rw [uIcc_of_le hb.le]; exact Icc_subset_Ici_self
  rw [integrableOn_Ici_iff_integrableOn_Ioi] at hg2
  have t2 := intervalIntegral_tendsto_integral_Ioi _ hg2 tendsto_id
  have : Ioi (f a) ‚äÜ f '' Ici a :=
    Ioi_subset_Ici_self.trans <|
      IsPreconnected.intermediate_value_Ici isPreconnected_Ici left_mem_Ici
        (le_principal_iff.mpr <| Ici_mem_atTop _) hf hft
  have t1 := (intervalIntegral_tendsto_integral_Ioi _ (hg1.mono_set this) tendsto_id).comp hft
  exact tendsto_nhds_unique (Tendsto.congr' (eventuallyEq_of_mem (Ioi_mem_atTop a) eq) t2) t1",":= by
  have eq : ‚àÄ b : ‚Ñù, a < b ‚Üí (‚à´ x in [a:b], f' x ‚Ä¢ (g ‚àò f) x) = ‚à´ u in [f a:f b], g u := fun b hb ‚Ü¶ by
    have i1 : Ioo (min a b) (max a b) ‚äÜ Ioi a := by
      rw [min_eq_left hb.le]
      exact Ioo_subset_Ioi_self
    have i2 : [[a, b]] ‚äÜ Ici a := by rw [uIcc_of_le hb.le]; exact Icc_subset_Ici_self
    refine
      intervalIntegral.integral_comp_smul_deriv''' (hf.mono i2)
        (fun x hx => hff' x <| mem_of_mem_of_subset hx i1) (hg_cont.mono <| image_subset _ _)
        (hg1.mono_set <| image_subset _ _) (hg2.mono_set i2)
    ¬∑ rw [min_eq_left hb.le]; exact Ioo_subset_Ioi_self
    ¬∑ rw [uIcc_of_le hb.le]; exact Icc_subset_Ici_self
  rw [integrableOn_Ici_iff_integrableOn_Ioi] at hg2
  have t2 := intervalIntegral_tendsto_integral_Ioi _ hg2 tendsto_id
  have : Ioi (f a) ‚äÜ f '' Ici a :=
    Ioi_subset_Ici_self.trans <|
      IsPreconnected.intermediate_value_Ici isPreconnected_Ici left_mem_Ici
        (le_principal_iff.mpr <| Ici_mem_atTop _) hf hft
  have t1 := (intervalIntegral_tendsto_integral_Ioi _ (hg1.mono_set this) tendsto_id).comp hft
  exact tendsto_nhds_unique (Tendsto.congr' (eventuallyEq_of_mem (Ioi_mem_atTop a) eq) t2) t1"
Mathlib/NumberTheory/FunctionField.lean,functionField_iff,functionField_iff,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  let e := IsLocalization.algEquiv Fq[X]‚Å∞ (RatFunc Fq) Fqt
  have : ‚àÄ (c) (x : F), e c ‚Ä¢ x = c ‚Ä¢ x := by
    intro c x
    rw [Algebra.smul_def, Algebra.smul_def]
    congr
    refine congr_fun (f := fun c => algebraMap Fqt F (e c)) ?_ c 
    refine IsLocalization.ext (nonZeroDivisors Fq[X]) _ _ ?_ ?_? _? ?_ _ <;> intros <;>
      simp only [AlgEquiv.map_one, RingHom.map_one, AlgEquiv.map_mul, RingHom.map_mul,
        AlgEquiv.commutes, ‚Üê IsScalarTower.algebraMap_apply]
  constructor <;> intro h
  ¬∑ let b := FiniteDimensional.finBasis (RatFunc Fq) F
    exact FiniteDimensional.of_fintype_basis (b.mapCoeffs e this)
  ¬∑ let b := FiniteDimensional.finBasis Fqt F
    refine FiniteDimensional.of_fintype_basis (b.mapCoeffs e.symm ?_)
    intro c x; convert (this (e.symm c) x).symm; simp only [e.apply_symm_apply]",error:  unknown identifier '_?',"theorem functionField_iff (Fqt : Type*) [Field Fqt] [Algebra Fq[X] Fqt]
    [IsFractionRing Fq[X] Fqt] [Algebra (RatFunc Fq) F] [Algebra Fqt F] [Algebra Fq[X] F]
    [IsScalarTower Fq[X] Fqt F] [IsScalarTower Fq[X] (RatFunc Fq) F] :
    FunctionField Fq F ‚Üî FiniteDimensional Fqt F ",":= by
  let e := IsLocalization.algEquiv Fq[X]‚Å∞ (RatFunc Fq) Fqt
  have : ‚àÄ (c) (x : F), e c ‚Ä¢ x = c ‚Ä¢ x := by
    intro c x
    rw [Algebra.smul_def, Algebra.smul_def]
    congr
    refine congr_fun (f := fun c => algebraMap Fqt F (e c)) ?_ c 
    refine IsLocalization.ext (nonZeroDivisors Fq[X]) _ _ ?_ ?_ ?_ ?_ ?_ <;> intros <;>
      simp only [map_one, map_mul, AlgEquiv.commutes, ‚Üê IsScalarTower.algebraMap_apply]
  constructor <;> intro h
  ¬∑ let b := FiniteDimensional.finBasis (RatFunc Fq) F
    exact FiniteDimensional.of_fintype_basis (b.mapCoeffs e this)
  ¬∑ let b := FiniteDimensional.finBasis Fqt F
    refine FiniteDimensional.of_fintype_basis (b.mapCoeffs e.symm ?_)
    intro c x; convert (this (e.symm c) x).symm; simp only [e.apply_symm_apply]",":= by
  let e := IsLocalization.algEquiv Fq[X]‚Å∞ (RatFunc Fq) Fqt
  have : ‚àÄ (c) (x : F), e c ‚Ä¢ x = c ‚Ä¢ x := by
    intro c x
    rw [Algebra.smul_def, Algebra.smul_def]
    congr
    refine congr_fun (f := fun c => algebraMap Fqt F (e c)) ?_ c 
    refine IsLocalization.ext (nonZeroDivisors Fq[X]) ?_ ?_ ?_ ?_ ?_ ?_ <;> intros <;>
      simp only [AlgEquiv.map_one, RingHom.map_one, AlgEquiv.map_mul, RingHom.map_mul,
        AlgEquiv.commutes, ‚Üê IsScalarTower.algebraMap_apply]
  constructor <;> intro h
  ¬∑ let b := FiniteDimensional.finBasis (RatFunc Fq) F
    exact FiniteDimensional.of_fintype_basis (b.mapCoeffs e this)
  ¬∑ let b := FiniteDimensional.finBasis Fqt F
    refine FiniteDimensional.of_fintype_basis (b.mapCoeffs e.symm ?_)
    intro c x; convert (this (e.symm c) x).symm; simp only [e.apply_symm_apply]"
Mathlib/MeasureTheory/Function/LpSpace.lean,MeasureTheory.indicatorConstLp_eq_toSpanSingleton_compLp,indicatorConstLp_eq_toSpanSingleton_compLp,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext1
  refine indicatorConstLp_coeFn.trans ?_
  have h_compLp :=
    (ContinuousLinearMap.toSpanSingleton ‚Ñù x).coeFn_compLp (indicatorConstLp 2 hs hŒºs (1 : ‚Ñù))
  rw [‚Üê EventuallyEq] at h_compLp
  refine EventuallyEq.trans ?_ h_compLp.symm
  refine (@indicatorConstLp_coeFn _ _ _ 2 Œº _ s hs hŒºs (1 : ‚Ñù)).mono fun y hy => ?_
  dsimp only
  rw [hy]
  simp_rw [ContinuousLinearMap.toSpanSingleton_apply]
  by_cases hy_mem : y ‚àà s <;> simp [hy_mem, ContinuousLinearMap.lsmul_apply]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  ContinuousLinearMap
has type
  (?m.664723 ‚Üí+* ?m.664724) ‚Üí
    (M : Type ?u.664720) ‚Üí
      [inst : TopologicalSpace M] ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          (M‚ÇÇ : Type ?u.664719) ‚Üí
            [inst_1 : TopologicalSpace M‚ÇÇ] ‚Üí
              [inst_2 : AddCommMonoid M‚ÇÇ] ‚Üí
                [inst : Module ?m.664723 M] ‚Üí [inst : Module ?m.664724 M‚ÇÇ] ‚Üí Type (max ?u.664720 ?u.664719)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  ContinuousLinearMap
has type
  (?m.666508 ‚Üí+* ?m.666509) ‚Üí
    (M : Type ?u.666505) ‚Üí
      [inst : TopologicalSpace M] ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          (M‚ÇÇ : Type ?u.666504) ‚Üí
            [inst_1 : TopologicalSpace M‚ÇÇ] ‚Üí
              [inst_2 : AddCommMonoid M‚ÇÇ] ‚Üí
                [inst : Module ?m.666508 M] ‚Üí [inst : Module ?m.666509 M‚ÇÇ] ‚Üí Type (max ?u.666505 ?u.666504)","theorem indicatorConstLp_eq_toSpanSingleton_compLp {s : Set Œ±} [NormedSpace ‚Ñù F]
    (hs : MeasurableSet s) (hŒºs : Œº s ‚â† ‚àû) (x : F) :
    indicatorConstLp 2 hs hŒºs x =
      (ContinuousLinearMap.toSpanSingleton ‚Ñù x).compLp (indicatorConstLp 2 hs hŒºs (1 : ‚Ñù)) ",":= by
  ext1
  refine indicatorConstLp_coeFn.trans ?_
  have h_compLp :=
    (ContinuousLinearMap.toSpanSingleton ‚Ñù x).coeFn_compLp (indicatorConstLp 2 hs hŒºs (1 : ‚Ñù))
  rw [‚Üê EventuallyEq] at h_compLp
  refine EventuallyEq.trans ?_ h_compLp.symm
  refine (@indicatorConstLp_coeFn _ _ _ 2 Œº _ s hs hŒºs (1 : ‚Ñù)).mono fun y hy => ?_
  dsimp only
  rw [hy]
  simp_rw [ContinuousLinearMap.toSpanSingleton_apply]
  by_cases hy_mem : y ‚àà s <;> simp [hy_mem]",":= by
  ext1
  refine indicatorConstLp_coeFn.trans ?_
  have h_compLp :=
    (ContinuousLinearMap.toSpanSingleton ‚Ñù x).coeFn_compLp (indicatorConstLp 2 hs hŒºs (1 : ‚Ñù))
  rw [‚Üê EventuallyEq] at h_compLp
  refine EventuallyEq.trans ?_ h_compLp.symm
  refine (@indicatorConstLp_coeFn _ _ _ 2 Œº _ s hs hŒºs (1 : ‚Ñù)).mono fun y hy => ?_
  dsimp only [hy]
  simp_rw [ContinuousLinearMap.toSpanSingleton_apply]
  by_cases hy_mem : y ‚àà s <;> simp [hy_mem, ContinuousLinearMap.lsmul_apply]"
Mathlib/LinearAlgebra/CliffordAlgebra/EvenEquiv.lean,CliffordAlgebra.EquivEven.neg_e0_mul_v,neg_e0_mul_v,b230323edbbae116cd0d4712c238e553cdcccb9e,":= by
  refine' neg_eq_of_add_eq_zero_right ((Œπ_mul_Œπ_add_swap _ _).trans _)
  dsimp [QuadraticMap.polar]
  simp only [add_zero, mul_zero, mul_one, zero_add, neg_zero, QuadraticMap.map_zero,
    add_sub_cancel_right, sub_self, map_zero, zero_sub]","error:  unknown identifier 'QuadraticMap.polar'
error:  unknown identifier 'QuadraticMap.map_zero'
error:  simp made no progress",theorem neg_e0_mul_v (m : M) : -(e0 Q * v Q m) = v Q m * e0 Q ,":= by
  refine neg_eq_of_add_eq_zero_right ((Œπ_mul_Œπ_add_swap _ _).trans ?_)
  dsimp [QuadraticForm.polar]
  simp only [add_zero, mul_zero, mul_one, zero_add, neg_zero, QuadraticForm.map_zero,
    add_sub_cancel_right, sub_self, map_zero, zero_sub]",":= by
  refine neg_eq_of_add_eq_zero_right ((Œπ_mul_Œπ_add_swap _ _).trans ?_)
  dsimp [QuadraticMap.polar]
  simp only [add_zero, mul_zero, mul_one, zero_add, neg_zero, QuadraticMap.map_zero,
    add_sub_cancel_right, sub_self, map_zero, zero_sub]"
Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean,FiniteField.isSquare_two_iff,FiniteField.isSquare_two_iff,0829989fb05c0f3d0ef2ff405811515ae4ea6aa2,":= by
  classical
  by_cases hF : ringChar F = 2
  focus
    have h := FiniteField.even_card_of_char_two hF
    simp only [FiniteField.isSquare_of_char_two hF, true_iff_iff]
  rotate_left
  focus
    have h := FiniteField.odd_card_of_char_ne_two hF
    rw [‚Üê quadraticChar_one_iff_isSquare (Ring.two_ne_zero hF), quadraticChar_two hF,
      œá‚Çà_nat_eq_if_mod_eight]
    simp only [h, Nat.one_ne_zero, if_false, ite_eq_left_iff, Ne.def, (by decide : (-1 : ‚Ñ§) ‚â† 1),
      imp_false, Classical.not_not]
  all_goals
    rw [‚Üê Nat.mod_mod_of_dvd _ (by decide : 2 ‚à£ 8)] at h
    have h‚ÇÅ := Nat.mod_lt (Fintype.card F) (by decide : 0 < 8)
    revert h‚ÇÅ h
    generalize Fintype.card F % 8 = n
    intros; interval_cases n <;> simp_all ","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.9728 ‚Üí ?m.9728 ‚Üí Prop","theorem FiniteField.isSquare_two_iff :
    IsSquare (2 : F) ‚Üî Fintype.card F % 8 ‚â† 3 ‚àß Fintype.card F % 8 ‚â† 5 ",":= by
  classical
  by_cases hF : ringChar F = 2
  ¬∑ have h := FiniteField.even_card_of_char_two hF
    simp only [FiniteField.isSquare_of_char_two hF, true_iff_iff]
    omega
  ¬∑ have h := FiniteField.odd_card_of_char_ne_two hF
    rw [‚Üê quadraticChar_one_iff_isSquare (Ring.two_ne_zero hF), quadraticChar_two hF,
      œá‚Çà_nat_eq_if_mod_eight]
    omega",":= by
  classical
  by_cases hF : ringChar F = 2
  focus
    have h := FiniteField.even_card_of_char_two hF
    simp only [FiniteField.isSquare_of_char_two hF, true_iff_iff]
  rotate_left
  focus
    have h := FiniteField.odd_card_of_char_ne_two hF
    rw [‚Üê quadraticChar_one_iff_isSquare (Ring.two_ne_zero hF), quadraticChar_two hF,
      œá‚Çà_nat_eq_if_mod_eight]
    simp only [h, Nat.one_ne_zero, if_false, ite_eq_left_iff, Ne, (by decide : (-1 : ‚Ñ§) ‚â† 1),
      imp_false, Classical.not_not]
  all_goals
    rw [‚Üê Nat.mod_mod_of_dvd _ (by decide : 2 ‚à£ 8)] at h
    have h‚ÇÅ := Nat.mod_lt (Fintype.card F) (by decide : 0 < 8)
    revert h‚ÇÅ h
    generalize Fintype.card F % 8 = n
    intros; interval_cases n <;> simp_all"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  simp made no progress
warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metri"
Mathlib/Analysis/LocallyConvex/Basic.lean,Balanced.absorbs_self,Balanced.absorbs_self,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  refine' ‚ü®1, zero_lt_one, fun a ha x hx => _‚ü©
  rw [mem_smul_set_iff_inv_smul_mem‚ÇÄ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]
  refine' hA a‚Åª¬π _ (smul_mem_smul_set hx)
  rw [norm_inv]
  exact inv_le_one ha","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  (Bornology.cobounded ùïú).1 {x | (fun a ‚Ü¶ A ‚äÜ a ‚Ä¢ A) x}
error:  no goals to be solved",theorem Balanced.absorbs_self (hA : Balanced ùïú A) : Absorbs ùïú A A ,":=
  .of_norm ‚ü®1, fun _ => hA.subset_smul‚ü©",":= by
  refine ‚ü®1, zero_lt_one, fun a ha x hx => ?_‚ü©
  rw [mem_smul_set_iff_inv_smul_mem‚ÇÄ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]
  refine hA a‚Åª¬π _ (smul_mem_smul_set hx) ?_"
Mathlib/Topology/UniformSpace/Compact.lean,CompactSpace.uniformContinuous_of_continuous,CompactSpace.uniformContinuous_of_continuous,ff33484322fbce1ead24eb4ca948306955c68664,":=
  have : Tendsto (Prod.map f f) (ùìùÀ¢ (diagonal Œ±)) (ùìùÀ¢ (diagonal Œ≤)) :=
    (h.prod_map h).tendsto_nhdsSet mapsTo_prod_map_diagonal
  (this.mono_left nhdsSet_diagonal_eq_uniformity.ge).mono_right nhdsSet_diagonal_le_uniformity",error:  unexpected token 'calc'; expected command,"theorem CompactSpace.uniformContinuous_of_continuous [CompactSpace Œ±] {f : Œ± ‚Üí Œ≤}
    (h : Continuous f) : UniformContinuous f ",:=,":=
  have : Tendsto (Prod.map f f) (ùìùÀ¢ (diagonal Œ±)) (ùìùÀ¢ (diagonal Œ≤)) :=
    (h.prod_map h).tendsto_nhdsSet mapsTo_prod_map_diagonal
  (this.mono_left nhdsSet_diagonal_eq_uniformity.ge).mono_right nhdsSet_diagonal_le_uniformity"
Mathlib/Topology/UniformSpace/Compact.lean,nhdsSet_diagonal_eq_uniformity,nhdsSet_diagonal_eq_uniformity,f9ae3115c6e504194a2eb51ce073c473ad6ee510,":= by
  refine' nhdsSet_diagonal_le_uniformity.antisymm _
  have :
    (ùì§ (Œ± √ó Œ±)).HasBasis (fun U => U ‚àà ùì§ Œ±) fun U =>
      (fun p : (Œ± √ó Œ±) √ó Œ± √ó Œ± => ((p.1.1, p.2.1), p.1.2, p.2.2)) ‚Åª¬π' U √óÀ¢ U := by
    rw [uniformity_prod_eq_comap_prod]
    exact (ùì§ Œ±).basis_sets.prod_self.comap _
  refine' (isCompact_diagonal.nhdsSet_basis_uniformity this).ge_iff.2 fun U hU => _
  exact mem_of_superset hU fun ‚ü®x, y‚ü© hxy => mem_union·µ¢‚ÇÇ.2
    ‚ü®(x, x), rfl, refl_mem_uniformity hU, hxy‚ü©",error:  unknown identifier 'mem_union·µ¢‚ÇÇ',theorem nhdsSet_diagonal_eq_uniformity [CompactSpace Œ±] : ùìùÀ¢ (diagonal Œ±) = ùì§ Œ± ,":= by
  refine nhdsSet_diagonal_le_uniformity.antisymm ?_
  have :
    (ùì§ (Œ± √ó Œ±)).HasBasis (fun U => U ‚àà ùì§ Œ±) fun U =>
      (fun p : (Œ± √ó Œ±) √ó Œ± √ó Œ± => ((p.1.1, p.2.1), p.1.2, p.2.2)) ‚Åª¬π' U √óÀ¢ U := by
    rw [uniformity_prod_eq_comap_prod]
    exact (ùì§ Œ±).basis_sets.prod_self.comap _
  refine (isCompact_diagonal.nhdsSet_basis_uniformity this).ge_iff.2 fun U hU => ?_
  exact mem_of_superset hU fun ‚ü®x, y‚ü© hxy => mem_iUnion‚ÇÇ.2
    ‚ü®(x, x), rfl, refl_mem_uniformity hU, hxy‚ü©",":= by
  refine nhdsSet_diagonal_le_uniformity.antisymm ?_
  have :
    (ùì§ (Œ± √ó Œ±)).HasBasis (fun U => U ‚àà ùì§ Œ±) fun U =>
      (fun p : (Œ± √ó Œ±) √ó Œ± √ó Œ± => ((p.1.1, p.2.1), p.1.2, p.2.2)) ‚Åª¬π' U √óÀ¢ U := by
    rw [uniformity_prod_eq_comap_prod]
    exact (ùì§ Œ±).basis_sets.prod_self.comap _
  refine (isCompact_diagonal.nhdsSet_basis_uniformity this).ge_iff.2 fun U hU => ?_
  exact mem_of_superset hU fun ‚ü®x, y‚ü© hxy => mem_union·µ¢‚ÇÇ.2
    ‚ü®(x, x), rfl, refl_mem_uniformity hU, hxy‚ü©"
Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean,HasCompactSupport.integral_Iic_deriv_eq,_root_.HasCompactSupport.integral_Iic_deriv_eq,494478bf8809a6197efc24a4ee1fc7b02edca0e8,":= by
  have := fun x (_ : x ‚àà Iio b) ‚Ü¶ hf.differentiable le_rfl x |>.hasDerivAt
  rw [integral_Iic_of_hasDerivAt_of_tendsto hf.continuous.continuousWithinAt this, sub_zero]
  refine hf.continuous_deriv le_rfl |>.integrable_of_hasCompactSupport h2f.deriv |>.integrableOn
  rw [hasCompactSupport_iff_eventuallyEq, Filter.coclosedCompact_eq_cocompact] at h2f
  exact h2f.filter_mono atBot_le_cocompact |>.tendsto","warning:  `Real.atBot_le_cocompact` has been deprecated, use `atBot_le_cocompact` instead
error:  ambiguous, possible interpretations 
  _root_.atBot_le_cocompact : atBot ‚â§ cocompact ‚Ñù
  
  Real.atBot_le_cocompact : atBot ‚â§ cocompact ‚Ñù","theorem _root_.HasCompactSupport.integral_Iic_deriv_eq (hf : ContDiff ‚Ñù 1 f)
    (h2f : HasCompactSupport f) (b : ‚Ñù) : ‚à´ x in Iic b, deriv f x = f b ",":= by
  have := fun x (_ : x ‚àà Iio b) ‚Ü¶ hf.differentiable le_rfl x |>.hasDerivAt
  rw [integral_Iic_of_hasDerivAt_of_tendsto hf.continuous.continuousWithinAt this, sub_zero]
  ¬∑ refine hf.continuous_deriv le_rfl |>.integrable_of_hasCompactSupport h2f.deriv |>.integrableOn
  rw [hasCompactSupport_iff_eventuallyEq, Filter.coclosedCompact_eq_cocompact] at h2f
  exact h2f.filter_mono _root_.atBot_le_cocompact |>.tendsto",":= by
  have := fun x (_ : x ‚àà Iio b) ‚Ü¶ hf.differentiable le_rfl x |>.hasDerivAt
  have := hf.continuous_deriv le_rfl |>.integrable_of_hasCompactSupport h2f.deriv |>.integrableOn
  rw [hasCompactSupport_iff_eventuallyEq, Filter.coclosedCompact_eq_cocompact] at h2f
  exact h2f.filter_mono atBot_le_cocompact |>.tendsto"
Mathlib/Data/NNRat/Lemmas.lean,NNRat.num_div_den,num_div_den,e2b81ba84dbe04d1922bf2fe517ab39d55326d72,":= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, ‚Üê Int.cast_ofNat,
    Int.natAbs_of_nonneg (Rat.num_nonneg_iff_zero_le.2 q.prop)]
  exact Rat.num_div_den q","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  OfNat.ofNat ?n
case a
p q‚úù q : ‚Ñö‚â•0
‚ä¢ ‚Üë(‚Üëq).num.natAbs / ‚Üëq.den = ‚Üëq",lemma num_div_den (q : ‚Ñö‚â•0) : (q.num : ‚Ñö‚â•0) / q.den = q ,":= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, ‚Üê Int.cast_natCast,
    Int.natAbs_of_nonneg (Rat.num_nonneg.2 q.cast_nonneg)]
  exact Rat.num_div_den q",":= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, ‚Üê Int.cast_ofNat,
    Int.natAbs_of_nonneg (Rat.num_nonneg_iff_zero_le.2 q.prop)]"
Mathlib/NumberTheory/Modular.lean,ModularGroup.tendsto_normSq_coprime_pair,tendsto_normSq_coprime_pair,079113af31d690223d4821fd5f7a58291d2347e7,":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)","error:  unknown identifier 'ofReal_int_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.22323
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
f_def : ‚áëf = fun p ‚Ü¶ ‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)
x‚úù : Fin 2 ‚Üí ‚Ñ§
‚ä¢ normSq (‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)) = normSq (‚Üë‚Üë(x‚úù 0) * ‚Üëz + ‚Üë‚Üë(x‚úù 1))
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem tendsto_normSq_coprime_pair :
    Filter.Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * z + p 1)) cofinite atTop ",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_intCast, ofReal_intCast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)"
Mathlib/Data/Nat/Factorial/Basic.lean,Nat.ascFactorial_le_pow_add,ascFactorial_le_pow_add,df9cfef55a1b8cd650f6575f7f576b85ef124030,"  | 0 => by rw [ascFactorial_zero, Nat.pow_zero]; exact Nat.le_refl _
  | k + 1 => by
    rw [ascFactorial_succ, Nat.pow_succ, Nat.mul_comm, ‚Üê Nat.add_assoc, Nat.add_right_comm n 1 k]
    exact Nat.mul_le_mul_right _
      (Nat.le_trans (ascFactorial_le_pow_add _ k) (Nat.pow_le_pow_left (le_succ _) _))",error:  no goals to be solved,"theorem ascFactorial_le_pow_add (n : ‚Ñï) : ‚àÄ k : ‚Ñï, (n+1).ascFactorial k ‚â§ (n + k) ^ k
","  | 0 => by rw [ascFactorial_zero, Nat.pow_zero]
  | k + 1 => by
    rw [ascFactorial_succ, Nat.pow_succ, Nat.mul_comm, ‚Üê Nat.add_assoc, Nat.add_right_comm n 1 k]
    exact Nat.mul_le_mul_right _
      (Nat.le_trans (ascFactorial_le_pow_add _ k) (Nat.pow_le_pow_left (le_succ _) _))",":= | 0 => by rw [ascFactorial_zero, Nat.pow_zero]; exact Nat.le_refl _
  | k + 1 => by
    rw [ascFactorial_succ, Nat.pow_succ, Nat.mul_comm, ‚Üê Nat.add_assoc, Nat.add_right_comm n 1 k]
    exact Nat.mul_le_mul_right _
      (Nat.le_trans (ascFactorial_le_pow_add _ k) (Nat.pow_le_pow_left (le_succ _) _))"
Mathlib/Topology/AlexandrovDiscrete.lean,IsOpen.exterior_subset_iff,IsOpen.exterior_subset_iff,13444d800e71a22689e60023576255503756cd93,:=,error:  unexpected token '@['; expected term,lemma IsOpen.exterior_subset_iff (ht : IsOpen t) : exterior s ‚äÜ t ‚Üî s ‚äÜ t ,":=
  ‚ü®subset_exterior.trans, fun h ‚Ü¶ exterior_minimal h ht‚ü©",":=
  ‚ü®fun h => ht.exterior_subset, fun h => h.exterior_subset‚ü©"
Mathlib/Topology/Bases.lean,Dense.exists_countable_dense_subset_bot_top,Dense.exists_countable_dense_subset_bot_top,b0906f1a9f950f5731cad2defb88e9843a7e3fc9,":= by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine' ‚ü®(t ‚à™ ({ x | IsBot x } ‚à™ { x | IsTop x })) ‚à© s, _, _, _, _, _‚ü©
  exacts [inter_subset_right _ _,
    (htc.union ((countable_isBot Œ±).union (countable_isTop Œ±))).mono (inter_subset_left _ _),
    htd.mono (subset_inter (subset_union_left _ _) hts), fun x hx hxs => ‚ü®Or.inr <| Or.inl hx, hxs‚ü©,
    fun x hx hxs => ‚ü®Or.inr <| Or.inr hx, hxs‚ü©]","error:  function expected at
  inter_subset_right ?m.106690
term has type
  ?m.106689 ‚àà ?m.106688
error:  function expected at
  inter_subset_left ?m.106782
term has type
  ?m.106781 ‚àà ?m.106779
error:  function expected at
  subset_union_left ?m.106878
term has type
  ?m.106877 ‚àà ?m.106875 ‚à™ ?m.106876","theorem Dense.exists_countable_dense_subset_bot_top {Œ± : Type*} [TopologicalSpace Œ±]
    [PartialOrder Œ±] {s : Set Œ±} [SeparableSpace s] (hs : Dense s) :
    ‚àÉ t ‚äÜ s, t.Countable ‚àß Dense t ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àà s ‚Üí x ‚àà t) ‚àß
      ‚àÄ x, IsTop x ‚Üí x ‚àà s ‚Üí x ‚àà t ",":= by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine ‚ü®(t ‚à™ ({ x | IsBot x } ‚à™ { x | IsTop x })) ‚à© s, ?_, ?_, ?_, ?_, ?_‚ü©
  exacts [inter_subset_right,
    (htc.union ((countable_isBot Œ±).union (countable_isTop Œ±))).mono inter_subset_left,
    htd.mono (subset_inter subset_union_left hts), fun x hx hxs => ‚ü®Or.inr <| Or.inl hx, hxs‚ü©,
    fun x hx hxs => ‚ü®Or.inr <| Or.inr hx, hxs‚ü©]",":= by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine ‚ü®(t ‚à™ ({ x | IsBot x } ‚à™ { x | IsTop x })) ‚à© s, ?_, ?_, ?_, ?_‚ü©
  exacts [inter_subset_right,
    (htc.union ((countable_isBot Œ±).union (countable_isTop Œ±))).mono inter_subset_left,
    htd.mono (subset_inter (subset_union_left hts), fun x hx hxs => ‚ü®Or.inr <| Or.inl hx, hxs‚ü©,
    fun x hx hxs => ‚ü®Or.inr <| Or.inr hx, hxs‚ü©]"
Mathlib/NumberTheory/DiophantineApproximation.lean,Rat.den_le_and_le_num_le_of_sub_lt_one_div_den_sq,den_le_and_le_num_le_of_sub_lt_one_div_den_sq,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  have hq‚ÇÄ : (0 : ‚Ñö) < q.den := Nat.cast_pos.mpr q.pos
  replace h : |Œæ * q.den - q.num| < 1 / q.den
  ¬∑ rw [‚Üê mul_lt_mul_right hq‚ÇÄ] at h
    conv_lhs at h => rw [‚Üê abs_of_pos hq‚ÇÄ, ‚Üê abs_mul, sub_mul, mul_den_eq_num]
    rwa [sq, div_mul, mul_div_cancel_left _ hq‚ÇÄ.ne'] at h
  constructor
  ¬∑ rcases eq_or_ne Œæ q with (rfl | H)
    ¬∑ exact le_rfl
    ¬∑ have hŒæ‚ÇÄ : (0 : ‚Ñö) < Œæ.den := Nat.cast_pos.mpr Œæ.pos
      rw [‚Üê Rat.num_div_den Œæ, div_mul_eq_mul_div, div_sub' _ _ _ hŒæ‚ÇÄ.ne', abs_div, abs_of_pos hŒæ‚ÇÄ,
        div_lt_iff hŒæ‚ÇÄ, div_mul_comm, mul_one] at h
      refine' Nat.cast_le.mp ((one_lt_div hq‚ÇÄ).mp <| lt_of_le_of_lt _ h).le
      norm_cast
      rw [mul_comm _ q.num]
      exact Int.one_le_abs (sub_ne_zero_of_ne <| mt Rat.eq_iff_mul_eq_mul.mpr H)
  ¬∑ obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© :=
      abs_sub_lt_iff.mp
        (h.trans_le <|
          (one_div_le zero_lt_one hq‚ÇÄ).mp <| (@one_div_one ‚Ñö _).symm ‚ñ∏ Nat.cast_le.mpr q.pos)
    rw [sub_lt_iff_lt_add, add_comm] at h‚ÇÅ h‚ÇÇ
    rw [‚Üê sub_lt_iff_lt_add] at h‚ÇÇ
    norm_cast at h‚ÇÅ h‚ÇÇ
    exact
      ‚ü®sub_le_iff_le_add.mpr (Int.ceil_le.mpr h‚ÇÅ.le), sub_le_iff_le_add.mp (Int.le_floor.mpr h‚ÇÇ.le)‚ü©","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
Œæ q : ‚Ñö
hq‚ÇÄ : 0 < ‚Üëq.den
h : |Œæ * ‚Üëq.den - ‚Üëq.num| < 1 / ‚Üëq.den
‚ä¢ q.den ‚â§ Œæ.den ‚àß ‚åàŒæ * ‚Üëq.den‚åâ - 1 ‚â§ q.num ‚àß q.num ‚â§ ‚åäŒæ * ‚Üëq.den‚åã + 1","theorem den_le_and_le_num_le_of_sub_lt_one_div_den_sq {Œæ q : ‚Ñö}
    (h : |Œæ - q| < 1 / (q.den : ‚Ñö) ^ 2) :
    q.den ‚â§ Œæ.den ‚àß ‚åàŒæ * q.den‚åâ - 1 ‚â§ q.num ‚àß q.num ‚â§ ‚åäŒæ * q.den‚åã + 1 ",":= by
  have hq‚ÇÄ : (0 : ‚Ñö) < q.den := Nat.cast_pos.mpr q.pos
  replace h : |Œæ * q.den - q.num| < 1 / q.den := by
    rw [‚Üê mul_lt_mul_right hq‚ÇÄ] at h
    conv_lhs at h => rw [‚Üê abs_of_pos hq‚ÇÄ, ‚Üê abs_mul, sub_mul, mul_den_eq_num]
    rwa [sq, div_mul, mul_div_cancel_left‚ÇÄ _ hq‚ÇÄ.ne'] at h
  constructor
  ¬∑ rcases eq_or_ne Œæ q with (rfl | H)
    ¬∑ exact le_rfl
    ¬∑ have hŒæ‚ÇÄ : (0 : ‚Ñö) < Œæ.den := Nat.cast_pos.mpr Œæ.pos
      rw [‚Üê Rat.num_div_den Œæ, div_mul_eq_mul_div, div_sub' _ _ _ hŒæ‚ÇÄ.ne', abs_div, abs_of_pos hŒæ‚ÇÄ,
        div_lt_iff hŒæ‚ÇÄ, div_mul_comm, mul_one] at h
      refine Nat.cast_le.mp ((one_lt_div hq‚ÇÄ).mp <| lt_of_le_of_lt ?_ h).le
      norm_cast
      rw [mul_comm _ q.num]
      exact Int.one_le_abs (sub_ne_zero_of_ne <| mt Rat.eq_iff_mul_eq_mul.mpr H)
  ¬∑ obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© :=
      abs_sub_lt_iff.mp
        (h.trans_le <|
          (one_div_le zero_lt_one hq‚ÇÄ).mp <| (@one_div_one ‚Ñö _).symm ‚ñ∏ Nat.cast_le.mpr q.pos)
    rw [sub_lt_iff_lt_add, add_comm] at h‚ÇÅ h‚ÇÇ
    rw [‚Üê sub_lt_iff_lt_add] at h‚ÇÇ
    norm_cast at h‚ÇÅ h‚ÇÇ
    exact
      ‚ü®sub_le_iff_le_add.mpr (Int.ceil_le.mpr h‚ÇÅ.le), sub_le_iff_le_add.mp (Int.le_floor.mpr h‚ÇÇ.le)‚ü©",":= by
  have hq‚ÇÄ : (0 : ‚Ñö) < q.den := Nat.cast_pos.mpr q.pos
  replace h : |Œæ * q.den - q.num| < 1 / q.den
  ¬∑ rw [‚Üê mul_lt_mul_right hq‚ÇÄ] at h
    conv_lhs at h => rw [‚Üê abs_of_pos hq‚ÇÄ, ‚Üê abs_mul, sub_mul, mul_den_eq_num]
    rwa [sq, div_mul, mul_div_cancel_left _ hq‚ÇÄ.ne'] at h
  constructor
  ¬∑ rcases eq_or_ne Œæ q with (rfl | H)
    ¬∑ exact le_rfl
    ¬∑ have hŒæ‚ÇÄ : (0 : ‚Ñö) < Œæ.den := Nat.cast_pos.mpr Œæ.pos
      rw [‚Üê Rat.num_div_den Œæ, div_mul_eq_mul_div, div_sub' _ _ _ hŒæ‚ÇÄ.ne', abs_div, abs_of_pos hŒæ‚ÇÄ,
        div_lt_iff hŒæ‚ÇÄ, div_mul_comm, mul_one] at h
      refine Nat.cast_le.mp ((one_lt_div hq‚ÇÄ).mp <| lt_of_le_of_lt ?_ h).le
      norm_cast
      rw [mul_comm _ q.num]
      exact Int.one_le_abs (sub_ne_zero_of_ne <| mt Rat.eq_iff_mul_eq_mul.mpr H)
  ¬∑ obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© :=
      abs_sub_lt_iff.mp
        (h.trans_le <|
          (one_div_le zero_lt_one hq‚ÇÄ).mp <| (@one_div_one ‚Ñö _).symm ‚ñ∏ Nat.cast_le.mpr q.pos)
    rw [sub_lt_iff_lt_add, add_comm] at h‚ÇÅ h‚ÇÇ
    rw [‚Üê sub_lt_iff_lt_add] at h‚ÇÇ
    norm_cast at h‚ÇÅ h‚ÇÇ
    exact
      ‚ü®sub_le_iff_le_add.mpr (Int.ceil_le.mpr h‚ÇÅ.le), sub_le_iff_le_add.mp (Int.le_floor.mpr h‚ÇÇ.le)‚ü©"
Mathlib/MeasureTheory/Measure/Typeclasses.lean,MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ,countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ,7dbc4ee943ff99bb5a359e820806969fa45b18b0,":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only []
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine' countable_iUnion fun n => Finite.countable _
  refine' finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite",error:  simp made no progress,"theorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ {Œπ : Type*} {_ : MeasurableSpace Œ±}
    (Œº : Measure Œ±) {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, NullMeasurableSet (As i) Œº)
    (As_disj : Pairwise (AEDisjoint Œº on As)) (Union_As_finite : Œº (‚ãÉ i, As i) ‚â† ‚àû) :
    Set.Countable { i : Œπ | 0 < Œº (As i) } ",":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only [fairmeas]
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable ?_
  exact finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite",":= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only []
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable _
  refine finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite"
Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean,ExteriorAlgebra.ŒπMulti_span,ŒπMulti_span,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  rw [Submodule.eq_top_iff']
  intro x
  induction x
    using DirectSum.Decomposition.inductionOn fun i => LinearMap.range (Œπ R (M := M)) ^ i with
  | h_zero => exact Submodule.zero_mem _
  | h_add _ _ hm hm' => exact Submodule.add_mem _ hm hm'
  | h_homogeneous hm =>
    let ‚ü®m, hm‚ü© := hm
    apply Set.mem_of_mem_of_subset hm
    rw [‚Üê ŒπMulti_span_fixedDegree]
    refine Submodule.span_mono fun _ hx ‚Ü¶ ?_
    obtain ‚ü®y, rfl‚ü© := hx
    exact ‚ü®‚ü®_, y‚ü©, rfl‚ü©","error:  failed to synthesize
  DirectSum.Decomposition fun i ‚Ü¶ LinearMap.range (Œπ R) ^ i
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚ãÄ[?R]^?n ?M
case h_homogeneous
R : Type u_1
M : Type u_2
inst‚úù¬≤ : CommRing R
inst‚úù¬π : AddCommGroup M
inst‚úù : Module R M
i‚úù : ‚Ñï
hm‚úù : ‚Ü•(LinearMap.range (Œπ R) ^ i‚úù)
m : ExteriorAlgebra R M
hm : m ‚àà LinearMap.range (Œπ R) ^ i‚úù
‚ä¢ ‚Üë(LinearMap.range (Œπ R) ^ i‚úù) ‚äÜ ‚Üë(Submodule.span R (Set.range fun x ‚Ü¶ (ŒπMulti R x.fst) x.snd))
error:  alternative 'x_0' has not been provided","lemma ŒπMulti_span :
    Submodule.span R (Set.range fun x : Œ£ n, (Fin n ‚Üí M) => ŒπMulti R x.1 x.2) = ‚ä§ ",":= by
  rw [Submodule.eq_top_iff']
  intro x
  induction x using DirectSum.Decomposition.inductionOn fun i => ‚ãÄ[R]^i M with
  | h_zero => exact Submodule.zero_mem _
  | h_add _ _ hm hm' => exact Submodule.add_mem _ hm hm'
  | h_homogeneous hm =>
    let ‚ü®m, hm‚ü© := hm
    apply Set.mem_of_mem_of_subset hm
    rw [‚Üê ŒπMulti_span_fixedDegree]
    refine Submodule.span_mono fun _ hx ‚Ü¶ ?_
    obtain ‚ü®y, rfl‚ü© := hx
    exact ‚ü®‚ü®_, y‚ü©, rfl‚ü©",":= by
  rw [Submodule.eq_top_iff']
  intro x
  induction x
    using DirectSum.Decomposition.inductionOn fun i => LinearMap.range (Œπ R (M := M)) ^ i with
  | h_zero => exact Submodule.zero_mem _
  | h_add _ _ hm hm' => exact Submodule.add_mem _ hm hm'
  | h_homogeneous hm =>
    let ‚ü®m, hm‚ü© := hm
    apply Set.mem_of_mem_of_subset hm
    rw [‚Üê ŒπMulti_span_fixedDegree]
    refine Submodule.span_mono fun _ hx ‚Ü¶ ?_
    obtain ‚ü®y, rfl‚ü© := hx
    exact ‚ü®‚ü®_, y‚ü©, rfl‚ü©"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le,norm_volume_sub_integral_face_upper_sub_lower_smul_le,5314a658f207fdcef03c22ffaf7bc64414488ae1,":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
      ¬∑ intro y hy
        refine' (hŒµ y hy).trans (mul_le_mul_of_nonneg_left _ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [Function.comp_def, Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul,
        mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine' norm_integral_le_of_le_const (fun y hy => (this y hy).trans _) volume
      rw [mul_assoc (2 * Œµ)]
      exact mul_le_mul_of_nonneg_left (I.diam_Icc_le_of_distortion_le i hc)
        (mul_nonneg zero_le_two h0.le)
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case convert_2
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
y : Fin n ‚Üí ‚Ñù
hy : y ‚àà Box.Icc (I.face i)
g : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
hfc : ContinuousOn (fun y ‚Ü¶ a + f' (y - x) + g y) (Box.Icc I)
Hi :
  ‚àÄ x_1 ‚àà Set.Icc (I.lower i) (I.upper i),
    Integrable (I.face i) ‚ä• ((fun y ‚Ü¶ a + f' (y - x) + g y) ‚àò e x_1) BoxAdditiveMap.volume
hg : g = fun y ‚Ü¶ (fun y ‚Ü¶ a + f' (y - x) + g y) y - a - f' (y - x)
this : ‚àÄ z ‚àà Set.Icc (I.lower i) (I.upper i), e z y ‚àà Box.Icc I
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
error:  unsolved goals
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
hfc : ContinuousOn f (Box.Icc I)
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
Hi : ‚àÄ x ‚àà Set.Icc (I.lower i) (I.upper i), Integrable (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume
this :
  ‚àÄ y ‚àà Box.Icc (I.face i),
    ‚Äñf' (Pi.single i (I.upper i - I.lower i)) - (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñ(‚àè j : Fin (n + 1), (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
        (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
          integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ ‚â§
    2 * Œµ * ‚Üëc * ‚àè j : Fin (n + 1), (I.upper j - I.lower j)","theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E}
    {f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) ‚Üí ‚Ñù}
    (hxI : x ‚àà (Box.Icc I)) {a : E} {Œµ : ‚Ñù} (h0 : 0 < Œµ)
    (hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ) {c : ‚Ñù‚â•0}
    (hc : I.distortion ‚â§ c) :
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
      (integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.lower i))
          BoxAdditiveMap.volume)‚Äñ ‚â§
      2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) ",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I) := by
        intro y hy
        refine (hŒµ y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(¬∑ ‚àò ¬∑), Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * Œµ)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e "
Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean,TopCat.range_pullback_map,range_pullback_map,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range, ‚Üêcomp_apply, limit.lift_œÄ,
      PullbackCone.mk_pt, PullbackCone.mk_œÄ_app]
    simp only [comp_apply, exists_apply_eq_apply, and_self]
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    simp only [‚Üê comp_apply, eq‚ÇÅ, eq‚ÇÇ]
    simp only [comp_apply, hx‚ÇÅ, hx‚ÇÇ]
    simp only [‚Üê comp_apply, pullback.condition]
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  apply Concrete.limit_ext
  rintro (_ | _ | _) <;>
  simp only [‚Üêcomp_apply, Category.assoc, limit.lift_œÄ, PullbackCone.mk_œÄ_app_one]
  ¬∑ simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, comp_apply,
      pullbackFst_apply, hx‚ÇÅ]
    rw [‚Üê limit.w _ WalkingCospan.Hom.inl, cospan_map_inl, comp_apply (g := g‚ÇÅ)]
  ¬∑ simp [hx‚ÇÅ]
  ¬∑ simp [hx‚ÇÇ]","error:  simp made no progress
error:  simp made no progress
error:  tactic 'apply' failed, failed to unify
  ?x = ?y
with
  (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) ((pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®(x‚ÇÅ, x‚ÇÇ), this‚ü©) = x‚úù
case h
J : Type v
inst‚úù : SmallCategory J
X‚úù Y‚úù Z‚úù : TopCat
W X Y Z S T : TopCat
f‚ÇÅ : W ‚ü∂ S
f‚ÇÇ : X ‚ü∂ S
g‚ÇÅ : Y ‚ü∂ T
g‚ÇÇ : Z ‚ü∂ T
i‚ÇÅ : W ‚ü∂ Y
i‚ÇÇ : X ‚ü∂ Z
i‚ÇÉ : S ‚ü∂ T
H‚ÇÉ : Mono i‚ÇÉ
eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ
eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ
x‚úù : ‚Üë(pullback g‚ÇÅ g‚ÇÇ)
x‚ÇÅ : ‚ÜëW
hx‚ÇÅ : i‚ÇÅ x‚ÇÅ = pullback.fst x‚úù
x‚ÇÇ : ‚ÜëX
hx‚ÇÇ : i‚ÇÇ x‚ÇÇ = pullback.snd x‚úù
this : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ
‚ä¢ (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) ((pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®(x‚ÇÅ, x‚ÇÇ), this‚ü©) = x‚úù","theorem range_pullback_map {W X Y Z S T : TopCat} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) (g‚ÇÅ : Y ‚ü∂ T)
    (g‚ÇÇ : Z ‚ü∂ T) (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T) [H‚ÇÉ : Mono i‚ÇÉ] (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ)
    (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) :
    Set.range (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) =
      (pullback.fst : pullback g‚ÇÅ g‚ÇÇ ‚ü∂ _) ‚Åª¬π' Set.range i‚ÇÅ ‚à©
        (pullback.snd : pullback g‚ÇÅ g‚ÇÇ ‚ü∂ _) ‚Åª¬π' Set.range i‚ÇÇ ",":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range]
    erw [‚Üê comp_apply, ‚Üê comp_apply] 
    simp only [limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app, comp_apply]
    exact ‚ü®exists_apply_eq_apply _ _, exists_apply_eq_apply _ _‚ü©
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    erw [‚Üê comp_apply, eq‚ÇÅ, ‚Üê comp_apply, eq‚ÇÇ, 
      comp_apply, comp_apply, hx‚ÇÅ, hx‚ÇÇ, ‚Üê comp_apply, pullback.condition]
    rfl 
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  change (forget TopCat).map _ _ = _
  apply Concrete.limit_ext
  rintro (_ | _ | _) <;>
  erw [‚Üê comp_apply, ‚Üê comp_apply] 
  simp only [Category.assoc, limit.lift_œÄ, PullbackCone.mk_œÄ_app_one]
  ¬∑ simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [pullbackFst_apply, hx‚ÇÅ]
    rw [‚Üê limit.w _ WalkingCospan.Hom.inl, cospan_map_inl, comp_apply (g := g‚ÇÅ)]
    rfl 
  ¬∑ simp only [cospan_left, limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,
      pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [hx‚ÇÅ] 
    rfl 
  ¬∑ simp only [cospan_right, limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,
      pullbackIsoProdSubtype_inv_snd_assoc, comp_apply]
    erw [hx‚ÇÇ] 
    rfl ",":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range, ‚Üêcomp_apply, limit.lift_œÄ,
      PullbackCone.mk_pt, PullbackCone.mk_œÄ_app]
    simp only [comp_apply, exists_apply_eq_apply, and_self]
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    simp only [‚Üê comp_apply, eq‚ÇÅ, eq‚ÇÇ]
    simp only [comp_apply, pullback.condition]
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  apply Concrete.limit_ext
  rintro (_ | _ | _) <;>
  simp only [‚Üê comp_apply, Category.assoc, limit.lift_œÄ, PullbackCone.mk_œÄ_app_one]
  ¬∑ simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, comp_apply,
      pullbackFst_apply, hx‚ÇÅ]
    rw [‚Üê limit.w _ WalkingCospan.Hom.inl, cospan_map_inl, comp_apply (g := g‚ÇÅ)]
  ¬∑ simp [hx‚ÇÅ]
  ¬∑ simp [hx‚ÇÇ]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,65f7857d510e130142dbb111786341d695ac399b,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_ortho"
Mathlib/Analysis/Calculus/FormalMultilinearSeries.lean,FormalMultilinearSeries.order_eq_find,order_eq_find,ef3c9bcd07782b044027916a64e925f3e4951707,:= {n | p n ‚â† 0}) hp,"error:  type mismatch
  {n | p n ‚â† 0}
has type
  Set ‚Ñï : Type
but is expected to have type
  p.order = Nat.find hp : Prop
error:  unexpected token ')'; expected command","theorem order_eq_find [DecidablePred fun n => p n ‚â† 0] (hp : ‚àÉ n, p n ‚â† 0) :
    p.order = Nat.find hp ",:= by convert Nat.sInf_def hp,:= {n | p n ‚â† 0}
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le,norm_volume_sub_integral_face_upper_sub_lower_smul_le,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
      ¬∑ intro y hy
        refine' (hŒµ y hy).trans (mul_le_mul_of_nonneg_left _ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(¬∑ ‚àò ¬∑), Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine' norm_integral_le_of_le_const (fun y hy => (this y hy).trans _) volume
      rw [mul_assoc (2 * Œµ)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case convert_2
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
y : Fin n ‚Üí ‚Ñù
hy : y ‚àà Box.Icc (I.face i)
g : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
hfc : ContinuousOn (fun y ‚Ü¶ a + f' (y - x) + g y) (Box.Icc I)
Hi :
  ‚àÄ x_1 ‚àà Set.Icc (I.lower i) (I.upper i),
    Integrable (I.face i) ‚ä• ((fun y ‚Ü¶ a + f' (y - x) + g y) ‚àò e x_1) BoxAdditiveMap.volume
hg : g = fun y ‚Ü¶ (fun y ‚Ü¶ a + f' (y - x) + g y) y - a - f' (y - x)
this : ‚àÄ z ‚àà Set.Icc (I.lower i) (I.upper i), e z y ‚àà Box.Icc I
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
error:  unsolved goals
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
hfc : ContinuousOn f (Box.Icc I)
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
Hi : ‚àÄ x ‚àà Set.Icc (I.lower i) (I.upper i), Integrable (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume
this :
  ‚àÄ y ‚àà Box.Icc (I.face i),
    ‚Äñf' (Pi.single i (I.upper i - I.lower i)) - (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñ(‚àè j : Fin (n + 1), (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
        (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
          integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ ‚â§
    2 * Œµ * ‚Üëc * ‚àè j : Fin (n + 1), (I.upper j - I.lower j)","theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E}
    {f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) ‚Üí ‚Ñù}
    (hxI : x ‚àà (Box.Icc I)) {a : E} {Œµ : ‚Ñù} (h0 : 0 < Œµ)
    (hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ) {c : ‚Ñù‚â•0}
    (hc : I.distortion ‚â§ c) :
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
      (integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.lower i))
          BoxAdditiveMap.volume)‚Äñ ‚â§
      2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) ",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I) := by
        intro y hy
        refine (hŒµ y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(¬∑ ‚àò ¬∑), Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * Œµ)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e "
Mathlib/FieldTheory/SeparableClosure.lean,separableClosure.map_eq_of_separableClosure_eq_bot,separableClosure.map_eq_of_separableClosure_eq_bot,67bc82d1ddb7cf6ad83d9d67c3f839281acb4d63,":= by
  refine le_antisymm (map_le_of_algHom _) (fun x hx ‚Ü¶ ?_)
  obtain ‚ü®y, rfl‚ü© := mem_bot.1 <| h ‚ñ∏ mem_separableClosure_iff.2
    (IsSeparable.of_isScalarTower E <| mem_separableClosure_iff.1 hx)
  exact ‚ü®y, (map_mem_separableClosure_iff <| IsScalarTower.toAlgHom F E K).mp hx, rfl‚ü©","error:  unknown constant 'IsSeparable.of_isScalarTower'
error:  tactic 'subst' failed, invalid equality proof, it is not of the form (x = t) or (t = x)
  (algebraMap E K) y = ?m.6924
case intro
F : Type u
E : Type v
inst‚úù‚Å∂ : Field F
inst‚úù‚Åµ : Field E
inst‚úù‚Å¥ : Algebra F E
K : Type w
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Algebra F K
inst‚úù¬π : Algebra E K
inst‚úù : IsScalarTower F E K
h : separableClosure E K = ‚ä•
x : K
hx : x ‚àà separableClosure F K
y : E
h‚úù : (algebraMap E K) y = ?m.6924
‚ä¢ x ‚àà IntermediateField.map (IsScalarTower.toAlgHom F E K) (separableClosure F E)","theorem separableClosure.map_eq_of_separableClosure_eq_bot [Algebra E K] [IsScalarTower F E K]
    (h : separableClosure E K = ‚ä•) :
    (separableClosure F E).map (IsScalarTower.toAlgHom F E K) = separableClosure F K ",":= by
  refine le_antisymm (map_le_of_algHom _) (fun x hx ‚Ü¶ ?_)
  obtain ‚ü®y, rfl‚ü© := mem_bot.1 <| h ‚ñ∏ mem_separableClosure_iff.2
    (mem_separableClosure_iff.1 hx |>.map_minpoly E)
  exact ‚ü®y, (map_mem_separableClosure_iff <| IsScalarTower.toAlgHom F E K).mp hx, rfl‚ü©",":= by
  refine le_antisymm (map_le_of_algHom _) (fun x hx ‚Ü¶ ?_)
  obtain ‚ü®y, rfl‚ü© := mem_bot.1 <| h ‚ñ∏ mem_separableClosure_iff.2
    (IsSeparable.of_isScalarTower E <| mem_separableClosure_iff.1 hx)
  exact ‚ü®y, (map_mem_separableClosure_iff <| IsScalarTower.toAlgHom F E K).mp hx, rfl‚ü©"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.update_eq_single_add_erase,update_eq_single_add_erase,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.update_eq_single_add_erase f a b","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.update_eq_single_add_erase'","theorem update_eq_single_add_erase (f : Œ± ‚Üí‚ÇÄ M) (a : Œ±) (b : M) :
    f.update a b = single a b + f.erase a ",":= by
  classical
    ext j
    rcases eq_or_ne a j with (rfl | h)
    ¬∑ simp
    ¬∑ simp [Function.update_noteq h.symm, single_apply, h, erase_ne, h.symm]",":=
  update_eq_single_add_erase f a b"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.map_think,map_think,938069ac7c83a4980c46ca108d9947ab788c12ee,":=
  Seq'.map_cons _ _ _",error:  unknown identifier 'Seq'.map_cons',theorem map_think (f : Œ± ‚Üí Œ≤) (s) : map f (think s) = think (map f s) ,":=
  Seq.map_cons _ _ _",":=
  Seq.map_cons _ _"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú'
  ¬∑ rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine' Or.inl ‚ü®hs, _‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, _‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine'
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' ‚ü®hus, hsv.symm, ‚ü®x, _, _‚ü©, _‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right _ _, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) _
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans $ subset_union_left _ _),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  unexpected token '¬∑'; expected 'by' or 'from'","theorem shadow_compression_subset_compression_shadow (u v : Finset Œ±)
    (huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú) :
    ‚àÇ (ùìí u v ùíú) ‚äÜ ùìí u v (‚àÇ ùíú) ",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine mem_shadow_iff.2
        ‚ü®(t ‚äî u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) ?_
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú'
  ¬∑ rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx "
Mathlib/GroupTheory/Perm/Cycle/Concrete.lean,Equiv.Perm.IsCycle.existsUnique_cycle,IsCycle.existsUnique_cycle,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  cases nonempty_fintype Œ±
  obtain ‚ü®x, hx, hy‚ü© := id hf
  refine ‚ü®f.toList x, ‚ü®nodup_toList f x, ?_‚ü©, ?_‚ü©
  ¬∑ simp [formPerm_toList, hf.cycleOf_eq hx]
  ¬∑ rintro ‚ü®l‚ü© ‚ü®hn, rfl‚ü©
    simp only [Cycle.mk_eq_coe, Cycle.coe_eq_coe, Subtype.coe_mk, Cycle.formPerm_coe]
    refine (toList_formPerm_isRotated_self _ ?_ hn _? _).symm
    ¬∑ contrapose! hx
      suffices formPerm l = 1 by simp [this]
      rw [formPerm_eq_one_iff _ hn]
      exact Nat.le_of_lt_succ hx
    ¬∑ rw [‚Üê mem_toFinset]
      refine support_formPerm_le l ?_
      simpa using hx","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
error:  unknown identifier '_?'
warning:  'decide' tactic does nothing
note: this linter can be disabled with `set_option linter.unusedTactic false`","theorem IsCycle.existsUnique_cycle {f : Perm Œ±} (hf : IsCycle f) :
    ‚àÉ! s : Cycle Œ±, ‚àÉ h : s.Nodup, s.formPerm h = f ",":= by
  cases nonempty_fintype Œ±
  obtain ‚ü®x, hx, hy‚ü© := id hf
  refine ‚ü®f.toList x, ‚ü®nodup_toList f x, ?_‚ü©, ?_‚ü©
  ¬∑ simp [formPerm_toList, hf.cycleOf_eq hx]
  ¬∑ rintro ‚ü®l‚ü© ‚ü®hn, rfl‚ü©
    simp only [Cycle.mk_eq_coe, Cycle.coe_eq_coe, Subtype.coe_mk, Cycle.formPerm_coe]
    refine (toList_formPerm_isRotated_self _ ?_ hn _ ?_).symm
    ¬∑ contrapose! hx
      suffices formPerm l = 1 by simp [this]
      rw [formPerm_eq_one_iff _ hn]
      exact Nat.le_of_lt_succ hx
    ¬∑ rw [‚Üê mem_toFinset]
      refine support_formPerm_le l ?_
      simpa using hx",":= by
  cases nonempty_fintype Œ±
  obtain ‚ü®x, hx, hy‚ü© := id hf
  refine ‚ü®f.toList x, ‚ü®nodup_toList f x, ?_‚ü©, ?_‚ü©
  ¬∑ simp [formPerm_toList, hf.cycleOf_eq hx]
  ¬∑ rintro ‚ü®l‚ü© ‚ü®hn, rfl‚ü©
    simp only [Cycle.mk_eq_coe, Cycle.coe_eq_coe, Subtype.coe_mk, Cycle.formPerm_coe]
    refine (toList_formPerm_isRotated_self _ ?_ hn ?_ ?_).symm
    ¬∑ contrapose! hx
      suffices formPerm l = 1 by simp [this]
      rw [formPerm_eq_one_iff _ hn]
      exact Nat.le_of_lt_succ hx
    ¬∑ rw [‚Üê mem_toFinset]
      refine support_formPerm_le l ?_
      simpa using hx"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_ortho"
Mathlib/Topology/Algebra/UniformRing.lean,UniformSpace.Completion.Continuous.mul,Continuous.mul,54d2d04a76999eff29e8b39b03fa3d5fc19ac0e3,":=
  hf.mul hg","error:  failed to synthesize
  ContinuousMul (Completion Œ±)
use `set_option diagnostics true` to get diagnostic information","theorem Continuous.mul {Œ≤ : Type*} [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Completion Œ±}
    (hf : Continuous f) (hg : Continuous g) : Continuous fun b => f b * g b ",":=
  Continuous.comp continuous_mul (Continuous.prod_mk hf hg : _)",":=
  hf.mul hg"
Mathlib/Topology/Category/TopCat/Limits/Products.lean,TopCat.binaryCofan_isColimit_iff,binaryCofan_isColimit_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inr, ?_‚ü©
      erw [Set.range_comp, ‚Üê eq_compl_iff_isCompl, coe_comp, coe_comp, Set.range_comp _ Sum.inr,
        ‚Üê Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
      aesop
    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      have : ‚àÄ x, x ‚àà Set.range c.inl ‚à® x ‚àà Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
        exact fun _ => or_not
      refine ‚ü®BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_‚ü©
      ¬∑ intro T f g
        refine ContinuousMap.mk ?_ ?_
        ¬∑ exact fun x =>
            if h : x ‚àà Set.range c.inl then f ((Equiv.ofInjective _ h‚ÇÅ.inj).symm ‚ü®x, h‚ü©)
            else g ((Equiv.ofInjective _ h‚ÇÇ.inj).symm ‚ü®x, (this x).resolve_left h‚ü©)
        rw [continuous_iff_continuousAt]
        intro x
        by_cases h : x ‚àà Set.range c.inl
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            convert_to Continuous (f ‚àò (Homeomorph.ofEmbedding _ h‚ÇÅ.toEmbedding).symm)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_pos hx
            apply Continuous.comp
            ¬∑ exact f.continuous_toFun
            ¬∑ continuity
          ¬∑ exact h‚ÇÅ.isOpen_range
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            have : ‚àÄ a, a ‚àâ Set.range c.inl ‚Üí a ‚àà Set.range c.inr := by
              rintro a (h : a ‚àà (Set.range c.inl)·∂ú)
              rwa [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            convert_to Continuous
                (g ‚àò (Homeomorph.ofEmbedding _ h‚ÇÇ.toEmbedding).symm ‚àò Subtype.map _ this)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_neg hx
            apply Continuous.comp
            ¬∑ exact g.continuous_toFun
            ¬∑ apply Continuous.comp
              ¬∑ continuity
              ¬∑ rw [embedding_subtype_val.toInducing.continuous_iff]
                exact continuous_subtype_val
          ¬∑ change IsOpen (Set.range c.inl)·∂ú
            rw [‚Üê eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            exact h‚ÇÇ.isOpen_range
      ¬∑ intro T f g
        ext x
        refine (dif_pos ?_).trans ?_
        ¬∑ exact ‚ü®x, rfl‚ü©
        ¬∑ dsimp; conv_lhs => erw [Equiv.ofInjective_symm_apply]
      ¬∑ intro T f g
        ext x
        refine (dif_neg ?_).trans ?_
        ¬∑ rintro ‚ü®y, e‚ü©
          have : c.inr x ‚àà Set.range c.inl ‚äì Set.range c.inr := ‚ü®‚ü®_, e‚ü©, ‚ü®_, rfl‚ü©‚ü©
          rwa [disjoint_iff.mp h‚ÇÉ.1] at this
        ¬∑ exact congr_arg g (Equiv.ofInjective_symm_apply _ _)
      ¬∑ rintro T _ _ m rfl rfl
        ext x
        change m x = dite _ _ _
        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ‚ü®_, _‚ü©).symm","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚áë(?f ‚â´ ?g)
case mp.intro
J : Type v
inst‚úù : SmallCategory J
X Y : TopCat
c : BinaryCofan X Y
h : IsColimit c
‚ä¢ ‚áë(h.coconePointUniqueUpToIso (X.binaryCofanIsColimit Y)).inv '' Set.range ‚áë(X.binaryCofan Y).inl =
    (Set.range (‚áë(h.coconePointUniqueUpToIso (X.binaryCofanIsColimit Y)).inv ‚àò ‚áë(X.binaryCofan Y).inr))·∂ú
error:  unsolved goals
case mpr.intro.intro.refine_2.w.refine_2
J : Type v
inst‚úù : SmallCategory J
X Y : TopCat
c : BinaryCofan X Y
h‚ÇÅ : OpenEmbedding ‚áëc.inl
h‚ÇÇ : OpenEmbedding ‚áëc.inr
h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
this :
  ‚àÄ (x : ‚Üë(((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := WalkingPair.left })),
    x ‚àà Set.range ‚áëc.inl ‚à® x ‚àà Set.range ‚áëc.inr
T : TopCat
f : X ‚ü∂ T
g : Y ‚ü∂ T
x : (forget TopCat).obj ((pair X Y).obj { as := WalkingPair.left })
‚ä¢ f x = f x","theorem binaryCofan_isColimit_iff {X Y : TopCat} (c : BinaryCofan X Y) :
    Nonempty (IsColimit c) ‚Üî
      OpenEmbedding c.inl ‚àß OpenEmbedding c.inr ‚àß IsCompl (Set.range c.inl) (Set.range c.inr) ",":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inr, ?_‚ü©
      erw [Set.range_comp, ‚Üê eq_compl_iff_isCompl, Set.range_comp _ Sum.inr,
        ‚Üê Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      have : ‚àÄ x, x ‚àà Set.range c.inl ‚à® x ‚àà Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
        exact fun _ => or_not
      refine ‚ü®BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_‚ü©
      ¬∑ intro T f g
        refine ContinuousMap.mk ?_ ?_
        ¬∑ exact fun x =>
            if h : x ‚àà Set.range c.inl then f ((Equiv.ofInjective _ h‚ÇÅ.inj).symm ‚ü®x, h‚ü©)
            else g ((Equiv.ofInjective _ h‚ÇÇ.inj).symm ‚ü®x, (this x).resolve_left h‚ü©)
        rw [continuous_iff_continuousAt]
        intro x
        by_cases h : x ‚àà Set.range c.inl
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            convert_to Continuous (f ‚àò (Homeomorph.ofEmbedding _ h‚ÇÅ.toEmbedding).symm)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_pos hx
            apply Continuous.comp
            ¬∑ exact f.continuous_toFun
            ¬∑ continuity
          ¬∑ exact h‚ÇÅ.isOpen_range
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            have : ‚àÄ a, a ‚àâ Set.range c.inl ‚Üí a ‚àà Set.range c.inr := by
              rintro a (h : a ‚àà (Set.range c.inl)·∂ú)
              rwa [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            convert_to Continuous
                (g ‚àò (Homeomorph.ofEmbedding _ h‚ÇÇ.toEmbedding).symm ‚àò Subtype.map _ this)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_neg hx
            apply Continuous.comp
            ¬∑ exact g.continuous_toFun
            ¬∑ apply Continuous.comp
              ¬∑ continuity
              ¬∑ rw [embedding_subtype_val.toInducing.continuous_iff]
                exact continuous_subtype_val
          ¬∑ change IsOpen (Set.range c.inl)·∂ú
            rw [‚Üê eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            exact h‚ÇÇ.isOpen_range
      ¬∑ intro T f g
        ext x
        refine (dif_pos ?_).trans ?_
        ¬∑ exact ‚ü®x, rfl‚ü©
        ¬∑ dsimp
          conv_lhs => erw [Equiv.ofInjective_symm_apply]
          rfl 
      ¬∑ intro T f g
        ext x
        refine (dif_neg ?_).trans ?_
        ¬∑ rintro ‚ü®y, e‚ü©
          have : c.inr x ‚àà Set.range c.inl ‚äì Set.range c.inr := ‚ü®‚ü®_, e‚ü©, ‚ü®_, rfl‚ü©‚ü©
          rwa [disjoint_iff.mp h‚ÇÉ.1] at this
        ¬∑ exact congr_arg g (Equiv.ofInjective_symm_apply _ _)
      ¬∑ rintro T _ _ m rfl rfl
        ext x
        change m x = dite _ _ _
        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ‚ü®_, _‚ü©).symm",":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
           (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
      aesop
    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      have : ‚àÄ x, x ‚àà Set.range c.inl ‚à® x ‚àà Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
        exact fun _ => or_not
      refine ‚ü®BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_‚ü©
      ¬∑ intro T f g
        refine ContinuousMap.mk ?_ ?_
        ¬∑ exact fun x =>
            if h : x ‚àà Set.range c.inl then f ((Equiv.ofInjective _ h‚ÇÅ.inj).symm ‚ü®x, h‚ü©)
            else g ((Equiv.ofInjective _ h‚ÇÇ.inj).symm ‚ü®x, (this x).resolve_left h‚ü©)
        rw [continuous_iff_continuousAt]
        intro x
        by_c"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le,norm_volume_sub_integral_face_upper_sub_lower_smul_le,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
      ¬∑ intro y hy
        refine' (hŒµ y hy).trans (mul_le_mul_of_nonneg_left _ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(¬∑ ‚àò ¬∑), Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine' norm_integral_le_of_le_const (fun y hy => (this y hy).trans _) volume
      rw [mul_assoc (2 * Œµ)]
      exact mul_le_mul_of_nonneg_left (I.diam_Icc_le_of_distortion_le i hc)
        (mul_nonneg zero_le_two h0.le)
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case convert_2
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
y : Fin n ‚Üí ‚Ñù
hy : y ‚àà Box.Icc (I.face i)
g : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
hfc : ContinuousOn (fun y ‚Ü¶ a + f' (y - x) + g y) (Box.Icc I)
Hi :
  ‚àÄ x_1 ‚àà Set.Icc (I.lower i) (I.upper i),
    Integrable (I.face i) ‚ä• ((fun y ‚Ü¶ a + f' (y - x) + g y) ‚àò e x_1) BoxAdditiveMap.volume
hg : g = fun y ‚Ü¶ (fun y ‚Ü¶ a + f' (y - x) + g y) y - a - f' (y - x)
this : ‚àÄ z ‚àà Set.Icc (I.lower i) (I.upper i), e z y ‚àà Box.Icc I
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
error:  unsolved goals
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
hfc : ContinuousOn f (Box.Icc I)
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
Hi : ‚àÄ x ‚àà Set.Icc (I.lower i) (I.upper i), Integrable (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume
this :
  ‚àÄ y ‚àà Box.Icc (I.face i),
    ‚Äñf' (Pi.single i (I.upper i - I.lower i)) - (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñ(‚àè j : Fin (n + 1), (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
        (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
          integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ ‚â§
    2 * Œµ * ‚Üëc * ‚àè j : Fin (n + 1), (I.upper j - I.lower j)","theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E}
    {f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) ‚Üí ‚Ñù}
    (hxI : x ‚àà (Box.Icc I)) {a : E} {Œµ : ‚Ñù} (h0 : 0 < Œµ)
    (hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ) {c : ‚Ñù‚â•0}
    (hc : I.distortion ‚â§ c) :
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
      (integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.lower i))
          BoxAdditiveMap.volume)‚Äñ ‚â§
      2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) ",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I) := by
        intro y hy
        refine (hŒµ y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(¬∑ ‚àò ¬∑), Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * Œµ)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e "
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©,? _‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",error:  unknown constant 'StrictOrderedSemiring.to_charZero',"theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)) : IsIntegralClosure (adjoin ‚Ñ§ ({Œ∂} : Set K)) ‚Ñ§ K ",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subtype.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subtype.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subtype.mem_coe]
    exact Subalgebra"
Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean,Real.Angle.cos_neg,cos_neg,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction Œ∏
  exact Real.cos_neg _","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ∏ : Angle
‚ä¢ (-Œ∏).cos = Œ∏.cos",theorem cos_neg (Œ∏ : Angle) : cos (-Œ∏) = cos Œ∏ ,":= by
  induction Œ∏ using Real.Angle.induction_on
  exact Real.cos_neg _",":= by
  exact Real.cos_neg _"
Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean,MeasureTheory.Measure.lintegral_rnDeriv,lintegral_rnDeriv,069e96204afb60639e37cc18449fd7f58ab913c1,":= by
  rw [‚Üê set_lintegral_univ, set_lintegral_rnDeriv hŒºŒΩ MeasurableSet.univ]","warning:  `MeasureTheory.set_lintegral_univ` has been deprecated, use `MeasureTheory.setLIntegral_univ` instead
warning:  `MeasureTheory.Measure.set_lintegral_rnDeriv` has been deprecated, use `MeasureTheory.Measure.setLIntegral_rnDeriv` instead
error:  application type mismatch
  set_lintegral_rnDeriv hŒºŒΩ MeasurableSet.univ
argument
  MeasurableSet.univ
has type
  MeasurableSet Set.univ : Prop
but is expected to have type
  Set Œ± : Type u_1
error:  failed to synthesize
  SFinite ŒΩ
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.41109
Œ± : Type u_1
Œ≤ : Type u_2
m : MeasurableSpace Œ±
Œº ŒΩ : Measure Œ±
inst‚úù : Œº.HaveLebesgueDecomposition ŒΩ
hŒºŒΩ : Œº ‚â™ ŒΩ
‚ä¢ ‚à´‚Åª (x : Œ±) in Set.univ, Œº.rnDeriv ŒΩ x ‚àÇŒΩ = Œº Set.univ","lemma lintegral_rnDeriv [HaveLebesgueDecomposition Œº ŒΩ] (hŒºŒΩ : Œº ‚â™ ŒΩ) :
    ‚à´‚Åª x, Œº.rnDeriv ŒΩ x ‚àÇŒΩ = Œº Set.univ ",":= by
  rw [‚Üê setLIntegral_univ, setLIntegral_rnDeriv' hŒºŒΩ MeasurableSet.univ]",":= by
  rw [‚Üê setLIntegral_univ, setLIntegral_rnDeriv hŒºŒΩ MeasurableSet.univ]"
Mathlib/MeasureTheory/Measure/Haar/OfBasis.lean,parallelepiped_comp_equiv,parallelepiped_comp_equiv,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  simp only [parallelepiped]
  let K : (Œπ' ‚Üí ‚Ñù) ‚âÉ (Œπ ‚Üí ‚Ñù) := Equiv.piCongrLeft' (fun _a : Œπ' => ‚Ñù) e
  have : Icc (0 : Œπ ‚Üí ‚Ñù) 1 = K '' Icc (0 : Œπ' ‚Üí ‚Ñù) 1 := by
    rw [‚Üê Equiv.preimage_eq_iff_eq_image]
    ext x
    simp only [mem_preimage, mem_Icc, Pi.le_def, Pi.zero_apply, Equiv.piCongrLeft'_apply,
      Pi.one_apply]
    refine'
      ‚ü®fun h => ‚ü®fun i => _, fun i => _‚ü©, fun h =>
        ‚ü®fun i => h.1 (e.symm i), fun i => h.2 (e.symm i)‚ü©‚ü©
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.1 (e i)
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.2 (e i)
  rw [this, ‚Üê image_comp]
  congr 1 with x
  have := fun z : Œπ' ‚Üí ‚Ñù => e.symm.sum_comp fun i => z i ‚Ä¢ v (e i)
  simp_rw [Equiv.apply_symm_apply] at this
  simp_rw [Function.comp_apply, mem_image, mem_Icc, Equiv.piCongrLeft'_apply, this]","error:  type mismatch
  h‚úù
has type
  0 ‚â§ K x (e i) : Prop
but is expected to have type
  0 ‚â§ x i : Prop
error:  type mismatch
  h‚úù
has type
  K x (e i) ‚â§ 1 : Prop
but is expected to have type
  x i ‚â§ 1 : Prop
error:  simp made no progress","theorem parallelepiped_comp_equiv (v : Œπ ‚Üí E) (e : Œπ' ‚âÉ Œπ) :
    parallelepiped (v ‚àò e) = parallelepiped v ",":= by
  simp only [parallelepiped]
  let K : (Œπ' ‚Üí ‚Ñù) ‚âÉ (Œπ ‚Üí ‚Ñù) := Equiv.piCongrLeft' (fun _a : Œπ' => ‚Ñù) e
  have : Icc (0 : Œπ ‚Üí ‚Ñù) 1 = K '' Icc (0 : Œπ' ‚Üí ‚Ñù) 1 := by
    rw [‚Üê Equiv.preimage_eq_iff_eq_image]
    ext x
    simp only [K, mem_preimage, mem_Icc, Pi.le_def, Pi.zero_apply, Equiv.piCongrLeft'_apply,
      Pi.one_apply]
    refine
      ‚ü®fun h => ‚ü®fun i => ?_, fun i => ?_‚ü©, fun h =>
        ‚ü®fun i => h.1 (e.symm i), fun i => h.2 (e.symm i)‚ü©‚ü©
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.1 (e i)
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.2 (e i)
  rw [this, ‚Üê image_comp]
  congr 1 with x
  have := fun z : Œπ' ‚Üí ‚Ñù => e.symm.sum_comp fun i => z i ‚Ä¢ v (e i)
  simp_rw [Equiv.apply_symm_apply] at this
  simp_rw [Function.comp_apply, mem_image, mem_Icc, K, Equiv.piCongrLeft'_apply, this]",":= by
  simp only [parallelepiped]
  let K : (Œπ' ‚Üí ‚Ñù) ‚âÉ (Œπ ‚Üí ‚Ñù) := Equiv.piCongrLeft' (fun _a : Œπ' => ‚Ñù) e
  have : Icc (0 : Œπ ‚Üí ‚Ñù) 1 = K '' Icc (0 : Œπ' ‚Üí ‚Ñù) 1 := by
    rw [‚Üê Equiv.preimage_eq_iff_eq_image]
    ext x
    simp only [mem_preimage, mem_Icc, Pi.le_def, Pi.zero_apply, Equiv.piCongrLeft'_apply,
      Pi.one_apply]
    refine
      ‚ü®fun h => ‚ü®fun i => ?_, fun i => ?_‚ü©, fun h =>
        ‚ü®fun i => h.1 (e.symm i), fun i => h.2 (e.symm i)‚ü©‚ü©
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.1 (e i)
    ¬∑ simpa only [Equiv.symm_apply_apply] using h.2 (e i)
  rw [this, ‚Üê image_comp]
  congr 1 with x
  have := fun z : Œπ' ‚Üí ‚Ñù => e.symm.sum_comp fun i => z i ‚Ä¢ v (e i)
  simp_rw [Equiv.apply_symm_apply] at this
  simp_rw [Function.comp_apply, mem_image, mem_Icc, Equiv.piCongrLeft'_apply, this]"
Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean,geometric_hahn_banach_open,geometric_hahn_banach_open,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  obtain rfl | ‚ü®a‚ÇÄ, ha‚ÇÄ‚ü© := s.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 0, by simp, fun b _hb => le_rfl‚ü©
  obtain rfl | ‚ü®b‚ÇÄ, hb‚ÇÄ‚ü© := t.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 1, fun a _ha => zero_lt_one, by simp‚ü©
  let x‚ÇÄ := b‚ÇÄ - a‚ÇÄ
  let C := x‚ÇÄ +·µ• (s - t)
  have : (0 : E) ‚àà C :=
    ‚ü®a‚ÇÄ - b‚ÇÄ, sub_mem_sub ha‚ÇÄ hb‚ÇÄ, by simp_rw [vadd_eq_add, sub_add_sub_cancel', sub_self]‚ü©
  have : Convex ‚Ñù C := (hs‚ÇÅ.sub ht).vadd _
  have : x‚ÇÄ ‚àâ C := by
    intro hx‚ÇÄ
    rw [‚Üê add_zero x‚ÇÄ] at hx‚ÇÄ
    exact disj.zero_not_mem_sub_set (vadd_mem_vadd_set_iff.1 hx‚ÇÄ)
  obtain ‚ü®f, hf‚ÇÅ, hf‚ÇÇ‚ü© := separate_convex_open_set ‚Äπ0 ‚àà C‚Ä∫ ‚Äπ_‚Ä∫ (hs‚ÇÇ.sub_right.vadd _) ‚Äπx‚ÇÄ ‚àâ C‚Ä∫
  have : f b‚ÇÄ = f a‚ÇÄ + 1 := by simp [x‚ÇÄ, ‚Üê hf‚ÇÅ]
  have forall_le : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a ‚â§ f b := by
    intro a ha b hb
    have := hf‚ÇÇ (x‚ÇÄ + (a - b)) (vadd_mem_vadd_set <| sub_mem_sub ha hb)
    simp only [f.map_add, f.map_sub, hf‚ÇÅ] at this
    linarith
  refine' ‚ü®f, sInf (f '' t), image_subset_iff.1 (_ : f '' s ‚äÜ Iio (sInf (f '' t))), fun b hb => _‚ü©
  ¬∑ rw [‚Üê interior_Iic]
    refine' interior_maximal (image_subset_iff.2 fun a ha => _) (f.isOpenMap_of_ne_zero _ _ hs‚ÇÇ)
    ¬∑ exact le_csInf (Nonempty.image _ ‚ü®_, hb‚ÇÄ‚ü©) (ball_image_of_ball <| forall_le _ ha)
    ¬∑ rintro rfl
      simp at hf‚ÇÅ
  ¬∑ exact csInf_le ‚ü®f a‚ÇÄ, ball_image_of_ball <| forall_le _ ha‚ÇÄ‚ü© (mem_image_of_mem _ hb)","error:  simp made no progress
warning:  `Set.ball_image_of_ball` has been deprecated, use `Set.forall_mem_image` instead
warning:  `Set.ball_image_of_ball` has been deprecated, use `Set.forall_mem_image` instead","theorem geometric_hahn_banach_open (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsOpen s) (ht : Convex ‚Ñù t)
    (disj : Disjoint s t) : ‚àÉ (f : E ‚ÜíL[‚Ñù] ‚Ñù) (u : ‚Ñù), (‚àÄ a ‚àà s, f a < u) ‚àß ‚àÄ b ‚àà t, u ‚â§ f b ",":= by
  obtain rfl | ‚ü®a‚ÇÄ, ha‚ÇÄ‚ü© := s.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 0, by simp, fun b _hb => le_rfl‚ü©
  obtain rfl | ‚ü®b‚ÇÄ, hb‚ÇÄ‚ü© := t.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 1, fun a _ha => zero_lt_one, by simp‚ü©
  let x‚ÇÄ := b‚ÇÄ - a‚ÇÄ
  let C := x‚ÇÄ +·µ• (s - t)
  have : (0 : E) ‚àà C :=
    ‚ü®a‚ÇÄ - b‚ÇÄ, sub_mem_sub ha‚ÇÄ hb‚ÇÄ, by simp_rw [x‚ÇÄ, vadd_eq_add, sub_add_sub_cancel', sub_self]‚ü©
  have : Convex ‚Ñù C := (hs‚ÇÅ.sub ht).vadd _
  have : x‚ÇÄ ‚àâ C := by
    intro hx‚ÇÄ
    rw [‚Üê add_zero x‚ÇÄ] at hx‚ÇÄ
    exact disj.zero_not_mem_sub_set (vadd_mem_vadd_set_iff.1 hx‚ÇÄ)
  obtain ‚ü®f, hf‚ÇÅ, hf‚ÇÇ‚ü© := separate_convex_open_set ‚Äπ0 ‚àà C‚Ä∫ ‚Äπ_‚Ä∫ (hs‚ÇÇ.sub_right.vadd _) ‚Äπx‚ÇÄ ‚àâ C‚Ä∫
  have : f b‚ÇÄ = f a‚ÇÄ + 1 := by simp [x‚ÇÄ, ‚Üê hf‚ÇÅ]
  have forall_le : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a ‚â§ f b := by
    intro a ha b hb
    have := hf‚ÇÇ (x‚ÇÄ + (a - b)) (vadd_mem_vadd_set <| sub_mem_sub ha hb)
    simp only [f.map_add, f.map_sub, hf‚ÇÅ] at this
    linarith
  refine ‚ü®f, sInf (f '' t), image_subset_iff.1 (?_ : f '' s ‚äÜ Iio (sInf (f '' t))), fun b hb => ?_‚ü©
  ¬∑ rw [‚Üê interior_Iic]
    refine interior_maximal (image_subset_iff.2 fun a ha => ?_) (f.isOpenMap_of_ne_zero ?_ _ hs‚ÇÇ)
    ¬∑ exact le_csInf (Nonempty.image _ ‚ü®_, hb‚ÇÄ‚ü©) (forall_mem_image.2 <| forall_le _ ha)
    ¬∑ rintro rfl
      simp at hf‚ÇÅ
  ¬∑ exact csInf_le ‚ü®f a‚ÇÄ, forall_mem_image.2 <| forall_le _ ha‚ÇÄ‚ü© (mem_image_of_mem _ hb)",":= by
  obtain rfl | ‚ü®a‚ÇÄ, ha‚ÇÄ‚ü© := s.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 0, by simp, fun b _hb => le_rfl‚ü©
  obtain rfl | ‚ü®b‚ÇÄ, hb‚ÇÄ‚ü© := t.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 1, fun a _ha => zero_lt_one, by simp‚ü©
  let x‚ÇÄ := b‚ÇÄ - a‚ÇÄ
  let C := x‚ÇÄ +·µ• (s - t)
  have : (0 : E) ‚àà C :=
    ‚ü®a‚ÇÄ - b‚ÇÄ, sub_mem_sub ha‚ÇÄ hb‚ÇÄ, by simp_rw [vadd_eq_add, sub_add_sub_cancel', sub_self]‚ü©
  have : Convex ‚Ñù C := (hs‚ÇÅ.sub ht).vadd _
  have : x‚ÇÄ ‚àâ C := by
    intro hx‚ÇÄ
    rw [‚Üê add_zero x‚ÇÄ] at hx‚ÇÄ
    exact disj.zero_not_mem_sub_set (vadd_mem_vadd_set_iff.1 hx‚ÇÄ)
  obtain ‚ü®f, hf‚ÇÅ, hf‚ÇÇ‚ü© := separate_convex_open_set ‚Äπ0 ‚àà C‚Ä∫ ‚Äπ_‚Ä∫ (hs‚ÇÇ.sub_right.vadd _) ‚Äπx‚ÇÄ ‚àâ C‚Ä∫
  have : f b‚ÇÄ = f a‚ÇÄ + 1 := by simp [x‚ÇÄ, ‚Üê hf‚ÇÅ]
  have forall_le : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a ‚â§ f b := by
    intro a ha b hb
    have := hf‚ÇÇ (x‚ÇÄ + (a - b)) (vadd_mem_vadd_set <| sub_mem_sub ha hb)
    simp only [f.map_add, f.map_sub, hf‚ÇÅ] at this
    linarith
  refine ‚ü®f, sInf (f '' t), image_subset_iff.1 (_ : f '' s ‚äÜ Iio (sInf (f '' t))), fun b hb => ?_‚ü©
  ¬∑ rw [‚Üê interior_Iic]
    refine interior_maximal (image_subset_iff.2 fun a ha => ?_) (f.isOpenMap_of_ne_zero _ _ hs‚ÇÇ)
    ¬∑ exact le_csInf (Nonempty.image _ ‚ü®_, hb‚ÇÄ‚ü©) (ball_image_of_ball <| forall_le _ ha)
    ¬∑ rintro rfl
      simp at hf‚ÇÅ
  ¬∑ exact csInf_le ‚ü®f a‚ÇÄ, ball_image_of_ball <| forall_le _ ha‚ÇÄ‚ü© (mem_image_of_mem _ hb)"
Mathlib/RingTheory/IntegralDomain.lean,sum_hom_units,sum_hom_units,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  classical
    obtain ‚ü®x, hx‚ü© :
      ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0  
    exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u : RÀ£ in univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u : RÀ£ in univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := (congr_arg‚ÇÇ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n in range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only [mem_univ, forall_true_iff])
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
            (fun m n hm hn =>
              pow_injective_of_lt_orderOf _ (by simpa only [mem_range] using hm)
                (by simpa only [mem_range] using hn))
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ‚ä¢; rw [‚Üê pow_eq_mod_orderOf, hn]‚ü©)
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]","error:  unexpected identifier; expected '|'
error:  unsolved goals
case intro
R : Type u_1
G : Type u_2
inst‚úù¬≥ : CommRing R
inst‚úù¬≤ : IsDomain R
inst‚úù¬π : Group G
inst‚úù : Fintype G
f : G ‚Üí* R
hf : f ‚â† 1
x : ‚Ü•f.toHomUnits.range
hx : ‚àÄ (y : ‚Ü•f.toHomUnits.range), y ‚àà Submonoid.powers x
hx1 : ‚Üë‚Üëx - 1 ‚â† 0
‚ä¢ ‚àë g : G, f g = 0","theorem sum_hom_units_eq_zero (f : G ‚Üí* R) (hf : f ‚â† 1) : ‚àë g : G, f g = 0 ",":= by
  classical
    obtain ‚ü®x, hx‚ü© : ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u ‚àà univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u ‚àà univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := congr_arg‚ÇÇ _ rfl ?_
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n ‚àà range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ ¬∑) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ‚ä¢; rw [pow_mod_orderOf, hn]‚ü©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]",":= by
  classical
    obtain ‚ü®x, hx‚ü© :
      ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0 := fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u : RÀ£ ‚àà univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u : RÀ£ ‚àà univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := (congr_arg‚ÇÇ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n ‚àà range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only [mem_univ, forall_true_iff])
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                 Units.val_pow_eq_pow_val])
            (fun m n hm hn =>
              pow_injective_of_lt_orderOf _ (by simpa only [mem_range] using hm)
               (by simpa only [mem_range] using hn))
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
                 by dsimp at hn ‚ä¢; rw [‚Üê pow_eq_mod_orderOf, hn]‚ü©)
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine' Or.inl ‚ü®hs, _‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, _‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine'
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' ‚ü®hus, hsv.symm, ‚ü®x, _, _‚ü©, _‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right _ _, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) _
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 ‚àà ?m.92170 ‚à™ ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 ‚àà ?m.92636 ‚à™ ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 ‚àà ?m.94503 ‚à™ ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 ‚àà ?m.97297 ‚à™ ?m.97298
error:  ambiguous, possible interpretations 
  _root_.not_imp : ¬¨(?m.97719 ‚Üí ?m.97720) ‚Üî ?m.97719 ‚àß ¬¨?m.97720
  
  Classical.not_imp : ¬¨(?m.97721 ‚Üí ?m.97722) ‚Üî ?m.97721 ‚àß ¬¨?m.97722
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.97724
case neg
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
ùíú : Finset (Finset Œ±)
u‚úù v‚úù a : Finset Œ±
r : ‚Ñï
u v : Finset Œ±
huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú
ùíú' : Finset (Finset Œ±) := ùìí u v ùíú
s : Finset Œ±
hsùíú' : s ‚àà ‚àÇ ùíú'
hsùíú : s ‚àâ ‚àÇ ùíú
m : ‚àÄ y ‚àâ s, insert y s ‚àâ ùíú
x : Œ±
left‚úù : x ‚àâ s
right‚úù : insert x s ‚àà ùíú'
hus‚úù : u ‚äÜ insert x s
hvs : Disjoint v (insert x s)
this‚úù¬≤ : (insert x s ‚à™ v) \ u ‚àà ùíú
hsv : Disjoint s v
hvu : Disjoint v u
hxv : x ‚àâ v
this‚úù¬π : v \ u = v
this‚úù : x ‚àâ u
hus : u ‚äÜ s
w : Œ±
hwB : ¬¨(w ‚àà s ‚à™ v ‚àß w ‚àâ u)
hwùíú' : insert w ((s ‚à™ v) \ u) ‚àà ùíú'
this : v ‚äÜ insert w ((s ‚à™ v) \ u)
hwu : w ‚àâ u
‚ä¢ False","theorem shadow_compression_subset_compression_shadow (u v : Finset Œ±)
    (huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú) :
    ‚àÇ (ùìí u v ùíú) ‚äÜ ùìí u v (‚àÇ ùíú) ",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine mem_shadow_iff.2
        ‚ü®(t ‚äî u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) ?_
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx"
Mathlib/Algebra/FreeAlgebra.lean,FreeAlgebra.induction,induction,1cef6bde091247a2ca9028e8773b7efedab9a1b3,":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a","error:  unsolved goals
case w.h
R : Type u_1
inst‚úù : CommSemiring R
X : Type u_2
C : FreeAlgebra R X ‚Üí Prop
h_grade0 : ‚àÄ (r : R), C ((algebraMap R (FreeAlgebra R X)) r)
h_grade1 : ‚àÄ (x : X), C (Œπ R x)
h_mul : ‚àÄ (a b : FreeAlgebra R X), C a ‚Üí C b ‚Üí C (a * b)
h_add : ‚àÄ (a b : FreeAlgebra R X), C a ‚Üí C b ‚Üí C (a + b)
a : FreeAlgebra R X
s : Subalgebra R (FreeAlgebra R X) :=
  { carrier := C, mul_mem' := ‚ãØ, one_mem' := ‚ãØ, add_mem' := ‚ãØ, zero_mem' := ‚ãØ, algebraMap_mem' := h_grade0 }
of : X ‚Üí ‚Ü•s := Subtype.coind (Œπ R) h_grade1
x‚úù : X
‚ä¢ Œπ R x‚úù = ‚Üë(of x‚úù)","theorem induction {C : FreeAlgebra R X ‚Üí Prop}
    (h_grade0 : ‚àÄ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ‚àÄ x, C (Œπ R x))
    (h_mul : ‚àÄ a b, C a ‚Üí C b ‚Üí C (a * b)) (h_add : ‚àÄ a b, C a ‚Üí C b ‚Üí C (a + b))
    (a : FreeAlgebra R X) : C a ",":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a",":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [Subtype.coind]
  suffices a = lift R of a by rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,aestronglyMeasurable_of_tendsto_ae,_root_.aestronglyMeasurable_of_tendsto_ae,ea54eb89c8a123dcfceeb11bd200d459f2f95413,":= by
  borelize Œ≤
  refine' aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®_, _‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà Œº.ae := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ‚ü®closure (‚ãÉ i, t i), .closure <| .iUnion t_sep, ?_‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    refine eventually_of_forall fun n => ?_
    apply mem_iUnion_of_mem n
    exact hx n","error:  invalid field 'ae', the environment does not contain 'MeasureTheory.Measure.ae'
  Œº
has type
  Measure Œ±","theorem _root_.aestronglyMeasurable_of_tendsto_ae {Œπ : Type*} [PseudoMetrizableSpace Œ≤]
    (u : Filter Œπ) [NeBot u] [IsCountablyGenerated u] {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}
    (hf : ‚àÄ i, AEStronglyMeasurable (f i) Œº) (lim : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) u (ùìù (g x))) :
    AEStronglyMeasurable g Œº ",":= by
  borelize Œ≤
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®?_, ?_‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà ae Œº := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ‚ü®closure (‚ãÉ i, t i), .closure <| .iUnion t_sep, ?_‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)",":= by
  borelize Œ≤
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®_, ?_‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà Œº.ae := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ‚ü®closure (‚ãÉ i, t i), .closure <| .iUnion t_sep, ?_‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    refine eventually_of_forall fun n => ?_
    apply mem_iUnion_of_mem n
    exact hx n"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le,norm_volume_sub_integral_face_upper_sub_lower_smul_le,1164cf04af901bdf18b9c65a9e173feb3a0278f9,":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ 
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
      ¬∑ intro y hy
        refine' (hŒµ y hy).trans (mul_le_mul_of_nonneg_left _ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.bounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(¬∑ ‚àò ¬∑), Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine' norm_integral_le_of_le_const (fun y hy => (this y hy).trans _) volume
      rw [mul_assoc (2 * Œµ)]
      exact mul_le_mul_of_nonneg_left (I.diam_Icc_le_of_distortion_le i hc)
        (mul_nonneg zero_le_two h0.le)
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case convert_2
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
y : Fin n ‚Üí ‚Ñù
hy : y ‚àà Box.Icc (I.face i)
g : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
hfc : ContinuousOn (fun y ‚Ü¶ a + f' (y - x) + g y) (Box.Icc I)
Hi :
  ‚àÄ x_1 ‚àà Set.Icc (I.lower i) (I.upper i),
    Integrable (I.face i) ‚ä• ((fun y ‚Ü¶ a + f' (y - x) + g y) ‚àò e x_1) BoxAdditiveMap.volume
hg : g = fun y ‚Ü¶ (fun y ‚Ü¶ a + f' (y - x) + g y) y - a - f' (y - x)
this : ‚àÄ z ‚àà Set.Icc (I.lower i) (I.upper i), e z y ‚àà Box.Icc I
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
error:  unsolved goals
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
hfc : ContinuousOn f (Box.Icc I)
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
Hi : ‚àÄ x ‚àà Set.Icc (I.lower i) (I.upper i), Integrable (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume
this :
  ‚àÄ y ‚àà Box.Icc (I.face i),
    ‚Äñf' (Pi.single i (I.upper i - I.lower i)) - (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñ(‚àè j : Fin (n + 1), (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
        (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
          integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ ‚â§
    2 * Œµ * ‚Üëc * ‚àè j : Fin (n + 1), (I.upper j - I.lower j)","theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E}
    {f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) ‚Üí ‚Ñù}
    (hxI : x ‚àà (Box.Icc I)) {a : E} {Œµ : ‚Ñù} (h0 : 0 < Œµ)
    (hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ) {c : ‚Ñù‚â•0}
    (hc : I.distortion ‚â§ c) :
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
      (integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.lower i))
          BoxAdditiveMap.volume)‚Äñ ‚â§
      2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) ",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I) := by
        intro y hy
        refine (hŒµ y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(¬∑ ‚àò ¬∑), Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * Œµ)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ 
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ 
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ 
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ 
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) "
Mathlib/RingTheory/IntegrallyClosed.lean,isIntegrallyClosed_iff_isIntegralClosure,isIntegrallyClosed_iff_isIntegralClosure,6b3f3fe208f0cdce581d713270301bed755856ed,":=
  (isIntegrallyClosed_iff K).trans <| by
    constructor
    ¬∑ intro cl
      refine' ‚ü®IsFractionRing.injective R K, ‚ü®cl, _‚ü©‚ü©
      rintro ‚ü®y, y_eq‚ü©
      rw [‚Üê y_eq]
      exact isIntegral_algebraMap
    ¬∑ rintro ‚ü®-, cl‚ü© x hx
      exact cl.mp hx",error:  unknown identifier 'isIntegrallyClosed_iff',theorem isIntegrallyClosed_iff_isIntegralClosure : IsIntegrallyClosed R ‚Üî IsIntegralClosure R R K ,":=
  isIntegrallyClosed_iff_isIntegrallyClosedIn K",":=
  isIntegrallyClosed_iff K).trans <| by
    constructor
    ¬∑ intro cl
      refine ‚ü®IsFractionRing.injective R K, ‚ü®cl, ?_‚ü©‚ü©
      rintro ‚ü®y, y_eq‚ü©
      rw [‚Üê y_eq]
      exact isIntegral_algebraMap
    ¬∑ rintro ‚ü®-, cl‚ü© x hx
      exact cl.mp hx"
Mathlib/Data/Rat/Cast/Order.lean,Rat.cast_strictMono,cast_strictMono,73bc871350d19e466d5b8cb7d3d2edb4344a437f,":= fun m n => by
  simpa only [sub_pos, cast_sub] using @cast_pos_of_pos K _ (n - m)","error:  application type mismatch
  @cast_pos_of_pos K
argument
  K
has type
  Type u_5 : Type (u_5 + 1)
but is expected to have type
  ‚Ñö : Type
error:  type mismatch
  n - m
has type
  ‚Ñö : outParam Type
but is expected to have type
  LinearOrderedField ?m.1639 : Type ?u.1294",theorem cast_strictMono : StrictMono ((‚Üë) : ‚Ñö ‚Üí K) ,":= fun p q => by
  simpa only [sub_pos, cast_sub] using cast_pos_of_pos (K := K) (q := q - p)",":= fun m n => by
  simpa only [sub_pos, cast_sub] using @cast_pos_of_pos K _ (n - m)"
Mathlib/Analysis/NormedSpace/Spectrum.lean,SpectrumRestricts.nnreal_iff,nnreal_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine ‚ü®fun h x hx ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ obtain ‚ü®x, -, rfl‚ü© := h.algebraMap_image.symm ‚ñ∏ hx
    exact coe_nonneg x
  ¬∑ exact .of_subset_range_algebraMap _ _ (fun _ ‚Ü¶ Real.toNNReal_coe)
      fun x hx ‚Ü¶ ‚ü®‚ü®x, h x hx‚ü©, rfl‚ü©","error:  function expected at
  of_subset_range_algebraMap ?m.382445 ?m.382446
term has type
  SpectrumRestricts ?m.382443 ?m.382444","lemma nnreal_iff [Algebra ‚Ñù A] {a : A} :
    SpectrumRestricts a ContinuousMap.realToNNReal ‚Üî ‚àÄ x ‚àà spectrum ‚Ñù a, 0 ‚â§ x ",":= by
  refine ‚ü®fun h x hx ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ obtain ‚ü®x, -, rfl‚ü© := h.algebraMap_image.symm ‚ñ∏ hx
    exact coe_nonneg x
  ¬∑ exact .of_subset_range_algebraMap (fun _ ‚Ü¶ Real.toNNReal_coe) fun x hx ‚Ü¶ ‚ü®‚ü®x, h x hx‚ü©, rfl‚ü©",":= by
  refine ‚ü®fun h x hx ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ obtain ‚ü®x, -, rfl‚ü© := h.algebraMap_image.symm ‚ñ∏ hx
    exact coe_nonneg x
  ¬∑ exact .of_subset_range_algebraMap _ _ fun _ ‚Ü¶ Real.toNNReal_coe
      fun x hx ‚Ü¶ ‚ü®‚ü®x, h x hx‚ü©, rfl‚ü©"
Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean,MeasureTheory.Measure.tendsto_addHaar_inter_smul_one_of_density_one,tendsto_addHaar_inter_smul_one_of_density_one,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  have I : ‚àÄ u v, Œº u ‚â† 0 ‚Üí Œº u ‚â† ‚àû ‚Üí MeasurableSet v ‚Üí
    Œº u / Œº u - Œº (v·∂ú ‚à© u) / Œº u = Œº (v ‚à© u) / Œº u := by
    intro u v uzero utop vmeas
    simp_rw [div_eq_mul_inv]
    rw [‚Üê ENNReal.sub_mul]; swap
    ¬∑ simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]
    congr 1
    apply
      ENNReal.sub_eq_of_add_eq (ne_top_of_le_ne_top utop (measure_mono (inter_subset_right _ _)))
    rw [inter_comm _ u, inter_comm _ u]
    exact measure_inter_add_diff u vmeas
  have L : Tendsto (fun r => Œº (s·∂ú ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0) := by
    have A : Tendsto (fun r => Œº (closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1) := by
      apply tendsto_const_nhds.congr' _
      filter_upwards [self_mem_nhdsWithin]
      intro r hr
      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]
      ¬∑ exact (measure_closedBall_pos Œº _ hr).ne'
      ¬∑ exact measure_closedBall_lt_top.ne
    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)
    simp only [tsub_self] at B
    apply B.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    convert I (closedBall x r) s·∂ú (measure_closedBall_pos Œº _ rpos).ne'
      measure_closedBall_lt_top.ne hs.compl
    rw [compl_compl]
  have L' : Tendsto (fun r : ‚Ñù => Œº (s·∂ú ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 0) :=
    tendsto_addHaar_inter_smul_zero_of_density_zero Œº s·∂ú x L t ht h''t
  have L'' : Tendsto (fun r : ‚Ñù => Œº ({x} + r ‚Ä¢ t) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by
    apply tendsto_const_nhds.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    rw [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne', ENNReal.div_self h't h''t]
  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)
  simp only [tsub_zero] at this
  apply this.congr' _
  filter_upwards [self_mem_nhdsWithin]
  rintro r (rpos : 0 < r)
  refine I ({x} + r ‚Ä¢ t) s ?_ ?_ hs
  ¬∑ simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage_add, abs_pow,
      singleton_add, mul_eq_zero]
  ¬∑ simp [h''t, ENNReal.ofReal_ne_top, addHaar_smul, image_add_left, ENNReal.mul_eq_top,
      Ne, not_false_iff, measure_preimage_add, singleton_add, and_false_iff, false_and_iff,
      or_self_iff]","error:  function expected at
  inter_subset_right ?m.538807
term has type
  ?m.538806 ‚àà ?m.538805","theorem tendsto_addHaar_inter_smul_one_of_density_one_aux (s : Set E) (hs : MeasurableSet s)
    (x : E) (h : Tendsto (fun r => Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1))
    (t : Set E) (ht : MeasurableSet t) (h't : Œº t ‚â† 0) (h''t : Œº t ‚â† ‚àû) :
    Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) ",":= by
  have I : ‚àÄ u v, Œº u ‚â† 0 ‚Üí Œº u ‚â† ‚àû ‚Üí MeasurableSet v ‚Üí
    Œº u / Œº u - Œº (v·∂ú ‚à© u) / Œº u = Œº (v ‚à© u) / Œº u := by
    intro u v uzero utop vmeas
    simp_rw [div_eq_mul_inv]
    rw [‚Üê ENNReal.sub_mul]; swap
    ¬∑ simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]
    congr 1
    apply
      ENNReal.sub_eq_of_add_eq (ne_top_of_le_ne_top utop (measure_mono inter_subset_right))
    rw [inter_comm _ u, inter_comm _ u]
    exact measure_inter_add_diff u vmeas
  have L : Tendsto (fun r => Œº (s·∂ú ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0) := by
    have A : Tendsto (fun r => Œº (closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1) := by
      apply tendsto_const_nhds.congr' _
      filter_upwards [self_mem_nhdsWithin]
      intro r hr
      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]
      ¬∑ exact (measure_closedBall_pos Œº _ hr).ne'
      ¬∑ exact measure_closedBall_lt_top.ne
    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)
    simp only [tsub_self] at B
    apply B.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    convert I (closedBall x r) s·∂ú (measure_closedBall_pos Œº _ rpos).ne'
      measure_closedBall_lt_top.ne hs.compl
    rw [compl_compl]
  have L' : Tendsto (fun r : ‚Ñù => Œº (s·∂ú ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 0) :=
    tendsto_addHaar_inter_smul_zero_of_density_zero Œº s·∂ú x L t ht h''t
  have L'' : Tendsto (fun r : ‚Ñù => Œº ({x} + r ‚Ä¢ t) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by
    apply tendsto_const_nhds.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    rw [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne', ENNReal.div_self h't h''t]
  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)
  simp only [tsub_zero] at this
  apply this.congr' _
  filter_upwards [self_mem_nhdsWithin]
  rintro r (rpos : 0 < r)
  refine I ({x} + r ‚Ä¢ t) s ?_ ?_ hs
  ¬∑ simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage_add, abs_pow,
      singleton_add, mul_eq_zero]
  ¬∑ simp [h''t, ENNReal.ofReal_ne_top, addHaar_smul, image_add_left, ENNReal.mul_eq_top,
      Ne, not_false_iff, measure_preimage_add, singleton_add, and_false_iff, false_and_iff,
      or_self_iff]",":= by
  have I : ‚àÄ u v, Œº u ‚â† 0 ‚Üí Œº u ‚â† ‚àû ‚Üí MeasurableSet v ‚Üí
    Œº u / Œº u - Œº (v·∂ú ‚à© u) / Œº u = Œº (v ‚à© u) / Œº u := by
    intro u v uzero utop vmeas
    simp_rw [div_eq_mul_inv]
    rw [‚Üê ENNReal.sub_mul]; swap
    ¬∑ simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]
    congr 1
    apply
      ENNReal.sub_eq_of_add_eq (ne_top_of_le_ne_top utop (measure_mono inter_subset_right))
    rw [inter_comm _ u, inter_comm _ u]
    exact measure_inter_add_diff u vmeas
  have L : Tendsto (fun r => Œº (s·∂ú ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0) := by
    have A : Tendsto (fun r => Œº (closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1) := by
      apply tendsto_const_nhds.congr' _
      filter_upwards [self_mem_nhdsWithin]
      intro r hr
      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]
      ¬∑ exact (measure_closedBall_pos Œº _ hr).ne'
      ¬∑ exact measure_closedBall_lt_top.ne
    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)
    simp only [tsub_self] at B
    apply B.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    convert I (closedBall x r) s·∂ú (measure_closedBall_pos Œº _ rpos).ne'
      measure_closedBall_lt_top.ne hs.compl
    rw [compl_compl]
  have L' : Tendsto (fun r : ‚Ñù => Œº (s·∂ú ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) :=
    tendsto_addHaar_inter_smul_zero_of_density_zero Œº s·∂ú x L t ht h''t
  have L'' : Tendsto (fun r : ‚Ñù => Œº ({x} + r ‚Ä¢ t) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) :=
    tendsto_addHaar_inter_smul_zero_of_density_zero Œº s·∂ú x L t ht h''t
  have L'' : Tendsto (fun r : ‚Ñù => Œº ({x} + r ‚Ä¢ t) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by
    apply tendsto_const_nhds.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    rw [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne', ENNReal.div_self h't h''t]
  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)
  simp only [tsub_zero] at this
  apply this.congr' _
  filter_upwards [self_mem_nhdsWithin]
  rintro r (rpos : 0 < r)
  refine I ({x} + r ‚Ä¢ t) s ?_ ?_ hs
  ¬∑ simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage_left,
      ENNReal.ofReal_eq_zero, not_le, or_fal"
Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus.lean,StarSubalgebra.isUnit_coe_inv_mem,StarSubalgebra.isUnit_coe_inv_mem,f9cebff38659a52daa6b43e9ff6c4f6db610fabe,":= by
  have hx := h.star.mul h
  suffices this : (‚Üëhx.unit‚Åª¬π : A) ‚àà S
  ¬∑ rw [‚Üê one_mul (‚Üëh.unit‚Åª¬π : A), ‚Üê hx.unit.inv_mul, mul_assoc, IsUnit.unit_spec, mul_assoc,
      h.mul_val_inv, mul_one]
    exact mul_mem this (star_mem hxS)
  refine' le_of_isClosed_of_mem ‚ÑÇ hS (mul_mem (star_mem hxS) hxS) _
  haveI := (IsSelfAdjoint.star_mul_self x).isStarNormal
  have hx' := elementalStarAlgebra.isUnit_of_isUnit_of_isStarNormal hx
  convert (‚Üëhx'.unit‚Åª¬π : elementalStarAlgebra ‚ÑÇ (star x * x)).prop using 1
  refine left_inv_eq_right_inv hx.unit.inv_mul ?_
  exact (congr_arg ((‚Üë) : _ ‚Üí A) hx'.unit.mul_inv)",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem StarSubalgebra.isUnit_coe_inv_mem {S : StarSubalgebra ‚ÑÇ A} (hS : IsClosed (S : Set A))
    {x : A} (h : IsUnit x) (hxS : x ‚àà S) : ‚Üëh.unit‚Åª¬π ‚àà S ",":= by
  have hx := h.star.mul h
  suffices this : (‚Üëhx.unit‚Åª¬π : A) ‚àà S by
    rw [‚Üê one_mul (‚Üëh.unit‚Åª¬π : A), ‚Üê hx.unit.inv_mul, mul_assoc, IsUnit.unit_spec, mul_assoc,
      h.mul_val_inv, mul_one]
    exact mul_mem this (star_mem hxS)
  refine le_of_isClosed_of_mem ‚ÑÇ hS (mul_mem (star_mem hxS) hxS) ?_
  haveI := (IsSelfAdjoint.star_mul_self x).isStarNormal
  have hx' := elementalStarAlgebra.isUnit_of_isUnit_of_isStarNormal hx
  convert (‚Üëhx'.unit‚Åª¬π : elementalStarAlgebra ‚ÑÇ (star x * x)).prop using 1
  refine left_inv_eq_right_inv hx.unit.inv_mul ?_
  exact (congr_arg ((‚Üë) : _ ‚Üí A) hx'.unit.mul_inv)",":= by
  have hx := h.star.mul h
  suffices this : (‚Üëhx.unit‚Åª¬π : A) ‚àà S by rw [‚Üê one_mul (‚Üëh.unit‚Åª¬π : A), ‚Üê hx.unit.inv_mul, mul_assoc, IsUnit.unit_spec, mul_assoc,
      h.mul_val_inv, mul_one]
    exact mul_mem this (star_mem hxS)
  refine le_of_isClosed_of_mem ‚ÑÇ hS (mul_mem (star_mem hxS) hxS) ?_
  haveI := (IsSelfAdjoint.star_mul_self x).isStarNormal
  have hx' := elementalStarAlgebra.isUnit_of_isUnit_of_isStarNormal hx
  convert (‚Üëhx'.unit‚Åª¬π : elementalStarAlgebra ‚ÑÇ (star x * x)).prop using 1
  refine left_inv_eq_right_inv hx.unit.inv_mul ?_
  exact (congr_arg ((‚Üë) : _ ‚Üí A) hx'.unit.mul_inv)"
Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean,SimpleGraph.ComponentCompl.exists_adj_boundary_pair,exists_adj_boundary_pair,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  refine' ComponentCompl.ind fun v vnK => _
  let C : G.ComponentCompl K := G.componentComplMk vnK
  let dis := Set.disjoint_iff.mp C.disjoint_right
  by_contra' h
  suffices Set.univ = (C : Set V) by exact dis ‚ü®hK.choose_spec, this ‚ñ∏ Set.mem_univ hK.some‚ü©
  symm
  rw [Set.eq_univ_iff_forall]
  rintro u
  by_contra unC
  obtain ‚ü®p‚ü© := Gc v u
  obtain ‚ü®‚ü®‚ü®x, y‚ü©, xy‚ü©, -, xC, ynC‚ü© :=
    p.exists_boundary_dart (C : Set V) (G.componentComplMk_mem vnK) unC
  exact ynC (mem_of_adj x y xC (fun yK : y ‚àà K => h ‚ü®x, y‚ü© xC yK xy) xy)","error:  unknown tactic
error:  unsolved goals
V : Type u
G : SimpleGraph V
K L L' M : Set V
Gc : G.Preconnected
hK : K.Nonempty
v : V
vnK : v ‚àâ K
C : G.ComponentCompl K := G.componentComplMk vnK
dis : K ‚à© ‚ÜëC ‚äÜ ‚àÖ := Set.disjoint_iff.mp (ComponentCompl.disjoint_right C)
‚ä¢ ‚àÉ ck, ck.1 ‚àà G.componentComplMk vnK ‚àß ck.2 ‚àà K ‚àß G.Adj ck.1 ck.2","theorem exists_adj_boundary_pair (Gc : G.Preconnected) (hK : K.Nonempty) :
    ‚àÄ C : G.ComponentCompl K, ‚àÉ ck : V √ó V, ck.1 ‚àà C ‚àß ck.2 ‚àà K ‚àß G.Adj ck.1 ck.2 ",":= by
  refine ComponentCompl.ind fun v vnK => ?_
  let C : G.ComponentCompl K := G.componentComplMk vnK
  let dis := Set.disjoint_iff.mp C.disjoint_right
  by_contra! h
  suffices Set.univ = (C : Set V) by exact dis ‚ü®hK.choose_spec, this ‚ñ∏ Set.mem_univ hK.some‚ü©
  symm
  rw [Set.eq_univ_iff_forall]
  rintro u
  by_contra unC
  obtain ‚ü®p‚ü© := Gc v u
  obtain ‚ü®‚ü®‚ü®x, y‚ü©, xy‚ü©, -, xC, ynC‚ü© :=
    p.exists_boundary_dart (C : Set V) (G.componentComplMk_mem vnK) unC
  exact ynC (mem_of_adj x y xC (fun yK : y ‚àà K => h ‚ü®x, y‚ü© xC yK xy) xy)",":= by
  refine ComponentCompl.ind fun v vnK => ?_
  let C : G.ComponentCompl K := G.componentComplMk vnK
  let dis := Set.disjoint_iff.mp C.disjoint_right
  by_contra' h
  suffices Set.univ = (C : Set V) by exact dis ‚ü®hK.choose_spec, this ‚ñ∏ Set.mem_univ hK.some‚ü©
  symm
  rw [Set.eq_univ_iff_forall]
  rintro u
  by_contra unC
  obtain ‚ü®p‚ü© := Gc v u
  obtain ‚ü®‚ü®‚ü®x, y‚ü©, xy‚ü©, -, xC, ynC‚ü© :=
    p.exists_boundary_dart (C : Set V) (G.componentComplMk_mem vnK) unC
  exact ynC (mem_of_adj x y xC (fun yK : y ‚àà K => h ‚ü®x, y‚ü© xC yK xy) xy)"
Mathlib/Data/List/Cycle.lean,List.next_getLast_cons,next_getLast_cons,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [next, get, ‚Üê dropLast_append_getLast (cons_ne_nil y l), hx, nextOr_concat]
  subst hx
  intro H
  obtain ‚ü®‚ü®_ | k, hk‚ü©, hk'‚ü© := get_of_mem H
  ¬∑ rw [‚Üê Option.some_inj] at hk'
    rw [‚Üê get?_eq_get, dropLast_eq_take, get?_take, get?_zero, head?_cons,
      Option.some_inj] at hk'
    ¬∑ exact hy (Eq.symm hk')
    rw [length_cons, Nat.pred_succ]
    exact length_pos_of_mem (by assumption)
  suffices k + 1 = l.length by simp [this] at hk
  cases' l with hd tl
  ¬∑ simp at hk
  ¬∑ rw [nodup_iff_injective_get] at hl
    rw [length, Nat.succ_inj']
    refine Fin.val_eq_of_eq <| @hl ‚ü®k, Nat.lt_of_succ_lt <| by simpa using hk‚ü©
      ‚ü®tl.length, by simp‚ü© ?_
    rw [‚Üê Option.some_inj] at hk'
    rw [‚Üê get?_eq_get, dropLast_eq_take, get?_take, get?, get?_eq_get, Option.some_inj] at hk'
    ¬∑ rw [hk']
      simp only [getLast_eq_get, length_cons, ge_iff_le, Nat.succ_sub_succ_eq_sub,
        nonpos_iff_eq_zero, add_eq_zero_iff, and_false, tsub_zero, get_cons_succ]
    simpa using hk","warning:  `List.get?_take` has been deprecated, use `List.getElem?_take` instead
warning:  `List.get?_take` has been deprecated, use `List.getElem?_take` instead
error:  unsolved goals
case h.intro.mk.succ.cons
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
y : Œ±
k : ‚Ñï
hd : Œ±
tl : List Œ±
hl : Function.Injective (hd :: tl).get
h‚úù : (y :: hd :: tl).getLast ‚ãØ ‚àà hd :: tl
h : (y :: hd :: tl).getLast ‚ãØ ‚àà y :: hd :: tl
hy : (y :: hd :: tl).getLast ‚ãØ ‚â† y
H : (y :: hd :: tl).getLast ‚ãØ ‚àà (y :: hd :: tl).dropLast
hk : k + 1 < (y :: hd :: tl).dropLast.length
hk'‚úù : (hd :: tl).get? k = some ((y :: hd :: tl).getLast ‚ãØ)
hk' : (hd :: tl).get ‚ü®k, ‚ãØ‚ü© = (y :: hd :: tl).getLast ‚ãØ
‚ä¢ (y :: hd :: tl).get ‚ü®tl.length + 1 - 0, ‚ãØ‚ü© = (hd :: tl).get ‚ü®tl.length, ‚ãØ‚ü©
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead","theorem next_getLast_cons (h : x ‚àà l) (y : Œ±) (h : x ‚àà y :: l) (hy : x ‚â† y)
    (hx : x = getLast (y :: l) (cons_ne_nil _ _)) (hl : Nodup l) : next (y :: l) x h = y ",":= by
  rw [next, get, ‚Üê dropLast_append_getLast (cons_ne_nil y l), hx, nextOr_concat]
  subst hx
  intro H
  obtain ‚ü®‚ü®_ | k, hk‚ü©, hk'‚ü© := get_of_mem H
  ¬∑ rw [‚Üê Option.some_inj] at hk'
    rw [‚Üê get?_eq_get, dropLast_eq_take, get?_eq_getElem?, getElem?_take, getElem?_cons_zero,
      Option.some_inj] at hk'
    ¬∑ exact hy (Eq.symm hk')
    rw [length_cons, Nat.pred_succ]
    exact length_pos_of_mem (by assumption)
  suffices k + 1 = l.length by simp [this] at hk
  cases' l with hd tl
  ¬∑ simp at hk
  ¬∑ rw [nodup_iff_injective_get] at hl
    rw [length, Nat.succ_inj']
    refine Fin.val_eq_of_eq <| @hl ‚ü®k, Nat.lt_of_succ_lt <| by simpa using hk‚ü©
      ‚ü®tl.length, by simp‚ü© ?_
    rw [‚Üê Option.some_inj] at hk'
    rw [‚Üê get?_eq_get, dropLast_eq_take, get?_eq_getElem?, getElem?_take, getElem?_cons_succ,
      getElem?_eq_getElem, Option.some_inj] at hk'
    ¬∑ rw [get_eq_getElem, hk']
      simp only [getLast_eq_get, length_cons, Nat.succ_eq_add_one, Nat.succ_sub_succ_eq_sub,
        Nat.sub_zero, get_eq_getElem, getElem_cons_succ]
    simpa using hk",":= by
  rw [next, get, ‚Üê dropLast_append_getLast (cons_ne_nil y l), hx, nextOr_concat]
  subst hx
  intro H
  obtain ‚ü®‚ü®_ | k, hk‚ü©, hk'‚ü© := get_of_mem H
  ¬∑ rw [‚Üê Option.some_inj] at hk'
    rw [‚Üê get?_eq_get, dropLast_eq_take, get?_take, get?_eq_get, Option.some_inj] at hk'
    ¬∑ rw [hk']
      simp only [getLast_eq_get, length_cons, ge_iff_le, Nat.succ_sub_succ_eq_sub,
        nonpos_iff_eq_zero, add_eq_zero_iff, and_false, tsub_zero, get_cons_succ]
    simpa using hk"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,2ba547a6481ef513d87a606a16c441262be9e648,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  simp made no progress
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff]"
Mathlib/Analysis/Analytic/Composition.lean,FormalMultilinearSeries.compChangeOfVariables_blocksFun,compChangeOfVariables_blocksFun,af9d43f9bbdb4f3b53b8f44c4470bd5820508324,":= by
  rcases i with ‚ü®n, f‚ü©
  dsimp [Composition.blocksFun, Composition.blocks, compChangeOfVariables]
  simp only [map_ofFn, List.get_ofFn, Function.comp_apply]
  rfl","error:  simp made no progress
warning:  `List.get_splitWrtComposition` has been deprecated, use `List.getElem_splitWrtComposition` instead
warning:  `List.get_drop'` has been deprecated, use `List.getElem_drop'` instead
warning:  `List.get_take'` has been deprecated, use `List.getElem_take` instead","theorem compChangeOfVariables_blocksFun (m M N : ‚Ñï) {i : Œ£ n, Fin n ‚Üí ‚Ñï}
    (hi : i ‚àà compPartialSumSource m M N) (j : Fin i.1) :
    (compChangeOfVariables m M N i hi).2.blocksFun
        ‚ü®j, (compChangeOfVariables_length m M N hi).symm ‚ñ∏ j.2‚ü© =
      i.2 j ",":= by
  rcases i with ‚ü®n, f‚ü©
  dsimp [Composition.blocksFun, Composition.blocks, compChangeOfVariables]
  simp only [map_ofFn, List.getElem_ofFn, Function.comp_apply]",":= by
  rcases i with ‚ü®n, f‚ü©
  dsimp [Composition.blocksFun, Composition.blocks, compChangeOfVariables]
  rfl"
Mathlib/NumberTheory/Pell.lean,Pell.Solution‚ÇÅ.exists_pos_of_not_isSquare,exists_pos_of_not_isSquare,a71231735e55fa1fc4000a42658641f766fde88b,":= by
  obtain ‚ü®x, y, h, hy‚ü© := exists_of_not_isSquare h‚ÇÄ hd
  refine' ‚ü®mk |x| |y| (by rwa [sq_abs, sq_abs]), _, abs_pos.mpr hy‚ü©
  rw [x_mk, ‚Üê one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]
  exact mul_pos h‚ÇÄ (sq_pos_of_ne_zero y hy)","error:  application type mismatch
  sq_pos_of_ne_zero y
argument
  y
has type
  ‚Ñ§ : Type
but is expected to have type
  ?m.135767 ‚â† 0 : Prop","theorem exists_pos_of_not_isSquare (h‚ÇÄ : 0 < d) (hd : ¬¨IsSquare d) :
    ‚àÉ a : Solution‚ÇÅ d, 1 < a.x ‚àß 0 < a.y ",":= by
  obtain ‚ü®x, y, h, hy‚ü© := exists_of_not_isSquare h‚ÇÄ hd
  refine ‚ü®mk |x| |y| (by rwa [sq_abs, sq_abs]), ?_, abs_pos.mpr hy‚ü©
  rw [x_mk, ‚Üê one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]
  exact mul_pos h‚ÇÄ (sq_pos_of_ne_zero hy)",":= by
  obtain ‚ü®x, y, h, hy‚ü© := exists_of_not_isSquare h‚ÇÄ hd
  refine ‚ü®mk |x| |y| (by rwa [sq_abs, sq_abs]), ?_, abs_pos.mpr hy‚ü©
  rw [x_mk, ‚Üê one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]
  exact mul_pos h‚ÇÄ sq_pos_of_ne_zero y hy"
Mathlib/Topology/Bases.lean,Dense.exists_countable_dense_subset_bot_top,Dense.exists_countable_dense_subset_bot_top,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine ‚ü®(t ‚à™ ({ x | IsBot x } ‚à™ { x | IsTop x })) ‚à© s, ?_, ?_?, ?_, _, ?_‚ü©
  exacts [inter_subset_right _ _,
    (htc.union ((countable_isBot Œ±).union (countable_isTop Œ±))).mono (inter_subset_left _ _),
    htd.mono (subset_inter (subset_union_left _ _) hts), fun x hx hxs => ‚ü®Or.inr <| Or.inl hx, hxs‚ü©,
    fun x hx hxs => ‚ü®Or.inr <| Or.inr hx, hxs‚ü©]","error:  don't know how to synthesize placeholder for argument 'left'
context:
Œ± : Type u_1
inst‚úù¬≤ : TopologicalSpace Œ±
inst‚úù¬π : PartialOrder Œ±
s : Set Œ±
inst‚úù : SeparableSpace ‚Üës
hs : Dense s
t : Set Œ±
hts : t ‚äÜ s
htc : t.Countable
htd : Dense t
‚ä¢ ‚àÄ (x : Œ±), IsBot x ‚Üí x ‚àà s ‚Üí x ‚àà (t ‚à™ ({x | IsBot x} ‚à™ {x | IsTop x})) ‚à© s
error:  unsolved goals
case intro.intro.intro
Œ± : Type u_1
inst‚úù¬≤ : TopologicalSpace Œ±
inst‚úù¬π : PartialOrder Œ±
s : Set Œ±
inst‚úù : SeparableSpace ‚Üës
hs : Dense s
t : Set Œ±
hts : t ‚äÜ s
htc : t.Countable
htd : Dense t
‚ä¢ ‚àÉ t ‚äÜ s, t.Countable ‚àß Dense t ‚àß (‚àÄ (x : Œ±), IsBot x ‚Üí x ‚àà s ‚Üí x ‚àà t) ‚àß ‚àÄ (x : Œ±), IsTop x ‚Üí x ‚àà s ‚Üí x ‚àà t","theorem Dense.exists_countable_dense_subset_bot_top {Œ± : Type*} [TopologicalSpace Œ±]
    [PartialOrder Œ±] {s : Set Œ±} [SeparableSpace s] (hs : Dense s) :
    ‚àÉ t ‚äÜ s, t.Countable ‚àß Dense t ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àà s ‚Üí x ‚àà t) ‚àß
      ‚àÄ x, IsTop x ‚Üí x ‚àà s ‚Üí x ‚àà t ",":= by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine ‚ü®(t ‚à™ ({ x | IsBot x } ‚à™ { x | IsTop x })) ‚à© s, ?_, ?_, ?_, ?_, ?_‚ü©
  exacts [inter_subset_right,
    (htc.union ((countable_isBot Œ±).union (countable_isTop Œ±))).mono inter_subset_left,
    htd.mono (subset_inter subset_union_left hts), fun x hx hxs => ‚ü®Or.inr <| Or.inl hx, hxs‚ü©,
    fun x hx hxs => ‚ü®Or.inr <| Or.inr hx, hxs‚ü©]",":= by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine ‚ü®(t ‚à™ ({ x | IsBot x } ‚à™ { x | IsTop x })) ‚à© s, ?_, ?_, ?_, ?_, ?_‚ü©
  exacts [inter_subset_right,
    (htc.union ((countable_isBot Œ±).union (countable_isTop Œ±))).mono inter_subset_left,
    htd.mono (subset_inter (subset_union_left hts), fun x hx hxs => ‚ü®Or.inr <| Or.inl hx, hxs‚ü©,
    fun x hx hxs => ‚ü®Or.inr <| Or.inr hx, hxs‚ü©]"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,dc75ecfadb9fc95b08f2668b88d64b26c11ab59b,":= by
  refine' ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, _‚ü©, rfl‚ü©, _‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",error:  unknown constant 'StrictOrderedSemiring.to_charZero',"theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)) : IsIntegralClosure (adjoin ‚Ñ§ ({Œ∂} : Set K)) ‚Ñ§ K ",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.sub_mem _ (self_mem_adjo"
Mathlib/Data/Set/Function.lean,Set.exists_eq_graphOn,exists_eq_graphOn,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  refine ‚ü®?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ rintro ‚ü®f, hf‚ü©
    rw [hf]
    exact InjOn.image_of_comp <| injOn_id _
  ¬∑ have : ‚àÄ x ‚àà Prod.fst '' s, ‚àÉ y, (x, y) ‚àà s := ball_image_iff.2 fun (x, y) h ‚Ü¶ ‚ü®y, h‚ü©
    choose! f hf using this
    rw [ball_image_iff] at hf
    use f
    rw [graphOn, image_image, EqOn.image_eq_self]
    exact fun x hx ‚Ü¶ h (hf x hx) hx rfl","warning:  `Set.ball_image_iff` has been deprecated, use `Set.forall_mem_image` instead
warning:  `Set.ball_image_iff` has been deprecated, use `Set.forall_mem_image` instead
error:  application type mismatch
  hf x
argument
  x
has type
  Œ± √ó Œ≤ : Type (max u_1 u_2)
but is expected to have type
  ?m.51208 ‚àà s : Prop","lemma exists_eq_graphOn_image_fst [Nonempty Œ≤] {s : Set (Œ± √ó Œ≤)} :
    (‚àÉ f : Œ± ‚Üí Œ≤, s = graphOn f (Prod.fst '' s)) ‚Üî InjOn Prod.fst s ",":= by
  refine ‚ü®?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ rintro ‚ü®f, hf‚ü©
    rw [hf]
    exact InjOn.image_of_comp <| injOn_id _
  ¬∑ have : ‚àÄ x ‚àà Prod.fst '' s, ‚àÉ y, (x, y) ‚àà s := forall_mem_image.2 fun (x, y) h ‚Ü¶ ‚ü®y, h‚ü©
    choose! f hf using this
    rw [forall_mem_image] at hf
    use f
    rw [graphOn, image_image, EqOn.image_eq_self]
    exact fun x hx ‚Ü¶ h (hf hx) hx rfl",":= by
  refine ‚ü®?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ rintro ‚ü®f, hf‚ü©
    rw [hf]
    exact InjOn.image_of_comp <| injOn_id _
  ¬∑ have : ‚àÄ x ‚àà Prod.fst '' s, ‚àÉ y, (x, y) ‚àà s := ball_image_iff.2 fun (x, y) h ‚Ü¶ ‚ü®y, h‚ü©
    choose! f hf using this
    rw [ball_image_iff] at hf
    use f
    rw [graphOn, image_image]
    exact fun x hx ‚Ü¶ h (hf x hx) hx rfl"
Mathlib/Analysis/SpecialFunctions/Integrals.lean,intervalIntegral.intervalIntegrable_rpow',intervalIntegrable_rpow',0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg_of_nonneg hx.1.le
    ¬∑ refine' (continuousOn_id.rpow_const _).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine' m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]","error:  no goals to be solved
warning:  `rpow_nonneg_of_nonneg` has been deprecated, use `Real.rpow_nonneg` instead","theorem intervalIntegrable_rpow' {r : ‚Ñù} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg_of_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const _).div_const ?_; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]"
Mathlib/Algebra/Homology/QuasiIso.lean,quasiIso_of_comp_right,quasiIso_of_comp_right,4773ba7abb162ea632c1ff5810cd5f45a1289422,  quasiIso n := quasiIsoAt_of_comp_right œÜ œÜ' n,"error:  function expected at
  QuasiIso œÜ
term has type
  Prop
error:  unknown identifier 'n'","lemma quasiIso_of_comp_right (œÜ : K ‚ü∂ L) (œÜ' : L ‚ü∂ M) [‚àÄ i, K.HasHomology i]
    [‚àÄ i, L.HasHomology i] [‚àÄ i, M.HasHomology i]
    [hœÜ : QuasiIso œÜ'] [hœÜœÜ' : QuasiIso (œÜ ‚â´ œÜ')] :
    QuasiIso œÜ ",":= by
  rw [‚Üê quasiIso_iff_comp_right œÜ œÜ']
  infer_instance",:= QuasiIso.comp_right œÜ œÜ' n
Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean,Collinear.oangle_sign_of_sameRay_vsub,_root_.Collinear.oangle_sign_of_sameRay_vsub,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _
          (Set.mem_singleton _)))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÉ‚ÇÑ
    rw [‚Üê Real.Angle.sign_eq_zero_iff] at hs‚ÇÅ‚ÇÖ‚ÇÇ hs‚ÇÉ‚ÇÖ‚ÇÑ
    rw [hs‚ÇÅ‚ÇÖ‚ÇÇ, hs‚ÇÉ‚ÇÖ‚ÇÑ]
  ¬∑ let s : Set (P √ó P √ó P) :=
      (fun x : line[‚Ñù, p‚ÇÅ, p‚ÇÇ] √ó V => (x.1, p‚ÇÖ, x.2 +·µ• (x.1 : P))) ''
        Set.univ √óÀ¢ {v | SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) v ‚àß v ‚â† 0}
    have hco : IsConnected s :=
      haveI : ConnectedSpace line[‚Ñù, p‚ÇÅ, p‚ÇÇ] := AddTorsor.connectedSpace _ _
      (isConnected_univ.prod (isConnected_setOf_sameRay_and_ne_zero
        (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm))).image _
        (continuous_fst.subtype_val.prod_mk (continuous_const.prod_mk
          (continuous_snd.vadd continuous_fst.subtype_val))).continuousOn
    have hf : ContinuousOn (fun p : P √ó P √ó P => ‚à° p.1 p.2.1 p.2.2) s := by
      refine' ContinuousAt.continuousOn fun p hp => continuousAt_oangle _ _
      all_goals
        simp_rw [Set.mem_image, Set.mem_prod, Set.mem_univ, true_and_iff, Prod.ext_iff] at hp
        obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
        dsimp only at hp ‚ä¢
        obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
        dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
        obtain ‚ü®hvr, -‚ü© := hv
        rintro rfl
        refine hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan ?_).2 (collinear_pair _ _ _))
      ¬∑ exact hq
      ¬∑ refine' vadd_mem_of_mem_direction _ hq
        rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
        obtain ‚ü®r, -, rfl‚ü© := hvr
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hsp : ‚àÄ p : P √ó P √ó P, p ‚àà s ‚Üí ‚à° p.1 p.2.1 p.2.2 ‚â† 0 ‚àß ‚à° p.1 p.2.1 p.2.2 ‚â† œÄ := by
      intro p hp
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff] at hp
      obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
      dsimp only at hp ‚ä¢
      obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
      dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
      obtain ‚ü®hvr, hv0‚ü© := hv
      rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
      obtain ‚ü®r, -, rfl‚ü© := hvr
      change q ‚àà line[‚Ñù, p‚ÇÅ, p‚ÇÇ] at hq
      rw [oangle_ne_zero_and_ne_pi_iff_affineIndependent]
      refine' affineIndependent_of_ne_of_mem_of_not_mem_of_mem _ hq
          (fun h => hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan h).2 (collinear_pair _ _ _))) _
      ¬∑ rwa [‚Üê @vsub_ne_zero V, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, neg_ne_zero]
      ¬∑ refine' vadd_mem_of_mem_direction _ hq
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hp‚ÇÅp‚ÇÇs : (p‚ÇÅ, p‚ÇÖ, p‚ÇÇ) ‚àà s := by
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff, Prod.ext_iff]
      refine' ‚ü®‚ü®‚ü®p‚ÇÅ, left_mem_affineSpan_pair ‚Ñù _ _‚ü©, p‚ÇÇ -·µ• p‚ÇÅ‚ü©,
        ‚ü®SameRay.rfl, vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm‚ü©, _‚ü©
      simp
    have hp‚ÇÉp‚ÇÑs : (p‚ÇÉ, p‚ÇÖ, p‚ÇÑ) ‚àà s := by
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff, Prod.ext_iff]
      refine' ‚ü®‚ü®‚ü®p‚ÇÉ, hc.mem_affineSpan_of_mem_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _))) hp‚ÇÅp‚ÇÇ‚ü©, p‚ÇÑ -·µ• p‚ÇÉ‚ü©,
        ‚ü®hr, vsub_ne_zero.2 hp‚ÇÉp‚ÇÑ.symm‚ü©, _‚ü©
      simp
    convert Real.Angle.sign_eq_of_continuousOn hco hf hsp hp‚ÇÉp‚ÇÑs hp‚ÇÅp‚ÇÇs","warning:  @oangle does not have a doc string
error:  simp made no progress
error:  simp made no progress
error:  unknown identifier 'hq'
error:  unknown identifier 'hq'
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress","theorem _root_.Collinear.oangle_sign_of_sameRay_vsub {p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P} (p‚ÇÖ : P) (hp‚ÇÅp‚ÇÇ : p‚ÇÅ ‚â† p‚ÇÇ)
    (hp‚ÇÉp‚ÇÑ : p‚ÇÉ ‚â† p‚ÇÑ) (hc : Collinear ‚Ñù ({p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P))
    (hr : SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) (p‚ÇÑ -·µ• p‚ÇÉ)) : (‚à° p‚ÇÅ p‚ÇÖ p‚ÇÇ).sign = (‚à° p‚ÇÉ p‚ÇÖ p‚ÇÑ).sign ",":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _
          (Set.mem_singleton _)))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÉ‚ÇÑ
    rw [‚Üê Real.Angle.sign_eq_zero_iff] at hs‚ÇÅ‚ÇÖ‚ÇÇ hs‚ÇÉ‚ÇÖ‚ÇÑ
    rw [hs‚ÇÅ‚ÇÖ‚ÇÇ, hs‚ÇÉ‚ÇÖ‚ÇÑ]
  ¬∑ let s : Set (P √ó P √ó P) :=
      (fun x : line[‚Ñù, p‚ÇÅ, p‚ÇÇ] √ó V => (x.1, p‚ÇÖ, x.2 +·µ• (x.1 : P))) ''
        Set.univ √óÀ¢ {v | SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) v ‚àß v ‚â† 0}
    have hco : IsConnected s :=
      haveI : ConnectedSpace line[‚Ñù, p‚ÇÅ, p‚ÇÇ] := AddTorsor.connectedSpace _ _
      (isConnected_univ.prod (isConnected_setOf_sameRay_and_ne_zero
        (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm))).image _
        (continuous_fst.subtype_val.prod_mk (continuous_const.prod_mk
          (continuous_snd.vadd continuous_fst.subtype_val))).continuousOn
    have hf : ContinuousOn (fun p : P √ó P √ó P => ‚à° p.1 p.2.1 p.2.2) s := by
      refine ContinuousAt.continuousOn fun p hp => continuousAt_oangle ?_ ?_
      all_goals
        simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_univ, true_and_iff, Prod.ext_iff] at hp
        obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
        dsimp only at hp ‚ä¢
        obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
        dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
        obtain ‚ü®hvr, -‚ü© := hv
        rintro rfl
        refine hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan ?_).2 (collinear_pair _ _ _))
      ¬∑ exact hq
      ¬∑ refine vadd_mem_of_mem_direction ?_ hq
        rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
        obtain ‚ü®r, -, rfl‚ü© := hvr
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hsp : ‚àÄ p : P √ó P √ó P, p ‚àà s ‚Üí ‚à° p.1 p.2.1 p.2.2 ‚â† 0 ‚àß ‚à° p.1 p.2.1 p.2.2 ‚â† œÄ := by
      intro p hp
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff] at hp
      obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
      dsimp only at hp ‚ä¢
      obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
      dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
      obtain ‚ü®hvr, hv0‚ü© := hv
      rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
      obtain ‚ü®r, -, rfl‚ü© := hvr
      change q ‚àà line[‚Ñù, p‚ÇÅ, p‚ÇÇ] at hq
      rw [oangle_ne_zero_and_ne_pi_iff_affineIndependent]
      refine affineIndependent_of_ne_of_mem_of_not_mem_of_mem ?_ hq
          (fun h => hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan h).2 (collinear_pair _ _ _))) ?_
      ¬∑ rwa [‚Üê @vsub_ne_zero V, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, neg_ne_zero]
      ¬∑ refine vadd_mem_of_mem_direction ?_ hq
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hp‚ÇÅp‚ÇÇs : (p‚ÇÅ, p‚ÇÖ, p‚ÇÇ) ‚àà s := by
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine ‚ü®‚ü®‚ü®p‚ÇÅ, left_mem_affineSpan_pair ‚Ñù _ _‚ü©, p‚ÇÇ -·µ• p‚ÇÅ‚ü©,
        ‚ü®SameRay.rfl, vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm‚ü©, ?_‚ü©
      simp
    have hp‚ÇÉp‚ÇÑs : (p‚ÇÉ, p‚ÇÖ, p‚ÇÑ) ‚àà s := by
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine ‚ü®‚ü®‚ü®p‚ÇÉ, hc.mem_affineSpan_of_mem_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _))) hp‚ÇÅp‚ÇÇ‚ü©, p‚ÇÑ -·µ• p‚ÇÉ‚ü©,
        ‚ü®hr, vsub_ne_zero.2 hp‚ÇÉp‚ÇÑ.symm‚ü©, ?_‚ü©
      simp
    convert Real.Angle.sign_eq_of_continuousOn hco hf hsp hp‚ÇÉp‚ÇÑs hp‚ÇÅp‚ÇÇs",":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ Set.mem_insert _ _))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2"
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,8c4338d2f64ef8da7809ea24b10b780568e6b917,":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp (config := { unfoldPartialApp := true }) only [inversion]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ F ‚ÜíL[‚Ñù] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x ‚Ü¶ c + x) x) c) ^ 2 ‚Ä¢
      ‚Üë{ toLinearEquiv := (reflection (Submodule.span ‚Ñù {(fun x ‚Ü¶ c + x) x - c})·óÆ).toLinearEquiv, continuous_toFun := ‚ãØ,
          continuous_invFun := ‚ãØ })
    ((fun x ‚Ü¶ c + x) x)","theorem hasFDerivAt_inversion (hx : x ‚â† c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 ‚Ä¢ (reflection (‚Ñù ‚àô (x - c))·óÆ : F ‚ÜíL[‚Ñù] F)) x ",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (?_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp (config := { unfoldPartialApp := true }) only [inversion]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]"
Mathlib/Topology/AlexandrovDiscrete.lean,exterior_subset_iff_mem_nhdsSet,exterior_subset_iff_mem_nhdsSet,13444d800e71a22689e60023576255503756cd93,:=,error:  unexpected token 'lemma'; expected term,lemma exterior_subset_iff_mem_nhdsSet : exterior s ‚äÜ t ‚Üî t ‚àà ùìùÀ¢ s ,":=
  exterior_subset_iff.trans mem_nhdsSet_iff_exists.symm",":=
  mem_nhdsSet_iff_mem_nhdsSet"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.exists_of_mem_join,exists_of_mem_join,938069ac7c83a4980c46ca108d9947ab788c12ee,":= by
  suffices
    ‚àÄ ss : WSeq Œ±,
      a ‚àà ss ‚Üí ‚àÄ s S, append s (join S) = ss ‚Üí a ‚àà append s (join S) ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)
  intro ss h; induction' h using mem_rec_on with ss b ss _ IH ss _ IH <;> intro s S
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp at m ‚ä¢
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp only [cons_append, mem_cons_iff] at m ‚ä¢
    cases' m with e m
    ¬∑ simp [e]
    exact Or.imp_left Or.inr (IH _ _ rfl m)
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;> simp at this <;>
      subst ss
    ¬∑ apply Or.inr
      simp [-exists_eq_or_imp] at m ‚ä¢
      cases' IH s S rfl m with as ex
      ¬∑ exact ‚ü®s, Or.inl rfl, as‚ü©
      ¬∑ rcases ex with ‚ü®s', sS, as‚ü©
        exact ‚ü®s', Or.inr sS, as‚ü©
    ¬∑ apply Or.inr
      simp? at m says simp only [join_think, nil_append, mem_think] at m
      rcases (IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with ‚ü®s, sS, as‚ü©
      exact ‚ü®s, by simp [sS], as‚ü©
    ¬∑ simp only [think_append, mem_think] at m IH ‚ä¢
      apply IH _ _ rfl m",error:  failed to infer implicit target s,"theorem exists_of_mem_join {a : Œ±} : ‚àÄ {S : WSeq (WSeq Œ±)}, a ‚àà join S ‚Üí ‚àÉ s, s ‚àà S ‚àß a ‚àà s ",":= by
  suffices
    ‚àÄ ss : WSeq Œ±,
      a ‚àà ss ‚Üí ‚àÄ s S, append s (join S) = ss ‚Üí a ‚àà append s (join S) ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)
  intro ss h; apply mem_rec_on h <;> [intro b ss o; intro ss IH] <;> intro s S
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp? at m ‚ä¢ says simp only [cons_append, mem_cons_iff] at m ‚ä¢
    cases' o with e IH
    ¬∑ simp [e]
    cases' m with e m
    ¬∑ simp [e]
    exact Or.imp_left Or.inr (IH _ _ rfl m)
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq.destruct ej <;> simp at this <;>
      subst ss
    ¬∑ apply Or.inr
      simp [-exists_eq_or_imp] at m ‚ä¢
      cases' IH s S rfl m with as ex
      ¬∑ exact ‚ü®s, Or.inl rfl, as‚ü©
      ¬∑ rcases ex with ‚ü®s', sS, as‚ü©
        exact ‚ü®s', Or.inr sS, as‚ü©
    ¬∑ apply Or.inr
      simp? at m says simp only [join_think, nil_append, mem_think] at m
      rcases (IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with ‚ü®s, sS, as‚ü©
      exact ‚ü®s, by simp [sS], as‚ü©
    ¬∑ simp only [think_append, mem_think] at m IH ‚ä¢
      apply IH _ _ rfl m",":= by
  suffices
    ‚àÄ ss : WSeq Œ±,
      a ‚àà ss ‚Üí ‚àÄ s S, append s (join S) = ss ‚Üí a ‚àà append s (join S) ‚Üí a ‚àà s ‚à® ‚àÉ s, s ‚àà S ‚àß a ‚àà s
    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)
  intro ss h; induction' h using mem_rec_on with ss b ss _ IH ss _ IH <;> intro s S
  ¬∑ induction' s using WSeq.recOn with b' s s <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp only [cons_append, mem_cons_iff] at m ‚ä¢
    cases' IH s S rfl m with as ex
      ¬∑ exact ‚ü®s, Or.inl rfl, as‚ü©
      ¬∑ rcases ex with ‚ü®s', sS, as‚ü©
        exact ‚ü®s', Or.inr sS, as‚ü©
    ¬∑ apply Or.inr
      simp? at m says simp only [join_think, nil_append, mem_think] at m
      rcases (IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with ‚ü®s, sS, as‚ü©
      exact ‚ü®s, by simp [sS], as‚ü©
    ¬∑ simp only [think_append, mem_think] at m IH ‚ä¢
      apply IH _ _ rfl m"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpi_tfae,effectiveEpi_tfae,df63b67fb76899941d920b6834b1fea5b3dc0b7c,":= by
  1 ‚Üí 2 := fun _ ‚Ü¶ inferInstance
  2 ‚Üî 3 := epi_iff_surjective œÄ
  3 ‚Üí 1 := fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©","error:  unexpected token; expected '{' or tactic
error:  unsolved goals
B X : Profinite
œÄ : X ‚ü∂ B
‚ä¢ [EffectiveEpi œÄ, Epi œÄ, Function.Surjective ‚áëœÄ].TFAE","theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (œÄ : X ‚ü∂ B) :
    TFAE
    [ EffectiveEpi œÄ
    , Epi œÄ
    , Function.Surjective œÄ
    ] ",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",":= by
  1 ‚Üí 2
  ¬∑ fun _ ‚Ü¶ inferInstance
  2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©"
Mathlib/Topology/Category/TopCat/Limits/Products.lean,TopCat.binaryCofan_isColimit_iff,binaryCofan_isColimit_iff,374f787b0cbfda75985563cc7071d29d50ba6c50,":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine' ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inr, _‚ü©
      erw [Set.range_comp, ‚Üê eq_compl_iff_isCompl, coe_comp, coe_comp, Set.range_comp _ Sum.inr,
        ‚Üê Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
      aesop
    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      have : ‚àÄ x, x ‚àà Set.range c.inl ‚à® x ‚àà Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
        exact fun _ => or_not
      refine' ‚ü®BinaryCofan.IsColimit.mk _ _ _ _ _‚ü©
      ¬∑ intro T f g
        refine' ContinuousMap.mk _ _
        ¬∑ exact fun x =>
            if h : x ‚àà Set.range c.inl then f ((Equiv.ofInjective _ h‚ÇÅ.inj).symm ‚ü®x, h‚ü©)
            else g ((Equiv.ofInjective _ h‚ÇÇ.inj).symm ‚ü®x, (this x).resolve_left h‚ü©)
        rw [continuous_iff_continuousAt]
        intro x
        by_cases h : x ‚àà Set.range c.inl
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            convert_to Continuous (f ‚àò (Homeomorph.ofEmbedding _ h‚ÇÅ.toEmbedding).symm)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_pos hx
            apply Continuous.comp
            ¬∑ exact f.continuous_toFun
            ¬∑ continuity
          ¬∑ exact h‚ÇÅ.isOpen_range
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            have : ‚àÄ a, a ‚àâ Set.range c.inl ‚Üí a ‚àà Set.range c.inr := by
              rintro a (h : a ‚àà (Set.range c.inl)·∂ú)
              rwa [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            convert_to Continuous
                (g ‚àò (Homeomorph.ofEmbedding _ h‚ÇÇ.toEmbedding).symm ‚àò Subtype.map _ this)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_neg hx
            apply Continuous.comp
            ¬∑ exact g.continuous_toFun
            ¬∑ apply Continuous.comp
              ¬∑ continuity
              ¬∑ rw [embedding_subtype_val.toInducing.continuous_iff]
                exact continuous_subtype_val
          ¬∑ change IsOpen (Set.range c.inl)·∂ú
            rw [‚Üê eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            exact h‚ÇÇ.isOpen_range
      ¬∑ intro T f g
        ext x
        refine' (dif_pos _).trans _
        ¬∑ exact ‚ü®x, rfl‚ü©
        ¬∑ dsimp; conv_lhs => erw [Equiv.ofInjective_symm_apply]
      ¬∑ intro T f g
        ext x
        refine' (dif_neg _).trans _
        ¬∑ rintro ‚ü®y, e‚ü©
          have : c.inr x ‚àà Set.range c.inl ‚äì Set.range c.inr := ‚ü®‚ü®_, e‚ü©, ‚ü®_, rfl‚ü©‚ü©
          rwa [disjoint_iff.mp h‚ÇÉ.1] at this
        ¬∑ exact congr_arg g (Equiv.ofInjective_symm_apply _ _)
      ¬∑ rintro T _ _ m rfl rfl
        ext x
        change m x = dite _ _ _
        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ‚ü®_, _‚ü©).symm","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚áë(?f ‚â´ ?g)
case mp.intro
J : Type v
inst‚úù : SmallCategory J
X Y : TopCat
c : BinaryCofan X Y
h : IsColimit c
‚ä¢ ‚áë(h.coconePointUniqueUpToIso (X.binaryCofanIsColimit Y)).inv '' Set.range ‚áë(X.binaryCofan Y).inl =
    (Set.range (‚áë(h.coconePointUniqueUpToIso (X.binaryCofanIsColimit Y)).inv ‚àò ‚áë(X.binaryCofan Y).inr))·∂ú
error:  unsolved goals
case mpr.intro.intro.refine'_2.w.refine'_2
J : Type v
inst‚úù : SmallCategory J
X Y : TopCat
c : BinaryCofan X Y
h‚ÇÅ : OpenEmbedding ‚áëc.inl
h‚ÇÇ : OpenEmbedding ‚áëc.inr
h‚ÇÉ : IsCompl (Set.range ‚áëc.inl) (Set.range ‚áëc.inr)
this :
  ‚àÄ (x : ‚Üë(((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := WalkingPair.left })),
    x ‚àà Set.range ‚áëc.inl ‚à® x ‚àà Set.range ‚áëc.inr
T : TopCat
f : X ‚ü∂ T
g : Y ‚ü∂ T
x : (forget TopCat).obj ((pair X Y).obj { as := WalkingPair.left })
‚ä¢ f x = f x","theorem binaryCofan_isColimit_iff {X Y : TopCat} (c : BinaryCofan X Y) :
    Nonempty (IsColimit c) ‚Üî
      OpenEmbedding c.inl ‚àß OpenEmbedding c.inr ‚àß IsCompl (Set.range c.inl) (Set.range c.inr) ",":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inr, ?_‚ü©
      erw [Set.range_comp, ‚Üê eq_compl_iff_isCompl, Set.range_comp _ Sum.inr,
        ‚Üê Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      have : ‚àÄ x, x ‚àà Set.range c.inl ‚à® x ‚àà Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
        exact fun _ => or_not
      refine ‚ü®BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_‚ü©
      ¬∑ intro T f g
        refine ContinuousMap.mk ?_ ?_
        ¬∑ exact fun x =>
            if h : x ‚àà Set.range c.inl then f ((Equiv.ofInjective _ h‚ÇÅ.inj).symm ‚ü®x, h‚ü©)
            else g ((Equiv.ofInjective _ h‚ÇÇ.inj).symm ‚ü®x, (this x).resolve_left h‚ü©)
        rw [continuous_iff_continuousAt]
        intro x
        by_cases h : x ‚àà Set.range c.inl
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            convert_to Continuous (f ‚àò (Homeomorph.ofEmbedding _ h‚ÇÅ.toEmbedding).symm)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_pos hx
            apply Continuous.comp
            ¬∑ exact f.continuous_toFun
            ¬∑ continuity
          ¬∑ exact h‚ÇÅ.isOpen_range
        ¬∑ revert h x
          apply (IsOpen.continuousOn_iff _).mp
          ¬∑ rw [continuousOn_iff_continuous_restrict]
            have : ‚àÄ a, a ‚àâ Set.range c.inl ‚Üí a ‚àà Set.range c.inr := by
              rintro a (h : a ‚àà (Set.range c.inl)·∂ú)
              rwa [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            convert_to Continuous
                (g ‚àò (Homeomorph.ofEmbedding _ h‚ÇÇ.toEmbedding).symm ‚àò Subtype.map _ this)
            ¬∑ ext ‚ü®x, hx‚ü©
              exact dif_neg hx
            apply Continuous.comp
            ¬∑ exact g.continuous_toFun
            ¬∑ apply Continuous.comp
              ¬∑ continuity
              ¬∑ rw [embedding_subtype_val.toInducing.continuous_iff]
                exact continuous_subtype_val
          ¬∑ change IsOpen (Set.range c.inl)·∂ú
            rw [‚Üê eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
            exact h‚ÇÇ.isOpen_range
      ¬∑ intro T f g
        ext x
        refine (dif_pos ?_).trans ?_
        ¬∑ exact ‚ü®x, rfl‚ü©
        ¬∑ dsimp
          conv_lhs => erw [Equiv.ofInjective_symm_apply]
          rfl 
      ¬∑ intro T f g
        ext x
        refine (dif_neg ?_).trans ?_
        ¬∑ rintro ‚ü®y, e‚ü©
          have : c.inr x ‚àà Set.range c.inl ‚äì Set.range c.inr := ‚ü®‚ü®_, e‚ü©, ‚ü®_, rfl‚ü©‚ü©
          rwa [disjoint_iff.mp h‚ÇÉ.1] at this
        ¬∑ exact congr_arg g (Equiv.ofInjective_symm_apply _ _)
      ¬∑ rintro T _ _ m rfl rfl
        ext x
        change m x = dite _ _ _
        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ‚ü®_, _‚ü©).symm",":= by
  classical
    constructor
    ¬∑ rintro ‚ü®h‚ü©
      rw [‚Üê show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.left‚ü©,
        ‚Üê show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ‚ü®WalkingPair.right‚ü©]
      dsimp
      refine ‚ü®(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
           (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
      aesop
    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      have : ‚àÄ x, x ‚àà Set.range c.inl ‚à® x ‚àà Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr h‚ÇÉ.symm]
        exact fun _ => or_not
      refine ‚ü®BinaryCofan.IsColimit.mk _ _ _ _ ?_‚ü©
      ¬∑ intro T f g
        refine ContinuousMap.mk ?_ ?_
        ¬∑ exact fun x =>
            if h : x ‚àà Set.range c.inl then f ((Equiv.ofInjective _ h‚ÇÅ.inj).symm ‚ü®x, h‚ü©)
            else g ((Equiv.ofInjective _ h‚ÇÇ.inj).symm ‚ü®x, (this x).resolve_left h‚ü©)
        rw [continuous_iff_continuousAt]
        intro x
        by_case"
Mathlib/MeasureTheory/Measure/VectorMeasure.lean,MeasureTheory.VectorMeasure.MutuallySingular.add_left,add_left,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  obtain ‚ü®u, hmu, hu‚ÇÅ, hu‚ÇÇ‚ü© := h‚ÇÅ
  obtain ‚ü®v, hmv, hv‚ÇÅ, hv‚ÇÇ‚ü© := h‚ÇÇ
  refine mk (u ‚à© v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_
  ¬∑ rw [add_apply, hu‚ÇÅ _ (Set.subset_inter_iff.1 ht).1, hv‚ÇÅ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  ¬∑ rw [Set.compl_inter] at ht
    rw [(_ : t = u·∂ú ‚à© t ‚à™ v·∂ú \ u·∂ú ‚à© t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), hu‚ÇÇ, hv‚ÇÇ, add_zero]
    ¬∑ exact Set.Subset.trans (Set.inter_subset_left _ _) (Set.diff_subset _ _)
    ¬∑ exact Set.inter_subset_left _ _
    ¬∑ exact disjoint_sdiff_self_right.mono (Set.inter_subset_left _ _) (Set.inter_subset_left _ _)
    ¬∑ apply Set.Subset.antisymm <;> intro x hx
      ¬∑ by_cases hxu' : x ‚àà u·∂ú
        ¬∑ exact Or.inl ‚ü®hxu', hx‚ü©
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr ‚ü®‚ü®hxv, hxu'‚ü©, hx‚ü©]
      ¬∑ cases' hx with hx hx <;> exact hx.2","warning:  @VectorMeasure.AbsolutelyContinuous does not have a doc string
warning:  @VectorMeasure.MutuallySingular does not have a doc string
error:  function expected at
  inter_subset_left ?m.336041
term has type
  ?m.336040 ‚àà ?m.336038
error:  function expected at
  diff_subset ?m.336083
term has type
  ?m.336082 ‚àà ?m.336080
error:  function expected at
  inter_subset_left ?m.336125
term has type
  ?m.336124 ‚àà ?m.336122
error:  function expected at
  inter_subset_left ?m.336366
term has type
  ?m.336365 ‚àà ?m.336363
error:  function expected at
  inter_subset_left ?m.336418
term has type
  ?m.336417 ‚àà ?m.336415",theorem add_left [T2Space N] [ContinuousAdd M] (h‚ÇÅ : v‚ÇÅ ‚üÇ·µ• w) (h‚ÇÇ : v‚ÇÇ ‚üÇ·µ• w) : v‚ÇÅ + v‚ÇÇ ‚üÇ·µ• w ,":= by
  obtain ‚ü®u, hmu, hu‚ÇÅ, hu‚ÇÇ‚ü© := h‚ÇÅ
  obtain ‚ü®v, hmv, hv‚ÇÅ, hv‚ÇÇ‚ü© := h‚ÇÇ
  refine mk (u ‚à© v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_
  ¬∑ rw [add_apply, hu‚ÇÅ _ (Set.subset_inter_iff.1 ht).1, hv‚ÇÅ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  ¬∑ rw [Set.compl_inter] at ht
    rw [(_ : t = u·∂ú ‚à© t ‚à™ v·∂ú \ u·∂ú ‚à© t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), hu‚ÇÇ, hv‚ÇÇ, add_zero]
    ¬∑ exact Set.Subset.trans Set.inter_subset_left diff_subset
    ¬∑ exact Set.inter_subset_left
    ¬∑ exact disjoint_sdiff_self_right.mono Set.inter_subset_left Set.inter_subset_left
    ¬∑ apply Set.Subset.antisymm <;> intro x hx
      ¬∑ by_cases hxu' : x ‚àà u·∂ú
        ¬∑ exact Or.inl ‚ü®hxu', hx‚ü©
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr ‚ü®‚ü®hxv, hxu'‚ü©, hx‚ü©]
      ¬∑ cases' hx with hx hx <;> exact hx.2",":= by
  obtain ‚ü®u, hmu, hu‚ÇÅ, hu‚ÇÇ‚ü© := h‚ÇÅ
  obtain ‚ü®v, hmv, hv‚ÇÅ, hv‚ÇÇ‚ü© := h‚ÇÇ
  refine mk (u ‚à© v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_
  ¬∑ rw [add_apply, hu‚ÇÅ _ (Set.subset_inter_iff.1 ht).1, hv‚ÇÅ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  ¬∑ rw [Set.compl_inter] at ht
    rw [(_ : t = u·∂ú ‚à© t ‚à™ v·∂ú \ u·∂ú ‚à© t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), hu‚ÇÇ, hv‚ÇÇ, add_zero]
    ¬∑ exact Set.Subset.trans Set.inter_subset_left Set.diff_subset
    ¬∑ exact Set.inter_subset_left
    ¬∑ exact disjoint_sdiff_self_right.mono Set.inter_subset_left Set.inter_subset_left
    ¬∑ apply Set.Subset.antisymm <;> intro x hx
      ¬∑ by_cases hxu' : x ‚àà u·∂ú
        ¬∑ exact Or.inl ‚ü®hxu', hx‚ü©
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr ‚ü®‚ü®hxv, hxu'‚ü©, hx‚ü©]
      ¬∑ cases' hx with hx hx <;> exact hx.2"
Mathlib/Analysis/InnerProductSpace/Projection.lean,norm_eq_iInf_iff_real_inner_le_zero,norm_eq_iInf_iff_real_inner_le_zero,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel'_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            exact this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num [Œ∏])
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine' le_add_of_nonneg_right _
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _","warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
error:  type mismatch
  div_mul_cancel p ?m.225193
has type
  p / ?m.225193 * ?m.225193 = p : Prop
but is expected to have type
  p / q * q = p : Prop","theorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ‚Ñù K) {u : F} {v : F}
    (hv : v ‚àà K) : (‚Äñu - v‚Äñ = ‚®Ö w : K, ‚Äñu - w‚Äñ) ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0 ",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel‚ÇÄ _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            exact this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num [Œ∏])
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine le_add_of_nonneg_right ?_
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
         _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
           simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
             rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
             rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                   absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicAt.order_eq_int_iff,order_eq_int_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_natCast, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_natCast, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚ä§ - ‚Üë?m.79514
case pos
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí E
x : ùïú
hf : MeromorphicAt f x
n : ‚Ñ§
h : ‚ãØ.order = ‚ä§
‚ä¢ ‚ä§ - ‚Üë‚Üë(Exists.choose hf) = ‚Üën ‚Üî ‚àÉ g, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë?m.80098 - ‚Üë?m.80099
case neg.intro
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí E
x : ùïú
hf : MeromorphicAt f x
n : ‚Ñ§
h‚úù : ¬¨‚ãØ.order = ‚ä§
m : ‚Ñï
h : ‚Üëm = ‚ãØ.order
‚ä¢ ‚Üë‚Üëm - ‚Üë‚Üë(Exists.choose hf) = ‚Üën ‚Üî ‚àÉ g, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z","lemma order_eq_int_iff {f : ùïú ‚Üí E} {x : ùïú} (hf : MeromorphicAt f x) (n : ‚Ñ§) : hf.order = n ‚Üî
    ‚àÉ g : ùïú ‚Üí E, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z ",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_natCast, ‚Üê coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_natCast, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_natCast, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©"
Mathlib/RingTheory/RootsOfUnity/Basic.lean,IsPrimitiveRoot.nthRoots_one_eq_biUnion_primitiveRoots,nthRoots_one_eq_biUnion_primitiveRoots,7d3d6e43b685327db5942f774dfd160e0a94f15f,":= by
  symm
  apply Finset.eq_of_subset_of_card_le
  ¬∑ intro x
    simp only [nthRootsFinset, ‚Üê Multiset.toFinset_eq (nthRoots_nodup h), exists_prop,
      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,
      Nat.mem_divisors, and_true_iff, Ne.def, PNat.ne_zero, PNat.pos, not_false_iff]
    rintro ‚ü®a, ‚ü®d, hd‚ü©, ha‚ü©
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, zero_mul]
      exact n.ne_zero
    rw [mem_primitiveRoots hazero] at ha
    rw [hd, pow_mul, ha.pow_eq_one, one_pow]
  ¬∑ apply le_of_eq
    rw [h.card_nthRootsFinset, Finset.card_biUnion]
    ¬∑ nth_rw 1 [‚Üê Nat.sum_totient n]
      refine' sum_congr rfl _
      simp only [Nat.mem_divisors]
      rintro k ‚ü®‚ü®d, hd‚ü©, -‚ü©
      rw [mul_comm] at hd
      rw [(h.pow n.pos hd).card_primitiveRoots]
    ¬∑ intro i _ j _ hdiff
      exact disjoint hdiff","error:  application type mismatch
  Multiset.toFinset_eq (nthRoots_nodup h)
argument
  nthRoots_nodup h
has type
  ?m.275951 ‚â† 0 ‚Üí (nthRoots ‚Üën ?m.275951).Nodup : Prop
but is expected to have type
  ?m.275934.Nodup : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.276404 ‚Üí ?m.276404 ‚Üí Prop
error:  type mismatch
  PNat.ne_zero n
has type
  ‚Üën ‚â† 0 : Prop
but is expected to have type
  ‚Üën = 0 : Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  False
case h.intro.intro.intro
M : Type u_1
N : Type u_2
G : Type u_3
R : Type u_4
S : Type u_5
F : Type u_6
inst‚úù‚Å¥ : CommMonoid M
inst‚úù¬≥ : CommMonoid N
inst‚úù¬≤ : DivisionCommMonoid G
k l : ‚Ñï
inst‚úù¬π : CommRing R
Œ∂‚úù : RÀ£
h‚úù : IsPrimitiveRoot Œ∂‚úù k
inst‚úù : IsDomain R
Œ∂ : R
n : ‚Ñï+
h : IsPrimitiveRoot Œ∂ ‚Üën
x : R
a : ‚Ñï
ha : IsPrimitiveRoot x a
d : a ‚à£ ‚Üën
hd : ‚Üën ‚â† 0
hazero : 0 < a
‚ä¢ x ‚àà (nthRoots (‚Üën) 1).toFinset","theorem nthRoots_one_eq_biUnion_primitiveRoots' {Œ∂ : R} {n : ‚Ñï+} (h : IsPrimitiveRoot Œ∂ n) :
    nthRootsFinset n R = (Nat.divisors ‚Üën).biUnion fun i => primitiveRoots i R ",":= by
  symm
  apply Finset.eq_of_subset_of_card_le
  ¬∑ intro x
    simp only [nthRootsFinset, ‚Üê Multiset.toFinset_eq (nthRoots_one_nodup h), exists_prop,
      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,
      Nat.mem_divisors, and_true_iff, Ne, PNat.ne_zero, PNat.pos, not_false_iff]
    rintro ‚ü®a, ‚ü®d, hd‚ü©, ha‚ü©
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, zero_mul]
      exact n.ne_zero
    rw [mem_primitiveRoots hazero] at ha
    rw [hd, pow_mul, ha.pow_eq_one, one_pow]
  ¬∑ apply le_of_eq
    rw [h.card_nthRootsFinset, Finset.card_biUnion]
    ¬∑ nth_rw 1 [‚Üê Nat.sum_totient n]
      refine sum_congr rfl ?_
      simp only [Nat.mem_divisors]
      rintro k ‚ü®‚ü®d, hd‚ü©, -‚ü©
      rw [mul_comm] at hd
      rw [(h.pow n.pos hd).card_primitiveRoots]
    ¬∑ intro i _ j _ hdiff
      exact disjoint hdiff",":= by
  symm
  apply Finset.eq_of_subset_of_card_le
  ¬∑ intro x
    simp only [nthRootsFinset, ‚Üê Multiset.toFinset_eq (nthRoots_nodup h), exists_prop,
      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,
      Nat.mem_divisors, and_true_iff, Ne, PNat.ne_zero, PNat.pos, not_false_iff]
    rintro ‚ü®a, ‚ü®d, hd‚ü©, ha‚ü©
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, zero_mul]
      exact n.ne_zero
    rw [mem_primitiveRoots hazero] at ha
    rw [hd, pow_mul, ha.pow_eq_one, one_pow]
  ¬∑ apply le_of_eq
    rw [h.card_nthRootsFinset, Finset.card_biUnion]
    ¬∑ nth_rw 1 [‚Üê Nat.sum_totient n]
      refine sum_congr rfl ?_
      simp only [Nat.mem_divisors]
      rintro k ‚ü®‚ü®d, hd‚ü©, -‚ü©
      rw [mul_comm] at hd
      rw [(h.pow n.pos hd).card_primitiveRoots]
    ¬∑ intro i _ j _ hdiff
      exact disjoint hdiff"
Mathlib/Analysis/Calculus/LocalExtr/Polynomial.lean,Polynomial.card_roots_le_derivative,card_roots_le_derivative,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":=
  calc
    Multiset.card p.roots = ‚àë x in p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x in p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x in p.roots.toFinset, (p.rootMultiplicity x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x in p.roots.toFinset, p.derivative.rootMultiplicity x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x in p.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x in p.derivative.roots.toFinset \ p.roots.toFinset,
            p.derivative.roots.count x) + 1) := by
      simp only [‚Üê count_roots]
      refine' add_le_add_left (add_le_add_right ((Finset.card_eq_sum_ones _).trans_le _) _) _
      refine Finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| ?_
      rw [Multiset.count_pos, ‚Üê Multiset.mem_toFinset]
      exact (Finset.mem_sdiff.1 hx).1
    _ = Multiset.card (derivative p).roots + 1 := by
      rw [‚Üê add_assoc, ‚Üê Finset.sum_union Finset.disjoint_sdiff, Finset.union_sdiff_self_eq_union, ‚Üê
        Multiset.toFinset_sum_count_eq, ‚Üê Finset.sum_subset (Finset.subset_union_right _ _)]
      intro x _ hx‚ÇÇ
      simpa only [Multiset.mem_toFinset, Multiset.count_eq_zero] using hx‚ÇÇ","error:  function expected at
  Finset.subset_union_right ?m.14170
term has type
  ?m.14169 ‚àà ?m.14167 ‚à™ ?m.14168","theorem card_roots_le_derivative (p : ‚Ñù[X]) :
    Multiset.card p.roots ‚â§ Multiset.card (derivative p).roots + 1 ",":=
  calc
    Multiset.card p.roots = ‚àë x ‚àà p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.rootMultiplicity x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.rootMultiplicity x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x ‚àà p.derivative.roots.toFinset \ p.roots.toFinset,
            p.derivative.roots.count x) + 1) := by
      simp only [‚Üê count_roots]
      refine add_le_add_left (add_le_add_right ((Finset.card_eq_sum_ones _).trans_le ?_) _) _
      refine Finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| ?_
      rw [Multiset.count_pos, ‚Üê Multiset.mem_toFinset]
      exact (Finset.mem_sdiff.1 hx).1
    _ = Multiset.card (derivative p).roots + 1 := by
      rw [‚Üê add_assoc, ‚Üê Finset.sum_union Finset.disjoint_sdiff, Finset.union_sdiff_self_eq_union, ‚Üê
        Multiset.toFinset_sum_count_eq, ‚Üê Finset.sum_subset Finset.subset_union_right]
      intro x _ hx‚ÇÇ
      simpa only [Multiset.mem_toFinset, Multiset.count_eq_zero] using hx‚ÇÇ",":=
  calc
    Multiset.card p.roots = ‚àë x ‚àà p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x ‚àà p.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x ‚àà p.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.c"
Mathlib/Data/Set/Card.lean,Set.exists_superset_subset_encard_eq,exists_superset_subset_encard_eq,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain (hs | hs) := eq_or_ne s.encard ‚ä§
  ¬∑ rw [hs, top_le_iff] at hsk; subst hsk; exact ‚ü®s, Subset.rfl, hst, hs‚ü©
  obtain ‚ü®k, rfl‚ü© := exists_add_of_le hsk
  obtain ‚ü®k', hk'‚ü© := exists_add_of_le hkt
  have hk : k ‚â§ encard (t \ s) := by
    rw [‚Üê encard_diff_add_encard_of_subset hst, add_comm] at hkt
    exact WithTop.le_of_add_le_add_right hs hkt
  obtain ‚ü®r', hr', rfl‚ü© := exists_subset_encard_eq hk
  refine ‚ü®s ‚à™ r', subset_union_left _ _, union_subset hst (hr'.trans (diff_subset _ _)), ?_‚ü©
  rw [encard_union_eq (disjoint_of_subset_right hr' disjoint_sdiff_right)]","error:  function expected at
  subset_union_left ?m.99161
term has type
  ?m.99160 ‚àà ?m.99158 ‚à™ ?m.99159
error:  function expected at
  diff_subset ?m.99262
term has type
  ?m.99261 ‚àà ?m.99259","theorem exists_superset_subset_encard_eq {k : ‚Ñï‚àû}
    (hst : s ‚äÜ t) (hsk : s.encard ‚â§ k) (hkt : k ‚â§ t.encard) :
    ‚àÉ r, s ‚äÜ r ‚àß r ‚äÜ t ‚àß r.encard = k ",":= by
  obtain (hs | hs) := eq_or_ne s.encard ‚ä§
  ¬∑ rw [hs, top_le_iff] at hsk; subst hsk; exact ‚ü®s, Subset.rfl, hst, hs‚ü©
  obtain ‚ü®k, rfl‚ü© := exists_add_of_le hsk
  obtain ‚ü®k', hk'‚ü© := exists_add_of_le hkt
  have hk : k ‚â§ encard (t \ s) := by
    rw [‚Üê encard_diff_add_encard_of_subset hst, add_comm] at hkt
    exact WithTop.le_of_add_le_add_right hs hkt
  obtain ‚ü®r', hr', rfl‚ü© := exists_subset_encard_eq hk
  refine ‚ü®s ‚à™ r', subset_union_left, union_subset hst (hr'.trans diff_subset), ?_‚ü©
  rw [encard_union_eq (disjoint_of_subset_right hr' disjoint_sdiff_right)]",":= by
  obtain (hs | hs) := eq_or_ne s.encard ‚ä§
  ¬∑ rw [hs, top_le_iff] at hsk; subst hsk; exact ‚ü®s, Subset.rfl, hst, hs‚ü©
  obtain ‚ü®k, rfl‚ü© := exists_add_of_le hsk
  obtain ‚ü®k', hk'‚ü© := exists_add_of_le hkt
  have hk : k ‚â§ encard (t \ s) := by
    rw [‚Üê encard_diff_add_encard_of_subset hst, add_comm] at hkt
    exact WithTop.le_of_add_le_add_right hs hkt
  obtain ‚ü®r', hr', rfl‚ü© := exists_subset_encard_eq hk
  refine ‚ü®s ‚à™ r', subset_union_left, union_subset hst (hr'.trans diff_subset), ?_‚ü©
  rw [encard_union_eq (disjoint_of_subset_right hr' disjoint_sdiff_right)]"
Mathlib/Data/DFinsupp/Basic.lean,DFinsupp.prod_add_index,prod_add_index,ea1b2576466eb49ae109b64acf312f52285dafce,":=
  have f_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (f i)) = f.prod h :=
    (Finset.prod_subset (Finset.subset_union_left _ _) <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (g i)) = g.prod h :=
    (Finset.prod_subset (Finset.subset_union_right _ _) <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  calc
    (‚àè i ‚àà (f + g).support, h i ((f + g) i)) = ‚àè i ‚àà f.support ‚à™ g.support, h i ((f + g) i) :=
      Finset.prod_subset support_add <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]
    _ = (‚àè i ‚àà f.support ‚à™ g.support, h i (f i)) * ‚àè i ‚àà f.support ‚à™ g.support, h i (g i) := by
      { simp [h_add, Finset.prod_mul_distrib] }
    _ = _ := by rw [f_eq, g_eq]","error:  function expected at
  Finset.subset_union_left ?m.703129
term has type
  ?m.703128 ‚àà ?m.703126 ‚à™ ?m.703127
error:  function expected at
  Finset.subset_union_right ?m.703451
term has type
  ?m.703450 ‚àà ?m.703448 ‚à™ ?m.703449","theorem prod_add_index [‚àÄ i, AddCommMonoid (Œ≤ i)] [‚àÄ (i) (x : Œ≤ i), Decidable (x ‚â† 0)]
    [CommMonoid Œ≥] {f g : Œ†‚ÇÄ i, Œ≤ i} {h : ‚àÄ i, Œ≤ i ‚Üí Œ≥} (h_zero : ‚àÄ i, h i 0 = 1)
    (h_add : ‚àÄ i b‚ÇÅ b‚ÇÇ, h i (b‚ÇÅ + b‚ÇÇ) = h i b‚ÇÅ * h i b‚ÇÇ) : (f + g).prod h = f.prod h * g.prod h ",":=
  have f_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (f i)) = f.prod h :=
    (Finset.prod_subset Finset.subset_union_left <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (g i)) = g.prod h :=
    (Finset.prod_subset Finset.subset_union_right <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  calc
    (‚àè i ‚àà (f + g).support, h i ((f + g) i)) = ‚àè i ‚àà f.support ‚à™ g.support, h i ((f + g) i) :=
      Finset.prod_subset support_add <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]
    _ = (‚àè i ‚àà f.support ‚à™ g.support, h i (f i)) * ‚àè i ‚àà f.support ‚à™ g.support, h i (g i) := by
      { simp [h_add, Finset.prod_mul_distrib] }
    _ = _ := by rw [f_eq, g_eq]",":=
  have f_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (f i)) = f.prod h :=
    (Finset.prod_subset (Finset.subset_union_right <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (g i)) = g.prod h :=
    (Finset.prod_subset (Finset.subset_union_right <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (g i)) = g.prod h :=
    (Finset.prod_subset (Finset.subset_union_right <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (g i)) = g.prod h :=
    (Finset.prod_subset (Finset.subset_union_right <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  calc
    (‚àè i ‚àà (f + g).support, h i ((f + g) i)) = ‚àè i ‚àà f.support ‚à™ g.support, h i (g i) := by
      { simp [h_add, Finset.prod_mul_distrib] }
    _ = _ := by rw [f_eq, g_eq]"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,5f92bfec6d6c4ec4639d991dbedc7d9dbbbd4162,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 ‚Üí ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 ‚Üí ?m.124403
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/Topology/Metrizable/Urysohn.lean,TopologicalSpace.exists_inducing_l_infty,exists_inducing_l_infty,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono (inter_subset_left _ _)).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine' ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, _‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine' ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm _ _‚ü©
  ¬∑ refine' (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => _
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine' (eventually_all_finite h_fin).2 fun UV _ => _
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine' this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => _
    cases' le_total Œ¥ (Œµ UV) with hle hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine' ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 _
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine' ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => _‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV
    exact (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _","error:  unexpected identifier; expected '|'
error:  unsolved goals
case intro.intro.refine'_2.intro.intro.intro.intro
X : Type u_1
inst‚úù¬≤ : TopologicalSpace X
inst‚úù¬π : RegularSpace X
inst‚úù : SecondCountableTopology X
B : Set (Set X)
hBc : B.Countable
hB : IsTopologicalBasis B
s : Set (Set X √ó Set X) := {UV | UV ‚àà B √óÀ¢ B ‚àß closure UV.1 ‚äÜ UV.2}
this‚úù¬π : Encodable ‚Üës
this‚úù : TopologicalSpace ‚Üës := ‚ä•
this : DiscreteTopology ‚Üës
hd : ‚àÄ (UV : ‚Üës), Disjoint (closure (‚ÜëUV).1) (‚ÜëUV).2·∂ú
Œµ : ‚Üës ‚Üí ‚Ñù
Œµ01 : ‚àÄ (UV : ‚Üës), Œµ UV ‚àà Ioc 0 1
hŒµ : Tendsto Œµ cofinite (ùìù 0)
f : ‚Üës ‚Üí C(X, ‚Ñù)
hf0 : ‚àÄ (UV : ‚Üës), EqOn (‚áë(f UV)) 0 (‚ÜëUV).1
hfŒµ : ‚àÄ (UV : ‚Üës), EqOn (‚áë(f UV)) (fun x ‚Ü¶ Œµ UV) (‚ÜëUV).2·∂ú
hf0Œµ : ‚àÄ (UV : ‚Üës) (x : X), (f UV) x ‚àà Icc 0 (Œµ UV)
hf01 : ‚àÄ (UV : ‚Üës) (x : X), (f UV) x ‚àà Icc 0 1
F : X ‚Üí ‚Üës ‚Üí·µá ‚Ñù := fun x ‚Ü¶ { toFun := fun UV ‚Ü¶ (f UV) x, continuous_toFun := ‚ãØ, map_bounded' := ‚ãØ }
hF : ‚àÄ (x : X) (UV : ‚Üës), (F x) UV = (f UV) x
x : X
V : Set X
hVB : V ‚àà B
hxV : x ‚àà V
U : Set X
hUB : U ‚àà B
hxU : x ‚àà U
hUV : closure U ‚äÜ V
UV : ‚Üës := ‚ü®(U, V), ‚ãØ‚ü©
y : X
hy : dist ((F y) UV) ((F x) UV) < Œµ UV
‚ä¢ y ‚àà V","theorem exists_inducing_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Inducing f ",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => ?_
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => ?_‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.isometry_extend (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV"
Mathlib/NumberTheory/Modular.lean,ModularGroup.tendsto_normSq_coprime_pair,tendsto_normSq_coprime_pair,22e97510854d6906cc856e022d297bf9cf8c9b3a,":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, ofReal_mul_im, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * 1
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
x‚úù : Fin 2 ‚Üí ‚Ñù
‚ä¢ f x‚úù = ‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)
error:  unknown identifier 'ofReal_int_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.22014
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
f_def : ‚áëf = fun p ‚Ü¶ ‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)
x‚úù : Fin 2 ‚Üí ‚Ñ§
‚ä¢ normSq (‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)) = normSq (‚Üë‚Üë(x‚úù 0) * ‚Üëz + ‚Üë‚Üë(x‚úù 1))
error:  unknown identifier 'ofReal_mul_im'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.33650
case h.h.head
g‚úù : SL(2, ‚Ñ§)
z : ‚Ñç
this‚úù : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
f_def : ‚áëf = fun p ‚Ü¶ ‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)
this : (fun p ‚Ü¶ normSq (‚Üë(p 0) * ‚Üëz + ‚Üë(p 1))) = ‚áënormSq ‚àò ‚áëf ‚àò fun p ‚Ü¶ Int.cast ‚àò p
g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù := LinearMap.pi ![imLm, imLm ‚àò‚Çó (‚Üëz ‚Ä¢ (‚Üë‚ÜëconjAe).toLinearMap)]
c : Fin 2 ‚Üí ‚Ñù
hz : (‚Üëz).im ‚â† 0
‚ä¢ (‚Üëz).im‚Åª¬π * ((‚Üë(c 0) * ‚Üëz).im + (‚Üë(c 1)).im) = c 0
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem tendsto_normSq_coprime_pair :
    Filter.Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * z + p 1)) cofinite atTop ",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_intCast, ofReal_intCast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, ofReal_mul_im, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)"
Mathlib/SetTheory/Cardinal/Basic.lean,Cardinal.mk_set_le,mk_set_le,ef3c9bcd07782b044027916a64e925f3e4951707,":=
  mk_subtype_le s.toPred","warning:  mk does not have a doc string
error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  s
has type
  Set Œ±
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  s
has type
  Œ± ‚Üí Prop
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Cardinal.power_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  aleph0 does not have a doc string
warning:  powerlt does not have a doc string",theorem mk_set_le (s : Set Œ±) : #s ‚â§ #Œ± ,":=
  mk_subtype_le s",:= mk_subtype_le s
Mathlib/NumberTheory/NumberField/Embeddings.lean,NumberField.Embeddings.pow_eq_one_of_norm_eq_one,pow_eq_one_of_norm_eq_one,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ ((¬∑ ^ ¬∑) x : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  ¬∑ wlog hlt : b < a
    ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
    refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
    dsimp at h 
    rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
    refine h.resolve_right fun hp => ?_
    specialize hx (IsAlgClosed.lift (NumberField.isAlgebraic K)).toRingHom
    rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsAlgClosed.lift ?m.50198
has type
  ?m.49380
error:  application type mismatch
  IsAlgClosed.lift ‚ãØ
argument
  NumberField.isAlgebraic K
has type
  Algebra.IsAlgebraic ‚Ñö K : Prop
but is expected to have type
  ?m.49385 : Type ?u.49377","theorem pow_eq_one_of_norm_eq_one {x : K} (hxi : IsIntegral ‚Ñ§ x) (hx : ‚àÄ œÜ : K ‚Üí+* A, ‚ÄñœÜ x‚Äñ = 1) :
    ‚àÉ (n : ‚Ñï) (_ : 0 < n), x ^ n = 1 ",":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ ¬∑ : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  wlog hlt : b < a
  ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
  refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
  rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
  refine h.resolve_right fun hp => ?_
  specialize hx (IsAlgClosed.lift (R := ‚Ñö)).toRingHom
  rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx",":= by
  obtain ‚ü®a, -, b, -, habne, h‚ü© :=
    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ ((¬∑ ^ ¬∑) x : ‚Ñï ‚Üí K) Set.infinite_univ
      (by exact fun a _ => ‚ü®hxi.pow a, fun œÜ => by simp [hx œÜ]‚ü©) (finite_of_norm_le K A (1 : ‚Ñù))
  ¬∑ wlog hlt : b < a
    ¬∑ exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)
    refine ‚ü®a - b, tsub_pos_of_lt hlt, ?_‚ü©
    dsimp at h 
    rw [‚Üê Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self‚ÇÄ] at h
    refine h.resolve_right fun hp => ?_
    specialize hx (IsAlgClosed.lift (NumberField.isAlgebraic K)).toRingHom
    rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx"
Mathlib/RingTheory/NonUnitalSubring/Basic.lean,NonUnitalSubring.mem_iSup_of_directed,mem_iSup_of_directed,a37e82f3616d798c1103557af7187357fc3e9e42,":= by
  refine' ‚ü®_, fun ‚ü®i, hi‚ü© => (SetLike.le_def.1 <| le_iSup S i) hi‚ü©
  let U : NonUnitalSubring R :=
    NonUnitalSubring.mk' (‚ãÉ i, (S i : Set R)) (‚®Ü i, (S i).toSubsemigroup) (‚®Ü i, (S i).toAddSubgroup)
      (Subsemigroup.coe_iSup_of_directed <| hS.mono_comp _ fun _ _ => id)
      (AddSubgroup.coe_iSup_of_directed <| hS.mono_comp _ fun _ _ => id)
  suffices (‚®Ü i, S i) ‚â§ U by simpa using @this x
  exact iSup_le fun i x hx => Set.mem_iUnion.2 ‚ü®i, hx‚ü©","error:  type mismatch
  h‚úù
has type
  x ‚àà ‚®Ü i, S i ‚Üí x ‚àà U : Prop
but is expected to have type
  x ‚àà ‚®Ü i, S i ‚Üí ‚àÉ i, x ‚àà S i : Prop","theorem mem_iSup_of_directed {Œπ} [hŒπ : Nonempty Œπ] {S : Œπ ‚Üí NonUnitalSubring R}
    (hS : Directed (¬∑ ‚â§ ¬∑) S) {x : R} : (x ‚àà ‚®Ü i, S i) ‚Üî ‚àÉ i, x ‚àà S i ",":= by
  refine ‚ü®?_, fun ‚ü®i, hi‚ü© ‚Ü¶ le_iSup S i hi‚ü©
  let U : NonUnitalSubring R :=
    NonUnitalSubring.mk' (‚ãÉ i, (S i : Set R)) (‚®Ü i, (S i).toSubsemigroup) (‚®Ü i, (S i).toAddSubgroup)
      (Subsemigroup.coe_iSup_of_directed hS) (AddSubgroup.coe_iSup_of_directed hS)
  suffices ‚®Ü i, S i ‚â§ U by simpa [U] using @this x
  exact iSup_le fun i x hx ‚Ü¶ Set.mem_iUnion.2 ‚ü®i, hx‚ü©",":= by
  refine ‚ü®_, fun ‚ü®i, hi‚ü© => (SetLike.le_def.1 <| le_iSup S i) hi‚ü©
  let U : NonUnitalSubring R :=
    NonUnitalSubring.mk' (‚ãÉ i, (S i : Set R)) (‚®Ü i, (S i).toSubsemigroup) (‚®Ü i, (S i).toAddSubgroup)
      (Subsemigroup.coe_iSup_of_directed <| hS.mono_comp _ fun _ _ => id)
      (AddSubgroup.coe_iSup_of_directed <| hS.mono_comp _ fun _ _ => id)
      (AddSubgroup.coe_iSup_of_directed <| hS.mono_comp _ fun _ _ => id)
  suffices (‚®Ü i, S i) ‚â§ U by simpa using @this x
  exact iSup_le fun i x hx => Set.mem_iUnion.2 ‚ü®i, hx‚ü©"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,56d6c36569bfa5f38809662c438716c5f84ec909,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniforml"
Mathlib/NumberTheory/Padics/PadicVal.lean,padicValRat.le_padicValRat_add_of_le,le_padicValRat_add_of_le,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":=
  if hq : q = 0 then by simpa [hq] using h
  else
    if hr : r = 0 then by simp [hr]
    else by
      have hqn : q.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hq
      have hqd : (q.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hqreq : q + r = (q.num * r.den + q.den * r.num) /. (q.den * r.den) := Rat.add_num_den _ _
      have hqrd : q.num * r.den + q.den * r.num ‚â† 0 := Rat.mk_num_ne_zero_of_ne_zero hqr hqreq
      conv_lhs => rw [‚Üê @Rat.num_den q]
      rw [hqreq, padicValRat_le_padicValRat_iff hqn hqrd hqd (mul_ne_zero hqd hrd), ‚Üê
        multiplicity_le_multiplicity_iff, mul_left_comm,
        multiplicity.mul (Nat.prime_iff_prime_int.1 hp.1), add_mul]
      rw [‚Üê @Rat.num_den q, ‚Üê @Rat.num_den r, padicValRat_le_padicValRat_iff hqn hrn hqd hrd, ‚Üê
        multiplicity_le_multiplicity_iff] at h
      calc
        _ ‚â§
            min (multiplicity (‚Üëp) (q.num * r.den * q.den))
              (multiplicity (‚Üëp) (‚Üëq.den * r.num * ‚Üëq.den)) :=
          le_min
            (by rw [@multiplicity.mul _ _ _ _ (_ * _) _ (Nat.prime_iff_prime_int.1 hp.1), add_comm])
            (by
              rw [mul_assoc,
                  @multiplicity.mul _ _ _ _ (q.den : ‚Ñ§) (_ * _)
                    (Nat.prime_iff_prime_int.1 hp.1)]
              exact add_le_add_left h _)
        _ ‚â§ _ := min_le_multiplicity_add","error:  unknown constant 'Rat.num_ne_zero_of_ne_zero'
error:  unknown constant 'Rat.num_ne_zero_of_ne_zero'
error:  invalid use of field notation with `@` modifier
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.41902
p : ‚Ñï
hp : Fact (Nat.Prime p)
q r : ‚Ñö
hqr : q + r ‚â† 0
h : padicValRat p q ‚â§ padicValRat p r
hq : ¬¨q = 0
hr : ¬¨r = 0
hqn : q.num ‚â† 0
hqd : ‚Üëq.den ‚â† 0
hrn : r.num ‚â† 0
hrd : ‚Üër.den ‚â† 0
hqreq : q + r = (q.num * ‚Üër.den + ‚Üëq.den * r.num) /. (‚Üëq.den * ‚Üër.den)
hqrd : q.num * ‚Üër.den + ‚Üëq.den * r.num ‚â† 0
| padicValRat p q
warning:  unused variable `hp`
note: this linter can be disabled with `set_option linter.unusedVariables false`","theorem le_padicValRat_add_of_le {q r : ‚Ñö} (hqr : q + r ‚â† 0)
    (h : padicValRat p q ‚â§ padicValRat p r) : padicValRat p q ‚â§ padicValRat p (q + r) ",":=
  if hq : q = 0 then by simpa [hq] using h
  else
    if hr : r = 0 then by simp [hr]
    else by
      have hqn : q.num ‚â† 0 := Rat.num_ne_zero.2 hq
      have hqd : (q.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero.2 hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hqreq : q + r = (q.num * r.den + q.den * r.num) /. (q.den * r.den) := Rat.add_num_den _ _
      have hqrd : q.num * r.den + q.den * r.num ‚â† 0 := Rat.mk_num_ne_zero_of_ne_zero hqr hqreq
      conv_lhs => rw [‚Üê q.num_divInt_den]
      rw [hqreq, padicValRat_le_padicValRat_iff hqn hqrd hqd (mul_ne_zero hqd hrd), ‚Üê
        multiplicity_le_multiplicity_iff, mul_left_comm,
        multiplicity.mul (Nat.prime_iff_prime_int.1 hp.1), add_mul]
      rw [‚Üê q.num_divInt_den, ‚Üê r.num_divInt_den, padicValRat_le_padicValRat_iff hqn hrn hqd hrd, ‚Üê
        multiplicity_le_multiplicity_iff] at h
      calc
        _ ‚â§
            min (multiplicity (‚Üëp) (q.num * r.den * q.den))
              (multiplicity (‚Üëp) (‚Üëq.den * r.num * ‚Üëq.den)) :=
          le_min
            (by rw [@multiplicity.mul _ _ _ _ (_ * _) _ (Nat.prime_iff_prime_int.1 hp.1), add_comm])
            (by
              rw [mul_assoc,
                  @multiplicity.mul _ _ _ _ (q.den : ‚Ñ§) (_ * _)
                    (Nat.prime_iff_prime_int.1 hp.1)]
              exact add_le_add_left h _)
        _ ‚â§ _ := min_le_multiplicity_add",":=
  if hq : q = 0 then by simpa [hq] using h
  else
    if hr : r = 0 then by simp [hr]
    else by
      have hqn : q.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hq
      have hqd : (q.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
   "
Mathlib/MeasureTheory/Group/FundamentalDomain.lean,MeasureTheory.IsFundamentalDomain.covolume_eq_volume,IsFundamentalDomain.covolume_eq_volume,85d5f96e889a9989f88357a1e0c0159e124db61b,":= by
  dsimp [covolume]
  simp only [(fund_dom_s.hasFundamentalDomain ŒΩ), ‚ÜìreduceDite]
  rw [fund_dom_s.measure_eq]
  exact (fund_dom_s.hasFundamentalDomain ŒΩ).ExistsIsFundamentalDomain.choose_spec","error:  unknown identifier 'reduceDite'
error:  type mismatch
  Exists.choose_spec HasFundamentalDomain.ExistsIsFundamentalDomain
has type
  IsFundamentalDomain G ‚ãØ.choose ŒΩ : Prop
but is expected to have type
  (if h : True then ŒΩ ‚ãØ.choose else 0) = ŒΩ ?m.535913 : Prop","lemma IsFundamentalDomain.covolume_eq_volume (ŒΩ : Measure Œ±) [Countable G]
    [MeasurableSMul G Œ±] [SMulInvariantMeasure G Œ± ŒΩ] {s : Set Œ±}
    (fund_dom_s : IsFundamentalDomain G s ŒΩ) : covolume G Œ± ŒΩ = ŒΩ s ",":= by
  dsimp [covolume]
  simp only [(fund_dom_s.hasFundamentalDomain ŒΩ), ‚ÜìreduceDIte]
  rw [fund_dom_s.measure_eq]
  exact (fund_dom_s.hasFundamentalDomain ŒΩ).ExistsIsFundamentalDomain.choose_spec",":= by
  dsimp [covolume]
  simp only [(fund_dom_s.hasFundamentalDomain ŒΩ), ‚ÜìreduceDIte]
  rw [fund_dom_s.measure_eq]
  exact (fund_dom_s.hasFundamentalDomain ŒΩ).ExistsIsFundamentalDomain.choose_spec"
Mathlib/RingTheory/Finiteness.lean,Submodule.fg_of_fg_map_of_fg_inf_ker,fg_of_fg_map_of_fg_inf_ker,22b19e1aaf45d4cbf676dcaf7d0cf96ec8cb3642,":= by
  haveI := Classical.decEq R
  haveI := Classical.decEq M
  haveI := Classical.decEq P
  cases' hs1 with t1 ht1
  cases' hs2 with t2 ht2
  have : ‚àÄ y ‚àà t1, ‚àÉ x ‚àà s, f x = y := by
    intro y hy
    have : y ‚àà s.map f := by
      rw [‚Üê ht1]
      exact subset_span hy
    rcases mem_map.1 this with ‚ü®x, hx1, hx2‚ü©
    exact ‚ü®x, hx1, hx2‚ü©
  have : ‚àÉ g : P ‚Üí M, ‚àÄ y ‚àà t1, g y ‚àà s ‚àß f (g y) = y := by
    choose g hg1 hg2 using this
    exists fun y => if H : y ‚àà t1 then g y H else 0
    intro y H
    constructor
    ¬∑ simp only [dif_pos H]
      apply hg1
    ¬∑ simp only [dif_pos H]
      apply hg2
  cases' this with g hg
  clear this
  exists t1.image g ‚à™ t2
  rw [Finset.coe_union, span_union, Finset.coe_image]
  apply le_antisymm
  ¬∑ refine' sup_le (span_le.2 <| image_subset_iff.2 _) (span_le.2 _)
    ¬∑ intro y hy
      exact (hg y hy).1
    ¬∑ intro x hx
      have : x ‚àà span R t2 := subset_span hx
      rw [ht2] at this
      exact this.1
  intro x hx
  have : f x ‚àà s.map f := by
    rw [mem_map]
    exact ‚ü®x, hx, rfl‚ü©
  rw [‚Üê ht1, ‚Üê Set.image_id (t1 : Set P), Finsupp.mem_span_image_iff_total] at this
  rcases this with ‚ü®l, hl1, hl2‚ü©
  refine'
    mem_sup.2
      ‚ü®(Finsupp.total M M R id).toFun ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), _,
        x - Finsupp.total M M R id ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), _,
        add_sub_cancel'_right _ _‚ü©
  ¬∑ rw [‚Üê Set.image_id (g '' ‚Üët1), Finsupp.mem_span_image_iff_total]
    refine' ‚ü®_, _, rfl‚ü©
    haveI : Inhabited P := ‚ü®0‚ü©
    rw [‚Üê Finsupp.lmapDomain_supported _ _ g, mem_map]
    refine' ‚ü®l, hl1, _‚ü©
    rfl
  rw [ht2, mem_inf]
  constructor
  ¬∑ apply s.sub_mem hx
    rw [Finsupp.total_apply, Finsupp.lmapDomain_apply, Finsupp.sum_mapDomain_index]
    refine' s.sum_mem _
    ¬∑ intro y hy
      exact s.smul_mem _ (hg y (hl1 hy)).1
    ¬∑ exact zero_smul _
    ¬∑ exact fun _ _ _ => add_smul _ _ _
  ¬∑ rw [LinearMap.mem_ker, f.map_sub, ‚Üê hl2]
    rw [Finsupp.total_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply]
    rw [Finsupp.sum_mapDomain_index, Finsupp.sum, Finsupp.sum, f.map_sum]
    rw [sub_eq_zero]
    refine' Finset.sum_congr rfl fun y hy => _
    unfold id
    rw [f.map_smul, (hg y (hl1 hy)).2]
    ¬∑ exact zero_smul _
    ¬∑ exact fun _ _ _ => add_smul _ _ _","warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
error:  invalid field 'map_sum', the environment does not contain 'LinearMap.map_sum'
  f
has type
  M ‚Üí‚Çó[R] P
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.111488
case intro.intro.intro.a.intro.intro.refine'_2.right
R‚úù : Type u_1
M‚úù : Type u_2
inst‚úù‚Åπ : Semiring R‚úù
inst‚úù‚Å∏ : AddCommMonoid M‚úù
inst‚úù‚Å∑ : Module R‚úù M‚úù
P‚úù : Type u_3
inst‚úù‚Å∂ : AddCommMonoid P‚úù
inst‚úù‚Åµ : Module R‚úù P‚úù
f‚úù : M‚úù ‚Üí‚Çó[R‚úù] P‚úù
R : Type u_4
M : Type u_5
P : Type u_6
inst‚úù‚Å¥ : Ring R
inst‚úù¬≥ : AddCommGroup M
inst‚úù¬≤ : Module R M
inst‚úù¬π : AddCommGroup P
inst‚úù : Module R P
f : M ‚Üí‚Çó[R] P
s : Submodule R M
this‚úù¬π : DecidableEq R
this‚úù : DecidableEq M
this : DecidableEq P
t1 : Finset P
ht1 : span R ‚Üët1 = map f s
t2 : Finset M
ht2 : span R ‚Üët2 = s ‚äì LinearMap.ker f
g : P ‚Üí M
hg : ‚àÄ y ‚àà t1, g y ‚àà s ‚àß f (g y) = y
x : M
hx : x ‚àà s
l : P ‚Üí‚ÇÄ R
hl1 : l ‚àà Finsupp.supported R R ‚Üët1
hl2 : (Finsupp.total P P R id) l = f x
‚ä¢ ‚àë a ‚àà l.support, l a ‚Ä¢ id a - f (‚àë a ‚àà l.support, l a ‚Ä¢ id (g a)) = 0
warning:  Module.Finite does not have a doc string","theorem fg_of_fg_map_of_fg_inf_ker {R M P : Type*} [Ring R] [AddCommGroup M] [Module R M]
    [AddCommGroup P] [Module R P] (f : M ‚Üí‚Çó[R] P) {s : Submodule R M}
    (hs1 : (s.map f).FG)
    (hs2 : (s ‚äì LinearMap.ker f).FG) : s.FG ",":= by
  haveI := Classical.decEq R
  haveI := Classical.decEq M
  haveI := Classical.decEq P
  cases' hs1 with t1 ht1
  cases' hs2 with t2 ht2
  have : ‚àÄ y ‚àà t1, ‚àÉ x ‚àà s, f x = y := by
    intro y hy
    have : y ‚àà s.map f := by
      rw [‚Üê ht1]
      exact subset_span hy
    rcases mem_map.1 this with ‚ü®x, hx1, hx2‚ü©
    exact ‚ü®x, hx1, hx2‚ü©
  have : ‚àÉ g : P ‚Üí M, ‚àÄ y ‚àà t1, g y ‚àà s ‚àß f (g y) = y := by
    choose g hg1 hg2 using this
    exists fun y => if H : y ‚àà t1 then g y H else 0
    intro y H
    constructor
    ¬∑ simp only [dif_pos H]
      apply hg1
    ¬∑ simp only [dif_pos H]
      apply hg2
  cases' this with g hg
  clear this
  exists t1.image g ‚à™ t2
  rw [Finset.coe_union, span_union, Finset.coe_image]
  apply le_antisymm
  ¬∑ refine sup_le (span_le.2 <| image_subset_iff.2 ?_) (span_le.2 ?_)
    ¬∑ intro y hy
      exact (hg y hy).1
    ¬∑ intro x hx
      have : x ‚àà span R t2 := subset_span hx
      rw [ht2] at this
      exact this.1
  intro x hx
  have : f x ‚àà s.map f := by
    rw [mem_map]
    exact ‚ü®x, hx, rfl‚ü©
  rw [‚Üê ht1, ‚Üê Set.image_id (t1 : Set P), Finsupp.mem_span_image_iff_total] at this
  rcases this with ‚ü®l, hl1, hl2‚ü©
  refine
    mem_sup.2
      ‚ü®(Finsupp.total M M R id).toFun ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), ?_,
        x - Finsupp.total M M R id ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), ?_,
        add_sub_cancel _ _‚ü©
  ¬∑ rw [‚Üê Set.image_id (g '' ‚Üët1), Finsupp.mem_span_image_iff_total]
    refine ‚ü®_, ?_, rfl‚ü©
    haveI : Inhabited P := ‚ü®0‚ü©
    rw [‚Üê Finsupp.lmapDomain_supported _ _ g, mem_map]
    refine ‚ü®l, hl1, ?_‚ü©
    rfl
  rw [ht2, mem_inf]
  constructor
  ¬∑ apply s.sub_mem hx
    rw [Finsupp.total_apply, Finsupp.lmapDomain_apply, Finsupp.sum_mapDomain_index]
    ¬∑ refine s.sum_mem ?_
      intro y hy
      exact s.smul_mem _ (hg y (hl1 hy)).1
    ¬∑ exact zero_smul _
    ¬∑ exact fun _ _ _ => add_smul _ _ _
  ¬∑ rw [LinearMap.mem_ker, f.map_sub, ‚Üê hl2]
    rw [Finsupp.total_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply]
    rw [Finsupp.sum_mapDomain_index, Finsupp.sum, Finsupp.sum, map_sum]
    ¬∑ rw [sub_eq_zero]
      refine Finset.sum_congr rfl fun y hy => ?_
      unfold id
      rw [f.map_smul, (hg y (hl1 hy)).2]
    ¬∑ exact zero_smul _
    ¬∑ exact fun _ _ _ => add_smul _ _ _",":= by
  haveI := Classical.decEq R
  haveI := Classical.decEq P
  cases' hs1 with t1 ht1
  cases' hs2 with t2 ht2
  have : ‚àÄ y ‚àà t1, ‚àÉ x ‚àà s, f x = y := by
    intro y hy
    have : y ‚àà s.map f := by
      rw [‚Üê ht1]
      exact subset_span hy
    rcases mem_map.1 this with ‚ü®x, hx1, hx2‚ü©
    exact ‚ü®x, hx1, hx2‚ü©
  have : ‚àÉ g : P ‚Üí M, ‚àÄ y ‚àà t1, g y ‚àà s ‚àß f (g y) = y := by
    choose g hg1 hg2 using this
    exists fun y => if H : y ‚àà t1 then g y H else 0
    intro y H
    constructor
    ¬∑ simp only [dif_pos H]
      apply hg1
    ¬∑ simp only [dif_pos H]
      apply hg2
  cases' this with g hg
  clear this
  exists t1.image g ‚à™ t2
  rw [Finset.coe_union, span_union, Finset.coe_image]
  apply le_antisymm
  ¬∑ refine sup_le (span_le.2 <| image_subset_iff.2 ?_) (span_le.2 ?_)
    ¬∑ intro y hy
      exact (hg y hy).1
    ¬∑ intro x hx
      have : x ‚àà span R t2 := subset_span hx
      rw [ht2] at this
      exact this.1
  intro x hx
  have : f x ‚àà s.map f := by
    rw [mem_map]
    exact ‚ü®x, hx, rfl‚ü©
  rw [‚Üê ht1, ‚Üê Set.image_id (t1 : Set P), Finsupp.mem_span_image_iff_total] at this
  rcases this with ‚ü®l, hl1, hl2‚ü©
  refine
    mem_sup.2
      ‚ü®(Finsupp.total M M R id).toFun ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), ?_,
        x - Finsupp.total M M R id ((Finsupp.lmapDomain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), ?_,
        add_sub_cancel_right _ _‚ü©
  ¬∑ rw [‚Üê Set.image_id (g '' ‚Üët1), Finsupp.mem_span_image_iff_total]
    refine ‚ü®_, ?_, rfl‚ü©
    haveI : Inhabited P := ‚ü®0‚ü©
    rw [‚Üê Finsupp.lmapDomain_supported _ _ g, mem_map]
    refine ‚ü®l, hl1, ?_‚ü©
    rfl
  rw [ht2, mem_inf]
  constructor
  ¬∑ apply s.sub_mem hx
    rw [Finsupp.total_apply, Finsupp.lmapDomain_apply, Finsupp.sum_mapDomain_index]
    refine s.sum_mem ?_
    ¬∑ intro y hy
      exact s.smul_mem _ (hg y (hl1 hy)).1
    ¬∑ exact zero_smul _
    ¬∑ exact fun _ _ _ => add_smul _ _ _
  ¬∑ rw [LinearMap.mem_ker, f.map_sub, ‚Üê hl2]
    rw [Finsupp.total_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply]
    rw [Finsupp.sum_mapDomain_index, Finsupp.sum, Finsupp.sum, Finsupp.sum, f.map_sum]
    rw [sub_eq_zero]
    refine Finset.sum_congr rfl fun y hy => ?_
    unfold id
    rw [f.map_smul, (hg y (hl1 hy)).2]
    ¬∑ exact zero_smul _
    ¬∑ exact fun _ _ _ => add_smul _ _ _
  ¬∑ rw [LinearMap.mem_ker, f.map_sub, ‚Üê hl2]
    rw [Finsupp.total_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply]
    rw [Finsupp.sum_mapDomain_index, Finsupp.sum, Finsupp.sum, Fins"
Mathlib/Data/Nat/Factorization/Basic.lean,Nat.factors_count_eq,factors_count_eq,6cab3d646c38b08ac405dd08d69f9cd87938b5c1,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  by_cases pp : p.Prime
  case neg =>
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization, coe_mk, pp, if_true]
  rw [‚Üê PartENat.natCast_inj, padicValNat_def' pp.ne_one hn0,
    UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors pp hn0.ne']
  simp [factors_eq]","error:  unknown identifier 'UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.7120
case pos
a b m n‚úù p‚úù n p : ‚Ñï
hn0 : n > 0
pp : Prime p
‚ä¢ ‚Üë(count p n.factors) = multiplicity p n",theorem factors_count_eq {n p : ‚Ñï} : n.factors.count p = n.factorization p ,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization_def _ pp]
  apply _root_.le_antisymm
  ¬∑ rw [le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm
  ¬∑ rw [‚Üê Nat.lt_add_one_iff, lt_iff_not_ge, ge_iff_le,
      le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this",":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  by_cases pp : p.Prime
  case neg =>
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization, coe_mk, pp, if_true]
  rw [‚Üê PartENat.natCast_inj, padicValNat_def' pp.ne_one hn0,
    UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors pp hn0.ne']"
Mathlib/LinearAlgebra/QuadraticForm/Real.lean,QuadraticForm.equivalent_one_zero_neg_one_weighted_sum_squared,equivalent_one_zero_neg_one_weighted_sum_squared,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":=
  let ‚ü®w, ‚ü®hw‚ÇÅ‚ü©‚ü© := Q.equivalent_weightedSumSquares
  ‚ü®Real.sign ‚àò ((‚Üë) : ‚Ñù ‚Üí ‚Ñù) ‚àò w, fun i => sign_apply_eq (w i),
    ‚ü®hw‚ÇÅ.trans (isometryEquivSignWeightedSumSquares w)‚ü©‚ü©","error:  unknown constant 'Real.sign'
error:  unknown identifier 'sign_apply_eq'","theorem equivalent_one_zero_neg_one_weighted_sum_squared {M : Type*} [AddCommGroup M] [Module ‚Ñù M]
    [FiniteDimensional ‚Ñù M] (Q : QuadraticForm ‚Ñù M) :
    ‚àÉ w : Fin (FiniteDimensional.finrank ‚Ñù M) ‚Üí ‚Ñù,
      (‚àÄ i, w i = -1 ‚à® w i = 0 ‚à® w i = 1) ‚àß Equivalent Q (weightedSumSquares ‚Ñù w) ",":=
  let ‚ü®w, hw‚ü© := Q.equivalent_signType_weighted_sum_squared
  ‚ü®(w ¬∑), fun i ‚Ü¶ by cases h : w i <;> simp [h], hw‚ü©",":=
  let ‚ü®w, ‚ü®hw‚ÇÅ‚ü©‚ü© := Q.equivalent_weightedSumSquares
  ‚ü®Real.sign ‚àò ((‚Üë) : ‚Ñù ‚Üí ‚Ñù) ‚àò w, fun i => sign_apply_eq (w i),
    ‚ü®hw‚ÇÅ.trans isometryEquivSignWeightedSumSquares w‚ü©‚ü©"
Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean,Finset.mul_pluennecke_petridis,mul_pluennecke_petridis,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' C with x C _ ih
  ¬∑ simp
  set A' := A ‚à© (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have h‚ÇÄ : A' * {x} = A * {x} ‚à© (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have h‚ÇÅ : A * B * C' = A * B * C ‚à™ (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine (sup_sdiff_eq_sup ?_).symm
    rw [mul_right_comm, mul_right_comm A, h‚ÇÄ]
    exact mul_subset_mul_right inter_subset_right
  have h‚ÇÇ : A' * B * {x} ‚äÜ A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right inter_subset_left)
  have h‚ÇÉ : (A * B * C').card ‚â§ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [h‚ÇÅ]
    refine (card_union_le _ _).trans_eq ?_
    rw [card_sdiff h‚ÇÇ, ‚Üê add_tsub_assoc_of_le (card_le_card h‚ÇÇ), card_mul_singleton,
      card_mul_singleton]
  refine (mul_le_mul_right' h‚ÇÉ _).trans ?_
  rw [tsub_mul, add_mul]
  refine (tsub_le_tsub (add_le_add_right ih _) <| hA _ inter_subset_left).trans_eq ?_
  rw [‚Üê mul_add, ‚Üê mul_tsub, ‚Üê hA', hC', insert_eq, mul_union, ‚Üê card_mul_singleton A x, ‚Üê
    card_mul_singleton A' x, add_comm (card _), h‚ÇÄ,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]","error:  simp made no progress
error:  no goals to be solved","theorem mul_pluennecke_petridis (C : Finset Œ±)
    (hA : ‚àÄ A' ‚äÜ A, (A * B).card * A'.card ‚â§ (A' * B).card * A.card) :
    (A * B * C).card * A.card ‚â§ (A * B).card * (A * C).card ",":= by
  induction' C using Finset.induction_on with x C _ ih
  ¬∑ simp
  set A' := A ‚à© (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have h‚ÇÄ : A' * {x} = A * {x} ‚à© (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have h‚ÇÅ : A * B * C' = A * B * C ‚à™ (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine (sup_sdiff_eq_sup ?_).symm
    rw [mul_right_comm, mul_right_comm A, h‚ÇÄ]
    exact mul_subset_mul_right inter_subset_right
  have h‚ÇÇ : A' * B * {x} ‚äÜ A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right inter_subset_left)
  have h‚ÇÉ : (A * B * C').card ‚â§ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [h‚ÇÅ]
    refine (card_union_le _ _).trans_eq ?_
    rw [card_sdiff h‚ÇÇ, ‚Üê add_tsub_assoc_of_le (card_le_card h‚ÇÇ), card_mul_singleton,
      card_mul_singleton]
  refine (mul_le_mul_right' h‚ÇÉ _).trans ?_
  rw [tsub_mul, add_mul]
  refine (tsub_le_tsub (add_le_add_right ih _) <| hA _ inter_subset_left).trans_eq ?_
  rw [‚Üê mul_add, ‚Üê mul_tsub, ‚Üê hA', hC', insert_eq, mul_union, ‚Üê card_mul_singleton A x, ‚Üê
    card_mul_singleton A' x, add_comm (card _), h‚ÇÄ,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]",":= by
  induction' C with x C _ ih
  ¬∑ simp
  set A' := A ‚à© (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have h‚ÇÄ : A' * {x} = A * {x} ‚à© (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have h‚ÇÅ : A * B * C' = A * B * C ‚à™ (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine (sup_sdiff_eq_sup ?_).symm
    rw [mul_right_comm, mul_right_comm A, h‚ÇÄ]
    exact mul_subset_mul_right inter_subset_right
  have h‚ÇÇ : A' * B * {x} ‚äÜ A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right inter_subset_left)
  have h‚ÇÉ : (A * B * C').card ‚â§ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [h‚ÇÅ]
    refine (card_union_le _ _).trans_eq ?_
    rw [card_sdiff h‚ÇÇ, ‚Üê add_tsub_assoc_of_le (card_le_card h‚ÇÇ), card_mul_singleton,
      card_mul_singleton]
  refine (mul_le_mul_right' h‚ÇÉ ?_).trans ?_
  rw [tsub_mul, add_mul]
  refine (tsub_le_tsub (add_le_add_right ih _) <| hA _ inter_subset_left).trans_eq ?_
  rw [‚Üê mul_add, ‚Üê mul_tsub, ‚Üê hA', hC', insert_eq, mul_union, ‚Üê card_mul_singleton A x, ‚Üê
    card_mul_singleton A' x, add_comm (card _), h‚ÇÄ,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]"
Mathlib/RingTheory/Artinian.lean,IsArtinianRing.localization_surjective,localization_surjective,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  intro r'
  obtain ‚ü®r‚ÇÅ, s, rfl‚ü© := IsLocalization.mk'_surjective S r'
  obtain ‚ü®r‚ÇÇ, h‚ü© : ‚àÉ r : R, IsLocalization.mk' L 1 s = algebraMap R L r
  swap
  ¬∑ exact ‚ü®r‚ÇÅ * r‚ÇÇ, by rw [IsLocalization.mk'_eq_mul_mk'_one, map_mul, h]‚ü©
  obtain ‚ü®n, r, hr‚ü© := IsArtinian.exists_pow_succ_smul_dvd (s : R) (1 : R)
  use r
  rw [smul_eq_mul, smul_eq_mul, pow_succ', mul_assoc] at hr
  apply_fun algebraMap R L at hr
  simp only [map_mul] at hr
  rw [‚Üê IsLocalization.mk'_one (M := S) L, IsLocalization.mk'_eq_iff_eq, mul_one, Submonoid.coe_one,
    ‚Üê (IsLocalization.map_units L (s ^ n)).mul_left_cancel hr, map_mul]","error:  application type mismatch
  IsUnit.mul_left_cancel (IsLocalization.map_units L (s ^ n)) hr
argument
  hr
has type
  (algebraMap R L) ‚Üës * ((algebraMap R L) (‚Üës ^ n) * (algebraMap R L) r) =
    (algebraMap R L) (‚Üës ^ n) * (algebraMap R L) 1 : Prop
but is expected to have type
  (algebraMap R L) ‚Üë(s ^ n) * ?m.321813 = (algebraMap R L) ‚Üë(s ^ n) * ?m.321814 : Prop
error:  tactic 'rewrite' failed, pattern is a metavariable
  ?m.321814
from equation
  ?m.321814 = ?m.321813
case h
R : Type u_1
inst‚úù‚Å¥ : CommRing R
inst‚úù¬≥ : IsArtinianRing R
S : Submonoid R
L : Type u_2
inst‚úù¬≤ : CommRing L
inst‚úù¬π : Algebra R L
inst‚úù : IsLocalization S L
r‚ÇÅ : R
s : ‚Ü•S
n : ‚Ñï
r : R
hr :
  (algebraMap R L) ‚Üës * ((algebraMap R L) (‚Üës ^ n) * (algebraMap R L) r) =
    (algebraMap R L) (‚Üës ^ n) * (algebraMap R L) 1
‚ä¢ (algebraMap R L) 1 = (algebraMap R L) (‚Üës * r)",theorem localization_surjective : Function.Surjective (algebraMap R L) ,":= by
  intro r'
  obtain ‚ü®r‚ÇÅ, s, rfl‚ü© := IsLocalization.mk'_surjective S r'
  obtain ‚ü®r‚ÇÇ, h‚ü© : ‚àÉ r : R, IsLocalization.mk' L 1 s = algebraMap R L r := by
    obtain ‚ü®n, r, hr‚ü© := IsArtinian.exists_pow_succ_smul_dvd (s : R) (1 : R)
    use r
    rw [smul_eq_mul, smul_eq_mul, pow_succ, mul_assoc] at hr
    apply_fun algebraMap R L at hr
    simp only [map_mul] at hr
    rw [‚Üê IsLocalization.mk'_one (M := S) L, IsLocalization.mk'_eq_iff_eq, mul_one,
      Submonoid.coe_one, ‚Üê (IsLocalization.map_units L (s ^ n)).mul_left_cancel hr, map_mul]
  exact ‚ü®r‚ÇÅ * r‚ÇÇ, by rw [IsLocalization.mk'_eq_mul_mk'_one, map_mul, h]‚ü©",":= by
  intro r'
  obtain ‚ü®r‚ÇÅ, s, rfl‚ü© := IsLocalization.mk'_surjective S r'
  obtain ‚ü®r‚ÇÇ, h‚ü© : ‚àÉ r : R, IsLocalization.mk' L 1 s = algebraMap R L r
  swap
  ¬∑ exact ‚ü®r‚ÇÅ * r‚ÇÇ, by rw [IsLocalization.mk'_eq_mul_mk'_one, map_mul, h]‚ü©
  obtain ‚ü®n, r, hr‚ü© := IsArtinian.exists_pow_succ_smul_dvd (s : R) (1 : R)
  use r
  rw [smul_eq_mul, smul_eq_mul, pow_succ', mul_assoc] at hr
  apply_fun algebraMap R L at hr
  simp only [map_mul] at hr
  rw [‚Üê IsLocalization.mk'_one (M := S) L, IsLocalization.mk'_eq_iff_eq, mul_one,
    ‚Üê (IsLocalization.map_units L (s ^ n)).mul_left_cancel hr, map_mul]"
Mathlib/Data/Sum/Interval.lean,Finset.sumLexLift_eq_empty,sumLexLift_eq_empty,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_,? _, ?_‚ü©, fun h? ‚Ü¶ _‚ü©
  any_goals rintro a b rfl rfl; exact map_eq_empty.1 h
  ¬∑ rintro a b rfl rfl; exact disjSum_eq_empty.1 h
  cases a <;> cases b
  ¬∑ exact map_eq_empty.2 (h.1 _ _ rfl rfl)
  ¬∑ simp [h.2.1 _ _ rfl rfl]
  ¬∑ rfl
  ¬∑ exact map_eq_empty.2 (h.2.2 _ _ rfl rfl)","error:  don't know how to synthesize placeholder
context:
Œ±‚ÇÅ : Type u_1
Œ±‚ÇÇ : Type u_2
Œ≤‚ÇÅ : Type u_3
Œ≤‚ÇÇ : Type u_4
Œ≥‚ÇÅ : Type u_5
Œ≥‚ÇÇ : Type u_6
f‚ÇÅ f‚ÇÅ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ ‚Üí Finset Œ≥‚ÇÅ
f‚ÇÇ f‚ÇÇ' : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÇ
g‚ÇÅ g‚ÇÅ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÅ
g‚ÇÇ g‚ÇÇ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÇ
a : Œ±‚ÇÅ ‚äï Œ±‚ÇÇ
b : Œ≤‚ÇÅ ‚äï Œ≤‚ÇÇ
c : Œ≥‚ÇÅ ‚äï Œ≥‚ÇÇ
h? :
  (‚àÄ (a‚ÇÅ : Œ±‚ÇÅ) (b‚ÇÅ : Œ≤‚ÇÅ), a = inl a‚ÇÅ ‚Üí b = inl b‚ÇÅ ‚Üí f‚ÇÅ a‚ÇÅ b‚ÇÅ = ‚àÖ) ‚àß
    (‚àÄ (a‚ÇÅ : Œ±‚ÇÅ) (b‚ÇÇ : Œ≤‚ÇÇ), a = inl a‚ÇÅ ‚Üí b = inr b‚ÇÇ ‚Üí g‚ÇÅ a‚ÇÅ b‚ÇÇ = ‚àÖ ‚àß g‚ÇÇ a‚ÇÅ b‚ÇÇ = ‚àÖ) ‚àß
      ‚àÄ (a‚ÇÇ : Œ±‚ÇÇ) (b‚ÇÇ : Œ≤‚ÇÇ), a = inr a‚ÇÇ ‚Üí b = inr b‚ÇÇ ‚Üí f‚ÇÇ a‚ÇÇ b‚ÇÇ = ‚àÖ
‚ä¢ sumLexLift f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ a b = ‚àÖ
error:  unsolved goals
Œ±‚ÇÅ : Type u_1
Œ±‚ÇÇ : Type u_2
Œ≤‚ÇÅ : Type u_3
Œ≤‚ÇÇ : Type u_4
Œ≥‚ÇÅ : Type u_5
Œ≥‚ÇÇ : Type u_6
f‚ÇÅ f‚ÇÅ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ ‚Üí Finset Œ≥‚ÇÅ
f‚ÇÇ f‚ÇÇ' : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÇ
g‚ÇÅ g‚ÇÅ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÅ
g‚ÇÇ g‚ÇÇ' : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÇ ‚Üí Finset Œ≥‚ÇÇ
a : Œ±‚ÇÅ ‚äï Œ±‚ÇÇ
b : Œ≤‚ÇÅ ‚äï Œ≤‚ÇÇ
c : Œ≥‚ÇÅ ‚äï Œ≥‚ÇÇ
‚ä¢ sumLexLift f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ a b = ‚àÖ ‚Üî
    (‚àÄ (a‚ÇÅ : Œ±‚ÇÅ) (b‚ÇÅ : Œ≤‚ÇÅ), a = inl a‚ÇÅ ‚Üí b = inl b‚ÇÅ ‚Üí f‚ÇÅ a‚ÇÅ b‚ÇÅ = ‚àÖ) ‚àß
      (‚àÄ (a‚ÇÅ : Œ±‚ÇÅ) (b‚ÇÇ : Œ≤‚ÇÇ), a = inl a‚ÇÅ ‚Üí b = inr b‚ÇÇ ‚Üí g‚ÇÅ a‚ÇÅ b‚ÇÇ = ‚àÖ ‚àß g‚ÇÇ a‚ÇÅ b‚ÇÇ = ‚àÖ) ‚àß
        ‚àÄ (a‚ÇÇ : Œ±‚ÇÇ) (b‚ÇÇ : Œ≤‚ÇÇ), a = inr a‚ÇÇ ‚Üí b = inr b‚ÇÇ ‚Üí f‚ÇÇ a‚ÇÇ b‚ÇÇ = ‚àÖ","lemma sumLexLift_eq_empty :
    sumLexLift f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ a b = ‚àÖ ‚Üî
      (‚àÄ a‚ÇÅ b‚ÇÅ, a = inl a‚ÇÅ ‚Üí b = inl b‚ÇÅ ‚Üí f‚ÇÅ a‚ÇÅ b‚ÇÅ = ‚àÖ) ‚àß
        (‚àÄ a‚ÇÅ b‚ÇÇ, a = inl a‚ÇÅ ‚Üí b = inr b‚ÇÇ ‚Üí g‚ÇÅ a‚ÇÅ b‚ÇÇ = ‚àÖ ‚àß g‚ÇÇ a‚ÇÅ b‚ÇÇ = ‚àÖ) ‚àß
          ‚àÄ a‚ÇÇ b‚ÇÇ, a = inr a‚ÇÇ ‚Üí b = inr b‚ÇÇ ‚Üí f‚ÇÇ a‚ÇÇ b‚ÇÇ = ‚àÖ ",":= by
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, ?_, ?_‚ü©, fun h ‚Ü¶ ?_‚ü©
  any_goals rintro a b rfl rfl; exact map_eq_empty.1 h
  ¬∑ rintro a b rfl rfl; exact disjSum_eq_empty.1 h
  cases a <;> cases b
  ¬∑ exact map_eq_empty.2 (h.1 _ _ rfl rfl)
  ¬∑ simp [h.2.1 _ _ rfl rfl]
  ¬∑ rfl
  ¬∑ exact map_eq_empty.2 (h.2.2 _ _ rfl rfl)",":= by
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, ?_, ?_‚ü©, fun h ‚Ü¶ ?_‚ü©
  any_goals rintro a b rfl rfl; exact map_eq_empty.1 h
  ¬∑ rintro a b rfl rfl; exact disjSum_eq_empty.1 h
  cases a <;> cases b
  ¬∑ exact map_eq_empty.2 (h.1 _ _ rfl rfl)
  ¬∑ simp [h.2.1 _ _ rfl rfl]
  ¬∑ rfl
  ¬∑ exact map_eq_empty.2 (h.2.2 _ _ rfl rfl)"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,d61c95e1653dffe3f92c8927a905826929f50bce,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogon"
Mathlib/Algebra/Order/Ring/Defs.lean,mul_add_mul_le_mul_add_mul,mul_add_mul_le_mul_add_mul,5cea0b9bd58be4113638510bc58153baefc34cdf,":= by
  obtain ‚ü®b, rfl‚ü© := exists_add_of_le hab
  obtain ‚ü®d, hd, rfl‚ü© := exists_nonneg_add_of_le hcd
  rw [mul_add, add_right_comm, mul_add, ‚Üê add_assoc]
  exact add_le_add_left (mul_le_mul_of_nonneg_right hab <| hd) _","error:  unknown identifier 'exists_nonneg_add_of_le'
error:  rcases tactic failed: x‚úù : ?m.118170 is not an inductive datatype",lemma mul_add_mul_le_mul_add_mul (hab : a ‚â§ b) (hcd : c ‚â§ d) : a * d + b * c ‚â§ a * c + b * d ,":= by
  obtain ‚ü®b, rfl‚ü© := exists_add_of_le hab
  obtain ‚ü®d, rfl‚ü© := exists_add_of_le hcd
  rw [mul_add, add_right_comm, mul_add, ‚Üê add_assoc]
  exact add_le_add_left (mul_le_mul_of_nonneg_right hab <| (le_add_iff_nonneg_right _).1 hcd) _",":= by
  obtain ‚ü®b, rfl‚ü© := exists_add_of_le hab
  obtain ‚ü®d, hd, rfl‚ü© := exists_nonneg_add_of_le hcd
  rw [mul_add, add_right_comm, mul_add, ‚Üê add_assoc]
  exact add_le_add_left (mul_le_mul_of_nonneg_right hab <| hd) _"
Mathlib/Analysis/Calculus/MeanValue.lean,Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le,norm_image_sub_le_of_norm_hasFDerivWithin_le,fdcecc6431ccffb2e1ba4fe8b297b20ee9baa42b,":= by
  letI : NormedSpace ‚Ñù G := RestrictScalars.normedSpace ‚Ñù ùïú G
  set g := (AffineMap.lineMap x y : ‚Ñù ‚Üí E)
  have segm : MapsTo g (Icc 0 1 : Set ‚Ñù) s := hs.mapsTo_lineMap xs ys
  have hD : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1,
      HasDerivWithinAt (f ‚àò g) (f' (g t) (y - x)) (Icc 0 1) t := fun t ht => by
    simpa using ((hf (g t) (segm ht)).restrictScalars ‚Ñù).comp_hasDerivWithinAt _
      AffineMap.hasDerivWithinAt_lineMap segm
  have bound : ‚àÄ t ‚àà Ico (0 : ‚Ñù) 1, ‚Äñf' (g t) (y - x)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ := fun t ht =>
    le_of_opNorm_le _ (bound _ <| segm <| Ico_subset_Icc_self ht) _
  simpa using norm_image_sub_le_of_norm_deriv_le_segment_01' hD bound","error:  type mismatch
  h‚úù
has type
  ‚Äñf (g 1) - f (g 0)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ : Prop
but is expected to have type
  ‚Äñf y - f x‚Äñ ‚â§ C * ‚Äñy - x‚Äñ : Prop","theorem norm_image_sub_le_of_norm_hasFDerivWithin_le
    (hf : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) (bound : ‚àÄ x ‚àà s, ‚Äñf' x‚Äñ ‚â§ C) (hs : Convex ‚Ñù s)
    (xs : x ‚àà s) (ys : y ‚àà s) : ‚Äñf y - f x‚Äñ ‚â§ C * ‚Äñy - x‚Äñ ",":= by
  letI : NormedSpace ‚Ñù G := RestrictScalars.normedSpace ‚Ñù ùïú G
  set g := (AffineMap.lineMap x y : ‚Ñù ‚Üí E)
  have segm : MapsTo g (Icc 0 1 : Set ‚Ñù) s := hs.mapsTo_lineMap xs ys
  have hD : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1,
      HasDerivWithinAt (f ‚àò g) (f' (g t) (y - x)) (Icc 0 1) t := fun t ht => by
    simpa using ((hf (g t) (segm ht)).restrictScalars ‚Ñù).comp_hasDerivWithinAt _
      AffineMap.hasDerivWithinAt_lineMap segm
  have bound : ‚àÄ t ‚àà Ico (0 : ‚Ñù) 1, ‚Äñf' (g t) (y - x)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ := fun t ht =>
    le_of_opNorm_le _ (bound _ <| segm <| Ico_subset_Icc_self ht) _
  simpa [g] using norm_image_sub_le_of_norm_deriv_le_segment_01' hD bound",":= by
  letI : NormedSpace ‚Ñù G := RestrictScalars.normedSpace ‚Ñù ùïú G
  set g := (AffineMap.lineMap x y : ‚Ñù ‚Üí E)
  have segm : MapsTo g (Icc 0 1 : Set ‚Ñù) s := hs.mapsTo_lineMap xs ys
  have hD : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1,
      HasDerivWithinAt (f ‚àò g) (f' (g t) (y - x)) (Icc 0 1) t := fun t ht => by
    simpa using ((hf (g t) (segm ht)).restrictScalars ‚Ñù).comp_hasDerivWithinAt _
      AffineMap.hasDerivWithinAt_lineMap segm
  have bound : ‚àÄ t ‚àà Ico (0:‚Ñù) 1, ‚Äñf' (g t) (y - x)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ := fun t ht =>
    le_of_opNorm_le _ (bound _ <| segm <| Ico_subset_Icc_self ht) _
  simpa using norm_image_sub_le_of_norm_deriv_le_segment_01' hD bound"
Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean,jacobiTheta‚ÇÇ_add_right,jacobiTheta‚ÇÇ_add_right,66444f12b4fdd8b7704fda89d16282bec494d3ac,":= by
  refine tsum_congr (fun n ‚Ü¶ ?_)
  simp_rw [Complex.exp_add]
  suffices cexp (œÄ * I * n ^ 2 * 2 : ‚ÑÇ) = 1 by rw [mul_add, Complex.exp_add, this, mul_one]
  rw [(by push_cast; ring : (œÄ * I * n ^ 2 * 2 : ‚ÑÇ) = (n ^ 2 :) * (2 * œÄ * I)), exp_int_mul,
    exp_two_pi_mul_I, one_zpow]",error:  simp made no progress,lemma jacobiTheta‚ÇÇ_add_right (z œÑ : ‚ÑÇ) : jacobiTheta‚ÇÇ z (œÑ + 2) = jacobiTheta‚ÇÇ z œÑ ,":= by
  refine tsum_congr (fun n ‚Ü¶ ?_)
  simp_rw [jacobiTheta‚ÇÇ_term, Complex.exp_add]
  suffices cexp (œÄ * I * n ^ 2 * 2 : ‚ÑÇ) = 1 by rw [mul_add, Complex.exp_add, this, mul_one]
  rw [(by push_cast; ring : (œÄ * I * n ^ 2 * 2 : ‚ÑÇ) = (n ^ 2 :) * (2 * œÄ * I)), exp_int_mul,
    exp_two_pi_mul_I, one_zpow]",":= by
  refine tsum_congr (fun n ‚Ü¶ ?_)
  simp_rw [Complex.exp_add]
  suffices cexp (œÄ * I * n ^ 2 * 2 : ‚ÑÇ) = 1 by rw [mul_add, Complex.exp_add, this, mul_one]
  rw [(by push_cast; ring : (œÄ * I * n ^ 2 * 2 : ‚ÑÇ) = (n ^ 2) * (2 * œÄ * I)), exp_int_mul,
    exp_two_pi_mul_I, one_zpow]"
Mathlib/Probability/Kernel/RadonNikodym.lean,ProbabilityTheory.kernel.measurableSet_mutuallySingular,measurableSet_mutuallySingular,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  measurable_rnDerivAux Œ∫ (Œ∫ + Œ∑) (measurableSet_singleton 1)","error:  application type mismatch
  measurable_rnDerivAux Œ∫ (Œ∫ + Œ∑) (measurableSet_singleton 1)
argument
  measurableSet_singleton 1
has type
  MeasurableSet {1} : Prop
but is expected to have type
  MeasurableSet (Real.le 1) : Prop","lemma measurableSet_mutuallySingularSet (Œ∫ Œ∑ : kernel Œ± Œ≥) :
    MeasurableSet (mutuallySingularSet Œ∫ Œ∑) ",":=
  measurable_rnDerivAux Œ∫ (Œ∫ + Œ∑) measurableSet_Ici",":=
  measurable_rnDerivAux Œ∫ (Œ∫ + Œ∑) measurableSet_singleton"
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Œ¥_comp_œÉ_of_gt,Œ¥_comp_œÉ_of_gt,336881cb90caf4627017282bb293a4ecc5422243,":= by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]","error:  unknown constant 'Fin.castSucc_pred'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.77738
case a.h.h.inl.inr
n : ‚Ñï
i : Fin (n + 2)
j : Fin (n + 1)
H : j.castSucc < i
k : Fin ([n + 1].len + 1)
hik : k ‚â§ i
hjk : j.castSucc < k
‚ä¢ k.castSucc.pred ‚ãØ = (k.pred ‚ãØ).castSucc","theorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Œ¥ i.succ ‚â´ œÉ (Fin.castSucc j) = œÉ j ‚â´ Œ¥ i ",":= by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]",":= by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]"
Mathlib/Topology/Separation.lean,loc_compact_Haus_tot_disc_of_zero_dim,loc_compact_Haus_tot_disc_of_zero_dim,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  refine isTopologicalBasis_of_open_of_nhds (fun u hu => hu.1) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := ((‚Üë) : s ‚Üí H) ‚Åª¬π' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, clopen_in_s, Vx, V_sub‚ü© := compact_exists_clopen_in_open u_open_in_s xs
  have V_clopen : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine' ‚ü®_, comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 clopen_in_s.2‚ü©
    let v : Set u := ((‚Üë) : u ‚Üí s) ‚Åª¬π' V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine' ‚ü®f0, _‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_left interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := clopen_in_s.1.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  refine' ‚ü®(‚Üë) '' V, V_clopen, by simp [Vx], Subset.trans _ sU‚ü©
  simp","error:  unknown identifier 'isTopologicalBasis_of_open_of_nhds'
error:  no goals to be solved","theorem loc_compact_Haus_tot_disc_of_zero_dim [TotallyDisconnectedSpace H] :
    IsTopologicalBasis { s : Set H | IsClopen s } ",":= by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.2) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := ((‚Üë) : s ‚Üí H) ‚Åª¬π' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, VisClopen, Vx, V_sub‚ü© := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine ‚ü®comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.1, ?_‚ü©
    let v : Set u := ((‚Üë) : u ‚Üí s) ‚Åª¬π' V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine ‚ü®f0, ?_‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_right interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.2.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_right V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  use (‚Üë) '' V, VisClopen', by simp [Vx], Subset.trans (by simp) sU",":= by
  refine isTopologicalBasis_of_open_of_nhds (fun u hu => hu.1) fun x U memU hU => ?_
  obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
  let u : Set s := ((‚Üë) : s ‚Üí H) ‚Åª¬π' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ‚ü®V : Set s, clopen_in_s, Vx, V_sub‚ü© := compact_exists_clopen_in_open u_open_in_s xs
  have V_clopen : IsClopen (((‚Üë) : s ‚Üí H) '' V) := by
    refine ‚ü®_, comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 clopen_in_s.2‚ü©
    let v : Set u := ((‚Üë) : u ‚Üí s) ‚Åª¬π' V
    have : ((‚Üë) : u ‚Üí H) = ((‚Üë) : s ‚Üí H) ‚àò ((‚Üë) : u ‚Üí s) := rfl
    have f0 : Embedding ((‚Üë) : u ‚Üí H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((‚Üë) : u ‚Üí H) := by
      refine ‚ü®f0, ?_‚ü©
      ¬∑ have : Set.range ((‚Üë) : u ‚Üí H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_left interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := clopen_in_s.1.preimage continuous_subtype_val
    have f3 : ((‚Üë) : s ‚Üí H) '' V = ((‚Üë) : u ‚Üí H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  refine ‚ü®(‚Üë) '' V, V_clopen, by simp [Vx], Subset.trans ?_ sU‚ü©
  simp"
Mathlib/Analysis/Calculus/LocalExtr/Basic.lean,IsLocalMaxOn.hasFDerivWithinAt_nonpos,IsLocalMaxOn.hasFDerivWithinAt_nonpos,161c69c1dbf66cf3c7ec4f648a61551d044a43e4,":= by
  rcases hy with ‚ü®c, d, hd, hc, hcd‚ü©
  have hc' : Tendsto (‚Äñc ¬∑‚Äñ) atTop atTop := tendsto_abs_atTop_atTop.comp hc
  suffices : ‚àÄ·∂† n in atTop, c n ‚Ä¢ (f (a + d n) - f a) ‚â§ 0
  ¬∑ exact le_of_tendsto (hf.lim atTop hd hc' hcd) this
  replace hd : Tendsto (fun n => a + d n) atTop (ùìù[s] (a + 0))
  ¬∑ exact tendsto_nhdsWithin_iff.2 ‚ü®tendsto_const_nhds.add (tangentConeAt.lim_zero _ hc' hcd), hd‚ü©
  rw [add_zero] at hd
  filter_upwards [hd.eventually h, hc.eventually_ge_atTop 0] with n hfn hcn
  exact mul_nonpos_of_nonneg_of_nonpos hcn (sub_nonpos.2 hfn)",error:  unexpected token ':'; expected term,"theorem IsLocalMaxOn.hasFDerivWithinAt_nonpos {s : Set E} (h : IsLocalMaxOn f s a)
    (hf : HasFDerivWithinAt f f' s a) {y} (hy : y ‚àà posTangentConeAt s a) : f' y ‚â§ 0 ",":= by
  rcases hy with ‚ü®c, d, hd, hc, hcd‚ü©
  have hc' : Tendsto (‚Äñc ¬∑‚Äñ) atTop atTop := tendsto_abs_atTop_atTop.comp hc
  suffices ‚àÄ·∂† n in atTop, c n ‚Ä¢ (f (a + d n) - f a) ‚â§ 0 from
    le_of_tendsto (hf.lim atTop hd hc' hcd) this
  replace hd : Tendsto (fun n => a + d n) atTop (ùìù[s] (a + 0)) :=
    tendsto_nhdsWithin_iff.2 ‚ü®tendsto_const_nhds.add (tangentConeAt.lim_zero _ hc' hcd), hd‚ü©
  rw [add_zero] at hd
  filter_upwards [hd.eventually h, hc.eventually_ge_atTop 0] with n hfn hcn
  exact mul_nonpos_of_nonneg_of_nonpos hcn (sub_nonpos.2 hfn)",":= by
  rcases hy with ‚ü®c, d, hd, hc, hcd‚ü©
  have hc' : Tendsto (‚Äñc ¬∑‚Äñ) atTop atTop := tendsto_abs_atTop_atTop.comp hc
  suffices ‚àÄ·∂† n in atTop, c n ‚Ä¢ (f (a + d n) - f a) ‚â§ 0 by
    exact le_of_tendsto (hf.lim atTop hd hc' hcd) this
  replace hd : Tendsto (fun n => a + d n) atTop (ùìù[s] (a + 0))
  ¬∑ exact tendsto_nhdsWithin_iff.2 ‚ü®tendsto_const_nhds.add (tangentConeAt.lim_zero _ hc' hcd), hd‚ü©
  rw [add_zero] at hd
  filter_upwards [hd.eventually h, hc.eventually_ge_atTop 0] with n hfn hcn
  exact mul_nonpos_of_nonneg_of_nonpos hcn (sub_nonpos.2 hfn)"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,672f5f5cb82ed7f2e260348bba07f84ada7a8172,":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",error:  unknown constant 'StrictOrderedSemiring.to_charZero',"theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)) : IsIntegralClosure (adjoin ‚Ñ§ ({Œ∂} : Set K)) ‚Ñ§ K ",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subtype.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subtype.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subtype.mem_coe]
    exact Subalgebra"
Mathlib/Algebra/CharP/Basic.lean,CharP.char_is_prime,char_is_prime,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  suffices ‚àÄ (d) (_ : d ‚à£ p), d = 1 ‚à® d = p from Nat.prime_def_lt''.mpr ‚ü®hp, this‚ü©
  fun (d : ‚Ñï) (hdvd : ‚àÉ e, p = d * e) =>
  let ‚ü®e, hmul‚ü© := hdvd
  have : (p : R) = 0 := (cast_eq_zero_iff R p p).mpr (dvd_refl p)
  have : (d : R) * e = 0 := @Nat.cast_mul R _ d e ‚ñ∏ hmul ‚ñ∏ this
  Or.elim (eq_zero_or_eq_zero_of_mul_eq_zero this)
    (fun hd : (d : R) = 0 =>
      have : p ‚à£ d := (cast_eq_zero_iff R p d).mp hd
      show d = 1 ‚à® d = p from Or.inr (this.antisymm' ‚ü®e, hmul‚ü©))
    fun he : (e : R) = 0 =>
    have : p ‚à£ e := (cast_eq_zero_iff R p e).mp he
    have : e ‚à£ p := dvd_of_mul_left_eq d (Eq.symm hmul)
    have : e = p := ‚Äπe ‚à£ p‚Ä∫.antisymm ‚Äπp ‚à£ e‚Ä∫
    have h‚ÇÄ : 0 < p := two_pos.trans_le hp
    have : d * p = 1 * p := by rw [‚Äπe = p‚Ä∫] at hmul; rw [one_mul]; exact Eq.symm hmul
    show d = 1 ‚à® d = p from Or.inl (mul_right_cancel‚ÇÄ h‚ÇÄ.ne' this)","error:  unknown identifier 'hp'
error:  unknown identifier 'hp'",theorem char_is_prime (p : ‚Ñï) [CharP R p] : p.Prime ,":=
  Or.resolve_right (char_is_prime_or_zero R p) (char_ne_zero_of_finite R p)",":=
  suffices ‚àÄ (d) (_ : d ‚à£ p), d = 1 ‚à® d = p from Nat.prime_def_lt''.mpr ‚ü®hp, this‚ü©
  fun (d : ‚Ñï) (hdvd : ‚àÉ e, p = d * e) =>
  let ‚ü®e, hmul‚ü© := hdvd
  have : (p : R) = 0 := (cast_eq_zero_iff R p p).mpr (dvd_refl p)
  have : (d : R) * e = 0 := @Nat.cast_mul R _ d e ‚ñ∏ hmul ‚ñ∏ this
  Or.elim (eq_zero_or_eq_zero_of_mul_eq_zero this)
    (fun hd : (d : R) = 0 =>
      have : p ‚à£ d := (cast_eq_zero_iff R p d).mp hd
      show d = 1 ‚à® d = p from Or.inr (this.antisymm' ‚ü®e, hmul‚ü©))
    fun he : (e : R) = 0 =>
    have : p ‚à£ e := (cast_eq_zero_iff R p e).mp he
    have : e ‚à£ p := dvd_of_mul_left_eq d (Eq.symm hmul)
    have : e = p := ‚Äπe ‚à£ p‚Ä∫.antisymm ‚Äπp ‚à£ e‚Ä∫
    have h‚ÇÄ : 0 < p := two_pos.trans_le hp
    have : d * p = 1 * p := by rw [‚Äπe = p‚Ä∫] at hmul; rw [one_mul]; exact Eq.symm hmul
    show d = 1 ‚à® d = p from Or.inl (mul_right_cancel‚ÇÄ h‚ÇÄ.ne' this)"
Mathlib/MeasureTheory/Group/Measure.lean,MeasureTheory.measure_univ_of_isMulLeftInvariant,measure_univ_of_isMulLeftInvariant,573992a4b8322a4b7622a9a4dc3f40e8e6fd4dfa,":= by
  obtain ‚ü®K, K1, hK, Kclosed‚ü© : ‚àÉ K ‚àà ùìù (1 : G), IsCompact K ‚àß IsClosed K :=
    exists_mem_nhds_isCompact_isClosed 1
  have K_pos : 0 < Œº K := measure_pos_of_mem_nhds Œº K1
  have A : ‚àÄ L : Set G, IsCompact L ‚Üí ‚àÉ g : G, Disjoint L (g ‚Ä¢ K) := fun L hL =>
    exists_disjoint_smul_of_isCompact hL hK
  choose! g hg using A
  set L : ‚Ñï ‚Üí Set G := fun n => (fun T => T ‚à™ g T ‚Ä¢ K)^[n] K
  have Lcompact : ‚àÄ n, IsCompact (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact hK
    ¬∑ simp_rw [iterate_succ']
      apply IsCompact.union IH (hK.smul (g (L n)))
  have Lclosed : ‚àÄ n, IsClosed (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ simp only [one_mul, Nat.cast_one, iterate_zero, id.def, Nat.zero_eq, Nat.zero_add]
    ¬∑ calc
        Œº (L (n + 1)) = Œº (L n) + Œº (g (L n) ‚Ä¢ K) := by
          simp_rw [iterate_succ']
          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet
        _ = (n + 1 + 1 : ‚Ñï) * Œº K := by
          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]
  have N : Tendsto (fun n => Œº (L n)) atTop (ùìù (‚àû * Œº K)) := by
    simp_rw [M]
    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)
    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)
  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N
  apply top_le_iff.1
  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)","error:  simp made no progress
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.184226 ‚Üí ?m.184226
error:  unsolved goals
case zero
ùïú : Type u_1
G : Type u_2
H : Type u_3
inst‚úù¬π‚Å∞ : MeasurableSpace G
inst‚úù‚Åπ : MeasurableSpace H
inst‚úù‚Å∏ : TopologicalSpace G
inst‚úù‚Å∑ : BorelSpace G
Œº‚úù : Measure G
inst‚úù‚Å∂ : Group G
inst‚úù‚Åµ : TopologicalGroup G
inst‚úù‚Å¥ : Œº‚úù.IsMulLeftInvariant
inst‚úù¬≥ : WeaklyLocallyCompactSpace G
inst‚úù¬≤ : NoncompactSpace G
Œº : Measure G
inst‚úù¬π : Œº.IsOpenPosMeasure
inst‚úù : Œº.IsMulLeftInvariant
K : Set G
K1 : K ‚àà ùìù 1
hK : IsCompact K
Kclosed : IsClosed K
K_pos : 0 < Œº K
g : Set G ‚Üí G
hg : ‚àÄ (L : Set G), IsCompact L ‚Üí Disjoint L (g L ‚Ä¢ K)
L : ‚Ñï ‚Üí Set G := fun n ‚Ü¶ (fun T ‚Ü¶ T ‚à™ g T ‚Ä¢ K)^[n] K
Lcompact : ‚àÄ (n : ‚Ñï), IsCompact (L n)
Lclosed : ‚àÄ (n : ‚Ñï), IsClosed (L n)
‚ä¢ Œº (L 0) = Œº K
error:  simp made no progress","theorem measure_univ_of_isMulLeftInvariant [WeaklyLocallyCompactSpace G] [NoncompactSpace G]
    (Œº : Measure G) [IsOpenPosMeasure Œº] [Œº.IsMulLeftInvariant] : Œº univ = ‚àû ",":= by
  obtain ‚ü®K, K1, hK, Kclosed‚ü© : ‚àÉ K ‚àà ùìù (1 : G), IsCompact K ‚àß IsClosed K :=
    exists_mem_nhds_isCompact_isClosed 1
  have K_pos : 0 < Œº K := measure_pos_of_mem_nhds Œº K1
  have A : ‚àÄ L : Set G, IsCompact L ‚Üí ‚àÉ g : G, Disjoint L (g ‚Ä¢ K) := fun L hL =>
    exists_disjoint_smul_of_isCompact hL hK
  choose! g hg using A
  set L : ‚Ñï ‚Üí Set G := fun n => (fun T => T ‚à™ g T ‚Ä¢ K)^[n] K
  have Lcompact : ‚àÄ n, IsCompact (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact hK
    ¬∑ simp_rw [L, iterate_succ']
      apply IsCompact.union IH (hK.smul (g (L n)))
  have Lclosed : ‚àÄ n, IsClosed (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [L, iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ simp only [L, one_mul, Nat.cast_one, iterate_zero, id, Nat.zero_eq, Nat.zero_add]
    ¬∑ calc
        Œº (L (n + 1)) = Œº (L n) + Œº (g (L n) ‚Ä¢ K) := by
          simp_rw [L, iterate_succ']
          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet
        _ = (n + 1 + 1 : ‚Ñï) * Œº K := by
          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]
  have N : Tendsto (fun n => Œº (L n)) atTop (ùìù (‚àû * Œº K)) := by
    simp_rw [M]
    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)
    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)
  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N
  apply top_le_iff.1
  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)",":= by
  obtain ‚ü®K, K1, hK, Kclosed‚ü© : ‚àÉ K ‚àà ùìù (1 : G), IsCompact K ‚àß IsClosed K :=
    exists_mem_nhds_isCompact_isClosed 1
  have K_pos : 0 < Œº K := measure_pos_of_mem_nhds Œº K1
  have A : ‚àÄ L : Set G, IsCompact L ‚Üí ‚àÉ g : G, Disjoint L (g ‚Ä¢ K) := fun L hL =>
    exists_disjoint_smul_of_isCompact hL hK
  choose! g hg using A
  set L : ‚Ñï ‚Üí Set G := fun n => (fun T => T ‚à™ g T ‚Ä¢ K)^[n] K
  have Lcompact : ‚àÄ n, IsCompact (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact hK
    ¬∑ simp_rw [iterate_succ']
      apply IsCompact.union IH (hK.smul (g (L n)))
  have Lclosed : ‚àÄ n, IsClosed (L n) := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ exact Kclosed
    ¬∑ simp_rw [iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : ‚àÄ n, Œº (L n) = (n + 1 : ‚Ñï) * Œº K := by
    intro n
    induction' n with n IH
    ¬∑ simp only [one_mul, Nat.cast_one, iterate_zero, id, Nat.zero_eq, Nat.zero_add]
    ¬∑ calc
        Œº (L (n + 1)) = Œº (L n) + Œº (g (L n) ‚Ä¢ K) := by
          simp_rw [iterate_succ']
          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet
        _ = (n + 1 + 1 : ‚Ñï) * Œº K := by
          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]
  have N : Tendsto (fun n => Œº (L n)) atTop (ùìù (‚àû * Œº K)) := by
    simp_rw [M]
    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)
    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)
  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N
  apply top_le_iff.1
  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)"
Mathlib/Topology/PartialHomeomorph.lean,PartialHomeomorph.subtypeRestr_symm_eqOn_of_le,subtypeRestr_symm_eqOn_of_le,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  set i := Set.inclusion hUV
  intro y hy
  dsimp [PartialHomeomorph.subtypeRestr_def] at hy ‚ä¢
  have hyV : e.symm y ‚àà (V.partialHomeomorphSubtypeCoe hV).target := by
    rw [Opens.partialHomeomorphSubtypeCoe_target] at hy ‚ä¢
    exact hUV hy.2
  refine (V.partialHomeomorphSubtypeCoe hV).injOn ?_ trivial? _
  ¬∑ rw [‚Üê PartialHomeomorph.symm_target]
    apply PartialHomeomorph.map_source
    rw [PartialHomeomorph.symm_source]
    exact hyV
  ¬∑ rw [(V.partialHomeomorphSubtypeCoe hV).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hy.2]","error:  unknown identifier 'trivial?'
error:  unsolved goals
X : Type u_1
X' : Type u_2
Y : Type u_3
Y' : Type u_4
Z : Type u_5
Z' : Type u_6
inst‚úù‚Åµ : TopologicalSpace X
inst‚úù‚Å¥ : TopologicalSpace X'
inst‚úù¬≥ : TopologicalSpace Y
inst‚úù¬≤ : TopologicalSpace Y'
inst‚úù¬π : TopologicalSpace Z
inst‚úù : TopologicalSpace Z'
e : PartialHomeomorph X Y
s : Opens X
hs : Nonempty ‚Ü•s
U V : Opens X
hU : Nonempty ‚Ü•U
hV : Nonempty ‚Ü•V
hUV : U ‚â§ V
i : ‚Üë‚ÜëU ‚Üí ‚Üë‚ÜëV := inclusion hUV
y : Y
hy : y ‚àà e.target ‚à© ‚Üëe.symm ‚Åª¬π' (U.partialHomeomorphSubtypeCoe hU).target
hyV : ‚Üëe.symm y ‚àà (V.partialHomeomorphSubtypeCoe hV).target
‚ä¢ ‚Üë(V.partialHomeomorphSubtypeCoe hV).symm (‚Üëe.symm y) = i (‚Üë(U.partialHomeomorphSubtypeCoe hU).symm (‚Üëe.symm y))","theorem subtypeRestr_symm_eqOn_of_le {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ‚â§ V) : EqOn (e.subtypeRestr hV).symm (Set.inclusion hUV ‚àò (e.subtypeRestr hU).symm)
      (e.subtypeRestr hU).target ",":= by
  set i := Set.inclusion hUV
  intro y hy
  dsimp [PartialHomeomorph.subtypeRestr_def] at hy ‚ä¢
  have hyV : e.symm y ‚àà (V.partialHomeomorphSubtypeCoe hV).target := by
    rw [Opens.partialHomeomorphSubtypeCoe_target] at hy ‚ä¢
    exact hUV hy.2
  refine (V.partialHomeomorphSubtypeCoe hV).injOn ?_ trivial ?_
  ¬∑ rw [‚Üê PartialHomeomorph.symm_target]
    apply PartialHomeomorph.map_source
    rw [PartialHomeomorph.symm_source]
    exact hyV
  ¬∑ rw [(V.partialHomeomorphSubtypeCoe hV).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hy.2]",":= by
  set i := Set.inclusion hUV
  intro y hy
  dsimp [PartialHomeomorph.subtypeRestr_def] at hy ‚ä¢
  have hyV : e.symm y ‚àà (V.partialHomeomorphSubtypeCoe hV).target := by
    rw [Opens.partialHomeomorphSubtypeCoe_target] at hy ‚ä¢
    exact hUV hy.2
  refine (V.partialHomeomorphSubtypeCoe hV).injOn ?_ trivial
  ¬∑ rw [‚Üê PartialHomeomorph.symm_target]
    apply PartialHomeomorph.map_source
    rw [PartialHomeomorph.symm_source]
    exact hyV
  ¬∑ rw [(V.partialHomeomorphSubtypeCoe hV).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hy.2]"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.tendsto_self_mul_Gamma_nhds_zero,tendsto_self_mul_Gamma_nhds_zero,7dc162787d2a79bf721a83a87f641ace70251b17,":= by
  rw [show ùìù (1 : ‚ÑÇ) = ùìù (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]]
  convert (Tendsto.mono_left _ nhdsWithin_le_nhds).congr'
    (eventuallyEq_of_mem self_mem_nhdsWithin Complex.Gamma_add_one)
  refine' ContinuousAt.comp (g := Gamma) _ (continuous_id.add continuous_const).continuousAt
  refine' (Complex.differentiableAt_Gamma _ fun m => _).continuousAt
  rw [zero_add, ‚Üê ofReal_nat_cast, ‚Üê ofReal_neg, ‚Üê ofReal_one, Ne.def, ofReal_inj]
  refine' (lt_of_le_of_lt _ zero_lt_one).ne'
  exact neg_nonpos.mpr (Nat.cast_nonneg _)","error:  unknown identifier 'ofReal_nat_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.127050
case convert_1
m : ‚Ñï
‚ä¢ 1 ‚â† -‚Üëm",theorem tendsto_self_mul_Gamma_nhds_zero : Tendsto (fun z : ‚ÑÇ => z * Gamma z) (ùìù[‚â†] 0) (ùìù 1) ,":= by
  rw [show ùìù (1 : ‚ÑÇ) = ùìù (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]]
  convert (Tendsto.mono_left _ nhdsWithin_le_nhds).congr'
    (eventuallyEq_of_mem self_mem_nhdsWithin Complex.Gamma_add_one)
  refine ContinuousAt.comp (g := Gamma) ?_ (continuous_id.add continuous_const).continuousAt
  refine (Complex.differentiableAt_Gamma _ fun m => ?_).continuousAt
  rw [zero_add, ‚Üê ofReal_natCast, ‚Üê ofReal_neg, ‚Üê ofReal_one, Ne, ofReal_inj]
  refine (lt_of_le_of_lt ?_ zero_lt_one).ne'
  exact neg_nonpos.mpr (Nat.cast_nonneg _)",":= by
  rw [show ùìù (1 : ‚ÑÇ) = ùìù (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]]
  convert (Tendsto.mono_left _ nhdsWithin_le_nhds).congr'
    (eventuallyEq_of_mem self_mem_nhdsWithin Complex.Gamma_add_one)
  refine ContinuousAt.comp (g := Gamma) ?_ (continuous_id.add continuous_const).continuousAt
  refine (Complex.differentiableAt_Gamma _ fun m => ?_).continuousAt
  rw [zero_add, ‚Üê ofReal_natCast, ‚Üê ofReal_neg, ‚Üê ofReal_one, Ne, ofReal_inj]
  refine (lt_of_le_of_lt ?_ zero_lt_one).ne'
  exact neg_nonpos.mpr (Nat.cast_nonneg _)"
Mathlib/Data/Set/Image.lean,Set.subset_image_diff,subset_image_diff,ea1b2576466eb49ae109b64acf312f52285dafce,":= by
  rw [diff_subset_iff, ‚Üê image_union, union_diff_self]
  exact image_subset f (subset_union_right t s)","error:  application type mismatch
  subset_union_right t
argument
  t
has type
  Set Œ± : Type u_1
but is expected to have type
  ?m.34007 ‚àà ?m.34006 : Prop",theorem subset_image_diff (f : Œ± ‚Üí Œ≤) (s t : Set Œ±) : f '' s \ f '' t ‚äÜ f '' (s \ t) ,":= by
  rw [diff_subset_iff, ‚Üê image_union, union_diff_self]
  exact image_subset f subset_union_right",":= by
  rw [diff_subset_iff, ‚Üê image_union, union_diff_self]
  exact image_subset f subset_union_right"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.sum_weightedHomogeneousComponent,sum_weightedHomogeneousComponent,b271affacf1fa368c4e879d75cd5aaf54b75b7ed,":= by
  classical
  rw [finsum_eq_sum _ (weightedHomogeneousComponent_finsupp œÜ)]
  ext1 d
  simp only [coeff_sum, coeff_weightedHomogeneousComponent]
  rw [Finset.sum_eq_single (weightedDegree' w d)]
  ¬∑ rw [if_pos rfl]
  ¬∑ intro m _ hm'
    rw [if_neg hm'.symm]
  ¬∑ intro hm
    rw [if_pos rfl]
    simp only [Finite.mem_toFinset, mem_support, Ne, Classical.not_not] at hm
    have := coeff_weightedHomogeneousComponent (w := w) (weightedDegree' w d) œÜ d
    rw [hm, if_pos rfl, coeff_zero] at this
    exact this.symm","error:  unknown identifier 'weightedDegree''
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  if ?m.95273 = ?m.95273 then ?m.95275 else ?m.95276
case a
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
n : M
œÜ œà : MvPolynomial œÉ R
d : œÉ ‚Üí‚ÇÄ ‚Ñï
‚ä¢ (if (weightedDegree w) d = sorryAx M true then coeff d œÜ else 0) = coeff d œÜ
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  if ?m.95318 = ?m.95318 then ?m.95320 else ?m.95321
case a.h‚ÇÅ
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
n : M
œÜ œà : MvPolynomial œÉ R
d : œÉ ‚Üí‚ÇÄ ‚Ñï
hm : sorryAx M true ‚àâ ‚ãØ.toFinset
‚ä¢ (if (weightedDegree w) d = sorryAx M true then coeff d œÜ else 0) = 0","theorem sum_weightedHomogeneousComponent :
    (finsum fun m => weightedHomogeneousComponent w m œÜ) = œÜ ",":= by
  classical
  rw [finsum_eq_sum _ (weightedHomogeneousComponent_finsupp œÜ)]
  ext1 d
  simp only [coeff_sum, coeff_weightedHomogeneousComponent]
  rw [Finset.sum_eq_single (weightedDegree w d)]
  ¬∑ rw [if_pos rfl]
  ¬∑ intro m _ hm'
    rw [if_neg hm'.symm]
  ¬∑ intro hm
    rw [if_pos rfl]
    simp only [Finite.mem_toFinset, mem_support, Ne, Classical.not_not] at hm
    have := coeff_weightedHomogeneousComponent (w := w) (weightedDegree w d) œÜ d
    rw [hm, if_pos rfl, coeff_zero] at this
    exact this.symm",":= by
  classical
  rw [finsum_eq_sum _ (weightedHomogeneousComponent_finsupp œÜ)]
  ext1 d
  simp only [coeff_sum, coeff_weightedHomogeneousComponent]
  rw [Finset.sum_eq_single (weightedDegree' w d)]
  ¬∑ rw [if_pos rfl]
  ¬∑ intro m _ hm'
    rw [if_neg hm'.symm]
  ¬∑ intro hm
    rw [if_pos rfl]
    simp only [Finite.mem_toFinset, mem_support, Ne, Classical.not_not] at hm
    have := coeff_weightedHomogeneousComponent (w := w) (weightedDegree' w d) œÜ d
    rw [hm, if_pos rfl, coeff_zero] at this"
Mathlib/Data/Nat/Bitwise.lean,Nat.bitwise_bit',bitwise_bit',3e3c6d9e5921e3d7ea0548c1e05738832f610db4,":= by
  conv_lhs => unfold bitwise
  rw [‚Üêbit_ne_zero_iff] at ham hbn
  simp only [ham, hbn, bit_mod_two_eq_one_iff, Bool.decide_coe, ‚Üê div2_val, div2_bit, ne_eq,
    ite_false]
  conv_rhs => simp only [bit, bit1, bit0, Bool.cond_eq_ite]","warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unsolved goals
f : Bool ‚Üí Bool ‚Üí Bool
a : Bool
m : ‚Ñï
b : Bool
n : ‚Ñï
ham : bit a m ‚â† 0
hbn : bit b n ‚â† 0
‚ä¢ (if f a b = true then bitwise f m n + bitwise f m n + 1 else bitwise f m n + bitwise f m n) =
    (if f a b = true then bit1 else bit0) (bitwise f m n)
warning:  `Nat.mul_lt_mul'` has been deprecated, use `Nat.mul_lt_mul_of_le_of_lt` instead
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated","lemma bitwise_bit' {f : Bool ‚Üí Bool ‚Üí Bool} (a : Bool) (m : Nat) (b : Bool) (n : Nat)
    (ham : m = 0 ‚Üí a = true) (hbn : n = 0 ‚Üí b = true) :
    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) ",":= by
  conv_lhs => unfold bitwise
  rw [‚Üê bit_ne_zero_iff] at ham hbn
  simp only [ham, hbn, bit_mod_two_eq_one_iff, Bool.decide_coe, ‚Üê div2_val, div2_bit, ne_eq,
    ite_false]
  conv_rhs => simp only [bit, bit1, bit0, Bool.cond_eq_ite]
  split_ifs with hf <;> rfl",":= by
  conv_lhs => unfold bitwise
  rw [‚Üê bit_ne_zero_iff] at ham hbn
  simp only [ham, hbn, bit_mod_two_eq_one_iff, Bool.decide_coe, ‚Üê div2_val, div2_bit, ne_eq,
    ite_false]
  conv_rhs => simp only [bit, bit1, bit0, Nat.cond_eq_ite]"
Mathlib/Analysis/Analytic/Composition.lean,FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop,compPartialSumTarget_tendsto_atTop,070b09db52c6f063dd905c04b291f74460734aab,":= by
  apply Monotone.tendsto_atTop_finset
  ¬∑ intro m n hmn a ha
    have : ‚àÄ i, i < m ‚Üí i < n := fun i hi => lt_of_lt_of_le hi hmn
    aesop
  ¬∑ rintro ‚ü®n, c‚ü©
    simp only [mem_compPartialSumTarget_iff]
    obtain ‚ü®n, hn‚ü© : BddAbove ‚Üë(Finset.univ.image fun i : Fin c.length => c.blocksFun i) :=
      Finset.bddAbove _
    refine'
      ‚ü®max n c.length + 1, bot_le, lt_of_le_of_lt (le_max_right n c.length) (lt_add_one _), fun j =>
        lt_of_le_of_lt (le_trans _ (le_max_left _ _)) (lt_add_one _)‚ü©
    apply hn
    simp only [Finset.mem_image_of_mem, Finset.mem_coe, Finset.mem_univ]","error:  type mismatch
  Finset.bddAbove ?m.601694
has type
  BddAbove ‚Üë?m.601694 : Prop
but is expected to have type
  BddAbove ?m.601612 : Prop
warning:  `List.get_splitWrtComposition` has been deprecated, use `List.getElem_splitWrtComposition` instead
warning:  `List.get_drop'` has been deprecated, use `List.getElem_drop'` instead
warning:  `List.get_take'` has been deprecated, use `List.getElem_take` instead","theorem compPartialSumTarget_tendsto_atTop :
    Tendsto (fun N => compPartialSumTarget 0 N N) atTop atTop ",":= by
  apply Monotone.tendsto_atTop_finset
  ¬∑ intro m n hmn a ha
    have : ‚àÄ i, i < m ‚Üí i < n := fun i hi => lt_of_lt_of_le hi hmn
    aesop
  ¬∑ rintro ‚ü®n, c‚ü©
    simp only [mem_compPartialSumTarget_iff]
    obtain ‚ü®n, hn‚ü© : BddAbove ((Finset.univ.image fun i : Fin c.length => c.blocksFun i) : Set ‚Ñï) :=
      Finset.bddAbove _
    refine
      ‚ü®max n c.length + 1, bot_le, lt_of_le_of_lt (le_max_right n c.length) (lt_add_one _), fun j =>
        lt_of_le_of_lt (le_trans ?_ (le_max_left _ _)) (lt_add_one _)‚ü©
    apply hn
    simp only [Finset.mem_image_of_mem, Finset.mem_coe, Finset.mem_univ]",":= by
  apply Monotone.tendsto_atTop_finset
  ¬∑ intro m n hmn a ha
    have : ‚àÄ i, i < m ‚Üí i < n := fun i hi => lt_of_lt_of_le hi hmn
    aesop
  ¬∑ rintro ‚ü®n, c‚ü©
    simp only [mem_compPartialSumTarget_iff]
    obtain ‚ü®n, hn‚ü© : BddAbove ‚Üë(Finset.univ.image fun i : Fin c.length => c.blocksFun i) :=
      Finset.bddAbove _
    refine
      ‚ü®max n c.length + 1, bot_le, lt_of_le_of_lt (le_max_right n c.length) (lt_add_one _), fun j =>
        lt_of_le_of_lt (le_trans ?_ (le_max_left _ _)) (lt_add_one _)‚ü©
    apply hn
    simp only [Finset.mem_image_of_mem, Finset.mem_coe, Finset.mem_univ]"
Mathlib/Data/Finset/Sups.lean,Finset.subset_sups_self,subset_sups_self,1faa648b0b1359dec61956304fa51ac01bdbb219,":= fun _a ha ‚Ü¶ mem_sups.2 ‚ü®_, ha, _, ha, sup_idem‚ü©","error:  application type mismatch
  ‚ü®ha, sup_idem‚ü©
argument
  sup_idem
has type
  ‚àÄ (a : ?m.18364), a ‚äî a = a : Prop
but is expected to have type
  _a ‚äî _a = _a : Prop
warning:  @Finset.disjSups does not have a doc string
warning:  @Finset.diffs does not have a doc string
warning:  @Finset.compls does not have a doc string",lemma subset_sups_self : s ‚äÜ s ‚äª s ,":= fun _a ha ‚Ü¶ mem_sups.2 ‚ü®_, ha, _, ha, sup_idem _‚ü©",":= fun _a ha ‚Ü¶ mem_sups.2 ‚ü®_, ha, _, ha, sup_idem‚ü©"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,cauchy_map_of_uniformCauchySeqOn_fderiv,cauchy_map_of_uniformCauchySeqOn_fderiv,0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":= by
  have : NeBot l := (cauchy_map_iff.1 hfg).1
  let t := { y | y ‚àà s ‚àß Cauchy (map (fun n => f n y) l) }
  suffices H : s ‚äÜ t; exact (H hx).2
  have A : ‚àÄ x Œµ, x ‚àà t ‚Üí Metric.ball x Œµ ‚äÜ s ‚Üí Metric.ball x Œµ ‚äÜ t := fun x Œµ xt hx y hy =>
    ‚ü®hx hy,
      (uniformCauchySeqOn_ball_of_fderiv (hf'.mono hx) (fun n y hy => hf n y (hx hy))
            xt.2).cauchy_map
        hy‚ü©
  have open_t : IsOpen t := by
    rw [Metric.isOpen_iff]
    intro x hx
    rcases Metric.isOpen_iff.1 hs x hx.1 with ‚ü®Œµ, Œµpos, hŒµ‚ü©
    exact ‚ü®Œµ, Œµpos, A x Œµ hx hŒµ‚ü©
  have st_nonempty : (s ‚à© t).Nonempty := ‚ü®x‚ÇÄ, hx‚ÇÄ, ‚ü®hx‚ÇÄ, hfg‚ü©‚ü©
  suffices H : closure t ‚à© s ‚äÜ t; exact h's.subset_of_closure_inter_subset open_t st_nonempty H
  rintro x ‚ü®xt, xs‚ü©
  obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ (Œµ : ‚Ñù), Œµ > 0 ‚àß Metric.ball x Œµ ‚äÜ s := Metric.isOpen_iff.1 hs x xs
  obtain ‚ü®y, yt, hxy‚ü© : ‚àÉ (y : E), y ‚àà t ‚àß dist x y < Œµ / 2 :=
    Metric.mem_closure_iff.1 xt _ (half_pos Œµpos)
  have B : Metric.ball y (Œµ / 2) ‚äÜ Metric.ball x Œµ := by
    apply Metric.ball_subset_ball'; rw [dist_comm]; linarith
  exact A y (Œµ / 2) yt (B.trans hŒµ) (Metric.mem_ball.2 hxy)",error:  unexpected token ';'; expected 'by' or 'from',"theorem cauchy_map_of_uniformCauchySeqOn_fderiv {s : Set E} (hs : IsOpen s) (h's : IsPreconnected s)
    (hf' : UniformCauchySeqOn f' l s) (hf : ‚àÄ n : Œπ, ‚àÄ y : E, y ‚àà s ‚Üí HasFDerivAt (f n) (f' n y) y)
    {x‚ÇÄ x : E} (hx‚ÇÄ : x‚ÇÄ ‚àà s) (hx : x ‚àà s) (hfg : Cauchy (map (fun n => f n x‚ÇÄ) l)) :
    Cauchy (map (fun n => f n x) l) ",":= by
  have : NeBot l := (cauchy_map_iff.1 hfg).1
  let t := { y | y ‚àà s ‚àß Cauchy (map (fun n => f n y) l) }
  suffices H : s ‚äÜ t from (H hx).2
  have A : ‚àÄ x Œµ, x ‚àà t ‚Üí Metric.ball x Œµ ‚äÜ s ‚Üí Metric.ball x Œµ ‚äÜ t := fun x Œµ xt hx y hy =>
    ‚ü®hx hy,
      (uniformCauchySeqOn_ball_of_fderiv (hf'.mono hx) (fun n y hy => hf n y (hx hy))
            xt.2).cauchy_map
        hy‚ü©
  have open_t : IsOpen t := by
    rw [Metric.isOpen_iff]
    intro x hx
    rcases Metric.isOpen_iff.1 hs x hx.1 with ‚ü®Œµ, Œµpos, hŒµ‚ü©
    exact ‚ü®Œµ, Œµpos, A x Œµ hx hŒµ‚ü©
  have st_nonempty : (s ‚à© t).Nonempty := ‚ü®x‚ÇÄ, hx‚ÇÄ, ‚ü®hx‚ÇÄ, hfg‚ü©‚ü©
  suffices H : closure t ‚à© s ‚äÜ t from h's.subset_of_closure_inter_subset open_t st_nonempty H
  rintro x ‚ü®xt, xs‚ü©
  obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ (Œµ : ‚Ñù), Œµ > 0 ‚àß Metric.ball x Œµ ‚äÜ s := Metric.isOpen_iff.1 hs x xs
  obtain ‚ü®y, yt, hxy‚ü© : ‚àÉ (y : E), y ‚àà t ‚àß dist x y < Œµ / 2 :=
    Metric.mem_closure_iff.1 xt _ (half_pos Œµpos)
  have B : Metric.ball y (Œµ / 2) ‚äÜ Metric.ball x Œµ := by
    apply Metric.ball_subset_ball'; rw [dist_comm]; linarith
  exact A y (Œµ / 2) yt (B.trans hŒµ) (Metric.mem_ball.2 hxy)",":= by
  have : NeBot l := (cauchy_map_iff.1 hfg).1
  let t := { y | y ‚àà s ‚àß Cauchy (map (fun n => f n y) l) }
  suffices H : s ‚äÜ t; exact (H hx).2
  have A : ‚àÄ x Œµ, x ‚àà t ‚Üí Metric.ball x Œµ ‚äÜ s ‚Üí Metric.ball x Œµ ‚äÜ t := fun x Œµ xt hx y hy =>
    ‚ü®hx hy,
      (uniformCauchySeqOn_ball_of_fderiv (hf'.mono hx) (fun n y hy => hf n y (hx hy))
           xt.2).cauchy_map
        hy‚ü©
  have open_t : IsOpen t := by
    rw [Metric.isOpen_iff]
    intro x hx
    rcases Metric.isOpen_iff.1 hs x hx.1 with ‚ü®Œµ, Œµpos, hŒµ‚ü©
    exact ‚ü®Œµ, Œµpos, A x Œµ hx hŒµ‚ü©
  have st_nonempty : (s ‚à© t).Nonempty := ‚ü®x‚ÇÄ, hx‚ÇÄ, ‚ü®hx‚ÇÄ, hfg‚ü©‚ü©
  suffices H : closure t ‚à© s ‚äÜ t; exact h's.subset_of_closure_inter_subset open_t st_nonempty H
  rintro x ‚ü®xt, xs‚ü©
  obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ (Œµ : ‚Ñù), Œµ > 0 ‚àß Metric.ball x Œµ ‚äÜ s := Metric.isOpen_iff.1 hs x xs
  obtain ‚ü®y, yt, hxy‚ü© : ‚àÉ (y : E), y ‚àà t ‚àß dist x y < Œµ / 2 :=
    Metric.mem_closure_iff.1 xt _ (half_pos Œµpos)
  have B : Metric.ball y (Œµ / 2) ‚äÜ Metric.ball x Œµ := by
    apply Metric.ball_subset_ball'; rw [dist_comm]; linarith
  exact A y (Œµ / 2) yt (B.trans hŒµ) (Metric.mem_ball.2 hxy)"
Mathlib/NumberTheory/LucasPrimality.lean,lucas_primality,lucas_primality,d7eb868c7c00f4e5aaecec47c00a11aeefaceedb,":= by
  have h0 : p ‚â† 0 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have h1 : p ‚â† 1 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have hp1 : 1 < p := lt_of_le_of_ne h0.bot_lt h1.symm
  have order_of_a : orderOf a = p - 1 := by
    apply orderOf_eq_of_pow_and_pow_div_prime _ ha hd
    exact tsub_pos_of_lt hp1
  haveI : NeZero p := ‚ü®h0‚ü©
  rw [Nat.prime_iff_card_units]
  refine' le_antisymm (Nat.card_units_zmod_lt_sub_one hp1) _
  have hp' : p - 2 + 1 = p - 1 := tsub_add_eq_add_tsub hp1
  let a' : (ZMod p)À£ := Units.mkOfMulEqOne a (a ^ (p - 2)) (by rw [‚Üê pow_succ, hp', ha])
  calc
    p - 1 = orderOf a := order_of_a.symm
    _ = orderOf a' := (orderOf_injective (Units.coeHom (ZMod p)) Units.ext a')
    _ ‚â§ Fintype.card (ZMod p)À£ := orderOf_le_card_univ","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a ^ ?n * ?a
p : ‚Ñï
a : ZMod p
ha : a ^ (p - 1) = 1
hd : ‚àÄ (q : ‚Ñï), Nat.Prime q ‚Üí q ‚à£ p - 1 ‚Üí a ^ ((p - 1) / q) ‚â† 1
h0 : p ‚â† 0
h1 : p ‚â† 1
hp1 : 1 < p
order_of_a : orderOf a = p - 1
this : NeZero p
hp' : p - 2 + 1 = p - 1
‚ä¢ a * a ^ (p - 2) = 1","theorem lucas_primality (p : ‚Ñï) (a : ZMod p) (ha : a ^ (p - 1) = 1)
    (hd : ‚àÄ q : ‚Ñï, q.Prime ‚Üí q ‚à£ p - 1 ‚Üí a ^ ((p - 1) / q) ‚â† 1) : p.Prime ",":= by
  have h0 : p ‚â† 0 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have h1 : p ‚â† 1 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have hp1 : 1 < p := lt_of_le_of_ne h0.bot_lt h1.symm
  have order_of_a : orderOf a = p - 1 := by
    apply orderOf_eq_of_pow_and_pow_div_prime _ ha hd
    exact tsub_pos_of_lt hp1
  haveI : NeZero p := ‚ü®h0‚ü©
  rw [Nat.prime_iff_card_units]
  refine le_antisymm (Nat.card_units_zmod_lt_sub_one hp1) ?_
  have hp' : p - 2 + 1 = p - 1 := tsub_add_eq_add_tsub hp1
  let a' : (ZMod p)À£ := Units.mkOfMulEqOne a (a ^ (p - 2)) (by rw [‚Üê pow_succ', hp', ha])
  calc
    p - 1 = orderOf a := order_of_a.symm
    _ = orderOf a' := (orderOf_injective (Units.coeHom (ZMod p)) Units.ext a')
    _ ‚â§ Fintype.card (ZMod p)À£ := orderOf_le_card_univ",":= by
  have h0 : p ‚â† 0 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have h1 : p ‚â† 1 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have h1 : p ‚â† 1 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have hp1 : 1 < p := lt_of_le_of_ne h0.bot_lt h1.symm
  have order_of_a : orderOf a = p - 1 := by
    apply orderOf_eq_of_pow_and_pow_div_prime _ ha hd
    exact tsub_pos_of_lt hp1
  haveI : NeZero p := ‚ü®h0‚ü©
  rw [Nat.prime_iff_card_units]
  refine le_antisymm (Nat.card_units_zmod_lt_sub_one hp1) ?_
  have hp' : p - 2 + 1 = p - 1 := tsub_add_eq_add_tsub hp1
  let a' : (ZMod p)À£ := Units.mkOfMulEqOne a (a ^ (p - 2)) (by rw [‚Üê pow_succ, hp', ha])
  calc
    p - 1 = orderOf a := order_of_a.symm
    _ = orderOf a' := (orderOf_injective (Units.coeHom (ZMod p)) Units.ext a')
    _ ‚â§ Fintype.card (ZMod p)À£ := orderOf_le_card_univ"
Mathlib/CategoryTheory/Abelian/RightDerived.lean,CategoryTheory.Functor.rightDerived_map_eq,Functor.rightDerived_map_eq,59656d871b75b8384364dfe02f1d82e5419c6d62,":= by
  rw [‚Üê cancel_mono (Q.isoRightDerivedObj F n).hom,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id]
  rw [‚Üê HomologicalComplex.comp_f, w, HomologicalComplex.comp_f,
    CochainComplex.single‚ÇÄ_map_f_0]","error:  unknown constant 'CochainComplex.single‚ÇÄ_map_f_0'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.40684
C : Type u
inst‚úù‚Åµ : Category.{v, u} C
D : Type u_1
inst‚úù‚Å¥ : Category.{u_2, u_1} D
inst‚úù¬≥ : Abelian C
inst‚úù¬≤ : HasInjectiveResolutions C
inst‚úù¬π : Abelian D
F : C ‚•§ D
inst‚úù : F.Additive
n : ‚Ñï
X Y : C
f : X ‚ü∂ Y
P : InjectiveResolution X
Q : InjectiveResolution Y
g : P.cocomplex ‚ü∂ Q.cocomplex
w : P.Œπ ‚â´ g = (CochainComplex.single‚ÇÄ C).map f ‚â´ Q.Œπ
‚ä¢ ((CochainComplex.single‚ÇÄ C).map f).f 0 ‚â´ Q.Œπ.f 0 = f ‚â´ Q.Œπ.f 0","theorem Functor.rightDerived_map_eq (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) {X Y : C} (f : X ‚ü∂ Y)
    {P : InjectiveResolution X} {Q : InjectiveResolution Y} (g : P.cocomplex ‚ü∂ Q.cocomplex)
    (w : P.Œπ ‚â´ g = (CochainComplex.single‚ÇÄ C).map f ‚â´ Q.Œπ) :
    (F.rightDerived n).map f =
      (P.isoRightDerivedObj F n).hom ‚â´
        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map g ‚â´
          (Q.isoRightDerivedObj F n).inv ",":= by
  rw [‚Üê cancel_mono (Q.isoRightDerivedObj F n).hom,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    assoc, assoc, Iso.inv_hom_id, comp_id]
  rw [‚Üê HomologicalComplex.comp_f, w, HomologicalComplex.comp_f,
    CochainComplex.single‚ÇÄ_map_f_zero]",":= by
  rw [‚Üê cancel_mono (Q.isoRightDerivedObj F n).hom,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id]
  rw [‚Üê HomologicalComplex.comp_f, w, HomologicalComplex.comp_f,
    CochainComplex.single‚ÇÄ_map_f_0]"
Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean,FiniteField.isSquare_neg_one_iff,FiniteField.isSquare_neg_one_iff,66c0098b0b62ad14d9c618b402e7673658137a7e,":= by
  classical 
  by_cases hF : ringChar F = 2
  ¬∑ simp only [FiniteField.isSquare_of_char_two hF, Ne.def, true_iff_iff]
    exact fun hf =>
      one_ne_zero <|
        (Nat.odd_of_mod_four_eq_three hf).symm.trans <| FiniteField.even_card_of_char_two hF
  ¬∑ have h‚ÇÅ := FiniteField.odd_card_of_char_ne_two hF
    rw [‚Üê quadraticChar_one_iff_isSquare (neg_ne_zero.mpr (one_ne_zero' F)),
      quadraticChar_neg_one hF, œá‚ÇÑ_nat_eq_if_mod_four, h‚ÇÅ]
    simp only [Nat.one_ne_zero, if_false, ite_eq_left_iff, Ne.def, (by decide : (-1 : ‚Ñ§) ‚â† 1),
      imp_false, Classical.not_not]
    exact
      ‚ü®fun h => ne_of_eq_of_ne h (by decide : 1 ‚â† 3), Or.resolve_right (Nat.odd_mod_four_iff.mp h‚ÇÅ)‚ü©","warning:  `MulChar.IsNontrivial` has been deprecated
warning:  `MulChar.isNontrivial_iff` has been deprecated
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.46477 ‚Üí ?m.46477 ‚Üí Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.48605 ‚Üí ?m.48605 ‚Üí Prop",theorem FiniteField.isSquare_neg_one_iff : IsSquare (-1 : F) ‚Üî Fintype.card F % 4 ‚â† 3 ,":= by
  classical 
  by_cases hF : ringChar F = 2
  ¬∑ simp only [FiniteField.isSquare_of_char_two hF, Ne, true_iff_iff]
    exact fun hf ‚Ü¶
      one_ne_zero <|
        (Nat.odd_of_mod_four_eq_three hf).symm.trans <| FiniteField.even_card_of_char_two hF
  ¬∑ have h‚ÇÅ := FiniteField.odd_card_of_char_ne_two hF
    rw [‚Üê quadraticChar_one_iff_isSquare (neg_ne_zero.mpr (one_ne_zero' F)),
      quadraticChar_neg_one hF, œá‚ÇÑ_nat_eq_if_mod_four, h‚ÇÅ]
    simp only [Nat.one_ne_zero, if_false, ite_eq_left_iff, (by omega : (-1 : ‚Ñ§) ‚â† 1), imp_false,
      not_not, Ne]
    exact ‚ü®fun h ‚Ü¶ ne_of_eq_of_ne h (by omega), (Nat.odd_mod_four_iff.mp h‚ÇÅ).resolve_right‚ü©",":= by
  classical 
  by_cases hF : ringChar F = 2
  ¬∑ simp only [FiniteField.isSquare_of_char_two hF, Ne, true_iff_iff]
    exact fun hf =>
      one_ne_zero <|
        (Nat.odd_of_mod_four_eq_three hf).symm.trans <| FiniteField.even_card_of_char_two hF
  ¬∑ have h‚ÇÅ := FiniteField.odd_card_of_char_ne_two hF
    rw [‚Üê quadraticChar_one_iff_isSquare (neg_ne_zero.mpr (one_ne_zero' F)),
      quadraticChar_neg_one hF, œá‚ÇÑ_nat_eq_if_mod_four, h‚ÇÅ]
    simp only [Nat.one_ne_zero, if_false, ite_eq_left_iff, Ne, (by decide : (-1 : ‚Ñ§) ‚â† 1),
      imp_false, Classical.not_not]
    exact
      ‚ü®fun h => ne_of_eq_of_ne h (by decide : 1 ‚â† 3), Or.resolve_right (Nat.odd_mod_four_iff.mp h‚ÇÅ)‚ü©"
Mathlib/Analysis/SpecialFunctions/Integrals.lean,intervalIntegral.intervalIntegrable_rpow',intervalIntegrable_rpow',a6271c402acd28c481f9bf48ab7b20cbe549e2e2,":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg_of_nonneg hx.1.le
    ¬∑ refine' (continuousOn_id.rpow_const _).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine' m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply _, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]","error:  no goals to be solved
warning:  `rpow_nonneg_of_nonneg` has been deprecated, use `Real.rpow_nonneg` instead","theorem intervalIntegrable_rpow' {r : ‚Ñù} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg_of_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const _).div_const ?_; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply _, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]"
Mathlib/Topology/Sheaves/SheafCondition/UniqueGluing.lean,TopCat.Presheaf.isSheaf_of_isSheafUniqueGluing_types,isSheaf_of_isSheafUniqueGluing_types,6fc8e6ec44a01eed01778e1f6cfe13cab42118b2,":= by
  rw [isSheaf_iff_isSheafEqualizerProducts]
  intro Œπ U
  refine' ‚ü®Fork.IsLimit.mk' _ _‚ü©
  intro s
  have h_compatible :
    ‚àÄ x : s.pt, F.IsCompatible U (piOpensIsoSectionsFamily F U (s.Œπ x)) := by
    intro x
    rw [compatible_iff_leftRes_eq_rightRes]
    convert congr_fun s.condition x
  choose m m_spec m_uniq using fun x : s.pt =>
    Fsh U (piOpensIsoSectionsFamily F U (s.Œπ x)) (h_compatible x)
  refine' ‚ü®m, _, _‚ü©
  ¬∑ 
    refine limit.hom_ext fun ‚ü®i‚ü© => funext fun x => ?_
    simp only [Discrete.functor_obj, Functor.const_obj_obj, fork_pt, parallelPair_obj_zero, fork_Œπ,
      res._eq_1, types_comp_apply, Types.pi_lift_œÄ_apply]
    simpa using m_spec x i
  ¬∑ intro l hl
    ext x
    apply m_uniq
    rw [isGluing_iff_eq_res]
    exact congr_fun hl x","error:  unknown identifier 'isSheaf_iff_isSheafEqualizerProducts'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.14468
C : Type u
inst‚úù¬π : Category.{v, u} C
inst‚úù : ConcreteCategory C
X : TopCat
F : Presheaf (Type u) X
Œπ : Type x
U : Œπ ‚Üí Opens ‚ÜëX
Fsh : F.IsSheafUniqueGluing
‚ä¢ F.IsSheaf",theorem isSheaf_of_isSheafUniqueGluing_types (Fsh : F.IsSheafUniqueGluing) : F.IsSheaf ,":=
  (isSheaf_iff_isSheafUniqueGluing_types F).mpr Fsh",":= by
  rw [isSheaf_iff_isSheafEqualizerProducts]
  intro Œπ U
  refine ‚ü®Fork.IsLimit.mk' _ ?_‚ü©
  intro s
  have h_compatible :
    ‚àÄ x : s.pt, F.IsCompatible U (piOpensIsoSectionsFamily F U (s.Œπ x)) := by
    intro x
    rw [compatible_iff_leftRes_eq_rightRes]
    convert congr_fun s.condition x
  choose m m_spec m_uniq using fun x : s.pt =>
    Fsh U (piOpensIsoSectionsFamily F U (s.Œπ x)) (h_compatible x)
  refine ‚ü®m, ?_, ?_‚ü©
  ¬∑ 
    refine limit.hom_ext fun ‚ü®i‚ü© => funext fun x => ?_
    simp only [Discrete.functor_obj, Functor.const_obj_obj, fork_pt, parallelPair_obj_zero, fork_Œπ,
      res._eq_1, types_comp_apply, Types.pi_lift_œÄ_apply]
    simpa using m_spec x i
  ¬∑ intro l hl
    ext x
    apply m_uniq
    rw [isGluing_iff_eq_res]
    exact congr_fun hl x"
Mathlib/Algebra/BigOperators/Ring/Multiset.lean,Multiset.prod_map_add,prod_map_add,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine s.induction_on ?_ fun a s ih ‚Ü¶ ?_
  ¬∑ simp only [map_zero, prod_zero, antidiagonal_zero, map_singleton, mul_one, sum_singleton]
  ¬∑ simp only [map_cons, prod_cons, ih, sum_map_mul_left.symm, add_mul, mul_left_comm (f a),
      mul_left_comm (g a), sum_map_add, antidiagonal_cons, Prod_map, id_eq, map_add, map_map,
      Function.comp_apply, mul_assoc, sum_add]
    exact add_comm _ _","warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  typeclass instance problem is stuck, it is often due to metavariables
  AddCommMagma ?m.13262","lemma prod_map_add {s : Multiset Œπ} {f g : Œπ ‚Üí Œ±} :
    prod (s.map fun i ‚Ü¶ f i + g i) =
      sum ((antidiagonal s).map fun p ‚Ü¶ (p.1.map f).prod * (p.2.map g).prod) ",":= by
  refine s.induction_on ?_ fun a s ih ‚Ü¶ ?_
  ¬∑ simp only [map_zero, prod_zero, antidiagonal_zero, map_singleton, mul_one, sum_singleton]
  ¬∑ simp only [map_cons, prod_cons, ih, sum_map_mul_left.symm, add_mul, mul_left_comm (f a),
      mul_left_comm (g a), sum_map_add, antidiagonal_cons, Prod.map_fst, Prod.map_snd,
      id_eq, map_add, map_map, Function.comp_apply, mul_assoc, sum_add]
    exact add_comm _ _",":= by
  refine s.induction_on ?_ fun a s ih ‚Ü¶ ?_
  ¬∑ simp only [map_zero, prod_zero, antidiagonal_zero, map_singleton, mul_one, sum_singleton]
  ¬∑ simp only [map_cons, prod_cons, ih, sum_map_mul_left.symm, add_mul, mul_left_comm (f a),
      mul_left_comm (g a), sum_map_add, antidiagonal_cons, Prod.map, id_eq, map_add, map_map,
      Function.comp_apply, mul_assoc, sum_add]
    exact add_comm _ _"
Mathlib/Topology/Category/Profinite/Nobeling.lean,Profinite.Nobeling.embedding,Nobeling.embedding,e194c75699f5107c3020dd83bb1dc00cf62f62aa,":= by
  apply Continuous.closedEmbedding
  ¬∑ dsimp [Œπ]
    refine continuous_pi ?_
    intro C
    rw [‚Üê IsLocallyConstant.iff_continuous]
    refine ((IsLocallyConstant.tfae _).out 0 3).mpr ?_
    rintro ‚ü®‚ü©
    ¬∑ refine IsClopen.isOpen (isClopen_compl_iff.mp ?_)
      convert C.2
      ext x
      simp only [Set.mem_compl_iff, Set.mem_preimage, Set.mem_singleton_iff,
        decide_eq_false_iff_not, not_not]
    ¬∑ refine IsClopen.isOpen ?_
      convert C.2
      ext x
      simp only [Set.mem_preimage, Set.mem_singleton_iff, decide_eq_true_eq]
  ¬∑ intro a b h
    by_contra hn
    obtain ‚ü®C, hC, hh‚ü© := exists_clopen_of_totally_separated hn
    apply hh.2 ‚àò of_decide_eq_true
    dsimp [Œπ] at h
    rw [‚Üê congr_fun h ‚ü®C, hC‚ü©]
    exact decide_eq_true hh.1","error:  unsolved goals
case h.e'_3.h
S : Profinite
C : { C // IsClopen C }
x : ‚ÜëS.toCompHaus.toTop
‚ä¢ ¬¨Œπ S x C = false ‚Üî x ‚àà ‚ÜëC
error:  unsolved goals
case h.e'_3.h
S : Profinite
C : { C // IsClopen C }
x : ‚ÜëS.toCompHaus.toTop
‚ä¢ Œπ S x C = true ‚Üî x ‚àà ‚ÜëC
error:  unknown identifier 'exists_clopen_of_totally_separated'
error:  rcases tactic failed: x‚úù : ?m.585776 is not an inductive datatype",theorem Nobeling.embedding : ClosedEmbedding (Nobeling.Œπ S) ,":= by
  apply Continuous.closedEmbedding
  ¬∑ dsimp (config := { unfoldPartialApp := true }) [Œπ]
    refine continuous_pi ?_
    intro C
    rw [‚Üê IsLocallyConstant.iff_continuous]
    refine ((IsLocallyConstant.tfae _).out 0 3).mpr ?_
    rintro ‚ü®‚ü©
    ¬∑ refine IsClopen.isOpen (isClopen_compl_iff.mp ?_)
      convert C.2
      ext x
      simp only [Set.mem_compl_iff, Set.mem_preimage, Set.mem_singleton_iff,
        decide_eq_false_iff_not, not_not]
    ¬∑ refine IsClopen.isOpen ?_
      convert C.2
      ext x
      simp only [Set.mem_preimage, Set.mem_singleton_iff, decide_eq_true_eq]
  ¬∑ intro a b h
    by_contra hn
    obtain ‚ü®C, hC, hh‚ü© := exists_isClopen_of_totally_separated hn
    apply hh.2 ‚àò of_decide_eq_true
    dsimp (config := { unfoldPartialApp := true }) [Œπ] at h
    rw [‚Üê congr_fun h ‚ü®C, hC‚ü©]
    exact decide_eq_true hh.1",":= by
  apply Continuous.closedEmbedding
  ¬∑ dsimp [Œπ]
    refine continuous_pi ?_
    intro C
    rw [‚Üê IsLocallyConstant.iff_continuous]
    refine ((IsLocallyConstant.tfae _).out 0 3).mpr ?_
    rintro ‚ü®‚ü©
    ¬∑ refine IsClopen.isOpen (isClopen_compl_iff.mp ?_)
      convert C.2
      ext x
      simp only [Set.mem_compl_iff, Set.mem_preimage, Set.mem_singleton_iff, decide_eq_true_eq]
  ¬∑ intro a b h
    by_contra hn
    obtain ‚ü®C, hC, hh‚ü© := exists_clopen_of_totally_separated hn
    apply hh.2 ‚àò of_decide_eq_true
    dsimp [Œπ] at h
    rw [‚Üê congr_fun h ‚ü®C, hC‚ü©]
    exact decide_eq_true hh.1"
Mathlib/Computability/Primrec.lean,Primrec.nat_casesOn,nat_casesOn,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  nat_rec hf (hg.comp‚ÇÇ fst <| comp fst snd).to‚ÇÇ","error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ hg fst
argument
  fst
has type
  Primrec Prod.fst : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.76368 : Prop","theorem nat_casesOn' {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí ‚Ñï ‚Üí Œ≤} (hf : Primrec f) (hg : Primrec‚ÇÇ g) :
    Primrec‚ÇÇ fun a (n : ‚Ñï) => (n.casesOn (f a) (g a) : Œ≤) ",":=
  nat_rec hf <| hg.comp‚ÇÇ Primrec‚ÇÇ.left <| comp‚ÇÇ fst Primrec‚ÇÇ.right",":=
  nat_rec hf (hg.comp‚ÇÇ fst <| comp fst snd)"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.zero_update,zero_update,67e80fd089fe45abea632652c43b78eba72d60e3,":= by
  ext
  rw [single_eq_update]
  rfl","warning:  Finsupp does not have a doc string
error:  failed to synthesize
  DecidableEq Œ±
use `set_option diagnostics true` to get diagnostic information",theorem zero_update : update 0 a b = single a b ,":= by
  classical
    ext
    rw [single_eq_update]
    rfl",":= by
  rw [single_eq_update]
  rfl"
Mathlib/Analysis/LocallyConvex/Bounded.lean,Bornology.isVonNBounded_covers,isVonNBounded_covers,fce7faeae2bd16f268cd47d7cd0fceb445a4d5ac,":=
  Set.eq_univ_iff_forall.mpr fun x =>
    Set.mem_union‚Çõ.mpr ‚ü®{x}, isVonNBounded_singleton _, Set.mem_singleton _‚ü©",error:  unknown constant 'Set.mem_union‚Çõ.mpr',theorem isVonNBounded_covers : ‚ãÉ‚ÇÄ setOf (IsVonNBounded ùïú) = (Set.univ : Set E) ,":=
  Set.eq_univ_iff_forall.mpr fun x =>
    Set.mem_sUnion.mpr ‚ü®{x}, isVonNBounded_singleton _, Set.mem_singleton _‚ü©",":=
  Set.eq_univ_iff_forall.mpr fun x =>
    Set.mem_union.mpr ‚ü®{x}, isVonNBounded_singleton _, Set.mem_singleton _‚ü©"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,9f377843ae74f8ea35a167e1fcc7752e1a90722a,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Module.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg ((¬∑ * ¬∑) œÅ) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Module.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_o"
Mathlib/Topology/Algebra/Algebra.lean,continuous_algebraMap,continuous_algebraMap,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine' ‚ü®fun h => _, fun h => _‚ü©
  ¬∑ simp only [Algebra.smul_def]
    exact (h.comp continuous_fst).mul continuous_snd
  ¬∑ rw [algebraMap_eq_smul_one']
    exact h.comp (continuous_id.prod_mk continuous_const)","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  ‚àÄ (s : Set A), IsOpen s ‚Üí IsOpen (‚áë(algebraMap R A) ‚Åª¬π' s)
error:  no goals to be solved",theorem continuous_algebraMap [ContinuousSMul R A] : Continuous (algebraMap R A) ,":= by
  rw [algebraMap_eq_smul_one']
  exact continuous_id.smul continuous_const",":= by
  refine ‚ü®fun h => ?_, fun h => ?_‚ü©
  ¬∑ simp only [Algebra.smul_def]
    exact (h.comp continuous_fst).mul continuous_snd
  ¬∑ rw [algebraMap_eq_smul_one']
    exact h.comp continuous_id.prod_mk continuous_const"
Mathlib/CategoryTheory/Limits/Final.lean,CategoryTheory.Functor.initial_of_adjunction,initial_of_adjunction,c27ed32d370b030de9da7574fb6ad900747de344,":=
  {
    out := fun d =>
      let u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)
      @zigzag_isConnected _ _ ‚ü®u‚ü© fun f g =>
        Relation.ReflTransGen.trans
          (Relation.ReflTransGen.single
            (show Zag f u from
              Or.inl ‚ü®CostructuredArrow.homMk (adj.homEquiv f.left d f.hom) (by simp)‚ü©))
          (Relation.ReflTransGen.single
            (show Zag u g from
              Or.inr ‚ü®CostructuredArrow.homMk (adj.homEquiv g.left d g.hom) (by simp)‚ü©)) }","error:  unsolved goals
C : Type u‚ÇÅ
inst‚úù¬π : Category.{v‚ÇÅ, u‚ÇÅ} C
D : Type u‚ÇÇ
inst‚úù : Category.{v‚ÇÇ, u‚ÇÇ} D
L : C ‚•§ D
R : D ‚•§ C
adj : L ‚ä£ R
d : D
u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)
f g : CostructuredArrow L d
‚ä¢ L.map (adj.unit.app f.left) ‚â´ L.map (R.map f.hom) ‚â´ u.hom = f.hom
error:  unsolved goals
C : Type u‚ÇÅ
inst‚úù¬π : Category.{v‚ÇÅ, u‚ÇÅ} C
D : Type u‚ÇÇ
inst‚úù : Category.{v‚ÇÇ, u‚ÇÇ} D
L : C ‚•§ D
R : D ‚•§ C
adj : L ‚ä£ R
d : D
u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)
f g : CostructuredArrow L d
‚ä¢ L.map (adj.unit.app g.left) ‚â´ L.map (R.map g.hom) ‚â´ u.hom = g.hom",theorem initial_of_adjunction {L : C ‚•§ D} {R : D ‚•§ C} (adj : L ‚ä£ R) : Initial L ,":=
  { out := fun d =>
      let u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)
      @zigzag_isConnected _ _ ‚ü®u‚ü© fun f g =>
        Relation.ReflTransGen.trans
          (Relation.ReflTransGen.single
            (show Zag f u from
              Or.inl ‚ü®CostructuredArrow.homMk (adj.homEquiv f.left d f.hom) (by simp [u])‚ü©))
          (Relation.ReflTransGen.single
            (show Zag u g from
              Or.inr ‚ü®CostructuredArrow.homMk (adj.homEquiv g.left d g.hom) (by simp [u])‚ü©)) }",":=
  {
    out := fun d =>
      let u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)
      @zigzag_isConnected _ _ ‚ü®u‚ü© fun f g =>
        Relation.ReflTransGen.trans
           (Relation.ReflTransGen.single
             (show Zag f u from
              Or.inl ‚ü®CostructuredArrow.homMk (adj.homEquiv f.left d f.hom) (by simp)‚ü©))
          (Relation.ReflTransGen.single
            (show Zag u g from
              Or.inl ‚ü®CostructuredArrow.homMk (adj.homEquiv f.left d f.hom) (by simp)‚ü©))
          (Relation.ReflTransGen.single
             (show Zag u g from
             Or.inr ‚ü®CostructuredArrow.homMk (adj.homEquiv g.left d g.hom) (by simp)‚ü©)) }"
Mathlib/RingTheory/RootsOfUnity/Minpoly.lean,IsPrimitiveRoot.separable_minpoly_mod,separable_minpoly_mod,9e34a191034458a56331f976ff7400a26407c888,":= by
  have hdvd : map (Int.castRingHom (ZMod p)) (minpoly ‚Ñ§ Œº) ‚à£ X ^ n - 1 := by
    simp [Polynomial.map_pow, map_X, Polynomial.map_one, Polynomial.map_sub]
    convert RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p)))
        (minpoly_dvd_x_pow_sub_one h)
    simp only [map_sub, map_pow, coe_mapRingHom, map_X, map_one]
  refine' Separable.of_dvd (separable_X_pow_sub_C 1 _ one_ne_zero) hdvd
  by_contra hzero
  exact hdiv ((ZMod.nat_cast_zmod_eq_zero_iff_dvd n p).1 hzero)","error:  simp made no progress
warning:  `ZMod.nat_cast_zmod_eq_zero_iff_dvd` has been deprecated, use `ZMod.natCast_zmod_eq_zero_iff_dvd` instead
error:  application type mismatch
  separable_minpoly_mod h
argument
  h
has type
  IsPrimitiveRoot Œº n : Prop
but is expected to have type
  ¬¨?m.13675 ‚à£ ?m.13671 : Prop
error:  application type mismatch
  squarefree_minpoly_mod h
argument
  h
has type
  IsPrimitiveRoot Œº n : Prop
but is expected to have type
  ¬¨?m.25210 ‚à£ ?m.25206 : Prop
error:  application type mismatch
  minpoly_dvd_mod_p h
argument
  h
has type
  IsPrimitiveRoot Œº n : Prop
but is expected to have type
  ¬¨?m.35437 ‚à£ ?m.35433 : Prop
error:  rcases tactic failed: x‚úù : ?m.35772 is not an inductive datatype","theorem separable_minpoly_mod {p : ‚Ñï} [Fact p.Prime] (hdiv : ¬¨p ‚à£ n) :
    Separable (map (Int.castRingHom (ZMod p)) (minpoly ‚Ñ§ Œº)) ",":= by
  have hdvd : map (Int.castRingHom (ZMod p)) (minpoly ‚Ñ§ Œº) ‚à£ X ^ n - 1 := by
    convert RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p)))
        (minpoly_dvd_x_pow_sub_one h)
    simp only [map_sub, map_pow, coe_mapRingHom, map_X, map_one]
  refine Separable.of_dvd (separable_X_pow_sub_C 1 ?_ one_ne_zero) hdvd
  by_contra hzero
  exact hdiv ((ZMod.natCast_zmod_eq_zero_iff_dvd n p).1 hzero)",":= by
  have hdvd : map (Int.castRingHom (ZMod p)) (minpoly ‚Ñ§ Œº) ‚à£ X ^ n - 1 := by
    simp [Polynomial.map_pow, map_X, Polynomial.map_one, Polynomial.map_sub]
    convert RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p)))
        (minpoly_dvd_x_pow_sub_one h)
    simp only [map_sub, map_pow, coe_mapRingHom, map_X, map_one]
  refine Separable.of_dvd (separable_X_pow_sub_C 1 ?_ one_ne_zero) hdvd
  by_contra hzero
  exact hdiv ((ZMod.natCast_zmod_eq_zero_iff_dvd n p).1 hzero)"
Mathlib/Order/OrderIsoNat.lean,RelEmbedding.acc_iff_no_decreasing_seq,acc_iff_no_decreasing_seq,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    choose f h using this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h",error:  unknown identifier 'lt_add_one',"theorem acc_iff_no_decreasing_seq {x} :
    Acc r x ‚Üî IsEmpty { f : ((¬∑ > ¬∑) : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop) ‚Ü™r r // x ‚àà Set.range f } ",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (Nat.lt_succ_self _))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    choose f h using this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    choose f h using this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h"
Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean,TopCat.range_pullback_map,range_pullback_map,bf799bb912c215766620a5a7133594b711412432,":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    simp only [‚Üê comp_apply, eq‚ÇÅ, eq‚ÇÇ]
    simp only [comp_apply, hx‚ÇÅ, hx‚ÇÇ]
    simp only [‚Üê comp_apply, pullback.condition]
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  apply Concrete.limit_ext
  rintro (_ | _ | _)
  ¬∑ simp only [TopCat.comp_app, limit.lift_œÄ_apply, Category.assoc, PullbackCone.mk_œÄ_app_one, hx‚ÇÅ,
      pullbackIsoProdSubtype_inv_fst_apply, Subtype.coe_mk]
    simp only [‚Üê comp_apply]
    have : pullback.fst ‚â´ g‚ÇÅ = limit.œÄ (cospan g‚ÇÅ g‚ÇÇ) none := by
      apply limit.w _ WalkingCospan.Hom.inl
    rw [this]
  ¬∑ simp [hx‚ÇÅ]
  ¬∑ simp [hx‚ÇÇ]","error:  unsolved goals
case h.mp.intro
J : Type v
inst‚úù : SmallCategory J
X‚úù Y‚úù Z‚úù : TopCat
W X Y Z S T : TopCat
f‚ÇÅ : W ‚ü∂ S
f‚ÇÇ : X ‚ü∂ S
g‚ÇÅ : Y ‚ü∂ T
g‚ÇÇ : Z ‚ü∂ T
i‚ÇÅ : W ‚ü∂ Y
i‚ÇÇ : X ‚ü∂ Z
i‚ÇÉ : S ‚ü∂ T
H‚ÇÉ : Mono i‚ÇÉ
eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ
eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ
y : ‚Üë(pullback f‚ÇÅ f‚ÇÇ)
‚ä¢ (‚àÉ y_1, i‚ÇÅ y_1 = pullback.fst ((pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) y)) ‚àß
    ‚àÉ y_1, i‚ÇÇ y_1 = pullback.snd ((pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) y)
error:  simp made no progress
error:  tactic 'apply' failed, failed to unify
  ?x = ?y
with
  (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) ((pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®(x‚ÇÅ, x‚ÇÇ), this‚ü©) = x‚úù
case h
J : Type v
inst‚úù : SmallCategory J
X‚úù Y‚úù Z‚úù : TopCat
W X Y Z S T : TopCat
f‚ÇÅ : W ‚ü∂ S
f‚ÇÇ : X ‚ü∂ S
g‚ÇÅ : Y ‚ü∂ T
g‚ÇÇ : Z ‚ü∂ T
i‚ÇÅ : W ‚ü∂ Y
i‚ÇÇ : X ‚ü∂ Z
i‚ÇÉ : S ‚ü∂ T
H‚ÇÉ : Mono i‚ÇÉ
eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ
eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ
x‚úù : ‚Üë(pullback g‚ÇÅ g‚ÇÇ)
x‚ÇÅ : ‚ÜëW
hx‚ÇÅ : i‚ÇÅ x‚ÇÅ = pullback.fst x‚úù
x‚ÇÇ : ‚ÜëX
hx‚ÇÇ : i‚ÇÇ x‚ÇÇ = pullback.snd x‚úù
this : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ
‚ä¢ (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) ((pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®(x‚ÇÅ, x‚ÇÇ), this‚ü©) = x‚úù","theorem range_pullback_map {W X Y Z S T : TopCat} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) (g‚ÇÅ : Y ‚ü∂ T)
    (g‚ÇÇ : Z ‚ü∂ T) (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T) [H‚ÇÉ : Mono i‚ÇÉ] (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ)
    (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) :
    Set.range (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) =
      (pullback.fst : pullback g‚ÇÅ g‚ÇÇ ‚ü∂ _) ‚Åª¬π' Set.range i‚ÇÅ ‚à©
        (pullback.snd : pullback g‚ÇÅ g‚ÇÇ ‚ü∂ _) ‚Åª¬π' Set.range i‚ÇÇ ",":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range]
    erw [‚Üê comp_apply, ‚Üê comp_apply] 
    simp only [limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app, comp_apply]
    exact ‚ü®exists_apply_eq_apply _ _, exists_apply_eq_apply _ _‚ü©
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    erw [‚Üê comp_apply, eq‚ÇÅ, ‚Üê comp_apply, eq‚ÇÇ, 
      comp_apply, comp_apply, hx‚ÇÅ, hx‚ÇÇ, ‚Üê comp_apply, pullback.condition]
    rfl 
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  change (forget TopCat).map _ _ = _
  apply Concrete.limit_ext
  rintro (_ | _ | _) <;>
  erw [‚Üê comp_apply, ‚Üê comp_apply] 
  simp only [Category.assoc, limit.lift_œÄ, PullbackCone.mk_œÄ_app_one]
  ¬∑ simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [pullbackFst_apply, hx‚ÇÅ]
    rw [‚Üê limit.w _ WalkingCospan.Hom.inl, cospan_map_inl, comp_apply (g := g‚ÇÅ)]
    rfl 
  ¬∑ simp only [cospan_left, limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,
      pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [hx‚ÇÅ] 
    rfl 
  ¬∑ simp only [cospan_right, limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,
      pullbackIsoProdSubtype_inv_snd_assoc, comp_apply]
    erw [hx‚ÇÇ] 
    rfl ",":= by
  ext
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    simp
  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©
  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by
    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ
    simp only [‚Üê comp_apply, eq‚ÇÅ, eq‚ÇÇ]
    simp only [comp_apply, hx‚ÇÅ, hx‚ÇÇ]
    simp only [‚Üê comp_apply, pullback.condition]
  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©
  apply Concrete.limit_ext
  rintro (_ | _ | _)
  ¬∑ simp only [TopCat.comp_app, limit.lift_œÄ_apply, Category.assoc, PullbackCone.mk_œÄ_app_one, hx‚ÇÅ,
      pullbackIsoProdSubtype_inv_fst_apply, Subtype.coe_mk]
    simp only [‚Üê comp_apply]
    have : pullback.fst ‚â´ g‚ÇÅ = limit.œÄ (cospan g‚ÇÅ g‚ÇÇ) none := by
      apply limit.w _ WalkingCospan.Hom.inl
    rw [this]
  ¬∑ simp [hx‚ÇÅ]
  ¬∑ simp [hx‚ÇÇ]"
Mathlib/NumberTheory/DiophantineApproximation.lean,Real.exists_rat_eq_convergent',exists_rat_eq_convergent',2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    cases' le_or_lt (u : ‚Ñù) Œæ with ht ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      cases' eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine' ‚ü®(fract_lt_one Œæ).le, _‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (by exact_mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_ofNat, inv_div, sub_div, mul_div_cancel _ Hv, add_sub_cancel'_right]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë(OfNat.ofNat ?n)
case h
v‚úù : ‚Ñ§
hv : 2 ‚â§ v‚úù
v : ‚Ñï
ih : ‚àÄ m < v, ‚àÄ {Œæ : ‚Ñù} {u : ‚Ñ§}, ContfracLegendre.Ass Œæ u ‚Üëm ‚Üí ‚àÉ n, ‚Üëu / ‚Üëm = Œæ.convergent n
Œæ : ‚Ñù
u : ‚Ñ§
h : ContfracLegendre.Ass Œæ u ‚Üëv
ht : 1 < v
huv‚ÇÄ : 0 < u - ‚åäŒæ‚åã * ‚Üëv
huv‚ÇÅ : u - ‚åäŒæ‚åã * ‚Üëv < ‚Üëv
Hv : ‚Üëv ‚â† 0
huv‚ÇÅ' : (u - ‚åäŒæ‚åã * ‚Üëv).toNat < v
inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π ‚Üëv ‚Üë(u - ‚åäŒæ‚åã * ‚Üëv).toNat
n : ‚Ñï
hn : ‚Üë‚Üëv / ‚Üë(u - ‚åäŒæ‚åã * ‚Üëv).toNat = (fract Œæ)‚Åª¬π.convergent n
‚ä¢ ‚Üëu / ‚Üëv = ‚Üë‚åäŒæ‚åã + (‚Üë‚Üëv / (‚Üëu - ‚Üë‚åäŒæ‚åã * ‚Üëv))‚Åª¬π","theorem exists_rat_eq_convergent' {v : ‚Ñï} (h' : ContfracLegendre.Ass Œæ u v) :
    ‚àÉ n, (u / v : ‚Ñö) = Œæ.convergent n ",":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    rcases le_or_lt (u : ‚Ñù) Œæ with ht | ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      rcases eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ | HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine ‚ü®(fract_lt_one Œæ).le, ?_‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_natCast, inv_div, sub_div, mul_div_cancel_right‚ÇÄ _ Hv, add_sub_cancel]",":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    cases' le_or_lt (u : ‚Ñù) Œæ with ht ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      cases' eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine ‚ü®(fract_lt_one Œæ).le, ?_‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (by exact_mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_ofNat, inv_div, sub_div, mul_div_cancel _ Hv, add_sub_cancel'_right]"
Mathlib/LinearAlgebra/CliffordAlgebra/EvenEquiv.lean,CliffordAlgebra.EquivEven.neg_e0_mul_v,neg_e0_mul_v,b82e978679b451490878b9d55401f33dea523113,":= by
  refine neg_eq_of_add_eq_zero_right ((Œπ_mul_Œπ_add_swap _ _).trans ?_)
  dsimp [QuadraticMap.polar]
  simp only [add_zero, mul_zero, mul_one, zero_add, neg_zero, QuadraticMap.map_zero,
    add_sub_cancel_right, sub_self, map_zero, zero_sub]","error:  unknown identifier 'QuadraticMap.polar'
error:  unknown identifier 'QuadraticMap.map_zero'
error:  simp made no progress",theorem neg_e0_mul_v (m : M) : -(e0 Q * v Q m) = v Q m * e0 Q ,":= by
  refine neg_eq_of_add_eq_zero_right ((Œπ_mul_Œπ_add_swap _ _).trans ?_)
  dsimp [QuadraticForm.polar]
  simp only [add_zero, mul_zero, mul_one, zero_add, neg_zero, QuadraticForm.map_zero,
    add_sub_cancel_right, sub_self, map_zero, zero_sub]",":= by
  refine neg_eq_of_add_eq_zero_right ((Œπ_mul_Œπ_add_swap _ _).trans ?_)
  dsimp [QuadraticMap.polar]
  simp only [add_zero, mul_zero, zero_add, neg_zero, QuadraticMap.map_zero,
    add_sub_cancel_right, sub_self, map_zero, zero_sub]"
Mathlib/Analysis/SpecialFunctions/Stirling.lean,Stirling.stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq,stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  have : 4 = 2 * 2 := by rfl
  rw [stirlingSeq, this, pow_mul, stirlingSeq, Wallis.W_eq_factorial_ratio]
  simp_rw [div_pow, mul_pow]
  rw [sq_sqrt, sq_sqrt]
  any_goals positivity
  field_simp; ring","info:  Try this: ring_nf
error:  unsolved goals
n : ‚Ñï
hn : n ‚â† 0
this : 4 = 2 * 2
‚ä¢ ‚Üën ! ^ 4 * rexp ‚Üën ^ 4 * ‚Üën ^ 2 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * 2 ^ (n * 4) * 4 +
      ‚Üën ! ^ 4 * rexp ‚Üën ^ 4 * ‚Üën ^ 3 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * 2 ^ (n * 4) * 8 =
    ‚Üën ! ^ 4 * ‚Üën ^ 2 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * rexp (‚Üën * 2) ^ 2 * 2 ^ (n * 4) * 4 +
      ‚Üën ! ^ 4 * ‚Üën ^ 3 * ‚Üën ^ (n * 4) * ‚Üë(n * 2)! ^ 2 * rexp (‚Üën * 2) ^ 2 * 2 ^ (n * 4) * 8","theorem stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq (n : ‚Ñï) (hn : n ‚â† 0) :
    stirlingSeq n ^ 4 / stirlingSeq (2 * n) ^ 2 * (n / (2 * n + 1)) = Wallis.W n ",":= by
  have : 4 = 2 * 2 := by rfl
  rw [stirlingSeq, this, pow_mul, stirlingSeq, Wallis.W_eq_factorial_ratio]
  simp_rw [div_pow, mul_pow]
  rw [sq_sqrt, sq_sqrt]
  any_goals positivity
  field_simp [‚Üê exp_nsmul]
  ring_nf",":= by
  have : 4 = 2 * 2 := by rfl
  rw [stirlingSeq, this, pow_mul, stirlingSeq, Wallis.W_eq_factorial_ratio]
  simp_rw [sq_sqrt, sq_sqrt]
  any_goals positivity
  field_simp; ring"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,contMDiff_coe_sphere,contMDiff_coe_sphere,28f34517ea07a4ecc94b3d55041dd0ca1152a2a8,":= by
  have := smoothMfldWithCorners (E := E) (n := n)
  rw [contMDiff_iff]
  constructor
  ¬∑ exact continuous_subtype_val
  ¬∑ intro v _
    let U : _ ‚âÉ‚Çó·µ¢[‚Ñù] _ :=
      (
          OrthonormalBasis.fromOrthogonalSpanSingleton
          n (ne_zero_of_mem_unit_sphere (-v))).repr
    exact
      ((contDiff_stereoInvFunAux.comp (‚Ñù ‚Ä¢ (-v : E))·óÆ.subtypeL.contDiff).comp
          U.symm.contDiff).contDiffOn","error:  unknown identifier 'smoothMfldWithCorners'
error:  unsolved goals
E : Type u_1
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : InnerProductSpace ‚Ñù E
n : ‚Ñï
inst‚úù : Fact (finrank ‚Ñù E = n + 1)
‚ä¢ ContMDiff ùìò(‚Ñù, EuclideanSpace ‚Ñù (Fin n)) ùìò(‚Ñù, E) ‚ä§ Subtype.val","theorem contMDiff_coe_sphere {n : ‚Ñï} [Fact (finrank ‚Ñù E = n + 1)] :
    ContMDiff (ùì° n) ùìò(‚Ñù, E) ‚àû ((‚Üë) : sphere (0 : E) 1 ‚Üí E) ",":= by
  have := EuclideanSpace.instSmoothManifoldWithCornersSphere (E := E) (n := n)
  rw [contMDiff_iff]
  constructor
  ¬∑ exact continuous_subtype_val
  ¬∑ intro v _
    let U : _ ‚âÉ‚Çó·µ¢[‚Ñù] _ :=
      (
          OrthonormalBasis.fromOrthogonalSpanSingleton
          n (ne_zero_of_mem_unit_sphere (-v))).repr
    exact
      ((contDiff_stereoInvFunAux.comp (‚Ñù ‚àô (-v : E))·óÆ.subtypeL.contDiff).comp
          U.symm.contDiff).contDiffOn",":= by
  have := smoothMfldWithCorners (E := E) (n := n)
  rw [contMDiff_iff]
  constructor
  ¬∑ exact continuous_subtype_val
  ¬∑ intro v _
    let U : _ ‚âÉ‚Çó·µ¢[‚Ñù] _ :=
      (
          OrthonormalBasis.fromOrthogonalSpanSingleton
           n (ne_zero_of_mem_unit_sphere (-v))).repr
    exact
      ((contDiff_stereoInvFunAux.comp (‚Ñù ‚Ä¢ (-v : E))·óÆ.subtypeL.contDiff).comp
          U.symm.contDiff).contDiffOn"
Mathlib/Algebra/Module/PID.lean,Submodule.isSemisimple_torsionBy_of_irreducible,Submodule.isSemisimple_torsionBy_of_irreducible,e54b06464b16cc1b649903b81d6957f117d1255b,":= by
  rw [IsSemisimpleModule, ‚Üê (submodule_torsionBy_orderIso a).complementedLattice_iff]
  set I : Ideal R := R ‚àô a
  have _i2 : I.IsMaximal := PrincipalIdealRing.isMaximal_of_irreducible h
  let _i3 : Field (R ‚ß∏ I) := Ideal.Quotient.field I
  exact Module.Submodule.complementedLattice",error:  unknown constant 'Module.Submodule.complementedLattice',"theorem Submodule.isSemisimple_torsionBy_of_irreducible {a : R} (h : Irreducible a) :
    IsSemisimpleModule R (torsionBy R M a) ",":=
  haveI := PrincipalIdealRing.isMaximal_of_irreducible h
  letI := Ideal.Quotient.field (R ‚àô a)
  (submodule_torsionBy_orderIso a).complementedLattice",":= by
  rw [IsSemisimpleModule, ‚Üê (submodule_torsionBy_orderIso a).complementedLattice_iff]
  set I : Ideal R := R ‚àô a
  have _i2 : I.IsMaximal := PrincipalIdealRing.isMaximal_of_irreducible h
  let _i3 : Field (R ‚ß∏ I) := Ideal.Quotient.field I
  exact Module.Submodule.complementedLattice"
Mathlib/GroupTheory/Nilpotent.lean,nilpotent_of_surjective,nilpotent_of_surjective,e406b2ea849d364a8088bb124711622aa6b81eeb,":= by
  rcases h with ‚ü®n, hn‚ü©
  use n
  apply eq_top_iff.mpr
  calc
    ‚ä§ = range f := symm (range_top_of_surjective f hf)
    _ = Subgroup.map f ‚ä§ := (MonoidHom.range_eq_map _)
    _ = Subgroup.map f (upperCentralSeries G n) := by rw [hn]
    _ ‚â§ upperCentralSeries G' n := upperCentralSeries.map hf n","error:  unknown identifier 'range'
error:  unknown identifier 'range_top_of_surjective'","theorem nilpotent_of_surjective {G' : Type*} [Group G'] [h : IsNilpotent G] (f : G ‚Üí* G')
    (hf : Function.Surjective f) : IsNilpotent G' ",":= by
  rcases h with ‚ü®n, hn‚ü©
  use n
  apply eq_top_iff.mpr
  calc
    ‚ä§ = f.range := symm (f.range_top_of_surjective hf)
    _ = Subgroup.map f ‚ä§ := MonoidHom.range_eq_map _
    _ = Subgroup.map f (upperCentralSeries G n) := by rw [hn]
    _ ‚â§ upperCentralSeries G' n := upperCentralSeries.map hf n",":= by
  rcases h with ‚ü®n, hn‚ü©
  use n
  apply eq_top_iff.mpr
  calc
    ‚ä§ = range f := symm (range_top_of_surjective f hf)
    _ = Subgroup.map f ‚ä§ := MonoidHom.range_eq_map _
    _ = Subgroup.map f (upperCentralSeries G n) := by rw [hn]
    _ ‚â§ upperCentralSeries G' n := upperCentralSeries.map hf n"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ ¬∑ rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx"
Mathlib/Analysis/Convex/Basic.lean,MonotoneOn.convex_lt,MonotoneOn.convex_lt,ef3c9bcd07782b044027916a64e925f3e4951707,":= fun x hx y hy _ _ ha hb hab =>
  ‚ü®hs hx.1 hy.1 ha hb hab,
    (hf (hs hx.1 hy.1 ha hb hab) (max_rec' s.toPred hx.1 hy.1)
          (Convex.combo_le_max x y ha hb hab)).trans_lt
      (max_rec' { x | f x < r }.toPred hx.2 hy.2)‚ü©","error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  s
has type
  Set E
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  s
has type
  E ‚Üí Prop
error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  {x | f x < r}
has type
  Set E
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  {x | f x < r}
has type
  E ‚Üí Prop","theorem MonotoneOn.convex_lt (hf : MonotoneOn f s) (hs : Convex ùïú s) (r : Œ≤) :
    Convex ùïú ({ x ‚àà s | f x < r }) ",":= fun x hx y hy _ _ ha hb hab =>
  ‚ü®hs hx.1 hy.1 ha hb hab,
    (hf (hs hx.1 hy.1 ha hb hab) (max_rec' s hx.1 hy.1)
          (Convex.combo_le_max x y ha hb hab)).trans_lt
      (max_rec' { x | f x < r } hx.2 hy.2)‚ü©",":= fun x hx y hy _ _ ha hb hab =>
  ‚ü®hs hx.1 hy.1 ha hb hab,
    (hf (hs hx.1 hy.1 ha hb hab) (max_rec' s.toPred hx.1 hy.1)
          (Convex.combo_le_max x y ha hb hab)).trans_lt
      (max_rec' { x | f x < r }.toPred hx.2 hy.2)‚ü©"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,63aaa8cc21050b7a5cb193c6764569918728723b,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Œµ hŒµ).mono fun y hy => _
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  unknown identifier 'IsROrC.norm_ofReal'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.81235
case f.h
Œπ : Type u_1
l : Filter Œπ
E : Type u_2
inst‚úù‚Åµ : NormedAddCommGroup E
ùïú : Type u_3
inst‚úù‚Å¥ : RCLike ùïú
inst‚úù¬≥ : NormedSpace ùïú E
G : Type u_4
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : NormedSpace ùïú G
f : Œπ ‚Üí E ‚Üí G
g : E ‚Üí G
f' : Œπ ‚Üí E ‚Üí E ‚ÜíL[ùïú] G
g' : E ‚Üí E ‚ÜíL[ùïú] G
x : E
inst‚úù : l.NeBot
hf' : TendstoUniformlyOnFilter f' g' l (ùìù x)
hf : ‚àÄ·∂† (n : Œπ √ó E) in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2
hfg : ‚àÄ·∂† (y : E) in ùìù x, Tendsto (fun n ‚Ü¶ f n y) l (ùìù (g y))
x‚úù : Œπ √ó E
| |‚Äñx‚úù.2 - x‚Äñ‚Åª¬π| * ‚Äñg x‚úù.2 - g x - (g' x) (x‚úù.2 - x)‚Äñ","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto"
Mathlib/LinearAlgebra/FiniteDimensional.lean,Submodule.eq_top_of_finrank_eq,_root_.Submodule.eq_top_of_finrank_eq,3a9380ee1b3df597767214061c61454e81effff0,":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]","error:  type mismatch
  h‚úù
has type
  LinearIndependent (Œπ := ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) K ‚áëbS : Prop
but is expected to have type
  LinearIndependent K fun (x : ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) ‚Ü¶ ‚Üëx : Prop
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  no goals to be solved
error:  unknown identifier 'eq_top_of_finrank_eq'","theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ‚ä§ ",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa using b.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
             finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]"
Mathlib/Algebra/Polynomial/Eval.lean,Polynomial.eval_natCast_map,eval_natCast_map,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction p with
  | h_add p q hp hq =>
    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]
  | h_monomial n r =>
    simp only [map_natCast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  invalid alternative name 'h_add'","theorem eval_natCast_map (f : R ‚Üí+* S) (p : R[X]) (n : ‚Ñï) :
    (p.map f).eval (n : S) = f (p.eval n) ",":= by
  induction p using Polynomial.induction_on' with
  | h_add p q hp hq =>
    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]
  | h_monomial n r =>
    simp only [map_natCast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]",":= by
  induction p using Polynomial.induction_on' with
  | h_add p q hp hq =>
    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]
  | h_monomial n r =>
    simp only [map_natCast f, eval_monomial, map_monomial, map_pow, f.map_mul]"
Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean,Orientation.oangle_eq_of_angle_eq_of_sign_eq,oangle_eq_of_angle_eq_of_sign_eq,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  by_cases h0 : (w = 0 ‚à® x = 0) ‚à® y = 0 ‚à® z = 0
  ¬∑ have hs' : (o.oangle w x).sign = 0 ‚àß (o.oangle y z).sign = 0 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      ¬∑ simpa using hs.symm
      ¬∑ simpa using hs.symm
      ¬∑ simpa using hs
      ¬∑ simpa using hs
    rcases hs' with ‚ü®hswx, hsyz‚ü©
    have h' : InnerProductGeometry.angle w x = œÄ / 2 ‚àß InnerProductGeometry.angle y z = œÄ / 2 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      ¬∑ simpa using h.symm
      ¬∑ simpa using h.symm
      ¬∑ simpa using h
      ¬∑ simpa using h
    rcases h' with ‚ü®hwx, hyz‚ü©
    have hpi : œÄ / 2 ‚â† œÄ := by
      intro hpi
      rw [div_eq_iff, eq_comm, ‚Üê sub_eq_zero, mul_two, add_sub_cancel] at hpi
      ¬∑ exact Real.pi_pos.ne.symm hpi
      ¬∑ exact two_ne_zero
    have h0wx : w = 0 ‚à® x = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hswx
      simpa [hwx, Real.pi_pos.ne.symm, hpi] using h0'
    have h0yz : y = 0 ‚à® z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0wx with (h0wx | h0wx) <;> rcases h0yz with (h0yz | h0yz) <;> simp [h0wx, h0yz]
  ¬∑ push_neg at h0
    rw [Real.Angle.eq_iff_abs_toReal_eq_of_sign_eq hs]
    rwa [o.angle_eq_abs_oangle_toReal h0.1.1 h0.1.2,
      o.angle_eq_abs_oangle_toReal h0.2.1 h0.2.2] at h","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
V : Type u_1
V' : Type u_2
inst‚úù‚Åµ : NormedAddCommGroup V
inst‚úù‚Å¥ : NormedAddCommGroup V'
inst‚úù¬≥ : InnerProductSpace ‚Ñù V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V'
inst‚úù¬π : Fact (finrank ‚Ñù V = 2)
inst‚úù : Fact (finrank ‚Ñù V' = 2)
o : Orientation ‚Ñù V (Fin 2)
w x y z : V
h : InnerProductGeometry.angle w x = InnerProductGeometry.angle y z
hs : (o.oangle w x).sign = (o.oangle y z).sign
h0 : (w = 0 ‚à® x = 0) ‚à® y = 0 ‚à® z = 0
hswx : (o.oangle w x).sign = 0
hsyz : (o.oangle y z).sign = 0
hwx : InnerProductGeometry.angle w x = œÄ / 2
hyz : InnerProductGeometry.angle y z = œÄ / 2
hpi : œÄ + œÄ - œÄ = 0
‚ä¢ False","theorem oangle_eq_of_angle_eq_of_sign_eq {w x y z : V}
    (h : InnerProductGeometry.angle w x = InnerProductGeometry.angle y z)
    (hs : (o.oangle w x).sign = (o.oangle y z).sign) : o.oangle w x = o.oangle y z ",":= by
  by_cases h0 : (w = 0 ‚à® x = 0) ‚à® y = 0 ‚à® z = 0
  ¬∑ have hs' : (o.oangle w x).sign = 0 ‚àß (o.oangle y z).sign = 0 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      ¬∑ simpa using hs.symm
      ¬∑ simpa using hs.symm
      ¬∑ simpa using hs
      ¬∑ simpa using hs
    rcases hs' with ‚ü®hswx, hsyz‚ü©
    have h' : InnerProductGeometry.angle w x = œÄ / 2 ‚àß InnerProductGeometry.angle y z = œÄ / 2 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      ¬∑ simpa using h.symm
      ¬∑ simpa using h.symm
      ¬∑ simpa using h
      ¬∑ simpa using h
    rcases h' with ‚ü®hwx, hyz‚ü©
    have hpi : œÄ / 2 ‚â† œÄ := by
      intro hpi
      rw [div_eq_iff, eq_comm, ‚Üê sub_eq_zero, mul_two, add_sub_cancel_right] at hpi
      ¬∑ exact Real.pi_pos.ne.symm hpi
      ¬∑ exact two_ne_zero
    have h0wx : w = 0 ‚à® x = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hswx
      simpa [hwx, Real.pi_pos.ne.symm, hpi] using h0'
    have h0yz : y = 0 ‚à® z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0wx with (h0wx | h0wx) <;> rcases h0yz with (h0yz | h0yz) <;> simp [h0wx, h0yz]
  ¬∑ push_neg at h0
    rw [Real.Angle.eq_iff_abs_toReal_eq_of_sign_eq hs]
    rwa [o.angle_eq_abs_oangle_toReal h0.1.1 h0.1.2,
      o.angle_eq_abs_oangle_toReal h0.2.1 h0.2.2] at h",":= by
  by_cases h0 : (w = 0 ‚à® x = 0) ‚à® y = 0 ‚à® z = 0
  ¬∑ have hs' : (o.oangle w x).sign = 0 ‚àß (o.oangle y z).sign = 0 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      ¬∑ simpa using hs.symm
      ¬∑ simpa using hs
      ¬∑ simpa using hs
      ¬∑ simpa using hs
    rcases hs' with ‚ü®hswx, hsyz‚ü©
    have h' : InnerProductGeometry.angle w x = œÄ / 2 ‚àß InnerProductGeometry.angle y z = œÄ / 2 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      ¬∑ simpa using h.symm
      ¬∑ simpa using hs.symm
      ¬∑ simpa using hs
      ¬∑ simpa using hs
      ¬∑ simpa using hs' with ‚ü®hswx, hsyz‚ü©
    have h' : InnerProductGeometry.angle w x = œÄ / 2 ‚àß InnerProductGeometry.angle y z = œÄ / 2 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      ¬∑ simpa using h.symm
      ¬∑ simpa using hs.symm
      ¬∑ simpa using h
      ¬∑ simpa using h
    rcases h' with ‚ü®hwx, hyz‚ü©
    have hpi : œÄ / 2 ‚â† œÄ := by
      intro hpi
      rw [div_eq_iff, eq_comm, ‚Üê sub_eq_zero, mul_two, add_sub_cancel] at hpi
      ¬∑ exact Real.pi_pos.ne.symm hpi
      ¬∑ exact two_ne_zero
    have h0wx : w = 0 ‚à® x = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hswx
      simpa [hwx, Real.pi_pos.ne.symm, hpi] using h0'
    have h0yz : y = 0 ‚à® z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0yz : y = 0 ‚à® z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0yz : y = 0 ‚à® z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0yz : y = 0 ‚à® z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0yz : y = 0 ‚à® z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0yz : y = 0 ‚à® z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0yz : y = 0 ‚à® z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0yz : y = 0 ‚à® z = 0 := by
      have h0' := o.eq_zero_or_an"
Mathlib/Data/Nat/Choose/Central.lean,Nat.four_pow_lt_mul_centralBinom,four_pow_lt_mul_centralBinom,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  induction' n using Nat.strong_induction_on with n IH
  rcases lt_trichotomy n 4 with (hn | rfl | hn)
  ¬∑ clear IH; exact False.elim ((not_lt.2 n_big) hn)
  ¬∑ norm_num [centralBinom, choose]
  obtain ‚ü®n, rfl‚ü© : ‚àÉ m, n = m + 1 := Nat.exists_eq_succ_of_ne_zero (Nat.not_eq_zero_of_lt hn)
  calc
    4 ^ (n + 1) < 4 * (n * centralBinom n) := lt_of_eq_of_lt (pow_succ'' n 4) $
      (mul_lt_mul_left <| zero_lt_four' ‚Ñï).mpr (IH n n.lt_succ_self (Nat.le_of_lt_succ hn))
    _ ‚â§ 2 * (2 * n + 1) * centralBinom n := by rw [‚Üê mul_assoc]; linarith
    _ = (n + 1) * centralBinom (n + 1) := (succ_mul_centralBinom_succ n).symm",error:  unknown identifier 'pow_succ''',theorem four_pow_lt_mul_centralBinom (n : ‚Ñï) (n_big : 4 ‚â§ n) : 4 ^ n < n * centralBinom n ,":= by
  induction' n using Nat.strong_induction_on with n IH
  rcases lt_trichotomy n 4 with (hn | rfl | hn)
  ¬∑ clear IH; exact False.elim ((not_lt.2 n_big) hn)
  ¬∑ norm_num [centralBinom, choose]
  obtain ‚ü®n, rfl‚ü© : ‚àÉ m, n = m + 1 := Nat.exists_eq_succ_of_ne_zero (Nat.not_eq_zero_of_lt hn)
  calc
    4 ^ (n + 1) < 4 * (n * centralBinom n) := lt_of_eq_of_lt pow_succ' <|
      (mul_lt_mul_left <| zero_lt_four' ‚Ñï).mpr (IH n n.lt_succ_self (Nat.le_of_lt_succ hn))
    _ ‚â§ 2 * (2 * n + 1) * centralBinom n := by rw [‚Üê mul_assoc]; linarith
    _ = (n + 1) * centralBinom (n + 1) := (succ_mul_centralBinom_succ n).symm",":= by
  induction' n using Nat.strong_induction_on with n IH
  rcases lt_trichotomy n 4 with (hn | rfl | hn)
  ¬∑ clear IH; exact False.elim ((not_lt.2 n_big) hn)
  ¬∑ norm_num [centralBinom, choose]
  obtain ‚ü®n, rfl‚ü© : ‚àÉ m, n = m + 1 := Nat.exists_eq_succ_of_ne_zero (Nat.not_eq_zero_of_lt hn)
  calc
    4 ^ (n + 1) < 4 * (n * centralBinom n) := lt_of_eq_of_lt (pow_succ'' n 4) $
      (mul_lt_mul_left <| zero_lt_four' ‚Ñï).mpr (IH n n.lt_succ_self (Nat.le_of_lt_succ hn))
    _ ‚â§ 2 * (2 * n + 1) * centralBinom n := by rw [‚Üê mul_assoc]; linarith
    _ = (n + 1) * centralBinom (n + 1) := (succ_mul_centralBinom_succ n).symm"
Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean,WeierstrassCurve.Projective.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,044a5b033e4757e2f21f01f04b5d9cc88f84791f,":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]‚ü©","error:  application type mismatch
  div_mul_cancel ?m.248578 hQ
argument
  hQ
has type
  ¬¨Q 1 = 0 : Prop
but is expected to have type
  ?m.248576 : Type ?u.248575
error:  unsolved goals
R : Type u
inst‚úù¬π : CommRing R
W‚úù : Projective R
F : Type u
inst‚úù : Field F
W : Projective F
P Q : Fin 3 ‚Üí F
hPz : P 2 = 0
hQz : Q 2 = 0
hP : ¬¨P 1 = 0
hQ : ¬¨Q 1 = 0
‚ä¢ ![0, P 1 / Q 1 * Q 1, 0] = ![0, P 1, 0]","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]‚ü©"
Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean,AlgebraicGeometry.sourceAffineLocally_isLocal,sourceAffineLocally_isLocal,4209dc8f278089a5b27c0d4aeb13dbe1dd2fad04,":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
      ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
            IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
          exact this _ rfl
        intro V hV
        rw [Scheme.preimage_basicOpen] at hV
        subst hV
        exact U.2.ŒπOpens_preimage (Scheme.Œì.map f.op r.1)","error:  no goals to be solved
error:  unsolved goals
case ofBasicOpenCover.refine_1
P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí (R ‚Üí+* S) ‚Üí Prop
h‚ÇÅ : RingHom.RespectsIso P
h‚ÇÇ : RingHom.LocalizationPreserves P
h‚ÇÉ : RingHom.OfLocalizationSpan P
X Y : Scheme
inst‚úù : IsAffine Y
f : X ‚ü∂ Y
s : Finset ‚ÜëŒì(Y, ‚ä§)
hs : Ideal.span ‚Üës = ‚ä§
hs' : ‚àÄ (r : { x // x ‚àà s }), sourceAffineLocally P (f ‚à£_ Y.basicOpen ‚Üër)
U : ‚ÜëX.affineOpens
r : ‚Üë‚Üës
‚ä¢ X.ofRestrict ‚ãØ ‚Åª¬π·µÅ ‚ÜëU ‚àà (X ‚à£_·µ§ f ‚Åª¬π·µÅ Y.basicOpen ‚Üër).affineOpens","theorem sourceAffineLocally_isLocal (h‚ÇÅ : RingHom.RespectsIso @P)
    (h‚ÇÇ : RingHom.LocalizationPreserves @P) (h‚ÇÉ : RingHom.OfLocalizationSpan @P) :
    (sourceAffineLocally @P).IsLocal ",":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
    ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
          IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
        exact this _ rfl
      intro V hV
      rw [Scheme.preimage_basicOpen] at hV
      subst hV
      exact U.2.ŒπOpens_basicOpen_preimage (Scheme.Œì.map f.op r.1)",":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
      ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
            IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
          exact this _ rfl
        intro V hV
        rw [Scheme.preimage_basicOpen] at hV
        subst hV
        exact U.2.ŒπOpens_preimage (Scheme.Œì.map f.op r.1)"
Mathlib/LinearAlgebra/Dimension/DivisionRing.lean,rank_add_rank_split,rank_add_rank_split,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  have hf : Surjective (coprod db eb) := by rwa [‚Üê range_eq_top, range_coprod, eq_top_iff]
  conv =>
    rhs
    rw [‚Üê rank_prod', rank_eq_of_surjective _ hf]
  congr 1
  apply LinearEquiv.rank_eq
  let L : V‚ÇÅ ‚Üí‚Çó[K] ker (coprod db eb) := by 
    refine' LinearMap.codRestrict _ (prod cd (-ce)) _
    ¬∑ intro c
      simp only [add_eq_zero_iff_eq_neg, LinearMap.prod_apply, mem_ker, Pi.prod, coprod_apply,
        neg_neg, map_neg, neg_apply]
      exact LinearMap.ext_iff.1 eq c
  refine' LinearEquiv.ofBijective L ‚ü®_, _‚ü©
  ¬∑ rw [‚Üê ker_eq_bot, ker_codRestrict, ker_prod, hgd, bot_inf_eq]
  ¬∑ rw [‚Üê range_eq_top, eq_top_iff, range_codRestrict, ‚Üê map_le_iff_le_comap, Submodule.map_top,
      range_subtype]
    rintro ‚ü®d, e‚ü©
    have h := eq‚ÇÇ d (-e)
    simp only [add_eq_zero_iff_eq_neg, LinearMap.prod_apply, mem_ker, SetLike.mem_coe,
      Prod.mk.inj_iff, coprod_apply, map_neg, neg_apply, LinearMap.mem_range, Pi.prod] at h ‚ä¢
    intro hde
    rcases h hde with ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü©
    refine' ‚ü®c, h‚ÇÅ, _‚ü©
    rw [h‚ÇÇ, _root_.neg_neg]","error:  function expected at
  rank_eq_of_surjective ?m.38954
term has type
  Module.rank ?m.38944 ?m.38945 = Module.rank ?m.38944 ?m.38946 + Module.rank ?m.38944 ‚Ü•(ker ?m.38953)
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.39515
K R : Type u
V V‚ÇÅ V‚ÇÇ V‚ÇÉ : Type v
V' V'‚ÇÅ : Type v'
V'' : Type v''
Œπ : Type w
Œπ' : Type w'
Œ∑ : Type u‚ÇÅ'
œÜ : Œ∑ ‚Üí Type u_1
inst‚úù¬π‚Å∞ : DivisionRing K
inst‚úù‚Åπ : AddCommGroup V
inst‚úù‚Å∏ : Module K V
inst‚úù‚Å∑ : AddCommGroup V'
inst‚úù‚Å∂ : Module K V'
inst‚úù‚Åµ : AddCommGroup V‚ÇÅ
inst‚úù‚Å¥ : Module K V‚ÇÅ
inst‚úù¬≥ : AddCommGroup V‚ÇÇ
inst‚úù¬≤ : Module K V‚ÇÇ
inst‚úù¬π : AddCommGroup V‚ÇÉ
inst‚úù : Module K V‚ÇÉ
db : V‚ÇÇ ‚Üí‚Çó[K] V
eb : V‚ÇÉ ‚Üí‚Çó[K] V
cd : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ
ce : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÉ
hde : ‚ä§ ‚â§ LinearMap.range db ‚äî LinearMap.range eb
hgd : ker cd = ‚ä•
eq : db ‚àò‚Çó cd = eb ‚àò‚Çó ce
eq‚ÇÇ : ‚àÄ (d : V‚ÇÇ) (e : V‚ÇÉ), db d = eb e ‚Üí ‚àÉ c, cd c = d ‚àß ce c = e
hf : Surjective ‚áë(db.coprod eb)
| Module.rank K (V‚ÇÇ √ó V‚ÇÉ)","theorem rank_add_rank_split (db : V‚ÇÇ ‚Üí‚Çó[K] V) (eb : V‚ÇÉ ‚Üí‚Çó[K] V) (cd : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ)
    (ce : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÉ) (hde : ‚ä§ ‚â§ LinearMap.range db ‚äî LinearMap.range eb) (hgd : ker cd = ‚ä•)
    (eq : db.comp cd = eb.comp ce) (eq‚ÇÇ : ‚àÄ d e, db d = eb e ‚Üí ‚àÉ c, cd c = d ‚àß ce c = e) :
    Module.rank K V + Module.rank K V‚ÇÅ = Module.rank K V‚ÇÇ + Module.rank K V‚ÇÉ ",":= by
  have hf : Surjective (coprod db eb) := by rwa [‚Üê range_eq_top, range_coprod, eq_top_iff]
  conv =>
    rhs
    rw [‚Üê rank_prod', rank_eq_of_surjective hf]
  congr 1
  apply LinearEquiv.rank_eq
  let L : V‚ÇÅ ‚Üí‚Çó[K] ker (coprod db eb) := by 
    refine LinearMap.codRestrict _ (prod cd (-ce)) ?_
    ¬∑ intro c
      simp only [add_eq_zero_iff_eq_neg, LinearMap.prod_apply, mem_ker, Pi.prod, coprod_apply,
        neg_neg, map_neg, neg_apply]
      exact LinearMap.ext_iff.1 eq c
  refine LinearEquiv.ofBijective L ‚ü®?_, ?_‚ü©
  ¬∑ rw [‚Üê ker_eq_bot, ker_codRestrict, ker_prod, hgd, bot_inf_eq]
  ¬∑ rw [‚Üê range_eq_top, eq_top_iff, range_codRestrict, ‚Üê map_le_iff_le_comap, Submodule.map_top,
      range_subtype]
    rintro ‚ü®d, e‚ü©
    have h := eq‚ÇÇ d (-e)
    simp only [add_eq_zero_iff_eq_neg, LinearMap.prod_apply, mem_ker, SetLike.mem_coe,
      Prod.mk.inj_iff, coprod_apply, map_neg, neg_apply, LinearMap.mem_range, Pi.prod] at h ‚ä¢
    intro hde
    rcases h hde with ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü©
    refine ‚ü®c, h‚ÇÅ, ?_‚ü©
    rw [h‚ÇÇ, _root_.neg_neg]",":= by
  have hf : Surjective (coprod db eb) := by rwa [‚Üê range_eq_top, range_coprod, eq_top_iff]
  conv =>
    rhs
    rw [‚Üê rank_prod', rank_eq_of_surjective _ hf]
  congr 1
  apply LinearEquiv.rank_eq
  let L : V‚ÇÅ ‚Üí‚Çó[K] ker (coprod db eb) := by
    refine LinearMap.codRestrict _ (prod cd (-ce)) ?_
    ¬∑ intro c
      simp only [add_eq_zero_iff_eq_neg, LinearMap.prod_apply, mem_ker, Pi.prod, coprod_apply,
        neg_neg, map_neg, neg_apply]
      exact LinearMap.ext_iff.1 eq c
  refine LinearEquiv.ofBijective L ‚ü®?_, ?_‚ü©
  ¬∑ rw [‚Üê ker_eq_bot, ker_codRestrict, ker_prod, hgd, bot_inf_eq]
  ¬∑ rw [‚Üê range_eq_top, eq_top_iff, range_codRestrict, ‚Üê map_le_iff_le_comap, Submodule.map_top,
      range_subtype]
    rintro ‚ü®d, e‚ü©
    have h := eq‚ÇÇ d (-e)
    simp only [add_eq_zero_iff_eq_neg, LinearMap.prod_apply, mem_ker, SetLike.mem_coe,
      Prod.mk.inj_iff, coprod_apply, map_neg, neg_apply, LinearMap.mem_range, Pi.prod] at h ‚ä¢
    intro hde
    rcases h hde with ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü©
    refine ‚ü®c, h‚ÇÅ, ?_‚ü©
    rw [h‚ÇÇ, _root_.neg_neg]"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,df80f92cd37291ae10f3efaf1c701700cac70a5d,":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú'
  ¬∑ rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine' Or.inl ‚ü®hs, _‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, _‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine'
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' ‚ü®hus, hsv.symm, ‚ü®x, _, _‚ü©, _‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right _ _, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) _
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  unexpected token '¬∑'; expected 'by' or 'from'","theorem shadow_compression_subset_compression_shadow (u v : Finset Œ±)
    (huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú) :
    ‚àÇ (ùìí u v ùíú) ‚äÜ ùìí u v (‚àÇ ùíú) ",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine mem_shadow_iff.2
        ‚ü®(t ‚äî u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) ?_
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú'
  ¬∑ rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx "
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,50f79eaf0f5e360632afea97f3cefd2b1eab4c46,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero, Nat.zero_eq,
          Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 ‚Üí ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 ‚Üí ?m.124403
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134258 ‚Üí ?m.134258 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134394 ‚Üí ?m.134394 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/Data/Set/Function.lean,Set.BijOn.inter_mapsTo,BijOn.inter_mapsTo,ea1b2576466eb49ae109b64acf312f52285dafce,":=
  ‚ü®h‚ÇÅ.mapsTo.inter_inter h‚ÇÇ, h‚ÇÅ.injOn.mono <| inter_subset_left _ _, fun _ hy =>
    let ‚ü®x, hx, hxy‚ü© := h‚ÇÅ.surjOn hy.1
    ‚ü®x, ‚ü®hx, h‚ÇÉ ‚ü®hx, hxy.symm.subst hy.2‚ü©‚ü©, hxy‚ü©‚ü©","error:  function expected at
  inter_subset_left ?m.66339
term has type
  ?m.66338 ‚àà ?m.66336","theorem BijOn.inter_mapsTo (h‚ÇÅ : BijOn f s‚ÇÅ t‚ÇÅ) (h‚ÇÇ : MapsTo f s‚ÇÇ t‚ÇÇ) (h‚ÇÉ : s‚ÇÅ ‚à© f ‚Åª¬π' t‚ÇÇ ‚äÜ s‚ÇÇ) :
    BijOn f (s‚ÇÅ ‚à© s‚ÇÇ) (t‚ÇÅ ‚à© t‚ÇÇ) ",":=
  ‚ü®h‚ÇÅ.mapsTo.inter_inter h‚ÇÇ, h‚ÇÅ.injOn.mono inter_subset_left, fun _ hy =>
    let ‚ü®x, hx, hxy‚ü© := h‚ÇÅ.surjOn hy.1
    ‚ü®x, ‚ü®hx, h‚ÇÉ ‚ü®hx, hxy.symm.subst hy.2‚ü©‚ü©, hxy‚ü©‚ü©",":=
  ‚ü®h‚ÇÅ.mapsTo.inter_inter h‚ÇÇ, h‚ÇÅ.injOn, inter_subset_left, fun _ hy =>
    let ‚ü®x, hx, hxy‚ü© := h‚ÇÅ.surjOn hy.1
    ‚ü®x, ‚ü®hx, h‚ÇÉ ‚ü®hx, hxy.symm.subst hy.2‚ü©‚ü©, hxy‚ü©‚ü©"
Mathlib/NumberTheory/DiophantineApproximation.lean,Real.exists_rat_eq_convergent',exists_rat_eq_convergent',5fb9beab28702fb284701d494bc9b7c5f52fef53,":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    cases' le_or_lt (u : ‚Ñù) Œæ with ht ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      cases' eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine' ‚ü®(fract_lt_one Œæ).le, _‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_ofNat, inv_div, sub_div, mul_div_cancel _ Hv, add_sub_cancel'_right]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë(OfNat.ofNat ?n)
case h
v‚úù : ‚Ñ§
hv : 2 ‚â§ v‚úù
v : ‚Ñï
ih : ‚àÄ m < v, ‚àÄ {Œæ : ‚Ñù} {u : ‚Ñ§}, ContfracLegendre.Ass Œæ u ‚Üëm ‚Üí ‚àÉ n, ‚Üëu / ‚Üëm = Œæ.convergent n
Œæ : ‚Ñù
u : ‚Ñ§
h : ContfracLegendre.Ass Œæ u ‚Üëv
ht : 1 < v
huv‚ÇÄ : 0 < u - ‚åäŒæ‚åã * ‚Üëv
huv‚ÇÅ : u - ‚åäŒæ‚åã * ‚Üëv < ‚Üëv
Hv : ‚Üëv ‚â† 0
huv‚ÇÅ' : (u - ‚åäŒæ‚åã * ‚Üëv).toNat < v
inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π ‚Üëv ‚Üë(u - ‚åäŒæ‚åã * ‚Üëv).toNat
n : ‚Ñï
hn : ‚Üë‚Üëv / ‚Üë(u - ‚åäŒæ‚åã * ‚Üëv).toNat = (fract Œæ)‚Åª¬π.convergent n
‚ä¢ ‚Üëu / ‚Üëv = ‚Üë‚åäŒæ‚åã + (‚Üë‚Üëv / (‚Üëu - ‚Üë‚åäŒæ‚åã * ‚Üëv))‚Åª¬π","theorem exists_rat_eq_convergent' {v : ‚Ñï} (h' : ContfracLegendre.Ass Œæ u v) :
    ‚àÉ n, (u / v : ‚Ñö) = Œæ.convergent n ",":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    rcases le_or_lt (u : ‚Ñù) Œæ with ht | ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      rcases eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ | HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine ‚ü®(fract_lt_one Œæ).le, ?_‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_natCast, inv_div, sub_div, mul_div_cancel_right‚ÇÄ _ Hv, add_sub_cancel]",":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    cases' le_or_lt (u : ‚Ñù) Œæ with ht ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      cases' eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine ‚ü®(fract_lt_one Œæ).le, ?_‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_ofNat, inv_div, sub_div, mul_div_cancel _ Hv, add_sub_cancel'_right]"
Mathlib/Data/Matroid/Constructions.lean,Matroid.freeOn_indep,freeOn_indep,77ff61d9f57da074d1df33f288be538476412b19,":= by
  simp [indep_iff_subset_base]","error:  unknown identifier 'indep_iff_subset_base'
error:  simp made no progress",theorem freeOn_indep_iff : (freeOn E).Indep I ‚Üî I ‚äÜ E ,":= by
  simp [indep_iff]",":= by
  simp [indep_iff_subset_base]"
Mathlib/Analysis/Convolution.lean,MeasureTheory.hasFDerivAt_convolution_right_with_param,hasFDerivAt_convolution_right_with_param,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine' (hasFDerivAt_zero_of_eventually_const 0 _).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s := Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine' ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, _, _‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C := ht.subset_closedBall_lt 0 0
    refine' ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => _‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine' mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), _, _‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine' (HasCompactSupport.convolutionExists_right L _ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº :=
    hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine' ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, _‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    apply eventually_of_forall
    intro a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    apply eventually_of_forall
    intro a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, id.def, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6","error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1587051 ‚Üí ?m.1587051
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1587346 ‚Üí ?m.1587346
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  unsolved goals
case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.1 = (_root_.id x).1

case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.2 - a = (_root_.id x).2 - a","theorem hasFDerivAt_convolution_right_with_param {g : P ‚Üí G ‚Üí E'} {s : Set P} {k : Set G}
    (hs : IsOpen s) (hk : IsCompact k) (hgs : ‚àÄ p, ‚àÄ x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0)
    (hf : LocallyIntegrable f Œº) (hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)) (q‚ÇÄ : P √ó G)
    (hq‚ÇÄ : q‚ÇÄ.1 ‚àà s) :
    HasFDerivAt (fun q : P √ó G => (f ‚ãÜ[L, Œº] g q.1) q.2)
      ((f ‚ãÜ[L.precompR (P √ó G), Œº] fun x : G => fderiv ùïú (‚Üøg) (q‚ÇÄ.1, x)) q‚ÇÄ.2) q‚ÇÄ ",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s := Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C := ht.subset_closedBall_lt 0 0
    refine ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => ?_‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), ?_, ?_‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine (HasCompactSupport.convolutionExists_right L ?_ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº :=
    hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, ?_‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    filter_upwards with a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    filter_upwards with a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, _root_.id, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s := Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans"
Mathlib/Topology/Bases.lean,Dense.exists_countable_dense_subset_bot_top,Dense.exists_countable_dense_subset_bot_top,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine ‚ü®(t ‚à™ ({ x | IsBot x } ‚à™ { x | IsTop x })) ‚à© s, ?_, ?_, ?_, ?_, ?_‚ü©
  exacts [inter_subset_right _ _,
    (htc.union ((countable_isBot Œ±).union (countable_isTop Œ±))).mono (inter_subset_left _ _),
    htd.mono (subset_inter (subset_union_left _ _) hts), fun x hx hxs => ‚ü®Or.inr <| Or.inl hx, hxs‚ü©,
    fun x hx hxs => ‚ü®Or.inr <| Or.inr hx, hxs‚ü©]","error:  function expected at
  inter_subset_right ?m.106690
term has type
  ?m.106689 ‚àà ?m.106688
error:  function expected at
  inter_subset_left ?m.106782
term has type
  ?m.106781 ‚àà ?m.106779
error:  function expected at
  subset_union_left ?m.106878
term has type
  ?m.106877 ‚àà ?m.106875 ‚à™ ?m.106876","theorem Dense.exists_countable_dense_subset_bot_top {Œ± : Type*} [TopologicalSpace Œ±]
    [PartialOrder Œ±] {s : Set Œ±} [SeparableSpace s] (hs : Dense s) :
    ‚àÉ t ‚äÜ s, t.Countable ‚àß Dense t ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àà s ‚Üí x ‚àà t) ‚àß
      ‚àÄ x, IsTop x ‚Üí x ‚àà s ‚Üí x ‚àà t ",":= by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine ‚ü®(t ‚à™ ({ x | IsBot x } ‚à™ { x | IsTop x })) ‚à© s, ?_, ?_, ?_, ?_, ?_‚ü©
  exacts [inter_subset_right,
    (htc.union ((countable_isBot Œ±).union (countable_isTop Œ±))).mono inter_subset_left,
    htd.mono (subset_inter subset_union_left hts), fun x hx hxs => ‚ü®Or.inr <| Or.inl hx, hxs‚ü©,
    fun x hx hxs => ‚ü®Or.inr <| Or.inr hx, hxs‚ü©]",":= by
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©
  refine ‚ü®(t ‚à™ ({ x | IsBot x } ‚à™ { x | IsTop x })) ‚à© s, ?_, ?_, ?_, ?_, ?_‚ü©
  exacts [inter_subset_right,
    (htc.union ((countable_isBot Œ±).union (countable_isTop Œ±))).mono inter_subset_left,
    htd.mono (subset_inter (subset_union_left hts), fun x hx hxs => ‚ü®Or.inr <| Or.inl hx, hxs‚ü©,
    fun x hx hxs => ‚ü®Or.inr <| Or.inr hx, hxs‚ü©]"
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,c480a87bf98e8eb1bd5a2eec1b3b1369bfff595d,":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x)
  ¬∑ simp_rw [inversion, dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π
    ¬∑ rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    dsimp
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
    rw [Pi.smul_apply, Pi.smul_apply, real_inner_self_eq_norm_sq]
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]
    rw [Pi.smul_apply, Pi.smul_apply]
    simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  unexpected token '¬∑'; expected '|'
error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ F ‚ÜíL[‚Ñù] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x ‚Ü¶ c + x) x) c) ^ 2 ‚Ä¢
      ‚Üë{ toLinearEquiv := (reflection (Submodule.span ‚Ñù {(fun x ‚Ü¶ c + x) x - c})·óÆ).toLinearEquiv, continuous_toFun := ‚ãØ,
          continuous_invFun := ‚ãØ })
    ((fun x ‚Ü¶ c + x) x)","theorem hasFDerivAt_inversion (hx : x ‚â† c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 ‚Ä¢ (reflection (‚Ñù ‚àô (x - c))·óÆ : F ‚ÜíL[‚Ñù] F)) x ",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (?_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x)
  ¬∑ simp_rw [inversion, dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π
    ¬∑ rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    dsimp
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]"
Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean,HomogeneousIdeal.toIdeal_homogeneousCore_eq_self,HomogeneousIdeal.toIdeal_homogeneousCore_eq_self,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  HomogeneousSubmodule.toSubmodule_homogeneousCore_eq_self I",error:  unknown identifier 'HomogeneousSubmodule.toSubmodule_homogeneousCore_eq_self',"theorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self (I : HomogeneousIdeal ùíú) :
    I.toIdeal.homogeneousCore ùíú = I ",":= by
  ext1
  convert Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self I.isHomogeneous",":=
  HomogeneousSubmodule.toSubmodule_homogeneousCore _"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding',exists_extension_norm_eq_of_closedEmbedding',3b4737b3b07aa77aaa08420241e83ad9c46eda8a,":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => ((fun g => g + F (f - g.compContinuous e))^[n]) 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel', pow_succ, mul_assoc]
      refine' (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel']
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := (mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine' tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 _)
    refine' squeeze_zero (fun _ => dist_nonneg) hgf _
    rw [‚Üê MulZeroClass.zero_mul ‚Äñf‚Äñ]
    refine' (tendsto_pow_atTop_nhds_0_of_lt_1 _ _).mul tendsto_const_nhds <;> norm_num1
  refine' ‚ü®limUnder atTop g, le_antisymm _ _, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine'
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq _
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  application type mismatch
  LE.le.trans (hF_dist (f - (g n).compContinuous e)) (mul_le_mul_of_nonneg_left ?m.115481 ?m.115895)
argument
  mul_le_mul_of_nonneg_left ?m.115481 ?m.115895
has type
  2 / 3 * ‚Äñf - (g n).compContinuous e‚Äñ ‚â§ 2 / 3 * ?m.115476 : Prop
but is expected to have type
  2 / 3 * ‚Äñf - (g n).compContinuous e‚Äñ ‚â§ (2 / 3) ^ n * (2 / 3 * ‚Äñf‚Äñ) : Prop
error:  no goals to be solved
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
warning:  `tendsto_pow_atTop_nhds_0_of_lt_1` has been deprecated, use `tendsto_pow_atTop_nhds_zero_of_lt_one` instead","theorem exists_extension_norm_eq_of_closedEmbedding' (f : X ‚Üí·µá ‚Ñù) (e : C(X, Y))
    (he : ClosedEmbedding e) : ‚àÉ g : Y ‚Üí·µá ‚Ñù, ‚Äñg‚Äñ = ‚Äñf‚Äñ ‚àß g.compContinuous e = f ",":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [‚Üê zero_mul ‚Äñf‚Äñ]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ‚ü®limUnder atTop g, le_antisymm ?_ ?_, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _",":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => ((fun g => g + F (f - g.compContinuous e))^[n]) 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel', pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel']
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [‚Üê MulZeroClass.zero_mul ‚Äñf‚Äñ]
    refine (tendsto_pow_atTop_nhds_0_of_lt_1 ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ‚ü®limUnder atTop g, le_antisymm ?_ ?_, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _"
Mathlib/GroupTheory/Perm/Support.lean,Equiv.Perm.mem_support_swap_mul_imp_mem_support_ne,mem_support_swap_mul_imp_mem_support_ne,848a859b767a9159257960fdeea9a255b1c2dd48,":= by
  simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *
  by_cases h : f y = x
  ¬∑ constructor <;> intro <;> simp_all only [if_true, eq_self_iff_true, not_true, Ne]
  ¬∑ split_ifs at hy with hf heq <;>
    simp_all only [not_true]
    ¬∑ exact ‚ü®h, hy‚ü©
    ¬∑ exact ‚ü®hy, heq‚ü©","warning:  unused name: heq
error:  simp_all made no progress
error:  unknown identifier 'heq'","theorem mem_support_swap_mul_imp_mem_support_ne {x y : Œ±} (hy : y ‚àà support (swap x (f x) * f)) :
    y ‚àà support f ‚àß y ‚â† x ",":= by
  simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *
  by_cases h : f y = x
  ¬∑ constructor <;> intro <;> simp_all only [if_true, eq_self_iff_true, not_true, Ne]
  ¬∑ split_ifs at hy with heq
    ¬∑ subst heq; exact ‚ü®h, hy‚ü©
    ¬∑ exact ‚ü®hy, heq‚ü©",":= by
  simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *
  by_cases h : f y = x
  ¬∑ constructor <;> intro <;> simp_all only [if_true, eq_self_iff_true, not_true, Ne]
  ¬∑ split_ifs at hy with hf heq <;>
    simp_all only [not_true]
    ¬∑ exact ‚ü®h, hy‚ü©
    ¬∑ exact ‚ü®hy, heq‚ü©"
Mathlib/NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean,ZMod.Ico_map_valMinAbs_natAbs_eq_Ico_map_id,Ico_map_valMinAbs_natAbs_eq_Ico_map_id,a3708498bec5c2641fd86b158487e675e90d687a,":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, lt_succ_iff, succ_le_iff, pos_iff_ne_zero,
      natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x ‚àà Ico 1 (p / 2).succ, b = (a * x : ZMod p).valMinAbs.natAbs := by
    intro b hb
    refine' ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®_, _‚ü©, _‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne.def, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [nat_cast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel' _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
      ¬∑ erw [mul_neg, mul_div_cancel' _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,
          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  simp only [‚Üê exists_prop] at hsurj
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem (fun _ _ => rfl)
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj","error:  unknown identifier 'lt_succ_iff'
error:  unsolved goals
p : ‚Ñï
hp : Fact (Nat.Prime p)
a : ZMod p
hap : a ‚â† 0
he : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2
hep : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p
hpe : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x
x : ‚Ñï
hx : x ‚àà Ico 1 (p / 2).succ
‚ä¢ (a * ‚Üëx).valMinAbs.natAbs < p / 2 + 1
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.14804 ‚Üí ?m.14804 ‚Üí Prop
error:  unsolved goals
case refine'_1.a
p : ‚Ñï
hp : Fact (Nat.Prime p)
a : ZMod p
hap : a ‚â† 0
he : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2
hep : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p
hpe : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x
hmem : ‚àÄ x ‚àà Ico 1 (p / 2).succ, (a * ‚Üëx).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ
b : ‚Ñï
hb : b ‚àà Ico 1 (p / 2).succ
‚ä¢ (‚Üëb * a‚Åª¬π).valMinAbs.natAbs ‚â† 0
warning:  `ZMod.nat_cast_natAbs_valMinAbs` has been deprecated, use `ZMod.natCast_natAbs_valMinAbs` instead
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead
error:  type mismatch
  rfl
has type
  ?m.18030 = ?m.18030 : Prop
but is expected to have type
  ‚àÄ (a‚ÇÇ : ‚Ñï) (ha‚ÇÇ : a‚ÇÇ ‚àà (Ico 1 (p / 2).succ).val),
    (fun x x_1 ‚Ü¶ (a * ‚Üëx).valMinAbs.natAbs) x‚úù¬π x‚úù = (fun x x_1 ‚Ü¶ (a * ‚Üëx).valMinAbs.natAbs) a‚ÇÇ ha‚ÇÇ ‚Üí x‚úù¬π = a‚ÇÇ : Prop
error:  application type mismatch
  inj_on_of_surj_on_of_card_le (fun a_1 ha ‚Ü¶ (a * ‚Üëa_1).valMinAbs.natAbs) hmem hsurj
argument
  hsurj
has type
  ‚àÄ b ‚àà Ico 1 (p / 2).succ, ‚àÉ x, ‚àÉ (_ : x ‚àà Ico 1 (p / 2).succ), b = (a * ‚Üëx).valMinAbs.natAbs : Prop
but is expected to have type
  ‚àÄ b ‚àà Ico 1 (p / 2).succ, ‚àÉ a_2, ‚àÉ (_ : a_2 ‚àà Ico 1 (p / 2).succ), (a * ‚Üëa_2).valMinAbs.natAbs = b : Prop","theorem Ico_map_valMinAbs_natAbs_eq_Ico_map_id (p : ‚Ñï) [hp : Fact p.Prime] (a : ZMod p)
    (hap : a ‚â† 0) : ((Ico 1 (p / 2).succ).1.map fun (x : ‚Ñï) => (a * x).valMinAbs.natAbs) =
    (Ico 1 (p / 2).succ).1.map fun a => a ",":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,
      pos_iff_ne_zero, natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x, ‚àÉ _ : x ‚àà Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®?_, ?_‚ü©, ?_‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [natCast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel‚ÇÄ _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
      ¬∑ erw [mul_neg, mul_div_cancel‚ÇÄ _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,
          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)",":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, lt_succ_iff, succ_le_iff, pos_iff_ne_zero,
      natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x ‚àà Ico 1 (p / 2).succ, b = (a * x : ZMod p).valMinAbs.natAbs := by
    intro b hb
    refine ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®_, ?_‚ü©, ?_‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [nat_cast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel' _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  simp only [‚Üê exists_prop] at hsurj
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem (fun _ _ => rfl)
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.le_mul_withDensity,le_mul_withDensity,3f810735e0ec9a13c0f8fcef14dc2ee3d0b23a7f,":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne.def] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine' le_trans (measure_mono (inter_subset_right _ _)) (le_trans (le_of_eq _) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono (inter_subset_right _ _)).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
          ‚àë' n : ‚Ñ§, (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = (t ‚Ä¢ ŒΩ) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t ‚Ä¢ ŒΩ) f_meas hs ht).symm","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.231051 ‚Üí ?m.231051 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  t ‚â† 0 : Prop
but is expected to have type
  ‚Üët ‚â† 0 : Prop
error:  function expected at
  inter_subset_right ?m.233027
term has type
  ?m.233026 ‚àà ?m.233025
error:  type mismatch
  measure_limRatioMeas_zero v hœÅ
has type
  œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 : Prop
but is expected to have type
  Set Œ± : Type u_1
error:  function expected at
  inter_subset_right ?m.235312
term has type
  ?m.235311 ‚àà ?m.235310
error:  unsolved goals
case calc.step
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
m0 : MeasurableSpace Œ±
Œº : Measure Œ±
v : VitaliFamily Œº
E : Type u_2
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : SecondCountableTopology Œ±
inst‚úù¬≤ : BorelSpace Œ±
inst‚úù¬π : IsLocallyFiniteMeasure Œº
œÅ : Measure Œ±
inst‚úù : IsLocallyFiniteMeasure œÅ
hœÅ : œÅ ‚â™ Œº
s : Set Œ±
hs : MeasurableSet s
t : ‚Ñù‚â•0
ht : 1 < t
t_ne_zero' : t ‚â† 0
t_ne_zero : ‚Üët ‚â† 0
ŒΩ : Measure Œ± := Œº.withDensity (v.limRatioMeas hœÅ)
f : Œ± ‚Üí ‚Ñù‚â•0‚àû := v.limRatioMeas hœÅ
f_meas : Measurable f
A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0})
B : œÅ (s ‚à© f ‚Åª¬π' {‚ä§}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚ä§})
n : ‚Ñ§
I : Set ‚Ñù‚â•0‚àû := Ico (‚Üët ^ n) (‚Üët ^ (n + 1))
M : MeasurableSet (s ‚à© f ‚Åª¬π' I)
‚ä¢ ‚Üët * ‚à´‚Åª (x : Œ±) in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº ‚â§ ‚Üët * ŒΩ (s ‚à© f ‚Åª¬π' Ico (‚Üët ^ n) (‚Üët ^ (n + 1)))","theorem le_mul_withDensity {s : Set Œ±} (hs : MeasurableSet s) {t : ‚Ñù‚â•0} (ht : 1 < t) :
    œÅ s ‚â§ t * Œº.withDensity (v.limRatioMeas hœÅ) s ",":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ŒΩ, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
          ‚àë' n : ‚Ñ§, (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = (t ‚Ä¢ ŒΩ) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t ‚Ä¢ ŒΩ) f_meas hs ht).symm",":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {0}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_me"
Mathlib/Order/CompleteLattice.lean,sSup_diff_singleton_bot,sSup_diff_singleton_bot,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":=
  (sSup_le_sSup (diff_subset _ _)).antisymm <|
    sSup_le_sSup_of_subset_insert_bot <| subset_insert_diff_singleton _ _","error:  function expected at
  diff_subset ?m.35426
term has type
  ?m.35425 ‚àà ?m.35423",theorem sSup_diff_singleton_bot (s : Set Œ±) : sSup (s \ {‚ä•}) = sSup s ,":=
  (sSup_le_sSup diff_subset).antisymm <|
    sSup_le_sSup_of_subset_insert_bot <| subset_insert_diff_singleton _ _",":=
  (sSup_le_sSup diff_subset).antisymm <|
    sSup_le_sSup_of_subset_insert_bot <| subset_insert_diff_singleton _ _"
Mathlib/Combinatorics/Optimization/ValuedCSP.lean,Function.HasMaxCutPropertyAt.rows_lt_aux,Function.HasMaxCutPropertyAt.rows_lt_aux,8b1c0c0542396f3504037d03fabae0655d19d8d5,":= by
  rw [FractionalOperation.tt, Multiset.mem_map] at rin
  rw [show r = ![r 0, r 1] from List.ofFn_inj.mp (by simp [List.ofFn, Array.ofFn, Array.ofFn.go])]
  apply lt_of_le_of_ne (mcf.right (r 0) (r 1)).left
  intro equ
  have asymm : r 0 ‚â† r 1 := by
    rcases (mcf.right (r 0) (r 1)).right equ with ‚ü®ha0, hb1‚ü© | ‚ü®ha1, hb0‚ü©
    ¬∑ rw [ha0, hb1] at hab
      exact hab
    ¬∑ rw [ha1, hb0] at hab
      exact hab.symm
  apply asymm
  obtain ‚ü®o, in_omega, rfl‚ü© := rin
  show o (fun j => ![![a, b], ![b, a]] j 0) = o (fun j => ![![a, b], ![b, a]] j 1)
  have := List.Perm.swap b a []
  convert symmega ![a, b] ![b, a] (by simpa using this)  o in_omega using 2 <;>
    simp [Matrix.const_fin1_eq]","error:  unsolved goals
D : Type u_1
C‚úù : Type u_2
inst‚úù¬π : OrderedAddCommMonoid C‚úù
m : ‚Ñï
C : Type u_3
inst‚úù : OrderedCancelAddCommMonoid C
f : (Fin 2 ‚Üí D) ‚Üí C
a b : D
mcf : HasMaxCutPropertyAt f a b
hab : a ‚â† b
œâ : FractionalOperation D 2
symmega : œâ.IsSymmetric
r : Fin 2 ‚Üí D
rin : ‚àÉ a_1 ‚àà œâ, (fun i ‚Ü¶ a_1 (swap ![![a, b], ![b, a]] i)) = r
‚ä¢ List.ofFn.go r 2 0 ‚ãØ = List.ofFn.go ![r 0, r 1] 2 0 ‚ãØ","lemma Function.HasMaxCutPropertyAt.rows_lt_aux
    {f : (Fin 2 ‚Üí D) ‚Üí C} {a b : D} (mcf : f.HasMaxCutPropertyAt a b) (hab : a ‚â† b)
    {œâ : FractionalOperation D 2} (symmega : œâ.IsSymmetric)
    {r : Fin 2 ‚Üí D} (rin : r ‚àà (œâ.tt ![![a, b], ![b, a]])) :
    f ![a, b] < f r ",":= by
  rw [FractionalOperation.tt, Multiset.mem_map] at rin
  rw [show r = ![r 0, r 1] from List.ofFn_inj.mp rfl]
  apply lt_of_le_of_ne (mcf.right (r 0) (r 1)).left
  intro equ
  have asymm : r 0 ‚â† r 1 := by
    rcases (mcf.right (r 0) (r 1)).right equ with ‚ü®ha0, hb1‚ü© | ‚ü®ha1, hb0‚ü©
    ¬∑ rw [ha0, hb1] at hab
      exact hab
    ¬∑ rw [ha1, hb0] at hab
      exact hab.symm
  apply asymm
  obtain ‚ü®o, in_omega, rfl‚ü© := rin
  show o (fun j => ![![a, b], ![b, a]] j 0) = o (fun j => ![![a, b], ![b, a]] j 1)
  convert symmega ![a, b] ![b, a] (List.Perm.swap b a []) o in_omega using 2 <;>
    simp [Matrix.const_fin1_eq]",":= by
  rw [FractionalOperation.tt, Multiset.mem_map] at rin
  rw [show r = ![r 0, r 1] from List.ofFn_inj.mp (by simp [List.ofFn, Array.ofFn, Array.ofFn.go])]
  apply lt_of_le_of_ne (mcf.right (r 0) (r 1)).left
  intro equ
  have asymm : r 0 ‚â† r 1 := by
    rcases (mcf.right (r 0) (r 1)).right equ with ‚ü®ha0, hb1‚ü© | ‚ü®ha1, hb0‚ü©
    ¬∑ rw [ha0, hb1] at hab
      exact hab.symm
  apply asymm
  obtain ‚ü®o, in_omega, rfl‚ü© := rin
  show o (fun j => ![![a, b], ![b, a]] j 0) = o (fun j => ![![a, b], ![b, a]] j 1)
  have := List.Perm.swap b a []
  convert symmega ![a, b] ![b, a] (by simpa using this)  o in_omega using 2 <;>
    simp [Matrix.const_fin1_eq]"
Mathlib/Algebra/Homology/TotalComplex.lean,HomologicalComplex‚ÇÇ.Œπ_totalDesc,Œπ_totalDesc,10f63baf7e1660a2ffa3e891eef40812f434a38f,":= by
  simp [totalDesc]","error:  unsolved goals
C : Type u_1
inst‚úù‚Å¥ : Category.{u_5, u_1} C
inst‚úù¬≥ : Preadditive C
I‚ÇÅ : Type u_2
I‚ÇÇ : Type u_3
I‚ÇÅ‚ÇÇ : Type u_4
c‚ÇÅ : ComplexShape I‚ÇÅ
c‚ÇÇ : ComplexShape I‚ÇÇ
K L M : HomologicalComplex‚ÇÇ C c‚ÇÅ c‚ÇÇ
œÜ : K ‚ü∂ L
e : K ‚âÖ L
œà : L ‚ü∂ M
c‚ÇÅ‚ÇÇ : ComplexShape I‚ÇÅ‚ÇÇ
inst‚úù¬≤ : DecidableEq I‚ÇÅ‚ÇÇ
inst‚úù¬π : TotalComplexShape c‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ
inst‚úù : K.HasTotal c‚ÇÅ‚ÇÇ
A : C
i‚ÇÅ‚ÇÇ : I‚ÇÅ‚ÇÇ
f : (i‚ÇÅ : I‚ÇÅ) ‚Üí (i‚ÇÇ : I‚ÇÇ) ‚Üí c‚ÇÅ.œÄ c‚ÇÇ c‚ÇÅ‚ÇÇ (i‚ÇÅ, i‚ÇÇ) = i‚ÇÅ‚ÇÇ ‚Üí ((K.X i‚ÇÅ).X i‚ÇÇ ‚ü∂ A)
i‚ÇÅ : I‚ÇÅ
i‚ÇÇ : I‚ÇÇ
hi : c‚ÇÅ.œÄ c‚ÇÇ c‚ÇÅ‚ÇÇ (i‚ÇÅ, i‚ÇÇ) = i‚ÇÅ‚ÇÇ
‚ä¢ (K.ŒπTotal c‚ÇÅ‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÅ‚ÇÇ hi ‚â´ K.toGradedObject.descMapObj (c‚ÇÅ.œÄ c‚ÇÇ c‚ÇÅ‚ÇÇ) fun x hi ‚Ü¶ f x.1 x.2 hi) = f i‚ÇÅ i‚ÇÇ hi","lemma Œπ_totalDesc (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (hi : ComplexShape.œÄ c‚ÇÅ c‚ÇÇ c‚ÇÅ‚ÇÇ (i‚ÇÅ, i‚ÇÇ) = i‚ÇÅ‚ÇÇ) :
    K.ŒπTotal c‚ÇÅ‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÅ‚ÇÇ hi ‚â´ K.totalDesc f = f i‚ÇÅ i‚ÇÇ hi ",":= by
  simp [totalDesc, ŒπTotal]",":= by
  rw [totalDesc]"
Mathlib/GroupTheory/FreeAbelianGroup.lean,FreeAbelianGroup.lift.add',lift.add',fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine FreeAbelianGroup.induction_on a ?_? ?_ _? _
  ¬∑ simp only [(lift _).map_zero, zero_add]
  ¬∑ intro x
    simp only [lift.of, Pi.add_apply]
  ¬∑ intro x _
    simp only [map_neg, lift.of, Pi.add_apply, neg_add]
  ¬∑ intro x y hx hy
    simp only [(lift _).map_add, hx, hy, add_add_add_comm]","error:  unknown identifier '_?'
error:  unsolved goals
Œ±‚úù : Type u
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù : AddCommGroup Œ≤
a : FreeAbelianGroup Œ±
f g : Œ± ‚Üí Œ≤
‚ä¢ (lift (f + g)) a = (lift f) a + (lift g) a","theorem lift.add' {Œ± Œ≤} [AddCommGroup Œ≤] (a : FreeAbelianGroup Œ±) (f g : Œ± ‚Üí Œ≤) :
    lift (f + g) a = lift f a + lift g a ",":= by
  refine FreeAbelianGroup.induction_on a ?_ ?_ ?_ ?_
  ¬∑ simp only [(lift _).map_zero, zero_add]
  ¬∑ intro x
    simp only [lift.of, Pi.add_apply]
  ¬∑ intro x _
    simp only [map_neg, lift.of, Pi.add_apply, neg_add]
  ¬∑ intro x y hx hy
    simp only [(lift _).map_add, hx, hy, add_add_add_comm]",":= by
  refine FreeAbelianGroup.induction_on a ?_
  ¬∑ intro x _
    simp only [map_neg, lift.of, Pi.add_apply, neg_add]
  ¬∑ intro x y hx hy
    simp only [(lift _).map_add, hx, hy, add_add_add_comm]"
Mathlib/Data/Nat/Factorization/Basic.lean,Nat.factors_count_eq,factors_count_eq,4dfaa68b610f4fec195818efd185e26e366b84e8,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization, coe_mk, pp, if_true]
  rw [‚Üê PartENat.natCast_inj, padicValNat_def' pp.ne_one hn0]
  apply _root_.le_antisymm
  ¬∑ rw [le_multiplicity_iff_replicate_le_normalizedFactors' pp hn0.ne']
    have := List.le_count_iff_replicate_sublist.mp (le_refl (n.factors.count p))
    exact this.subperm
  ¬∑ apply PartENat.le_of_lt_add_one
    rw [‚Üê Nat.cast_one, ‚Üê Nat.cast_add, lt_iff_not_ge, ge_iff_le, le_multiplicity_iff_replicate_le_normalizedFactors' pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this","error:  unknown identifier 'le_multiplicity_iff_replicate_le_normalizedFactors''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.7160
case inr.a
a b m n‚úù p‚úù n p : ‚Ñï
hn0 : n > 0
pp : Prime p
‚ä¢ ‚Üë(count p n.factors) ‚â§ multiplicity p n
error:  unknown identifier 'le_multiplicity_iff_replicate_le_normalizedFactors''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.7638
case inr.a.h
a b m n‚úù p‚úù n p : ‚Ñï
hn0 : n > 0
pp : Prime p
‚ä¢ ¬¨‚Üë(count p n.factors + 1) ‚â§ multiplicity p n",theorem factors_count_eq {n p : ‚Ñï} : n.factors.count p = n.factorization p ,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization_def _ pp]
  apply _root_.le_antisymm
  ¬∑ rw [le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm
  ¬∑ rw [‚Üê Nat.lt_add_one_iff, lt_iff_not_ge, ge_iff_le,
      le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this",":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  ¬∑ simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization, coe_mk, pp, if_true]
  rw [‚Üê PartENat.natCast_inj, padicValNat_def' pp.ne_one hn0]
  apply _root_.le_antisymm
  ¬∑ rw [le_multiplicity_iff_replicate_le_normalizedFactors' pp hn0.ne']
    have := List.le_count_iff_replicate_sublist.mp (le_refl (n.factors.count p))
    exact this.subperm
  ¬∑ apply PartENat.le_of_lt_add_one
    rw [‚Üê Nat.cast_ne, ‚Üê Nat.cast_add, lt_iff_not_ge, ge_iff_le, le_multiplicity_iff_replicate_le_normalizedFactors' pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this"
Mathlib/Analysis/Normed/Group/Quotient.lean,quotient_norm_add_le,quotient_norm_add_le,2c51ddac66e30dac33162736742396566e191ff8,":= by
  rcases And.intro (mk_surjective x) (mk_surjective y) with ‚ü®‚ü®x, rfl‚ü©, ‚ü®y, rfl‚ü©‚ü©
  simp only [‚Üê mk'_apply, ‚Üê map_add, quotient_norm_mk_eq, inf‚Çõ_image']
  refine le_cinf·µ¢_add_cinf·µ¢ fun a b ‚Ü¶ ?_
  refine cinf·µ¢_le_of_le ‚ü®0, forall_range_iff.2 fun _ ‚Ü¶ norm_nonneg _‚ü© (a + b) ?_
  exact (congr_arg norm (add_add_add_comm _ _ _ _)).trans_le (norm_add_le _ _)","error:  unknown identifier 'inf‚Çõ_image''
error:  unknown identifier 'le_cinf·µ¢_add_cinf·µ¢'
error:  no goals to be solved",theorem quotient_norm_add_le (S : AddSubgroup M) (x y : M ‚ß∏ S) : ‚Äñx + y‚Äñ ‚â§ ‚Äñx‚Äñ + ‚Äñy‚Äñ ,":= by
  rcases And.intro (mk_surjective x) (mk_surjective y) with ‚ü®‚ü®x, rfl‚ü©, ‚ü®y, rfl‚ü©‚ü©
  simp only [‚Üê mk'_apply, ‚Üê map_add, quotient_norm_mk_eq, sInf_image']
  refine le_ciInf_add_ciInf fun a b ‚Ü¶ ?_
  refine ciInf_le_of_le ‚ü®0, forall_mem_range.2 fun _ ‚Ü¶ norm_nonneg _‚ü© (a + b) ?_
  exact (congr_arg norm (add_add_add_comm _ _ _ _)).trans_le (norm_add_le _ _)",":= by
  rcases And.intro (mk_surjective x) (mk_surjective y) with ‚ü®‚ü®x, rfl‚ü©, ‚ü®y, rfl‚ü©‚ü©
  simp only [‚Üê mk'_apply, ‚Üê map_add, quotient_norm_mk_eq, inf‚Çõ_image']
  refine le_cinf·µ¢_add_cinf·µ¢ fun a b ‚Ü¶ ?_
  refine cinf·µ¢_le_of_le ‚ü®0, forall_range_iff.2 fun _ ‚Ü¶ norm_nonneg _‚ü© (a + b) ?_
  exact (congr_arg norm (add_add_add_comm _ _ _ _)).trans_le (norm_add_le _ _)"
Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,CategoryTheory.MorphismProperty.LeftFraction.comp‚ÇÄ_rel,comp‚ÇÄ_rel,9072ff84a0d139a344bf9eed4a00c4cd27596c79,":= by
  obtain ‚ü®z‚ÇÑ, fac‚ü© := HasLeftCalculusOfFractions.exists_leftFraction
    (RightFraction.mk z‚ÇÉ.s z‚ÇÉ.hs z‚ÇÉ'.s)
  dsimp at fac
  have eq : z‚ÇÅ.s ‚â´ z‚ÇÉ.f ‚â´ z‚ÇÑ.f = z‚ÇÅ.s ‚â´ z‚ÇÉ'.f ‚â´ z‚ÇÑ.s := by
    rw [‚Üê reassoc_of% h‚ÇÉ, ‚Üê reassoc_of% h‚ÇÉ', fac]
  obtain ‚ü®Y, t, ht, fac'‚ü© := HasLeftCalculusOfFractions.ext _ _ _ z‚ÇÅ.hs eq
  simp only [assoc] at fac'
  refine' ‚ü®Y, z‚ÇÑ.f ‚â´ t, z‚ÇÑ.s ‚â´ t, _, _, _‚ü©
  ¬∑ simp only [comp‚ÇÄ, assoc, reassoc_of% fac]
  ¬∑ simp only [comp‚ÇÄ, assoc, fac']
  ¬∑ simp only [comp‚ÇÄ, assoc, ‚Üê reassoc_of% fac]","error:  unsolved goals
case intro.intro.intro.intro.refine'_3
C : Type u_1
D : Type u_2
inst‚úù¬≤ : Category.{u_3, u_1} C
inst‚úù¬π : Category.{?u.28084, u_2} D
W : MorphismProperty C
inst‚úù : W.HasLeftCalculusOfFractions
X Y‚úù Z : C
z‚ÇÅ : W.LeftFraction X Y‚úù
z‚ÇÇ : W.LeftFraction Y‚úù Z
z‚ÇÉ z‚ÇÉ' : W.LeftFraction z‚ÇÅ.Y' z‚ÇÇ.Y'
h‚ÇÉ : z‚ÇÇ.f ‚â´ z‚ÇÉ.s = z‚ÇÅ.s ‚â´ z‚ÇÉ.f
h‚ÇÉ' : z‚ÇÇ.f ‚â´ z‚ÇÉ'.s = z‚ÇÅ.s ‚â´ z‚ÇÉ'.f
z‚ÇÑ : W.LeftFraction z‚ÇÉ.Y' z‚ÇÉ'.Y'
fac : z‚ÇÉ'.s ‚â´ z‚ÇÑ.s = z‚ÇÉ.s ‚â´ z‚ÇÑ.f
eq : z‚ÇÅ.s ‚â´ z‚ÇÉ.f ‚â´ z‚ÇÑ.f = z‚ÇÅ.s ‚â´ z‚ÇÉ'.f ‚â´ z‚ÇÑ.s
Y : C
t : z‚ÇÑ.Y' ‚ü∂ Y
ht : W t
fac' : z‚ÇÉ.f ‚â´ z‚ÇÑ.f ‚â´ t = z‚ÇÉ'.f ‚â´ z‚ÇÑ.s ‚â´ t
‚ä¢ W (z‚ÇÇ.s ‚â´ z‚ÇÉ'.s ‚â´ z‚ÇÑ.s ‚â´ t)","lemma comp‚ÇÄ_rel {X Y Z : C} (z‚ÇÅ : W.LeftFraction X Y) (z‚ÇÇ : W.LeftFraction Y Z)
    (z‚ÇÉ z‚ÇÉ' : W.LeftFraction z‚ÇÅ.Y' z‚ÇÇ.Y') (h‚ÇÉ : z‚ÇÇ.f ‚â´ z‚ÇÉ.s = z‚ÇÅ.s ‚â´ z‚ÇÉ.f)
    (h‚ÇÉ' : z‚ÇÇ.f ‚â´ z‚ÇÉ'.s = z‚ÇÅ.s ‚â´ z‚ÇÉ'.f) :
    LeftFractionRel (z‚ÇÅ.comp‚ÇÄ z‚ÇÇ z‚ÇÉ) (z‚ÇÅ.comp‚ÇÄ z‚ÇÇ z‚ÇÉ') ",":= by
  obtain ‚ü®z‚ÇÑ, fac‚ü© := exists_leftFraction (RightFraction.mk z‚ÇÉ.s z‚ÇÉ.hs z‚ÇÉ'.s)
  dsimp at fac
  have eq : z‚ÇÅ.s ‚â´ z‚ÇÉ.f ‚â´ z‚ÇÑ.f = z‚ÇÅ.s ‚â´ z‚ÇÉ'.f ‚â´ z‚ÇÑ.s := by
    rw [‚Üê reassoc_of% h‚ÇÉ, ‚Üê reassoc_of% h‚ÇÉ', fac]
  obtain ‚ü®Y, t, ht, fac'‚ü© := HasLeftCalculusOfFractions.ext _ _ _ z‚ÇÅ.hs eq
  simp only [assoc] at fac'
  refine ‚ü®Y, z‚ÇÑ.f ‚â´ t, z‚ÇÑ.s ‚â´ t, ?_, ?_, ?_‚ü©
  ¬∑ simp only [comp‚ÇÄ, assoc, reassoc_of% fac]
  ¬∑ simp only [comp‚ÇÄ, assoc, fac']
  ¬∑ simp only [comp‚ÇÄ, assoc, ‚Üê reassoc_of% fac]
    exact W.comp_mem _ _ z‚ÇÇ.hs (W.comp_mem _ _ z‚ÇÉ'.hs (W.comp_mem _ _ z‚ÇÑ.hs ht))",":= by
  obtain ‚ü®z‚ÇÑ, fac‚ü© := HasLeftCalculusOfFractions.exists_leftFraction
    (RightFraction.mk z‚ÇÉ.s z‚ÇÉ.hs z‚ÇÉ'.s)
  dsimp at fac
  have eq : z‚ÇÅ.s ‚â´ z‚ÇÉ.f ‚â´ z‚ÇÑ.f = z‚ÇÅ.s ‚â´ z‚ÇÉ'.f ‚â´ z‚ÇÑ.s := by
    rw [‚Üê reassoc_of% h‚ÇÉ, ‚Üê reassoc_of% h‚ÇÉ', fac]
  obtain ‚ü®Y, t, ht, fac'‚ü© := HasLeftCalculusOfFractions.ext _ _ _ z‚ÇÅ.hs eq
  simp only [assoc] at fac'
  refine ‚ü®Y, z‚ÇÑ.f ‚â´ t, z‚ÇÑ.s ‚â´ t, ?_, ?_, ?_‚ü©
  ¬∑ simp only [comp‚ÇÄ, assoc, reassoc_of% fac]
  ¬∑ simp only [comp‚ÇÄ, assoc, ‚Üê reassoc_of% fac]"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero, Nat.zero_eq,
          Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120388 ‚Üí ?m.120388
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.123472 ‚Üí ?m.123472
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà u 0, closedBall p.1 p.2) ‚â§ Œº s
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133159 ‚Üí ?m.133159 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133295 ‚Üí ?m.133295 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/Topology/CompactOpen.lean,ContinuousMap.continuous_restrict,continuous_restrict,161c69c1dbf66cf3c7ec4f648a61551d044a43e4,":= by
  rw [continuous_iff_le_induced]
  exact compactOpen_le_induced s","error:  unknown identifier 'compactOpen_le_induced'
warning:  `ContinuousMap.curry'` has been deprecated, use `ContinuousMap.curry` instead","theorem continuous_restrict (s : Set X) : Continuous fun F : C(X, Y) => F.restrict s ",":=
  continuous_comp_left <| restrict s <| .id X",":= by
  rw [continuous_iff_le_induced]
  exact compactOpen_le_induced s"
Mathlib/Analysis/InnerProductSpace/Projection.lean,finrank_orthogonal_span_singleton,finrank_orthogonal_span_singleton,49b8ee5c731881e8d562a13d37f3ee3fd50b8092,":= by
  haveI : FiniteDimensional ùïú E := Module.finite_of_fact_finrank_eq_succ n
  exact Submodule.finrank_add_finrank_orthogonal' <| by
    simp [finrank_span_singleton hv, _i.elim, add_comm]",error:  unknown constant 'Module.finite_of_fact_finrank_eq_succ',"theorem finrank_orthogonal_span_singleton {n : ‚Ñï} [_i : Fact (finrank ùïú E = n + 1)] {v : E}
    (hv : v ‚â† 0) : finrank ùïú (ùïú ‚àô v)·óÆ = n ",":= by
  haveI : FiniteDimensional ùïú E := .of_fact_finrank_eq_succ n
  exact Submodule.finrank_add_finrank_orthogonal' <| by
    simp [finrank_span_singleton hv, _i.elim, add_comm]",":= by
  haveI : FiniteDimensional ùïú E := Module.finite_of_fact_finrank_eq_succ n
  exact Submodule.finrank_add_finrank_orthogonal' <| by
    simp [finrank_span_singleton hv, _i.elim, add_comm]"
Mathlib/LinearAlgebra/CliffordAlgebra/Basic.lean,CliffordAlgebra.induction,induction,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  let s : Subalgebra R (CliffordAlgebra Q) :=
    { carrier := ‚ü®C‚ü©
      mul_mem' := @mul
      add_mem' := @add
      algebraMap_mem' := algebraMap }
  letI h : AddCommMonoid s := inferInstanceAs (AddCommMonoid (Subalgebra.toSubmodule s))
  let of : { f : M ‚Üí‚Çó[R] s // ‚àÄ m, f m * f m = _root_.algebraMap _ _ (Q m) } :=
    ‚ü®(CliffordAlgebra.Œπ Q).codRestrict (Subalgebra.toSubmodule s) Œπ,
      fun m => Subtype.eq <| Œπ_sq_scalar Q m‚ü©
  have of_id : AlgHom.id R (CliffordAlgebra Q) = s.val.comp (lift Q of) := by
    ext
    simp [of]
    erw [LinearMap.codRestrict_apply]
  rw [‚Üê AlgHom.id_apply (R := R) a, of_id]
  exact Subtype.prop (lift Q of a)","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  CliffordAlgebra Q ‚Üí Prop
error:  application type mismatch
  LinearMap.codRestrict (Subalgebra.toSubmodule s) (CliffordAlgebra.Œπ Q) Œπ
argument
  Œπ
has type
  ‚àÄ (x : M), C ((CliffordAlgebra.Œπ Q) x) : Prop
but is expected to have type
  ‚àÄ (c : M), (CliffordAlgebra.Œπ Q) c ‚àà Subalgebra.toSubmodule s : Prop
error:  type mismatch
  Subtype.prop (((lift Q) of) a)
has type
  ‚Üë(((lift Q) of) a) ‚àà s : Prop
but is expected to have type
  C ((s.val.comp ((lift Q) of)) a) : Prop","theorem induction {C : CliffordAlgebra Q ‚Üí Prop}
    (algebraMap : ‚àÄ r, C (algebraMap R (CliffordAlgebra Q) r)) (Œπ : ‚àÄ x, C (Œπ Q x))
    (mul : ‚àÄ a b, C a ‚Üí C b ‚Üí C (a * b)) (add : ‚àÄ a b, C a ‚Üí C b ‚Üí C (a + b))
    (a : CliffordAlgebra Q) : C a ",":= by
  let s : Subalgebra R (CliffordAlgebra Q) :=
    { carrier := C
      mul_mem' := @mul
      add_mem' := @add
      algebraMap_mem' := algebraMap }
  letI h : AddCommMonoid s := inferInstanceAs (AddCommMonoid (Subalgebra.toSubmodule s))
  let of : { f : M ‚Üí‚Çó[R] s // ‚àÄ m, f m * f m = _root_.algebraMap _ _ (Q m) } :=
    ‚ü®(CliffordAlgebra.Œπ Q).codRestrict (Subalgebra.toSubmodule s) Œπ,
      fun m => Subtype.eq <| Œπ_sq_scalar Q m‚ü©
  have of_id : AlgHom.id R (CliffordAlgebra Q) = s.val.comp (lift Q of) := by
    ext
    simp [of]
    erw [LinearMap.codRestrict_apply]
  rw [‚Üê AlgHom.id_apply (R := R) a, of_id]
  exact Subtype.prop (lift Q of a)",":= by
  let s : Subalgebra R (CliffordAlgebra Q) :=
    { carrier := ‚ü®C‚ü©
      mul_mem' := @add
      algebraMap_mem' := algebraMap }
  letI h : AddCommMonoid s := inferInstanceAs (AddCommMonoid (Subalgebra.toSubmodule s))
  let of : { f : M ‚Üí‚Çó[R] s // ‚àÄ m, f m * f m = _root_.algebraMap _ _ (Q m) } :=
    ‚ü®(CliffordAlgebra.Œπ Q).codRestrict (Subalgebra.toSubmodule s) Œπ,
      fun m => Subtype.eq <| Œπ_sq_scalar Q m‚ü©
  have of_id : AlgHom.id R (CliffordAlgebra Q) = s.val.comp (lift Q of) := by
    ext
    simp [of]
    erw [LinearMap.codRestrict_apply]
  rw [‚Üê AlgHom.id_apply (R := R) a, of_id]
  exact Subtype.prop (lift Q of a)"
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,b15c6ea0b0ad3ac6e15420c45ece165eca6725cc,":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp (config := { unfoldPartialApp := true }) only [inversion]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π
    ¬∑ rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    dsimp
    simp only [add_sub_cancel', ContinuousLinearMap.comp_id, neg_smul, smul_neg,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, eqOn_singleton,
      ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, id_eq, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      two_mul, smul_add, Pi.add_apply, neg_add_rev, add_smul,
      reflection_orthogonalComplement_singleton_eq_neg]
    rw [Pi.smul_apply, Pi.smul_apply, real_inner_self_eq_norm_sq]
    simp only [smul_eq_mul, this, add_neg_cancel_comm_assoc]
  ¬∑ simp only [id_eq, Function.comp_apply, add_sub_cancel', ContinuousLinearMap.comp_id,
      neg_smul, smul_neg, ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, ContinuousLinearEquiv.coe_coe,
      LinearIsometryEquiv.coe_coe, reflection_mem_subspace_eq_self hy, add_right_eq_self,
      neg_eq_zero, smul_eq_zero]
    rw [Pi.smul_apply, Pi.smul_apply]
    simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  unexpected token '¬∑'; expected '|'
error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ F ‚ÜíL[‚Ñù] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x ‚Ü¶ c + x) x) c) ^ 2 ‚Ä¢
      ‚Üë{ toLinearEquiv := (reflection (Submodule.span ‚Ñù {(fun x ‚Ü¶ c + x) x - c})·óÆ).toLinearEquiv, continuous_toFun := ‚ãØ,
          continuous_invFun := ‚ãØ })
    ((fun x ‚Ü¶ c + x) x)","theorem hasFDerivAt_inversion (hx : x ‚â† c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 ‚Ä¢ (reflection (‚Ñù ‚àô (x - c))·óÆ : F ‚ÜíL[‚Ñù] F)) x ",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (?_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp (config := { unfoldPartialApp := true }) only [inversion]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π
    ¬∑ rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    dsimp
    simp only [add_sub_cancel', ContinuousLinearMap.comp_id, neg_smul, smul_neg,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, eqOn_singleton,
      ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, eqOn_singleton,
      ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, eqOn_singleton,
      ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, ContinuousLinearEquiv.coe_coe,
      LinearIsometryEquiv.coe_coe, reflection_mem_subspace_eq_self hy, add_right_eq_self,
      neg_eq_zero, smul_eq_zero]
    rw [Pi.smul_apply, Pi.smul_apply]
    simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow, inv_pow, ContinuousLinearEquiv.coe_coe,
      LinearIsometryEquiv.coe_coe, reflection_mem_subspace_eq_self hy, add_right_eq_self,
      neg_eq_zero, smul_eq_zero]
    rw [Pi.smul_apply, Pi.smul_apply]
    simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
     "
Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Degree.lean,WeierstrassCurve.natDegree_preŒ®_le,natDegree_preŒ®_le,409be1ff4c306030afd38a2641547686c28f2646,":= by
  induction n using Int.negInduction with
  | nat n => exact_mod_cast W.preŒ®_ofNat n ‚ñ∏ W.natDegree_preŒ®'_le n
  | neg ih => simp only [preŒ®_neg, natDegree_neg, Int.natAbs_neg, even_neg, ih]","error:  invalid argument, variable is not a proposition or let-declaration
error:  unsolved goals
case neg
R : Type u
inst‚úù : CommRing R
W : WeierstrassCurve R
ih : ‚Ñï
a‚úù : (W.preŒ® ‚Üëih).natDegree ‚â§ ((‚Üëih).natAbs ^ 2 - if Even ‚Üëih then 4 else 1) / 2
‚ä¢ (W.preŒ® ‚Üëih).natDegree ‚â§ ((‚Üëih).natAbs ^ 2 - if Even ‚Üëih then 4 else 1) / 2","lemma natDegree_preŒ®_le (n : ‚Ñ§) : (W.preŒ® n).natDegree ‚â§
    (n.natAbs ^ 2 - if Even n then 4 else 1) / 2 ",":= by
  induction n using Int.negInduction with
  | nat n => exact_mod_cast W.preŒ®_ofNat n ‚ñ∏ W.natDegree_preŒ®'_le n
  | neg => simpa only [preŒ®_neg, natDegree_neg, Int.natAbs_neg, even_neg]",":= by
  induction n using Int.negInduction with
  | nat n => exact_mod_cast W.preŒ®_ofNat n ‚ñ∏ W.natDegree_preŒ®'_le n
  | neg ih => simp only [preŒ®_neg, natDegree_neg, Int.natAbs_neg, even_neg, ih]"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,961db629df93e5dbd02440deee4c37efcf2faa85,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/Topology/Metrizable/Urysohn.lean,TopologicalSpace.exists_inducing_l_infty,exists_inducing_l_infty,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono (inter_subset_left _ _)).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => ?_
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => ?_‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _","error:  function expected at
  inter_subset_left ?m.504
term has type
  ?m.503 ‚àà ?m.501","theorem exists_inducing_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Inducing f ",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => ?_
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => ?_‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.isometry_extend (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,6861d9247d1a06a093e444c3a0319e5ec45263c2,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      apply reflection_mem_subspace_eq_self
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      apply reflection_mem_subspace_eq_self
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
    rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,stereographic'_target,stereographic'_target,ef3c9bcd07782b044027916a64e925f3e4951707,:= by simp [stereographic']; sorry,error:  no goals to be solved,"theorem stereographic'_target {n : ‚Ñï} [Fact (finrank ‚Ñù E = n + 1)] (v : sphere (0 : E) 1) :
    (stereographic' n v).target = Set.univ ",:= by simp [stereographic'],:= by simp [stereographic']
Mathlib/NumberTheory/PrimeCounting.lean,Nat.primeCounting'_add_le,primeCounting'_add_le,40b58304ad9cb6913d2d4e97172b2c306fdb61f2,":=
  calc
    œÄ' (k + n) ‚â§ ((range k).filter Prime).card + ((Ico k (k + n)).filter Prime).card := by
      rw [primeCounting', count_eq_card_filter_range, range_eq_Ico, ‚Üê
        Ico_union_Ico_eq_Ico (zero_le k) le_self_add, filter_union]
      apply card_union_le
    _ ‚â§ œÄ' k + ((Ico k (k + n)).filter Prime).card := by
      rw [primeCounting', count_eq_card_filter_range]
    _ ‚â§ œÄ' k + ((Ico k (k + n)).filter (coprime a)).card := by
      refine' add_le_add_left (card_le_of_subset _) k.primeCounting'
      simp only [subset_iff, and_imp, mem_filter, mem_Ico]
      intro p succ_k_le_p p_lt_n p_prime
      constructor
      ¬∑ exact ‚ü®succ_k_le_p, p_lt_n‚ü©
      ¬∑ rw [coprime_comm]
        exact coprime_of_lt_prime h0 (gt_of_ge_of_gt succ_k_le_p h1) p_prime
    _ ‚â§ œÄ' k + totient a * (n / a + 1) := by
      rw [add_le_add_iff_left]
      exact Ico_filter_coprime_le k n h0","warning:  primeCounting does not have a doc string
warning:  primeCounting' does not have a doc string
error:  unknown identifier 'coprime'
warning:  `Finset.card_le_of_subset` has been deprecated, use `Finset.card_le_card` instead","theorem primeCounting'_add_le {a k : ‚Ñï} (h0 : 0 < a) (h1 : a < k) (n : ‚Ñï) :
    œÄ' (k + n) ‚â§ œÄ' k + Nat.totient a * (n / a + 1) ",":=
  calc
    œÄ' (k + n) ‚â§ ((range k).filter Prime).card + ((Ico k (k + n)).filter Prime).card := by
      rw [primeCounting', count_eq_card_filter_range, range_eq_Ico, ‚Üê
        Ico_union_Ico_eq_Ico (zero_le k) le_self_add, filter_union]
      apply card_union_le
    _ ‚â§ œÄ' k + ((Ico k (k + n)).filter Prime).card := by
      rw [primeCounting', count_eq_card_filter_range]
    _ ‚â§ œÄ' k + ((Ico k (k + n)).filter (Coprime a)).card := by
      refine add_le_add_left (card_le_card ?_) k.primeCounting'
      simp only [subset_iff, and_imp, mem_filter, mem_Ico]
      intro p succ_k_le_p p_lt_n p_prime
      constructor
      ¬∑ exact ‚ü®succ_k_le_p, p_lt_n‚ü©
      ¬∑ rw [coprime_comm]
        exact coprime_of_lt_prime h0 (gt_of_ge_of_gt succ_k_le_p h1) p_prime
    _ ‚â§ œÄ' k + totient a * (n / a + 1) := by
      rw [add_le_add_iff_left]
      exact Ico_filter_coprime_le k n h0",":=
  calc
    œÄ' (k + n) ‚â§ ((range k).filter Prime).card + ((Ico k (k + n)).filter Prime).card := by
      rw [primeCounting', count_eq_card_filter_range]
    _ ‚â§ œÄ' k + ((Ico k (k + n)).filter Prime).card := by
      rw [primeCounting', count_eq_card_filter_range]
    _ ‚â§ œÄ' k + ((Ico k (k + n)).filter (coprime a)).card := by
      refine add_le_add_left (card_le_of_subset ?_) k.primeCounting'
      simp only [subset_iff, and_imp, mem_filter, mem_Ico]
      intro p succ_k_le_p p_lt_n p_prime
      constructor
      ¬∑ exact ‚ü®succ_k_le_p, p_lt_n‚ü©
      ¬∑ rw [coprime_comm]
        exact coprime_of_lt_prime h0 (gt_of_ge_of_gt succ_k_le_p h1) p_prime
    _ ‚â§ œÄ' k + totient a * (n / a + 1) := by
      rw [add_le_add_iff_left]
      exact Ico_filter_coprime_le k n h0"
Mathlib/Order/Basic.lean,eq_or_eq_or_eq_of_forall_not_lt_lt,eq_or_eq_or_eq_of_forall_not_lt_lt,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  by_contra hne
  simp only [not_or, ‚Üê Ne.def] at hne
  cases' hne.1.lt_or_lt with h‚ÇÅ h‚ÇÅ <;> cases' hne.2.1.lt_or_lt with h‚ÇÇ h‚ÇÇ <;>
    cases' hne.2.2.lt_or_lt with h‚ÇÉ h‚ÇÉ
  exacts [h h‚ÇÅ h‚ÇÇ, h h‚ÇÇ h‚ÇÉ, h h‚ÇÉ h‚ÇÇ, h h‚ÇÉ h‚ÇÅ, h h‚ÇÅ h‚ÇÉ, h h‚ÇÇ h‚ÇÉ, h h‚ÇÅ h‚ÇÉ, h h‚ÇÇ h‚ÇÅ]","warning:  @Order.Preimage does not have a doc string
warning:  OrderDual does not have a doc string
warning:  @StrongLT does not have a doc string
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.75874 ‚Üí ?m.75874 ‚Üí Prop
error:  invalid field 'lt_or_lt', the environment does not contain 'Not.lt_or_lt'
  hne.left
has type
  ¬¨x = y
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hne.left
has type
  x = y ‚Üí False
error:  tactic 'induction' failed, major premise type is not an inductive type 
  ?m.75927
Œπ : Type u_1
Œ± : Type u_2
Œ≤ : Type u_3
œÄ : Œπ ‚Üí Type u_4
inst‚úù : LinearOrder Œ±
h : ‚àÄ ‚¶Éx y z : Œ±‚¶Ñ, x < y ‚Üí y < z ‚Üí False
x y z : Œ±
hne : ¬¨x = y ‚àß ¬¨y = z ‚àß ¬¨x = z
x‚úù : ?m.75927
‚ä¢ False","lemma eq_or_eq_or_eq_of_forall_not_lt_lt [LinearOrder Œ±]
    (h : ‚àÄ ‚¶Éx y z : Œ±‚¶Ñ, x < y ‚Üí y < z ‚Üí False) (x y z : Œ±) : x = y ‚à® y = z ‚à® x = z ",":= by
  by_contra hne
  simp only [not_or, ‚Üê Ne.eq_def] at hne
  cases' hne.1.lt_or_lt with h‚ÇÅ h‚ÇÅ <;> cases' hne.2.1.lt_or_lt with h‚ÇÇ h‚ÇÇ <;>
    cases' hne.2.2.lt_or_lt with h‚ÇÉ h‚ÇÉ
  exacts [h h‚ÇÅ h‚ÇÇ, h h‚ÇÇ h‚ÇÉ, h h‚ÇÉ h‚ÇÇ, h h‚ÇÉ h‚ÇÅ, h h‚ÇÅ h‚ÇÉ, h h‚ÇÇ h‚ÇÉ, h h‚ÇÅ h‚ÇÉ, h h‚ÇÇ h‚ÇÅ]",":= by
  by_contra hne
  simp only [not_or, ‚Üê Ne] at hne
  cases' hne.1.lt_or_lt with h‚ÇÅ h‚ÇÅ <;> cases' hne.2.1.lt_or_lt with h‚ÇÇ h‚ÇÇ <;>
    cases' hne.2.2.lt_or_lt with h‚ÇÉ h‚ÇÉ
  exacts [h h‚ÇÅ h‚ÇÇ, h h‚ÇÇ h‚ÇÉ, h h‚ÇÉ h‚ÇÇ, h h‚ÇÉ h‚ÇÅ, h h‚ÇÅ h‚ÇÉ, h h‚ÇÇ h‚ÇÉ, h h‚ÇÇ h‚ÇÉ, h h‚ÇÇ h‚ÇÅ]"
Mathlib/Data/Nat/Dist.lean,Nat.dist.triangle_inequality,dist.triangle_inequality,0c824fb54f74f0c66db893166b73e377be2feb6f,":= by
  have : dist n m + dist m k = n - m + (m - k) + (k - m + (m - n)) := by
    simp [dist, add_comm, add_left_comm]
  rw [this, dist]
  exact add_le_add tsub_le_tsub_add_tsub tsub_le_tsub_add_tsub","error:  unsolved goals
n m k : ‚Ñï
‚ä¢ n - m + (m - n) + (m - k + (k - m)) = m - n + (n - m + (m - k) + (k - m))",theorem dist.triangle_inequality (n m k : ‚Ñï) : dist n k ‚â§ dist n m + dist m k ,":= by
  have : dist n m + dist m k = n - m + (m - k) + (k - m + (m - n)) := by
    simp [dist, add_comm, add_left_comm, add_assoc]
  rw [this, dist]
  exact add_le_add tsub_le_tsub_add_tsub tsub_le_tsub_add_tsub",":= by
  have : dist n m + dist m k = n - m + (m - k) + (k - m - n) := by
    simp [dist, add_comm, add_left_comm]
  rw [this, dist]
  exact add_le_add tsub_le_tsub_add_tsub tsub_le_tsub_add_tsub"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,AntilipschitzWith.hausdorffMeasure_preimage_le,hausdorffMeasure_preimage_le,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  rcases eq_or_ne K 0 with (rfl | h0)
  ¬∑ rcases eq_empty_or_nonempty (f ‚Åª¬π' s) with (hs | ‚ü®x, hx‚ü©)
    ¬∑ simp only [hs, measure_empty, zero_le]
    have : f ‚Åª¬π' s = {x} := by
      haveI : Subsingleton X := hf.subsingleton
      have : (f ‚Åª¬π' s).Subsingleton := subsingleton_univ.anti (subset_univ _)
      exact (subsingleton_iff_singleton hx).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    ¬∑ simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ‚ü®f x, hx‚ü©
    ¬∑ haveI := noAtoms_hausdorff X h'd
      simp only [zero_le, measure_singleton]
  have hKd0 : (K : ‚Ñù‚â•0‚àû) ^ d ‚â† 0 := by simp [h0]
  have hKd : (K : ‚Ñù‚â•0‚àû) ^ d ‚â† ‚àû := by simp [hd]
  simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hKd0 hKd,
    ‚Üê ENNReal.tsum_mul_left]
  refine iSup‚ÇÇ_le fun Œµ Œµ0 => _
  refine le_iSup‚ÇÇ_of_le (Œµ / K) (by simp [Œµ0.ne']) _
  refine le_iInf‚ÇÇ fun t hst => le_iInf fun htŒµ => _
  replace hst : f ‚Åª¬π' s ‚äÜ _ := preimage_mono hst; rw [preimage_iUnion] at hst
  refine iInf‚ÇÇ_le_of_le _ hst (iInf_le_of_le (fun n => _) _)
  ¬∑ exact (hf.ediam_preimage_le _).trans (ENNReal.mul_le_of_le_div' <| htŒµ n)
  ¬∑ refine ENNReal.tsum_le_tsum fun n => iSup_le_iff.2 fun hft => _
    simp only [nonempty_of_nonempty_preimage hft, ciSup_pos]
    rw [‚Üê ENNReal.mul_rpow_of_nonneg _ _ hd]
    exact ENNReal.rpow_le_rpow (hf.ediam_preimage_le _) hd","error:  don't know how to synthesize placeholder
context:
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù‚Åµ : EMetricSpace X
inst‚úù‚Å¥ : EMetricSpace Y
inst‚úù¬≥ : MeasurableSpace X
inst‚úù¬≤ : BorelSpace X
inst‚úù¬π : MeasurableSpace Y
inst‚úù : BorelSpace Y
f : X ‚Üí Y
K : ‚Ñù‚â•0
d : ‚Ñù
hf : AntilipschitzWith K f
hd : 0 ‚â§ d
s : Set Y
h0 : K ‚â† 0
hKd0 : ‚ÜëK ^ d ‚â† 0
hKd : ‚ÜëK ^ d ‚â† ‚ä§
Œµ : ‚Ñù‚â•0‚àû
Œµ0 : 0 < Œµ
‚ä¢ ‚®Ö t,
      ‚®Ö (_ : f ‚Åª¬π' s ‚äÜ ‚ãÉ n, t n),
        ‚®Ö (_ : ‚àÄ (n : ‚Ñï), diam (t n) ‚â§ Œµ), ‚àë' (n : ‚Ñï), ‚®Ü (_ : (t n).Nonempty), diam (t n) ^ d ‚â§
    ‚®Ü i,
      ‚®Ü (_ : 0 < i),
        ‚®Ö i_1,
          ‚®Ö (_ : s ‚äÜ ‚ãÉ n, i_1 n),
            ‚®Ö (_ : ‚àÄ (n : ‚Ñï), diam (i_1 n) ‚â§ i), ‚àë' (i : ‚Ñï), ‚®Ü (_ : (i_1 i).Nonempty), ‚ÜëK ^ d * diam (i_1 i) ^ d
error:  unsolved goals
case inr
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù‚Åµ : EMetricSpace X
inst‚úù‚Å¥ : EMetricSpace Y
inst‚úù¬≥ : MeasurableSpace X
inst‚úù¬≤ : BorelSpace X
inst‚úù¬π : MeasurableSpace Y
inst‚úù : BorelSpace Y
f : X ‚Üí Y
K : ‚Ñù‚â•0
d : ‚Ñù
hf : AntilipschitzWith K f
hd : 0 ‚â§ d
s : Set Y
h0 : K ‚â† 0
hKd0 : ‚ÜëK ^ d ‚â† 0
hKd : ‚ÜëK ^ d ‚â† ‚ä§
‚ä¢ ‚®Ü r,
      ‚®Ü (_ : 0 < r),
        ‚®Ö t,
          ‚®Ö (_ : f ‚Åª¬π' s ‚äÜ ‚ãÉ n, t n),
            ‚®Ö (_ : ‚àÄ (n : ‚Ñï), diam (t n) ‚â§ r), ‚àë' (n : ‚Ñï), ‚®Ü (_ : (t n).Nonempty), diam (t n) ^ d ‚â§
    ‚®Ü i,
      ‚®Ü (_ : 0 < i),
        ‚®Ö i_1,
          ‚®Ö (_ : s ‚äÜ ‚ãÉ n, i_1 n),
            ‚®Ö (_ : ‚àÄ (n : ‚Ñï), diam (i_1 n) ‚â§ i), ‚àë' (i : ‚Ñï), ‚®Ü (_ : (i_1 i).Nonempty), ‚ÜëK ^ d * diam (i_1 i) ^ d","theorem hausdorffMeasure_preimage_le (hf : AntilipschitzWith K f) (hd : 0 ‚â§ d) (s : Set Y) :
    ŒºH[d] (f ‚Åª¬π' s) ‚â§ (K : ‚Ñù‚â•0‚àû) ^ d * ŒºH[d] s ",":= by
  rcases eq_or_ne K 0 with (rfl | h0)
  ¬∑ rcases eq_empty_or_nonempty (f ‚Åª¬π' s) with (hs | ‚ü®x, hx‚ü©)
    ¬∑ simp only [hs, measure_empty, zero_le]
    have : f ‚Åª¬π' s = {x} := by
      haveI : Subsingleton X := hf.subsingleton
      have : (f ‚Åª¬π' s).Subsingleton := subsingleton_univ.anti (subset_univ _)
      exact (subsingleton_iff_singleton hx).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    ¬∑ simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ‚ü®f x, hx‚ü©
    ¬∑ haveI := noAtoms_hausdorff X h'd
      simp only [zero_le, measure_singleton]
  have hKd0 : (K : ‚Ñù‚â•0‚àû) ^ d ‚â† 0 := by simp [h0]
  have hKd : (K : ‚Ñù‚â•0‚àû) ^ d ‚â† ‚àû := by simp [hd]
  simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hKd0 hKd,
    ‚Üê ENNReal.tsum_mul_left]
  refine iSup‚ÇÇ_le fun Œµ Œµ0 => ?_
  refine le_iSup‚ÇÇ_of_le (Œµ / K) (by simp [Œµ0.ne']) ?_
  refine le_iInf‚ÇÇ fun t hst => le_iInf fun htŒµ => ?_
  replace hst : f ‚Åª¬π' s ‚äÜ _ := preimage_mono hst; rw [preimage_iUnion] at hst
  refine iInf‚ÇÇ_le_of_le _ hst (iInf_le_of_le (fun n => ?_) ?_)
  ¬∑ exact (hf.ediam_preimage_le _).trans (ENNReal.mul_le_of_le_div' <| htŒµ n)
  ¬∑ refine ENNReal.tsum_le_tsum fun n => iSup_le_iff.2 fun hft => ?_
    simp only [nonempty_of_nonempty_preimage hft, ciSup_pos]
    rw [‚Üê ENNReal.mul_rpow_of_nonneg _ _ hd]
    exact ENNReal.rpow_le_rpow (hf.ediam_preimage_le _) hd",":= by
  rcases eq_or_ne K 0 with (rfl | h0)
  ¬∑ rcases eq_empty_or_nonempty (f ‚Åª¬π' s) with (hs | ‚ü®x, hx‚ü©)
    ¬∑ simp only [hs, measure_empty, zero_le]
    have : f ‚Åª¬π' s = {x} := by
      haveI : Subsingleton X := hf.subsingleton
      have : (f ‚Åª¬π' s).Subsingleton := subsingleton_univ.anti (subset_univ _)
      exact (subsingleton_iff_singleton hx).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    ¬∑ simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ‚ü®f x, hx‚ü©
    ¬∑ haveI := noAtoms_hausdorff X h'd
      simp only [zero_le, measure_singleton]
  have hKd0 : (K : ‚Ñù‚â•0‚àû) ^ d ‚â† 0 := by simp [h0]
  have hKd : (K : ‚Ñù‚â•0‚àû) ^ d ‚â† ‚àû := by simp [hd]
  simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hKd0 hKd,
    ‚Üê ENNReal.tsum_mul_left]
  refine iSup‚ÇÇ_le fun Œµ Œµ0 => ?_
  refine le_iSup‚ÇÇ_of_le (Œµ / K) (by simp [Œµ0.ne']) ?_
  refine le_iInf‚ÇÇ fun t hst => le_iInf fun htŒµ => ?_
  replace hst : f ‚Åª¬π' s ‚äÜ _ := preimage_mono hst; rw [preimage_iUnion] at hst
  refine iInf‚ÇÇ_le_of_le _ hst (iInf_le_of_le (fun n => ?_) _)
  ¬∑ exact (hf.ediam_preimage_le _).trans (ENNReal.mul_le_of_le_div' <| htŒµ n)
  ¬∑ refine ENNReal.tsum_le_tsum fun n => iSup_le_iff.2 fun hft => ?_
    simp only [nonempty_of_nonempty_preimage hft, ciSup_pos]
    rw [‚Üê ENNReal.mul_rpow_of_nonneg _ _ hd]
    exact ENNReal.rpow_le_rpow (hf.ediam_preimage_le _) hd"
Mathlib/CategoryTheory/Localization/LocalizerMorphism.lean,CategoryTheory.LocalizerMorphism.IsLocalizedEquivalence.mk',IsLocalizedEquivalence.mk',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  nonempty_isEquivalence := by
    rw [Œ¶.nonempty_isEquivalence_iff W‚ÇÅ.Q W‚ÇÇ.Q (Œ¶.localizedFunctor W‚ÇÅ.Q W‚ÇÇ.Q) L‚ÇÅ L‚ÇÇ G]
    exact ‚ü®inferInstance‚ü©",error:  'nonempty_isEquivalence' is not a field of structure 'CategoryTheory.LocalizerMorphism.IsLocalizedEquivalence',"lemma IsLocalizedEquivalence.mk' [CatCommSq Œ¶.functor L‚ÇÅ L‚ÇÇ G] [G.IsEquivalence] :
    Œ¶.IsLocalizedEquivalence where
","  isEquivalence := by
    rw [Œ¶.isEquivalence_iff W‚ÇÅ.Q W‚ÇÇ.Q (Œ¶.localizedFunctor W‚ÇÅ.Q W‚ÇÇ.Q) L‚ÇÅ L‚ÇÇ G]
    exact inferInstance",":= by
  rw [Œ¶.nonempty_isEquivalence_iff W‚ÇÅ.Q W‚ÇÇ.Q (Œ¶.localizedFunctor W‚ÇÅ.Q W‚ÇÇ.Q) L‚ÇÅ L‚ÇÇ G]
  exact ‚ü®inferInstance‚ü©"
Mathlib/Analysis/NormedSpace/Pointwise.lean,affinity_unitClosedBall,affinity_unitClosedBall,af8d8e6d37fbe07db1396e407d0253571fd7ea2b,":= by
  rw [smul_unit_closedBall, Real.norm_of_nonneg hr, vadd_closedBall_zero]","error:  unknown identifier 'smul_unit_closedBall'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.264970
ùïú : Type u_1
E : Type u_2
inst‚úù¬≥ : NormedField ùïú
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ùïú E
inst‚úù : NormedSpace ‚Ñù E
r : ‚Ñù
hr : 0 ‚â§ r
x : E
‚ä¢ x +·µ• r ‚Ä¢ closedBall 0 1 = closedBall x r","theorem affinity_unitClosedBall {r : ‚Ñù} (hr : 0 ‚â§ r) (x : E) :
    x +·µ• r ‚Ä¢ closedBall (0 : E) 1 = closedBall x r ",":= by
  rw [smul_closedUnitBall, Real.norm_of_nonneg hr, vadd_closedBall_zero]",":= by
  rw [smul_unit_closedBall, Real.norm_of_nonneg hr, vadd_closedBall_zero]"
Mathlib/Topology/Homotopy/HSpaces.lean,unitInterval.continuous_qRight,continuous_qRight,f655aad92f39fa1eff3436b3b0c4a1004e666b53,":=
  by unfold qRight; fun_prop","error:  `fun_prop` was unable to prove `Continuous fun p ‚Ü¶ Set.projIcc 0 1 qRight.proof_1 (2 * ‚Üëp.1 / (1 + ‚Üëp.2))`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `Set.projIcc` in order to prove Continuous fun p ‚Ü¶ Set.projIcc 0 1 qRight.proof_1 (2 * ‚Üëp.1 / (1 + ‚Üëp.2))
  No theorems found for `Set.projIcc` in order to prove Continuous fun a ‚Ü¶ Set.projIcc 0 1 qRight.proof_1 a
  Failed to synthesize instance DiscreteTopology ‚Ñù when applying theorem continuous_of_discreteTopology.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`",theorem continuous_qRight : Continuous qRight ,":=
  continuous_projIcc.comp <|
    Continuous.div (by fun_prop) (by fun_prop) fun x ‚Ü¶ (add_pos zero_lt_one).ne'",":=
  by unfold qRight; fun_prop"
Mathlib/Algebra/Order/Group/Abs.lean,abs_add,abs_add,26c28adfd0e2ebe738b1e9e210e7e6f3ad53b9e9,":=
  abs_le.2
    ‚ü®(neg_add |a| |b|).symm ‚ñ∏
        add_le_add ((@neg_le Œ± ..).2 <| neg_le_abs_self _) ((@neg_le Œ± ..).2 <| neg_le_abs_self _),
      add_le_add (le_abs_self _) (le_abs_self _)‚ü©","warning:  @mabs does not have a doc string
error:  unknown identifier 'neg_le_abs_self'
error:  unknown identifier 'neg_le_abs_self'",theorem abs_add (a b : Œ±) : |a + b| ‚â§ |a| + |b| ,":=
  abs_le.2
    ‚ü®(neg_add |a| |b|).symm ‚ñ∏
        add_le_add ((@neg_le Œ± ..).2 <| neg_le_abs _) ((@neg_le Œ± ..).2 <| neg_le_abs _),
      add_le_add (le_abs_self _) (le_abs_self _)‚ü©",":=
  abs_le.2
    ‚ü®(neg_add |a| |b|).symm ‚ñ∏
      add_le_add ((@neg_le Œ± ..).2 <| neg_le_abs_self _) ((@neg_le Œ± ..).2 <| neg_le_abs_self _),
      add_le_add (le_abs_self _) (le_abs_self _)‚ü©"
Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean,AlgebraicGeometry.sourceAffineLocally_isLocal,sourceAffineLocally_isLocal,30ec1836633a36c24a299e12b19ba56dcec36da5,":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
      ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
            IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
          exact this _ rfl
        intro V hV
        rw [Scheme.preimage_basicOpen] at hV
        subst hV
        exact U.2.ŒπOpens_basicOpen_preimage (Scheme.Œì.map f.op r.1)","error:  no goals to be solved
error:  unsolved goals
case ofBasicOpenCover.refine_1
P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí (R ‚Üí+* S) ‚Üí Prop
h‚ÇÅ : RingHom.RespectsIso P
h‚ÇÇ : RingHom.LocalizationPreserves P
h‚ÇÉ : RingHom.OfLocalizationSpan P
X Y : Scheme
inst‚úù : IsAffine Y
f : X ‚ü∂ Y
s : Finset ‚ÜëŒì(Y, ‚ä§)
hs : Ideal.span ‚Üës = ‚ä§
hs' : ‚àÄ (r : { x // x ‚àà s }), sourceAffineLocally P (f ‚à£_ Y.basicOpen ‚Üër)
U : ‚ÜëX.affineOpens
r : ‚Üë‚Üës
‚ä¢ X.ofRestrict ‚ãØ ‚Åª¬π·µÅ ‚ÜëU ‚àà (X ‚à£_·µ§ f ‚Åª¬π·µÅ Y.basicOpen ‚Üër).affineOpens","theorem sourceAffineLocally_isLocal (h‚ÇÅ : RingHom.RespectsIso @P)
    (h‚ÇÇ : RingHom.LocalizationPreserves @P) (h‚ÇÉ : RingHom.OfLocalizationSpan @P) :
    (sourceAffineLocally @P).IsLocal ",":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
    ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
          IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
        exact this _ rfl
      intro V hV
      rw [Scheme.preimage_basicOpen] at hV
      subst hV
      exact U.2.ŒπOpens_basicOpen_preimage (Scheme.Œì.map f.op r.1)",":= by
  constructor
  ¬∑ exact sourceAffineLocally_respectsIso h‚ÇÅ
  ¬∑ introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves h‚ÇÅ h‚ÇÇ; assumption
  ¬∑ introv hs hs' U
    apply h‚ÇÉ _ _ hs
    intro r
    have := hs' r ‚ü®(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_‚ü©
    ¬∑ rwa [h‚ÇÅ.ofRestrict_morphismRestrict_iff] at this
      ¬∑ exact U.2
      ¬∑ rfl
      ¬∑ suffices ‚àÄ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
            IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
          exact this _ rfl
        intro V hV
        rw [Scheme.preimage_basicOpen] at hV
        subst hV
        exact U.2.ŒπOpens_basicOpen_preimage (Scheme.Œì.map f.op r.1)"
Mathlib/CategoryTheory/Limits/Final.lean,CategoryTheory.Functor.final_comp_equivalence,final_comp_equivalence,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  let i : F ‚âÖ (F ‚ãô G) ‚ãô G.inv := isoWhiskerLeft F IsEquivalence.unitIso
  have : Final ((F ‚ãô G) ‚ãô G.inv) := final_of_natIso i
  final_of_comp_full_faithful (F ‚ãô G) G.inv","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsEquivalence
has type
  ?m.258354 ‚•§ ?m.258463 ‚Üí Prop
error:  stuck at solving universe constraint
  max (max (max u‚ÇÅ v‚ÇÅ) v‚ÇÇ) ?u.258204 =?= max (max (max u‚ÇÅ u‚ÇÇ) v‚ÇÅ) v‚ÇÇ
while trying to unify
  @Iso.{max u‚ÇÅ v‚ÇÇ,
      max (max (max ?u.258204 u‚ÇÅ) v‚ÇÇ)
        v‚ÇÅ} : {C : Type (max (max (max ?u.258204 u‚ÇÅ) v‚ÇÇ) v‚ÇÅ)} ‚Üí
    [inst : Category.{max u‚ÇÅ v‚ÇÇ, max (max (max ?u.258204 u‚ÇÅ) v‚ÇÇ) v‚ÇÅ} C] ‚Üí C ‚Üí C ‚Üí Type (max u‚ÇÅ v‚ÇÇ)
with
  @Iso : {C : Type (max (max (max u‚ÇÅ u‚ÇÇ) v‚ÇÅ) v‚ÇÇ)} ‚Üí
    [inst : Category.{max u‚ÇÅ v‚ÇÇ, max (max (max u‚ÇÅ u‚ÇÇ) v‚ÇÅ) v‚ÇÇ} C] ‚Üí C ‚Üí C ‚Üí Type (max u‚ÇÅ v‚ÇÇ)",theorem final_comp_equivalence [Final F] [IsEquivalence G] : Final (F ‚ãô G) ,":=
  let i : F ‚âÖ (F ‚ãô G) ‚ãô G.inv := isoWhiskerLeft F G.asEquivalence.unitIso
  have : Final ((F ‚ãô G) ‚ãô G.inv) := final_of_natIso i
  final_of_comp_full_faithful (F ‚ãô G) G.inv",":=
  let i : F ‚âÖ (F ‚ãô G) ‚ãô G.inv := isoWhiskerLeft F IsEquivalence.unitIso
  have : Final ((F ‚ãô G) ‚ãô G.inv) := final_of_natIso i
  final_of_full_faithful (F ‚ãô G) G.inv"
Mathlib/Algebra/Polynomial/Eval.lean,Polynomial.eval‚ÇÇ_comp',eval‚ÇÇ_comp',c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction p with
  | h_add r s hr hs => simp only [add_comp, eval‚ÇÇ_add, hr, hs]
  | h_monomial n a => simp only [monomial_comp, eval‚ÇÇ_mul', eval‚ÇÇ_C, eval‚ÇÇ_monomial, eval‚ÇÇ_pow']","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  invalid alternative name 'h_add'","theorem eval‚ÇÇ_comp' : eval‚ÇÇ (algebraMap R S) x (p.comp q) =
    eval‚ÇÇ (algebraMap R S) (eval‚ÇÇ (algebraMap R S) x q) p ",":= by
  induction p using Polynomial.induction_on' with
  | h_add r s hr hs => simp only [add_comp, eval‚ÇÇ_add, hr, hs]
  | h_monomial n a => simp only [monomial_comp, eval‚ÇÇ_mul', eval‚ÇÇ_C, eval‚ÇÇ_monomial, eval‚ÇÇ_pow']",":= by
  induction p with
  | h_add r s hr hs => simp only [add_comp, eval‚ÇÇ_add, hr, hs]
  | h_monomial n a => simp only [monomial_comp, eval‚ÇÇ_mul', eval‚ÇÇ_C, eval‚ÇÇ_monomial, eval‚ÇÇ_pow']"
Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean,TopCat.pullback_fst_range,pullback_fst_range,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext x
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    use (pullback.snd : pullback f g ‚ü∂ _) y
    exact ConcreteCategory.congr_hom pullback.condition y
  ¬∑ rintro ‚ü®y, eq‚ü©
    use (TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®x, y‚ü©, eq‚ü©
    simp","error:  application type mismatch
  ConcreteCategory.congr_hom pullback.condition y
argument
  y
has type
  ‚Üë(pullback f g) : Type u_1
but is expected to have type
  (forget ?m.132517).obj (pullback ?m.132522 ?m.132523) : Type ?u.132507
error:  unsolved goals
case h
J : Type v
inst‚úù : SmallCategory J
X‚úù Y‚úù Z : TopCat
X Y S : TopCat
f : X ‚ü∂ S
g : Y ‚ü∂ S
x : ‚ÜëX
y : ‚ÜëY
eq : f x = g y
‚ä¢ pullback.fst ((pullbackIsoProdSubtype f g).inv ‚ü®(x, y), eq‚ü©) = x","theorem pullback_fst_range {X Y S : TopCat} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) :
    Set.range (pullback.fst : pullback f g ‚ü∂ _) = { x : X | ‚àÉ y : Y, f x = g y } ",":= by
  ext x
  constructor
  ¬∑ rintro ‚ü®(y : (forget TopCat).obj _), rfl‚ü©
    use (pullback.snd : pullback f g ‚ü∂ _) y
    exact ConcreteCategory.congr_hom pullback.condition y
  ¬∑ rintro ‚ü®y, eq‚ü©
    use (TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®x, y‚ü©, eq‚ü©
    rw [pullbackIsoProdSubtype_inv_fst_apply]",":= by
  ext x
  constructor
  ¬∑ rintro ‚ü®y, rfl‚ü©
    use (pullback.snd : pullback f g ‚ü∂ _) y
    exact ConcreteCategory.congr_hom pullback.condition y
  ¬∑ rintro ‚ü®y, eq‚ü©
    use (TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®x, y‚ü©, eq‚ü©
    simp"
Mathlib/MeasureTheory/Group/GeometryOfNumbers.lean,MeasureTheory.exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure,exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  have h_vol : Œº F < Œº ((2‚Åª¬π : ‚Ñù) ‚Ä¢ s) := by
    rw [addHaar_smul_of_nonneg Œº (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π) s, ‚Üê
      mul_lt_mul_right (pow_ne_zero (finrank ‚Ñù E) (two_ne_zero' _)) (pow_ne_top two_ne_top),
      mul_right_comm, ofReal_pow (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π), ofReal_inv_of_pos zero_lt_two]
    norm_num
    rwa [‚Üê mul_pow, ENNReal.inv_mul_cancel two_ne_zero two_ne_top, one_pow, one_mul]
  obtain ‚ü®x, y, hxy, h‚ü© :=
    exists_pair_mem_lattice_not_disjoint_vadd fund ((h_conv.smul _).nullMeasurableSet _) h_vol
  obtain ‚ü®_, ‚ü®v, hv, rfl‚ü©, w, hw, hvw‚ü© := Set.not_disjoint_iff.mp h
  refine ‚ü®x - y, sub_ne_zero.2 hxy, ?_‚ü©
  rw [Set.mem_inv_smul_set_iff‚ÇÄ (two_ne_zero' ‚Ñù)] at hv hw
  simp_rw [AddSubgroup.vadd_def, vadd_eq_add, add_comm _ w, ‚Üê sub_eq_sub_iff_add_eq_add, ‚Üê
    AddSubgroup.coe_sub] at hvw
  rw [‚Üê hvw, ‚Üê inv_smul_smul‚ÇÄ (two_ne_zero' ‚Ñù) (_ - _), smul_sub, sub_eq_add_neg, smul_add]
  refine h_conv hw (h_symm _ hv) ?_ ??_ _ <;> norm_num",error:  unexpected token '?'; expected '_' or identifier,"theorem exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure [NormedAddCommGroup E]
    [NormedSpace ‚Ñù E] [BorelSpace E] [FiniteDimensional ‚Ñù E] [IsAddHaarMeasure Œº]
    {L : AddSubgroup E} [Countable L] (fund : IsAddFundamentalDomain L F Œº)
    (h_symm : ‚àÄ x ‚àà s, -x ‚àà s) (h_conv : Convex ‚Ñù s) (h : Œº F * 2 ^ finrank ‚Ñù E < Œº s) :
    ‚àÉ x ‚â† 0, ((x : L) : E) ‚àà s ",":= by
  have h_vol : Œº F < Œº ((2‚Åª¬π : ‚Ñù) ‚Ä¢ s) := by
    rw [addHaar_smul_of_nonneg Œº (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π) s, ‚Üê
      mul_lt_mul_right (pow_ne_zero (finrank ‚Ñù E) (two_ne_zero' _)) (pow_ne_top two_ne_top),
      mul_right_comm, ofReal_pow (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π), ofReal_inv_of_pos zero_lt_two]
    norm_num
    rwa [‚Üê mul_pow, ENNReal.inv_mul_cancel two_ne_zero two_ne_top, one_pow, one_mul]
  obtain ‚ü®x, y, hxy, h‚ü© :=
    exists_pair_mem_lattice_not_disjoint_vadd fund ((h_conv.smul _).nullMeasurableSet _) h_vol
  obtain ‚ü®_, ‚ü®v, hv, rfl‚ü©, w, hw, hvw‚ü© := Set.not_disjoint_iff.mp h
  refine ‚ü®x - y, sub_ne_zero.2 hxy, ?_‚ü©
  rw [Set.mem_inv_smul_set_iff‚ÇÄ (two_ne_zero' ‚Ñù)] at hv hw
  simp_rw [AddSubgroup.vadd_def, vadd_eq_add, add_comm _ w, ‚Üê sub_eq_sub_iff_add_eq_add, ‚Üê
    AddSubgroup.coe_sub] at hvw
  rw [‚Üê hvw, ‚Üê inv_smul_smul‚ÇÄ (two_ne_zero' ‚Ñù) (_ - _), smul_sub, sub_eq_add_neg, smul_add]
  refine h_conv hw (h_symm _ hv) ?_ ?_ ?_ <;> norm_num",":= by
  have h_vol : Œº F < Œº ((2‚Åª¬π : ‚Ñù) ‚Ä¢ s) := by
    rw [addHaar_smul_of_nonneg Œº (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π) s, ‚Üê
      mul_lt_mul_right (pow_ne_zero (finrank ‚Ñù E) (two_ne_zero' _)) (pow_ne_top two_ne_top),
      mul_right_comm, ofReal_pow (by norm_num : 0 ‚â§ (2 : ‚Ñù)‚Åª¬π), ofReal_inv_of_pos zero_lt_two]
    norm_num
    rwa [‚Üê mul_pow, ENNReal.inv_mul_cancel two_ne_zero two_ne_top, one_pow, one_mul]
  obtain ‚ü®x, y, hxy, h‚ü© :=
    exists_pair_mem_lattice_not_disjoint_vadd fund ((h_conv.smul _).nullMeasurableSet _) h_vol
  obtain ‚ü®_, ‚ü®v, hv, rfl‚ü©, w, hw, hvw‚ü© := Set.not_disjoint_iff.mp h
  refine ‚ü®x - y, sub_ne_zero.2 hxy, ?_‚ü©
  rw [Set.mem_inv_smul_set_iff‚ÇÄ (two_ne_zero' ‚Ñù)] at hv hw
  simp_rw [AddSubgroup.vadd_def, vadd_eq_add, add_comm _ w, ‚Üê sub_eq_sub_iff_add_eq_add, ‚Üê
    AddSubgroup.coe_sub] at hvw
  rw [‚Üê hvw, ‚Üê inv_smul_smul‚ÇÄ (two_ne_zero' ‚Ñù) (_ - _), smul_sub, sub_eq_add_neg, smul_add]
  refine h_conv hw (h_symm _ hv) ?_ ?_ ?_ <;> norm_num"
Mathlib/Data/Nat/Factorial/Cast.lean,Nat.cast_descFactorial_two,cast_descFactorial_two,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  rw [cast_descFactorial]
  cases a
  ¬∑ simp
  ¬∑ rw [succ_sub_succ, tsub_zero, cast_succ, add_sub_cancel, pochhammer_succ_right, pochhammer_one,
      Polynomial.X_mul, Polynomial.eval_mul_X, Polynomial.eval_add, Polynomial.eval_X, cast_one,
      Polynomial.eval_one]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
case succ
S : Type u_1
inst‚úù : Ring S
b n‚úù : ‚Ñï
‚ä¢ Polynomial.eval (‚Üën‚úù) (ascPochhammer S 2) = (‚Üën‚úù + 1) * (‚Üën‚úù + 1 - 1)",theorem cast_descFactorial_two : (a.descFactorial 2 : S) = a * (a - 1) ,":= by
  rw [cast_descFactorial]
  cases a
  ¬∑ simp
  ¬∑ rw [succ_sub_succ, tsub_zero, cast_succ, add_sub_cancel_right, ascPochhammer_succ_right,
      ascPochhammer_one, Polynomial.X_mul, Polynomial.eval_mul_X, Polynomial.eval_add,
      Polynomial.eval_X, cast_one, Polynomial.eval_one]",":= by
  rw [cast_descFactorial]
  cases a
  ¬∑ simp
  ¬∑ rw [succ_sub_succ, tsub_zero, cast_succ, add_sub_cancel, pochhammer_succ_right, pochhammer_one,
      Polynomial.X_mul, Polynomial.eval_mul_X, Polynomial.eval_add, Polynomial.eval_X, cast_one,
      Polynomial.eval_one]"
Mathlib/NumberTheory/SumTwoSquares.lean,Nat.eq_sq_add_sq_iff,Nat.eq_sq_add_sq_iff,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  constructor
  ¬∑ rintro ‚ü®x, y, h‚ü©
    by_cases hxy : x = 0 ‚àß y = 0
    ¬∑ exact ‚ü®0, 1, by rw [h, hxy.1, hxy.2, zero_pow zero_lt_two, add_zero, zero_mul],
        ‚ü®0, by rw [zero_mul, neg_eq_zero, Fin.one_eq_zero_iff]‚ü©‚ü©
    ¬∑ have hg := Nat.pos_of_ne_zero (mt Nat.gcd_eq_zero_iff.mp hxy)
      obtain ‚ü®g, x‚ÇÅ, y‚ÇÅ, _, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü© := Nat.exists_coprime' hg
      exact ‚ü®g, x‚ÇÅ ^ 2 + y‚ÇÅ ^ 2, by rw [h, h‚ÇÉ, h‚ÇÑ]; ring,
        ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_coprime rfl h‚ÇÇ‚ü©
  ¬∑ rintro ‚ü®a, b, h‚ÇÅ, h‚ÇÇ‚ü©
    obtain ‚ü®x', y', h‚ü© := Nat.eq_sq_add_sq_of_isSquare_mod_neg_one h‚ÇÇ
    exact ‚ü®a * x', a * y', by rw [h‚ÇÅ, h]; ring‚ü©","error:  application type mismatch
  zero_pow zero_lt_two
argument
  zero_lt_two
has type
  0 < 2 : Prop
but is expected to have type
  ?m.44012 ‚â† 0 : Prop","theorem Nat.eq_sq_add_sq_iff_eq_sq_mul {n : ‚Ñï} :
    (‚àÉ x y : ‚Ñï, n = x ^ 2 + y ^ 2) ‚Üî ‚àÉ a b : ‚Ñï, n = a ^ 2 * b ‚àß IsSquare (-1 : ZMod b) ",":= by
  constructor
  ¬∑ rintro ‚ü®x, y, h‚ü©
    by_cases hxy : x = 0 ‚àß y = 0
    ¬∑ exact ‚ü®0, 1, by rw [h, hxy.1, hxy.2, zero_pow two_ne_zero, add_zero, zero_mul],
        ‚ü®0, by rw [zero_mul, neg_eq_zero, Fin.one_eq_zero_iff]‚ü©‚ü©
    ¬∑ have hg := Nat.pos_of_ne_zero (mt Nat.gcd_eq_zero_iff.mp hxy)
      obtain ‚ü®g, x‚ÇÅ, y‚ÇÅ, _, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü© := Nat.exists_coprime' hg
      exact ‚ü®g, x‚ÇÅ ^ 2 + y‚ÇÅ ^ 2, by rw [h, h‚ÇÉ, h‚ÇÑ]; ring,
        ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_coprime rfl h‚ÇÇ‚ü©
  ¬∑ rintro ‚ü®a, b, h‚ÇÅ, h‚ÇÇ‚ü©
    obtain ‚ü®x', y', h‚ü© := Nat.eq_sq_add_sq_of_isSquare_mod_neg_one h‚ÇÇ
    exact ‚ü®a * x', a * y', by rw [h‚ÇÅ, h]; ring‚ü©",":= by
  constructor
  ¬∑ rintro ‚ü®x, y, h‚ü©
    by_cases hxy : x = 0 ‚àß y = 0
    ¬∑ exact ‚ü®0, 1, by rw [h, hxy.1, hxy.2, zero_pow zero_lt_two, add_zero, zero_mul],
        ‚ü®0, by rw [zero_mul, neg_eq_zero, Fin.one_eq_zero_iff]‚ü©‚ü©
    ¬∑ have hg := Nat.pos_of_ne_zero (mt Nat.gcd_eq_zero_iff.mp hxy)
      obtain ‚ü®g, x‚ÇÅ, y‚ÇÅ, _, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü© := Nat.exists_coprime' hg
      exact ‚ü®g, x‚ÇÅ ^ 2 + y‚ÇÅ ^ 2, by rw [h, h‚ÇÉ, h‚ÇÑ]; ring,
        ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_coprime rfl h‚ÇÇ‚ü©
  ¬∑ rintro ‚ü®a, b, h‚ÇÅ, h‚ÇÇ‚ü©
    obtain ‚ü®x', y', h‚ü© := Nat.eq_sq_add_sq_of_isSquare_mod_neg_one h‚ÇÇ
    exact ‚ü®a * x', a * y', by rw [h‚ÇÅ, h]; ring‚ü©"
Mathlib/Algebra/Order/Ring/Defs.lean,mul_add_mul_le_mul_add_mul,mul_add_mul_le_mul_add_mul,403c299f8903ca8e59e5d9b107f9b2b15ed23dc2,":= by
  obtain ‚ü®b, rfl‚ü© := exists_add_of_le hab
  obtain ‚ü®d, hd, rfl‚ü© := exists_nonneg_add_of_le hcd
  rw [mul_add, add_right_comm, mul_add, ‚Üê add_assoc]
  exact add_le_add_left (mul_le_mul_of_nonneg_right hab hd) _","error:  unknown identifier 'exists_nonneg_add_of_le'
error:  rcases tactic failed: x‚úù : ?m.118170 is not an inductive datatype",lemma mul_add_mul_le_mul_add_mul (hab : a ‚â§ b) (hcd : c ‚â§ d) : a * d + b * c ‚â§ a * c + b * d ,":= by
  obtain ‚ü®b, rfl‚ü© := exists_add_of_le hab
  obtain ‚ü®d, rfl‚ü© := exists_add_of_le hcd
  rw [mul_add, add_right_comm, mul_add, ‚Üê add_assoc]
  exact add_le_add_left (mul_le_mul_of_nonneg_right hab <| (le_add_iff_nonneg_right _).1 hcd) _",":= by
  obtain ‚ü®b, rfl‚ü© := exists_add_of_le hab
  obtain ‚ü®d, hd, rfl‚ü© := exists_nonneg_add_of_le hcd
  rw [mul_add, add_right_comm, mul_add, ‚Üê add_assoc]
  exact add_le_add_left (mul_le_mul_of_nonneg_right hab hd) _"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicAt.order_eq_int_iff,order_eq_int_iff,c2d2bf7e3c17a8505a5d9206327d2cd9b9b50229,":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_nat, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel', zpow_coe_nat,
        zpow_coe_nat]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©","warning:  `WithTop.coe_nat` has been deprecated, use `WithTop.coe_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚ä§ - ‚Üë?m.79514
case pos
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí E
x : ùïú
hf : MeromorphicAt f x
n : ‚Ñ§
h : ‚ãØ.order = ‚ä§
‚ä¢ ‚ä§ - ‚Üë‚Üë(Exists.choose hf) = ‚Üën ‚Üî ‚àÉ g, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z
warning:  `WithTop.coe_nat` has been deprecated, use `WithTop.coe_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë?m.80098 - ‚Üë?m.80099
case neg.intro
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí E
x : ùïú
hf : MeromorphicAt f x
n : ‚Ñ§
h‚úù : ¬¨‚ãØ.order = ‚ä§
m : ‚Ñï
h : ‚Üëm = ‚ãØ.order
‚ä¢ ‚Üë‚Üëm - ‚Üë‚Üë(Exists.choose hf) = ‚Üën ‚Üî ‚àÉ g, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z","lemma order_eq_int_iff {f : ùïú ‚Üí E} {x : ùïú} (hf : MeromorphicAt f x) (n : ‚Ñ§) : hf.order = n ‚Üî
    ‚àÉ g : ùïú ‚Üí E, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z ",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_natCast, ‚Üê coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_nat, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left,
        zpow_coe_nat]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©"
Mathlib/Analysis/Calculus/LocalExtr/Polynomial.lean,Polynomial.card_roots_le_derivative,card_roots_le_derivative,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":=
  calc
    Multiset.card p.roots = ‚àë x in p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x in p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x in p.roots.toFinset, (p.rootMultiplicity x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x in p.roots.toFinset, p.derivative.rootMultiplicity x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x in p.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x in p.derivative.roots.toFinset \ p.roots.toFinset,
            p.derivative.roots.count x) + 1) := by
      simp only [‚Üê count_roots]
      refine add_le_add_left (add_le_add_right ((Finset.card_eq_sum_ones _).trans_le ?_) _) _
      refine Finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| ?_
      rw [Multiset.count_pos, ‚Üê Multiset.mem_toFinset]
      exact (Finset.mem_sdiff.1 hx).1
    _ = Multiset.card (derivative p).roots + 1 := by
      rw [‚Üê add_assoc, ‚Üê Finset.sum_union Finset.disjoint_sdiff, Finset.union_sdiff_self_eq_union, ‚Üê
        Multiset.toFinset_sum_count_eq, ‚Üê Finset.sum_subset (Finset.subset_union_right _ _)]
      intro x _ hx‚ÇÇ
      simpa only [Multiset.mem_toFinset, Multiset.count_eq_zero] using hx‚ÇÇ","error:  function expected at
  Finset.subset_union_right ?m.14170
term has type
  ?m.14169 ‚àà ?m.14167 ‚à™ ?m.14168","theorem card_roots_le_derivative (p : ‚Ñù[X]) :
    Multiset.card p.roots ‚â§ Multiset.card (derivative p).roots + 1 ",":=
  calc
    Multiset.card p.roots = ‚àë x ‚àà p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.rootMultiplicity x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.rootMultiplicity x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x ‚àà p.derivative.roots.toFinset \ p.roots.toFinset,
            p.derivative.roots.count x) + 1) := by
      simp only [‚Üê count_roots]
      refine add_le_add_left (add_le_add_right ((Finset.card_eq_sum_ones _).trans_le ?_) _) _
      refine Finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| ?_
      rw [Multiset.count_pos, ‚Üê Multiset.mem_toFinset]
      exact (Finset.mem_sdiff.1 hx).1
    _ = Multiset.card (derivative p).roots + 1 := by
      rw [‚Üê add_assoc, ‚Üê Finset.sum_union Finset.disjoint_sdiff, Finset.union_sdiff_self_eq_union, ‚Üê
        Multiset.toFinset_sum_count_eq, ‚Üê Finset.sum_subset Finset.subset_union_right]
      intro x _ hx‚ÇÇ
      simpa only [Multiset.mem_toFinset, Multiset.count_eq_zero] using hx‚ÇÇ",":=
  calc
    Multiset.card p.roots = ‚àë x ‚àà p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
"
Mathlib/Geometry/RingedSpace/Basic.lean,AlgebraicGeometry.RingedSpace.isUnit_of_isUnit_germ,isUnit_of_isUnit_germ,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  choose V iVU m h_unit using fun x : U => X.isUnit_res_of_isUnit_germ U f x (h x)
  have hcover : U ‚â§ iSup V
  ¬∑ intro x hxU
    erw [Opens.mem_iSup]
    exact ‚ü®‚ü®x, hxU‚ü©, m ‚ü®x, hxU‚ü©‚ü©
  choose g hg using fun x : U => IsUnit.exists_right_inv (h_unit x)
  have ic : IsCompatible (sheaf X).val V g
  ¬∑ intro x y
    apply section_ext X.sheaf (V x ‚äì V y)
    rintro ‚ü®z, hzVx, hzVy‚ü©
    erw [germ_res_apply, germ_res_apply]
    apply (IsUnit.mul_right_inj (h ‚ü®z, (iVU x).le hzVx‚ü©)).mp
    rw [‚Üêshow X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
      X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
      X.presheaf.germ_res_apply (iVU x) ‚ü®z, hzVx‚ü© f]
    change X.presheaf.germ ‚ü®z, hzVx‚ü© _ * (X.presheaf.germ ‚ü®z, hzVx‚ü© _) =
      X.presheaf.germ ‚ü®z, hzVx‚ü© _ * X.presheaf.germ ‚ü®z, hzVy‚ü© (g y)
    rw [‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVx‚ü© : V x)) (hg x),
      show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVy‚ü© (X.presheaf.map (iVU y).op f) =
          X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
          X.presheaf.germ_res_apply (iVU y) ‚ü®z, hzVy‚ü© f,
      ‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVy‚ü© : V y)) (hg y), RingHom.map_one, RingHom.map_one]
  obtain ‚ü®gl, gl_spec, -‚ü© := X.sheaf.existsUnique_gluing' V U iVU hcover g ic
  apply isUnit_of_mul_eq_one f gl
  apply X.sheaf.eq_of_locally_eq' V U iVU hcover
  intro i
  rw [RingHom.map_one, RingHom.map_mul, gl_spec]
  exact hg i","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
X : RingedSpace
U : Opens ‚Üë‚ÜëX.toPresheafedSpace
f : ‚Üë(X.presheaf.obj { unop := U })
h : ‚àÄ (x : ‚Ü•U), IsUnit ((X.presheaf.germ x) f)
V : ‚Ü•U ‚Üí Opens ‚Üë‚ÜëX.toPresheafedSpace
iVU : (x : ‚Ü•U) ‚Üí V x ‚ü∂ U
m : ‚àÄ (x : ‚Ü•U), ‚Üëx ‚àà V x
h_unit : ‚àÄ (x : ‚Ü•U), IsUnit ((X.presheaf.map (iVU x).op) f)
hcover : U ‚â§ iSup V
‚ä¢ IsUnit f","theorem isUnit_of_isUnit_germ (U : Opens X) (f : X.presheaf.obj (op U))
    (h : ‚àÄ x : U, IsUnit (X.presheaf.germ x f)) : IsUnit f ",":= by
  choose V iVU m h_unit using fun x : U => X.isUnit_res_of_isUnit_germ U f x (h x)
  have hcover : U ‚â§ iSup V := by
    intro x hxU
    erw [Opens.mem_iSup]
    exact ‚ü®‚ü®x, hxU‚ü©, m ‚ü®x, hxU‚ü©‚ü©
  choose g hg using fun x : U => IsUnit.exists_right_inv (h_unit x)
  have ic : IsCompatible (sheaf X).val V g := by
    intro x y
    apply section_ext X.sheaf (V x ‚äì V y)
    rintro ‚ü®z, hzVx, hzVy‚ü©
    erw [germ_res_apply, germ_res_apply]
    apply (IsUnit.mul_right_inj (h ‚ü®z, (iVU x).le hzVx‚ü©)).mp
    rw [‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
      X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
      X.presheaf.germ_res_apply (iVU x) ‚ü®z, hzVx‚ü© f]
    change X.presheaf.germ ‚ü®z, hzVx‚ü© _ * (X.presheaf.germ ‚ü®z, hzVx‚ü© _) =
      X.presheaf.germ ‚ü®z, hzVx‚ü© _ * X.presheaf.germ ‚ü®z, hzVy‚ü© (g y)
    rw [‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVx‚ü© : V x)) (hg x),
      show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVy‚ü© (X.presheaf.map (iVU y).op f) =
          X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
          X.presheaf.germ_res_apply (iVU y) ‚ü®z, hzVy‚ü© f,
      ‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVy‚ü© : V y)) (hg y), RingHom.map_one, RingHom.map_one]
  obtain ‚ü®gl, gl_spec, -‚ü© := X.sheaf.existsUnique_gluing' V U iVU hcover g ic
  apply isUnit_of_mul_eq_one f gl
  apply X.sheaf.eq_of_locally_eq' V U iVU hcover
  intro i
  rw [RingHom.map_one, RingHom.map_mul, gl_spec]
  exact hg i",":= by
  choose V iVU m h_unit using fun x : U => X.isUnit_res_of_isUnit_germ U f x (h x)
  have hcover : U ‚â§ iSup V
  ¬∑ intro x hxU
    erw [Opens.mem_iSup]
    exact ‚ü®‚ü®x, hxU‚ü©, m ‚ü®x, hxU‚ü©‚ü©
  choose g hg using fun x : U => IsUnit.exists_right_inv (h_unit x)
  have ic : IsCompatible (sheaf X).val V g
  ¬∑ intro x y
    apply section_ext X.sheaf (V x ‚äì V y)
    rintro ‚ü®z, hzVx, hzVy‚ü©
    erw [germ_res_apply, germ_res_apply]
    apply (IsUnit.mul_right_inj (h ‚ü®z, (iVU x).le hzVx‚ü©)).mp
    rw [‚Üêshow X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
      X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
      X.presheaf.germ_res_apply (iVU x) ‚ü®z, hzVx‚ü© f]
    change X.presheaf.germ ‚ü®z, hzVx‚ü© _ * (X.presheaf.germ ‚ü®z, hzVx‚ü© _) =
      X.presheaf.germ ‚ü®z, hzVx‚ü© _ * X.presheaf.germ ‚ü®z, hzVx‚ü© (g y)
    rw [‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVx‚ü© : V x)) (hg x),
      show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from
        X.presheaf.germ_res_apply (iVU x) ‚ü®z, hzVx‚ü© f]
    change X.presheaf.germ ‚ü®z, hzVx‚ü© _ * (X.presheaf.germ ‚ü®z, hzVx‚ü© _) =
      X.presheaf.germ ‚ü®z, hzVx‚ü© _ * X.presheaf.germ ‚ü®z, hzVx‚ü© (g y)
    rw [‚Üê RingHom.map_mul,
      congr_arg (X.presheaf.germ (‚ü®z, hzVx‚ü© : V x)) (hg x),
      show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU y).op f) =
          X.presheaf.germ ‚ü®z, ((iVU x) ‚ü®z, hzVx‚ü©).2‚ü© f from X.presheaf.germ_res_apply _ _ f,
      ‚Üê show X.presheaf.germ ‚ü®z, hzVx‚ü© (X.presheaf.map (iVU y).op f) =
          X.presheaf"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,a380f5a603bf5030bc30e58b1aed19567f67b98d,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 ‚Üí ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 ‚Üí ?m.124403
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134258 ‚Üí ?m.134258 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134394 ‚Üí ?m.134394 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/AlgebraicGeometry/Spec.lean,AlgebraicGeometry.Spec.sheafedSpaceMap_id,Spec.sheafedSpaceMap_id,796b4033eac2ff07562cc3dd2ea6c81031f7e12e,":=
  AlgebraicGeometry.PresheafedSpace.Hom.ext _ _ (Spec.topMap_id R) <| by
    ext U
    dsimp
    erw [PresheafedSpace.id_c_app, comap_id]; swap
    ¬∑ rw [Spec.topMap_id, TopologicalSpace.Opens.map_id_obj_unop]
    simp [eqToHom_map]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (ùüô ?X).c.app ?U
case w.w
R : CommRingCat
U : TopologicalSpace.Opens ‚Üë‚Üë(sheafedSpaceObj R).toPresheafedSpace
x‚úù : (forget CommRingCat).obj ((sheafedSpaceObj R).presheaf.obj { unop := U })
‚ä¢ ((structureSheaf ‚ÜëR).val.map (ùüô { unop := (TopologicalSpace.Opens.map (ùüô (topObj R))).obj U }))
      ((comap (ùüô R) U ((TopologicalSpace.Opens.map (ùüô (topObj R))).obj U) ‚ãØ) x‚úù) =
    (ùüô ((structureSheaf ‚ÜëR).val.obj { unop := U })) x‚úù","theorem Spec.sheafedSpaceMap_id {R : CommRingCat.{u}} :
    Spec.sheafedSpaceMap (ùüô R) = ùüô (Spec.sheafedSpaceObj R) ",":=
  AlgebraicGeometry.PresheafedSpace.Hom.ext _ _ (Spec.topMap_id R) <| by
    ext
    dsimp
    erw [comap_id (by simp)]
    simp",":=
  AlgebraicGeometry.PresheafedSpace.Hom.ext _ _ (Spec.topMap_id R) <| by
    ext U
    dsimp
    erw [PresheafedSpace.id_c_app, comap_id]
    ¬∑ rw [Spec.topMap_id, TopologicalSpace.Opens.map_id_obj_unop]
    simp [eqToHom_map]"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine' ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, _‚ü©, rfl‚ü©, _‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)","error:  function expected at
  le_integralClosure_iff_isIntegral.mp (adjoin_le_integralClosure (IsPrimitiveRoot.isIntegral hŒ∂ (PNat.pos (p ^ k))))
term has type
  Algebra.IsIntegral ‚Ñ§ ‚Ü•(adjoin ‚Ñ§ {Œ∂})
error:  unknown constant 'StrictOrderedSemiring.to_charZero'","theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ‚Ñö K]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ k)) : IsIntegralClosure (adjoin ‚Ñ§ ({Œ∂} : Set K)) ‚Ñ§ K ",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)",":= by
  refine ‚ü®Subtype.val_injective, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  swap
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hŒ∂.isIntegral (p ^ k).pos)) _)
  let B := hŒ∂.subOnePowerBasis ‚Ñö
  have hint : IsIntegral ‚Ñ§ B.gen := (hŒ∂.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ‚Ñö K
  have H := discr_mul_isIntegral_mem_adjoin ‚Ñö hint h
  obtain ‚ü®u, n, hun‚ü© := discr_prime_pow_eq_unit_mul_pow' hŒ∂
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [‚Üê smul_assoc, ‚Üê smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ‚Üê Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  ¬∑ haveI : IsCyclotomicExtension {1} ‚Ñö K := by simpa using hcycl
    have : x ‚àà (‚ä• : Subalgebra ‚Ñö K) := by
      rw [singleton_one ‚Ñö K]
      exact mem_top
    obtain ‚ü®y, rfl‚ü© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ‚Ñö K).injective).1 h
    obtain ‚ü®z, hz‚ü© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [‚Üê hz, ‚Üê IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  ¬∑ have hmin : (minpoly ‚Ñ§ B.gen).IsEisensteinAt (Submodule.span ‚Ñ§ {((p : ‚Ñï) : ‚Ñ§)}) := by
      have h‚ÇÅ := minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hint
      have h‚ÇÇ := hŒ∂.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h‚ÇÅ
      rw [h‚ÇÅ, ‚Üê map_cyclotomic_int, show Int.castRingHom ‚Ñö = algebraMap ‚Ñ§ ‚Ñö by rfl,
        show X + 1 = map (algebraMap ‚Ñ§ ‚Ñö) (X + 1) by simp, ‚Üê map_comp] at h‚ÇÇ
      haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ‚Ñ§ ‚Ñö) (algebraMap ‚Ñ§ ‚Ñö).injective_int h‚ÇÇ]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ‚Ñ§ _) (Subalgebra.one_mem _)"
Mathlib/Data/Int/CardIntervalMod.lean,Nat.count_modEq_card_eq_ceil,count_modEq_card_eq_ceil,0cfa2e624adcb0050d763a6de2232c16cdae9d5c,":= by
  have hr' : 0 < (r : ‚Ñö) := by positivity
  rw [count_eq_card_filter_range, ‚Üê Ico_zero_eq_range, Ico_filter_modEq_card _ _ hr,
    max_eq_left (sub_nonneg.mpr <| by gcongr <;> positivity)]
  conv_lhs =>
    rw [‚Üê div_add_mod v r, cast_add, cast_mul, add_comm]
    tactic => simp_rw [‚Üê sub_sub, sub_div (_ - _), mul_div_cancel_left _ hr'.ne', ceil_sub_nat]
    rw [sub_sub_sub_cancel_right, cast_zero, zero_sub]
  rw [sub_eq_self, ceil_eq_zero_iff, Set.mem_Ioc, div_le_iff hr', lt_div_iff hr', neg_one_mul,
    zero_mul, neg_lt_neg_iff, cast_lt]
  exact ‚ü®mod_lt _ hr, by simp‚ü©","error:  application type mismatch
  mul_div_cancel_left ?m.114531 (LT.lt.ne' hr')
argument
  LT.lt.ne' hr'
has type
  ‚Üër ‚â† 0 : Prop
but is expected to have type
  ?m.114529 : Type ?u.114528
error:  simp made no progress","theorem count_modEq_card_eq_ceil (v : ‚Ñï) :
    b.count (¬∑ ‚â° v [MOD r]) = ‚åà(b - (v % r : ‚Ñï)) / (r : ‚Ñö)‚åâ ",":= by
  have hr' : 0 < (r : ‚Ñö) := by positivity
  rw [count_eq_card_filter_range, ‚Üê Ico_zero_eq_range, Ico_filter_modEq_card _ _ hr,
    max_eq_left (sub_nonneg.mpr <| by gcongr <;> positivity)]
  conv_lhs =>
    rw [‚Üê div_add_mod v r, cast_add, cast_mul, add_comm]
    tactic => simp_rw [‚Üê sub_sub, sub_div (_ - _), mul_div_cancel_left‚ÇÄ _ hr'.ne', ceil_sub_nat]
    rw [sub_sub_sub_cancel_right, cast_zero, zero_sub]
  rw [sub_eq_self, ceil_eq_zero_iff, Set.mem_Ioc, div_le_iff hr', lt_div_iff hr', neg_one_mul,
    zero_mul, neg_lt_neg_iff, cast_lt]
  exact ‚ü®mod_lt _ hr, by simp‚ü©",":= by
  have hr' : 0 < (r : ‚Ñö) := by rw [count_eq_card_filter_range, ‚Üê Ico_zero_eq_range, Ico_filter_modEq_card _ _ hr,
    max_eq_left (sub_nonneg.mpr <| by gcongr <;> positivity)]
  conv_lhs =>
    rw [‚Üê div_add_mod v r, cast_add, cast_mul, add_comm]
    tactic => simp_rw [‚Üê sub_sub, sub_div (_ - _), mul_div_cancel_left _ hr'.ne', ceil_sub_nat]
    rw [sub_sub_sub_cancel_right, cast_zero, zero_sub]
  rw [sub_eq_self, ceil_eq_zero_iff, Set.mem_Ioc, div_le_iff hr', lt_div_iff hr', neg_one_mul,
    zero_mul, neg_lt_neg_iff, cast_lt]
  exact ‚ü®mod_lt _ hr, by simp‚ü©"
Mathlib/Analysis/Calculus/BumpFunction/FiniteDimension.lean,ExistsContDiffBumpBase.u_int_pos,u_int_pos,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  refine (integral_pos_iff_support_of_nonneg u_nonneg ?_).mpr? _
  ¬∑ exact (u_continuous E).integrable_of_hasCompactSupport (u_compact_support E)
  ¬∑ rw [u_support]; exact measure_ball_pos _ _ zero_lt_one","error:  invalid field 'mpr?', the environment does not contain 'Iff.mpr?'
  integral_pos_iff_support_of_nonneg u_nonneg ?m.116428
has type
  0 < ‚à´ (x : ?m.115925), u x ‚àÇ?m.115922 ‚Üî 0 < ?m.115922 (support u)
error:  no goals to be solved","theorem u_int_pos : 0 < ‚à´ x : E, u x ‚àÇŒº ",":= by
  refine (integral_pos_iff_support_of_nonneg u_nonneg ?_).mpr ?_
  ¬∑ exact (u_continuous E).integrable_of_hasCompactSupport (u_compact_support E)
  ¬∑ rw [u_support]; exact measure_ball_pos _ _ zero_lt_one",":= by
  refine (integral_pos_iff_support_of_nonneg u_nonneg ?_).mpr ?_
  ¬∑ exact (u_continuous E).integrable_of_hasCompactSupport (u_compact_support E)
  ¬∑ rw [u_support]; exact measure_ball_pos _ _ zero_lt_one"
Mathlib/Analysis/Complex/Schwarz.lean,Complex.affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div,affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  set g := dslope f c
  rintro z hz
  by_cases z = c; ¬∑ simp [h]
  have h_R‚ÇÅ : 0 < R‚ÇÅ := nonempty_ball.mp ‚ü®_, h_z‚ÇÄ‚ü©
  have g_le_div : ‚àÄ z ‚àà ball c R‚ÇÅ, ‚Äñg z‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ := fun z hz =>
    norm_dslope_le_div_of_mapsTo_ball hd h_maps hz
  have g_max : IsMaxOn (norm ‚àò g) (ball c R‚ÇÅ) z‚ÇÄ :=
    isMaxOn_iff.mpr fun z hz => by simpa [h_eq] using g_le_div z hz
  have g_diff : DifferentiableOn ‚ÑÇ g (ball c R‚ÇÅ) :=
    (differentiableOn_dslope (isOpen_ball.mem_nhds (mem_ball_self h_R‚ÇÅ))).mpr hd
  have : g z = g z‚ÇÄ := eqOn_of_isPreconnected_of_isMaxOn_norm (convex_ball c R‚ÇÅ).isPreconnected
    isOpen_ball g_diff h_z‚ÇÄ g_max hz
  simp [‚Üê this]","error:  unknown identifier 'h'
error:  unsolved goals
case pos
E : Type u_1
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚ÑÇ E
R R‚ÇÅ R‚ÇÇ : ‚Ñù
f : ‚ÑÇ ‚Üí E
c z‚úù z‚ÇÄ : ‚ÑÇ
inst‚úù¬π : CompleteSpace E
inst‚úù : StrictConvexSpace ‚Ñù E
hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ)
h_maps : MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ)
h_z‚ÇÄ : z‚ÇÄ ‚àà ball c R‚ÇÅ
g : ‚ÑÇ ‚Üí E := dslope f c
h_eq : ‚Äñg z‚ÇÄ‚Äñ = R‚ÇÇ / R‚ÇÅ
z : ‚ÑÇ
hz : z ‚àà ball c R‚ÇÅ
h‚úù : z = c
‚ä¢ f z = f c + (z - c) ‚Ä¢ g z‚ÇÄ
error:  unsolved goals
case neg
E : Type u_1
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚ÑÇ E
R R‚ÇÅ R‚ÇÇ : ‚Ñù
f : ‚ÑÇ ‚Üí E
c z‚úù z‚ÇÄ : ‚ÑÇ
inst‚úù¬π : CompleteSpace E
inst‚úù : StrictConvexSpace ‚Ñù E
hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ)
h_maps : MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ)
h_z‚ÇÄ : z‚ÇÄ ‚àà ball c R‚ÇÅ
g : ‚ÑÇ ‚Üí E := dslope f c
h_eq : ‚Äñg z‚ÇÄ‚Äñ = R‚ÇÇ / R‚ÇÅ
z : ‚ÑÇ
hz : z ‚àà ball c R‚ÇÅ
h‚úù : ¬¨z = c
h_R‚ÇÅ : 0 < R‚ÇÅ
g_le_div : ‚àÄ z ‚àà ball c R‚ÇÅ, ‚Äñg z‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ
g_max : IsMaxOn (norm ‚àò g) (ball c R‚ÇÅ) z‚ÇÄ
g_diff : DifferentiableOn ‚ÑÇ g (ball c R‚ÇÅ)
this : g z = g z‚ÇÄ
‚ä¢ f z = f c + (z - c) ‚Ä¢ g z","theorem affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div [CompleteSpace E] [StrictConvexSpace ‚Ñù E]
    (hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ)) (h_maps : Set.MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ))
    (h_z‚ÇÄ : z‚ÇÄ ‚àà ball c R‚ÇÅ) (h_eq : ‚Äñdslope f c z‚ÇÄ‚Äñ = R‚ÇÇ / R‚ÇÅ) :
    Set.EqOn f (fun z => f c + (z - c) ‚Ä¢ dslope f c z‚ÇÄ) (ball c R‚ÇÅ) ",":= by
  set g := dslope f c
  rintro z hz
  by_cases h : z = c; ¬∑ simp [h]
  have h_R‚ÇÅ : 0 < R‚ÇÅ := nonempty_ball.mp ‚ü®_, h_z‚ÇÄ‚ü©
  have g_le_div : ‚àÄ z ‚àà ball c R‚ÇÅ, ‚Äñg z‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ := fun z hz =>
    norm_dslope_le_div_of_mapsTo_ball hd h_maps hz
  have g_max : IsMaxOn (norm ‚àò g) (ball c R‚ÇÅ) z‚ÇÄ :=
    isMaxOn_iff.mpr fun z hz => by simpa [h_eq] using g_le_div z hz
  have g_diff : DifferentiableOn ‚ÑÇ g (ball c R‚ÇÅ) :=
    (differentiableOn_dslope (isOpen_ball.mem_nhds (mem_ball_self h_R‚ÇÅ))).mpr hd
  have : g z = g z‚ÇÄ := eqOn_of_isPreconnected_of_isMaxOn_norm (convex_ball c R‚ÇÅ).isPreconnected
    isOpen_ball g_diff h_z‚ÇÄ g_max hz
  simp [g] at this
  simp [g, ‚Üê this]",":= by
  set g := dslope f c
  rintro z hz
  by_cases z = c; ¬∑ simp [h]
  have h_R‚ÇÅ : 0 < R‚ÇÅ := nonempty_ball.mp ‚ü®_, h_z‚ÇÄ‚ü©
  have g_le_div : ‚àÄ z ‚àà ball c R‚ÇÅ, ‚Äñg z‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ := fun z hz =>
    norm_dslope_le_div_of_mapsTo_ball hd h_maps hz
  have g_max : IsMaxOn (norm ‚àò g) (ball c R‚ÇÅ) z‚ÇÄ :=
    isMaxOn_iff.mpr fun z hz => by simpa [h_eq] using g_le_div z hz
  have g_diff : DifferentiableOn ‚ÑÇ g (ball c R‚ÇÅ) :=
    (differentiableOn_dslope (isOpen_ball.mem_nhds (mem_ball_self h_R‚ÇÅ))).mpr hd
  have : g z = g z‚ÇÄ := eqOn_of_isPreconnected_of_isMaxOn_norm (convex_ball c R‚ÇÅ).isPreconnected
    isOpen_ball g_diff h_z‚ÇÄ g_max hz
  simp [‚Üê this]"
Mathlib/Analysis/Complex/CauchyIntegral.lean,Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r; exact ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R; exact ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine' fun z hz => (hd (g z) ‚ü®_, hz.2‚ü©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  application type mismatch
  mul_div_cancel_left ?m.98557 (circleMap_ne_center (LT.lt.ne' (Real.exp_pos ?m.98560)))
argument
  circleMap_ne_center (LT.lt.ne' (Real.exp_pos ?m.98560))
has type
  circleMap ?m.98558 (rexp ?m.98560) ?m.98590 ‚â† ?m.98558 : Prop
but is expected to have type
  ?m.98555 : Type ?u.98554
error:  tactic 'assumption' failed
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚ÑÇ E
inst‚úù : CompleteSpace E
c : ‚ÑÇ
f : ‚ÑÇ ‚Üí E
s : Set ‚ÑÇ
hs : s.Countable
a : ‚Ñù
h0 : 0 < rexp a
b : ‚Ñù
hle : a ‚â§ b
hd : ‚àÄ z ‚àà (ball c (rexp b) \ closedBall c (rexp a)) \ s, DifferentiableAt ‚ÑÇ f z
A : Set ‚ÑÇ := closedBall c (rexp b) \ ball c (rexp a)
hc : ContinuousOn f A
this : ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, I ‚Ä¢ f (circleMap c (rexp b) Œ∏) = ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, I ‚Ä¢ f (circleMap c (rexp a) Œ∏)
‚ä¢ ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, (circleMap 0 (rexp b) Œ∏ * I / circleMap 0 (rexp b) Œ∏) ‚Ä¢ f (circleMap c (rexp b) Œ∏) =
    ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, (circleMap 0 (rexp a) Œ∏ * I / circleMap 0 (rexp a) Œ∏) ‚Ä¢ f (circleMap c (rexp a) Œ∏)","theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ‚ÑÇ}
    {r R : ‚Ñù} (h0 : 0 < r) (hle : r ‚â§ R) {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ‚àÄ z ‚àà (ball c R \ closedBall c r) \ s, DifferentiableAt ‚ÑÇ f z) :
    (‚àÆ z in C(c, R), (z - c)‚Åª¬π ‚Ä¢ f z) = ‚àÆ z in C(c, r), (z - c)‚Åª¬π ‚Ä¢ f z ",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r := ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R := ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left‚ÇÄ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine fun z hz => (hd (g z) ‚ü®?_, hz.2‚ü©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r; exact ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R; exact ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine fun z hz => (hd (g z) ‚ü®?_, hz.2‚ü©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd"
Mathlib/LinearAlgebra/Semisimple.lean,Module.End.IsSemisimple.of_mem_adjoin_pair,IsSemisimple.of_mem_adjoin_pair,febed03c621542deef30d30ba2ce7c07a0a48924,":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R := (AdjoinRoot.powerBasis' <| minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral g).map _).finite
  set_option maxSynthPendingDepth 2 in
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ, ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.comp_apply, minpoly.aeval, œÜ.map_zero]","error:  function expected at
  isIntegral
term has type
  Algebra.IsIntegral ?m.165678 (End ?m.165678 ?m.165680)
error:  function expected at
  isIntegral
term has type
  Algebra.IsIntegral ?m.168378 (End ?m.168378 ?m.168380)","theorem IsSemisimple.of_mem_adjoin_pair {a : End K M} (ha : a ‚àà Algebra.adjoin K {f, g}) :
    a.IsSemisimple ",":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R :=
    (AdjoinRoot.powerBasis' <| minpoly.monic <| Algebra.IsIntegral.isIntegral f).finite
  have : Finite R S :=
    (AdjoinRoot.powerBasis' <| (minpoly.monic <| Algebra.IsIntegral.isIntegral g).map _).finite
  set_option maxSynthPendingDepth 2 in
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ, ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.comp_apply, minpoly.aeval, œÜ.map_zero]",":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R := (AdjoinRoot.powerBasis' <| minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral g).map _).finite
  set_option maxSynthPendingDepth 2 in
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ', ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.comp_apply, minpoly.aeval, œÜ.map_zero]"
Mathlib/NumberTheory/Modular.lean,ModularGroup.tendsto_normSq_coprime_pair,tendsto_normSq_coprime_pair,a3708498bec5c2641fd86b158487e675e90d687a,":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, ofReal_mul_im, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * 1
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
x‚úù : Fin 2 ‚Üí ‚Ñù
‚ä¢ f x‚úù = ‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)
error:  unknown identifier 'ofReal_int_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.22080
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
f_def : ‚áëf = fun p ‚Ü¶ ‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)
x‚úù : Fin 2 ‚Üí ‚Ñ§
‚ä¢ normSq (‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)) = normSq (‚Üë‚Üë(x‚úù 0) * ‚Üëz + ‚Üë‚Üë(x‚úù 1))
error:  unknown identifier 'ofReal_mul_im'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.33716
case h.h.head
g‚úù : SL(2, ‚Ñ§)
z : ‚Ñç
this‚úù : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
f_def : ‚áëf = fun p ‚Ü¶ ‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)
this : (fun p ‚Ü¶ normSq (‚Üë(p 0) * ‚Üëz + ‚Üë(p 1))) = ‚áënormSq ‚àò ‚áëf ‚àò fun p ‚Ü¶ Int.cast ‚àò p
g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù := LinearMap.pi ![imLm, imLm ‚àò‚Çó (‚Üëz ‚Ä¢ (‚Üë‚ÜëconjAe).toLinearMap)]
c : Fin 2 ‚Üí ‚Ñù
hz : (‚Üëz).im ‚â† 0
‚ä¢ (‚Üëz).im‚Åª¬π * ((‚Üë(c 0) * ‚Üëz).im + (‚Üë(c 1)).im) = c 0
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem tendsto_normSq_coprime_pair :
    Filter.Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * z + p 1)) cofinite atTop ",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_intCast, ofReal_intCast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, ofReal_mul_im, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)"
Mathlib/Topology/Metrizable/Urysohn.lean,TopologicalSpace.exists_inducing_l_infty,exists_inducing_l_infty,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono (inter_subset_left _ _)).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine' ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, _‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine' ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm _ _‚ü©
  ¬∑ refine' (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => _
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine' (eventually_all_finite h_fin).2 fun UV _ => _
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine' this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => _
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine' ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 _
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => ?_‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _","error:  function expected at
  inter_subset_left ?m.504
term has type
  ?m.503 ‚àà ?m.501","theorem exists_inducing_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Inducing f ",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => ?_
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => ?_‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.isometry_extend (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV"
Mathlib/Analysis/Complex/CauchyIntegral.lean,Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,15fc142c24a81bf41226645e01783f71b75b9d92,":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r; exact ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R; exact ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine' fun z hz => (hd (g z) ‚ü®_, hz.2‚ü©).comp z (hdg _)
    simpa [dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  application type mismatch
  mul_div_cancel_left ?m.98557 (circleMap_ne_center (LT.lt.ne' (Real.exp_pos ?m.98560)))
argument
  circleMap_ne_center (LT.lt.ne' (Real.exp_pos ?m.98560))
has type
  circleMap ?m.98558 (rexp ?m.98560) ?m.98590 ‚â† ?m.98558 : Prop
but is expected to have type
  ?m.98555 : Type ?u.98554
error:  tactic 'assumption' failed
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚ÑÇ E
inst‚úù : CompleteSpace E
c : ‚ÑÇ
f : ‚ÑÇ ‚Üí E
s : Set ‚ÑÇ
hs : s.Countable
a : ‚Ñù
h0 : 0 < rexp a
b : ‚Ñù
hle : a ‚â§ b
hd : ‚àÄ z ‚àà (ball c (rexp b) \ closedBall c (rexp a)) \ s, DifferentiableAt ‚ÑÇ f z
A : Set ‚ÑÇ := closedBall c (rexp b) \ ball c (rexp a)
hc : ContinuousOn f A
this : ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, I ‚Ä¢ f (circleMap c (rexp b) Œ∏) = ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, I ‚Ä¢ f (circleMap c (rexp a) Œ∏)
‚ä¢ ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, (circleMap 0 (rexp b) Œ∏ * I / circleMap 0 (rexp b) Œ∏) ‚Ä¢ f (circleMap c (rexp b) Œ∏) =
    ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, (circleMap 0 (rexp a) Œ∏ * I / circleMap 0 (rexp a) Œ∏) ‚Ä¢ f (circleMap c (rexp a) Œ∏)
error:  type mismatch
  h‚úù
has type
  z.re ‚â§ b ‚àß a ‚â§ z.re : Prop
but is expected to have type
  g z ‚àà A : Prop
error:  type mismatch
  h‚úù
has type
  a < z.re ‚àß z.re < b : Prop
but is expected to have type
  rexp a < abs (g z - c) ‚àß abs (g z - c) < rexp b : Prop
error:  type mismatch
  h‚úù
has type
  ((‚à´ (x : ‚Ñù) in a..b, f (g ‚Üëx)) - ‚à´ (x : ‚Ñù) in a..b, f (g (‚Üëx + 2 * ‚ÜëœÄ * I))) +
      I ‚Ä¢ ‚à´ (y : ‚Ñù) in 0 ..2 * œÄ, f (g (‚Üëb + ‚Üëy * I)) =
    I ‚Ä¢ ‚à´ (y : ‚Ñù) in 0 ..2 * œÄ, f (g (‚Üëa + ‚Üëy * I)) : Prop
but is expected to have type
  I ‚Ä¢ ‚à´ (x : ‚Ñù) in 0 ..2 * œÄ, f (c + cexp (‚Üëb + ‚Üëx * I)) = I ‚Ä¢ ‚à´ (x : ‚Ñù) in 0 ..2 * œÄ, f (c + cexp (‚Üëa + ‚Üëx * I)) : Prop","theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ‚ÑÇ}
    {r R : ‚Ñù} (h0 : 0 < r) (hle : r ‚â§ R) {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ‚àÄ z ‚àà (ball c R \ closedBall c r) \ s, DifferentiableAt ‚ÑÇ f z) :
    (‚àÆ z in C(c, R), (z - c)‚Åª¬π ‚Ä¢ f z) = ‚àÆ z in C(c, r), (z - c)‚Åª¬π ‚Ä¢ f z ",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r := ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R := ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left‚ÇÄ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine fun z hz => (hd (g z) ‚ü®?_, hz.2‚ü©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r; exact ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R; exact ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine fun z hz => (hd (g z) ‚ü®?_, hz.2‚ü©).comp z (hdg _)
    simpa [dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd"
Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean,CochainComplex.HomComplex.Cocycle.coe_sub,coe_sub,9072ff84a0d139a344bf9eed4a00c4cd27596c79,  (z‚ÇÅ : Cochain F G n) - (z‚ÇÇ : Cochain F G n) := rfl,"error:  application type mismatch
  ‚Üëz‚ÇÇ ‚Üëz‚ÇÅ
argument
  ‚Üëz‚ÇÅ
has type
  Cochain F G n : Type v
but is expected to have type
  Triplet n : Type","lemma coe_sub (z‚ÇÅ z‚ÇÇ : Cocycle F G n) :
    (‚Üë(z‚ÇÅ - z‚ÇÇ) : Cochain F G n) = (z‚ÇÅ : Cochain F G n) - (z‚ÇÇ : Cochain F G n) ",:= rfl,:= rfl
Mathlib/Topology/OmegaCompletePartialOrder.lean,notBelow_isOpen,notBelow_isOpen,0c1dd9cbd45d804e559a743f61a0763f683221f0,":= by
  have h : Monotone (notBelow y) := fun x z hle ‚Ü¶ mt hle.trans
  change œâScottContinuous fun x ‚Ü¶ x ‚àà (notBelow y)
  rw [œâScottContinuous_iff_monotone_map_œâSup]
  refine ‚ü®h, fun c ‚Ü¶ eq_of_forall_ge_iff fun z ‚Ü¶ ?_‚ü©
  simp only [œâSup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]","error:  unknown identifier 'œâScottContinuous'
error:  unknown identifier 'œâScottContinuous_iff_monotone_map_œâSup'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.30292
Œ± : Type u_1
inst‚úù : OmegaCompletePartialOrder Œ±
y : Scott Œ±
h : Monotone (notBelow y)
‚ä¢ sorryAx (Sort ?u.30117) true
error:  invalid occurrence of universe level 'u_3' at 'scottContinuous_of_continuous', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  notBelow_isOpen.{u_2, u_3} (f y)
at declaration body
  fun {Œ± : Type u_1} {Œ≤ : Type u_2} [OmegaCompletePartialOrder Œ±] [OmegaCompletePartialOrder Œ≤] (f : Scott Œ± ‚Üí Scott Œ≤)
      (hf : _root_.Continuous f) ‚Ü¶
    let_fun h : Monotone f := fun (x y : Scott Œ±) (h : x ‚â§ y) ‚Ü¶
      let_fun hf : IsUpperSet {x : Scott Œ± | ¬¨f x ‚â§ f y} :=
        IsOpen.isUpperSet Œ± (IsOpen.preimage hf (notBelow_isOpen (f y)));
      Eq.mp
        (Eq.trans
          (Eq.trans
            (implies_congr (Eq.refl ¬¨f x ‚â§ f y)
              (Eq.trans (congrArg Not (Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.5 (f y)))
                Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.6))
            Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.7)
          Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.8)
        (hf h);
    Exists.intro h fun (c : Chain (Scott Œ±)) ‚Ü¶
      eq_of_forall_ge_iff fun (z : Scott Œ≤) ‚Ü¶
        Exists.casesOn (IsOpen.preimage hf (notBelow_isOpen z))
          fun (hf : Monotone fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z)
            (hf' :
              OmegaCompletePartialOrder.Continuous { toFun := fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z, monotone' := hf }) ‚Ü¶
          Eq.mpr (id (congrArg (fun (_a : Prop) ‚Ü¶ _a) (Eq.symm (propext not_iff_not))))
            (Eq.mpr
              (id
                (congr
                  (congrArg Iff
                    (Eq.trans
                      (Eq.mp
                        (congr
                          (congrArg (fun (x : Œ± ‚Üío Prop) ‚Ü¶ Eq (x (œâSup c)))
                            ((fun {Œ± : Type u_1} {Œ≤ : Type} [Preorder Œ±] [Preorder Œ≤] (toFun toFun_1 : Œ± ‚Üí Œ≤)
                                  (e_toFun : toFun = toFun_1) ‚Ü¶
                                Eq.rec (motive := fun (toFun_2 : Œ± ‚Üí Œ≤) (e_toFun : toFun = toFun_2) ‚Ü¶
                                  ‚àÄ (monotone' : Monotone toFun),
                                    { toFun := toFun, monotone' := monotone' } =
                                      { toFun := toFun_2, monotone' := e_toFun ‚ñ∏ monotone' })
                                  (fun (monotone' : Monotone toFun) ‚Ü¶
                                    Eq.refl { toFun := toFun, monotone' := monotone' })
                                  e_toFun)
                              (fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z) (fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z)
                              (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf))
                          (congrArg (fun (x : Œ± ‚Üío Prop) ‚Ü¶ œâSup (c.map x))
                            ((fun {Œ± : Type u_1} {Œ≤ : Type} [Preorder Œ±] [Preorder Œ≤] (toFun toFun_1 : Œ± ‚Üí Œ≤)
                                  (e_toFun : toFun = toFun_1) ‚Ü¶
                                Eq.rec (motive := fun (toFun_2 : Œ± ‚Üí Œ≤) (e_toFun : toFun = toFun_2) ‚Ü¶
                                  ‚àÄ (monotone' : Monotone toFun),
                                    { toFun := toFun, monotone' := monotone' } =
                                      { toFun := toFun_2, monotone' := e_toFun ‚ñ∏ monotone' })
                                  (fun (monotone' : Monotone toFun) ‚Ü¶
                                    Eq.refl { toFun := toFun, monotone' := monotone' })
                                  e_toFun)
                              (fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z) (fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z)
                              (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf)))
                        (hf' c))
                      (congrArg Exists
                        (funext fun (a : Prop) ‚Ü¶
                          congrArg (fun (x : Prop) ‚Ü¶ x ‚àß a)
                            (Eq.trans Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.10
                              (congrArg Exists
                                (funext fun (y : ‚Ñï) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.11)))))))
                  (Eq.trans
                    (congrArg Not
                      (Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.9 (c.map { toFun := f, monotone' := h }) z))
                    Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.12)))
              (Or.casesOn
                (Decidable.iff_iff_and_or_not_and_not.mp
                  (Eq.to_iff
                    (Eq.mp
                      (congr
                        (congrArg (fun (x : Œ± ‚Üío Prop) ‚Ü¶ Eq (x (œâSup c)))
                          ((fun {Œ± : Type u_1} {Œ≤ : Type} [Preorder Œ±] [Preorder Œ≤] (toFun toFun_1 : Œ± ‚Üí Œ≤)
                                (e_toFun : toFun = toFun_1) ‚Ü¶
                              Eq.rec (motive := fun (toFun_2 : Œ± ‚Üí Œ≤) (e_toFun : toFun = toFun_2) ‚Ü¶
                                ‚àÄ (monotone' : Monotone toFun),
                                  { toFun := toFun, monotone' := monotone' } =
                                    { toFun := toFun_2, monotone' := e_toFun ‚ñ∏ monotone' })
                                (fun (monotone' : Monotone toFun) ‚Ü¶ Eq.refl { toFun := toFun, monotone' := monotone' })
                                e_toFun)
                            (fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z) (fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z)
                            (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf))
                        (congrArg (fun (x : Œ± ‚Üío Prop) ‚Ü¶ œâSup (c.map x))
                          ((fun {Œ± : Type u_1} {Œ≤ : Type} [Preorder Œ±] [Preorder Œ≤] (toFun toFun_1 : Œ± ‚Üí Œ≤)
                                (e_toFun : toFun = toFun_1) ‚Ü¶
                              Eq.rec (motive := fun (toFun_2 : Œ± ‚Üí Œ≤) (e_toFun : toFun = toFun_2) ‚Ü¶
                                ‚àÄ (monotone' : Monotone toFun),
                                  { toFun := toFun, monotone' := monotone' } =
                                    { toFun := toFun_2, monotone' := e_toFun ‚ñ∏ monotone' })
                                (fun (monotone' : Monotone toFun) ‚Ü¶ Eq.refl { toFun := toFun, monotone' := monotone' })
                                e_toFun)
                            (fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z) (fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z)
                            (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf)))
                      (hf' c))))
                (fun
                    (h :
                      ¬¨f (œâSup c) ‚â§ z ‚àß
                        œâSup
                          (c.map
                            { toFun := fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z,
                              monotone' :=
                                (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) ‚ñ∏ hf })) ‚Ü¶
                  And.casesOn h
                    fun (left : ¬¨f (œâSup c) ‚â§ z)
                      (right :
                        œâSup
                          (c.map
                            { toFun := fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z,
                              monotone' :=
                                (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) ‚ñ∏ hf })) ‚Ü¶
                    {
                      mp := fun (a : ‚àÉ (a : Prop), (‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî a) ‚àß a) ‚Ü¶
                        Exists.casesOn a fun (w : Prop) (h : (‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî w) ‚àß w) ‚Ü¶
                          And.casesOn h fun (left : ‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî w) (right : w) ‚Ü¶
                            Exists.casesOn left fun (w_1 : ‚Ñï) (h : ¬¨f (c w_1) ‚â§ z ‚Üî w) ‚Ü¶
                              Or.casesOn (Decidable.iff_iff_and_or_not_and_not.mp h)
                                (fun (h : ¬¨f (c w_1) ‚â§ z ‚àß w) ‚Ü¶
                                  And.casesOn h fun (left : ¬¨f (c w_1) ‚â§ z) (right : w) ‚Ü¶ Exists.intro w_1 left)
                                fun (h : ¬¨¬¨f (c w_1) ‚â§ z ‚àß ¬¨w) ‚Ü¶
                                And.casesOn h fun (left : ¬¨¬¨f (c w_1) ‚â§ z) (right_1 : ¬¨w) ‚Ü¶ absurd right right_1,
                      mpr := fun (a : ‚àÉ (x : ‚Ñï), ¬¨f (c x) ‚â§ z) ‚Ü¶
                        Exists.casesOn a fun (w : ‚Ñï) (h : ¬¨f (c w) ‚â§ z) ‚Ü¶
                          Exists.intro (¬¨f (c w) ‚â§ z) ‚ü®Exists.intro w Iff.rfl, h‚ü© })
                fun
                  (h :
                    ¬¨¬¨f (œâSup c) ‚â§ z ‚àß
                      ¬¨œâSup
                          (c.map
                            { toFun := fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z,
                              monotone' :=
                                (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) ‚ñ∏ hf })) ‚Ü¶
                And.casesOn h
                  fun (left : ¬¨¬¨f (œâSup c) ‚â§ z)
                    (right :
                      ¬¨œâSup
                          (c.map
                            { toFun := fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z,
                              monotone' :=
                                (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) ‚ñ∏ hf })) ‚Ü¶
                  {
                    mp := fun (a : ‚àÉ (a : Prop), (‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî a) ‚àß a) ‚Ü¶
                      Exists.casesOn a fun (w : Prop) (h : (‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî w) ‚àß w) ‚Ü¶
                        And.casesOn h fun (left : ‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî w) (right : w) ‚Ü¶
                          Exists.casesOn left fun (w_1 : ‚Ñï) (h : ¬¨f (c w_1) ‚â§ z ‚Üî w) ‚Ü¶
                            Or.casesOn (Decidable.iff_iff_and_or_not_and_not.mp h)
                              (fun (h : ¬¨f (c w_1) ‚â§ z ‚àß w) ‚Ü¶
                                And.casesOn h fun (left : ¬¨f (c w_1) ‚â§ z) (right : w) ‚Ü¶ Exists.intro w_1 left)
                              fun (h : ¬¨¬¨f (c w_1) ‚â§ z ‚àß ¬¨w) ‚Ü¶
                              And.casesOn h fun (left : ¬¨¬¨f (c w_1) ‚â§ z) (right_1 : ¬¨w) ‚Ü¶ absurd right right_1,
                    mpr := fun (a : ‚àÉ (x : ‚Ñï), ¬¨f (c x) ‚â§ z) ‚Ü¶
                      Exists.casesOn a fun (w : ‚Ñï) (h : ¬¨f (c w) ‚â§ z) ‚Ü¶
                        Exists.intro (¬¨f (c w) ‚â§ z) ‚ü®Exists.intro w Iff.rfl, h‚ü© }))",theorem notBelow_isOpen : IsOpen (notBelow y) ,":= by
  have h : Monotone (notBelow y) := fun x z hle ‚Ü¶ mt hle.trans
  refine ‚ü®h, fun c ‚Ü¶ eq_of_forall_ge_iff fun z ‚Ü¶ ?_‚ü©
  simp only [œâSup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]",":= by
  have h : Monotone (notBelow y) := fun x z hle ‚Ü¶ mt hle.trans
  change œâScottContinuous fun x ‚Ü¶ x ‚àà (notBelow y)
  rw [œâScottContinuous_iff_monotone_map_œâSup]
  refine ‚ü®h, fun c ‚Ü¶ eq_of_forall_ge_iff fun z ‚Ü¶ ?_‚ü©
  simp only [œâSup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]"
Mathlib/Order/OrderIsoNat.lean,RelEmbedding.acc_iff_no_decreasing_seq,acc_iff_no_decreasing_seq,3d1eb786ab19e0850749a0ee2e09d3ac5b9ccf43,":= by
  constructor
  ¬∑ refine' fun h => h.recOn fun x _ IH => _
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 :=
      by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    obtain ‚ü®f, h‚ü© := Classical.axiom_of_choice this
    refine' fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGt (fun n => ((f^[n]) ‚ü®x, hx‚ü©).1) fun n => _, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h","error:  unknown identifier 'lt_add_one'
error:  unknown identifier 'Classical.axiom_of_choice'
error:  rcases tactic failed: x‚úù : ?m.2248 is not an inductive datatype","theorem acc_iff_no_decreasing_seq {x} :
    Acc r x ‚Üî IsEmpty { f : ((¬∑ > ¬∑) : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop) ‚Ü™r r // x ‚àà Set.range f } ",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (Nat.lt_succ_self _))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    choose f h using this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, ?_, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 :=
      by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    obtain ‚ü®f, h‚ü© := Classical.axiom_of_choice this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGt (fun n => ((f^[n]) ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h"
Mathlib/Topology/MetricSpace/Polish.lean,IsClosed.isClopenable,_root_.IsClosed.isClopenable,e24d0042f0fd176848590f8a296e5c675237f634,":= by
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫
  ¬∑ simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    simp [preimage_preimage]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : TopologicalSpace Œ±
inst‚úù : PolishSpace Œ±
s : Set Œ±
hs : IsClosed s
this‚úù : PolishSpace ‚Üës
t : Set Œ± := s·∂ú
this : PolishSpace ‚Üët
f : ‚Üës ‚äï ‚Üët ‚âÉ Œ± := sorryAx (‚Üës ‚äï ‚Üët ‚âÉ Œ±) true
hle : coinduced (‚áëf) instTopologicalSpaceSum ‚â§ inst‚úù¬π
‚ä¢ IsClopenable s","theorem _root_.IsClosed.isClopenable [TopologicalSpace Œ±] [PolishSpace Œ±] {s : Set Œ±}
    (hs : IsClosed s) : IsClopenable s ",":= by
  classical
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫ := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    simp [f, preimage_preimage]",":= by
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫
  ¬∑ simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    simp [preimage_preimage]"
Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean,Real.Angle.cos_eq_iff_eq_or_eq_neg,cos_eq_iff_eq_or_eq_neg,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction œà
  exact cos_eq_real_cos_iff_eq_or_eq_neg","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ∏ œà : Angle
‚ä¢ Œ∏.cos = œà.cos ‚Üî Œ∏ = œà ‚à® Œ∏ = -œà",theorem cos_eq_iff_eq_or_eq_neg {Œ∏ œà : Angle} : cos Œ∏ = cos œà ‚Üî Œ∏ = œà ‚à® Œ∏ = -œà ,":= by
  induction œà using Real.Angle.induction_on
  exact cos_eq_real_cos_iff_eq_or_eq_neg",":=
  cos_eq_real_cos_iff_eq_or_eq_neg"
Mathlib/NumberTheory/LucasPrimality.lean,lucas_primality,lucas_primality,26daa9a9f2d032819a5c93099797dfafc8ed907a,":= by
  have h0 : p ‚â† 0 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have h1 : p ‚â† 1 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have hp1 : 1 < p := lt_of_le_of_ne h0.bot_lt h1.symm
  have order_of_a : orderOf a = p - 1 := by
    apply orderOf_eq_of_pow_and_pow_div_prime _ ha hd
    exact tsub_pos_of_lt hp1
  haveI : NeZero p := ‚ü®h0‚ü©
  rw [Nat.prime_iff_card_units]
  refine' le_antisymm (Nat.card_units_zMod_lt_sub_one hp1) _
  have hp' : p - 2 + 1 = p - 1 := tsub_add_eq_add_tsub hp1
  let a' : (ZMod p)À£ := Units.mkOfMulEqOne a (a ^ (p - 2)) (by rw [‚Üê pow_succ, hp', ha])
  calc
    p - 1 = orderOf a := order_of_a.symm
    _ = orderOf a' := (orderOf_injective (Units.coeHom (ZMod p)) Units.ext a')
    _ ‚â§ Fintype.card (ZMod p)À£ := orderOf_le_card_univ","error:  unknown constant 'Nat.card_units_zMod_lt_sub_one'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a ^ ?n * ?a
p : ‚Ñï
a : ZMod p
ha : a ^ (p - 1) = 1
hd : ‚àÄ (q : ‚Ñï), Nat.Prime q ‚Üí q ‚à£ p - 1 ‚Üí a ^ ((p - 1) / q) ‚â† 1
h0 : p ‚â† 0
h1 : p ‚â† 1
hp1 : 1 < p
order_of_a : orderOf a = p - 1
this : NeZero p
hp' : p - 2 + 1 = p - 1
‚ä¢ a * a ^ (p - 2) = 1","theorem lucas_primality (p : ‚Ñï) (a : ZMod p) (ha : a ^ (p - 1) = 1)
    (hd : ‚àÄ q : ‚Ñï, q.Prime ‚Üí q ‚à£ p - 1 ‚Üí a ^ ((p - 1) / q) ‚â† 1) : p.Prime ",":= by
  have h0 : p ‚â† 0 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have h1 : p ‚â† 1 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have hp1 : 1 < p := lt_of_le_of_ne h0.bot_lt h1.symm
  have order_of_a : orderOf a = p - 1 := by
    apply orderOf_eq_of_pow_and_pow_div_prime _ ha hd
    exact tsub_pos_of_lt hp1
  haveI : NeZero p := ‚ü®h0‚ü©
  rw [Nat.prime_iff_card_units]
  refine le_antisymm (Nat.card_units_zmod_lt_sub_one hp1) ?_
  have hp' : p - 2 + 1 = p - 1 := tsub_add_eq_add_tsub hp1
  let a' : (ZMod p)À£ := Units.mkOfMulEqOne a (a ^ (p - 2)) (by rw [‚Üê pow_succ', hp', ha])
  calc
    p - 1 = orderOf a := order_of_a.symm
    _ = orderOf a' := (orderOf_injective (Units.coeHom (ZMod p)) Units.ext a')
    _ ‚â§ Fintype.card (ZMod p)À£ := orderOf_le_card_univ",":= by
  have h0 : p ‚â† 0 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have h1 : p ‚â† 1 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have h1 : p ‚â† 1 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have h1 : p ‚â† 1 := by
    rintro ‚ü®‚ü©
    exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)
  have hp1 : 1 < p := lt_of_le_of_ne h0.bot_lt h1.symm
  have order_of_a : orderOf a = p - 1 := by
    apply orderOf_eq_of_pow_and_pow_div_prime _ ha hd
    exact tsub_pos_of_lt hp1
  haveI : NeZero p := ‚ü®h0‚ü©
  rw [Nat.prime_iff_card_units]
  refine le_antisymm (Nat.card_units_zMod_lt_sub_one hp1) ?_
  have hp' : p - 2 + 1 = p - 1 := tsub_add_eq_add_tsub hp1
  let a' : (ZMod p)À£ := Units.mkOfMulEqOne a (a ^ (p - 2)) (by rw [‚Üê pow_succ, hp', ha])
  calc
    p - 1 = orderOf a := order_of_a.symm
    _ = orderOf a' := (orderOf_injective (Units.coeHom (ZMod p)) Units.ext a')
    _ ‚â§ Fintype.card (ZMod p)À£ := orderOf_le_card_univ"
Mathlib/FieldTheory/IsAlgClosed/Basic.lean,IsAlgClosed.algebraMap_surjective_of_isIntegral',algebraMap_surjective_of_isIntegral',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  @algebraMap_surjective_of_isIntegral k K _ _ _ _ f.toAlgebra hf","error:  application type mismatch
  @algebraMap_surjective_of_isIntegral k K inst‚úù¬≥ CommRing.toRing inst‚úù¬π inst‚úù f.toAlgebra hf
argument
  hf
has type
  f.IsIntegral : Prop
but is expected to have type
  Algebra.IsIntegral k K : Prop","theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k ‚Üí+* K) (hf : f.IsIntegral) : Function.Surjective f ",":=
  let _ : Algebra k K := f.toAlgebra
  have : Algebra.IsIntegral k K := ‚ü®hf‚ü©
  algebraMap_surjective_of_isIntegral",":=
  @algebraMap_surjective_of_isIntegral k K _ _ _ _ f.toAlgebra"
Mathlib/RingTheory/FinitePresentation.lean,RingHom.FinitePresentation.of_comp_finiteType,of_comp_finiteType,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":=
  letI ins1 := RingHom.toSMul f
  letI ins1 := RingHom.toAlgebra f
  letI ins2 := RingHom.toSMul g
  letI ins2 := RingHom.toAlgebra g
  letI ins3 := RingHom.toSMul (g.comp f)
  letI ins3 := RingHom.toAlgebra (g.comp f)
  letI ins4 : IsScalarTower A B C :=
    { smul_assoc := fun a b c => by simp [Algebra.smul_def, mul_assoc]; rfl }
  letI : Algebra.FinitePresentation A C := hg
  letI : Algebra.FiniteType A B := hf
  Algebra.FinitePresentation.of_restrict_scalars_finitePresentation A B C","error:  unknown constant 'RingHom.toSMul'
error:  unknown constant 'RingHom.toSMul'
error:  unknown constant 'RingHom.toSMul'","theorem of_comp_finiteType (f : A ‚Üí+* B) {g : B ‚Üí+* C} (hg : (g.comp f).FinitePresentation)
    (hf : f.FiniteType) : g.FinitePresentation ",":=
  letI ins1 := RingHom.toAlgebra f
  letI ins2 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra (g.comp f)
  letI ins4 : IsScalarTower A B C :=
    { smul_assoc := fun a b c => by simp [Algebra.smul_def, mul_assoc]; rfl }
  letI : Algebra.FinitePresentation A C := hg
  letI : Algebra.FiniteType A B := hf
  Algebra.FinitePresentation.of_restrict_scalars_finitePresentation A B C",":=
  letI ins1 := RingHom.toAlgebra f
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  letI ins3 := RingHom.toAlgebra g
  "
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,229bb6cbcc9a67aabf677431de0faf2f1866dbf7,":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x)
  ¬∑ simp_rw [inversion, dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π
    ¬∑ rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    dsimp
    simp only [add_sub_cancel', ContinuousLinearMap.comp_id, neg_smul, smul_neg,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, eqOn_singleton,
      ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, id_eq, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      two_mul, smul_add, Pi.add_apply, neg_add_rev, add_smul,
      reflection_orthogonalComplement_singleton_eq_neg]
    rw [Pi.smul_apply, Pi.smul_apply, real_inner_self_eq_norm_sq]
    simp only [smul_eq_mul, this, add_neg_cancel_comm_assoc]
  ¬∑ simp only [id_eq, Function.comp_apply, add_sub_cancel', ContinuousLinearMap.comp_id,
      neg_smul, smul_neg, ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, ContinuousLinearEquiv.coe_coe,
      LinearIsometryEquiv.coe_coe, reflection_mem_subspace_eq_self hy, add_right_eq_self,
      neg_eq_zero, smul_eq_zero]
    rw [Pi.smul_apply, Pi.smul_apply]
    simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  unexpected token '¬∑'; expected '|'
error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ F ‚ÜíL[‚Ñù] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x ‚Ü¶ c + x) x) c) ^ 2 ‚Ä¢
      ‚Üë{ toLinearEquiv := (reflection (Submodule.span ‚Ñù {(fun x ‚Ü¶ c + x) x - c})·óÆ).toLinearEquiv, continuous_toFun := ‚ãØ,
          continuous_invFun := ‚ãØ })
    ((fun x ‚Ü¶ c + x) x)","theorem hasFDerivAt_inversion (hx : x ‚â† c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 ‚Ä¢ (reflection (‚Ñù ‚àô (x - c))·óÆ : F ‚ÜíL[‚Ñù] F)) x ",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (?_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x)
  ¬∑ simp_rw [inversion, dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π
    ¬∑ rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    dsimp
    simp only [add_sub_cancel', ContinuousLinearMap.comp_id, neg_smul, smul_neg,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, eqOn_singleton,
      ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, eqOn_singleton,
      ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, eqOn_singleton,
      ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, ContinuousLinearEquiv.coe_coe,
      LinearIsometryEquiv.coe_coe, reflection_mem_subspace_eq_self hy, add_right_eq_self,
      neg_eq_zero, smul_eq_zero]
    rw [Pi.smul_apply, Pi.smul_apply]
    simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow, inv_pow, ContinuousLinearEquiv.coe_coe,
      LinearIsometryEquiv.coe_coe, reflection_mem_subspace_eq_self hy, add_right_eq_self,
      neg_eq_zero, smul_eq_zero]
    rw [Pi.smul_apply, Pi.smul_apply]
    simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow,"
Mathlib/LinearAlgebra/Orientation.lean,Orientation.map_eq_neg_iff_det_neg,map_eq_neg_iff_det_neg,4ca3fa726f03959fa78d58075168b2b4d6fbee93,":= by
  cases isEmpty_or_nonempty Œπ
  ¬∑ have H : finrank R M = 0 := by
      refine' h.symm.trans _
      convert @Fintype.card_of_isEmpty Œπ _
    simp [LinearMap.det_eq_one_of_finrank_eq_zero H, Module.Ray.ne_neg_self x]
  have H : 0 < finrank R M := by
    rw [‚Üê h]
    exact Fintype.card_pos
  haveI : FiniteDimensional R M := finiteDimensional_of_finrank H
  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, LinearEquiv.coe_det]","error:  unsolved goals
case a
R : Type u_1
inst‚úù¬≥ : LinearOrderedField R
M : Type u_2
inst‚úù¬≤ : AddCommGroup M
inst‚úù¬π : Module R M
Œπ : Type u_3
inst‚úù : Fintype Œπ
_i : FiniteDimensional R M
x : Orientation R M Œπ
f : M ‚âÉ‚Çó[R] M
h : Fintype.card Œπ = finrank R M
h‚úù : IsEmpty Œπ
‚ä¢ Fintype.card Œπ = 0 ‚Üî ‚àÄ [inst : IsEmpty Œπ], Fintype.card Œπ = 0
error:  unknown identifier 'finiteDimensional_of_finrank'","theorem map_eq_neg_iff_det_neg (x : Orientation R M Œπ) (f : M ‚âÉ‚Çó[R] M)
    (h : Fintype.card Œπ = finrank R M) :
    Orientation.map Œπ f x = -x ‚Üî LinearMap.det (f : M ‚Üí‚Çó[R] M) < 0 ",":= by
  cases isEmpty_or_nonempty Œπ
  ¬∑ have H : finrank R M = 0 := h.symm.trans Fintype.card_eq_zero
    simp [LinearMap.det_eq_one_of_finrank_eq_zero H, Module.Ray.ne_neg_self x]
  have H : 0 < finrank R M := by
    rw [‚Üê h]
    exact Fintype.card_pos
  haveI : FiniteDimensional R M := of_finrank_pos H
  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, LinearEquiv.coe_det]",":= by
  cases isEmpty_or_nonempty Œπ
  ¬∑ have H : finrank R M = 0 := by
      refine h.symm.trans ?_
      convert @Fintype.card_of_isEmpty Œπ _
    simp [LinearMap.det_eq_one_of_finrank_eq_zero H, Module.Ray.ne_neg_self x]
  have H : 0 < finrank R M := by
    rw [‚Üê h]
    exact Fintype.card_pos
  haveI : FiniteDimensional R M := finiteDimensional_of_finrank H
  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, LinearEquiv.coe_det]"
Mathlib/Data/NNRat/Lemmas.lean,NNRat.num_div_den,num_div_den,b31c5abb977bb83fb147c55d651e6e80b17d2171,":= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, ‚Üê Int.cast_ofNat,
    Int.natAbs_of_nonneg (Rat.num_nonneg.2 q.prop)]
  exact Rat.num_div_den q","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  OfNat.ofNat ?n
case a
p q‚úù q : ‚Ñö‚â•0
‚ä¢ ‚Üë(‚Üëq).num.natAbs / ‚Üëq.den = ‚Üëq",lemma num_div_den (q : ‚Ñö‚â•0) : (q.num : ‚Ñö‚â•0) / q.den = q ,":= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, ‚Üê Int.cast_natCast,
    Int.natAbs_of_nonneg (Rat.num_nonneg.2 q.cast_nonneg)]
  exact Rat.num_div_den q",":= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, ‚Üê Int.cast_ofNat,
    Int.natAbs_of_nonneg (Rat.num_nonneg.2 q.prop)]"
Mathlib/Probability/Independence/Kernel.lean,ProbabilityTheory.kernel.IndepSets.union_iff,IndepSets.union_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  ‚ü®fun h =>
    ‚ü®indepSets_of_indepSets_of_le_left h (Set.subset_union_left s‚ÇÅ s‚ÇÇ),
      indepSets_of_indepSets_of_le_left h (Set.subset_union_right s‚ÇÅ s‚ÇÇ)‚ü©,
    fun h => IndepSets.union h.left h.right‚ü©","error:  application type mismatch
  Set.subset_union_left s‚ÇÅ
argument
  s‚ÇÅ
has type
  Set (Set Œ©) : Type u_2
but is expected to have type
  ?m.28146 ‚àà ?m.28144 : Prop
error:  application type mismatch
  Set.subset_union_right s‚ÇÅ
argument
  s‚ÇÅ
has type
  Set (Set Œ©) : Type u_2
but is expected to have type
  ?m.28617 ‚àà ?m.28616 : Prop","theorem IndepSets.union_iff {s‚ÇÅ s‚ÇÇ s' : Set (Set Œ©)} {_mŒ© : MeasurableSpace Œ©}
    {Œ∫ : kernel Œ± Œ©} {Œº : Measure Œ±} :
    IndepSets (s‚ÇÅ ‚à™ s‚ÇÇ) s' Œ∫ Œº ‚Üî IndepSets s‚ÇÅ s' Œ∫ Œº ‚àß IndepSets s‚ÇÇ s' Œ∫ Œº ",":=
  ‚ü®fun h =>
    ‚ü®indepSets_of_indepSets_of_le_left h Set.subset_union_left,
      indepSets_of_indepSets_of_le_left h Set.subset_union_right‚ü©,
    fun h => IndepSets.union h.left h.right‚ü©",":=
  ‚ü®fun h =>
    ‚ü®indepSets_of_indepSets_of_le_left h Set.subset_union_left,
      indepSets_of_indepSets_of_le_left h Set.subset_union_right‚ü©,
    fun h => IndepSets.union h.left h.right‚ü©"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpi_tfae,effectiveEpi_tfae,58de6a1c33e964db25c184d0d1809e6b5b414b50,":= by
  tfae_have : 1 ‚Üí 2
  | _ => inferInstance
  tfae_have : 2 ‚Üî 3 := epi_iff_surjective œÄ
  tfae_have : 3 ‚Üí 1 := fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (œÄ : X ‚ü∂ B) :
    TFAE
    [ EffectiveEpi œÄ
    , Epi œÄ
    , Function.Surjective œÄ
    ] ",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",":= by
  tfae_have 1 ‚Üí 2
  | _ => inferInstance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish"
Mathlib/Order/OrderIsoNat.lean,RelEmbedding.acc_iff_no_decreasing_seq,acc_iff_no_decreasing_seq,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  constructor
  ¬∑ refine' fun h => h.recOn fun x _ IH => _
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    obtain ‚ü®f, h‚ü© := Classical.axiom_of_choice this
    refine' fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGt (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => _, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h","error:  unknown identifier 'lt_add_one'
error:  unknown identifier 'Classical.axiom_of_choice'
error:  rcases tactic failed: x‚úù : ?m.2248 is not an inductive datatype","theorem acc_iff_no_decreasing_seq {x} :
    Acc r x ‚Üî IsEmpty { f : ((¬∑ > ¬∑) : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop) ‚Ü™r r // x ‚àà Set.range f } ",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (Nat.lt_succ_self _))) ‚ü®f, _, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    choose f h using this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGT (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h",":= by
  constructor
  ¬∑ refine fun h => h.recOn fun x _ IH => ?_
    constructor
    rintro ‚ü®f, k, hf‚ü©
    exact IsEmpty.elim' (IH (f (k + 1)) (hf ‚ñ∏ f.map_rel_iff.2 (lt_add_one k))) ‚ü®f, ?_, rfl‚ü©
  ¬∑ have : ‚àÄ x : { a // ¬¨Acc r a }, ‚àÉ y : { a // ¬¨Acc r a }, r y.1 x.1 := by
      rintro ‚ü®x, hx‚ü©
      cases exists_not_acc_lt_of_not_acc hx with
      | intro w h => exact ‚ü®‚ü®w, h.1‚ü©, h.2‚ü©
    obtain ‚ü®f, h‚ü© := Classical.axiom_of_choice this
    refine fun E =>
      by_contradiction fun hx => E.elim' ‚ü®natGt (fun n => (f^[n] ‚ü®x, hx‚ü©).1) fun n => ?_, 0, rfl‚ü©
    simp only [Function.iterate_succ']
    apply h"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.mul_measure_le_of_subset_lt_limRatioMeas,mul_measure_le_of_subset_lt_limRatioMeas,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº t·∂ú = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t);
  exact
    calc
      (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
      _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := (measure_union_le _ _)
      _ ‚â§ œÅ (s ‚à© t) + q * Œº t·∂ú := by
        apply add_le_add H
        rw [coe_nnreal_smul_apply]
        exact mul_le_mul_left' (measure_mono (inter_subset_right _ _)) _
      _ ‚â§ œÅ s := by
        rw [A, mul_zero, add_zero]; exact measure_mono (inter_subset_left _ _)
  refine' v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ _
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le",error:  unexpected token ';'; expected 'by' or 'from',"theorem mul_measure_le_of_subset_lt_limRatioMeas {q : ‚Ñù‚â•0} {s : Set Œ±}
    (h : s ‚äÜ {x | (q : ‚Ñù‚â•0‚àû) < v.limRatioMeas hœÅ x}) : (q : ‚Ñù‚â•0‚àû) * Œº s ‚â§ œÅ s ",":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº t·∂ú = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t) by calc
    (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
    _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := measure_union_le _ _
    _ ‚â§ œÅ (s ‚à© t) + (q ‚Ä¢ Œº) t·∂ú := by gcongr; apply inter_subset_right
    _ = œÅ (s ‚à© t) := by simp [A]
    _ ‚â§ œÅ s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ ?_
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le",":= by
  let t := {x : Œ± | Tendsto (fun a => œÅ a / Œº a) (v.filterAt x) (ùìù (v.limRatioMeas hœÅ x))}
  have A : Œº t·∂ú = 0 := v.ae_tendsto_limRatioMeas hœÅ
  suffices H : (q ‚Ä¢ Œº) (s ‚à© t) ‚â§ œÅ (s ‚à© t) by
    calc
      (q ‚Ä¢ Œº) s = (q ‚Ä¢ Œº) (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [inter_union_compl]
      _ ‚â§ (q ‚Ä¢ Œº) (s ‚à© t) + (q ‚Ä¢ Œº) (s ‚à© t·∂ú) := measure_union_le _ _
      _ ‚â§ œÅ (s ‚à© t) + q * Œº t·∂ú := by
        apply add_le_add H
        rw [coe_nnreal_smul_apply]
        exact mul_le_mul_left' (measure_mono inter_subset_right) _
      _ ‚â§ œÅ s := by
        rw [A, mul_zero, add_zero]; exact measure_mono inter_subset_left
  refine v.measure_le_of_frequently_le ?_ (AbsolutelyContinuous.rfl.smul _) ?_ ?_
  intro x hx
  have I : ‚àÄ·∂† a in v.filterAt x, (q : ‚Ñù‚â•0‚àû) < œÅ a / Œº a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le"
Mathlib/Order/Partition/Finpartition.lean,Finpartition.parts_eq_empty_iff,parts_eq_empty_iff,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  simp_rw [‚Üê P.sup_parts]
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ eq_empty_iff_forall_not_mem.2 fun b hb ‚Ü¶ P.not_bot_mem? _‚ü©
  ¬∑ rw [h]
    exact Finset.sup_empty
  ¬∑ rwa [‚Üê le_bot_iff.1 ((le_sup hb).trans h.le)]","error:  invalid field 'not_bot_mem?', the environment does not contain 'Finpartition.not_bot_mem?'
  P
has type
  Finpartition a
error:  no goals to be solved",theorem parts_eq_empty_iff : P.parts = ‚àÖ ‚Üî a = ‚ä• ,":= by
  simp_rw [‚Üê P.sup_parts]
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ eq_empty_iff_forall_not_mem.2 fun b hb ‚Ü¶ P.not_bot_mem ?_‚ü©
  ¬∑ rw [h]
    exact Finset.sup_empty
  ¬∑ rwa [‚Üê le_bot_iff.1 ((le_sup hb).trans h.le)]",":= by
  simp_rw [‚Üê P.sup_parts]
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ eq_empty_iff_forall_not_mem.2 fun b hb ‚Ü¶ P.not_bot_mem? ?_‚ü©
  ¬∑ rw [h]
    exact Finset.sup_empty
  ¬∑ rwa [‚Üê le_bot_iff.1 ((le_sup hb).trans h.le)]"
Mathlib/Algebra/BigOperators/Ring/Multiset.lean,Multiset.prod_map_add,prod_map_add,2ba547a6481ef513d87a606a16c441262be9e648,":= by
  refine s.induction_on ?_ fun a s ih ‚Ü¶ ?_
  ¬∑ simp only [map_zero, prod_zero, antidiagonal_zero, map_singleton, mul_one, sum_singleton]
  ¬∑ simp only [map_cons, prod_cons, ih, sum_map_mul_left.symm, add_mul, mul_left_comm (f a),
      mul_left_comm (g a), sum_map_add, antidiagonal_cons, Prod.map_apply, id_eq, map_add, map_map,
      Function.comp_apply, mul_assoc, sum_add]
    exact add_comm _ _","error:  typeclass instance problem is stuck, it is often due to metavariables
  AddCommMagma ?m.13262","lemma prod_map_add {s : Multiset Œπ} {f g : Œπ ‚Üí Œ±} :
    prod (s.map fun i ‚Ü¶ f i + g i) =
      sum ((antidiagonal s).map fun p ‚Ü¶ (p.1.map f).prod * (p.2.map g).prod) ",":= by
  refine s.induction_on ?_ fun a s ih ‚Ü¶ ?_
  ¬∑ simp only [map_zero, prod_zero, antidiagonal_zero, map_singleton, mul_one, sum_singleton]
  ¬∑ simp only [map_cons, prod_cons, ih, sum_map_mul_left.symm, add_mul, mul_left_comm (f a),
      mul_left_comm (g a), sum_map_add, antidiagonal_cons, Prod.map_fst, Prod.map_snd,
      id_eq, map_add, map_map, Function.comp_apply, mul_assoc, sum_add]
    exact add_comm _ _",":= by
  refine s.induction_on ?_ fun a s ih ‚Ü¶ ?_
  ¬∑ simp only [map_zero, prod_zero, antidiagonal_zero, map_singleton, mul_one, sum_singleton]
  ¬∑ simp only [map_cons, prod_cons, ih, sum_map_mul_left.symm, add_mul, mul_left_comm (f a),
      mul_left_comm (g a), sum_map_add, antidiagonal_cons, Prod.map_apply, id_eq, map_add,
      Function.comp_apply, mul_assoc, sum_add]
    exact add_comm _ _"
Mathlib/NumberTheory/DiophantineApproximation.lean,Real.exists_rat_eq_convergent',exists_rat_eq_convergent',61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    rcases le_or_lt (u : ‚Ñù) Œæ with ht | ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      rcases eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ | HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine' ‚ü®(fract_lt_one Œæ).le, _‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_ofNat, inv_div, sub_div, mul_div_cancel_right‚ÇÄ _ Hv, add_sub_cancel]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë(OfNat.ofNat ?n)
case h
v‚úù : ‚Ñ§
hv : 2 ‚â§ v‚úù
v : ‚Ñï
ih : ‚àÄ m < v, ‚àÄ {Œæ : ‚Ñù} {u : ‚Ñ§}, ContfracLegendre.Ass Œæ u ‚Üëm ‚Üí ‚àÉ n, ‚Üëu / ‚Üëm = Œæ.convergent n
Œæ : ‚Ñù
u : ‚Ñ§
h : ContfracLegendre.Ass Œæ u ‚Üëv
ht : 1 < v
huv‚ÇÄ : 0 < u - ‚åäŒæ‚åã * ‚Üëv
huv‚ÇÅ : u - ‚åäŒæ‚åã * ‚Üëv < ‚Üëv
Hv : ‚Üëv ‚â† 0
huv‚ÇÅ' : (u - ‚åäŒæ‚åã * ‚Üëv).toNat < v
inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π ‚Üëv ‚Üë(u - ‚åäŒæ‚åã * ‚Üëv).toNat
n : ‚Ñï
hn : ‚Üë‚Üëv / ‚Üë(u - ‚åäŒæ‚åã * ‚Üëv).toNat = (fract Œæ)‚Åª¬π.convergent n
‚ä¢ ‚Üëu / ‚Üëv = ‚Üë‚åäŒæ‚åã + (‚Üë‚Üëv / (‚Üëu - ‚Üë‚åäŒæ‚åã * ‚Üëv))‚Åª¬π","theorem exists_rat_eq_convergent' {v : ‚Ñï} (h' : ContfracLegendre.Ass Œæ u v) :
    ‚àÉ n, (u / v : ‚Ñö) = Œæ.convergent n ",":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    rcases le_or_lt (u : ‚Ñù) Œæ with ht | ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      rcases eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ | HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine ‚ü®(fract_lt_one Œæ).le, ?_‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_natCast, inv_div, sub_div, mul_div_cancel_right‚ÇÄ _ Hv, add_sub_cancel]",":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    rcases le_or_lt (u : ‚Ñù) Œæ with ht | ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      rcases eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ | HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine ‚ü®(fract_lt_one Œæ).le, ?_‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_ofNat, inv_div, sub_div, mul_div_cancel_right‚ÇÄ _ Hv, add_sub_cancel]"
Mathlib/RingTheory/UniqueFactorizationDomain.lean,UniqueFactorizationMonoid.count_normalizedFactors_eq',count_normalizedFactors_eq',8e31b5ac6bed8ba535a30f3442252684d2f151c1,":= by
  rcases hp with (rfl | hp)
  ¬∑ cases n
    ¬∑ exact count_eq_zero.2 (zero_not_mem_normalizedFactors _)
    ¬∑ rw [zero_pow (Nat.succ_pos _)] at hle hlt
      exact absurd hle hlt
  ¬∑ exact count_normalizedFactors_eq hp hnorm hle hlt","error:  application type mismatch
  zero_pow (Nat.succ_pos ?m.249581)
argument
  Nat.succ_pos ?m.249581
has type
  0 < ?m.249581.succ : Prop
but is expected to have type
  ?m.249580 ‚â† 0 : Prop
error:  application type mismatch
  zero_pow (Nat.succ_pos ?m.250347)
argument
  Nat.succ_pos ?m.250347
has type
  0 < ?m.250347.succ : Prop
but is expected to have type
  ?m.250346 ‚â† 0 : Prop","theorem count_normalizedFactors_eq' [DecidableEq R] {p x : R} (hp : p = 0 ‚à® Irreducible p)
    (hnorm : normalize p = p) {n : ‚Ñï} (hle : p ^ n ‚à£ x) (hlt : ¬¨p ^ (n + 1) ‚à£ x) :
    (normalizedFactors x).count p = n ",":= by
  rcases hp with (rfl | hp)
  ¬∑ cases n
    ¬∑ exact count_eq_zero.2 (zero_not_mem_normalizedFactors _)
    ¬∑ rw [zero_pow (Nat.succ_ne_zero _)] at hle hlt
      exact absurd hle hlt
  ¬∑ exact count_normalizedFactors_eq hp hnorm hle hlt",":= by
  rcases hp with (rfl | hp)
  ¬∑ cases n
    ¬∑ exact count_eq_zero.2 (zero_not_mem_normalizedFactors _)
    ¬∑ rw [zero_pow (Nat.succ_pos _)] at hle hlt
      exact absurd hle hlt
  ¬∑ exact count_normalizedFactors_eq hp hnorm hle hlt"
Mathlib/NumberTheory/Modular.lean,ModularGroup.tendsto_normSq_coprime_pair,tendsto_normSq_coprime_pair,cd6dd35c5cd5a80c46968d6ca29289986aa4e924,":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, ofReal_mul_im, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, MulZeroClass.mul_zero]
  have hf' : ClosedEmbedding f := by
    have := @LinearEquiv.closedEmbedding_of_injective ‚Ñù _ (Fin 2 ‚Üí ‚Ñù) _ _ ‚ÑÇ _ _ _ f
    exact this hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * 1
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
x‚úù : Fin 2 ‚Üí ‚Ñù
‚ä¢ f x‚úù = ‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)
error:  unknown identifier 'ofReal_int_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.22014
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
f_def : ‚áëf = fun p ‚Ü¶ ‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)
x‚úù : Fin 2 ‚Üí ‚Ñ§
‚ä¢ normSq (‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)) = normSq (‚Üë‚Üë(x‚úù 0) * ‚Üëz + ‚Üë‚Üë(x‚úù 1))
error:  unknown identifier 'ofReal_mul_im'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.33650
case h.h.head
g‚úù : SL(2, ‚Ñ§)
z : ‚Ñç
this‚úù : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
f_def : ‚áëf = fun p ‚Ü¶ ‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)
this : (fun p ‚Ü¶ normSq (‚Üë(p 0) * ‚Üëz + ‚Üë(p 1))) = ‚áënormSq ‚àò ‚áëf ‚àò fun p ‚Ü¶ Int.cast ‚àò p
g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù := LinearMap.pi ![imLm, imLm ‚àò‚Çó (‚Üëz ‚Ä¢ (‚Üë‚ÜëconjAe).toLinearMap)]
c : Fin 2 ‚Üí ‚Ñù
hz : (‚Üëz).im ‚â† 0
‚ä¢ (‚Üëz).im‚Åª¬π * ((‚Üë(c 0) * ‚Üëz).im + (‚Üë(c 1)).im) = c 0
error:  invalid use of field notation with `@` modifier
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem tendsto_normSq_coprime_pair :
    Filter.Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * z + p 1)) cofinite atTop ",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_intCast, ofReal_intCast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, ofReal_mul_im, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, MulZeroClass.mul_zero]
  have hf' : ClosedEmbedding f := by
    have := @LinearEquiv.closedEmbedding_of_injective ‚Ñù _ (Fin 2 ‚Üí ‚Ñù) _ _ ‚ÑÇ _ _ _ f
    exact this hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)"
Mathlib/Topology/Order/LocalExtr.lean,IsLocalExtrOn.inter,IsLocalExtrOn.inter,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  hf.on_subset (inter_subset_left s t)","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set Œ± : Type u
but is expected to have type
  ?m.3021 ‚àà ?m.3019 ‚à© ?m.3020 : Prop",theorem IsLocalExtrOn.inter (hf : IsLocalExtrOn f s a) (t) : IsLocalExtrOn f (s ‚à© t) a ,":=
  hf.on_subset inter_subset_left",":=
  inter_subset_left"
Mathlib/Geometry/Manifold/IntegralCurve.lean,IsIntegralCurve.isIntegralCurveAt,IsIntegralCurve.isIntegralCurveAt,fa459a52b70eb1e82d98d32addd467b39f69d576,":= ‚ü®univ, Filter.univ_mem, fun t _ => h t‚ü©","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  (ùìù t).1 {x | (fun t ‚Ü¶ HasMFDerivAt ùìò(‚Ñù, ‚Ñù) I Œ≥ t (ContinuousLinearMap.smulRight 1 (v (Œ≥ t)))) x}","lemma IsIntegralCurve.isIntegralCurveAt (h : IsIntegralCurve Œ≥ v) (t : ‚Ñù) :
    IsIntegralCurveAt Œ≥ v t ",":= isIntegralCurveAt_iff.mpr ‚ü®univ, Filter.univ_mem, fun t _ ‚Ü¶ h t‚ü©",":= ‚ü®univ, Filter.univ_mem‚ü©"
Mathlib/Analysis/SpecialFunctions/Log/NegMulLog.lean,Real.strictConvexOn_mul_log,strictConvexOn_mul_log,d2663c979dadc71a9495d0a9a161c7576a9cd988,":= by
  refine strictConvexOn_of_deriv2_pos (convex_Ici 0) (continuous_mul_log.continuousOn) ?_
  intro x hx
  simp only [Set.nonempty_Iio, interior_Ici', Set.mem_Ioi] at hx
  rw [deriv2_mul_log]
  positivity","error:  unsolved goals
x : ‚Ñù
hx : 0 < x
‚ä¢ x ‚â† 0",lemma strictConvexOn_mul_log : StrictConvexOn ‚Ñù (Set.Ici (0 : ‚Ñù)) (fun x ‚Ü¶ x * log x) ,":= by
  refine strictConvexOn_of_deriv2_pos (convex_Ici 0) (continuous_mul_log.continuousOn) ?_
  intro x hx
  simp only [Set.nonempty_Iio, interior_Ici', Set.mem_Ioi] at hx
  rw [deriv2_mul_log hx.ne']
  positivity",":= by
  refine strictConvexOn_of_deriv2_pos (convex_Ici 0) (continuous_mul_log.continuousOn) ?_
  intro x hx
  simp only [Set.nonempty_Iio, interior_Ici, Set.mem_Ioi] at hx
  rw [deriv2_mul_log]
  positivity"
Mathlib/FieldTheory/PrimitiveElement.lean,AlgHom.card_of_splits,AlgHom.card_of_splits,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [‚Üê Fintype.ofEquiv_card <| Algebra.IsAlgebraic.algHomEquivAlgHomOfSplits
    (AlgebraicClosure L) (Algebra.IsAlgebraic.of_finite F E) _ hL]
  convert AlgHom.card F E (AlgebraicClosure L)","error:  application type mismatch
  @Algebra.IsAlgebraic.algHomEquivAlgHomOfSplits ?m.101214 ?m.101215 (AlgebraicClosure L) ?m.101220 ?m.101221 ?m.101222
    ?m.101223 ?m.101224 ?m.101225 ‚ãØ
argument
  Algebra.IsAlgebraic.of_finite F E
has type
  Algebra.IsAlgebraic F E : Prop
but is expected to have type
  Type ?u.101210 : Type (?u.101210 + 1)","theorem AlgHom.card_of_splits (L : Type*) [Field L] [Algebra F L]
    (hL : ‚àÄ x : E, (minpoly F x).Splits (algebraMap F L)) :
    Fintype.card (E ‚Üí‚Çê[F] L) = finrank F E ",":= by
  rw [‚Üê Fintype.ofEquiv_card <| Algebra.IsAlgebraic.algHomEquivAlgHomOfSplits
    (AlgebraicClosure L) _ hL]
  convert AlgHom.card F E (AlgebraicClosure L)",":= by
  rw [‚Üê Fintype.ofEquiv_card <| Algebra.IsAlgebraic.algHomEquivAlgHomOfSplits
    (AlgebraicClosure L) (Algebra.IsAlgebraic.of_finite F E) _ hL]
  convert AlgHom.card F E (AlgebraicClosure L)"
Mathlib/LinearAlgebra/BilinearForm/Properties.lean,LinearMap.BilinForm.dualBasis_dualBasis,dualBasis_dualBasis,51ffdfe2da83e6545c31746684ae84a78c088bf8,":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ‚Ü¶ ?_))
  rw [toLin_apply, apply_dualBasis_left, toLin_apply, ‚Üê B.flip_apply,
    apply_dualBasis_left]
  simp_rw [@eq_comm _ i j]","error:  unknown identifier 'toLin_apply'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.470137
case a
R : Type u_1
M : Type u_2
inst‚úù¬π‚Åπ : CommSemiring R
inst‚úù¬π‚Å∏ : AddCommMonoid M
inst‚úù¬π‚Å∑ : Module R M
R‚ÇÅ : Type u_3
M‚ÇÅ : Type u_4
inst‚úù¬π‚Å∂ : CommRing R‚ÇÅ
inst‚úù¬π‚Åµ : AddCommGroup M‚ÇÅ
inst‚úù¬π‚Å¥ : Module R‚ÇÅ M‚ÇÅ
V : Type u_5
K : Type u_6
inst‚úù¬π¬≥ : Field K
inst‚úù¬π¬≤ : AddCommGroup V
inst‚úù¬π¬π : Module K V
M'‚úù : Type u_7
M'' : Type u_8
inst‚úù¬π‚Å∞ : AddCommMonoid M'‚úù
inst‚úù‚Åπ : AddCommMonoid M''
inst‚úù‚Å∏ : Module R M'‚úù
inst‚úù‚Å∑ : Module R M''
B‚úù : BilinForm R M
B‚ÇÅ : BilinForm R‚ÇÅ M‚ÇÅ
M' : Type u_9
inst‚úù‚Å∂ : AddCommMonoid M'
inst‚úù‚Åµ : Module R M'
inst‚úù‚Å¥ : FiniteDimensional K V
Œπ‚úù : Type u_10
inst‚úù¬≥ : DecidableEq Œπ‚úù
inst‚úù¬≤ : Finite Œπ‚úù
B : BilinForm K V
hB : B.Nondegenerate
Œπ : Type u_11
inst‚úù¬π : Finite Œπ
inst‚úù : DecidableEq Œπ
b : Basis Œπ K V
i j : Œπ
‚ä¢ (B ((B.dualBasis hB (B.flip.dualBasis ‚ãØ b)) i)) ((B.flip.dualBasis ‚ãØ b) j) = (B (b i)) ((B.flip.dualBasis ‚ãØ b) j)","lemma dualBasis_dualBasis_flip (B : BilinForm K V) (hB : B.Nondegenerate) {Œπ}
    [Finite Œπ] [DecidableEq Œπ] (b : Basis Œπ K V) :
    B.dualBasis hB (B.flip.dualBasis hB.flip b) = b ",":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ‚Ü¶ ?_))
  simp_rw [apply_dualBasis_left, ‚Üê B.flip_apply, apply_dualBasis_left, @eq_comm _ i j]",":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ‚Ü¶ ?_))
  rw [toLin_apply, apply_dualBasis_left, toLin_apply, ‚Üê B.flip_apply,
    apply_dualBasis_left]
  simp_rw [@eq_comm _ i j]"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.le_mul_withDensity,le_mul_withDensity,611a64b31f2f9df551954217d12578133430d2b6,":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne.def] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine' le_trans (measure_mono (inter_subset_right _ _)) (le_trans (le_of_eq _) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono (inter_subset_right _ _)).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ŒΩ, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
          ‚àë' n : ‚Ñ§, (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = (t ‚Ä¢ ŒΩ) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t ‚Ä¢ ŒΩ) f_meas hs ht).symm","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.231051 ‚Üí ?m.231051 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  t ‚â† 0 : Prop
but is expected to have type
  ‚Üët ‚â† 0 : Prop
error:  function expected at
  inter_subset_right ?m.233027
term has type
  ?m.233026 ‚àà ?m.233025
error:  type mismatch
  measure_limRatioMeas_zero v hœÅ
has type
  œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 : Prop
but is expected to have type
  Set Œ± : Type u_1
error:  function expected at
  inter_subset_right ?m.235312
term has type
  ?m.235311 ‚àà ?m.235310","theorem le_mul_withDensity {s : Set Œ±} (hs : MeasurableSet s) {t : ‚Ñù‚â•0} (ht : 1 < t) :
    œÅ s ‚â§ t * Œº.withDensity (v.limRatioMeas hœÅ) s ",":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ŒΩ, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
          ‚àë' n : ‚Ñ§, (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = (t ‚Ä¢ ŒΩ) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t ‚Ä¢ ŒΩ) f_meas hs ht).symm",":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ŒΩ, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {0}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ "
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.evaln_prim,evaln_prim,20100f1475ea197bf6dea643b6ee137219455a51,":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp [Nat.lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.get?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        cases evaln k cg n <;> rfl
      ¬∑ cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      ¬∑ cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        ¬∑ rfl
        simp
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      ¬∑ have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to‚ÇÇ).of_eq
    fun ‚ü®‚ü®k, c‚ü©, n‚ü© => by simp [evaln_map]","warning:  `List.map_congr` has been deprecated, use `List.map_congr_left` instead
warning:  `List.get?_range` has been deprecated, use `List.getElem?_range` instead
error:  unsolved goals
x‚úù : Unit
p n : ‚Ñï
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
c : Code
k' : ‚Ñï
k : ‚Ñï := k' + 1
nk : n ‚â§ k'
k‚ÇÅ : ‚Ñï
c‚ÇÅ : Code
n‚ÇÅ : ‚Ñï
hl : Nat.pair k‚ÇÅ (encode c‚ÇÅ) < Nat.pair k (encode c)
‚ä¢ ((Option.map (fun n ‚Ü¶ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
          (List.range (Nat.pair k (encode c)))[Nat.pair k‚ÇÅ (encode c‚ÇÅ)]?).bind
      fun a ‚Ü¶ a[n‚ÇÅ]?.bind fun a ‚Ü¶ a) =
    evaln k‚ÇÅ c‚ÇÅ n‚ÇÅ",theorem evaln_prim : Primrec fun a : (‚Ñï √ó Code) √ó ‚Ñï => evaln a.1.1 a.1.2 a.2 ,":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr_left fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.getElem?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        cases evaln k cg n <;> rfl
      ¬∑ cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      ¬∑ cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      ¬∑ have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to‚ÇÇ).of_eq
    fun ‚ü®‚ü®k, c‚ü©, n‚ü© => by simp [evaln_map]",":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp [Nat.lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
           evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.get?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp
        cases x <;> simp [Nat.succ_ne_zero]
      "
Mathlib/RingTheory/Valuation/Basic.lean,AddValuation.ext_iff,ext_iff,ae8b24f33174f0b9fcd8f2d87ba6c65a18ae9ceb,":=
  FunLike.ext_iff",error:  unknown constant 'FunLike.ext_iff',"theorem ext_iff {v‚ÇÅ v‚ÇÇ : Valuation R Œì‚ÇÄ} : v‚ÇÅ = v‚ÇÇ ‚Üî ‚àÄ r, v‚ÇÅ r = v‚ÇÇ r ",":=
  DFunLike.ext_iff",":=
  FunLike.ext_iff"
Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean,CategoryTheory.InjectiveResolution.desc_commutes,desc_commutes,f4520b46927a9e004dd0b17a599b790975d65150,":= by
  ext n
  rcases n with (_ | _ | n) <;>
    ¬∑ dsimp [desc, descFOne, descFZero]
      simp","warning:  `ext` did not consume the patterns: [n]
note: this linter can be disabled with `set_option linter.unusedRCasesPattern false`
error:  unknown identifier 'n'
error:  rcases tactic failed: x‚úù : ?m.10147 is not an inductive datatype","theorem desc_commutes {Y Z : C} (f : Z ‚ü∂ Y) (I : InjectiveResolution Y)
    (J : InjectiveResolution Z) : J.Œπ ‚â´ desc f I J = (CochainComplex.single‚ÇÄ C).map f ‚â´ I.Œπ ",":= by
  ext
  simp [desc, descFOne, descFZero]",":= by
  ext n
  rcases n with (_ | _ | n) <;>
    ¬∑ dsimp [descFOne, descFZero]
      simp"
Mathlib/Analysis/InnerProductSpace/Projection.lean,norm_eq_iInf_iff_real_inner_le_zero,norm_eq_iInf_iff_real_inner_le_zero,4449fea6cb71b0c9863e5f2aaa338fd940fe3afa,":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel'_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v))
      ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            refine' this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num)
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine' le_add_of_nonneg_right _
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _","error:  unexpected identifier; expected '|'
error:  unsolved goals
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Å¥ : _root_.RCLike ùïú
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedAddCommGroup F
inst‚úù¬π : InnerProductSpace ùïú E
inst‚úù : InnerProductSpace ‚Ñù F
K : Set F
h : Convex ‚Ñù K
u v : F
hv : v ‚àà K
this‚úù : Nonempty ‚ÜëK := Nonempty.intro ‚ü®v, hv‚ü©
eq : ‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ
w : F
hw : w ‚àà K
Œ¥ : ‚Ñù := ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ
p : ‚Ñù := ‚ü™u - v, w - v‚ü´_‚Ñù
q : ‚Ñù := ‚Äñw - v‚Äñ ^ 2
Œ¥_le : ‚àÄ (w : ‚ÜëK), Œ¥ ‚â§ ‚Äñu - ‚Üëw‚Äñ
Œ¥_le' : ‚àÄ w ‚àà K, Œ¥ ‚â§ ‚Äñu - w‚Äñ
Œ∏ : ‚Ñù
hŒ∏‚ÇÅ : 0 < Œ∏
hŒ∏‚ÇÇ : Œ∏ ‚â§ 1
this : 0 ‚â§ Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù
eq‚ÇÅ :
  ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
    ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù)
eq‚ÇÇ : Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù = Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * ‚ü™u - v, w - v‚ü´_‚Ñù)
‚ä¢ 2 * p ‚â§ Œ∏ * q
error:  unsolved goals
case mp
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Å¥ : _root_.RCLike ùïú
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedAddCommGroup F
inst‚úù¬π : InnerProductSpace ùïú E
inst‚úù : InnerProductSpace ‚Ñù F
K : Set F
h : Convex ‚Ñù K
u v : F
hv : v ‚àà K
this‚úù : Nonempty ‚ÜëK := Nonempty.intro ‚ü®v, hv‚ü©
eq : ‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ
w : F
hw : w ‚àà K
Œ¥ : ‚Ñù := ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ
p : ‚Ñù := ‚ü™u - v, w - v‚ü´_‚Ñù
q : ‚Ñù := ‚Äñw - v‚Äñ ^ 2
Œ¥_le : ‚àÄ (w : ‚ÜëK), Œ¥ ‚â§ ‚Äñu - ‚Üëw‚Äñ
Œ¥_le' : ‚àÄ w ‚àà K, Œ¥ ‚â§ ‚Äñu - w‚Äñ
this : ‚àÄ (Œ∏ : ‚Ñù), 0 < Œ∏ ‚Üí Œ∏ ‚â§ 1 ‚Üí 2 * p ‚â§ Œ∏ * q
‚ä¢ ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0
error:  unsolved goals
case mpr
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Å¥ : _root_.RCLike ùïú
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedAddCommGroup F
inst‚úù¬π : InnerProductSpace ùïú E
inst‚úù : InnerProductSpace ‚Ñù F
K : Set F
h : Convex ‚Ñù K
u v : F
hv : v ‚àà K
this : Nonempty ‚ÜëK := Nonempty.intro ‚ü®v, hv‚ü©
‚ä¢ (‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0) ‚Üí ‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ","theorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ‚Ñù K) {u : F} {v : F}
    (hv : v ‚àà K) : (‚Äñu - v‚Äñ = ‚®Ö w : K, ‚Äñu - w‚Äñ) ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0 ",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel‚ÇÄ _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            exact this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num [Œ∏])
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine le_add_of_nonneg_right ?_
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
         _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
           simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
             rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                   absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) ("
Mathlib/Data/Nat/Choose/Central.lean,Nat.four_pow_le_two_mul_self_mul_centralBinom,four_pow_le_two_mul_self_mul_centralBinom,27d257fca86730535c755957eeacad78dfe0e921,"  | 0, pr => (Nat.not_lt_zero _ pr).elim
  | 1, _ => by norm_num [centralBinom, choose]
  | 2, _ => by norm_num [centralBinom, choose]
  | 3, _ => by norm_num [centralBinom, choose]
  | n + 4, _ =>
    calc
      4 ^ (n+4) ‚â§ (n+4) * centralBinom (n+4) := (four_pow_lt_mul_centralBinom _ le_add_self).le
      _ ‚â§ 2 * (n+4) * centralBinom (n+4) := by rw [mul_assoc];
                                               refine' le_mul_of_pos_left zero_lt_two",error:  unknown identifier 'le_mul_of_pos_left',"theorem four_pow_le_two_mul_self_mul_centralBinom :
    ‚àÄ (n : ‚Ñï) (_ : 0 < n), 4 ^ n ‚â§ 2 * n * centralBinom n
","  | 0, pr => (Nat.not_lt_zero _ pr).elim
  | 1, _ => by norm_num [centralBinom, choose]
  | 2, _ => by norm_num [centralBinom, choose]
  | 3, _ => by norm_num [centralBinom, choose]
  | n + 4, _ =>
    calc
      4 ^ (n+4) ‚â§ (n+4) * centralBinom (n+4) := (four_pow_lt_mul_centralBinom _ le_add_self).le
      _ ‚â§ 2 * (n+4) * centralBinom (n+4) := by
        rw [mul_assoc]; refine Nat.le_mul_of_pos_left _ zero_lt_two",":= by rw [mul_assoc];
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "
Mathlib/Analysis/InnerProductSpace/Projection.lean,norm_eq_iInf_iff_real_inner_le_zero,norm_eq_iInf_iff_real_inner_le_zero,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel'_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            exact this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num)
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine' le_add_of_nonneg_right _
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _","warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
error:  type mismatch
  div_mul_cancel p ?m.225193
has type
  p / ?m.225193 * ?m.225193 = p : Prop
but is expected to have type
  p / q * q = p : Prop","theorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ‚Ñù K) {u : F} {v : F}
    (hv : v ‚àà K) : (‚Äñu - v‚Äñ = ‚®Ö w : K, ‚Äñu - w‚Äñ) ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0 ",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
          _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
            simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
              rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
            rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
              ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) =
          Œ∏ * (Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this
    by_cases hq : q = 0
    ¬∑ rw [hq] at this
      have : p ‚â§ 0 := by
        have := this (1 : ‚Ñù) (by norm_num) (by norm_num)
        linarith
      exact this
    ¬∑ have q_pos : 0 < q := lt_of_le_of_ne (sq_nonneg _) fun h ‚Ü¶ hq h.symm
      by_contra hp
      rw [not_le] at hp
      let Œ∏ := min (1 : ‚Ñù) (p / q)
      have eq‚ÇÅ : Œ∏ * q ‚â§ p :=
        calc
          Œ∏ * q ‚â§ p / q * q := mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
          _ = p := div_mul_cancel‚ÇÄ _ hq
      have : 2 * p ‚â§ p :=
        calc
          2 * p ‚â§ Œ∏ * q := by
            exact this Œ∏ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num [Œ∏])
          _ ‚â§ p := eq‚ÇÅ
      linarith
  ¬∑ intro h
    apply le_antisymm
    ¬∑ apply le_ciInf
      intro w
      apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _)
      have := h w w.2
      calc
        ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ ‚â§ ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * inner (u - v) ((w : F) - v) := by linarith
        _ ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * inner (u - v) ((w : F) - v) + ‚Äñ(w : F) - v‚Äñ ^ 2 := by
          rw [sq]
          refine le_add_of_nonneg_right ?_
          exact sq_nonneg _
        _ = ‚Äñu - v - (w - v)‚Äñ ^ 2 := (@norm_sub_sq ‚Ñù _ _ _ _ _ _).symm
        _ = ‚Äñu - w‚Äñ * ‚Äñu - w‚Äñ := by
          have : u - v - (w - v) = u - w := by abel
          rw [this, sq]
    ¬∑ show ‚®Ö w : K, ‚Äñu - w‚Äñ ‚â§ (fun w : K => ‚Äñu - w‚Äñ) ‚ü®v, hv‚ü©
      apply ciInf_le
      use 0
      rintro y ‚ü®z, rfl‚ü©
      exact norm_nonneg _",":= by
  letI : Nonempty K := ‚ü®‚ü®v, hv‚ü©‚ü©
  constructor
  ¬∑ intro eq w hw
    let Œ¥ := ‚®Ö w : K, ‚Äñu - w‚Äñ
    let p := ‚ü™u - v, w - v‚ü´_‚Ñù
    let q := ‚Äñw - v‚Äñ ^ 2
    have Œ¥_le (w : K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := ciInf_le ‚ü®0, fun _ ‚ü®_, h‚ü© => h ‚ñ∏ norm_nonneg _‚ü© _
    have Œ¥_le' (w) (hw : w ‚àà K) : Œ¥ ‚â§ ‚Äñu - w‚Äñ := Œ¥_le ‚ü®w, hw‚ü©
    have (Œ∏ : ‚Ñù) (hŒ∏‚ÇÅ : 0 < Œ∏) (hŒ∏‚ÇÇ : Œ∏ ‚â§ 1) : 2 * p ‚â§ Œ∏ * q := by
      have : ‚Äñu - v‚Äñ ^ 2 ‚â§ ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * ‚ü™u - v, w - v‚ü´_‚Ñù + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 :=
        calc ‚Äñu - v‚Äñ ^ 2
         _ ‚â§ ‚Äñu - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v)‚Äñ ^ 2 := by
           simp only [sq]; apply mul_self_le_mul_self (norm_nonneg _)
            rw [eq]; apply Œ¥_le'
            apply h hw hv
            exacts [le_of_lt hŒ∏‚ÇÅ, sub_nonneg.2 hŒ∏‚ÇÇ, add_sub_cancel_right _ _]
          _ = ‚Äñu - v - Œ∏ ‚Ä¢ (w - v)‚Äñ ^ 2 := by
            have : u - (Œ∏ ‚Ä¢ w + (1 - Œ∏) ‚Ä¢ v) = u - v - Œ∏ ‚Ä¢ (w - v) := by
             rw [smul_sub, sub_smul, one_smul]
              simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev]
             rw [this]
          _ = ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 := by
            rw [@norm_sub_sq ‚Ñù, inner_smul_right, norm_smul]
            simp only [sq]
            show
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * (Œ∏ * inner (u - v) (w - v)) +
                   absR Œ∏ * ‚Äñw - v‚Äñ * (absR Œ∏ * ‚Äñw - v‚Äñ) =
               ‚Äñu - v‚Äñ * ‚Äñu - v‚Äñ - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * (‚Äñw - v‚Äñ * ‚Äñw - v‚Äñ)
            rw [abs_of_pos hŒ∏‚ÇÅ]; ring
      have eq‚ÇÅ :
        ‚Äñu - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by
        abel
      rw [eq‚ÇÅ, le_add_iff_nonneg_right] at this
      have eq‚ÇÇ :
        Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v) + Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 =
          ‚Äñu - v‚Äñ ^ 2 + (Œ∏ * Œ∏ * ‚Äñw - v‚Äñ ^ 2 - 2 * Œ∏ * inner (u - v) (w - v)) := by ring
      rw [eq‚ÇÇ] at this
      have := le_of_sub_nonneg (nonneg_of_mul_nonneg_right this hŒ∏‚ÇÅ)
      exact this"
Mathlib/LinearAlgebra/Orientation.lean,Basis.map_orientation_eq_det_inv_smul,map_orientation_eq_det_inv_smul,c342c339a777827331257acd880fea6d441a6aa6,":= by
  cases nonempty_fintype Œπ
  letI := Classical.decEq Œπ
  induction' x with g hg
  rw [Orientation.map_apply, smul_rayOfNeZero, ray_eq_iff, Units.smul_def,
    (g.compLinearMap f.symm).eq_smul_basis_det e, g.eq_smul_basis_det e,
    AlternatingMap.compLinearMap_apply, AlternatingMap.smul_apply,
    show (fun i ‚Ü¶ (LinearEquiv.symm f).toLinearMap (e i)) = (LinearEquiv.symm f).toLinearMap ‚àò e
    by rfl, Basis.det_comp, Basis.det_self, mul_one, smul_eq_mul, mul_comm, mul_smul,
    LinearEquiv.coe_inv_det]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
case intro
R : Type u_1
inst‚úù‚Åµ : StrictOrderedCommRing R
M : Type u_2
N : Type u_3
inst‚úù‚Å¥ : AddCommGroup M
inst‚úù¬≥ : AddCommGroup N
inst‚úù¬≤ : Module R M
inst‚úù¬π : Module R N
Œπ : Type u_4
Œπ' : Type u_5
inst‚úù : Finite Œπ
e : Basis Œπ R M
x : Orientation R M Œπ
f : M ‚âÉ‚Çó[R] M
val‚úù : Fintype Œπ
this : DecidableEq Œπ := Classical.decEq Œπ
‚ä¢ (Orientation.map Œπ f) x = (LinearEquiv.det f)‚Åª¬π ‚Ä¢ x","theorem map_orientation_eq_det_inv_smul [Finite Œπ] (e : Basis Œπ R M) (x : Orientation R M Œπ)
    (f : M ‚âÉ‚Çó[R] M) : Orientation.map Œπ f x = (LinearEquiv.det f)‚Åª¬π ‚Ä¢ x ",":= by
  cases nonempty_fintype Œπ
  letI := Classical.decEq Œπ
  induction' x using Module.Ray.ind with g hg
  rw [Orientation.map_apply, smul_rayOfNeZero, ray_eq_iff, Units.smul_def,
    (g.compLinearMap f.symm).eq_smul_basis_det e, g.eq_smul_basis_det e,
    AlternatingMap.compLinearMap_apply, AlternatingMap.smul_apply,
    show (fun i ‚Ü¶ (LinearEquiv.symm f).toLinearMap (e i)) = (LinearEquiv.symm f).toLinearMap ‚àò e
    by rfl, Basis.det_comp, Basis.det_self, mul_one, smul_eq_mul, mul_comm, mul_smul,
    LinearEquiv.coe_inv_det]",":= by
  cases nonempty_fintype Œπ
  letI := Classical.decEq Œπ
  induction' x with g hg
  rw [Orientation.map_apply, smul_rayOfNeZero, ray_eq_iff, Units.smul_def,
    (g.compLinearMap f.symm).eq_smul_basis_det e, g.eq_smul_basis_det e,
    AlternatingMap.compLinearMap_apply, AlternatingMap.smul_apply,
    show (fun i ‚Ü¶ (LinearEquiv.symm f).toLinearMap (e i)) = (LinearEquiv.symm f).toLinearMap ‚àò e
    by rfl, Basis.det_comp, Basis.det_self, mul_one, smul_eq_mul, mul_comm, mul_smul,
    LinearEquiv.coe_inv_det]"
Mathlib/RingTheory/Discriminant.lean,Algebra.discr_isIntegral,discr_isIntegral,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  classical
  rw [discr_def]
  exact IsIntegral.det fun i j => isIntegral_trace (isIntegral_mul (h i) (h j))",error:  unknown identifier 'isIntegral_mul',"theorem discr_isIntegral {b : Œπ ‚Üí L} (h : ‚àÄ i, IsIntegral R (b i)) : IsIntegral R (discr K b) ",":= by
  classical
  rw [discr_def]
  exact IsIntegral.det fun i j ‚Ü¶ isIntegral_trace ((h i).mul (h j))",":= by
  classical
  rw [discr_def]
  exact IsIntegral.det fun i j => isIntegral_trace (isIntegral_mul (h i) (h j))"
Mathlib/Topology/Clopen.lean,isClopen_inter_of_disjoint_cover_clopen,isClopen_inter_of_disjoint_cover_clopen,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  refine' ‚ü®IsOpen.inter h.1 ha, _‚ü©
  have : IsClosed (s ‚à© b·∂ú) := IsClosed.inter h.2 (isClosed_compl_iff.2 hb)
  convert this using 1
  refine' (inter_subset_inter_right s hab.subset_compl_right).antisymm _
  rintro x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
  exact ‚ü®hx‚ÇÅ, by simpa [not_mem_of_mem_compl hx‚ÇÇ] using cover hx‚ÇÅ‚ü©","error:  application type mismatch
  IsOpen.inter h.left
argument
  h.left
has type
  IsClosed s : Prop
but is expected to have type
  IsOpen ?m.5373 : Prop
error:  application type mismatch
  IsClosed.inter h.right
argument
  h.right
has type
  IsOpen s : Prop
but is expected to have type
  IsClosed s : Prop
error:  type mismatch
  HasSubset.Subset.antisymm (inter_subset_inter_right s (Disjoint.subset_compl_right hab)) ?m.6850
has type
  s ‚à© a = s ‚à© b·∂ú : Prop
but is expected to have type
  @IsOpen = @IsClosed : Prop","theorem isClopen_inter_of_disjoint_cover_clopen {s a b : Set X} (h : IsClopen s) (cover : s ‚äÜ a ‚à™ b)
    (ha : IsOpen a) (hb : IsOpen b) (hab : Disjoint a b) : IsClopen (s ‚à© a) ",":= by
  refine ‚ü®?_, IsOpen.inter h.2 ha‚ü©
  have : IsClosed (s ‚à© b·∂ú) := IsClosed.inter h.1 (isClosed_compl_iff.2 hb)
  convert this using 1
  refine (inter_subset_inter_right s hab.subset_compl_right).antisymm ?_
  rintro x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
  exact ‚ü®hx‚ÇÅ, by simpa [not_mem_of_mem_compl hx‚ÇÇ] using cover hx‚ÇÅ‚ü©",":= by
  refine ‚ü®IsOpen.inter h.1 ha, ?_‚ü©
  have : IsClosed (s ‚à© b·∂ú) := IsClosed.inter h.2 isClosed_compl_iff.2 hb
  convert this using 1
  refine (inter_subset_inter_right s hab.subset_compl_right).antisymm ?_
  rintro x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
  exact ‚ü®hx‚ÇÅ, by simpa [not_mem_of_mem_compl hx‚ÇÇ] using cover hx‚ÇÅ‚ü©"
Mathlib/Topology/Sheaves/SheafCondition/UniqueGluing.lean,TopCat.Presheaf.isSheaf_of_isSheafUniqueGluing_types,isSheaf_of_isSheafUniqueGluing_types,a070b1f7d9c5435c82577c26578dcce0cf4e6ad0,":= by
  rw [isSheaf_iff_isSheafEqualizerProducts]
  intro Œπ U
  refine' ‚ü®Fork.IsLimit.mk' _ _‚ü©
  intro s
  have h_compatible :
    ‚àÄ x : s.pt, F.IsCompatible U (piOpensIsoSectionsFamily F U (s.Œπ x)) := by
    intro x
    rw [compatible_iff_leftRes_eq_rightRes]
    convert congr_fun s.condition x
  choose m m_spec m_uniq using fun x : s.pt =>
    Fsh U (piOpensIsoSectionsFamily F U (s.Œπ x)) (h_compatible x)
  refine' ‚ü®m, _, _‚ü©
  ¬∑ 
    refine limit.hom_ext fun ‚ü®i‚ü© => funext fun x => ?_
    simp [res]
    simpa using m_spec x i
  ¬∑ intro l hl
    ext x
    apply m_uniq
    rw [isGluing_iff_eq_res]
    exact congr_fun hl x","error:  unknown identifier 'isSheaf_iff_isSheafEqualizerProducts'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.14468
C : Type u
inst‚úù¬π : Category.{v, u} C
inst‚úù : ConcreteCategory C
X : TopCat
F : Presheaf (Type u) X
Œπ : Type x
U : Œπ ‚Üí Opens ‚ÜëX
Fsh : F.IsSheafUniqueGluing
‚ä¢ F.IsSheaf",theorem isSheaf_of_isSheafUniqueGluing_types (Fsh : F.IsSheafUniqueGluing) : F.IsSheaf ,":=
  (isSheaf_iff_isSheafUniqueGluing_types F).mpr Fsh",":= by
  rw [isSheaf_iff_isSheafEqualizerProducts]
  intro Œπ U
  refine ‚ü®Fork.IsLimit.mk' _ ?_‚ü©
  intro s
  have h_compatible :
    ‚àÄ x : s.pt, F.IsCompatible U (piOpensIsoSectionsFamily F U (s.Œπ x)) := by
    intro x
    rw [compatible_iff_leftRes_eq_rightRes]
    convert congr_fun s.condition x
  choose m m_spec m_uniq using fun x : s.pt =>
    Fsh U (piOpensIsoSectionsFamily F U (s.Œπ x)) (h_compatible x)
  refine ‚ü®m, ?_, ?_‚ü©
  ¬∑ 
    refine limit.hom_ext fun ‚ü®i‚ü© => funext fun x => ?_
    simp [res]
    simpa using m_spec x i
  ¬∑ intro l hl
    ext x
    apply m_uniq
    rw [isGluing_iff_eq_res]
    exact congr_fun hl x"
Mathlib/Combinatorics/Additive/FreimanHom.lean,Fin.isAddFreimanIso_Iic,isAddFreimanIso_Iic,596865180ecc63dcd1d95809202e31027ac3ae38,"  bijOn.left := by simp [MapsTo, Fin.le_iff_val_le_val, Nat.mod_eq_of_lt, aux hm hkmn]
  bijOn.right.left := val_injective.injOn _
  bijOn.right.right x (hx : x ‚â§ _) :=
    ‚ü®x, by simpa [le_iff_val_le_val, -val_fin_le, Nat.mod_eq_of_lt, aux hm hkmn, hx.trans_lt]‚ü©
  map_sum_eq_map_sum s t hsA htA hs ht := by
    have (u : Multiset (Fin (n + 1))) : Nat.castRingHom _ (u.map val).sum = u.sum := by simp
    rw [‚Üê this, ‚Üê this]
    have {u : Multiset (Fin (n + 1))} (huk : ‚àÄ x ‚àà u, x ‚â§ k) (hu : card u = m) :
        (u.map val).sum < (n + 1) := Nat.lt_succ_iff.2 $ hkmn.trans' $ by
      rw [‚Üê hu, ‚Üê card_map]
      refine sum_le_card_nsmul (u.map val) k ?_
      simpa [le_iff_val_le_val, -val_fin_le, Nat.mod_eq_of_lt, aux hm hkmn] using huk
    exact ‚ü®congr_arg _, CharP.natCast_injOn_Iio _ (n + 1) (this hsA hs) (this htA ht)‚ü©","error:  type mismatch
  Function.Injective.injOn val_injective ?m.166635
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Fin ?m.166612‚¶Ñ, x‚ÇÇ ‚àà ?m.166633 ‚Üí ‚Üë?m.166634 = ‚Üëx‚ÇÇ ‚Üí ?m.166634 = x‚ÇÇ : Prop
but is expected to have type
  InjOn val (Iic ‚Üëk) : Prop","lemma isAddFreimanIso_Iic (hm : m ‚â† 0) (hkmn : m * k ‚â§ n) :
    IsAddFreimanIso m (Iic (k : Fin (n + 1))) (Iic k) val where
","  bijOn.left := by simp [MapsTo, Fin.le_iff_val_le_val, Nat.mod_eq_of_lt, aux hm hkmn]
  bijOn.right.left := val_injective.injOn
  bijOn.right.right x (hx : x ‚â§ _) :=
    ‚ü®x, by simpa [le_iff_val_le_val, -val_fin_le, Nat.mod_eq_of_lt, aux hm hkmn, hx.trans_lt]‚ü©
  map_sum_eq_map_sum s t hsA htA hs ht := by
    have (u : Multiset (Fin (n + 1))) : Nat.castRingHom _ (u.map val).sum = u.sum := by simp
    rw [‚Üê this, ‚Üê this]
    have {u : Multiset (Fin (n + 1))} (huk : ‚àÄ x ‚àà u, x ‚â§ k) (hu : card u = m) :
        (u.map val).sum < (n + 1) := Nat.lt_succ_iff.2 $ hkmn.trans' $ by
      rw [‚Üê hu, ‚Üê card_map]
      refine sum_le_card_nsmul (u.map val) k ?_
      simpa [le_iff_val_le_val, -val_fin_le, Nat.mod_eq_of_lt, aux hm hkmn] using huk
    exact ‚ü®congr_arg _, CharP.natCast_injOn_Iio _ (n + 1) (this hsA hs) (this htA ht)‚ü©",":= val_injective.injOn _
  bijOn.right.right x (hx : x ‚â§ _) :=
    ‚ü®x, by simpa [le_iff_val_le_val, -val_fin_le, Nat.mod_eq_of_lt, aux hm hkmn, hx.trans_lt]‚ü©
  map_sum_eq_map_sum s t hsA htA hs ht := by
    have (u : Multiset (Fin (n + 1))) : Nat.castRingHom _ (u.map val).sum = u.sum := by simp
    rw [‚Üê this, ‚Üê this]
    have {u : Multiset (Fin (n + 1))} (huk : ‚àÄ x ‚àà u, x ‚â§ k) (hu : card u = m) :
        (u.map val).sum < (n + 1) := Nat.lt_succ_iff.2 $ hkmn.trans' $ by
      rw [‚Üê hu, ‚Üê card_map]
      refine sum_le_card_nsmul (u.map val) k ?_
      simpa [le_iff_val_le_val, -val_fin_le, Nat.mod_eq_of_lt, aux hm hkmn] using huk
    exact ‚ü®congr_arg _, CharP.natCast_injOn_Iio _ (n + 1) (this hsA hs) (this htA ht)‚ü©"
Mathlib/Analysis/Calculus/FDeriv/Measurable.lean,measurableSet_of_differentiableAt,measurableSet_of_differentiableAt,fdbb97baae10f5304e9ce72344499cd3620a87c2,":= by
  simp only [D, differentiable_set_eq_d K hK]
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iUnion fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine isOpen_b.measurableSet","error:  unknown identifier 'differentiable_set_eq_d'
error:  simp made no progress","theorem measurableSet_of_differentiableAt_of_isComplete {K : Set (E ‚ÜíL[ùïú] F)} (hK : IsComplete K) :
    MeasurableSet { x | DifferentiableAt ùïú f x ‚àß fderiv ùïú f x ‚àà K } ",":= by
  simp only [D, differentiable_set_eq_D K hK]
  repeat apply_rules [MeasurableSet.iUnion, MeasurableSet.iInter] <;> intro
  exact isOpen_B.measurableSet",":= by
  simp only [D, differentiable_set_eq_d K hK]
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter "
Mathlib/GroupTheory/PushoutI.lean,Monoid.PushoutI.NormalWord.eq_one_of_smul_normalized,eq_one_of_smul_normalized,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp only [‚Üê (d.compl _).equiv_snd_eq_self_iff_mem (one_mem _)] at hw hœÜw
  have hhead : ((d.compl i).equiv (Word.equivPair i w).head).2 =
      (Word.equivPair i w).head := by
    rw [Word.equivPair_head]
    dsimp only
    split_ifs with h
    ¬∑ rcases h with ‚ü®_, rfl‚ü©
      exact hw _ _ (List.head_mem _)
    ¬∑ rw [equiv_one (d.compl i) (one_mem _) (d.one_mem _)]
  by_contra hh1
  have := hœÜw i (œÜ i h * (Word.equivPair i w).head) ?_
  ¬∑ apply hh1
    rw [equiv_mul_left_of_mem (d.compl i) ‚ü®_, rfl‚ü©, hhead] at this
    simpa [((injective_iff_map_eq_one' _).1 (d.injective i))] using this
  ¬∑ simp only [Word.mem_smul_iff, not_true, false_and, ne_eq, Option.mem_def, mul_right_inj,
      exists_eq_right', mul_right_eq_self, exists_prop, true_and, false_or]
    constructor
    ¬∑ intro h
      apply_fun (d.compl i).equiv at h
      simp only [Prod.ext_iff, equiv_one (d.compl i) (one_mem _) (d.one_mem _),
        equiv_mul_left_of_mem (d.compl i) ‚ü®_, rfl‚ü© , hhead, Subtype.ext_iff,
        Prod.ext_iff, Subgroup.coe_mul] at h
      rcases h with ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
      rw [h‚ÇÇ, equiv_one (d.compl i) (one_mem _) (d.one_mem _), mul_one,
        ((injective_iff_map_eq_one' _).1 (d.injective i))] at h‚ÇÅ
      contradiction
    ¬∑ rw [Word.equivPair_head]
      dsimp
      split_ifs with hep
      ¬∑ rcases hep with ‚ü®hnil, rfl‚ü©
        rw [head?_eq_head _ hnil]
        simp_all
      ¬∑ push_neg at hep
        by_cases hw : w.toList = []
        ¬∑ simp [hw, Word.fstIdx]
        ¬∑ simp [head?_eq_head _ hw, Word.fstIdx, hep hw]",error:  dsimp made no progress,"theorem eq_one_of_smul_normalized (w : CoprodI.Word G) {i : Œπ} (h : H)
    (hw : ‚àÄ i g, ‚ü®i, g‚ü© ‚àà w.toList ‚Üí g ‚àà d.set i)
    (hœÜw : ‚àÄ j g, ‚ü®j, g‚ü© ‚àà (CoprodI.of (œÜ i h) ‚Ä¢ w).toList ‚Üí g ‚àà d.set j) :
    h = 1 ",":= by
  simp only [‚Üê (d.compl _).equiv_snd_eq_self_iff_mem (one_mem _)] at hw hœÜw
  have hhead : ((d.compl i).equiv (Word.equivPair i w).head).2 =
      (Word.equivPair i w).head := by
    rw [Word.equivPair_head]
    split_ifs with h
    ¬∑ rcases h with ‚ü®_, rfl‚ü©
      exact hw _ _ (List.head_mem _)
    ¬∑ rw [equiv_one (d.compl i) (one_mem _) (d.one_mem _)]
  by_contra hh1
  have := hœÜw i (œÜ i h * (Word.equivPair i w).head) ?_
  ¬∑ apply hh1
    rw [equiv_mul_left_of_mem (d.compl i) ‚ü®_, rfl‚ü©, hhead] at this
    simpa [((injective_iff_map_eq_one' _).1 (d.injective i))] using this
  ¬∑ simp only [Word.mem_smul_iff, not_true, false_and, ne_eq, Option.mem_def, mul_right_inj,
      exists_eq_right', mul_right_eq_self, exists_prop, true_and, false_or]
    constructor
    ¬∑ intro h
      apply_fun (d.compl i).equiv at h
      simp only [Prod.ext_iff, equiv_one (d.compl i) (one_mem _) (d.one_mem _),
        equiv_mul_left_of_mem (d.compl i) ‚ü®_, rfl‚ü© , hhead, Subtype.ext_iff,
        Prod.ext_iff, Subgroup.coe_mul] at h
      rcases h with ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
      rw [h‚ÇÇ, equiv_one (d.compl i) (one_mem _) (d.one_mem _), mul_one,
        ((injective_iff_map_eq_one' _).1 (d.injective i))] at h‚ÇÅ
      contradiction
    ¬∑ rw [Word.equivPair_head]
      dsimp
      split_ifs with hep
      ¬∑ rcases hep with ‚ü®hnil, rfl‚ü©
        rw [head?_eq_head _ hnil]
        simp_all
      ¬∑ push_neg at hep
        by_cases hw : w.toList = []
        ¬∑ simp [hw, Word.fstIdx]
        ¬∑ simp [head?_eq_head _ hw, Word.fstIdx, hep hw]",":= by
  simp only [‚Üê (d.compl _).equiv_snd_eq_self_iff_mem (one_mem _)] at hw hœÜw
  have hhead : ((d.compl i).equiv (Word.equivPair i w).head).2 =
      (Word.equivPair i w).head := by
    rw [Word.equivPair_head]
    dsimp only [Word.mem_smul_iff, not_true, false_and, ne_eq, Option.mem_def, mul_right_inj,
      exists_eq_right', mul_right_eq_self, exists_prop, true_and, false_or]
    constructor
    ¬∑ intro h
      apply_fun (d.compl i).equiv at h
      simp only [Prod.ext_iff, equiv_one (d.compl i) (one_mem _) (d.one_mem _),
        equiv_mul_left_of_mem (d.compl i) ‚ü®_, rfl‚ü© , hhead, Subtype.ext_iff,
        Prod.ext_iff, Subgroup.coe_mul] at h
      rcases h with ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
      rw [h‚ÇÇ, equiv_one (d.compl i) (one_mem _) (d.one_mem _), mul_one,
        ((injective_iff_map_eq_one' _).1 (d.injective i))] at h‚ÇÅ
      contradiction
    ¬∑ rw [Word.equivPair_head]
      dsimp
      split_ifs with hep
      ¬∑ rcases hep with ‚ü®hnil, rfl‚ü©
        rw [head?_eq_head _ hnil]
        simp_all
      ¬∑ push_neg at hep
        by_cases hw : w.toList = []
        ¬∑ simp [hw, Word.fstIdx]
        ¬∑ simp [head?_eq_head _ hw, Word.fstIdx, hep hw]"
Mathlib/LinearAlgebra/Span.lean,Submodule.finset_span_isCompactElement,finset_span_isCompactElement,ff33484322fbce1ead24eb4ca948306955c68664,":= by
  rw [span_eq_sup·µ¢_of_singleton_spans]
  simp only [Finset.mem_coe]
  rw [‚Üê Finset.sup_eq_sup·µ¢]
  exact
    CompleteLattice.finset_sup_compact_of_compact S fun x _ => singleton_span_isCompactElement x","error:  unknown identifier 'span_eq_sup·µ¢_of_singleton_spans'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.232594
R : Type u_1
R‚ÇÇ : Type u_2
K : Type u_3
M : Type u_4
M‚ÇÇ : Type u_5
V : Type u_6
S‚úù : Type u_7
inst‚úù‚Å∑ : Semiring R
inst‚úù‚Å∂ : AddCommMonoid M
inst‚úù‚Åµ : Module R M
x : M
p p' : Submodule R M
inst‚úù‚Å¥ : Semiring R‚ÇÇ
œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ
inst‚úù¬≥ : AddCommMonoid M‚ÇÇ
inst‚úù¬≤ : Module R‚ÇÇ M‚ÇÇ
F : Type u_8
inst‚úù¬π : FunLike F M M‚ÇÇ
inst‚úù : SemilinearMapClass F œÉ‚ÇÅ‚ÇÇ M M‚ÇÇ
s t : Set M
S : Finset M
‚ä¢ CompleteLattice.IsCompactElement (span R ‚ÜëS)","theorem finset_span_isCompactElement (S : Finset M) :
    CompleteLattice.IsCompactElement (span R S : Submodule R M) ",":= by
  rw [span_eq_iSup_of_singleton_spans]
  simp only [Finset.mem_coe]
  rw [‚Üê Finset.sup_eq_iSup]
  exact
    CompleteLattice.isCompactElement_finsetSup S fun x _ => singleton_span_isCompactElement x",":= by
  rw [span_eq_sup·µ¢_of_singleton_spans]
  simp only [Finset.mem_coe]
  rw [‚Üê Finset.sup_eq_sup]
  exact
    CompleteLattice.finset_sup_compact_of_compact S fun x _ => singleton_span_isCompactElement x"
Mathlib/Topology/Instances/Real.lean,AddSubgroup.tendsto_zmultiples_subtype_cofinite,tendsto_zmultiples_subtype_cofinite,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  rcases eq_or_ne a 0 with rfl | ha
  ¬∑ rw [zmultiples_zero_eq_bot, cofinite_eq_bot]; exact tendsto_bot
  ¬∑ calc cofinite.map (zmultiples a).subtype
      ‚â§ .map (zmultiples a).subtype (.map (rangeFactorization (¬∑ ‚Ä¢ a)) (@cofinite ‚Ñ§)) :=
        Filter.map_mono surjective_onto_range.le_map_cofinite
    _ = (@cofinite ‚Ñ§).map (zmultiplesHom ‚Ñù a) := Filter.map_map
    _ ‚â§ cocompact ‚Ñù := Int.tendsto_zmultiplesHom_cofinite ha","error:  type mismatch
  tendsto_zmultiplesHom_cofinite ha
has type
  Tendsto (‚áë((zmultiplesHom ‚Ñù) a)) Filter.cofinite (cocompact ‚Ñù) : Prop
but is expected to have type
  ?m.66265 ‚â§ cocompact ‚Ñù : Prop
error:  ambiguous, possible interpretations 
  Bornology.cofinite : Bornology ‚Ñ§
  
  Filter.cofinite : Filter ‚Ñ§","theorem tendsto_zmultiples_subtype_cofinite (a : ‚Ñù) :
    Tendsto (zmultiples a).subtype cofinite (cocompact ‚Ñù) ",":=
  (zmultiples a).tendsto_coe_cofinite_of_discrete",":= by
  rcases eq_or_ne a 0 with rfl | ha
  ¬∑ rw [zmultiples_zero_eq_bot, cofinite_eq_bot]; exact tendsto_bot
  ¬∑ calc cofinite.map (zmultiples a).subtype
      ‚â§ .map (zmultiples a).subtype (.map (rangeFactorization (¬∑ ‚Ä¢ a)) (@cofinite ‚Ñ§)) :=
        Filter.map_mono surjective_onto_range.le_map_cofinite
    _ = (@cofinite ‚Ñ§).map (zmultiplesHom ‚Ñù a) := Filter.map_map
    _ ‚â§ cocompact ‚Ñù := Int.tendsto_zmultiplesHom_cofinite ha"
Mathlib/LinearAlgebra/Orientation.lean,Orientation.map_eq_neg_iff_det_neg,map_eq_neg_iff_det_neg,9f377843ae74f8ea35a167e1fcc7752e1a90722a,":= by
  cases isEmpty_or_nonempty Œπ
  ¬∑ have H : finrank R M = 0 := by
      refine' h.symm.trans _
      convert @Fintype.card_of_isEmpty Œπ _
    simp [LinearMap.det_eq_one_of_finrank_eq_zero H, Module.Ray.ne_neg_self x]
  have H : 0 < finrank R M := by
    rw [‚Üê h]
    exact Fintype.card_pos
  haveI : FiniteDimensional R M := Module.finite_of_finrank_pos H
  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, LinearEquiv.coe_det]","error:  unsolved goals
case a
R : Type u_1
inst‚úù¬≥ : LinearOrderedField R
M : Type u_2
inst‚úù¬≤ : AddCommGroup M
inst‚úù¬π : Module R M
Œπ : Type u_3
inst‚úù : Fintype Œπ
_i : FiniteDimensional R M
x : Orientation R M Œπ
f : M ‚âÉ‚Çó[R] M
h : Fintype.card Œπ = finrank R M
h‚úù : IsEmpty Œπ
‚ä¢ Fintype.card Œπ = 0 ‚Üî ‚àÄ [inst : IsEmpty Œπ], Fintype.card Œπ = 0","theorem map_eq_neg_iff_det_neg (x : Orientation R M Œπ) (f : M ‚âÉ‚Çó[R] M)
    (h : Fintype.card Œπ = finrank R M) :
    Orientation.map Œπ f x = -x ‚Üî LinearMap.det (f : M ‚Üí‚Çó[R] M) < 0 ",":= by
  cases isEmpty_or_nonempty Œπ
  ¬∑ have H : finrank R M = 0 := h.symm.trans Fintype.card_eq_zero
    simp [LinearMap.det_eq_one_of_finrank_eq_zero H, Module.Ray.ne_neg_self x]
  have H : 0 < finrank R M := by
    rw [‚Üê h]
    exact Fintype.card_pos
  haveI : FiniteDimensional R M := of_finrank_pos H
  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, LinearEquiv.coe_det]",":= by
  cases isEmpty_or_nonempty Œπ
  ¬∑ have H : finrank R M = 0 := by
      refine h.symm.trans ?_
      convert @Fintype.card_of_isEmpty Œπ _
    simp [LinearMap.det_eq_one_of_finrank_eq_zero H, Module.Ray.ne_neg_self x]
  have H : 0 < finrank R M := by
    rw [‚Üê h]
    exact Fintype.card_pos
  haveI : FiniteDimensional R M := Module.finite_of_finrank_pos H
  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, LinearEquiv.coe_det]"
Mathlib/GroupTheory/Perm/Cycle/Type.lean,Equiv.Perm.card_fixedPoints_modEq,card_fixedPoints_modEq,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  let œÉ : Œ± ‚âÉ Œ± := ‚ü®f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)‚ü©
  have hœÉ : œÉ ^ p ^ n = 1 := by
    rw [DFunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End Œ± ‚Ü¶ g) rfl (fun g h ‚Ü¶ rfl) f (p ^ n)).symm.trans hf
  suffices Fintype.card f.fixedPoints = (support œÉ)·∂ú.card from
    this ‚ñ∏ (card_compl_support_modEq hœÉ).symm
  suffices f.fixedPoints = (support œÉ)·∂ú by
    simp only [this]; apply Fintype.card_coe
  simp [Set.ext_iff, IsFixedPt]","error:  unsolved goals
Œ± : Type u_1
inst‚úù¬π : Fintype Œ±
inst‚úù : DecidableEq Œ±
f : Function.End Œ±
p n : ‚Ñï
hp : Fact (Nat.Prime p)
hf : f ^ p ^ n = 1
œÉ : Œ± ‚âÉ Œ± := { toFun := f, invFun := f ^ (p ^ n - 1), left_inv := ‚ãØ, right_inv := ‚ãØ }
hœÉ : œÉ ^ p ^ n = 1
‚ä¢ ‚àÄ (x : Œ±), f x = x ‚Üî œÉ x = x","theorem card_fixedPoints_modEq [DecidableEq Œ±] {f : Function.End Œ±} {p n : ‚Ñï}
    [hp : Fact p.Prime] (hf : f ^ p ^ n = 1) :
    Fintype.card Œ± ‚â° Fintype.card f.fixedPoints [MOD p] ",":= by
  let œÉ : Œ± ‚âÉ Œ± := ‚ü®f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)‚ü©
  have hœÉ : œÉ ^ p ^ n = 1 := by
    rw [DFunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End Œ± ‚Ü¶ g) rfl (fun g h ‚Ü¶ rfl) f (p ^ n)).symm.trans hf
  suffices Fintype.card f.fixedPoints = (support œÉ)·∂ú.card from
    this ‚ñ∏ (card_compl_support_modEq hœÉ).symm
  suffices f.fixedPoints = (support œÉ)·∂ú by
    simp only [this]; apply Fintype.card_coe
  simp [œÉ, Set.ext_iff, IsFixedPt]",":= by
  let œÉ : Œ± ‚âÉ Œ± := ‚ü®f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)‚ü©
  have hœÉ : œÉ ^ p ^ n = 1 := by
    rw [DFunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End Œ± ‚Ü¶ g) rfl (fun g h ‚Ü¶ rfl) f (p ^ n)).symm.trans hf
  suffices Fintype.card f.fixedPoints = (support œÉ)·∂ú by
    simp only [this]; apply Fintype.card_coe
  simp [Set.ext_iff, IsFixedPt]"
Mathlib/RingTheory/IntegralDomain.lean,sum_hom_units,sum_hom_units,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  classical
    obtain ‚ü®x, hx‚ü© :
      ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0  
    exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u : RÀ£ in univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u : RÀ£ in univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := (congr_arg‚ÇÇ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n in range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ ¬∑) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ‚ä¢; rw [pow_mod_orderOf, hn]‚ü©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]","error:  unexpected identifier; expected '|'
error:  unsolved goals
case intro
R : Type u_1
G : Type u_2
inst‚úù¬≥ : CommRing R
inst‚úù¬≤ : IsDomain R
inst‚úù¬π : Group G
inst‚úù : Fintype G
f : G ‚Üí* R
hf : f ‚â† 1
x : ‚Ü•f.toHomUnits.range
hx : ‚àÄ (y : ‚Ü•f.toHomUnits.range), y ‚àà Submonoid.powers x
hx1 : ‚Üë‚Üëx - 1 ‚â† 0
‚ä¢ ‚àë g : G, f g = 0","theorem sum_hom_units_eq_zero (f : G ‚Üí* R) (hf : f ‚â† 1) : ‚àë g : G, f g = 0 ",":= by
  classical
    obtain ‚ü®x, hx‚ü© : ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u ‚àà univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u ‚àà univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := congr_arg‚ÇÇ _ rfl ?_
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n ‚àà range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ ¬∑) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ‚ä¢; rw [pow_mod_orderOf, hn]‚ü©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]",":= by
  classical
    obtain ‚ü®x, hx‚ü© :
      ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0      exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u : RÀ£ ‚àà univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u : RÀ£ ‚àà univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := (congr_arg‚ÇÇ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n ‚àà range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ ¬∑) (by simp only [mem_univ, forall_true_iff])
            (fun b _"
Mathlib/Data/Num/Lemmas.lean,PosNum.succ_to_nat,succ_to_nat,fc94d7cf19de72da26bfb583fdb140d8737abb30,"  | 1 => rfl
  | bit0 p => rfl
  | bit1 p => by simp [succ, succ_to_nat p, add_left_comm 1]","warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  unsolved goals
Œ± : Type u_1
p : PosNum
‚ä¢ _root_.bit0 (‚Üëp + 1) = _root_.bit1 ‚Üëp + 1
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `castNum` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated","theorem succ_to_nat : ‚àÄ n, (succ n : ‚Ñï) = n + 1
","  | 1 => rfl
  | bit0 p => rfl
  | bit1 p =>
    (congr_arg _root_.bit0 (succ_to_nat p)).trans <|
      show ‚Üëp + 1 + ‚Üëp + 1 = ‚Üëp + ‚Üëp + 1 + 1 by simp [add_left_comm]",":= by
  | 1 => rfl
  | bit1 p => by simp [succ, succ_to_nat p, add_left_comm 1]"
Mathlib/NumberTheory/ClassNumber/Finite.lean,ClassGroup.norm_le,norm_le,690644e30cc42cb5564cbbb1a59a5f2ca1df1bf5,":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, LinearEquiv.map_sum,
    LinearEquiv.map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  rw [‚Üê LinearMap.det_toMatrix bS]
  convert Matrix.det_sum_smul_le (n := Œπ) Finset.univ _ hy using 3
  . simp; rfl
  ¬∑ rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearEquiv
has type
  (œÉ : ?m.53606 ‚Üí+* ?m.53607) ‚Üí
    {œÉ' : ?m.53607 ‚Üí+* ?m.53606} ‚Üí
      [inst : RingHomInvPair œÉ œÉ'] ‚Üí
        [inst : RingHomInvPair œÉ' œÉ] ‚Üí
          (M : Type ?u.53603) ‚Üí
            (M‚ÇÇ : Type ?u.53602) ‚Üí
              [inst : AddCommMonoid M] ‚Üí
                [inst_1 : AddCommMonoid M‚ÇÇ] ‚Üí
                  [inst : Module ?m.53606 M] ‚Üí [inst : Module ?m.53607 M‚ÇÇ] ‚Üí Type (max ?u.53603 ?u.53602)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  LinearMap.det ?f
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
inst‚úù¬π‚Å¥ : EuclideanDomain R
inst‚úù¬π¬≥ : CommRing S
inst‚úù¬π¬≤ : IsDomain S
inst‚úù¬π¬π : Field K
inst‚úù¬π‚Å∞ : Field L
inst‚úù‚Åπ : Algebra R K
inst‚úù‚Å∏ : IsFractionRing R K
inst‚úù‚Å∑ : Algebra K L
inst‚úù‚Å∂ : FiniteDimensional K L
inst‚úù‚Åµ : IsSeparable K L
algRL : Algebra R L
inst‚úù‚Å¥ : IsScalarTower R K L
inst‚úù¬≥ : Algebra R S
inst‚úù¬≤ : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R ‚Ñ§
Œπ : Type u_5
inst‚úù¬π : DecidableEq Œπ
inst‚úù : Fintype Œπ
bS : Basis Œπ R S
a : S
y : ‚Ñ§
hy : ‚àÄ (k : Œπ), abv ((bS.repr a) k) ‚â§ y
‚ä¢ abv ((LinearMap.toMatrix bS bS) (‚àë x : Œπ, (bS.repr a) x ‚Ä¢ (Algebra.lmul R S) (bS x))).det ‚â§
    (Fintype.card Œπ).factorial ‚Ä¢
      (Fintype.card Œπ ‚Ä¢
          ((Finset.image (fun ijk ‚Ü¶ abv ((Algebra.leftMulMatrix bS) (bS ijk.1) ijk.2.1 ijk.2.2)) Finset.univ).max' ‚ãØ *
            y)) ^
        Fintype.card Œπ","theorem norm_le (a : S) {y : ‚Ñ§} (hy : ‚àÄ k, abv (bS.repr a k) ‚â§ y) :
    abv (Algebra.norm R a) ‚â§ normBound abv bS * y ^ Fintype.card Œπ ",":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  convert Matrix.det_sum_smul_le Finset.univ _ hy using 3
  ¬∑ rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©",":= by
  conv_lhs => rw [‚Üê bS.sum_repr a]
  rw [Algebra.norm_apply, ‚Üê LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, LinearEquiv.map_sum,
    LinearEquiv.map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ‚Üê mul_pow]
  rw [‚Üê LinearMap.det_toMatrix bS]
  convert Matrix.det_sum_smul_le (n := Œπ) Finset.univ _ hy using 3
  . simp; rfl
  ¬∑ rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  ¬∑ intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, Finset.mem_univ _, rfl‚ü©"
Mathlib/Data/List/Indexes.lean,List.map_enumFrom_eq_zipWith,map_enumFrom_eq_zipWith,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  intro l
  generalize e : l.length = len
  revert l
  induction' len with len ih <;> intros l e n f
  ¬∑ have : l = [] := by
      cases l
      ¬∑ rfl
      ¬∑ contradiction
    rw [this]; rfl
  ¬∑ cases' l with head tail
    ¬∑ contradiction
    ¬∑ simp only [map, uncurry_apply_pair, range_succ_eq_map, zipWith, zero_add, zipWith_map_left]
      rw [ih]
      ¬∑ suffices (fun i ‚Ü¶ f (i + (n + 1))) = ((fun i ‚Ü¶ f (i + n)) ‚àò Nat.succ) by
          rw [this]
          rfl
        funext n' a
        simp only [comp, Nat.add_assoc, Nat.add_comm, Nat.add_succ]
      simp only [length_cons, Nat.succ.injEq] at e; exact e","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
Œ± : Type u
Œ≤ : Type v
len : ‚Ñï
ih :
  ‚àÄ (l : List Œ±),
    l.length = len ‚Üí
      ‚àÄ (n : ‚Ñï) (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤), map (uncurry f) (enumFrom n l) = zipWith (fun i ‚Ü¶ f (i + n)) (range len) l
n : ‚Ñï
f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤
head : Œ±
tail : List Œ±
e : (head :: tail).length = len + 1
this : (fun i ‚Ü¶ f (i + (n + 1))) = (fun i ‚Ü¶ f (i + n)) ‚àò Nat.succ
‚ä¢ f n head :: zipWith ((fun i ‚Ü¶ f (i + n)) ‚àò Nat.succ) (range len) tail =
    f (0 + n) head :: zipWith (fun a b ‚Ü¶ f (a.succ + n) b) (range len) tail
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem map_enumFrom_eq_zipWith : ‚àÄ (l : List Œ±) (n : ‚Ñï) (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤),
    map (uncurry f) (enumFrom n l) = zipWith (fun i ‚Ü¶ f (i + n)) (range (length l)) l ",":= by
  intro l
  generalize e : l.length = len
  revert l
  induction' len with len ih <;> intros l e n f
  ¬∑ have : l = [] := by
      cases l
      ¬∑ rfl
      ¬∑ contradiction
    rw [this]; rfl
  ¬∑ cases' l with head tail
    ¬∑ contradiction
    ¬∑ simp only [map, uncurry_apply_pair, range_succ_eq_map, zipWith, Nat.zero_add,
        zipWith_map_left]
      rw [ih]
      ¬∑ suffices (fun i ‚Ü¶ f (i + (n + 1))) = ((fun i ‚Ü¶ f (i + n)) ‚àò Nat.succ) by
          rw [this]
          rfl
        funext n' a
        simp only [comp, Nat.add_assoc, Nat.add_comm, Nat.add_succ]
      simp only [length_cons, Nat.succ.injEq] at e; exact e",":= by
  intro l
  generalize e : l.length = len
  revert l
  induction' len with len ih <;> intros l e n f
  ¬∑ have : l = [] := by
      cases l
      ¬∑ rfl
      ¬∑ contradiction
    rw [this]; rfl
  ¬∑ cases' l with head tail
    ¬∑ contradiction
    ¬∑ simp only [map, uncurry_apply_pair, range_succ_eq_map, zipWith, zero_add, zipWith_map_left]
      rw [ih]
      ¬∑ suffices (fun i ‚Ü¶ f (i + (n + 1))) = ((fun i ‚Ü¶ f (i + n)) ‚àò Nat.succ) by
          rw [this]
          rfl
        funext n' a
        simp only [comp, Nat.add_assoc, Nat.add_comm, Nat.add_succ]
      simp only [length_cons, Nat.succ.injEq] at e; exact e"
Mathlib/CategoryTheory/Abelian/Pseudoelements.lean,CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono,pseudo_injective_of_mono,1cb1056b5a19f416d3fae3469d51eedb4f5b48cb,":= by
  intro abar abar'
  refine' Quotient.inductionOn‚ÇÇ abar abar' fun a a' ha => _
  apply Quotient.sound
  have : ‚ü¶(a.hom ‚â´ f : Over Q)‚üß = ‚ü¶‚Üë(a'.hom ‚â´ f)‚üß := by convert ha
  let ‚ü®R, p, q, ep, Eq, comm‚ü© := Quotient.exact this
  exact ‚ü®R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact comm‚ü©","error:  don't know how to synthesize implicit argument 'Œ±'
  @Eq (Quotient ?m.42591) ‚ü¶Over.mk (a.hom ‚â´ f)‚üß ‚ü¶Over.mk (a'.hom ‚â´ f)‚üß
context:
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ Type (max u v)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ Setoid (Over Q)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ Setoid (Over Q)
error:  unsolved goals
case a
C : Type u
inst‚úù¬≤ : Category.{v, u} C
inst‚úù¬π : Abelian C
P Q : C
f : P ‚ü∂ Q
inst‚úù : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f ‚ü¶a‚üß = pseudoApply f ‚ü¶a'‚üß
‚ä¢ a ‚âà a'",theorem pseudo_injective_of_mono {P Q : C} (f : P ‚ü∂ Q) [Mono f] : Function.Injective f ,":= by
  intro abar abar'
  refine Quotient.inductionOn‚ÇÇ abar abar' fun a a' ha => ?_
  apply Quotient.sound
  have : (‚ü¶(a.hom ‚â´ f : Over Q)‚üß : Quotient (setoid Q)) = ‚ü¶‚Üë(a'.hom ‚â´ f)‚üß := by convert ha
  have ‚ü®R, p, q, ep, Eq, comm‚ü© := Quotient.exact this
  exact ‚ü®R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact comm‚ü©",":= by
  intro abar abar'
  refine Quotient.inductionOn abar abar' fun a a' ha => ?_
  apply Quotient.sound
  have : ‚ü¶(a.hom ‚â´ f : Over Q)‚üß = ‚ü¶‚Üë(a'.hom ‚â´ f)‚üß := by convert ha
  let ‚ü®R, p, q, ep, Eq, comm‚ü© := Quotient.exact this
  exact ‚ü®R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact comm‚ü©"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet,ae_tendsto_measure_inter_div_of_measurableSet,5f16c539a4048e107d2e8f76816e95423850fb6d,":= by
  haveI : IsLocallyFiniteMeasure (Œº.restrict s) :=
    isLocallyFiniteMeasure_of_le restrict_le_self
  filter_upwards [ae_tendsto_rnDeriv v (Œº.restrict s), rnDeriv_restrict Œº hs]
  intro x hx h'x
  simpa only [h'x, restrict_apply' hs, inter_comm] using hx","error:  application type mismatch
  @rnDeriv_restrict Œ± m0 Œº hs
argument
  hs
has type
  MeasurableSet s : Prop
but is expected to have type
  Measure Œ± : Type u_1
error:  type mismatch
  h‚úù
has type
  Tendsto (fun a ‚Ü¶ Œº (s ‚à© a) / Œº a) (v.filterAt x) (ùìù ((Œº.restrict s).rnDeriv Œº x)) : Prop
but is expected to have type
  Tendsto (fun a ‚Ü¶ Œº (s ‚à© a) / Œº a) (v.filterAt x) (ùìù (s.indicator 1 x)) : Prop","theorem ae_tendsto_measure_inter_div_of_measurableSet {s : Set Œ±} (hs : MeasurableSet s) :
    ‚àÄ·µê x ‚àÇŒº, Tendsto (fun a => Œº (s ‚à© a) / Œº a) (v.filterAt x) (ùìù (s.indicator 1 x)) ",":= by
  haveI : IsLocallyFiniteMeasure (Œº.restrict s) :=
    isLocallyFiniteMeasure_of_le restrict_le_self
  filter_upwards [ae_tendsto_rnDeriv v (Œº.restrict s), rnDeriv_restrict_self Œº hs]
  intro x hx h'x
  simpa only [h'x, restrict_apply' hs, inter_comm] using hx",":= by
  haveI : IsLocallyFiniteMeasure (Œº.restrict s) := isLocallyFiniteMeasure_of_le restrict_le_self
  filter_upwards [ae_tendsto_rnDeriv v (Œº.restrict s), rnDeriv_restrict Œº hs]
  intro x hx h'x
  simpa only [h'x, restrict_apply' hs, inter_comm] using hx"
Mathlib/SetTheory/Cardinal/Ordinal.lean,Cardinal.mul_eq_self,mul_eq_self,c9b014cd7a6879d40f458f2b1099ae28ec9fd5bb,":= by
  refine' le_antisymm _ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine' Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => _) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  skip
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine' le_of_forall_lt fun o h => _
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine'
    lt_of_le_of_lt (_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p))))
      _
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit
    ¬∑
      exact
        ‚ü®(Set.embeddingOfSubset _ _ this).trans
            ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine' (Equiv.Set.insert _).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein (¬∑ < ¬∑) (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices : (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß
    ¬∑ exact (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type","error:  unexpected token '¬∑'; expected 'by' or 'from'
error:  unsolved goals
case intro.intro.intro.refine'_2
c‚úù : Cardinal.{u_1}
h‚úù : ‚Ñµ‚ÇÄ ‚â§ c‚úù
c : Cardinal.{u_1}
x‚úù : ‚àÄ y < c, Acc (fun x x_1 ‚Ü¶ x < x_1) y
Œ± : Type u_1
IH : ‚àÄ y < ‚ü¶Œ±‚üß, ‚Ñµ‚ÇÄ ‚â§ y ‚Üí y * y ‚â§ y
ol : ‚Ñµ‚ÇÄ ‚â§ ‚ü¶Œ±‚üß
r : Œ± ‚Üí Œ± ‚Üí Prop
wo : IsWellOrder Œ± r
e : (#Œ±).ord = type r
this‚úù¬π : LinearOrder Œ± := linearOrderOfSTO r
this‚úù : IsWellOrder Œ± fun x x_1 ‚Ü¶ x < x_1
g : Œ± √ó Œ± ‚Üí Œ± := fun p ‚Ü¶ max p.1 p.2
f : Œ± √ó Œ± ‚Ü™ Ordinal.{u_1} √ó Œ± √ó Œ± := { toFun := fun p ‚Ü¶ (typein (fun x x_1 ‚Ü¶ x < x_1) (g p), p), inj' := ‚ãØ }
s : Œ± √ó Œ± ‚Üí Œ± √ó Œ± ‚Üí Prop := ‚áëf ‚Åª¬π'o Prod.Lex (fun x x_1 ‚Ü¶ x < x_1) (Prod.Lex (fun x x_1 ‚Ü¶ x < x_1) fun x x_1 ‚Ü¶ x < x_1)
this : IsWellOrder (Œ± √ó Œ±) s
p : Œ± √ó Œ±
h : typein s p < type s
‚ä¢ (succ (typein (fun x x_1 ‚Ü¶ x < x_1) (g p))).card * (succ (typein (fun x x_1 ‚Ü¶ x < x_1) (g p))).card < #Œ±",theorem mul_eq_self {c : Cardinal} (h : ‚Ñµ‚ÇÄ ‚â§ c) : c * c = c ,":= by
  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => ?_) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine le_of_forall_lt fun o h => ?_
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine lt_of_le_of_lt
    (?_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p)))) ?_
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [s, f, Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit from
      ‚ü®(Set.embeddingOfSubset _ _ this).trans
        ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine (Equiv.Set.insert ?_).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein (¬∑ < ¬∑) (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß from (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type",":= by
  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => ?_) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  skip
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine le_of_forall_lt fun o h => ?_
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine
    lt_of_le_of_lt (_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p))))
      ?_
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit
    ¬∑
      exact
        ‚ü®(Set.embeddingOfSubset _ _ this).trans
            ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine (Equiv.Set.insert _).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein LT.lt (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß
    ¬∑ exact (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type"
Mathlib/NumberTheory/FermatPsp.lean,Nat.exists_infinite_pseudoprimes,exists_infinite_pseudoprimes,4ad46d4a6677dcfb96418e03062ff39837a061ae,":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by omega
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by omega) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by omega
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact ‚ü®fermatPsp_base_one (by omega) this, by omega‚ü©","error:  unsolved goals
b : ‚Ñï
h : 1 ‚â§ b
m : ‚Ñï
b_ge_two : ¬¨2 ‚â§ b
h‚ÇÅ : b = 1
‚ä¢ ¬¨m + 2 = 1","theorem exists_infinite_pseudoprimes {b : ‚Ñï} (h : 1 ‚â§ b) (m : ‚Ñï) :
    ‚àÉ n : ‚Ñï, FermatPsp n b ‚àß m ‚â§ n ",":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by omega
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h‚ÇÑ h‚ÇÖ
    have h‚Çá : b ‚â§ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by omega) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by omega
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by omega) (by omega)
    exact ‚ü®fermatPsp_base_one (by omega) this, by omega‚ü©",":= by
  by_cases b_ge_two : 2 ‚â§ b
  ¬∑ have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp‚ÇÅ hp‚ÇÇ
    have h‚ÇÅ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h‚ÇÇ : 4 ‚â§ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h‚ÇÉ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h‚ÇÇ (by norm_num))
    have h‚ÇÑ : 0 < b * (b ^ 2 - 1) := mul_pos h‚ÇÅ h‚ÇÉ
    have h‚ÇÖ : b * (b ^ 2 - 1) < p := by omega
    have h‚ÇÜ : ¬¨p ‚à£ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ h‚ÇÉ
    have h‚Çà : 2 ‚â§ b * (b ^ 2 - 1) := le_trans b_ge_two h‚Çá
    have h‚Çâ : 2 < p := gt_of_gt_of_ge h‚ÇÖ h‚Çà
    have h‚ÇÅ‚ÇÄ := psp_from_prime_gt_p b_ge_two hp‚ÇÇ h‚Çâ
    use psp_from_prime b p
    constructor
    ¬∑ exact psp_from_prime_psp b_ge_two hp‚ÇÇ h‚Çâ h‚ÇÜ
    ¬∑ exact le_trans (show m ‚â§ p by omega) (le_of_lt h‚ÇÅ‚ÇÄ)
  ¬∑ have h‚ÇÅ : b = 1 := by omega
    rw [h‚ÇÅ]
    use 2 * (m + 2)
    have : ¬¨Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact ‚ü®fermatPsp_base_one (by omega) this, by omega‚ü©"
Mathlib/MeasureTheory/Integral/Bochner.lean,MeasureTheory.ae_eq_trim_of_stronglyMeasurable,ae_eq_trim_of_stronglyMeasurable,5c3b19457914190f5f82a4845a908a6fa667ed79,":= by
  rwa [EventuallyEq, @ae_iff _ m, trim_measurableSet_eq hm _]
  exact (hf.measurableSet_eq_fun hg).compl","warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
error:  application type mismatch
  @ae_iff ?m.1321447 m
argument
  m
has type
  MeasurableSpace Œ≤ : Type u_7
but is expected to have type
  Type ?u.1321445 : Type (?u.1321445 + 1)","theorem ae_eq_trim_of_stronglyMeasurable [TopologicalSpace Œ≥] [MetrizableSpace Œ≥] (hm : m ‚â§ m0)
    {f g : Œ≤ ‚Üí Œ≥} (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g)
    (hfg : f =·µê[Œº] g) : f =·µê[Œº.trim hm] g ",":= by
  rwa [EventuallyEq, ae_iff, trim_measurableSet_eq hm]
  exact (hf.measurableSet_eq_fun hg).compl",":= by
  rwa [EventuallyEq, @ae_iff _ m, trim_measurableSet_eq hm _]"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.mul_le_addHaar_image_of_lt_det,mul_le_addHaar_image_of_lt_det,7088139429bcf36357f4c44f3beff1a1374a13e1,":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine' Tendsto.mul (tendsto_const_nhds.mul _) tendsto_id
      refine' (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ _
      simpa only [tsub_zero, inv_eq_zero, Ne.def] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toLocalEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target
  ¬∑ change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne.def] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne.def, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)","error:  unexpected token '¬∑'; expected 'by' or 'from'
error:  unsolved goals
case h
E : Type u_1
F : Type u_2
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : FiniteDimensional ‚Ñù E
inst‚úù‚Å¥ : NormedAddCommGroup F
inst‚úù¬≥ : NormedSpace ‚Ñù F
s‚úù : Set E
f‚úù : E ‚Üí E
f' : E ‚Üí E ‚ÜíL[‚Ñù] E
inst‚úù¬≤ : MeasurableSpace E
inst‚úù¬π : BorelSpace E
Œº : Measure E
inst‚úù : Œº.IsAddHaarMeasure
A : E ‚ÜíL[‚Ñù] E
m : ‚Ñù‚â•0
hm : ‚Üëm < ENNReal.ofReal |A.det|
mpos : 0 < m
hA : A.det ‚â† 0
B : E ‚âÉL[‚Ñù] E := A.toContinuousLinearEquivOfDetNeZero hA
I : ENNReal.ofReal |(‚ÜëB.symm).det| < ‚Üëm‚Åª¬π
Œ¥‚ÇÄ : ‚Ñù‚â•0
Œ¥‚ÇÄpos : 0 < Œ¥‚ÇÄ
hŒ¥‚ÇÄ : ‚àÄ (t : Set E) (g : E ‚Üí E), ApproximatesLinearOn g (‚ÜëB.symm) t Œ¥‚ÇÄ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t
L1 : ‚àÄ·∂† (Œ¥ : ‚Ñù‚â•0) in ùìù 0, Subsingleton E ‚à® Œ¥ < ‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π
L2 : ‚àÄ·∂† (Œ¥ : ‚Ñù‚â•0) in ùìù 0, ‚Äñ‚ÜëB.symm‚Äñ‚Çä * (‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ
Œ¥ : ‚Ñù‚â•0
h1Œ¥ : Subsingleton E ‚à® Œ¥ < ‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π
h2Œ¥ : ‚Äñ‚ÜëB.symm‚Äñ‚Çä * (‚Äñ‚ÜëB.symm‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ
s : Set E
f : E ‚Üí E
hf : ApproximatesLinearOn f A s Œ¥
hf' : ApproximatesLinearOn f (‚ÜëB) s Œ¥
‚ä¢ ‚Üëm * Œº s ‚â§ Œº (f '' s)","theorem mul_le_addHaar_image_of_lt_det (A : E ‚ÜíL[‚Ñù] E) {m : ‚Ñù‚â•0}
    (hm : (m : ‚Ñù‚â•0‚àû) < ENNReal.ofReal |A.det|) :
    ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù‚â•0),
      ‚àÄ (s : Set E) (f : E ‚Üí E), ApproximatesLinearOn f A s Œ¥ ‚Üí (m : ‚Ñù‚â•0‚àû) * Œº s ‚â§ Œº (f '' s) ",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ filter_upwards
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_eq_zero, Ne] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toPartialEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target by
    change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, tsub_zero] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, tsub_zero, tsub_zero, tsub_zero] using tendsto_const_nhds
      refine Tendsto.mul ("
Mathlib/GroupTheory/Sylow.lean,Sylow.exists_subgroup_le_card_le,exists_subgroup_le_card_le,a2d4b97db742cef33d7ce3404f92ab85330707e5,":= by
  obtain ‚ü®m, hmk, hkm‚ü© : ‚àÉ s, p ^ s ‚â§ k ‚àß k < p ^ (s + 1) :=
    exists_nat_pow_near (Nat.one_le_iff_ne_zero.2 hk‚ÇÄ) hp.one_lt
  obtain ‚ü®H', H'H, H'card‚ü© := exists_subgroup_le_card_pow_prime_of_le_card hp h (hmk.trans hk)
  refine ‚ü®H', H'H, ?_‚ü©
  simpa only [pow_succ, H'card] using And.intro hmk hkm","error:  type mismatch
  h‚úù
has type
  p ^ m ‚â§ k ‚àß k < p ^ m * p : Prop
but is expected to have type
  p ^ m ‚â§ k ‚àß k < p * p ^ m : Prop","lemma exists_subgroup_le_card_le {k p : ‚Ñï} (hp : p.Prime) (h : IsPGroup p G) {H : Subgroup G}
    (hk : k ‚â§ Nat.card H) (hk‚ÇÄ : k ‚â† 0) : ‚àÉ H' ‚â§ H, Nat.card H' ‚â§ k ‚àß k < p * Nat.card H' ",":= by
  obtain ‚ü®m, hmk, hkm‚ü© : ‚àÉ s, p ^ s ‚â§ k ‚àß k < p ^ (s + 1) :=
    exists_nat_pow_near (Nat.one_le_iff_ne_zero.2 hk‚ÇÄ) hp.one_lt
  obtain ‚ü®H', H'H, H'card‚ü© := exists_subgroup_le_card_pow_prime_of_le_card hp h (hmk.trans hk)
  refine ‚ü®H', H'H, ?_‚ü©
  simpa only [pow_succ', H'card] using And.intro hmk hkm",":= by
  obtain ‚ü®m, hmk, hkm‚ü© : ‚àÉ s, p ^ s ‚â§ k ‚àß k < p ^ (s + 1) :=
    exists_nat_pow_near (Nat.one_le_iff_ne_zero.2 hk‚ÇÄ) hp.one_lt
  obtain ‚ü®H', H'H, H'card‚ü© := exists_subgroup_le_card_pow_prime_of_le_card hp h (hmk.trans hk)
  refine ‚ü®H', H'H, ?_‚ü©
  simpa only [pow_succ, H'card] using And.intro hmk hkm"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg ((¬∑ * ¬∑) œÅ) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogon"
Mathlib/Algebra/BigOperators/Finprod.lean,finprod_mul_distrib,finprod_mul_distrib,a388d938162d1410e5399da3595dcff6614a5ffe,":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset _ hf (Finset.subset_union_left _ _),
      finprod_eq_prod_of_mulSupport_toFinset_subset _ hg (Finset.subset_union_right _ _), ‚Üê
      Finset.prod_mul_distrib]
    refine' finprod_eq_prod_of_mulSupport_subset _ _
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf,hg‚ü©
    simp [hf, hg]","error:  function expected at
  Finset.subset_union_left ?m.86793
term has type
  ?m.86792 ‚àà ?m.86790 ‚à™ ?m.86791
error:  function expected at
  Finset.subset_union_right ?m.86952
term has type
  ?m.86951 ‚àà ?m.86949 ‚à™ ?m.86950
error:  simp made no progress","theorem finprod_mul_distrib (hf : (mulSupport f).Finite) (hg : (mulSupport g).Finite) :
    ‚àè·∂† i, f i * g i = (‚àè·∂† i, f i) * ‚àè·∂† i, g i ",":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset f hf Finset.subset_union_left,
      finprod_eq_prod_of_mulSupport_toFinset_subset g hg Finset.subset_union_right, ‚Üê
      Finset.prod_mul_distrib]
    refine finprod_eq_prod_of_mulSupport_subset _ ?_
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf, hg‚ü©
    simp [hf, hg]",":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset _ hf (Finset.subset_union_left,
      finprod_eq_prod_of_mulSupport_toFinset_subset _ hg (Finset.subset_union_right), ‚Üê
      Finset.prod_mul_distrib]
    refine finprod_eq_prod_of_mulSupport_subset ?_ ?_
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf, hg‚ü©
    simp [hf, hg]"
Mathlib/CategoryTheory/Adjunction/Reflective.lean,CategoryTheory.equivEssImageOfReflective_map_counitIso_app_hom,equivEssImageOfReflective_map_counitIso_app_hom,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  (Functor.essImageInclusion i).map (equivEssImageOfReflective_counitIso_app X).hom =
    inv (NatTrans.app (ofRightAdjoint i).unit X.obj) := by
    simp only [Functor.comp_obj, Functor.essImageInclusion_obj, Functor.toEssImage_obj_obj,
      equivEssImageOfReflective_counitIso_app, asIso, Iso.symm_mk, Functor.essImageInclusion_map,
      Functor.id_obj]
    rfl","error:  unknown identifier 'ofRightAdjoint'
error:  unknown identifier 'equivEssImageOfReflective_map_counitIso_app_hom'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.31459
case a
C : Type u‚ÇÅ
D : Type u‚ÇÇ
E : Type u‚ÇÉ
inst‚úù¬≥ : Category.{v‚ÇÅ, u‚ÇÅ} C
inst‚úù¬≤ : Category.{v‚ÇÇ, u‚ÇÇ} D
inst‚úù¬π : Category.{v‚ÇÉ, u‚ÇÉ} E
i : D ‚•§ C
inst‚úù : Reflective i
X Y : i.EssImageSubcategory
f : X ‚ü∂ Y
h : (reflectorAdjunction i).unit.app X.obj ‚â´ (reflector i ‚ãô i).map f = f ‚â´ (reflectorAdjunction i).unit.app Y.obj
‚ä¢ i.essImageInclusion.map (((i.essImageInclusion ‚ãô reflector i) ‚ãô i.toEssImage).map f) ‚â´
      i.essImageInclusion.map (equivEssImageOfReflective_counitIso_app Y).hom =
    i.essImageInclusion.map (equivEssImageOfReflective_counitIso_app X).hom ‚â´
      i.essImageInclusion.map ((ùü≠ i.EssImageSubcategory).map f)
error:  unknown identifier 'equivEssImageOfReflective_map_counitIso_app_hom'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.31883
case a
C : Type u‚ÇÅ
D : Type u‚ÇÇ
E : Type u‚ÇÉ
inst‚úù¬≥ : Category.{v‚ÇÅ, u‚ÇÅ} C
inst‚úù¬≤ : Category.{v‚ÇÇ, u‚ÇÇ} D
inst‚úù¬π : Category.{v‚ÇÉ, u‚ÇÉ} E
i : D ‚•§ C
inst‚úù : Reflective i
X : D
‚ä¢ i.essImageInclusion.map
        (i.toEssImage.map
          ((NatIso.ofComponents (fun X ‚Ü¶ (asIso ((reflectorAdjunction i).counit.app X)).symm) ‚ãØ).hom.app X)) ‚â´
      i.essImageInclusion.map
        ((NatIso.ofComponents equivEssImageOfReflective_counitIso_app ‚ãØ).hom.app (i.toEssImage.obj X)) =
    i.essImageInclusion.map (ùüô (i.toEssImage.obj X))","lemma equivEssImageOfReflective_map_counitIso_app_hom [Reflective i]
    (X : Functor.EssImageSubcategory i) :
","  (Functor.essImageInclusion i).map (equivEssImageOfReflective_counitIso_app X).hom =
    inv (NatTrans.app (reflectorAdjunction i).unit X.obj) := by
    simp only [Functor.comp_obj, Functor.essImageInclusion_obj, Functor.toEssImage_obj_obj,
      equivEssImageOfReflective_counitIso_app, asIso, Iso.symm_mk, Functor.essImageInclusion_map,
      Functor.id_obj]
    rfl",":= by
    simp only [Functor.comp_obj, Functor.essImageInclusion_obj, Functor.toEssImage_obj_obj,
      equivEssImageOfReflective_counitIso_app, asIso, Iso.symm_mk, Functor.essImageInclusion_map,
      Functor.id_obj]"
Mathlib/Topology/Constructions.lean,nhds_subtype_eq_comap,nhds_subtype_eq_comap,9a069d68af1d7bc2ad676d68e44dc963e5910e7b,":= by
  rw [nhds_subtype, ‚Üê comap_nhdsWithin_range, Subtype.range_val]","error:  unknown identifier 'comap_nhdsWithin_range'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.91628
X : Type u
Y : Type v
Z : Type u_1
W : Type u_2
Œµ : Type u_3
Œ∂ : Type u_4
inst‚úù¬≤ : TopologicalSpace X
inst‚úù¬π : TopologicalSpace Y
inst‚úù : TopologicalSpace Z
p : X ‚Üí Prop
x : X
h : p x
‚ä¢ comap Subtype.val (ùìù ‚Üë‚ü®x, h‚ü©) = comap Subtype.val (ùìù x)","theorem nhds_subtype_eq_comap {x : X} {h : p x} : ùìù (‚ü®x, h‚ü© : Subtype p) = comap (‚Üë) (ùìù x) ",":=
  nhds_induced _ _",":= by
  rw [nhds_subtype, ‚Üê nhdsWithin_range, Subtype.range_val]"
Mathlib/MeasureTheory/Integral/Lebesgue.lean,MeasureTheory.lintegral_liminf_le',lintegral_liminf_le',3f9dee6adf287742f66dfda5079840cb2497af69,":=
  calc
    ‚à´‚Åª a, liminf (fun n => f n a) atTop ‚àÇŒº = ‚à´‚Åª a, ‚®Ü n : ‚Ñï, ‚®Ö i ‚â• n, f i a ‚àÇŒº := by
      simp only [liminf_eq_iSup_iInf_of_nat]
    _ = ‚®Ü n : ‚Ñï, ‚à´‚Åª a, ‚®Ö i ‚â• n, f i a ‚àÇŒº :=
      (lintegral_iSup' (fun n => aemeasurable_biInf _ (to_countable _) h_meas)
        (ae_of_all Œº fun a n m hnm => iInf_le_iInf_of_subset fun i hi => le_trans hnm hi))
    _ ‚â§ ‚®Ü n : ‚Ñï, ‚®Ö i ‚â• n, ‚à´‚Åª a, f i a ‚àÇŒº := (iSup_mono fun n => le_iInf‚ÇÇ_lintegral _)
    _ = atTop.liminf fun n => ‚à´‚Åª a, f n a ‚àÇŒº := Filter.liminf_eq_iSup_iInf_of_nat.symm","warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
error:  application type mismatch
  aemeasurable_biInf n.le (to_countable n.le) h_meas
argument
  h_meas
has type
  ‚àÄ (n : ‚Ñï), AEMeasurable (f n) Œº : Prop
but is expected to have type
  ‚àÄ i ‚àà n.le, AEMeasurable (f i) Œº : Prop","theorem lintegral_liminf_le' {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h_meas : ‚àÄ n, AEMeasurable (f n) Œº) :
    ‚à´‚Åª a, liminf (fun n => f n a) atTop ‚àÇŒº ‚â§ liminf (fun n => ‚à´‚Åª a, f n a ‚àÇŒº) atTop ",":=
  calc
    ‚à´‚Åª a, liminf (fun n => f n a) atTop ‚àÇŒº = ‚à´‚Åª a, ‚®Ü n : ‚Ñï, ‚®Ö i ‚â• n, f i a ‚àÇŒº := by
      simp only [liminf_eq_iSup_iInf_of_nat]
    _ = ‚®Ü n : ‚Ñï, ‚à´‚Åª a, ‚®Ö i ‚â• n, f i a ‚àÇŒº :=
      (lintegral_iSup' (fun n => aemeasurable_biInf _ (to_countable _) (fun i _ ‚Ü¶ h_meas i))
        (ae_of_all Œº fun a n m hnm => iInf_le_iInf_of_subset fun i hi => le_trans hnm hi))
    _ ‚â§ ‚®Ü n : ‚Ñï, ‚®Ö i ‚â• n, ‚à´‚Åª a, f i a ‚àÇŒº := iSup_mono fun n => le_iInf‚ÇÇ_lintegral _
    _ = atTop.liminf fun n => ‚à´‚Åª a, f n a ‚àÇŒº := Filter.liminf_eq_iSup_iInf_of_nat.symm",":=
  calc
    ‚à´‚Åª a, liminf (fun n => f n a) atTop ‚àÇŒº = ‚à´‚Åª a, ‚®Ü n : ‚Ñï, ‚®Ö i ‚â• n, f i a ‚àÇŒº := by
      simp only [liminf_eq_iSup_iInf_of_nat]
    _ = ‚®Ü n : ‚Ñï, ‚à´‚Åª a, ‚®Ö i ‚â• n, f i a ‚àÇŒº :=
      (lintegral_iSup' (fun n => aemeasurable_biInf _ (to_countable _) h_meas)
        (ae_of_all Œº fun a n m hnm => iInf_le_iInf_of_subset fun i hi => le_trans hnm hi))
    _ ‚â§ ‚®Ü n : ‚Ñï, ‚®Ö i ‚â• n, ‚à´‚Åª a, f i a ‚àÇŒº := iSup_mono fun n => le_iInf‚ÇÇ_lintegral _
    _ = atTop.liminf fun n => ‚à´‚Åª a, f n a ‚àÇŒº := Filter.liminf_eq_iSup_iInf_of_nat.symm"
Mathlib/Algebra/BigOperators/Finsupp.lean,Finsupp.univ_sum_single,univ_sum_single,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  classical
  refine FunLike.coe_injective ?_
  simp_rw [coe_finset_sum, single_eq_pi_single, Finset.univ_sum_single]","error:  unknown constant 'FunLike.coe_injective'
error:  no goals to be solved","theorem univ_sum_single [Fintype Œ±] [AddCommMonoid M] (f : Œ± ‚Üí‚ÇÄ M) :
    ‚àë a : Œ±, single a (f a) = f ",":= by
  classical
  refine DFunLike.coe_injective ?_
  simp_rw [coe_finset_sum, single_eq_pi_single, Finset.univ_sum_single]",":= by
  classical
  refine FunLike.coe_injective ?_
  simp_rw [FunLike.coe_injective, Finset.univ_sum_single]"
Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean,MeasureTheory.Measure.addHaar_affineSubspace,addHaar_affineSubspace,63aaa8cc21050b7a5cb193c6764569918728723b,":= by
  rcases s.eq_bot_or_nonempty with (rfl | hne)
  ¬∑ rw [AffineSubspace.bot_coe, measure_empty]
  rw [Ne.def, ‚Üê AffineSubspace.direction_eq_top_iff_of_nonempty hne] at hs
  rcases hne with ‚ü®x, hx : x ‚àà s‚ü©
  simpa only [AffineSubspace.coe_direction_eq_vsub_set_right hx, vsub_eq_sub, sub_eq_add_neg,
    image_add_right, neg_neg, measure_preimage_add_right] using addHaar_submodule Œº s.direction hs","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.109837 ‚Üí ?m.109837 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.109839
case inr
E : Type u_1
inst‚úù‚Åµ : NormedAddCommGroup E
inst‚úù‚Å¥ : NormedSpace ‚Ñù E
inst‚úù¬≥ : MeasurableSpace E
inst‚úù¬≤ : BorelSpace E
inst‚úù¬π : FiniteDimensional ‚Ñù E
Œº : Measure E
inst‚úù : Œº.IsAddHaarMeasure
s : AffineSubspace ‚Ñù E
hs : s ‚â† ‚ä§
hne : (‚Üës).Nonempty
‚ä¢ Œº ‚Üës = 0","theorem addHaar_affineSubspace {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [MeasurableSpace E] [BorelSpace E] [FiniteDimensional ‚Ñù E] (Œº : Measure E) [IsAddHaarMeasure Œº]
    (s : AffineSubspace ‚Ñù E) (hs : s ‚â† ‚ä§) : Œº s = 0 ",":= by
  rcases s.eq_bot_or_nonempty with (rfl | hne)
  ¬∑ rw [AffineSubspace.bot_coe, measure_empty]
  rw [Ne, ‚Üê AffineSubspace.direction_eq_top_iff_of_nonempty hne] at hs
  rcases hne with ‚ü®x, hx : x ‚àà s‚ü©
  simpa only [AffineSubspace.coe_direction_eq_vsub_set_right hx, vsub_eq_sub, sub_eq_add_neg,
    image_add_right, neg_neg, measure_preimage_add_right] using addHaar_submodule Œº s.direction hs",":= by
  rcases s.eq_bot_or_nonempty with (rfl | hne)
  ¬∑ rw [AffineSubspace.bot_coe, measure_empty]
  rw [Ne, ‚Üê AffineSubspace.direction_eq_top_iff_of_nonempty hne] at hs
  rcases hne with ‚ü®x, hx : x ‚àà s‚ü©
  simpa only [AffineSubspace.coe_direction_eq_vsub_set_right hx, vsub_eq_sub, sub_eq_add_neg,
    image_add_right, neg_neg, measure_preimage_add_right] using addHaar_submodule Œº s.direction hs"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,821d503181d6030794806a9ac2fb2b1f5dd5dfb3,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Œµ hŒµ).mono fun y hy => _
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",error:  simp made no progress,"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto"
Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean,CochainComplex.HomComplex.Œ¥_map,Œ¥_map,9072ff84a0d139a344bf9eed4a00c4cd27596c79,":= by
  by_cases hnm : n + 1 = m
  ¬∑ ext p q hpq
    dsimp
    simp only [Œ¥_v n m hnm _ p q hpq (q-1) (p+1) rfl rfl,
      Functor.map_add, Functor.map_comp, Functor.map_zsmul,
      Cochain.map_v, Functor.mapHomologicalComplex_obj_d]
  ¬∑ simp only [Œ¥_shape _ _ hnm, Cochain.map_zero]","error:  unsolved goals
case pos.h
C : Type u
inst‚úù‚Å∂ : Category.{v, u} C
inst‚úù‚Åµ : Preadditive C
R : Type u_1
inst‚úù‚Å¥ : Ring R
inst‚úù¬≥ : Linear R C
F G K L : CochainComplex C ‚Ñ§
n m : ‚Ñ§
D : Type u_2
inst‚úù¬≤ : Category.{u_3, u_2} D
inst‚úù¬π : Preadditive D
z z' : Cochain K L n
f : K ‚ü∂ L
Œ¶ : C ‚•§ D
inst‚úù : Œ¶.Additive
hnm : n + 1 = m
p q : ‚Ñ§
hpq : p + m = q
‚ä¢ Œ¶.map (z.v p (q - 1) ‚ãØ) ‚â´ Œ¶.map (L.d (q - 1) q) + m.negOnePow ‚Ä¢ Œ¶.map (K.d p (p + 1)) ‚â´ Œ¶.map (z.v (p + 1) q ‚ãØ) =
    Œ¶.map (z.v p (q - 1) ‚ãØ) ‚â´ Œ¶.map (L.d (q - 1) q) + Œ¶.map (m.negOnePow ‚Ä¢ K.d p (p + 1) ‚â´ z.v (p + 1) q ‚ãØ)",lemma Œ¥_map : Œ¥ n m (z.map Œ¶) = (Œ¥ n m z).map Œ¶ ,":= by
  by_cases hnm : n + 1 = m
  ¬∑ ext p q hpq
    dsimp
    simp only [Œ¥_v n m hnm _ p q hpq (q-1) (p+1) rfl rfl,
      Functor.map_add, Functor.map_comp, Functor.map_units_smul,
      Cochain.map_v, Functor.mapHomologicalComplex_obj_d]
  ¬∑ simp only [Œ¥_shape _ _ hnm, Cochain.map_zero]",":= by
  by_cases hnm : n + 1 = m
  ¬∑ ext p q hpq
    dsimp
    simp only [Œ¥_v n m hnm _ p q hpq (q-1) (p+1) rfl rfl,
      Functor.map_add, Functor.map_comp, Functor.map_zsmul,
      Cochain.map_v, Functor.mapHomologicalComplex_obj_d]
  ¬∑ simp only [Œ¥_shape _ _ hnm, Cochain.map_zero]"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,fb54f94c133c9225bec877b481995fc98cd3a253,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/Topology/Bases.lean,TopologicalSpace.IsTopologicalBasis.diff_empty,IsTopologicalBasis.diff_empty,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine ‚ü®?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_‚ü©
  ¬∑ rintro t‚ÇÅ ‚ü®h‚ÇÅ, -‚ü© t‚ÇÇ ‚ü®h‚ÇÇ, -‚ü© x hx
    obtain ‚ü®t‚ÇÉ, h‚ÇÉ, hs‚ü© := h.exists_subset_inter _ h‚ÇÅ _ h‚ÇÇ x hx
    exact ‚ü®t‚ÇÉ, ‚ü®h‚ÇÉ, Nonempty.ne_empty ‚ü®x, hs.1‚ü©‚ü©, hs‚ü©
  ¬∑ rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti <| diff_subset s _) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t ‚àÖ
    ¬∑ exact @isOpen_empty _ (generateFrom _)
    ¬∑ exact .basic t ‚ü®ht, he‚ü©","error:  application type mismatch
  diff_subset s
argument
  s
has type
  Set (Set Œ±) : Type u
but is expected to have type
  ?m.1865 ‚àà ?m.1863 \ ?m.1864 : Prop","theorem IsTopologicalBasis.diff_empty {s : Set (Set Œ±)} (h : IsTopologicalBasis s) :
    IsTopologicalBasis (s \ {‚àÖ}) ",":= by
  refine ‚ü®?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_‚ü©
  ¬∑ rintro t‚ÇÅ ‚ü®h‚ÇÅ, -‚ü© t‚ÇÇ ‚ü®h‚ÇÇ, -‚ü© x hx
    obtain ‚ü®t‚ÇÉ, h‚ÇÉ, hs‚ü© := h.exists_subset_inter _ h‚ÇÅ _ h‚ÇÇ x hx
    exact ‚ü®t‚ÇÉ, ‚ü®h‚ÇÉ, Nonempty.ne_empty ‚ü®x, hs.1‚ü©‚ü©, hs‚ü©
  ¬∑ rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti diff_subset) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t ‚àÖ
    ¬∑ exact @isOpen_empty _ (generateFrom _)
    ¬∑ exact .basic t ‚ü®ht, he‚ü©",":= by
  refine ‚ü®?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_‚ü©
  ¬∑ rintro t‚ÇÅ ‚ü®h‚ÇÅ, -‚ü© t‚ÇÇ ‚ü®h‚ÇÇ, -‚ü© x hx
    obtain ‚ü®t‚ÇÉ, h‚ÇÉ, hs‚ü© := h.exists_subset_inter _ h‚ÇÅ _ h‚ÇÇ x hx
    exact ‚ü®t‚ÇÉ, ‚ü®h‚ÇÉ, Nonempty.ne_empty ‚ü®x, hs.1‚ü©‚ü©, hs‚ü©
  ¬∑ rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti <| diff_subset s _) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t ‚àÖ
    ¬∑ exact @isOpen_empty _ (generateFrom _)
    ¬∑ exact .basic t ‚ü®ht, he‚ü©"
Mathlib/RingTheory/IntegralDomain.lean,sum_hom_units,sum_hom_units,9e34a191034458a56331f976ff7400a26407c888,":= by
  classical
    obtain ‚ü®x, hx‚ü© :
      ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0  
    exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u : RÀ£ in univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u : RÀ£ in univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := (congr_arg‚ÇÇ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n in range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only [mem_univ, forall_true_iff])
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
            (fun m n hm hn =>
              pow_injective_of_lt_orderOf _ (by simpa only [mem_range] using hm)
                (by simpa only [mem_range] using hn))
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ‚ä¢; rw [‚Üê pow_eq_mod_orderOf, hn]‚ü©)
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, MulZeroClass.zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]","error:  unexpected identifier; expected '|'
error:  unsolved goals
case intro
R : Type u_1
G : Type u_2
inst‚úù¬≥ : CommRing R
inst‚úù¬≤ : IsDomain R
inst‚úù¬π : Group G
inst‚úù : Fintype G
f : G ‚Üí* R
hf : f ‚â† 1
x : ‚Ü•f.toHomUnits.range
hx : ‚àÄ (y : ‚Ü•f.toHomUnits.range), y ‚àà Submonoid.powers x
hx1 : ‚Üë‚Üëx - 1 ‚â† 0
‚ä¢ ‚àë g : G, f g = 0","theorem sum_hom_units_eq_zero (f : G ‚Üí* R) (hf : f ‚â† 1) : ‚àë g : G, f g = 0 ",":= by
  classical
    obtain ‚ü®x, hx‚ü© : ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u ‚àà univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u ‚àà univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := congr_arg‚ÇÇ _ rfl ?_
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n ‚àà range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ ¬∑) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ‚ä¢; rw [pow_mod_orderOf, hn]‚ü©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]",":= by
  classical
    obtain ‚ü®x, hx‚ü© :
      ‚àÉ x : MonoidHom.range f.toHomUnits,
        ‚àÄ y : MonoidHom.range f.toHomUnits, y ‚àà Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x ‚â† 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ‚ü®f.toHomUnits g, g, rfl‚ü© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ‚â† 0      exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ‚àë g : G, f g = ‚àë g : G, (f.toHomUnits g : R) := rfl
      _ = ‚àë u : RÀ£ ‚àà univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card ‚Ä¢ (u : R) :=
        (sum_comp ((‚Üë) : RÀ£ ‚Üí R) f.toHomUnits)
      _ = ‚àë u : RÀ£ ‚àà univ.image f.toHomUnits, c ‚Ä¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_arg‚ÇÇ _ ?_ rfl)
      _ = ‚àë b : MonoidHom.range f.toHomUnits, c ‚Ä¢ ((b : RÀ£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c ‚Ä¢ ‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R) := smul_sum.symm
      _ = c ‚Ä¢ (0 : R) := (congr_arg‚ÇÇ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    ¬∑ 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      ¬∑ simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      ¬∑ exact ‚ü®1, f.toHomUnits.map_one‚ü©
    show (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R)) = 0
    calc
      (‚àë b : MonoidHom.range f.toHomUnits, ((b : RÀ£) : R))
        = ‚àë n ‚àà range (orderOf x), ((x : RÀ£) : R) ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only [mem_univ, forall_true_iff])
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                 Units.val_pow_eq_pow_val])
            (fun m n hm hn =>
              pow_injective_of_lt_orderOf _ (by simpa only [mem_range] using hm)
               (by simpa only [mem_range] using hn))
            (fun b _ => let ‚ü®n, hn‚ü© := hx b
              ‚ü®n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
                 by dsimp at hn ‚ä¢; rw [‚Üê pow_eq_mod_orderOf, hn]‚ü©)
      _ = 0 := ?_

    rw [‚Üê mul_left_inj' hx1, MulZeroClass.zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le,norm_volume_sub_integral_face_upper_sub_lower_smul_le,01cbe052ff3f63d184556afa56666d0df4fed183,":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
      ¬∑ intro y hy
        refine' (hŒµ y hy).trans (mul_le_mul_of_nonneg_left _ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [Function.comp_def, Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine' norm_integral_le_of_le_const (fun y hy => (this y hy).trans _) volume
      rw [mul_assoc (2 * Œµ)]
      exact mul_le_mul_of_nonneg_left (I.diam_Icc_le_of_distortion_le i hc)
        (mul_nonneg zero_le_two h0.le)
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case convert_2
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
y : Fin n ‚Üí ‚Ñù
hy : y ‚àà Box.Icc (I.face i)
g : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
hfc : ContinuousOn (fun y ‚Ü¶ a + f' (y - x) + g y) (Box.Icc I)
Hi :
  ‚àÄ x_1 ‚àà Set.Icc (I.lower i) (I.upper i),
    Integrable (I.face i) ‚ä• ((fun y ‚Ü¶ a + f' (y - x) + g y) ‚àò e x_1) BoxAdditiveMap.volume
hg : g = fun y ‚Ü¶ (fun y ‚Ü¶ a + f' (y - x) + g y) y - a - f' (y - x)
this : ‚àÄ z ‚àà Set.Icc (I.lower i) (I.upper i), e z y ‚àà Box.Icc I
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
error:  unsolved goals
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
hfc : ContinuousOn f (Box.Icc I)
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
Hi : ‚àÄ x ‚àà Set.Icc (I.lower i) (I.upper i), Integrable (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume
this :
  ‚àÄ y ‚àà Box.Icc (I.face i),
    ‚Äñf' (Pi.single i (I.upper i - I.lower i)) - (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñ(‚àè j : Fin (n + 1), (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
        (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
          integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ ‚â§
    2 * Œµ * ‚Üëc * ‚àè j : Fin (n + 1), (I.upper j - I.lower j)","theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E}
    {f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) ‚Üí ‚Ñù}
    (hxI : x ‚àà (Box.Icc I)) {a : E} {Œµ : ‚Ñù} (h0 : 0 < Œµ)
    (hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ) {c : ‚Ñù‚â•0}
    (hc : I.distortion ‚â§ c) :
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
      (integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.lower i))
          BoxAdditiveMap.volume)‚Äñ ‚â§
      2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) ",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I) := by
        intro y hy
        refine (hŒµ y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(¬∑ ‚àò ¬∑), Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * Œµ)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e "
Mathlib/Analysis/LocallyConvex/WithSeminorms.lean,SeminormFamily.basisSets_intersect,basisSets_intersect,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  classical
    rcases p.basisSets_iff.mp hU with ‚ü®s, r‚ÇÅ, hr‚ÇÅ, hU‚ü©
    rcases p.basisSets_iff.mp hV with ‚ü®t, r‚ÇÇ, hr‚ÇÇ, hV‚ü©
    use ((s ‚à™ t).sup p).ball 0 (min r‚ÇÅ r‚ÇÇ)
    refine' ‚ü®p.basisSets_mem (s ‚à™ t) (lt_min_iff.mpr ‚ü®hr‚ÇÅ, hr‚ÇÇ‚ü©), _‚ü©
    rw [hU, hV, ball_finset_sup_eq_iInter _ _ _ (lt_min_iff.mpr ‚ü®hr‚ÇÅ, hr‚ÇÇ‚ü©),
      ball_finset_sup_eq_iInter _ _ _ hr‚ÇÅ, ball_finset_sup_eq_iInter _ _ _ hr‚ÇÇ]
    exact
      Set.subset_inter
        (Set.iInter‚ÇÇ_mono' fun i hi =>
          ‚ü®i, Finset.subset_union_left _ _ hi, ball_mono <| min_le_left _ _‚ü©)
        (Set.iInter‚ÇÇ_mono' fun i hi =>
          ‚ü®i, Finset.subset_union_right _ _ hi, ball_mono <| min_le_right _ _‚ü©)","error:  function expected at
  Finset.subset_union_left ?m.25600
term has type
  ?m.25599 ‚àà ?m.25597 ‚à™ ?m.25598
error:  function expected at
  Finset.subset_union_right ?m.26759
term has type
  ?m.26758 ‚àà ?m.26756 ‚à™ ?m.26757","theorem basisSets_intersect (U V : Set E) (hU : U ‚àà p.basisSets) (hV : V ‚àà p.basisSets) :
    ‚àÉ z ‚àà p.basisSets, z ‚äÜ U ‚à© V ",":= by
  classical
    rcases p.basisSets_iff.mp hU with ‚ü®s, r‚ÇÅ, hr‚ÇÅ, hU‚ü©
    rcases p.basisSets_iff.mp hV with ‚ü®t, r‚ÇÇ, hr‚ÇÇ, hV‚ü©
    use ((s ‚à™ t).sup p).ball 0 (min r‚ÇÅ r‚ÇÇ)
    refine ‚ü®p.basisSets_mem (s ‚à™ t) (lt_min_iff.mpr ‚ü®hr‚ÇÅ, hr‚ÇÇ‚ü©), ?_‚ü©
    rw [hU, hV, ball_finset_sup_eq_iInter _ _ _ (lt_min_iff.mpr ‚ü®hr‚ÇÅ, hr‚ÇÇ‚ü©),
      ball_finset_sup_eq_iInter _ _ _ hr‚ÇÅ, ball_finset_sup_eq_iInter _ _ _ hr‚ÇÇ]
    exact
      Set.subset_inter
        (Set.iInter‚ÇÇ_mono' fun i hi =>
          ‚ü®i, Finset.subset_union_left hi, ball_mono <| min_le_left _ _‚ü©)
        (Set.iInter‚ÇÇ_mono' fun i hi =>
          ‚ü®i, Finset.subset_union_right hi, ball_mono <| min_le_right _ _‚ü©)",":= by
  classical
    rcases p.basisSets_iff.mp hU with ‚ü®s, r‚ÇÅ, hr‚ÇÅ, hU‚ü©
    rcases p.basisSets_iff.mp hV with ‚ü®t, r‚ÇÇ, hr‚ÇÇ, hV‚ü©
    use ((s ‚à™ t).sup p).ball 0 (min r‚ÇÅ r‚ÇÇ)
    refine ‚ü®p.basisSets_mem (s ‚à™ t) (lt_min_iff.mpr ‚ü®hr‚ÇÅ, hr‚ÇÇ‚ü©), ?_‚ü©
    rw [hU, hV, ball_finset_sup_eq_iInter _ _ _ hr‚ÇÅ, ball_finset_sup_eq_iInter _ _ _ hr‚ÇÇ]
    exact
      Set.subset_inter
        (Set.iInter‚ÇÇ_mono' fun i hi =>
          ‚ü®i, Finset.subset_union_left _ _ hi, ball_mono <| min_le_right _ _‚ü©)"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, _‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine'
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' ‚ü®hus, hsv.symm, ‚ü®x, _, _‚ü©, _‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right _ _, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) _
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 ‚àà ?m.92170 ‚à™ ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 ‚àà ?m.92636 ‚à™ ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 ‚àà ?m.94503 ‚à™ ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 ‚àà ?m.97297 ‚à™ ?m.97298
error:  function expected at
  subset_union_left ?m.98875
term has type
  ?m.98874 ‚àà ?m.98872 ‚à™ ?m.98873","theorem shadow_compression_subset_compression_shadow (u v : Finset Œ±)
    (huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú) :
    ‚àÇ (ùìí u v ùíú) ‚äÜ ùìí u v (‚àÇ ùíú) ",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine mem_shadow_iff.2
        ‚ü®(t ‚äî u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) ?_
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
           sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx "
Mathlib/Combinatorics/SetFamily/Shadow.lean,Finset.mem_upShadow_iff_exists_sdiff,mem_upShadow_iff_exists_sdiff,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  simp_rw [mem_upShadow_iff, ‚Üêcovby_iff_card_sdiff_eq_one, covby_iff_exists_insert]","warning:  @shadow does not have a doc string
warning:  @upShadow does not have a doc string
error:  unknown identifier 'covby_iff_card_sdiff_eq_one'
error:  simp made no progress","lemma mem_upShadow_iff_exists_sdiff : t ‚àà ‚àÇ‚Å∫ ùíú ‚Üî ‚àÉ s ‚àà ùíú, s ‚äÜ t ‚àß (t \ s).card = 1 ",":= by
  simp_rw [mem_upShadow_iff, ‚Üê covBy_iff_card_sdiff_eq_one, covBy_iff_exists_insert]",":= by
  simp_rw [mem_upShadow_iff, covBy_iff_exists_insert]"
Mathlib/Order/Filter/Lift.lean,Filter.HasBasis.mem_lift_iff,HasBasis.mem_lift_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine' (mem_biInf_of_directed _ ‚ü®univ, univ_sets _‚ü©).trans _
  ¬∑ intro t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ
    exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm <| inter_subset_left _ _, gm <| inter_subset_right _ _‚ü©
  ¬∑ simp only [‚Üê (hg _).mem_iff]
    exact hf.exists_iff fun t‚ÇÅ t‚ÇÇ ht H => gm ht H","error:  function expected at
  inter_subset_left ?m.2034
term has type
  ?m.2033 ‚àà ?m.2031
error:  function expected at
  inter_subset_right ?m.2080
term has type
  ?m.2079 ‚àà ?m.2078","theorem HasBasis.mem_lift_iff {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {f : Filter Œ±}
    (hf : f.HasBasis p s) {Œ≤ : Œπ ‚Üí Type*} {pg : ‚àÄ i, Œ≤ i ‚Üí Prop} {sg : ‚àÄ i, Œ≤ i ‚Üí Set Œ≥}
    {g : Set Œ± ‚Üí Filter Œ≥} (hg : ‚àÄ i, (g <| s i).HasBasis (pg i) (sg i)) (gm : Monotone g)
    {s : Set Œ≥} : s ‚àà f.lift g ‚Üî ‚àÉ i, p i ‚àß ‚àÉ x, pg i x ‚àß sg i x ‚äÜ s ",":= by
  refine (mem_biInf_of_directed ?_ ‚ü®univ, univ_sets _‚ü©).trans ?_
  ¬∑ intro t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ
    exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm inter_subset_left, gm inter_subset_right‚ü©
  ¬∑ simp only [‚Üê (hg _).mem_iff]
    exact hf.exists_iff fun t‚ÇÅ t‚ÇÇ ht H => gm ht H",":= by
  refine (mem_biInf_of_directed _ ‚ü®univ, univ_sets _‚ü©).trans ?_
  ¬∑ intro t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ
    exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm <| inter_subset_left, gm <| inter_subset_right‚ü©
  ¬∑ simp only [‚Üê (hg _).mem_iff]
    exact hf.exists_iff fun t‚ÇÅ t‚ÇÇ ht H => gm ht H"
Mathlib/Analysis/Analytic/Uniqueness.lean,AnalyticOn.eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux,eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux,4a37a8e778eb3014aeb05af1b09f6de104536d53,":= by
  let u := {x | f =·∂†[ùìù x] 0}
  suffices main : closure u ‚à© U ‚äÜ u
  ¬∑ have Uu : U ‚äÜ u :=
      hU.subset_of_closure_inter_subset isOpen_setOf_eventually_nhds ‚ü®z‚ÇÄ, h‚ÇÄ, hfz‚ÇÄ‚ü© main
    intro z hz
    simpa using mem_of_mem_nhds (Uu hz)
  rintro x ‚ü®xu, xU‚ü©
  rcases hf x xU with ‚ü®p, r, hp‚ü©
  obtain ‚ü®y, yu, hxy‚ü© : ‚àÉ y ‚àà u, edist x y < r / 2
  exact EMetric.mem_closure_iff.1 xu (r / 2) (ENNReal.half_pos hp.r_pos.ne')
  let q := p.changeOrigin (y - x)
  have has_series : HasFPowerSeriesOnBall f q y (r / 2) := by
    have A : (‚Äñy - x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < r / 2 := by rwa [edist_comm, edist_eq_coe_nnnorm_sub] at hxy
    have := hp.changeOrigin (A.trans_le ENNReal.half_le_self)
    simp only [add_sub_cancel'_right] at this
    apply this.mono (ENNReal.half_pos hp.r_pos.ne')
    apply ENNReal.le_sub_of_add_le_left ENNReal.coe_ne_top
    apply (add_le_add A.le (le_refl (r / 2))).trans (le_of_eq _)
    exact ENNReal.add_halves _
  have M : EMetric.ball y (r / 2) ‚àà ùìù x := EMetric.isOpen_ball.mem_nhds hxy
  filter_upwards [M] with z hz
  have A : HasSum (fun n : ‚Ñï => q n fun _ : Fin n => z - y) (f z) := has_series.hasSum_sub hz
  have B : HasSum (fun n : ‚Ñï => q n fun _ : Fin n => z - y) 0 := by
    have : HasFPowerSeriesAt 0 q y := has_series.hasFPowerSeriesAt.congr yu
    convert hasSum_zero (Œ± := F) using 2
    ext n
    exact this.apply_eq_zero n _
  exact HasSum.unique A B",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux [CompleteSpace F] {f : E ‚Üí F} {U : Set E}
    (hf : AnalyticOn ùïú f U) (hU : IsPreconnected U) {z‚ÇÄ : E} (h‚ÇÄ : z‚ÇÄ ‚àà U) (hfz‚ÇÄ : f =·∂†[ùìù z‚ÇÄ] 0) :
    EqOn f 0 U ",":= by
  let u := {x | f =·∂†[ùìù x] 0}
  suffices main : closure u ‚à© U ‚äÜ u by
    have Uu : U ‚äÜ u :=
      hU.subset_of_closure_inter_subset isOpen_setOf_eventually_nhds ‚ü®z‚ÇÄ, h‚ÇÄ, hfz‚ÇÄ‚ü© main
    intro z hz
    simpa using mem_of_mem_nhds (Uu hz)
  rintro x ‚ü®xu, xU‚ü©
  rcases hf x xU with ‚ü®p, r, hp‚ü©
  obtain ‚ü®y, yu, hxy‚ü© : ‚àÉ y ‚àà u, edist x y < r / 2 :=
    EMetric.mem_closure_iff.1 xu (r / 2) (ENNReal.half_pos hp.r_pos.ne')
  let q := p.changeOrigin (y - x)
  have has_series : HasFPowerSeriesOnBall f q y (r / 2) := by
    have A : (‚Äñy - x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < r / 2 := by rwa [edist_comm, edist_eq_coe_nnnorm_sub] at hxy
    have := hp.changeOrigin (A.trans_le ENNReal.half_le_self)
    simp only [add_sub_cancel] at this
    apply this.mono (ENNReal.half_pos hp.r_pos.ne')
    apply ENNReal.le_sub_of_add_le_left ENNReal.coe_ne_top
    apply (add_le_add A.le (le_refl (r / 2))).trans (le_of_eq _)
    exact ENNReal.add_halves _
  have M : EMetric.ball y (r / 2) ‚àà ùìù x := EMetric.isOpen_ball.mem_nhds hxy
  filter_upwards [M] with z hz
  have A : HasSum (fun n : ‚Ñï => q n fun _ : Fin n => z - y) (f z) := has_series.hasSum_sub hz
  have B : HasSum (fun n : ‚Ñï => q n fun _ : Fin n => z - y) 0 := by
    have : HasFPowerSeriesAt 0 q y := has_series.hasFPowerSeriesAt.congr yu
    convert hasSum_zero (Œ± := F) using 2
    ext n
    exact this.apply_eq_zero n _
  exact HasSum.unique A B",":= by
  let u := {x | f =·∂†[ùìù x] 0}
  suffices main : closure u ‚à© U ‚äÜ u by
    have Uu : U ‚äÜ u :=
      hU.subset_of_closure_inter_subset isOpen_setOf_eventually_nhds ‚ü®z‚ÇÄ, h‚ÇÄ, hfz‚ÇÄ‚ü© main
    intro z hz
    simpa using mem_of_mem_nhds (Uu hz)
  rintro x ‚ü®xu, xU‚ü©
  rcases hf x xU with ‚ü®p, r, hp‚ü©
  obtain ‚ü®y, yu, hxy‚ü© : ‚àÉ y ‚àà u, edist x y < r / 2
  exact EMetric.mem_closure_iff.1 xu (r / 2) (ENNReal.half_pos hp.r_pos.ne')
  let q := p.changeOrigin (y - x)
  have has_series : HasFPowerSeriesOnBall f q y (r / 2) := by
    have A : (‚Äñy - x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < r / 2 := by rwa [edist_comm, edist_eq_coe_nnnorm_sub] at hxy
    have := hp.changeOrigin (A.trans_le ENNReal.half_le_self)
    simp only [add_sub_cancel_right] at this
    apply this.mono (ENNReal.half_pos hp.r_pos.ne')
    apply ENNReal.le_sub_of_add_le_left ENNReal.coe_ne_top
    apply (add_le_add A.le (le_refl (r / 2))).trans (le_of_eq _)
    exact ENNReal.add_halves _
  have M : EMetric.ball y (r / 2) ‚àà ùìù x := EMetric.isOpen_ball.mem_nhds hxy
  filter_upwards [M] with z hz
  have A : HasSum (fun n : ‚Ñï => q n fun _ : Fin n => z - y) (f z) := has_series.hasSum_sub hz
  have B : HasSum (fun n : ‚Ñï => q n fun _ : Fin n => z - y) 0 := by
    have : HasFPowerSeriesAt 0 q y := has_series.hasFPowerSeriesAt.congr yu
    convert hasSum_zero (Œ± := F) using 2
    ext n
    exact this.apply_eq_zero n _
  exact HasSum.unique A B"
Mathlib/Order/MinMax.lean,min_cases,min_cases,a9a1f7d7266a51942458f829f615d2f63c88c586,":= by
  by_cases a ‚â§ b
  ¬∑ left
    exact ‚ü®min_eq_left h, h‚ü©

  ¬∑ right
    exact ‚ü®min_eq_right (le_of_lt (not_le.mp h)), not_le.mp h‚ü©","error:  unknown identifier 'h'
error:  unknown identifier 'h'
error:  unknown identifier 'h'
error:  unknown identifier 'h'",theorem min_cases (a b : Œ±) : min a b = a ‚àß a ‚â§ b ‚à® min a b = b ‚àß b < a ,":= by
  by_cases h : a ‚â§ b
  ¬∑ left
    exact ‚ü®min_eq_left h, h‚ü©
  ¬∑ right
    exact ‚ü®min_eq_right (le_of_lt (not_le.mp h)), not_le.mp h‚ü©",":= by
  by_cases a ‚â§ b
  ¬∑ left
    exact ‚ü®min_eq_left h, h‚ü©
  ¬∑ right
    exact ‚ü®min_eq_right (le_of_lt (not_le.mp h)), not_le.mp h‚ü©"
Mathlib/Analysis/Convolution.lean,MeasureTheory.hasFDerivAt_convolution_right_with_param,hasFDerivAt_convolution_right_with_param,c8e0e8e80426a957d3b0b5ef46be522d07640e5a,":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine' (hasFDerivAt_zero_of_eventually_const 0 _).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s := Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine' ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, _, _‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C := ht.subset_closedBall_lt 0 0
    refine' ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => _‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine' mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), _, _‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine' (HasCompactSupport.convolutionExists_right L _ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº :=
    hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine' ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, _‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    filter_upwards with a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    filter_upwards with a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, id.def, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6","error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1590085 ‚Üí ?m.1590085
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.1590392 ‚Üí ?m.1590392
  
  unknown constant 'ContinuousLinearMap.id.def'
error:  unsolved goals
case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.1 = (_root_.id x).1

case h.a
ùïú : Type uùïú
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
inst‚úù¬π‚Å∂ : NormedAddCommGroup E
inst‚úù¬π‚Åµ : NormedAddCommGroup E'
inst‚úù¬π‚Å¥ : NormedAddCommGroup E''
inst‚úù¬π¬≥ : NormedAddCommGroup F
f f' : G ‚Üí E
g‚úù g'‚úù : G ‚Üí E'
x‚úù¬π x' : G
y y' : E
inst‚úù¬π¬≤ : RCLike ùïú
inst‚úù¬π¬π : NormedSpace ùïú E
inst‚úù¬π‚Å∞ : NormedSpace ùïú E'
inst‚úù‚Åπ : NormedSpace ùïú E''
inst‚úù‚Å∏ : NormedSpace ‚Ñù F
inst‚úù‚Å∑ : NormedSpace ùïú F
inst‚úù‚Å∂ : CompleteSpace F
inst‚úù‚Åµ : MeasurableSpace G
inst‚úù‚Å¥ : NormedAddCommGroup G
inst‚úù¬≥ : BorelSpace G
inst‚úù¬≤ : NormedSpace ùïú G
inst‚úù¬π : NormedAddCommGroup P
inst‚úù : NormedSpace ùïú P
Œº : Measure G
L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F
g : P ‚Üí G ‚Üí E'
s : Set P
k : Set G
hs : IsOpen s
hk : IsCompact k
hgs : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0
hf : LocallyIntegrable f Œº
hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)
q‚ÇÄ : P √ó G
hq‚ÇÄ : q‚ÇÄ.1 ‚àà s
g' : P √ó G ‚Üí P √ó G ‚ÜíL[ùïú] E' := fderiv ùïú ‚Üøg
A : ‚àÄ p ‚àà s, Continuous (g p)
A' : ‚àÄ (q : P √ó G), q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q
g'_zero : ‚àÄ (p : P) (x : G), p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0
Œµ C : ‚Ñù
Œµpos : 0 < Œµ
h‚ÇÄŒµ : ball q‚ÇÄ.1 Œµ ‚äÜ s
hŒµ : ‚àÄ (p : P) (x : G), ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C
I1 : ‚àÄ·∂† (x : P √ó G) in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)) (g x.1 (x.2 - a))) Œº
I2 : Integrable (fun a ‚Ü¶ (L (f a)) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº
I3 : AEStronglyMeasurable (fun a ‚Ü¶ (L (f a)).comp (g' (q‚ÇÄ.1, q‚ÇÄ.2 - a))) Œº
K' : Set G := -k + {q‚ÇÄ.2}
K'_def : K' = -k + {q‚ÇÄ.2}
hK' : IsCompact K'
U : Set G
U_open : IsOpen U
K'U : K' ‚äÜ U
hU : IntegrableOn f U Œº
Œ¥ : ‚Ñù
Œ¥pos : 0 < Œ¥
Œ¥Œµ : Œ¥ ‚â§ Œµ
hŒ¥ : K' + ball 0 Œ¥ ‚äÜ U
this : Norm (E ‚ÜíL[ùïú] (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) := hasOpNorm
bound : G ‚Üí ‚Ñù := U.indicator fun t ‚Ü¶ ‚ÄñprecompR (P √ó G) L‚Äñ * ‚Äñf t‚Äñ * C
I4 : ‚àÄ·µê (a : G) ‚àÇŒº, ‚àÄ (x : P √ó G), dist x q‚ÇÄ < Œ¥ ‚Üí ‚Äñ((precompR (P √ó G) L) (f a)) (g' (x.1, x.2 - a))‚Äñ ‚â§ bound a
I5 : Integrable bound Œº
a : G
x‚úù : P √ó G
hx : dist x‚úù q‚ÇÄ < Œ¥
N : s √óÀ¢ univ ‚àà ùìù (x‚úù.1, x‚úù.2 - a)
Z : HasFDerivAt (‚Üøg) (fderiv ùïú (‚Üøg) (x‚úù.1, x‚úù.2 - a)) (x‚úù.1, x‚úù.2 - a)
x : P √ó G
‚ä¢ x.2 - a = (_root_.id x).2 - a","theorem hasFDerivAt_convolution_right_with_param {g : P ‚Üí G ‚Üí E'} {s : Set P} {k : Set G}
    (hs : IsOpen s) (hk : IsCompact k) (hgs : ‚àÄ p, ‚àÄ x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g p x = 0)
    (hf : LocallyIntegrable f Œº) (hg : ContDiffOn ùïú 1 (‚Üøg) (s √óÀ¢ univ)) (q‚ÇÄ : P √ó G)
    (hq‚ÇÄ : q‚ÇÄ.1 ‚àà s) :
    HasFDerivAt (fun q : P √ó G => (f ‚ãÜ[L, Œº] g q.1) q.2)
      ((f ‚ãÜ[L.precompR (P √ó G), Œº] fun x : G => fderiv ùïú (‚Üøg) (q‚ÇÄ.1, x)) q‚ÇÄ.2) q‚ÇÄ ",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s := Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans (ball_subset_ball (min_le_right _ _)) hŒ¥
    obtain ‚ü®C, Cpos, hC‚ü© : ‚àÉ C, 0 < C ‚àß g' '' t ‚äÜ closedBall 0 C := ht.subset_closedBall_lt 0 0
    refine ‚ü®Œµ, C, Œµpos, h'Œµ, fun p x hp => ?_‚ü©
    have hps : p ‚àà s := h'Œµ (mem_ball_iff_norm.2 hp)
    by_cases hx : x ‚àà k
    ¬∑ have H : (p, x) ‚àà t := by
        apply hŒµ
        refine mem_thickening_iff.2 ‚ü®(q‚ÇÄ.1, x), ?_, ?_‚ü©
        ¬∑ simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        ¬∑ rw [‚Üê dist_eq_norm] at hp
          simpa only [Prod.dist_eq, Œµpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ‚àà closedBall (0 : P √ó G ‚ÜíL[ùïú] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    ¬∑ have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ‚àÄ·∂† x : P √ó G in ùìù q‚ÇÄ, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Œº := by
    filter_upwards [A' q‚ÇÄ hq‚ÇÄ]
    rintro ‚ü®p, x‚ü© ‚ü®hp, -‚ü©
    refine (HasCompactSupport.convolutionExists_right L ?_ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q‚ÇÄ.1 (q‚ÇÄ.2 - a))) Œº := by
    have M : HasCompactSupport (g q‚ÇÄ.1) := HasCompactSupport.intro hk fun x hx => hgs q‚ÇÄ.1 x hq‚ÇÄ hx
    apply M.convolutionExists_right L hf (A q‚ÇÄ.1 hq‚ÇÄ) q‚ÇÄ.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q‚ÇÄ.fst, q‚ÇÄ.snd - a))) Œº := by
    have T : HasCompactSupport fun y => g' (q‚ÇÄ.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q‚ÇÄ.1 x hq‚ÇÄ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P √ó G) : _) T hf _ q‚ÇÄ.2).1
    have : ContinuousOn g' (s √óÀ¢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq‚ÇÄ
  set K' := (-k + {q‚ÇÄ.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ‚ü®U, U_open, K'U, hU‚ü© : ‚àÉ U, IsOpen U ‚àß K' ‚äÜ U ‚àß IntegrableOn f U Œº :=
    hf.integrableOn_nhds_isCompact hK'
  obtain ‚ü®Œ¥, Œ¥pos, Œ¥Œµ, hŒ¥‚ü© : ‚àÉ Œ¥, (0 : ‚Ñù) < Œ¥ ‚àß Œ¥ ‚â§ Œµ ‚àß K' + ball 0 Œ¥ ‚äÜ U := by
    obtain ‚ü®V, V_mem, hV‚ü© : ‚àÉ V ‚àà ùìù (0 : G), K' + V ‚äÜ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
    refine ‚ü®min Œ¥ Œµ, lt_min Œ¥pos Œµpos, min_le_right Œ¥ Œµ, ?_‚ü©
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hŒ¥)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (ùïú := ùïú) (ùïú‚ÇÇ := ùïú) (E := E)
    (F := (P √ó G ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] P √ó G ‚ÜíL[ùïú] F) (œÉ‚ÇÅ‚ÇÇ := RingHom.id ùïú)
  let bound : G ‚Üí ‚Ñù := indicator U fun t => ‚Äñ(L.precompR (P √ó G))‚Äñ * ‚Äñf t‚Äñ * C
  have I4 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      ‚ÄñL.precompR (P √ó G) (f a) (g' (x.fst, x.snd - a))‚Äñ ‚â§ bound a := by
    filter_upwards with a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q‚ÇÄ.2 Œ¥ ‚äÜ U := by
      apply Subset.trans _ hŒ¥
      rw [K'_def, add_assoc]
      apply add_subset_add
      ¬∑ rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h‚ÇÄŒµ _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ
      ¬∑ simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    ¬∑ intro y
      exact hŒµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Œ¥Œµ)
    ¬∑ rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound Œº := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ‚àÄ·µê a : G ‚àÇŒº, ‚àÄ x : P √ó G, dist x q‚ÇÄ < Œ¥ ‚Üí
      HasFDerivAt (fun x : P √ó G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    filter_upwards with a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s √óÀ¢ univ ‚àà ùìù (x.1, x.2 - a) := by
      apply A'
      apply h‚ÇÄŒµ
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Œ¥Œµ
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P √ó G => (x.1, x.2 - a)) (ContinuousLinearMap.id ùïú (P √ó G)) x := by
      have : (fun x : P √ó G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, _root_.id, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Œ¥pos I1 I2 I3 I4 I5 I6",":= by
  let g' := fderiv ùïú ‚Üøg
  have A : ‚àÄ p ‚àà s, Continuous (g p) := fun p hp ‚Ü¶ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ‚àÄ q : P √ó G, q.1 ‚àà s ‚Üí s √óÀ¢ univ ‚àà ùìù q := fun q hq ‚Ü¶ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ‚àÄ p x, p ‚àà s ‚Üí x ‚àâ k ‚Üí g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : k·∂ú ‚àà ùìù x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ‚àà ùìù p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ‚ü®p, y‚ü© ‚ü®hp, hy‚ü©
    exact hgs p y hp hy
  obtain ‚ü®Œµ, C, Œµpos, h‚ÇÄŒµ, hŒµ‚ü© :
      ‚àÉ Œµ C, 0 < Œµ ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s ‚àß ‚àÄ p x, ‚Äñp - q‚ÇÄ.1‚Äñ < Œµ ‚Üí ‚Äñg' (p, x)‚Äñ ‚â§ C := by
    have A : IsCompact ({q‚ÇÄ.1} √óÀ¢ k) := isCompact_singleton.prod hk
    obtain ‚ü®t, kt, t_open, ht‚ü© : ‚àÉ t, {q‚ÇÄ.1} √óÀ¢ k ‚äÜ t ‚àß IsOpen t ‚àß IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s √óÀ¢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq‚ÇÄ, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ‚ü®Œµ, Œµpos, hŒµ, h'Œµ‚ü© :
      ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß thickening Œµ ({q‚ÇÄ.fst} √óÀ¢ k) ‚äÜ t ‚àß ball q‚ÇÄ.1 Œµ ‚äÜ s := by
      obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß thickening Œµ (({q‚ÇÄ.fst} : Set P) √óÀ¢ k) ‚äÜ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œ¥ ‚àß ball q‚ÇÄ.1 Œ¥ ‚äÜ s := Metric.isOpen_iff.1 hs _ hq‚ÇÄ
      refine ‚ü®min Œµ Œ¥, lt_min Œµpos Œ¥pos, ?_, ?_‚ü©
      ¬∑ exact Subset.trans (thickening_mono (min_le_left _ _) _) hŒµ
      ¬∑ exact Subset.trans"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,2d8928f07c222f171d2f9371935aa5b8359f9d44,":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine' Or.inl ‚ü®hs, _‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, _‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine'
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' ‚ü®hus, hsv.symm, ‚ü®x, _, _‚ü©, _‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right _ _, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) _
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 ‚àà ?m.92170 ‚à™ ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 ‚àà ?m.92636 ‚à™ ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 ‚àà ?m.94503 ‚à™ ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 ‚àà ?m.97297 ‚à™ ?m.97298
error:  function expected at
  subset_union_left ?m.98875
term has type
  ?m.98874 ‚àà ?m.98872 ‚à™ ?m.98873","theorem shadow_compression_subset_compression_shadow (u v : Finset Œ±)
    (huv : ‚àÄ x ‚àà u, ‚àÉ y ‚àà v, IsCompressed (u.erase x) (v.erase y) ùíú) :
    ‚àÇ (ùìí u v ùíú) ‚äÜ ùìí u v (‚àÇ ùíú) ",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine mem_shadow_iff.2
        ‚ü®(t ‚äî u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ‚àâ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‚ÄπDisjoint v u‚Ä∫.sdiff_eq_left
  have : x ‚àâ u := by
    intro hxu
    obtain ‚ü®y, hyv, hxy‚ü© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ‚à™ v) \ u ‚à™ erase u x) \ erase v y ‚àà ùíú := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‚Äπv \ u = v‚Ä∫]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‚Äπx ‚àà u‚Ä∫, erase_union_distrib,
      erase_insert ‚Äπx ‚àâ s‚Ä∫, erase_eq_of_not_mem ‚Äπx ‚àâ v‚Ä∫, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ‚äÜ s := by rwa [‚Üê erase_eq_of_not_mem ‚Äπx ‚àâ u‚Ä∫, ‚Üê subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ‚ü®hus, hsv.symm, ‚ü®x, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ‚ü®‚Äπx ‚àâ s‚Ä∫, ‚Äπx ‚àâ v‚Ä∫‚ü©)
  ¬∑ rwa [‚Üê insert_sdiff_of_not_mem _ ‚Äπx ‚àâ u‚Ä∫, ‚Üê insert_union]
  rintro ‚ü®w, hwB, hwùíú'‚ü©
  have : v ‚äÜ insert w ((s ‚à™ v) \ u) :=
    (subset_sdiff.2 ‚ü®subset_union_right, hvu‚ü©).trans (subset_insert _ _)
  by_cases hwu : w ‚àà u
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ‚à™ v) \ u) ‚àà ùíú := mem_of_mem_compression hwùíú' ‚Äπ_‚Ä∫ (aux huv)
    have : (insert w ((s ‚à™ v) \ u) ‚à™ erase u w) \ erase v z ‚àà ùíú := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‚Äπ_‚Ä∫) ?_
      rw [‚Üê sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‚Äπw ‚àà u‚Ä∫,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‚Äπz ‚àà v‚Ä∫), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ‚Üê Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ‚àò hwB ‚àò mem_union_left _)
  have : (insert w ((s ‚à™ v) \ u) ‚à™ u) \ v ‚àà ùíú :=
    sup_sdiff_mem_of_mem_compression ‚Äπinsert w ((s ‚à™ v) \ u) ‚àà ùíú'‚Ä∫ ‚Äπ_‚Ä∫
      (disjoint_insert_right.2 ‚ü®‚Äπ_‚Ä∫, disjoint_sdiff‚ü©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ‚àò hwB ‚àò mem_union_right _), union_sdiff_cancel_right hsv]",":= by
  set ùíú' := ùìí u v ùíú
  suffices H : ‚àÄ s ‚àà ‚àÇ ùíú',
      s ‚àâ ‚àÇ ùíú ‚Üí u ‚äÜ s ‚àß Disjoint v s ‚àß (s ‚à™ v) \ u ‚àà ‚àÇ ùíú ‚àß (s ‚à™ v) \ u ‚àâ ‚àÇ ùíú' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ‚àà ùíú.shadow
    swap
    ¬∑ obtain ‚ü®hus, hvs, h, _‚ü© := H _ hs' hs
      exact Or.inr ‚ü®hs, _, h, compress_of_disjoint_of_le' hvs hus‚ü©
    refine Or.inl ‚ü®hs, ?_‚ü©
    rw [compress]
    split_ifs with huvs
    swap
    ¬∑ exact hs
    rw [mem_shadow_iff] at hs'
    obtain ‚ü®t, Ht, a, hat, rfl‚ü© := hs'
    have hav : a ‚àâ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ‚â§ t := huvs.2.trans (erase_subset _ t)
    have ht : t ‚àà ùíú := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ‚àà u
    ¬∑ obtain ‚ü®b, hbv, Hcomp‚ü© := huv a hau
      refine mem_shadow_iff_insert_mem.2 ‚ü®b, not_mem_sdiff_of_mem_right hbv, ?_‚ü©
      rw [‚Üê Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ‚Üê
        erase_union_of_mem hau] at hsb
    ¬∑ refine
        mem_shadow_iff.2
          ‚ü®(t ‚äî u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_‚ü©
      ¬∑ rw [sup_eq_union, mem_sdiff, mem_union]
        exact ‚ü®Or.inl hat, hav‚ü©
      ¬∑ rw [‚Üê erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsùíú' hsùíú
  have m : ‚àÄ y, y ‚àâ s ‚Üí insert y s ‚àâ ùíú := fun y h a => hsùíú (mem_shadow_iff_insert_mem.2 ‚ü®y, h, a‚ü©)
  obtain ‚ü®x, _, _‚ü© := mem_shadow_iff_insert_mem.1 hsùíú'
  have hus : u ‚äÜ insert x s := le_of_mem_compression_of_not_mem ‚Äπ_ ‚àà ùíú'‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx ‚àâ s‚Ä∫)
  have : (insert x s ‚à™ v) \ u ‚àà ùíú := sup_sdiff_mem_of_mem_compression_of_not_mem ‚Äπ_‚Ä∫ (m _ ‚Äπx"
Mathlib/SetTheory/Cardinal/Cofinality.lean,Ordinal.ord_cof_eq,ord_cof_eq,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  let ‚ü®S, hS, e‚ü© := cof_eq r
  let ‚ü®s, _, e'‚ü© := Cardinal.ord_eq S
  let T : Set Œ± := { a | ‚àÉ aS : a ‚àà S, ‚àÄ b : S, s b ‚ü®_, aS‚ü© ‚Üí r b a }
  suffices Unbounded r T by
    refine ‚ü®T, this, le_antisymm ?_ (Cardinal.ord_le.2 <| cof_type_le this)‚ü©
    rw [‚Üê e, e']
    refine
      (RelEmbedding.ofMonotone
          (fun a : T =>
            (‚ü®a,
                let ‚ü®aS, _‚ü© := a.2
                aS‚ü© :
              S))
          fun a b h => ?_).ordinal_type_le
    rcases a with ‚ü®a, aS, ha‚ü©
    rcases b with ‚ü®b, bS, hb‚ü©
    change s ‚ü®a, _‚ü© ‚ü®b, _‚ü©
    refine ((trichotomous_of s _ _).resolve_left fun hn => ?_).resolve_left? _
    ¬∑ exact asymm h (ha _ hn)
    ¬∑ intro e
      injection e with e
      subst b
      exact irrefl _ h
  intro a
  have : { b : S | ¬¨r b a }.Nonempty :=
    let ‚ü®b, bS, ba‚ü© := hS a
    ‚ü®‚ü®b, bS‚ü©, ba‚ü©
  let b := (IsWellFounded.wf : WellFounded s).min _ this
  have ba : ¬¨r b a := IsWellFounded.wf.min_mem _ this
  refine ‚ü®b, ‚ü®b.2, fun c => not_imp_not.1 fun h => ?_‚ü©, ba‚ü©
  rw [show ‚àÄ b : S, (‚ü®b, b.2‚ü© : S) = b by intro b; cases b; rfl]
  exact IsWellFounded.wf.not_lt_min _ this (IsOrderConnected.neg_trans h ba)","error:  invalid field 'resolve_left?', the environment does not contain 'Or.resolve_left?'
  Or.resolve_left (trichotomous_of s ?m.18531 ?m.18532) fun hn ‚Ü¶ ?m.18555 hn
has type
  ?m.18531 = ?m.18532 ‚à® s ?m.18532 ?m.18531
error:  no goals to be solved","theorem ord_cof_eq (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsWellOrder Œ± r] :
    ‚àÉ S, Unbounded r S ‚àß type (Subrel r S) = (cof (type r)).ord ",":= by
  let ‚ü®S, hS, e‚ü© := cof_eq r
  let ‚ü®s, _, e'‚ü© := Cardinal.ord_eq S
  let T : Set Œ± := { a | ‚àÉ aS : a ‚àà S, ‚àÄ b : S, s b ‚ü®_, aS‚ü© ‚Üí r b a }
  suffices Unbounded r T by
    refine ‚ü®T, this, le_antisymm ?_ (Cardinal.ord_le.2 <| cof_type_le this)‚ü©
    rw [‚Üê e, e']
    refine
      (RelEmbedding.ofMonotone
          (fun a : T =>
            (‚ü®a,
                let ‚ü®aS, _‚ü© := a.2
                aS‚ü© :
              S))
          fun a b h => ?_).ordinal_type_le
    rcases a with ‚ü®a, aS, ha‚ü©
    rcases b with ‚ü®b, bS, hb‚ü©
    change s ‚ü®a, _‚ü© ‚ü®b, _‚ü©
    refine ((trichotomous_of s _ _).resolve_left fun hn => ?_).resolve_left ?_
    ¬∑ exact asymm h (ha _ hn)
    ¬∑ intro e
      injection e with e
      subst b
      exact irrefl _ h
  intro a
  have : { b : S | ¬¨r b a }.Nonempty :=
    let ‚ü®b, bS, ba‚ü© := hS a
    ‚ü®‚ü®b, bS‚ü©, ba‚ü©
  let b := (IsWellFounded.wf : WellFounded s).min _ this
  have ba : ¬¨r b a := IsWellFounded.wf.min_mem _ this
  refine ‚ü®b, ‚ü®b.2, fun c => not_imp_not.1 fun h => ?_‚ü©, ba‚ü©
  rw [show ‚àÄ b : S, (‚ü®b, b.2‚ü© : S) = b by intro b; cases b; rfl]
  exact IsWellFounded.wf.not_lt_min _ this (IsOrderConnected.neg_trans h ba)",":= by
  let ‚ü®S, hS, e‚ü© := cof_eq r
  let ‚ü®s, _, e'‚ü© := Cardinal.ord_eq S
  let T : Set Œ± := { a | ‚àÉ aS : a ‚àà S, ‚àÄ b : S, s b ‚ü®_, aS‚ü© ‚Üí r b a }
  suffices Unbounded r T by
    refine ‚ü®T, this, le_antisymm ?_ (Cardinal.ord_le.2 <| cof_type_le this)‚ü©
    rw [‚Üê e, e']
    refine
      (RelEmbedding.ofMonotone
          (fun a : T =>
              (‚ü®a,
                let ‚ü®aS, _‚ü© := a.2
                 aS‚ü© :
             S))
          fun a b h => ?_).ordinal_type_le
    rcases a with ‚ü®a, aS, ha‚ü©
    rcases b with ‚ü®b, bS, hb‚ü©
    change s ‚ü®a, _‚ü© ‚ü®b, _‚ü©
    refine ((trichotomous_of s _ _).resolve_left fun hn => ?_).resolve_left ?_
    ¬∑ exact asymm h (ha _ hn)
    ¬∑ intro e
      injection e with e
      subst b
      exact irrefl _ h
  intro a
  have : { b : S | ¬¨r b a }.Nonempty :=
    let ‚ü®b, bS, ba‚ü© := hS a
    ‚ü®‚ü®b, bS‚ü©, ba‚ü©
  let b := (IsWellFounded.wf : WellFounded s).min _ this
  have ba : ¬¨r b a := IsWellFounded.wf.min_mem _ this
  refine ‚ü®b, ‚ü®b.2, fun c => not_imp_not.1 fun h => ?_‚ü©, ba‚ü©
  rw [show ‚àÄ b : S, (‚ü®b, b.2‚ü© : S) = b by intro b; cases b; rfl]
  exact IsWellFounded.wf.not_lt_min _ this (IsOrderConnected.neg_trans h ba)"
Mathlib/Analysis/Convex/Segment.lean,openSegment_subset_union,openSegment_subset_union,ed737e5773cdf087080f52542509535e7446ced4,":= by
  rcases hz with ‚ü®c, rfl‚ü©
  simp only [openSegment_eq_image_lineMap, ‚Üê mapsTo']
  rintro a ‚ü®h‚ÇÄ, h‚ÇÅ‚ü©
  rcases lt_trichotomy a c with (hac | rfl | hca)
  ¬∑ right
    left
    have hc : 0 < c := h‚ÇÄ.trans hac
    refine' ‚ü®a / c, ‚ü®div_pos h‚ÇÄ hc, (div_lt_one hc).2 hac‚ü©, _‚ü©
    simp only [‚Üê homothety_eq_lineMap, ‚Üê homothety_mul_apply, div_mul_cancel _ hc.ne']
  ¬∑ left
    rfl
  ¬∑ right
    right
    have hc : 0 < 1 - c := sub_pos.2 (hca.trans h‚ÇÅ)
    simp only [‚Üê lineMap_apply_one_sub y]
    refine'
      ‚ü®(a - c) / (1 - c), ‚ü®div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right h‚ÇÅ _‚ü©,
        _‚ü©
    simp only [‚Üê homothety_eq_lineMap, ‚Üê homothety_mul_apply, sub_mul, one_mul,
      div_mul_cancel _ hc.ne', sub_sub_sub_cancel_right]","warning:  segment does not have a doc string
error:  application type mismatch
  div_mul_cancel ?m.283314 (LT.lt.ne' hc)
argument
  LT.lt.ne' hc
has type
  c ‚â† 0 : Prop
but is expected to have type
  ?m.283312 : Type ?u.283311
error:  unsolved goals
case intro.intro.inl.h.h
ùïú : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
Œπ : Type u_5
œÄ : Œπ ‚Üí Type u_6
inst‚úù¬≤ : LinearOrderedField ùïú
inst‚úù¬π : AddCommGroup E
inst‚úù : Module ùïú E
x‚úù y‚úù z x y : E
c a : ùïú
h‚ÇÄ : 0 < a
h‚ÇÅ : a < 1
hac : a < c
hc : 0 < c
‚ä¢ (homothety x (a / c * c)) y = (homothety x a) y
error:  application type mismatch
  div_mul_cancel ?m.286960 (LT.lt.ne' hc)
argument
  LT.lt.ne' hc
has type
  1 - c ‚â† 0 : Prop
but is expected to have type
  ?m.286958 : Type ?u.286957
error:  unsolved goals
case intro.intro.inr.inr.h.h
ùïú : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
Œπ : Type u_5
œÄ : Œπ ‚Üí Type u_6
inst‚úù¬≤ : LinearOrderedField ùïú
inst‚úù¬π : AddCommGroup E
inst‚úù : Module ùïú E
x‚úù y‚úù z x y : E
c a : ùïú
h‚ÇÄ : 0 < a
h‚ÇÅ : a < 1
hca : c < a
hc : 0 < 1 - c
‚ä¢ (homothety y (1 - c - (a - c) / (1 - c) * (1 - c))) x = (homothety y (1 - a)) x","theorem openSegment_subset_union (x y : E) {z : E} (hz : z ‚àà range (lineMap x y : ùïú ‚Üí E)) :
    openSegment ùïú x y ‚äÜ insert z (openSegment ùïú x z ‚à™ openSegment ùïú z y) ",":= by
  rcases hz with ‚ü®c, rfl‚ü©
  simp only [openSegment_eq_image_lineMap, ‚Üê mapsTo']
  rintro a ‚ü®h‚ÇÄ, h‚ÇÅ‚ü©
  rcases lt_trichotomy a c with (hac | rfl | hca)
  ¬∑ right
    left
    have hc : 0 < c := h‚ÇÄ.trans hac
    refine ‚ü®a / c, ‚ü®div_pos h‚ÇÄ hc, (div_lt_one hc).2 hac‚ü©, ?_‚ü©
    simp only [‚Üê homothety_eq_lineMap, ‚Üê homothety_mul_apply, div_mul_cancel‚ÇÄ _ hc.ne']
  ¬∑ left
    rfl
  ¬∑ right
    right
    have hc : 0 < 1 - c := sub_pos.2 (hca.trans h‚ÇÅ)
    simp only [‚Üê lineMap_apply_one_sub y]
    refine
      ‚ü®(a - c) / (1 - c), ‚ü®div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right h‚ÇÅ _‚ü©,
        ?_‚ü©
    simp only [‚Üê homothety_eq_lineMap, ‚Üê homothety_mul_apply, sub_mul, one_mul,
      div_mul_cancel‚ÇÄ _ hc.ne', sub_sub_sub_cancel_right]",":= by
  rcases hz with ‚ü®c, rfl‚ü©
  simp only [openSegment_eq_image_lineMap, ‚Üê mapsTo']
  rintro a ‚ü®h‚ÇÄ, h‚ÇÅ‚ü©
  rcases lt_trichotomy a c with (hac | rfl | hca)
  ¬∑ right
    left
    have hc : 0 < c := h‚ÇÄ.trans hac
    refine ‚ü®a / c, ‚ü®div_pos h‚ÇÄ hc, (div_lt_one hc).2 hac‚ü©, ?_‚ü©
    simp only [‚Üê homothety_eq_lineMap, ‚Üê homothety_mul_apply, div_mul_cancel _ hc.ne']
  ¬∑ left
    rfl
  ¬∑ right
    right
    have hc : 0 < 1 - c := sub_pos.2 (hca.trans h‚ÇÅ)
    simp only [‚Üê lineMap_apply_one_sub y]
    refine
      ‚ü®(a - c) / (1 - c), ‚ü®div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right h‚ÇÅ _‚ü©,
        ?_‚ü©
    simp only [‚Üê homothety_eq_lineMap, ‚Üê homothety_mul_apply, sub_mul, one_mul,
      div_mul_cancel _ hc.ne', sub_sub_sub_cancel_right]"
Mathlib/Analysis/Calculus/Monotone.lean,MonotoneOn.ae_differentiableWithinAt_of_mem,MonotoneOn.ae_differentiableWithinAt_of_mem,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  apply ae_of_mem_of_ae_of_mem_inter_Ioo
  intro a b as bs _
  obtain ‚ü®g, hg, gf‚ü© : ‚àÉ g : ‚Ñù ‚Üí ‚Ñù, Monotone g ‚àß EqOn f g (s ‚à© Icc a b) :=
    (hf.mono (inter_subset_left s (Icc a b))).exists_monotone_extension
      (hf.map_bddBelow (inter_subset_left _ _) ‚ü®a, fun x hx => hx.2.1, as‚ü©)
      (hf.map_bddAbove (inter_subset_left _ _) ‚ü®b, fun x hx => hx.2.2, bs‚ü©)
  filter_upwards [hg.ae_differentiableAt] with x hx
  intro h'x
  apply hx.differentiableWithinAt.congr_of_eventuallyEq _ (gf ‚ü®h'x.1, h'x.2.1.le, h'x.2.2.le‚ü©)
  have : Ioo a b ‚àà ùìù[s] x := nhdsWithin_le_nhds (Ioo_mem_nhds h'x.2.1 h'x.2.2)
  filter_upwards [self_mem_nhdsWithin, this] with y hy h'y
  exact gf ‚ü®hy, h'y.1.le, h'y.2.le‚ü©","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set ‚Ñù : Type
but is expected to have type
  ?m.100118 ‚àà ?m.100116 ‚à© ?m.100117 : Prop
error:  function expected at
  inter_subset_left ?m.100708
term has type
  ?m.100707 ‚àà ?m.100705
error:  function expected at
  inter_subset_left ?m.100801
term has type
  ?m.100800 ‚àà ?m.100798","theorem MonotoneOn.ae_differentiableWithinAt_of_mem {f : ‚Ñù ‚Üí ‚Ñù} {s : Set ‚Ñù} (hf : MonotoneOn f s) :
    ‚àÄ·µê x, x ‚àà s ‚Üí DifferentiableWithinAt ‚Ñù f s x ",":= by
  apply ae_of_mem_of_ae_of_mem_inter_Ioo
  intro a b as bs _
  obtain ‚ü®g, hg, gf‚ü© : ‚àÉ g : ‚Ñù ‚Üí ‚Ñù, Monotone g ‚àß EqOn f g (s ‚à© Icc a b) :=
    (hf.mono inter_subset_left).exists_monotone_extension
      (hf.map_bddBelow inter_subset_left ‚ü®a, fun x hx => hx.2.1, as‚ü©)
      (hf.map_bddAbove inter_subset_left ‚ü®b, fun x hx => hx.2.2, bs‚ü©)
  filter_upwards [hg.ae_differentiableAt] with x hx
  intro h'x
  apply hx.differentiableWithinAt.congr_of_eventuallyEq _ (gf ‚ü®h'x.1, h'x.2.1.le, h'x.2.2.le‚ü©)
  have : Ioo a b ‚àà ùìù[s] x := nhdsWithin_le_nhds (Ioo_mem_nhds h'x.2.1 h'x.2.2)
  filter_upwards [self_mem_nhdsWithin, this] with y hy h'y
  exact gf ‚ü®hy, h'y.1.le, h'y.2.le‚ü©",":= by
  apply ae_of_mem_of_ae_of_mem_inter_Ioo
  intro a b as bs _
  obtain ‚ü®g, hg, gf‚ü© : ‚àÉ g : ‚Ñù ‚Üí ‚Ñù, Monotone g ‚àß EqOn f g (s ‚à© Icc a b) :=
    (hf.mono inter_subset_left).exists_monotone_extension
      (hf.map_bddBelow inter_subset_left ‚ü®a, fun x hx => hx.2.1, as‚ü©)
      (hf.map_bddAbove inter_subset_left ‚ü®b, fun x hx => hx.2.2, bs‚ü©)
  filter_upwards [hg.ae_differentiableAt] with x hx
  intro h'x
  apply hx.differentiableWithinAt.congr_of_eventuallyEq _ (gf ‚ü®h'x.1, h'x.2.1.le, h'x.2.2.le‚ü©)
  have : Ioo a b ‚àà ùìù[s] x := nhdsWithin_le_nhds (Ioo_mem_nhds h'x.2.1 h'x.2.2)
  filter_upwards [self_mem_nhdsWithin, this] with y hy h'y
  exact gf ‚ü®hy, h'y.1.le, h'y.2.le‚ü©"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.le_mul_withDensity,le_mul_withDensity,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne.def] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine' le_trans (measure_mono (inter_subset_right _ _)) (le_trans (le_of_eq _) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono (inter_subset_right _ _)).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
          ‚àë' n : ‚Ñ§, (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = (t ‚Ä¢ ŒΩ) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t ‚Ä¢ ŒΩ) f_meas hs ht).symm","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.231051 ‚Üí ?m.231051 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  t ‚â† 0 : Prop
but is expected to have type
  ‚Üët ‚â† 0 : Prop
error:  function expected at
  inter_subset_right ?m.233027
term has type
  ?m.233026 ‚àà ?m.233025
error:  type mismatch
  measure_limRatioMeas_zero v hœÅ
has type
  œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 : Prop
but is expected to have type
  Set Œ± : Type u_1
error:  function expected at
  inter_subset_right ?m.235312
term has type
  ?m.235311 ‚àà ?m.235310
error:  unsolved goals
case calc.step
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
m0 : MeasurableSpace Œ±
Œº : Measure Œ±
v : VitaliFamily Œº
E : Type u_2
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : SecondCountableTopology Œ±
inst‚úù¬≤ : BorelSpace Œ±
inst‚úù¬π : IsLocallyFiniteMeasure Œº
œÅ : Measure Œ±
inst‚úù : IsLocallyFiniteMeasure œÅ
hœÅ : œÅ ‚â™ Œº
s : Set Œ±
hs : MeasurableSet s
t : ‚Ñù‚â•0
ht : 1 < t
t_ne_zero' : t ‚â† 0
t_ne_zero : ‚Üët ‚â† 0
ŒΩ : Measure Œ± := Œº.withDensity (v.limRatioMeas hœÅ)
f : Œ± ‚Üí ‚Ñù‚â•0‚àû := v.limRatioMeas hœÅ
f_meas : Measurable f
A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0})
B : œÅ (s ‚à© f ‚Åª¬π' {‚ä§}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚ä§})
n : ‚Ñ§
I : Set ‚Ñù‚â•0‚àû := Ico (‚Üët ^ n) (‚Üët ^ (n + 1))
M : MeasurableSet (s ‚à© f ‚Åª¬π' I)
‚ä¢ ‚Üët * ‚à´‚Åª (x : Œ±) in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº ‚â§ ‚Üët * ŒΩ (s ‚à© f ‚Åª¬π' Ico (‚Üët ^ n) (‚Üët ^ (n + 1)))","theorem le_mul_withDensity {s : Set Œ±} (hs : MeasurableSet s) {t : ‚Ñù‚â•0} (ht : 1 < t) :
    œÅ s ‚â§ t * Œº.withDensity (v.limRatioMeas hœÅ) s ",":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ŒΩ, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
          ‚àë' n : ‚Ñ§, (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = (t ‚Ä¢ ŒΩ) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t ‚Ä¢ ŒΩ) f_meas hs ht).symm",":= by
  have t_ne_zero' : t ‚â† 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ŒΩ := Œº.withDensity (v.limRatioMeas hœÅ)
  let f := v.limRatioMeas hœÅ
  have f_meas : Measurable f := v.limRatioMeas_measurable hœÅ
  have A : œÅ (s ‚à© f ‚Åª¬π' {0}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) := by
    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hœÅ
  have B : œÅ (s ‚à© f ‚Åª¬π' {‚àû}) ‚â§ (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hœÅ
    rw [‚Üê nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hœÅ).le
  have C :
    ‚àÄ n : ‚Ñ§,
      œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))
    have M : MeasurableSet (s ‚à© f ‚Åª¬π' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      œÅ (s ‚à© f ‚Åª¬π' I) ‚â§ (t : ‚Ñù‚â•0‚àû) ^ (n + 1) * Œº (s ‚à© f ‚Åª¬π' I) := by
        rw [‚Üê ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hœÅ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ‚à´‚Åª _ in s ‚à© f ‚Åª¬π' I, (t : ‚Ñù‚â•0‚àû) ^ (n + 1) ‚àÇŒº := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ‚â§ ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, t * f x ‚àÇŒº := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ‚à´‚Åª x in s ‚à© f ‚Åª¬π' I, f x ‚àÇŒº := lintegral_const_mul _ f_meas
  calc
    œÅ s =
      œÅ (s ‚à© f ‚Åª¬π' {0}) + œÅ (s ‚à© f ‚Åª¬π' {0}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_meas hs ht
    _ ‚â§
        (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {0}) + (t ‚Ä¢ ŒΩ) (s ‚à© f ‚Åª¬π' {‚àû}) +
        ‚àë' n : ‚Ñ§, œÅ (s ‚à© f ‚Åª¬π' Ico ((t : ‚Ñù‚â•0‚àû) ^ n) ((t : ‚Ñù‚â•0‚àû) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow œÅ f_me"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,aestronglyMeasurable_of_tendsto_ae,_root_.aestronglyMeasurable_of_tendsto_ae,dad539b67d42acd98d4662387f437158d796aa3d,":= by
  borelize Œ≤
  refine' aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®_, _‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà Œº.ae := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine' ‚ü®closure (‚ãÉ i, t i), (isSeparable_iUnion fun i => t_sep i).closure, _‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    refine eventually_of_forall fun n => ?_
    apply mem_iUnion_of_mem n
    exact hx n","error:  invalid field 'ae', the environment does not contain 'MeasureTheory.Measure.ae'
  Œº
has type
  Measure Œ±","theorem _root_.aestronglyMeasurable_of_tendsto_ae {Œπ : Type*} [PseudoMetrizableSpace Œ≤]
    (u : Filter Œπ) [NeBot u] [IsCountablyGenerated u] {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}
    (hf : ‚àÄ i, AEStronglyMeasurable (f i) Œº) (lim : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) u (ùìù (g x))) :
    AEStronglyMeasurable g Œº ",":= by
  borelize Œ≤
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®?_, ?_‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà ae Œº := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ‚ü®closure (‚ãÉ i, t i), .closure <| .iUnion t_sep, ?_‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)",":= by
  borelize Œ≤
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®_, ?_‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà Œº.ae := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ‚ü®closure (‚ãÉ i, t i), (isSeparable_iUnion fun i => t_sep i).closure, ?_‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    refine eventually_of_forall fun n => ?_
    apply mem_iUnion_of_mem n
    exact hx n"
Mathlib/Algebra/Order/Archimedean.lean,archimedean_iff_rat_lt,archimedean_iff_rat_lt,03690a4c3252f422184189d0b6a6dd8d1c55d551,"  mp := @exists_rat_gt Œ± _ _
  mpr H := archimedean_iff_nat_lt.2 fun x ‚Ü¶
    let ‚ü®q, h‚ü© := H x; ‚ü®‚åàq‚åâ‚Çä, lt_of_lt_of_le h <| mod_cast Nat.le_ceil _‚ü©","error:  failed to synthesize
  Archimedean Œ±
use `set_option diagnostics true` to get diagnostic information","theorem archimedean_iff_rat_lt : Archimedean Œ± ‚Üî ‚àÄ x : Œ±, ‚àÉ q : ‚Ñö, x < q where
","  mp := @exists_rat_gt Œ± _
  mpr H := archimedean_iff_nat_lt.2 fun x ‚Ü¶
    let ‚ü®q, h‚ü© := H x; ‚ü®‚åàq‚åâ‚Çä, lt_of_lt_of_le h <| mod_cast Nat.le_ceil _‚ü©",":= @exists_rat_gt Œ± _ _
  mpr H := archimedean_iff_nat_lt.2 fun x ‚Ü¶
    let ‚ü®q, h‚ü© := H x; ‚ü®‚åàq‚åâ‚Çä, lt_of_lt_of_le h <| mod_cast Nat.le_ceil _‚ü©"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding',exists_extension_norm_eq_of_closedEmbedding',ea54eb89c8a123dcfceeb11bd200d459f2f95413,":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel', pow_succ, mul_assoc]
      refine' (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel']
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := (mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine' tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 _)
    refine' squeeze_zero (fun _ => dist_nonneg) hgf _
    rw [‚Üê zero_mul ‚Äñf‚Äñ]
    refine' (tendsto_pow_atTop_nhds_zero_of_lt_one _ _).mul tendsto_const_nhds <;> norm_num1
  refine' ‚ü®limUnder atTop g, le_antisymm _ _, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine'
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq _
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  application type mismatch
  LE.le.trans (hF_dist (f - (g n).compContinuous e)) (mul_le_mul_of_nonneg_left ?m.115481 ?m.115895)
argument
  mul_le_mul_of_nonneg_left ?m.115481 ?m.115895
has type
  2 / 3 * ‚Äñf - (g n).compContinuous e‚Äñ ‚â§ 2 / 3 * ?m.115476 : Prop
but is expected to have type
  2 / 3 * ‚Äñf - (g n).compContinuous e‚Äñ ‚â§ (2 / 3) ^ n * (2 / 3 * ‚Äñf‚Äñ) : Prop
error:  no goals to be solved
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead","theorem exists_extension_norm_eq_of_closedEmbedding' (f : X ‚Üí·µá ‚Ñù) (e : C(X, Y))
    (he : ClosedEmbedding e) : ‚àÉ g : Y ‚Üí·µá ‚Ñù, ‚Äñg‚Äñ = ‚Äñf‚Äñ ‚àß g.compContinuous e = f ",":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [‚Üê zero_mul ‚Äñf‚Äñ]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ‚ü®limUnder atTop g, le_antisymm ?_ ?_, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _",":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel', pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel']
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [‚Üê zero_mul ‚Äñf‚Äñ]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ‚ü®limUnder atTop g, le_antisymm ?_ ?_, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _"
Mathlib/Data/Fin/Basic.lean,Fin.one_eq_zero_iff,one_eq_zero_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [‚Üê Nat.cast_one, natCast_eq_zero, Nat.dvd_one]","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown constant 'Nat.cast_one'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.20634
n m : ‚Ñï
inst‚úù : NeZero n
‚ä¢ 1 = 0 ‚Üî n = 1",theorem one_eq_zero_iff [NeZero n] : (1 : Fin n) = 0 ‚Üî n = 1 ,":= by
  obtain _ | _ | n := n <;> simp [Fin.ext_iff]",":= by
  rw [‚Üê Nat.cast_one, natCast_eq_zero, Nat.dvd_one]"
Mathlib/Analysis/Fourier/FourierTransform.lean,VectorFourier.fourierIntegral_continuous,fourierIntegral_continuous,102773d74ceb3ea7655230d0ea35a3ae873e0581,":= by
  apply continuous_of_dominated
  ¬∑ exact fun w ‚Ü¶ ((fourier_integral_convergent_iff he hL w).mp hf).1
  ¬∑ exact fun w ‚Ü¶ ae_of_all _ fun v ‚Ü¶ le_of_eq (norm_circle_smul _ _)
  ¬∑ exact hf.norm
  ¬∑ refine ae_of_all _ fun v ‚Ü¶ (he.comp ?_).smul continuous_const
    exact (hL.comp (continuous_prod_mk.mpr ‚ü®continuous_const, continuous_id‚ü©)).neg","warning:  `VectorFourier.fourier_integral_convergent_iff` has been deprecated, use `VectorFourier.fourierIntegral_convergent_iff` instead
error:  application type mismatch
  (fourier_integral_convergent_iff he hL w).mp hf
argument
  hf
has type
  Integrable f Œº : Prop
but is expected to have type
  Integrable (fun v ‚Ü¶ e (-(L v) w) ‚Ä¢ ?m.104127 v) ?m.104025 : Prop
warning:  Real.fourierChar does not have a doc string
warning:  @Real.fourierIntegral does not have a doc string
warning:  @Real.fourierIntegralInv does not have a doc string","theorem fourierIntegral_continuous [FirstCountableTopology W] (he : Continuous e)
    (hL : Continuous fun p : V √ó W ‚Ü¶ L p.1 p.2) {f : V ‚Üí E} (hf : Integrable f Œº) :
    Continuous (fourierIntegral e Œº L f) ",":= by
  apply continuous_of_dominated
  ¬∑ exact fun w ‚Ü¶ ((fourierIntegral_convergent_iff he hL w).2 hf).1
  ¬∑ exact fun w ‚Ü¶ ae_of_all _ fun v ‚Ü¶ le_of_eq (norm_circle_smul _ _)
  ¬∑ exact hf.norm
  ¬∑ refine ae_of_all _ fun v ‚Ü¶ (he.comp ?_).smul continuous_const
    exact (hL.comp (continuous_prod_mk.mpr ‚ü®continuous_const, continuous_id‚ü©)).neg",":= by
  apply continuous_of_dominated
  ¬∑ exact fun w ‚Ü¶ ((fourier_integral_convergent_iff he hL w).mp hf).1
  ¬∑ exact fun w ‚Ü¶ ae_of_all _ fun v ‚Ü¶ le_of_eq (norm_circle_smul _ _)
  ¬∑ exact hf.norm
  ¬∑ refine ae_of_all _ fun v ‚Ü¶ (he.comp ?_).smul continuous_const
    exact (hL.comp continuous_prod_mk.mpr ‚ü®continuous_const, continuous_id‚ü©)).neg"
Mathlib/Analysis/NormedSpace/Star/Spectrum.lean,IsSelfAdjoint.mem_spectrum_eq_re,IsSelfAdjoint.mem_spectrum_eq_re,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  have hu := exp_mem_unitary_of_mem_skewAdjoint ‚ÑÇ (ha.smul_mem_skewAdjoint conj_I)
  let Iu := Units.mk0 I I_ne_zero
  have : _root_.exp ‚ÑÇ (I ‚Ä¢ z) ‚àà spectrum ‚ÑÇ (_root_.exp ‚ÑÇ (I ‚Ä¢ a)) := by
    simpa only [Units.smul_def, Units.val_mk0] using
      spectrum.exp_mem_exp (Iu ‚Ä¢ a) (smul_mem_smul_iff.mpr hz)
  exact Complex.ext (ofReal_re _) <| by
    simpa only [‚Üê Complex.exp_eq_exp_‚ÑÇ, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,
      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using
      spectrum.subset_circle_of_unitary hu this","error:  unknown identifier '_root_.exp'
error:  unknown identifier '_root_.exp'
error:  unsolved goals
A : Type u_1
inst‚úù‚Åµ : NormedRing A
inst‚úù‚Å¥ : NormedAlgebra ‚ÑÇ A
inst‚úù¬≥ : CompleteSpace A
inst‚úù¬≤ : StarRing A
inst‚úù¬π : CstarRing A
inst‚úù : StarModule ‚ÑÇ A
a : A
ha : IsSelfAdjoint a
z : ‚ÑÇ
hz : z ‚àà spectrum ‚ÑÇ a
hu : NormedSpace.exp ‚ÑÇ (I ‚Ä¢ a) ‚àà unitary A
Iu : ‚ÑÇÀ£ := Units.mk0 I I_ne_zero
‚ä¢ z = ‚Üëz.re","theorem IsSelfAdjoint.mem_spectrum_eq_re [StarModule ‚ÑÇ A] {a : A} (ha : IsSelfAdjoint a) {z : ‚ÑÇ}
    (hz : z ‚àà spectrum ‚ÑÇ a) : z = z.re ",":= by
  have hu := exp_mem_unitary_of_mem_skewAdjoint ‚ÑÇ (ha.smul_mem_skewAdjoint conj_I)
  let Iu := Units.mk0 I I_ne_zero
  have : NormedSpace.exp ‚ÑÇ (I ‚Ä¢ z) ‚àà spectrum ‚ÑÇ (NormedSpace.exp ‚ÑÇ (I ‚Ä¢ a)) := by
    simpa only [Units.smul_def, Units.val_mk0] using
      spectrum.exp_mem_exp (Iu ‚Ä¢ a) (smul_mem_smul_iff.mpr hz)
  exact Complex.ext (ofReal_re _) <| by
    simpa only [‚Üê Complex.exp_eq_exp_‚ÑÇ, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,
      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using
      spectrum.subset_circle_of_unitary hu this",":= by
  have hu := exp_mem_unitary_of_mem_skewAdjoint ‚ÑÇ (ha.smul_mem_skewAdjoint conj_I)
  let Iu := Units.mk0 I I_ne_zero
  have : _root_.exp ‚ÑÇ (I ‚Ä¢ z) ‚àà spectrum ‚ÑÇ (_root_.exp ‚ÑÇ (I ‚Ä¢ a)) := by
    simpa only [Units.smul_def, Units.val_mk0] using
      exp_mem_exp (Iu ‚Ä¢ a) (smul_mem_smul_iff.mpr hz)
  exact Complex.ext (ofReal_re _) <| by
    simpa only [‚Üê Complex.exp_eq_exp_‚ÑÇ, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,
      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using
      spectrum.subset_circle_of_unitary hu this"
Mathlib/Data/Set/Finite.lean,Set.Finite.exists_not_mem,Finite.exists_not_mem,0e1fb8d54955c6fdc7263b0eb58946a3a50c37a4,":= by
  by_contra' h; exact infinite_univ (hs.subset fun a _ ‚Ü¶ h _)","error:  unknown tactic
error:  unsolved goals
Œ± : Type u
Œ≤ : Type v
Œπ : Sort w
Œ≥ : Type x
s t : Set Œ±
inst‚úù : Infinite Œ±
hs : s.Finite
‚ä¢ ‚àÉ a, a ‚àâ s","lemma Finite.exists_not_mem (hs : s.Finite) : ‚àÉ a, a ‚àâ s ",":= by
  by_contra! h; exact infinite_univ (hs.subset fun a _ ‚Ü¶ h _)",":= by
  by_contra h; exact infinite_univ (hs.subset fun a _ ‚Ü¶ h _)"
Mathlib/RingTheory/RootsOfUnity/Minpoly.lean,IsPrimitiveRoot.separable_minpoly_mod,separable_minpoly_mod,070b09db52c6f063dd905c04b291f74460734aab,":= by
  have hdvd : map (Int.castRingHom (ZMod p)) (minpoly ‚Ñ§ Œº) ‚à£ X ^ n - 1 := by
    simp [Polynomial.map_pow, map_X, Polynomial.map_one, Polynomial.map_sub]
    convert  RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p)))
        (minpoly_dvd_x_pow_sub_one h)
    simp only [map_sub, map_pow, coe_mapRingHom, map_X, map_one]
  refine' Separable.of_dvd (separable_X_pow_sub_C 1 _ one_ne_zero) hdvd
  by_contra hzero
  exact hdiv ((ZMod.nat_cast_zmod_eq_zero_iff_dvd n p).1 hzero)","error:  simp made no progress
warning:  `ZMod.nat_cast_zmod_eq_zero_iff_dvd` has been deprecated, use `ZMod.natCast_zmod_eq_zero_iff_dvd` instead
error:  application type mismatch
  separable_minpoly_mod h
argument
  h
has type
  IsPrimitiveRoot Œº n : Prop
but is expected to have type
  ¬¨?m.13675 ‚à£ ?m.13671 : Prop
error:  application type mismatch
  squarefree_minpoly_mod h
argument
  h
has type
  IsPrimitiveRoot Œº n : Prop
but is expected to have type
  ¬¨?m.25210 ‚à£ ?m.25206 : Prop
error:  application type mismatch
  minpoly_dvd_mod_p h
argument
  h
has type
  IsPrimitiveRoot Œº n : Prop
but is expected to have type
  ¬¨?m.35437 ‚à£ ?m.35433 : Prop
error:  rcases tactic failed: x‚úù : ?m.35772 is not an inductive datatype","theorem separable_minpoly_mod {p : ‚Ñï} [Fact p.Prime] (hdiv : ¬¨p ‚à£ n) :
    Separable (map (Int.castRingHom (ZMod p)) (minpoly ‚Ñ§ Œº)) ",":= by
  have hdvd : map (Int.castRingHom (ZMod p)) (minpoly ‚Ñ§ Œº) ‚à£ X ^ n - 1 := by
    convert RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p)))
        (minpoly_dvd_x_pow_sub_one h)
    simp only [map_sub, map_pow, coe_mapRingHom, map_X, map_one]
  refine Separable.of_dvd (separable_X_pow_sub_C 1 ?_ one_ne_zero) hdvd
  by_contra hzero
  exact hdiv ((ZMod.natCast_zmod_eq_zero_iff_dvd n p).1 hzero)",":= by
  have hdvd : map (Int.castRingHom (ZMod p)) (minpoly ‚Ñ§ Œº) ‚à£ X ^ n - 1 := by
    simp [Polynomial.map_pow, map_X, Polynomial.map_one, Polynomial.map_sub]
    convert RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p)))
        (minpoly_dvd_x_pow_sub_one h)
    simp only [map_sub, map_pow, coe_mapRingHom, map_X, map_one]
  refine Separable.of_dvd (separable_X_pow_sub_C 1 ?_ one_ne_zero) hdvd
  by_contra hzero
  exact hdiv ((ZMod.natCast_zmod_eq_zero_iff_dvd n p).1 hzero)"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.aemeasurable_fderivWithin,aemeasurable_fderivWithin,0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":= by
  refine' aemeasurable_of_unif_approx fun Œµ Œµpos => _
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, _‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
              (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine' ‚ü®g, g_meas.aemeasurable, _‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n => Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ
  ¬∑ have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine' ae_sum_iff.2 fun n => _
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono (inter_subset_left _ _)
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n
    exact ae_mono (restrict_mono (inter_subset_right _ _) le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem aemeasurable_fderivWithin (hs : MeasurableSet s)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (Œº.restrict s) ",":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, _‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
              (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ‚ü®g, g_meas.aemeasurable, ?_‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n ‚Ü¶ Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1",":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, ?_‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
             (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ‚ü®g, g_meas.aemeasurable, ?_‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n => Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n
    exact ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1"
Mathlib/MeasureTheory/Function/Jacobian.lean,exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt,exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt,775e01228dac511545eaea91c9d7e90a5ffa55b4,":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine' ‚ü®fun _ => ‚àÖ, fun _ => 0, _, _, _, _‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß (‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' x))) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine' mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, _‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine' ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, _, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine' ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, _‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := (norm_add_le _ _)
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ + ‚Äñf' x - f' z‚Äñ * ‚Äñy - x‚Äñ := by
        refine' add_le_add (hŒ¥ _) (ContinuousLinearMap.le_op_norm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ‚â§ r (f' z) * ‚Äñy - x‚Äñ := by
        rw [‚Üê add_mul, add_comm]
        exact mul_le_mul_of_nonneg_right hŒµ (norm_nonneg _)
  have closure_M_subset : ‚àÄ n z, s ‚à© closure (M n z) ‚äÜ M n z := by
    rintro n z x ‚ü®xs, hx‚ü©
    refine' ‚ü®xs, fun y hy => _‚ü©
    obtain ‚ü®a, aM, a_lim‚ü© : ‚àÉ a : ‚Ñï ‚Üí E, (‚àÄ k, a k ‚àà M n z) ‚àß Tendsto a atTop (ùìù x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ‚Ñï => ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ) atTop
        (ùìù ‚Äñf y - f x - (f' z) (y - x)‚Äñ) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (ùìù (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ‚Ñï => (r (f' z) : ‚Ñù) * ‚Äñy - a k‚Äñ) atTop (ùìù (r (f' z) * ‚Äñy - x‚Äñ)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ‚àÄ·∂† k in atTop, ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ ‚â§ r (f' z) * ‚Äñy - a k‚Äñ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (ùìù (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ‚ü®hy.1, hk‚ü©
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ‚ü®d, hd‚ü©
  let K : ‚Ñï ‚Üí T ‚Üí ‚Ñï ‚Üí Set E := fun n z p => closure (M n z) ‚à© closedBall (d p) (u n / 3)
  have K_approx : ‚àÄ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ‚à© K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ‚àà M n z := closure_M_subset _ _ ‚ü®hy.1, hy.2.1‚ü©
    refine' yM.2 _ ‚ü®hx.1, _‚ü©
    calc
      dist x y ‚â§ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ‚â§ u n / 3 + u n / 3 := (add_le_add hx.2.2 hy.2.2)
      _ < u n := by linarith [u_pos n]
  have K_closed : ‚àÄ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñï ‚Üí ‚Ñï √ó T √ó ‚Ñï, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases eq_empty_or_nonempty T with (rfl | hT)
      ¬∑ rcases hs with ‚ü®x, xs‚ü©
        rcases s_subset x xs with ‚ü®n, z, _‚ü©
        exact False.elim z.2
      ¬∑ exact hT.coe_sort
    inhabit ‚Ü•T
    exact ‚ü®_, Encodable.surjective_decode_iget (‚Ñï √ó T √ó ‚Ñï)‚ü©
  refine'
    ‚ü®fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => _, fun q => K_approx _ _ _, fun _ q => ‚ü®(F q).2.1, (F q).2.1.1.2, rfl‚ü©‚ü©
  obtain ‚ü®n, z, hnz‚ü© : ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := s_subset x xs
  obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, x ‚àà closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, d p ‚àà ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ‚ü®p, (mem_ball'.1 hp).le‚ü©
  obtain ‚ü®q, hq‚ü© : ‚àÉ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ‚ü®q, _‚ü©
  simp (config := { zeta := false }) only [hq, subset_closure hnz, hp, mem_inter_iff, and_true, hnz]","error:  application type mismatch
  IsLittleO.def (hf' x xs)
argument
  hf' x xs
has type
  HasFDerivWithinAt f (f' x) s x : Prop
but is expected to have type
  (fun y ‚Ü¶ f y - f x - (f' x) (y - x)) =o[ùìù[s] x] fun y ‚Ü¶ y - x : Prop
warning:  `ContinuousLinearMap.le_op_norm` has been deprecated, use `ContinuousLinearMap.le_opNorm` instead
error:  unsolved goals
E : Type u_1
F‚úù : Type u_2
inst‚úù‚Åµ : NormedAddCommGroup E
inst‚úù‚Å¥ : NormedSpace ‚Ñù E
inst‚úù¬≥ : FiniteDimensional ‚Ñù E
inst‚úù¬≤ : NormedAddCommGroup F‚úù
inst‚úù¬π : NormedSpace ‚Ñù F‚úù
s‚úù : Set E
f‚úù : E ‚Üí E
f'‚úù : E ‚Üí E ‚ÜíL[‚Ñù] E
inst‚úù : SecondCountableTopology F‚úù
f : E ‚Üí F‚úù
s : Set E
f' : E ‚Üí E ‚ÜíL[‚Ñù] F‚úù
hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x
r : (E ‚ÜíL[‚Ñù] F‚úù) ‚Üí ‚Ñù‚â•0
rpos : ‚àÄ (A : E ‚ÜíL[‚Ñù] F‚úù), r A ‚â† 0
hs : s.Nonempty
T : Set ‚Üës
T_count : T.Countable
hT : ‚ãÉ x ‚àà T, ball (f' ‚Üëx) ‚Üë(r (f' ‚Üëx)) = ‚ãÉ x, ball (f' ‚Üëx) ‚Üë(r (f' ‚Üëx))
u : ‚Ñï ‚Üí ‚Ñù
left‚úù : StrictAnti u
u_pos : ‚àÄ (n : ‚Ñï), 0 < u n
u_lim : Tendsto u atTop (ùìù 0)
M : ‚Ñï ‚Üí ‚ÜëT ‚Üí Set E :=
  fun n z ‚Ü¶ {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - (f' ‚Üë‚Üëz) (y - x)‚Äñ ‚â§ ‚Üë(r (f' ‚Üë‚Üëz)) * ‚Äñy - x‚Äñ}
s_subset : ‚àÄ x ‚àà s, ‚àÉ n z, x ‚àà M n z
closure_M_subset : ‚àÄ (n : ‚Ñï) (z : ‚ÜëT), s ‚à© closure (M n z) ‚äÜ M n z
d : ‚Ñï ‚Üí E
hd : DenseRange d
K : ‚Ñï ‚Üí ‚ÜëT ‚Üí ‚Ñï ‚Üí Set E := fun n z p ‚Ü¶ closure (M n z) ‚à© closedBall (d p) (u n / 3)
K_approx : ‚àÄ (n : ‚Ñï) (z : ‚ÜëT) (p : ‚Ñï), ApproximatesLinearOn f (f' ‚Üë‚Üëz) (s ‚à© K n z p) (r (f' ‚Üë‚Üëz))
K_closed : ‚àÄ (n : ‚Ñï) (z : ‚ÜëT) (p : ‚Ñï), IsClosed (K n z p)
F : ‚Ñï ‚Üí ‚Ñï √ó ‚ÜëT √ó ‚Ñï
hF : Function.Surjective F
x : E
xs : x ‚àà s
n : ‚Ñï
z : ‚ÜëT
hnz : x ‚àà M n z
p : ‚Ñï
hp : x ‚àà closedBall (d p) (u n / 3)
q : ‚Ñï
hq : F q = (n, z, p)
‚ä¢ x ‚àà K n z p","theorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]
    (f : E ‚Üí F) (s : Set E) (f' : E ‚Üí E ‚ÜíL[‚Ñù] F) (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x)
    (r : (E ‚ÜíL[‚Ñù] F) ‚Üí ‚Ñù‚â•0) (rpos : ‚àÄ A, r A ‚â† 0) :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] F),
      (‚àÄ n, IsClosed (t n)) ‚àß
        (s ‚äÜ ‚ãÉ n, t n) ‚àß
          (‚àÄ n, ApproximatesLinearOn f (A n) (s ‚à© t n) (r (A n))) ‚àß
            (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) ",":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => 0, ?_, ?_, ?_, ?_‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' x)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, ?_‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ + ‚Äñf' x - f' z‚Äñ * ‚Äñy - x‚Äñ := by
        refine add_le_add (hŒ¥ ?_) (ContinuousLinearMap.le_opNorm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ‚â§ r (f' z) * ‚Äñy - x‚Äñ := by
        rw [‚Üê add_mul, add_comm]
        gcongr
  have closure_M_subset : ‚àÄ n z, s ‚à© closure (M n z) ‚äÜ M n z := by
    rintro n z x ‚ü®xs, hx‚ü©
    refine ‚ü®xs, fun y hy => ?_‚ü©
    obtain ‚ü®a, aM, a_lim‚ü© : ‚àÉ a : ‚Ñï ‚Üí E, (‚àÄ k, a k ‚àà M n z) ‚àß Tendsto a atTop (ùìù x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ‚Ñï => ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ) atTop
        (ùìù ‚Äñf y - f x - (f' z) (y - x)‚Äñ) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (ùìù (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ‚Ñï => (r (f' z) : ‚Ñù) * ‚Äñy - a k‚Äñ) atTop (ùìù (r (f' z) * ‚Äñy - x‚Äñ)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ‚àÄ·∂† k in atTop, ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ ‚â§ r (f' z) * ‚Äñy - a k‚Äñ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (ùìù (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ‚ü®hy.1, hk‚ü©
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ‚ü®d, hd‚ü©
  let K : ‚Ñï ‚Üí T ‚Üí ‚Ñï ‚Üí Set E := fun n z p => closure (M n z) ‚à© closedBall (d p) (u n / 3)
  have K_approx : ‚àÄ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ‚à© K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ‚àà M n z := closure_M_subset _ _ ‚ü®hy.1, hy.2.1‚ü©
    refine yM.2 _ ‚ü®hx.1, ?_‚ü©
    calc
      dist x y ‚â§ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ‚â§ u n / 3 + u n / 3 := add_le_add hx.2.2 hy.2.2
      _ < u n := by linarith [u_pos n]
  have K_closed : ‚àÄ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñï ‚Üí ‚Ñï √ó T √ó ‚Ñï, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases hs with ‚ü®x, xs‚ü©
      rcases s_subset x xs with ‚ü®n, z, _‚ü©
      exact ‚ü®z‚ü©
    inhabit ‚Ü•T
    exact ‚ü®_, Encodable.surjective_decode_iget (‚Ñï √ó T √ó ‚Ñï)‚ü©
  refine
    ‚ü®fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => ?_, fun q => K_approx _ _ _, fun _ q => ‚ü®(F q).2.1, (F q).2.1.1.2, rfl‚ü©‚ü©
  obtain ‚ü®n, z, hnz‚ü© : ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := s_subset x xs
  obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, x ‚àà closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, d p ‚àà ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ‚ü®p, (mem_ball'.1 hp).le‚ü©
  obtain ‚ü®q, hq‚ü© : ‚àÉ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ‚ü®q, _‚ü©
  simp (config := { zeta := false }) only [K, hq, mem_inter_iff, hp, and_true]
  exact subset_closure hnz",":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => 0, ?_, ?_, ?_, ?_‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß (‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' z))) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, ?_‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm"
Mathlib/Data/Rat/Lemmas.lean,Rat.den_mk,den_mk,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases d with ((_ | _) | _) <;>
    simp [divInt, mkRat, Rat.normalize, Nat.succPNat, Int.sign, Int.gcd, -Nat.cast_succ]","warning:  'Nat.cast_succ' does not have [simp] attribute
warning:  'Nat.cast_succ' does not have [simp] attribute
warning:  'Nat.cast_succ' does not have [simp] attribute
error:  unsolved goals
case ofNat.succ
n : ‚Ñ§
n‚úù : ‚Ñï
‚ä¢ (n‚úù + 1) / n.natAbs.gcd (n‚úù + 1) = if ‚Üën‚úù + 1 = 0 then 1 else (‚Üën‚úù + 1).natAbs / n.natAbs.gcd (‚Üën‚úù + 1).natAbs",theorem den_mk (n d : ‚Ñ§) : (n /. d).den = if d = 0 then 1 else d.natAbs / n.gcd d ,":= by
  have (m : ‚Ñï) : Int.natAbs (m + 1) = m + 1 := by
    rw [‚Üê Nat.cast_one, ‚Üê Nat.cast_add, Int.natAbs_cast]
  rcases d with ((_ | _) | _) <;>
    simp [divInt, mkRat, Rat.normalize, Nat.succPNat, Int.sign, Int.gcd,
      if_neg (Nat.cast_add_one_ne_zero _), this]",":= by
  rcases d with ((_ | _) | _) <;>
    simp [divInt, mkRat, Rat.normalize, Nat.succPNat, Int.sign, Int.gcd, -Nat.cast_succ]"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicAt.order_eq_int_iff,order_eq_int_iff,1df5e9f2d5d2defceda7b95892bf4c4bb80859af,":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_nat, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z
    ¬∑ rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
      ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel', zpow_ofNat, zpow_ofNat]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©",error:  unexpected token '¬∑'; expected '|',"lemma order_eq_int_iff {f : ùïú ‚Üí E} {x : ùïú} (hf : MeromorphicAt f x) (n : ‚Ñ§) : hf.order = n ‚Üî
    ‚àÉ g : ùïú ‚Üí E, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z ",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_natCast, ‚Üê coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_nat, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z
    ¬∑ rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
      ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_ofNat]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©"
Mathlib/LinearAlgebra/FiniteDimensional.lean,Submodule.eq_top_of_finrank_eq,_root_.Submodule.eq_top_of_finrank_eq,bd925b6a47d15c0626631368b8cd4b10dac20b33,":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K (((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V).restrict id) :=
    @LinearIndependent.image_subtype _ _ _ _ _ _ _ _ _ (Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent (by simpa using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Set.range_restrict, Set.image_id, ‚Üê this,
    ‚ÜêSubmodule.coeSubtype, span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Set.range_restrict, Set.image_id] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]","error:  type mismatch
  h‚úù
has type
  LinearIndependent (Œπ := ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) K ‚áëbS : Prop
but is expected to have type
  LinearIndependent K fun (x : ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) ‚Ü¶ ‚Üëx : Prop
warning:  `finite_of_linearIndependent` has been deprecated, use `LinearIndependent.set_finite_of_isNoetherian` instead
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  no goals to be solved
error:  unknown identifier 'eq_top_of_finrank_eq'","theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ‚ä§ ",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K (((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V).restrict id) :=
    @LinearIndependent.image_subtype _ _ _ _ _ _ _ _ (Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
             finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Set.range_restrict, Set.image_id, ‚Üê this,
    ‚ÜêSubmodule.coeSubtype, span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Set.range_restrict, Set.image_id] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]"
Mathlib/GroupTheory/OrderOfElement.lean,IsOfFinOrder.apply,IsOfFinOrder.apply,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rcases (isOfFinOrder_iff_pow_eq_one _).mp h with ‚ü®n, npos, hn‚ü©
  exact fun _ => (isOfFinOrder_iff_pow_eq_one _).mpr ‚ü®n, npos, (congr_fun hn.symm _).symm‚ü©","error:  function expected at
  isOfFinOrder_iff_pow_eq_one
term has type
  IsOfFinOrder ?m.14062 ‚Üî ‚àÉ n, 0 < n ‚àß ?m.14062 ^ n = 1
error:  rcases tactic failed: x‚úù : ?m.13903 is not an inductive datatype","theorem IsOfFinOrder.apply {Œ∑ : Type*} {Gs : Œ∑ ‚Üí Type*} [‚àÄ i, Monoid (Gs i)] {x : ‚àÄ i, Gs i}
    (h : IsOfFinOrder x) : ‚àÄ i, IsOfFinOrder (x i) ",":= by
  obtain ‚ü®n, npos, hn‚ü© := h.exists_pow_eq_one
  exact fun _ => isOfFinOrder_iff_pow_eq_one.mpr ‚ü®n, npos, (congr_fun hn.symm _).symm‚ü©",":= by
  rcases (isOfFinOrder_iff_pow_eq_one _).mp h with ‚ü®n, npos, hn‚ü©
  exact fun _ => (isOfFinOrder_iff_pow_eq_one _).mpr ‚ü®n, npos, congr_fun hn.symm _).symm‚ü©"
Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean,WeierstrassCurve.Projective.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,403f0036f3625bbf32f578e4b9f9f7ff5d5648bd,":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, or_true, not_true_eq_false, mul_zero, zero_mul, add_zero, pow_eq_zero_iff, false_or,
      true_and, pow_eq_zero hQ.left.symm] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©","error:  application type mismatch
  div_ne_zero hP
argument
  hP
has type
  ¬¨3 = 0 ‚àß False ‚à® ¬¨P 1 = 0 : Prop
but is expected to have type
  P 1 ‚â† 0 : Prop
error:  application type mismatch
  div_mul_cancel‚ÇÄ ?m.248986 hQ
argument
  hQ
has type
  ¬¨3 = 0 ‚àß False ‚à® ¬¨Q 1 = 0 : Prop
but is expected to have type
  ?m.248985 ‚â† 0 : Prop
error:  unsolved goals
R : Type u
inst‚úù¬π : CommRing R
W‚úù : Projective R
F : Type u
inst‚úù : Field F
W : Projective F
P Q : Fin 3 ‚Üí F
hPz : P 2 = 0
hQz : Q 2 = 0
hP : ¬¨3 = 0 ‚àß False ‚à® ¬¨P 1 = 0
hQ : ¬¨3 = 0 ‚àß False ‚à® ¬¨Q 1 = 0
‚ä¢ ![0, P 1 / Q 1 * Q 1, 0] = ![0, P 1, 0]","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, or_true, not_true_eq_false, mul_zero, zero_mul, add_zero, pow_eq_zero_iff, false_or,
      true_and, pow_eq_zero hQ.left.symm] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©"
Mathlib/Probability/ConditionalProbability.lean,ProbabilityTheory.cond_cond_eq_cond_inter',cond_cond_eq_cond_inter',b0011bffcf8eff635640aae6c46f410c7fce1773,":= by
  ext u
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 := measure_mono_null (Set.inter_subset_left _ _) hst
    simp [cond_apply, *, ‚Üê Set.inter_assoc]
  ¬∑ have hs : Œº s ‚â† 0 :=
      (Œº.toOuterMeasure.pos_of_subset_ne_zero (Set.inter_subset_left _ _) hst).ne'
    simp [*, hms.inter hmt, cond_apply, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ‚Üê mul_assoc,
      mul_comm _ (Œº s)‚Åª¬π, ENNReal.inv_mul_cancel]","warning:  @cond does not have a doc string
warning:  @cond does not have a doc string
error:  function expected at
  inter_subset_left ?m.27904
term has type
  ?m.27903 ‚àà ?m.27901
warning:  `MeasureTheory.OuterMeasure.pos_of_subset_ne_zero` has been deprecated, use `MeasureTheory.measure_pos_of_superset` instead
error:  function expected at
  inter_subset_left ?m.31592
term has type
  ?m.31591 ‚àà ?m.31589","lemma cond_cond_eq_cond_inter' (hms : MeasurableSet s) (hmt : MeasurableSet t) (hcs : Œº s ‚â† ‚àû) :
    Œº[|s][|t] = Œº[|s ‚à© t] ",":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (measure_pos_of_superset Set.inter_subset_left hst).ne'
    simp [*, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Œº s)‚Åª¬π]",":= by
  ext u
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [cond_apply, *, ‚Üê Set.inter_assoc]
  ¬∑ have hs : Œº s ‚â† 0 :=
      (Œº.toOuterMeasure.pos_of_subset_ne_zero Set.inter_subset_left hst).ne'
    simp [*, hms.inter hmt, cond_apply, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ‚Üê mul_assoc,
      mul_comm _ (Œº s)‚Åª¬π, ENNReal.inv_mul_cancel]"
Mathlib/Topology/Compactness/Lindelof.lean,IsLindelof.inter_right,IsLindelof.inter_right,278815fde22e4550579704dd2875cfb94b828e44,":= by
  intro f hnf _ hstf
  obtain ‚ü®x, hsx, hx‚ü© : ‚àÉ x ‚àà s, ClusterPt x f :=
    hs (le_trans hstf (le_principal_iff.2 (inter_subset_left _ _)))
  have : x ‚àà t := ht.mem_of_nhdsWithin_neBot <|
    hx.mono <| le_trans hstf (le_principal_iff.2 (inter_subset_right _ _))
  exact ‚ü®x, ‚ü®hsx, this‚ü©, hx‚ü©

  theorem IsLindelof.inter_left (ht : IsLindelof t) (hs : IsClosed s) : IsLindelof (s ‚à© t) :=
  inter_comm t s ‚ñ∏ ht.inter_right hs

  theorem IsLindelof.diff (hs : IsLindelof s) (ht : IsOpen t) : IsLindelof (s \ t) :=
  hs.inter_right (isClosed_compl_iff.mpr ht)","error:  function expected at
  inter_subset_left ?m.7421
term has type
  ?m.7420 ‚àà ?m.7418
error:  function expected at
  inter_subset_right ?m.7663
term has type
  ?m.7662 ‚àà ?m.7661",theorem IsLindelof.inter_right (hs : IsLindelof s) (ht : IsClosed t) : IsLindelof (s ‚à© t) ,":= by
  intro f hnf _ hstf
  rw [‚Üê inf_principal, le_inf_iff] at hstf
  obtain ‚ü®x, hsx, hx‚ü© : ‚àÉ x ‚àà s, ClusterPt x f := hs hstf.1
  have hxt : x ‚àà t := ht.mem_of_nhdsWithin_neBot <| hx.mono hstf.2
  exact ‚ü®x, ‚ü®hsx, hxt‚ü©, hx‚ü©

  theorem IsLindelof.inter_left (ht : IsLindelof t) (hs : IsClosed s) : IsLindelof (s ‚à© t) :=
  inter_comm t s ‚ñ∏ ht.inter_right hs

  theorem IsLindelof.diff (hs : IsLindelof s) (ht : IsOpen t) : IsLindelof (s \ t) :=
  hs.inter_right (isClosed_compl_iff.mpr ht)",":= by
  intro f hnf _ hstf
  obtain ‚ü®x, hsx, hx‚ü© : ‚àÉ x ‚àà s, ClusterPt x f :=
    hs (le_trans hstf (le_principal_iff.2 inter_subset_left))
  have : x ‚àà t := ht.mem_of_nhdsWithin_neBot <|
    hx.mono <| le_trans hstf (le_principal_iff.2 inter_subset_right)
  exact ‚ü®x, ‚ü®hsx, this‚ü©, hx‚ü©

  theorem IsLindelof.inter_left (ht : IsLindelof t) (hs : IsClosed s) : IsLindelof (s ‚à© t) :=
  inter_comm t s ‚ñ∏ ht.inter_right hs
  theorem IsLindelof.diff (hs : IsLindelof s) (ht : IsOpen t) : IsLindelof (s \ t) :=
  hs.inter_right (isClosed_compl_iff.mpr ht)"
Mathlib/Topology/Semicontinuous.lean,LowerSemicontinuousWithinAt.add',LowerSemicontinuousWithinAt.add',200b13c6bec9232f07d98e431a27afa078e8f986,":= by
  rw [lowerSemicontinuousWithinAt_iff_eventually_lt] at hf hg ‚ä¢
  intro y hy
  obtain ‚ü®u, v, u_open, xu, v_open, xv, h‚ü© :
    ‚àÉ u v : Set Œ≥,
      IsOpen u ‚àß f x ‚àà u ‚àß IsOpen v ‚àß g x ‚àà v ‚àß u √óÀ¢ v ‚äÜ { p : Œ≥ √ó Œ≥ | y < p.fst + p.snd } :=
    mem_nhds_prod_iff'.1 (hcont (isOpen_Ioi.mem_nhds hy))
  by_cases hx‚ÇÅ : ‚àÉ l, l < f x
  ¬∑ obtain ‚ü®z‚ÇÅ, z‚ÇÅlt, h‚ÇÅ‚ü© : ‚àÉ z‚ÇÅ < f x, Ioc z‚ÇÅ (f x) ‚äÜ u :=
      exists_Ioc_subset_of_mem_nhds (u_open.mem_nhds xu) hx‚ÇÅ
    by_cases hx‚ÇÇ : ‚àÉ l, l < g x
    ¬∑ obtain ‚ü®z‚ÇÇ, z‚ÇÇlt, h‚ÇÇ‚ü© : ‚àÉ z‚ÇÇ < g x, Ioc z‚ÇÇ (g x) ‚äÜ v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hx‚ÇÇ
      filter_upwards [hf z‚ÇÅ z‚ÇÅlt, hg z‚ÇÇ z‚ÇÇlt] with z h‚ÇÅz h‚ÇÇz
      have A1 : min (f z) (f x) ‚àà u := by
        by_cases H : f z ‚â§ f x
        ¬∑ simp [H]
          exact h‚ÇÅ ‚ü®h‚ÇÅz, H‚ü©
        ¬∑ simp [le_of_not_le H]
          exact h‚ÇÅ ‚ü®z‚ÇÅlt, le_rfl‚ü©
      have A2 : min (g z) (g x) ‚àà v := by
        by_cases H : g z ‚â§ g x
        ¬∑ simp [H]
          exact h‚ÇÇ ‚ü®h‚ÇÇz, H‚ü©
        ¬∑ simp [le_of_not_le H]
          exact h‚ÇÇ ‚ü®z‚ÇÇlt, le_rfl‚ü©
      have : (min (f z) (f x), min (g z) (g x)) ‚àà u √óÀ¢ v := ‚ü®A1, A2‚ü©
      calc
        y < min (f z) (f x) + min (g z) (g x) := h this
        _ ‚â§ f z + g z := add_le_add (min_le_left _ _) (min_le_left _ _)

    ¬∑ simp only [not_exists, not_lt] at hx‚ÇÇ
      filter_upwards [hf z‚ÇÅ z‚ÇÅlt] with z h‚ÇÅz
      have A1 : min (f z) (f x) ‚àà u := by
        by_cases H : f z ‚â§ f x
        ¬∑ simp [H]
          exact h‚ÇÅ ‚ü®h‚ÇÅz, H‚ü©
        ¬∑ simp [le_of_not_le H]
          exact h‚ÇÅ ‚ü®z‚ÇÅlt, le_rfl‚ü©
      have : (min (f z) (f x), g x) ‚àà u √óÀ¢ v := ‚ü®A1, xv‚ü©
      calc
        y < min (f z) (f x) + g x := h this
        _ ‚â§ f z + g z := add_le_add (min_le_left _ _) (hx‚ÇÇ (g z))

  ¬∑ simp only [not_exists, not_lt] at hx‚ÇÅ
    by_cases hx‚ÇÇ : ‚àÉ l, l < g x
    ¬∑ obtain ‚ü®z‚ÇÇ, z‚ÇÇlt, h‚ÇÇ‚ü© : ‚àÉ z‚ÇÇ < g x, Ioc z‚ÇÇ (g x) ‚äÜ v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hx‚ÇÇ
      filter_upwards [hg z‚ÇÇ z‚ÇÇlt] with z h‚ÇÇz
      have A2 : min (g z) (g x) ‚àà v := by
        by_cases H : g z ‚â§ g x
        ¬∑ simp [H]
          exact h‚ÇÇ ‚ü®h‚ÇÇz, H‚ü©
        ¬∑ simp [le_of_not_le H]
          exact h‚ÇÇ ‚ü®z‚ÇÇlt, le_rfl‚ü©
      have : (f x, min (g z) (g x)) ‚àà u √óÀ¢ v := ‚ü®xu, A2‚ü©
      calc
        y < f x + min (g z) (g x) := h this
        _ ‚â§ f z + g z := add_le_add (hx‚ÇÅ (f z)) (min_le_left _ _)
    ¬∑ simp only [not_exists, not_lt] at hx‚ÇÅ hx‚ÇÇ
      apply Filter.eventually_of_forall
      intro z
      have : (f x, g x) ‚àà u √óÀ¢ v := ‚ü®xu, xv‚ü©
      calc
        y < f x + g x := h this
        _ ‚â§ f z + g z := add_le_add (hx‚ÇÅ (f z)) (hx‚ÇÇ (g z))","error:  unknown identifier 'lowerSemicontinuousWithinAt_iff_eventually_lt'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.73253
Œ± : Type u_1
inst‚úù‚Å¥ : TopologicalSpace Œ±
Œ≤ : Type u_2
inst‚úù¬≥ : Preorder Œ≤
f‚úù g‚úù : Œ± ‚Üí Œ≤
x : Œ±
s t : Set Œ±
y z : Œ≤
Œπ : Type u_3
Œ≥ : Type u_4
inst‚úù¬≤ : LinearOrderedAddCommMonoid Œ≥
inst‚úù¬π : TopologicalSpace Œ≥
inst‚úù : OrderTopology Œ≥
f g : Œ± ‚Üí Œ≥
hf : LowerSemicontinuousWithinAt f s x
hg : LowerSemicontinuousWithinAt g s x
hcont : ContinuousAt (fun p ‚Ü¶ p.1 + p.2) (f x, g x)
‚ä¢ LowerSemicontinuousWithinAt (fun z ‚Ü¶ f z + g z) s x
error:  application type mismatch
  LowerSemicontinuousWithinAt.add' ?m.172031 hf hg
argument
  hg
has type
  UpperSemicontinuousWithinAt g s x : Prop
but is expected to have type
  ContinuousAt (fun p ‚Ü¶ p.1 + p.2) (?m.172029 x, f x) : Prop
error:  application type mismatch
  @lowerSemicontinuousWithinAt_sum Œ± ?m.191770 x s Œπ Œ≥·µí·µà ?m.191773 ?m.191774 ?m.191775 ?m.191776 f
argument
  f
has type
  Œπ ‚Üí Œ± ‚Üí Œ≥ : Type (max (max u_1 u_3) u_4)
but is expected to have type
  Finset Œπ : Type u_3","theorem LowerSemicontinuousWithinAt.add' {f g : Œ± ‚Üí Œ≥} (hf : LowerSemicontinuousWithinAt f s x)
    (hg : LowerSemicontinuousWithinAt g s x)
    (hcont : ContinuousAt (fun p : Œ≥ √ó Œ≥ => p.1 + p.2) (f x, g x)) :
    LowerSemicontinuousWithinAt (fun z => f z + g z) s x ",":= by
  intro y hy
  obtain ‚ü®u, v, u_open, xu, v_open, xv, h‚ü© :
    ‚àÉ u v : Set Œ≥,
      IsOpen u ‚àß f x ‚àà u ‚àß IsOpen v ‚àß g x ‚àà v ‚àß u √óÀ¢ v ‚äÜ { p : Œ≥ √ó Œ≥ | y < p.fst + p.snd } :=
    mem_nhds_prod_iff'.1 (hcont (isOpen_Ioi.mem_nhds hy))
  by_cases hx‚ÇÅ : ‚àÉ l, l < f x
  ¬∑ obtain ‚ü®z‚ÇÅ, z‚ÇÅlt, h‚ÇÅ‚ü© : ‚àÉ z‚ÇÅ < f x, Ioc z‚ÇÅ (f x) ‚äÜ u :=
      exists_Ioc_subset_of_mem_nhds (u_open.mem_nhds xu) hx‚ÇÅ
    by_cases hx‚ÇÇ : ‚àÉ l, l < g x
    ¬∑ obtain ‚ü®z‚ÇÇ, z‚ÇÇlt, h‚ÇÇ‚ü© : ‚àÉ z‚ÇÇ < g x, Ioc z‚ÇÇ (g x) ‚äÜ v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hx‚ÇÇ
      filter_upwards [hf z‚ÇÅ z‚ÇÅlt, hg z‚ÇÇ z‚ÇÇlt] with z h‚ÇÅz h‚ÇÇz
      have A1 : min (f z) (f x) ‚àà u := by
        by_cases H : f z ‚â§ f x
        ¬∑ simp [H]
          exact h‚ÇÅ ‚ü®h‚ÇÅz, H‚ü©
        ¬∑ simp [le_of_not_le H]
          exact h‚ÇÅ ‚ü®z‚ÇÅlt, le_rfl‚ü©
      have A2 : min (g z) (g x) ‚àà v := by
        by_cases H : g z ‚â§ g x
        ¬∑ simp [H]
          exact h‚ÇÇ ‚ü®h‚ÇÇz, H‚ü©
        ¬∑ simp [le_of_not_le H]
          exact h‚ÇÇ ‚ü®z‚ÇÇlt, le_rfl‚ü©
      have : (min (f z) (f x), min (g z) (g x)) ‚àà u √óÀ¢ v := ‚ü®A1, A2‚ü©
      calc
        y < min (f z) (f x) + min (g z) (g x) := h this
        _ ‚â§ f z + g z := add_le_add (min_le_left _ _) (min_le_left _ _)

    ¬∑ simp only [not_exists, not_lt] at hx‚ÇÇ
      filter_upwards [hf z‚ÇÅ z‚ÇÅlt] with z h‚ÇÅz
      have A1 : min (f z) (f x) ‚àà u := by
        by_cases H : f z ‚â§ f x
        ¬∑ simp [H]
          exact h‚ÇÅ ‚ü®h‚ÇÅz, H‚ü©
        ¬∑ simp [le_of_not_le H]
          exact h‚ÇÅ ‚ü®z‚ÇÅlt, le_rfl‚ü©
      have : (min (f z) (f x), g x) ‚àà u √óÀ¢ v := ‚ü®A1, xv‚ü©
      calc
        y < min (f z) (f x) + g x := h this
        _ ‚â§ f z + g z := add_le_add (min_le_left _ _) (hx‚ÇÇ (g z))

  ¬∑ simp only [not_exists, not_lt] at hx‚ÇÅ
    by_cases hx‚ÇÇ : ‚àÉ l, l < g x
    ¬∑ obtain ‚ü®z‚ÇÇ, z‚ÇÇlt, h‚ÇÇ‚ü© : ‚àÉ z‚ÇÇ < g x, Ioc z‚ÇÇ (g x) ‚äÜ v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hx‚ÇÇ
      filter_upwards [hg z‚ÇÇ z‚ÇÇlt] with z h‚ÇÇz
      have A2 : min (g z) (g x) ‚àà v := by
        by_cases H : g z ‚â§ g x
        ¬∑ simp [H]
          exact h‚ÇÇ ‚ü®h‚ÇÇz, H‚ü©
        ¬∑ simp [le_of_not_le H]
          exact h‚ÇÇ ‚ü®z‚ÇÇlt, le_rfl‚ü©
      have : (f x, min (g z) (g x)) ‚àà u √óÀ¢ v := ‚ü®xu, A2‚ü©
      calc
        y < f x + min (g z) (g x) := h this
        _ ‚â§ f z + g z := add_le_add (hx‚ÇÅ (f z)) (min_le_left _ _)
    ¬∑ simp only [not_exists, not_lt] at hx‚ÇÅ hx‚ÇÇ
      apply Filter.eventually_of_forall
      intro z
      have : (f x, g x) ‚àà u √óÀ¢ v := ‚ü®xu, xv‚ü©
      calc
        y < f x + g x := h this
        _ ‚â§ f z + g z := add_le_add (hx‚ÇÅ (f z)) (hx‚ÇÇ (g z))",":= by
  rw [lowerSemicontinuousWithinAt_iff_eventually_lt] at hf hg ‚ä¢
  intro y hy
  obtain ‚ü®u, v, u_open, xu, v_open, xv, h‚ü© :
    ‚àÉ u v : Set Œ≥,
      IsOpen u ‚àß f x ‚àà u ‚àß IsOpen v ‚àß g x ‚àà v ‚àß u √óÀ¢ v ‚äÜ { p : Œ≥ √ó Œ≥ | y < p.fst + p.snd } :=
    mem_nhds_prod_iff'.1 (hcont (isOpen_Ioi.mem_nhds hy))
  by_cases hx‚ÇÅ : ‚àÉ l, l < f x
  ¬∑ obtain ‚ü®z‚ÇÅ, z‚ÇÅlt, h‚ÇÅ‚ü© : ‚àÉ z‚ÇÅ < f x, Ioc z‚ÇÅ (f x) ‚äÜ u :=
      exists_Ioc_subset_of_mem_nhds (u_open.mem_nhds xu) hx‚ÇÅ
    by_cases hx‚ÇÇ : ‚àÉ l, l < g x
    ¬∑ obtain ‚ü®z‚ÇÇ, z‚ÇÇlt, h‚ÇÇ‚ü© : ‚àÉ z‚ÇÇ < g x, Ioc z‚ÇÇ (g x) ‚äÜ v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hx‚ÇÇ
      filter_upwards [hf z‚ÇÅ z‚ÇÅlt, hg z‚ÇÇ z‚ÇÇlt] with z h‚ÇÅz h‚ÇÇz
      have A1 : min (f z) (f x) ‚àà u := by
        by_cases H : f z ‚â§ f x
        ¬∑ simp [H]
          exact h‚ÇÅ ‚ü®h‚ÇÅz, H‚ü©
        ¬∑ simp [le_of_not_le H]
          exact h‚ÇÅ ‚ü®z‚ÇÅlt, le_rfl‚ü©
      have : (min (f z) (f x), min (g z) (g x)) ‚àà u √óÀ¢ v := ‚ü®A1, A2‚ü©
      calc
        y < min (f z) (f x) + min (g z) (g x) := h this
        _ ‚â§ f z + g z := add_le_add (min_le_left _ _) (min_le_left _ _)
    ¬∑ simp only [not_exists, not_lt] at hx‚ÇÇ
      filter_upwards [hf z‚ÇÅ z‚ÇÅlt] with z h‚ÇÅz
      have A1 : min (f z) (f x) ‚àà u := by
        by_cases H : f z ‚â§ f x
        ¬∑ simp [H]
          exact h‚ÇÅ ‚ü®h‚ÇÅz, H‚ü©
        ¬∑ simp [le_of_not_le H]
          exact h‚ÇÅ ‚ü®z‚ÇÅlt, le_rfl‚ü©
      have : (min (f z) (f x), g x) ‚àà u √óÀ¢ v := ‚ü®A1, xv‚ü©
      calc
        y < min (f z) (f x) + g x := h this
        _ ‚â§ f z + g z := add_le_add (min_le_left _ _) (min_le_left _ _)
    ¬∑ simp only [not_exists, not_lt] at hx‚ÇÅ
    by_cases hx‚ÇÇ : ‚àÉ l, l < g x
    ¬∑ obtain ‚ü®z‚ÇÇ, z‚ÇÇlt, h‚ÇÇ‚ü© : ‚àÉ z‚ÇÇ < g x, Ioc z‚ÇÇ (g x) ‚äÜ v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hx‚ÇÇ
      filter_upwards [hg z‚ÇÇ z‚ÇÇlt] with z h‚ÇÇz
      have A2 : min (g z) (g x) ‚àà v := by
        by_cases H : g z ‚â§ g x
        ¬∑ simp [H]
          exact h‚ÇÅ ‚ü®h‚ÇÅz, H‚ü©
        ¬∑ simp [le_of_not_le H]
          exact h‚ÇÅ ‚ü®z‚ÇÅlt, le_rfl‚ü©
      have : (min (f z) (f x), g x) ‚àà u √óÀ¢ v := ‚ü®A1, xv‚ü©
      calc
        y < min (f z) (f x) + g x := h this
        _ ‚â§ f z + g z := add_le_add (min_le_left _ _) (min_le_left _ _)
    ¬∑ simp only [not_exists, not_lt] at hx‚ÇÅ
    by_cases hx‚ÇÇ : ‚àÉ l, l < g x
    ¬∑ obtain ‚ü®z‚ÇÇ, z‚ÇÇlt, h‚ÇÇ‚ü© : ‚àÉ z‚ÇÇ < g x, Ioc z‚ÇÇ (g x) ‚äÜ v :=
        exists_Ioc_subset_of_m"
Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean,List.Nat.antidiagonalTuple_one,antidiagonalTuple_one,4153c8119ca54207385194d365e0847cb9c5ca45,":= by
  simp_rw [antidiagonalTuple, antidiagonal, List.range_succ, List.map_append, List.map_singleton,
    tsub_self, List.append_bind, List.bind_singleton, List.map_bind]
  conv_rhs => rw [‚Üê List.nil_append [![n]]]
  congr 1
  simp_rw [List.bind_eq_nil, List.mem_range, List.map_eq_nil]
  intro x hx
  obtain ‚ü®m, rfl‚ü© := Nat.exists_eq_add_of_lt hx
  rw [add_assoc, add_tsub_cancel_left, antidiagonalTuple_zero_succ]",error:  simp made no progress,theorem antidiagonalTuple_one (n : ‚Ñï) : antidiagonalTuple 1 n = [![n]] ,":= by
  simp_rw [antidiagonalTuple, antidiagonal, List.range_succ, List.map_append, List.map_singleton,
    tsub_self, List.append_bind, List.bind_singleton, List.bind_map]
  conv_rhs => rw [‚Üê List.nil_append [![n]]]
  congr 1
  simp_rw [List.bind_eq_nil, List.mem_range, List.map_eq_nil]
  intro x hx
  obtain ‚ü®m, rfl‚ü© := Nat.exists_eq_add_of_lt hx
  rw [add_assoc, add_tsub_cancel_left, antidiagonalTuple_zero_succ]",":= by
  simp_rw [antidiagonalTuple, antidiagonal, List.range_succ, List.map_append, List.map_singleton,
    tsub_self, List.append_bind, List.bind_singleton, List.map_bind]
  conv_rhs => rw [‚Üê List.nil_append [![n]]]
  congr 1
  simp_rw [List.bind_eq_nil, List.mem_range, List.map_eq_nil]
  intro x hx
  obtain ‚ü®m, rfl‚ü© := Nat.exists_eq_add_of_lt hx
  rw [add_assoc, add_tsub_cancel_left, antidiagonalTuple_zero_succ]"
Mathlib/Probability/Kernel/MeasurableIntegral.lean,Measurable.lintegral_kernel_prod_right,_root_.Measurable.lintegral_kernel_prod_right,e6f9a50e9b8db18b96255fd34e1d7e09072168a9,":= by
  let F : ‚Ñï ‚Üí SimpleFunc (Œ± √ó Œ≤) ‚Ñù‚â•0‚àû := SimpleFunc.eapprox (uncurry f)
  have h : ‚àÄ a, (‚®Ü n, F n a) = uncurry f a := SimpleFunc.iSup_eapprox_apply (uncurry f) hf
  simp only [Prod.forall, uncurry_apply_pair] at h
  simp_rw [‚Üê h]
  have : ‚àÄ a, (‚à´‚Åª b, ‚®Ü n, F n (a, b) ‚àÇŒ∫ a) = ‚®Ü n, ‚à´‚Åª b, F n (a, b) ‚àÇŒ∫ a := by
    intro a
    rw [lintegral_iSup]
    ¬∑ exact fun n => (F n).measurable.comp measurable_prod_mk_left
    ¬∑ exact fun i j hij b => SimpleFunc.monotone_eapprox (uncurry f) hij _
  simp_rw [this]
  refine' measurable_iSup fun n => _
  refine' SimpleFunc.induction
    (P := fun f => Measurable (fun (a : Œ±) => ‚à´‚Åª (b : Œ≤), f (a, b) ‚àÇŒ∫ a)) _ _ (F n)
  ¬∑ intro c t ht
    simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,
      SimpleFunc.coe_zero, Set.piecewise_eq_indicator]
    exact Kernel.measurable_lintegral_indicator_const (Œ∫ := Œ∫) ht c
  ¬∑ intro g‚ÇÅ g‚ÇÇ _ hm‚ÇÅ hm‚ÇÇ
    simp only [SimpleFunc.coe_add, Pi.add_apply]
    have h_add :
      (fun a => ‚à´‚Åª b, g‚ÇÅ (a, b) + g‚ÇÇ (a, b) ‚àÇŒ∫ a) =
        (fun a => ‚à´‚Åª b, g‚ÇÅ (a, b) ‚àÇŒ∫ a) + fun a => ‚à´‚Åª b, g‚ÇÇ (a, b) ‚àÇŒ∫ a := by
      ext1 a
      rw [Pi.add_apply]
      erw [lintegral_add_left (g‚ÇÅ.measurable.comp measurable_prod_mk_left)]
      simp_rw [Function.comp_apply]
    rw [h_add]
    exact Measurable.add hm‚ÇÅ hm‚ÇÇ",error:  unknown identifier 'Kernel.measurable_lintegral_indicator_const',"theorem _root_.Measurable.lintegral_kernel_prod_right {f : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù‚â•0‚àû}
    (hf : Measurable (uncurry f)) : Measurable fun a => ‚à´‚Åª b, f a b ‚àÇŒ∫ a ",":= by
  let F : ‚Ñï ‚Üí SimpleFunc (Œ± √ó Œ≤) ‚Ñù‚â•0‚àû := SimpleFunc.eapprox (uncurry f)
  have h : ‚àÄ a, ‚®Ü n, F n a = uncurry f a := SimpleFunc.iSup_eapprox_apply (uncurry f) hf
  simp only [Prod.forall, uncurry_apply_pair] at h
  simp_rw [‚Üê h]
  have : ‚àÄ a, (‚à´‚Åª b, ‚®Ü n, F n (a, b) ‚àÇŒ∫ a) = ‚®Ü n, ‚à´‚Åª b, F n (a, b) ‚àÇŒ∫ a := by
    intro a
    rw [lintegral_iSup]
    ¬∑ exact fun n => (F n).measurable.comp measurable_prod_mk_left
    ¬∑ exact fun i j hij b => SimpleFunc.monotone_eapprox (uncurry f) hij _
  simp_rw [this]
  refine measurable_iSup fun n => ?_
  refine SimpleFunc.induction
    (P := fun f => Measurable (fun (a : Œ±) => ‚à´‚Åª (b : Œ≤), f (a, b) ‚àÇŒ∫ a)) ?_ ?_ (F n)
  ¬∑ intro c t ht
    simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,
      SimpleFunc.coe_zero, Set.piecewise_eq_indicator]
    exact kernel.measurable_lintegral_indicator_const (Œ∫ := Œ∫) ht c
  ¬∑ intro g‚ÇÅ g‚ÇÇ _ hm‚ÇÅ hm‚ÇÇ
    simp only [SimpleFunc.coe_add, Pi.add_apply]
    have h_add :
      (fun a => ‚à´‚Åª b, g‚ÇÅ (a, b) + g‚ÇÇ (a, b) ‚àÇŒ∫ a) =
        (fun a => ‚à´‚Åª b, g‚ÇÅ (a, b) ‚àÇŒ∫ a) + fun a => ‚à´‚Åª b, g‚ÇÇ (a, b) ‚àÇŒ∫ a := by
      ext1 a
      rw [Pi.add_apply]
      erw [lintegral_add_left (g‚ÇÅ.measurable.comp measurable_prod_mk_left)]
      simp_rw [Function.comp_apply]
    rw [h_add]
    exact Measurable.add hm‚ÇÅ hm‚ÇÇ",":= by
  let F : ‚Ñï ‚Üí SimpleFunc (Œ± √ó Œ≤) ‚Ñù‚â•0‚àû := SimpleFunc.eapprox (uncurry f)
  have h : ‚àÄ a, (‚®Ü n, F n a) = uncurry f a := SimpleFunc.iSup_eapprox_apply (uncurry f) hf
  simp only [Prod.forall, uncurry_apply_pair] at h
  simp_rw [‚Üê h]
  have : ‚àÄ a, (‚à´‚Åª b, ‚®Ü n, F n (a, b) ‚àÇŒ∫ a) = ‚®Ü n, ‚à´‚Åª b, F n (a, b) ‚àÇŒ∫ a := by
    intro a
    rw [lintegral_iSup]
    ¬∑ exact fun n => (F n).measurable.comp measurable_prod_mk_left
    ¬∑ exact fun i j hij b => SimpleFunc.monotone_eapprox (uncurry f) hij _
  simp_rw [this]
  refine measurable_iSup fun n => ?_
  refine SimpleFunc.induction
    (P := fun f => Measurable (fun (a : Œ±) => ‚à´‚Åª (b : Œ≤), f (a, b) ‚àÇŒ∫ a)) ?_ ?_ (F n)
  ¬∑ intro c t ht
    simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,
      SimpleFunc.coe_zero, Set.piecewise_eq_indicator]
    exact Kernel.measurable_lintegral_indicator_const (Œ∫ := Œ∫) ht c
  ¬∑ intro g‚ÇÅ g‚ÇÇ _ hm‚ÇÅ hm‚ÇÇ
    simp only [SimpleFunc.coe_add, Pi.add_apply]
    have h_add :
      (fun a => ‚à´‚Åª b, g‚ÇÅ (a, b) + g‚ÇÇ (a, b) ‚àÇŒ∫ a) =
        (fun a => ‚à´‚Åª b, g‚ÇÅ (a, b) ‚àÇŒ∫ a) + fun a => ‚à´‚Åª b, g‚ÇÇ (a, b) ‚àÇŒ∫ a := by
      ext1 a
      rw [Pi.add_apply]
      erw [lintegral_add_left (g‚ÇÅ.measurable.comp measurable_prod_mk_left)]
      simp_rw [Function.comp_apply]
    rw [h_add]
    exact Measurable.add hm‚ÇÅ hm‚ÇÇ"
Mathlib/MeasureTheory/Function/Jacobian.lean,exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt,exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => 0, ?_, ?_?, ?_, _‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' x)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, ?_‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ + ‚Äñf' x - f' z‚Äñ * ‚Äñy - x‚Äñ := by
        refine add_le_add (hŒ¥ ?_) (ContinuousLinearMap.le_opNorm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ‚â§ r (f' z) * ‚Äñy - x‚Äñ := by
        rw [‚Üê add_mul, add_comm]
        gcongr
  have closure_M_subset : ‚àÄ n z, s ‚à© closure (M n z) ‚äÜ M n z := by
    rintro n z x ‚ü®xs, hx‚ü©
    refine ‚ü®xs, fun y hy => ?_‚ü©
    obtain ‚ü®a, aM, a_lim‚ü© : ‚àÉ a : ‚Ñï ‚Üí E, (‚àÄ k, a k ‚àà M n z) ‚àß Tendsto a atTop (ùìù x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ‚Ñï => ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ) atTop
        (ùìù ‚Äñf y - f x - (f' z) (y - x)‚Äñ) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (ùìù (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ‚Ñï => (r (f' z) : ‚Ñù) * ‚Äñy - a k‚Äñ) atTop (ùìù (r (f' z) * ‚Äñy - x‚Äñ)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ‚àÄ·∂† k in atTop, ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ ‚â§ r (f' z) * ‚Äñy - a k‚Äñ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (ùìù (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ‚ü®hy.1, hk‚ü©
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ‚ü®d, hd‚ü©
  let K : ‚Ñï ‚Üí T ‚Üí ‚Ñï ‚Üí Set E := fun n z p => closure (M n z) ‚à© closedBall (d p) (u n / 3)
  have K_approx : ‚àÄ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ‚à© K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ‚àà M n z := closure_M_subset _ _ ‚ü®hy.1, hy.2.1‚ü©
    refine yM.2 _ ‚ü®hx.1, ?_‚ü©
    calc
      dist x y ‚â§ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ‚â§ u n / 3 + u n / 3 := add_le_add hx.2.2 hy.2.2
      _ < u n := by linarith [u_pos n]
  have K_closed : ‚àÄ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñï ‚Üí ‚Ñï √ó T √ó ‚Ñï, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases hs with ‚ü®x, xs‚ü©
      rcases s_subset x xs with ‚ü®n, z, _‚ü©
      exact ‚ü®z‚ü©
    inhabit ‚Ü•T
    exact ‚ü®_, Encodable.surjective_decode_iget (‚Ñï √ó T √ó ‚Ñï)‚ü©
  refine
    ‚ü®fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => ?_, fun q => K_approx _ _ _, fun _ q => ‚ü®(F q).2.1, (F q).2.1.1.2, rfl‚ü©‚ü©
  obtain ‚ü®n, z, hnz‚ü© : ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := s_subset x xs
  obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, x ‚àà closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, d p ‚àà ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ‚ü®p, (mem_ball'.1 hp).le‚ü©
  obtain ‚ü®q, hq‚ü© : ‚àÉ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ‚ü®q, _‚ü©
  simp (config := { zeta := false }) only [K, hq, mem_inter_iff, hp, and_true]
  exact subset_closure hnz","error:  don't know how to synthesize placeholder for argument 'right'
context:
E : Type u_1
F : Type u_2
inst‚úù‚Åµ : NormedAddCommGroup E
inst‚úù‚Å¥ : NormedSpace ‚Ñù E
inst‚úù¬≥ : FiniteDimensional ‚Ñù E
inst‚úù¬≤ : NormedAddCommGroup F
inst‚úù¬π : NormedSpace ‚Ñù F
s : Set E
f‚úù : E ‚Üí E
f'‚úù : E ‚Üí E ‚ÜíL[‚Ñù] E
inst‚úù : SecondCountableTopology F
f : E ‚Üí F
f' : E ‚Üí E ‚ÜíL[‚Ñù] F
r : (E ‚ÜíL[‚Ñù] F) ‚Üí ‚Ñù‚â•0
rpos : ‚àÄ (A : E ‚ÜíL[‚Ñù] F), r A ‚â† 0
hf' : ‚àÄ x ‚àà ‚àÖ, HasFDerivWithinAt f (f' x) ‚àÖ x
‚ä¢ ‚àÖ.Nonempty ‚Üí ‚àÄ (n : ‚Ñï), ‚àÉ y ‚àà ‚àÖ, (fun x ‚Ü¶ 0) n = f' y","theorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]
    (f : E ‚Üí F) (s : Set E) (f' : E ‚Üí E ‚ÜíL[‚Ñù] F) (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x)
    (r : (E ‚ÜíL[‚Ñù] F) ‚Üí ‚Ñù‚â•0) (rpos : ‚àÄ A, r A ‚â† 0) :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] F),
      (‚àÄ n, IsClosed (t n)) ‚àß
        (s ‚äÜ ‚ãÉ n, t n) ‚àß
          (‚àÄ n, ApproximatesLinearOn f (A n) (s ‚à© t n) (r (A n))) ‚àß
            (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) ",":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => 0, ?_, ?_, ?_, ?_‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' x)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, ?_‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ * ‚Äñy - x‚Äñ + ‚Äñf' x - f' z‚Äñ * ‚Äñy - x‚Äñ := by
        refine add_le_add (hŒ¥ ?_) (ContinuousLinearMap.le_opNorm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ‚â§ r (f' z) * ‚Äñy - x‚Äñ := by
        rw [‚Üê add_mul, add_comm]
        gcongr
  have closure_M_subset : ‚àÄ n z, s ‚à© closure (M n z) ‚äÜ M n z := by
    rintro n z x ‚ü®xs, hx‚ü©
    refine ‚ü®xs, fun y hy => ?_‚ü©
    obtain ‚ü®a, aM, a_lim‚ü© : ‚àÉ a : ‚Ñï ‚Üí E, (‚àÄ k, a k ‚àà M n z) ‚àß Tendsto a atTop (ùìù x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ‚Ñï => ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ) atTop
        (ùìù ‚Äñf y - f x - (f' z) (y - x)‚Äñ) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (ùìù (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ‚Ñï => (r (f' z) : ‚Ñù) * ‚Äñy - a k‚Äñ) atTop (ùìù (r (f' z) * ‚Äñy - x‚Äñ)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ‚àÄ·∂† k in atTop, ‚Äñf y - f (a k) - (f' z) (y - a k)‚Äñ ‚â§ r (f' z) * ‚Äñy - a k‚Äñ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (ùìù (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ‚ü®hy.1, hk‚ü©
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ‚ü®d, hd‚ü©
  let K : ‚Ñï ‚Üí T ‚Üí ‚Ñï ‚Üí Set E := fun n z p => closure (M n z) ‚à© closedBall (d p) (u n / 3)
  have K_approx : ‚àÄ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ‚à© K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ‚àà M n z := closure_M_subset _ _ ‚ü®hy.1, hy.2.1‚ü©
    refine yM.2 _ ‚ü®hx.1, ?_‚ü©
    calc
      dist x y ‚â§ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ‚â§ u n / 3 + u n / 3 := add_le_add hx.2.2 hy.2.2
      _ < u n := by linarith [u_pos n]
  have K_closed : ‚àÄ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ‚ü®F, hF‚ü© : ‚àÉ F : ‚Ñï ‚Üí ‚Ñï √ó T √ó ‚Ñï, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases hs with ‚ü®x, xs‚ü©
      rcases s_subset x xs with ‚ü®n, z, _‚ü©
      exact ‚ü®z‚ü©
    inhabit ‚Ü•T
    exact ‚ü®_, Encodable.surjective_decode_iget (‚Ñï √ó T √ó ‚Ñï)‚ü©
  refine
    ‚ü®fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => ?_, fun q => K_approx _ _ _, fun _ q => ‚ü®(F q).2.1, (F q).2.1.1.2, rfl‚ü©‚ü©
  obtain ‚ü®n, z, hnz‚ü© : ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := s_subset x xs
  obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, x ‚àà closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ‚ü®p, hp‚ü© : ‚àÉ p : ‚Ñï, d p ‚àà ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ‚ü®p, (mem_ball'.1 hp).le‚ü©
  obtain ‚ü®q, hq‚ü© : ‚àÉ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ‚ü®q, _‚ü©
  simp (config := { zeta := false }) only [K, hq, mem_inter_iff, hp, and_true]
  exact subset_closure hnz",":= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => 0, ?_, ?_, ?_, ?_, ?_‚ü© <;> simp
  obtain ‚ü®T, T_count, hT‚ü© :
    ‚àÉ T : Set s,
      T.Countable ‚àß ‚ãÉ x ‚àà T, ball (f' (x : E)) (r (f' z)) = ‚ãÉ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ‚ü®u, _, u_pos, u_lim‚ü© :
    ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß Tendsto u atTop (ùìù 0) :=
    exists_seq_strictAnti_tendsto (0 : ‚Ñù)
  let M : ‚Ñï ‚Üí T ‚Üí Set E := fun n z =>
    {x | x ‚àà s ‚àß ‚àÄ y ‚àà s ‚à© ball x (u n), ‚Äñf y - f x - f' z (y - x)‚Äñ ‚â§ r (f' z) * ‚Äñy - x‚Äñ}
  have s_subset : ‚àÄ x ‚àà s, ‚àÉ (n : ‚Ñï) (z : T), x ‚àà M n z := by
    intro x xs
    obtain ‚ü®z, zT, hz‚ü© : ‚àÉ z ‚àà T, f' x ‚àà ball (f' (z : E)) (r (f' z)) := by
      have : f' x ‚àà ‚ãÉ z ‚àà T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ‚ü®‚ü®x, xs‚ü©, ?_‚ü©
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion‚ÇÇ, bex_def] at this
    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ‚Äñf' x - f' z‚Äñ + Œµ ‚â§ r (f' z) := by
      refine ‚ü®r (f' z) - ‚Äñf' x - f' z‚Äñ, ?_, le_of_eq (by abel)‚ü©
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© :
      ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß ball x Œ¥ ‚à© s ‚äÜ {y | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
    obtain ‚ü®n, hn‚ü© : ‚àÉ n, u n < Œ¥ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    intro y hy
    calc
      ‚Äñf y - f x - (f' z) (y - x)‚Äñ = ‚Äñf y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñf y - f x - (f' x) (y - x)‚Äñ + ‚Äñ(f' x - f' z) (y - x)‚Äñ := norm_add_le _ _
      _ ‚â§ Œµ := ((tendsto_order.1 u_lim).2 _ Œ¥pos).exists
    refine ‚ü®n, ‚ü®z, zT‚ü©, ‚ü®xs, ?_‚ü©‚ü©
    i"
Mathlib/Analysis/SpecialFunctions/Integrals.lean,intervalIntegral.intervalIntegrable_rpow',intervalIntegrable_rpow',229bb6cbcc9a67aabf677431de0faf2f1866dbf7,":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg_of_nonneg hx.1.le
    ¬∑ refine' (continuousOn_id.rpow_const _).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine' m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    rw [Pi.smul_apply]
    simp only [Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]","error:  no goals to be solved
warning:  `rpow_nonneg_of_nonneg` has been deprecated, use `Real.rpow_nonneg` instead","theorem intervalIntegrable_rpow' {r : ‚Ñù} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg_of_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const _).div_const ?_; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    rw [Pi.smul_apply]
    simp only [Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,aestronglyMeasurable_of_tendsto_ae,_root_.aestronglyMeasurable_of_tendsto_ae,9745238e7313857e6c78443c861f5654ea43d4a5,":= by
  borelize Œ≤
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®?_, ?_‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà Œº.ae := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ‚ü®closure (‚ãÉ i, t i), .closure <| .iUnion t_sep, ?_‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)","error:  invalid field 'ae', the environment does not contain 'MeasureTheory.Measure.ae'
  Œº
has type
  Measure Œ±","theorem _root_.aestronglyMeasurable_of_tendsto_ae {Œπ : Type*} [PseudoMetrizableSpace Œ≤]
    (u : Filter Œπ) [NeBot u] [IsCountablyGenerated u] {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}
    (hf : ‚àÄ i, AEStronglyMeasurable (f i) Œº) (lim : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) u (ùìù (g x))) :
    AEStronglyMeasurable g Œº ",":= by
  borelize Œ≤
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®?_, ?_‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà ae Œº := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ‚ü®closure (‚ãÉ i, t i), .closure <| .iUnion t_sep, ?_‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)",":= by
  borelize Œ≤
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 ‚ü®?_, ?_‚ü©
  ¬∑ exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  ¬∑ rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
    have : ‚àÄ n : ‚Ñï, ‚àÉ t : Set Œ≤, IsSeparable t ‚àß f (v n) ‚Åª¬π' t ‚àà Œº.ae := fun n =>
      (aestronglyMeasurable_iff_aemeasurable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ‚ü®closure (‚ãÉ i, t i), .closure <| .iUnion t_sep, ?_‚ü©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)"
Mathlib/MeasureTheory/Integral/Lebesgue.lean,MeasureTheory.lintegral_add_mul_meas_add_le_le_lintegral,lintegral_add_mul_meas_add_le_le_lintegral,c5594244d6b6e5e0c0a479a4501c34b0ea194fce,":= by
  rcases exists_measurable_le_lintegral_eq Œº f with ‚ü®œÜ, hœÜm, hœÜ_le, hœÜ_eq‚ü©
  calc
    ‚à´‚Åª x, f x ‚àÇŒº + Œµ * Œº { x | f x + Œµ ‚â§ g x } = ‚à´‚Åª x, œÜ x ‚àÇŒº + Œµ * Œº { x | f x + Œµ ‚â§ g x } :=
      by rw [hœÜ_eq]
    _ ‚â§ ‚à´‚Åª x, œÜ x ‚àÇŒº + Œµ * Œº { x | œÜ x + Œµ ‚â§ g x } := by
      gcongr
      exact measure_mono fun x => (add_le_add_right (hœÜ_le _) _).trans
    _ = ‚à´‚Åª x, œÜ x + indicator { x | œÜ x + Œµ ‚â§ g x } (fun _ => Œµ) x ‚àÇŒº := by
      rw [lintegral_add_left hœÜm, lintegral_indicator‚ÇÄ, set_lintegral_const]
      exact measurableSet_le (hœÜm.nullMeasurable.measurable'.add_const _) hg.nullMeasurable
    _ ‚â§ ‚à´‚Åª x, g x ‚àÇŒº := lintegral_mono_ae (hle.mono fun x hx‚ÇÅ => ?_)
  simp only [indicator_apply]; split_ifs with hx‚ÇÇ
  exacts [hx‚ÇÇ, (add_zero _).trans_le <| (hœÜ_le x).trans hx‚ÇÅ]","warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
error:  typeclass instance problem is stuck, it is often due to metavariables
  OuterMeasureClass ?m.236556 ?m.236555
warning:  `MeasureTheory.set_lintegral_const` has been deprecated, use `MeasureTheory.setLIntegral_const` instead","theorem lintegral_add_mul_meas_add_le_le_lintegral {f g : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hle : f ‚â§·µê[Œº] g)
    (hg : AEMeasurable g Œº) (Œµ : ‚Ñù‚â•0‚àû) :
    ‚à´‚Åª a, f a ‚àÇŒº + Œµ * Œº { x | f x + Œµ ‚â§ g x } ‚â§ ‚à´‚Åª a, g a ‚àÇŒº ",":= by
  rcases exists_measurable_le_lintegral_eq Œº f with ‚ü®œÜ, hœÜm, hœÜ_le, hœÜ_eq‚ü©
  calc
    ‚à´‚Åª x, f x ‚àÇŒº + Œµ * Œº { x | f x + Œµ ‚â§ g x } = ‚à´‚Åª x, œÜ x ‚àÇŒº + Œµ * Œº { x | f x + Œµ ‚â§ g x } := by
      rw [hœÜ_eq]
    _ ‚â§ ‚à´‚Åª x, œÜ x ‚àÇŒº + Œµ * Œº { x | œÜ x + Œµ ‚â§ g x } := by
      gcongr
      exact fun x => (add_le_add_right (hœÜ_le _) _).trans
    _ = ‚à´‚Åª x, œÜ x + indicator { x | œÜ x + Œµ ‚â§ g x } (fun _ => Œµ) x ‚àÇŒº := by
      rw [lintegral_add_left hœÜm, lintegral_indicator‚ÇÄ, setLIntegral_const]
      exact measurableSet_le (hœÜm.nullMeasurable.measurable'.add_const _) hg.nullMeasurable
    _ ‚â§ ‚à´‚Åª x, g x ‚àÇŒº := lintegral_mono_ae (hle.mono fun x hx‚ÇÅ => ?_)
  simp only [indicator_apply]; split_ifs with hx‚ÇÇ
  exacts [hx‚ÇÇ, (add_zero _).trans_le <| (hœÜ_le x).trans hx‚ÇÅ]",":= by
  rcases exists_measurable_le_lintegral_eq Œº f with ‚ü®œÜ, hœÜm, hœÜ_le, hœÜ_eq‚ü©
  calc
    ‚à´‚Åª x, f x ‚àÇŒº + Œµ * Œº { x | f x + Œµ ‚â§ g x } = ‚à´‚Åª x, œÜ x ‚àÇŒº + Œµ * Œº { x | f x + Œµ ‚â§ g x } :=
      by rw [hœÜ_eq]
    _ ‚â§ ‚à´‚Åª x, œÜ x ‚àÇŒº + Œµ * Œº { x | œÜ x + Œµ ‚â§ g x } := by
      gcongr
      exact measure_mono fun x => (add_le_add_right (hœÜ_le _) _).trans
    _ = ‚à´‚Åª x, œÜ x + indicator { x | œÜ x + Œµ ‚â§ g x } (fun _ => Œµ) x ‚àÇŒº := by
      rw [lintegral_add_left hœÜm, lintegral_indicator‚ÇÄ, setIntegral_const]
      exact measurableSet_le (hœÜm.nullMeasurable.measurable'.add_const _) hg.nullMeasurable
    _ ‚â§ ‚à´‚Åª x, g x ‚àÇŒº := lintegral_mono_ae (hle.mono fun x hx‚ÇÅ => ?_)
  simp only [indicator_apply]; split_ifs with hx‚ÇÇ
  exacts [hx‚ÇÇ, (add_zero _).trans_le <| (hœÜ_le x).trans hx‚ÇÅ]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,d925bcb6a40d20ae582767f1a25d9e5251b014c6,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_ad"
Mathlib/Analysis/NormedSpace/Units.lean,Ideal.closure_ne_top,closure_ne_top,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  have h := closure_minimal (coe_subset_nonunits hI) nonunits.isClosed
  simpa only [I.closure.eq_top_iff_one, Ne.def] using mt (@h 1) one_not_mem_nonunits","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.85551 ‚Üí ?m.85551 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  1 ‚àâ closure ‚ÜëI : Prop
but is expected to have type
  I.closure ‚â† ‚ä§ : Prop",theorem closure_ne_top (I : Ideal R) (hI : I ‚â† ‚ä§) : I.closure ‚â† ‚ä§ ,":= by
  have h := closure_minimal (coe_subset_nonunits hI) nonunits.isClosed
  simpa only [I.closure.eq_top_iff_one, Ne] using mt (@h 1) one_not_mem_nonunits",":= by
  have h := closure_minimal (coe_subset_nonunits hI) nonunits.isClosed
  simpa only [I.closure.eq_top_iff_one, Ne] using mt (@h 1) one_not_mem_nonunits"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.aemeasurable_fderivWithin,aemeasurable_fderivWithin,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, _‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
              (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ‚ü®g, g_meas.aemeasurable, ?_‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n ‚Ü¶ Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono (inter_subset_left _ _)
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono (inter_subset_right _ _) le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1","error:  function expected at
  inter_subset_left ?m.375907
term has type
  ?m.375906 ‚àà ?m.375904
error:  function expected at
  inter_subset_left ?m.377059
term has type
  ?m.377058 ‚àà ?m.377056
error:  function expected at
  inter_subset_right ?m.377638
term has type
  ?m.377637 ‚àà ?m.377636","theorem aemeasurable_fderivWithin (hs : MeasurableSet s)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (Œº.restrict s) ",":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, _‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
              (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ‚ü®g, g_meas.aemeasurable, ?_‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n ‚Ü¶ Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1",":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, ?_‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
             (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ‚ü®g, g_meas.aemeasurable, ?_‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n ‚Ü¶ Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1"
Mathlib/Computability/RegularExpressions.lean,RegularExpression.star_rmatch_iff,star_rmatch_iff,a36d8932e98ea1d7efcdd316318586a6329f53a3,":=
  fun x => by
    have A : ‚àÄ m n : ‚Ñï, n < m + n + 1 := by
      intro m n
      convert add_lt_add_of_le_of_lt (add_le_add (zero_le m) (le_refl n)) zero_lt_one
      simp
    have IH := fun t (_h : List.length t < List.length x) => star_rmatch_iff P t
    clear star_rmatch_iff
    constructor
    ¬∑ cases' x with a x
      ¬∑ intro _h
        use []; dsimp; tauto
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        rintro ‚ü®t, u, hs, ht, hu‚ü©
        have hwf : u.length < (List.cons a x).length := by
          rw [hs, List.length_cons, List.length_append]
          apply A
        rw [IH _ hwf] at hu
        rcases hu with ‚ü®S', hsum, helem‚ü©
        use (a :: t) :: S'
        constructor
        ¬∑ simp [hs, hsum]
        ¬∑ intro t' ht'
          cases ht' with
          | head ht' =>
            simp only [ne_eq, not_false_iff, true_and, rmatch]
            exact ht
          | tail _ ht' => exact helem t' ht'
    ¬∑ rintro ‚ü®S, hsum, helem‚ü©
      cases' x with a x
      ¬∑ rfl
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        cases' S with t' U
        ¬∑ exact ‚ü®[], [], by tauto‚ü©
        ¬∑ cases' t' with b t
          ¬∑ simp only [forall_eq_or_imp, List.mem_cons] at helem
            simp only [eq_self_iff_true, not_true, Ne, false_and_iff] at helem
          simp only [List.join, List.cons_append, List.cons_eq_cons] at hsum
          refine' ‚ü®t, U.join, hsum.2, _, _‚ü©
          ¬∑ specialize helem (b :: t) (by simp)
            rw [rmatch] at helem
            convert helem.2
            exact hsum.1
          ¬∑ have hwf : U.join.length < (List.cons a x).length := by
              rw [hsum.1, hsum.2]
              simp only [List.length_append, List.length_join, List.length]
              apply A
            rw [IH _ hwf]
            refine ‚ü®U, rfl, fun t h => helem t ?_‚ü©
            right
            assumption
  termination_by t => (P, t.length)","error:  application type mismatch
  add_le_add (zero_le m) (le_refl n)
argument
  le_refl n
has type
  @LE.le ‚Ñï (@Preorder.toLE ‚Ñï (@PartialOrder.toPreorder ‚Ñï SemilatticeInf.toPartialOrder)) n n : Prop
but is expected to have type
  @LE.le ‚Ñï (@Preorder.toLE ‚Ñï (@PartialOrder.toPreorder ‚Ñï OrderedAddCommMonoid.toPartialOrder)) n n : Prop","theorem star_rmatch_iff (P : RegularExpression Œ±) :
    ‚àÄ x : List Œ±, (star P).rmatch x ‚Üî ‚àÉ S : List (List Œ±), x
          = S.join ‚àß ‚àÄ t ‚àà S, t ‚â† [] ‚àß P.rmatch t ",":=
  fun x => by
    have IH := fun t (_h : List.length t < List.length x) => star_rmatch_iff P t
    clear star_rmatch_iff
    constructor
    ¬∑ cases' x with a x
      ¬∑ intro _h
        use []; dsimp; tauto
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        rintro ‚ü®t, u, hs, ht, hu‚ü©
        have hwf : u.length < (List.cons a x).length := by
          rw [hs, List.length_cons, List.length_append]
          omega
        rw [IH _ hwf] at hu
        rcases hu with ‚ü®S', hsum, helem‚ü©
        use (a :: t) :: S'
        constructor
        ¬∑ simp [hs, hsum]
        ¬∑ intro t' ht'
          cases ht' with
          | head ht' =>
            simp only [ne_eq, not_false_iff, true_and, rmatch]
            exact ht
          | tail _ ht' => exact helem t' ht'
    ¬∑ rintro ‚ü®S, hsum, helem‚ü©
      cases' x with a x
      ¬∑ rfl
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        cases' S with t' U
        ¬∑ exact ‚ü®[], [], by tauto‚ü©
        ¬∑ cases' t' with b t
          ¬∑ simp only [forall_eq_or_imp, List.mem_cons] at helem
            simp only [eq_self_iff_true, not_true, Ne, false_and_iff] at helem
          simp only [List.join, List.cons_append, List.cons_eq_cons] at hsum
          refine ‚ü®t, U.join, hsum.2, ?_, ?_‚ü©
          ¬∑ specialize helem (b :: t) (by simp)
            rw [rmatch] at helem
            convert helem.2
            exact hsum.1
          ¬∑ have hwf : U.join.length < (List.cons a x).length := by
              rw [hsum.1, hsum.2]
              simp only [List.length_append, List.length_join, List.length]
              omega
            rw [IH _ hwf]
            refine ‚ü®U, rfl, fun t h => helem t ?_‚ü©
            right
            assumption
  termination_by t => (P, t.length)",":=
  fun x => by
    have A : ‚àÄ m n : ‚Ñï, n < m + n + 1 := by
      intro m n
      convert add_lt_add_of_le_of_lt (add_le_add (zero_le m) (le_refl n)) zero_lt_one
      simp
    have IH := fun t (_h : List.length t < List.length x) => star_rmatch_iff P t
    clear star_rmatch_iff
    constructor
    ¬∑ cases' x with a x
      ¬∑ intro _h
        use []; dsimp; tauto
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        rintro ‚ü®t, u, hs, ht, hu‚ü©
        have hwf : u.length < (List.cons a x).length := by
          rw [hs, List.length_cons, List.length_append]
          apply A
        rw [IH _ hwf] at hu
        rcases hu with ‚ü®S', hsum, helem‚ü©
        use (a :: t) :: S'
        constructor
        ¬∑ simp [hs, hsum]
        ¬∑ intro t' ht'
          cases ht' with
          | head ht' =>
            simp only [ne_eq, not_false_iff, true_and, rmatch]
            exact ht
           | tail _ ht' => exact helem t' ht'
    ¬∑ rintro ‚ü®S, hsum, helem‚ü©
      cases' x with a x
      ¬∑ rfl
      ¬∑ rw [rmatch, deriv, mul_rmatch_iff]
        cases' S with t' U
        ¬∑ exact ‚ü®[], [], by tauto‚ü©
        ¬∑ cases' t' with b t
          ¬∑ simp only [forall_eq_or_imp, List.mem_cons] at helem
            simp only [eq_self_iff_true, not_true, Ne, false_and_iff] at helem
          simp only [List.join, List.cons_append, List.cons_eq_cons] at hsum
          refine ‚ü®t, U.join, hsum.2, ?_, ?_‚ü©
          ¬∑ specialize helem (b :: t) (by simp)
           rw [rmatch] at helem
            convert helem.2
            exact hsum.1
          ¬∑ have hwf : U.join.length < (List.cons a x).length := by
             rw [hsum.1, hsum.2]
              simp only [List.length_append, List.length_join, List.length]
              apply A
            rw [IH _ hwf]
            refine ‚ü®U, rfl, fun t h => helem t ?_‚ü©
            right
            assumption
  termination_by t => (P, t.length)"
Mathlib/Topology/UniformSpace/Cauchy.lean,TotallyBounded.closure,TotallyBounded.closure,20100f1475ea197bf6dea643b6ee137219455a51,":=
  uniformity_hasBasis_closed.totallyBounded_iff.2 fun V hV =>
    let ‚ü®t, htf, hst‚ü© := h V hV.1
    ‚ü®t, htf,
      closure_minimal hst <|
        isClosed_biUnion htf fun _ _ => hV.2.preimage (continuous_id.prod_mk continuous_const)‚ü©",error:  unknown identifier 'isClosed_biUnion',theorem TotallyBounded.closure {s : Set Œ±} (h : TotallyBounded s) : TotallyBounded (closure s) ,":=
  uniformity_hasBasis_closed.totallyBounded_iff.2 fun V hV =>
    let ‚ü®t, htf, hst‚ü© := h V hV.1
    ‚ü®t, htf,
      closure_minimal hst <|
        htf.isClosed_biUnion fun _ _ => hV.2.preimage (continuous_id.prod_mk continuous_const)‚ü©",":=
  uniformity_hasBasis_closed.totallyBounded_iff.2 fun V hV =>
    let ‚ü®t, htf, hst‚ü© := h V hV.1
    ‚ü®t, htf,
      closure_minimal hst <|
        isClosed_biUnion htf fun _ _ => hV.2.preimage continuous_id.prod_mk continuous_const)‚ü©"
Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean,gramSchmidt_orthogonal,gramSchmidt_orthogonal,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ ha
    ¬∑ rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply wellFounded_lt.induction b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    ¬∑ rw [IsROrC.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ","error:  unknown identifier 'IsROrC.ofReal_pow'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.51260
case neg
ùïú : Type u_1
E : Type u_2
inst‚úù‚Åµ : RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : InnerProductSpace ùïú E
Œπ : Type u_3
inst‚úù¬≤ : LinearOrder Œπ
inst‚úù¬π : LocallyFiniteOrderBot Œπ
inst‚úù : IsWellOrder Œπ fun x x_1 ‚Ü¶ x < x_1
f : Œπ ‚Üí E
b‚úù b : Œπ
ih : ‚àÄ y < b, ‚àÄ a < y, ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f y‚ü´_ùïú = 0
a : Œπ
h‚ÇÄ : a < b
h : ¬¨gramSchmidt ùïú f a = 0
‚ä¢ ‚ü™gramSchmidt ùïú f a, f b‚ü´_ùïú -
      ‚ü™gramSchmidt ùïú f a, f b‚ü´_ùïú / ‚Üë(‚ÄñgramSchmidt ùïú f a‚Äñ ^ 2) * ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f a‚ü´_ùïú =
    0","theorem gramSchmidt_orthogonal (f : Œπ ‚Üí E) {a b : Œπ} (h‚ÇÄ : a ‚â† b) :
    ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 ",":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ ha
    ¬∑ rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply wellFounded_lt.induction b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    ¬∑ rw [RCLike.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel‚ÇÄ, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ",":= by
  suffices ‚àÄ a b : Œπ, a < b ‚Üí ‚ü™gramSchmidt ùïú f a, gramSchmidt ùïú f b‚ü´ = 0 by
    cases' h‚ÇÄ.lt_or_lt with ha hb
    ¬∑ exact this _ _ ha
    ¬∑ rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h‚ÇÄ a b
  intro a b h‚ÇÄ
  revert a
  apply wellFounded_lt.induction b
  intro b ih a h‚ÇÄ
  simp only [gramSchmidt_def ùïú f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h‚ÇÄ)]
  ¬∑ by_cases h : gramSchmidt ùïú f a = 0
    ¬∑ simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    ¬∑ rw [IsROrC.ofReal_pow, ‚Üê inner_self_eq_norm_sq_to_K, div_mul_cancel, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia‚ÇÅ hia‚ÇÇ
  ¬∑ rw [inner_eq_zero_symm]
    exact ih a h‚ÇÄ i hia‚ÇÅ
  ¬∑ exact ih i (mem_Iio.1 hi) a hia‚ÇÇ"
Mathlib/LinearAlgebra/Matrix/PosDef.lean,QuadraticForm.posDef_of_toMatrix',posDef_of_toMatrix',b82e978679b451490878b9d55401f33dea523113,":= by
  rw [‚Üê toQuadraticMap_associated ‚Ñù Q,
    ‚Üê LinearMap.toMatrix‚ÇÇ'.left_inv ((associatedHom (R := ‚Ñù) ‚Ñù) Q)]
  exact hQ.toQuadraticForm'","error:  unknown identifier 'toQuadraticMap_associated'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.178189
n : Type u_1
inst‚úù¬π : Fintype n
inst‚úù : DecidableEq n
Q : QuadraticForm ‚Ñù (n ‚Üí ‚Ñù)
hQ : Q.toMatrix'.PosDef
‚ä¢ Q.PosDef","theorem posDef_of_toMatrix' [DecidableEq n] {Q : QuadraticForm ‚Ñù (n ‚Üí ‚Ñù)}
    (hQ : Q.toMatrix'.PosDef) : Q.PosDef ",":= by
  rw [‚Üê toQuadraticForm_associated ‚Ñù Q,
    ‚Üê LinearMap.toMatrix‚ÇÇ'.left_inv ((associatedHom (R := ‚Ñù) ‚Ñù) Q)]
  exact hQ.toQuadraticForm'",":= by
  rw [‚Üê toQuadraticMap_associated ‚Ñù Q,
    ‚Üê LinearMap.toMatrix‚ÇÇ'.left_inv ((associatedHom (R := ‚Ñù) ‚Ñù) Q)]
  rfl"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.sum_weightedHomogeneousComponent,sum_weightedHomogeneousComponent,c04b29dd6b022753894b2fc21d2d4951e76e339e,":= by
  rw [finsum_eq_sum _ (weightedHomogeneousComponent_finsupp œÜ)]
  ext1 d
  simp only [coeff_sum, coeff_weightedHomogeneousComponent]
  rw [Finset.sum_eq_single (weightedDegree' w d)]
  ¬∑ rw [if_pos rfl]
  ¬∑ intro m _ hm'
    rw [if_neg hm'.symm]
  ¬∑ intro hm
    rw [if_pos rfl]
    simp only [Finite.mem_toFinset, mem_support, Ne.def, Classical.not_not] at hm
    have := coeff_weightedHomogeneousComponent (w := w) (weightedDegree' w d) œÜ d
    rw [hm, if_pos rfl, coeff_zero] at this
    exact this.symm","error:  unknown identifier 'weightedDegree''
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  if ?m.94968 = ?m.94968 then ?m.94970 else ?m.94971
case a
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
n : M
œÜ œà : MvPolynomial œÉ R
d : œÉ ‚Üí‚ÇÄ ‚Ñï
‚ä¢ coeff d ((weightedHomogeneousComponent w (sorryAx M true)) œÜ) = coeff d œÜ
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  if ?m.95012 = ?m.95012 then ?m.95014 else ?m.95015
case a.h‚ÇÅ
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
n : M
œÜ œà : MvPolynomial œÉ R
d : œÉ ‚Üí‚ÇÄ ‚Ñï
hm : sorryAx M true ‚àâ ‚ãØ.toFinset
‚ä¢ coeff d ((weightedHomogeneousComponent w (sorryAx M true)) œÜ) = 0","theorem sum_weightedHomogeneousComponent :
    (finsum fun m => weightedHomogeneousComponent w m œÜ) = œÜ ",":= by
  classical
  rw [finsum_eq_sum _ (weightedHomogeneousComponent_finsupp œÜ)]
  ext1 d
  simp only [coeff_sum, coeff_weightedHomogeneousComponent]
  rw [Finset.sum_eq_single (weightedDegree w d)]
  ¬∑ rw [if_pos rfl]
  ¬∑ intro m _ hm'
    rw [if_neg hm'.symm]
  ¬∑ intro hm
    rw [if_pos rfl]
    simp only [Finite.mem_toFinset, mem_support, Ne, Classical.not_not] at hm
    have := coeff_weightedHomogeneousComponent (w := w) (weightedDegree w d) œÜ d
    rw [hm, if_pos rfl, coeff_zero] at this
    exact this.symm",":= by
  rw [finsum_eq_sum _ (weightedHomogeneousComponent_finsupp œÜ)]
  ext1 d
  simp only [coeff_sum, coeff_weightedHomogeneousComponent]
  rw [Finset.sum_eq_single (weightedDegree' w d)]
  ¬∑ rw [if_pos rfl]
  ¬∑ intro m _ hm'
    rw [if_neg hm'.symm]
  ¬∑ intro hm
    rw [if_pos rfl]
    simp only [Finite.mem_toFinset, mem_support, Ne, Classical.not_not] at hm
    have := coeff_weightedHomogeneousComponent (w := w) (weightedDegree' w d) œÜ d
    rw [hm, if_pos rfl, coeff_zero] at this
    exact this.symm"
Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean,NNReal.strictConcaveOn_rpow,strictConcaveOn_rpow,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  have hp‚ÇÄ' : 0 < 1 / p := by positivity
  have hp‚ÇÅ' : 1 < 1 / p := by rw [one_lt_div hp‚ÇÄ]; exact hp‚ÇÅ
  let f := NNReal.orderIsoRpow (1 / p) hp‚ÇÄ'
  have h‚ÇÅ : StrictConvexOn ‚Ñù‚â•0 univ f := by
    refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
    exact (strictConvexOn_rpow hp‚ÇÅ').2 (by positivity : 0 ‚â§ x) (by positivity : 0 ‚â§ y)
      (by simp [hxy]) ha hb (by simp; norm_cast)
  have h‚ÇÇ : ‚àÄ x, f.symm x = x ^ p := by simp [NNReal.orderIsoRpow_symm_eq]
  refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
  simp only [‚Üêh‚ÇÇ]
  exact (f.strictConcaveOn_symm h‚ÇÅ).2 (Set.mem_univ x) (Set.mem_univ y) hxy ha hb hab",error:  simp made no progress,"lemma strictConcaveOn_rpow {p : ‚Ñù} (hp‚ÇÄ : 0 < p) (hp‚ÇÅ : p < 1) :
    StrictConcaveOn ‚Ñù‚â•0 univ fun x : ‚Ñù‚â•0 ‚Ü¶ x ^ p ",":= by
  have hp‚ÇÄ' : 0 < 1 / p := div_pos zero_lt_one hp‚ÇÄ
  have hp‚ÇÅ' : 1 < 1 / p := by rw [one_lt_div hp‚ÇÄ]; exact hp‚ÇÅ
  let f := NNReal.orderIsoRpow (1 / p) hp‚ÇÄ'
  have h‚ÇÅ : StrictConvexOn ‚Ñù‚â•0 univ f := by
    refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
    exact (strictConvexOn_rpow hp‚ÇÅ').2 x.2 y.2 (by simp [hxy]) ha hb (by simp; norm_cast)
  have h‚ÇÇ : ‚àÄ x, f.symm x = x ^ p := by simp [f, NNReal.orderIsoRpow_symm_eq]
  refine ‚ü®convex_univ, fun x mx y my hxy a b ha hb hab => ?_‚ü©
  simp only [‚Üê h‚ÇÇ]
  exact (f.strictConcaveOn_symm h‚ÇÅ).2 mx my hxy ha hb hab",":= by
  have hp‚ÇÄ' : 0 < 1 / p := by positivity
  have hp‚ÇÅ' : 1 < 1 / p := by rw [one_lt_div hp‚ÇÄ]; exact hp‚ÇÅ
  let f := NNReal.orderIsoRpow (1 / p) hp‚ÇÄ'
  have h‚ÇÅ : StrictConvexOn ‚Ñù‚â•0 univ f := by
    refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
    exact (strictConvexOn_rpow hp‚ÇÅ').2 (by positivity : 0 ‚â§ x) (by positivity : 0 ‚â§ y)
      (by simp [hxy]) ha hb (by simp; norm_cast)
  have h‚ÇÇ : ‚àÄ x, f.symm x = x ^ p := by simp [NNReal.orderIsoRpow_symm_eq]
  refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
  simp only [‚Üê h‚ÇÇ]
  exact (f.strictConcaveOn_symm h‚ÇÅ).2 (Set.mem_univ x) (Set.mem_univ y) hxy ha hb hab"
Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,CategoryTheory.MorphismProperty.LeftFraction.comp‚ÇÄ_rel,comp‚ÇÄ_rel,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  obtain ‚ü®z‚ÇÑ, fac‚ü© := exists_leftFraction (RightFraction.mk z‚ÇÉ.s z‚ÇÉ.hs z‚ÇÉ'.s)
  dsimp at fac
  have eq : z‚ÇÅ.s ‚â´ z‚ÇÉ.f ‚â´ z‚ÇÑ.f = z‚ÇÅ.s ‚â´ z‚ÇÉ'.f ‚â´ z‚ÇÑ.s := by
    rw [‚Üê reassoc_of% h‚ÇÉ, ‚Üê reassoc_of% h‚ÇÉ', fac]
  obtain ‚ü®Y, t, ht, fac'‚ü© := ext _ _ _ z‚ÇÅ.hs eq
  simp only [assoc] at fac'
  refine' ‚ü®Y, z‚ÇÑ.f ‚â´ t, z‚ÇÑ.s ‚â´ t, _, _, _‚ü©
  ¬∑ simp only [comp‚ÇÄ, assoc, reassoc_of% fac]
  ¬∑ simp only [comp‚ÇÄ, assoc, fac']
  ¬∑ simp only [comp‚ÇÄ, assoc, ‚Üê reassoc_of% fac]
    exact W.comp_mem _ _ z‚ÇÇ.hs (W.comp_mem _ _ z‚ÇÉ'.hs (W.comp_mem _ _ z‚ÇÑ.hs ht))","error:  function expected at
  ext ?m.29671 ?m.29672 ?m.29673
term has type
  ?m.29671 = ?m.29672
error:  rcases tactic failed: x‚úù : ?m.29785 is not an inductive datatype","lemma comp‚ÇÄ_rel {X Y Z : C} (z‚ÇÅ : W.LeftFraction X Y) (z‚ÇÇ : W.LeftFraction Y Z)
    (z‚ÇÉ z‚ÇÉ' : W.LeftFraction z‚ÇÅ.Y' z‚ÇÇ.Y') (h‚ÇÉ : z‚ÇÇ.f ‚â´ z‚ÇÉ.s = z‚ÇÅ.s ‚â´ z‚ÇÉ.f)
    (h‚ÇÉ' : z‚ÇÇ.f ‚â´ z‚ÇÉ'.s = z‚ÇÅ.s ‚â´ z‚ÇÉ'.f) :
    LeftFractionRel (z‚ÇÅ.comp‚ÇÄ z‚ÇÇ z‚ÇÉ) (z‚ÇÅ.comp‚ÇÄ z‚ÇÇ z‚ÇÉ') ",":= by
  obtain ‚ü®z‚ÇÑ, fac‚ü© := exists_leftFraction (RightFraction.mk z‚ÇÉ.s z‚ÇÉ.hs z‚ÇÉ'.s)
  dsimp at fac
  have eq : z‚ÇÅ.s ‚â´ z‚ÇÉ.f ‚â´ z‚ÇÑ.f = z‚ÇÅ.s ‚â´ z‚ÇÉ'.f ‚â´ z‚ÇÑ.s := by
    rw [‚Üê reassoc_of% h‚ÇÉ, ‚Üê reassoc_of% h‚ÇÉ', fac]
  obtain ‚ü®Y, t, ht, fac'‚ü© := HasLeftCalculusOfFractions.ext _ _ _ z‚ÇÅ.hs eq
  simp only [assoc] at fac'
  refine ‚ü®Y, z‚ÇÑ.f ‚â´ t, z‚ÇÑ.s ‚â´ t, ?_, ?_, ?_‚ü©
  ¬∑ simp only [comp‚ÇÄ, assoc, reassoc_of% fac]
  ¬∑ simp only [comp‚ÇÄ, assoc, fac']
  ¬∑ simp only [comp‚ÇÄ, assoc, ‚Üê reassoc_of% fac]
    exact W.comp_mem _ _ z‚ÇÇ.hs (W.comp_mem _ _ z‚ÇÉ'.hs (W.comp_mem _ _ z‚ÇÑ.hs ht))",":= by
  obtain ‚ü®z‚ÇÑ, fac‚ü© := exists_leftFraction (RightFraction.mk z‚ÇÉ.s z‚ÇÉ.hs z‚ÇÉ'.s)
  dsimp at fac
  have eq : z‚ÇÅ.s ‚â´ z‚ÇÉ.f ‚â´ z‚ÇÑ.f = z‚ÇÅ.s ‚â´ z‚ÇÉ'.f ‚â´ z‚ÇÑ.s := by
    rw [‚Üê reassoc_of% h‚ÇÉ, ‚Üê reassoc_of% h‚ÇÉ', fac]
  obtain ‚ü®Y, t, ht, fac'‚ü© := ext _ _ _ z‚ÇÅ.hs eq
  simp only [assoc] at fac'
  refine ‚ü®Y, z‚ÇÑ.f ‚â´ t, z‚ÇÑ.s ‚â´ t, ?_, ?_, ?_‚ü©
  ¬∑ simp only [comp‚ÇÄ, assoc, reassoc_of% fac]
  ¬∑ simp only [comp‚ÇÄ, assoc, fac']
  ¬∑ simp only [comp‚ÇÄ, assoc, ‚Üê reassoc_of% fac]
    exact W.comp_mem _ _ z‚ÇÇ.hs (W.comp_mem _ _ z‚ÇÉ'.hs (W.comp_mem _ _ z‚ÇÑ.hs ht))"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpi_tfae,effectiveEpi_tfae,65286a1e3e7bcef3a2e6ac0e19374d74e4bf7d6a,":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®CompHausLike.struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",error:  unknown identifier 'CompHausLike.struct',"theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (œÄ : X ‚ü∂ B) :
    TFAE
    [ EffectiveEpi œÄ
    , Epi œÄ
    , Function.Surjective œÄ
    ] ",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®CompHausLike.struct œÄ hœÄ‚ü©‚ü©
  tfae_finish"
Mathlib/RingTheory/DedekindDomain/Factorization.lean,Ideal.finite_mulSupport_inv,finite_mulSupport_inv,04cf8c4630518d88c67bf9ba4d4db872ea86f7e2,":= by
  rw [mulSupport]
  simp_rw [zpow_neg, Ne.def, inv_eq_one]
  exact finite_mulSupport_coe hI","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.14537 ‚Üí ?m.14537 ‚Üí Prop
error:  simp made no progress","theorem finite_mulSupport_inv {I : Ideal R} (hI : I ‚â† 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R‚Å∞ K) ^
      (-((Associates.mk v.asIdeal).count (Associates.mk I).factors : ‚Ñ§))).Finite ",":= by
  rw [mulSupport]
  simp_rw [zpow_neg, Ne, inv_eq_one]
  exact finite_mulSupport_coe hI",":= by
  rw [mulSupport]
  simp_rw [zpow_neg, Ne, inv_eq_one]
  exact finite_mulSupport_coe hI"
Mathlib/RingTheory/Ideal/Basic.lean,Ideal.span_pow_eq_top,span_pow_eq_top,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  rw [eq_top_iff_one]
  cases' n with n
  ¬∑ obtain rfl | ‚ü®x, hx‚ü© := eq_empty_or_nonempty s
    ¬∑ rw [Set.image_empty, hs]
      trivial
    ¬∑ exact subset_span ‚ü®_, hx, pow_zero _‚ü©
  rw [eq_top_iff_one, span, Finsupp.mem_span_iff_total] at hs
  rcases hs with ‚ü®f, hf‚ü©
  have hf : (f.support.sum fun a => f a * a) = 1 := hf 
  have := sum_pow_mem_span_pow f.support (fun a => f a * a) n
  rw [hf, one_pow] at this
  refine span_le.mpr ?_ this
  rintro _ hx
  simp_rw [Set.mem_image] at hx
  rcases hx with ‚ü®x, _, rfl‚ü©
  have : span ({(x : Œ±) ^ (n + 1)} : Set Œ±) ‚â§ span ((fun x : Œ± => x ^ (n + 1)) '' s) : = by
    rw [span_le, Set.singleton_subset_iff]
    exact subset_span ‚ü®x, x.prop, rfl‚ü©
  refine this ?_
  rw [mul_pow, mem_span_singleton]
  exact ‚ü®f x ^ (n + 1), mul_comm _ _‚ü©","error:  unexpected token ':'; expected '|'
error:  unsolved goals
case succ.intro.intro.intro
Œ± : Type u
Œ≤ : Type v
a b : Œ±
inst‚úù : CommSemiring Œ±
I : Ideal Œ±
s : Set Œ±
n : ‚Ñï
f : ‚Üës ‚Üí‚ÇÄ Œ±
hf‚úù : (Finsupp.total (‚Üës) Œ± Œ± Subtype.val) f = 1
hf : ‚àë a ‚àà f.support, f a * ‚Üëa = 1
this‚úù : 1 ‚àà span ((fun i ‚Ü¶ (f i * ‚Üëi) ^ (n + 1)) '' ‚Üëf.support)
x : ‚Üës
left‚úù : x ‚àà ‚Üëf.support
this : span {‚Üëx ^ (n + 1)} ‚â§ span ((fun x ‚Ü¶ x ^ (n + 1)) '' s)
‚ä¢ (f x * ‚Üëx) ^ (n + 1) ‚àà ‚Üë(span ((fun x ‚Ü¶ x ^ (n + 1)) '' s))","theorem span_pow_eq_top (s : Set Œ±) (hs : span s = ‚ä§) (n : ‚Ñï) :
    span ((fun (x : Œ±) => x ^ n) '' s) = ‚ä§ ",":= by
  rw [eq_top_iff_one]
  cases' n with n
  ¬∑ obtain rfl | ‚ü®x, hx‚ü© := eq_empty_or_nonempty s
    ¬∑ rw [Set.image_empty, hs]
      trivial
    ¬∑ exact subset_span ‚ü®_, hx, pow_zero _‚ü©
  rw [eq_top_iff_one, span, Finsupp.mem_span_iff_total] at hs
  rcases hs with ‚ü®f, hf‚ü©
  have hf : (f.support.sum fun a => f a * a) = 1 := hf 
  have := sum_pow_mem_span_pow f.support (fun a => f a * a) n
  rw [hf, one_pow] at this
  refine span_le.mpr ?_ this
  rintro _ hx
  simp_rw [Set.mem_image] at hx
  rcases hx with ‚ü®x, _, rfl‚ü©
  have : span ({(x:Œ±) ^ (n + 1)} : Set Œ±) ‚â§ span ((fun x : Œ± => x ^ (n + 1)) '' s) := by
    rw [span_le, Set.singleton_subset_iff]
    exact subset_span ‚ü®x, x.prop, rfl‚ü©
  refine this ?_
  rw [mul_pow, mem_span_singleton]
  exact ‚ü®f x ^ (n + 1), mul_comm _ _‚ü©",":= by
  rw [eq_top_iff_one]
  cases' n with n
  ¬∑ obtain rfl | ‚ü®x, hx‚ü© := eq_empty_or_nonempty s
    ¬∑ rw [Set.image_empty, hs]
      trivial
    ¬∑ exact subset_span ‚ü®_, hx, pow_zero _‚ü©
  rw [eq_top_iff_one, span, Finsupp.mem_span_iff_total] at hs
  rcases hs with ‚ü®f, hf‚ü©
  have hf : (f.support.sum fun a => f a * a) = 1 := hf 
  have := sum_pow_mem_span_pow f.support (fun a => f a * a) n
  rw [hf, one_pow] at this
  refine span_le.mpr ?_ this
  rintro _ hx
  simp_rw [Set.mem_image] at hx
  rcases hx with ‚ü®x, _, rfl‚ü©
  have : span ({(x : Œ±) ^ (n + 1)} : Set Œ±) ‚â§ span ((fun x : Œ± => x ^ (n + 1)) '' s) := by
    rw [span_le, Set.singleton_subset_iff]
    exact subset_span ‚ü®x, x.prop, rfl‚ü©
  refine this ?_
  rw [mul_pow, mem_span_singleton]
  exact ‚ü®f x ^ (n + 1), mul_comm _ _‚ü©"
Mathlib/Topology/MetricSpace/HausdorffDistance.lean,EMetric.infEdist_le_hausdorffEdist_of_mem,infEdist_le_hausdorffEdist_of_mem,75499222cc11ae5a47a99ba69c3066b962a0dc6f,":= by
  rw [hausdorffEdist_def]
  refine le_trans ?_ le_sup_left
  exact le_sup·µ¢‚ÇÇ (Œ± := ‚Ñù‚â•0‚àû) x h",error:  unknown identifier 'le_sup·µ¢‚ÇÇ',theorem infEdist_le_hausdorffEdist_of_mem (h : x ‚àà s) : infEdist x t ‚â§ hausdorffEdist s t ,":= by
  rw [hausdorffEdist_def]
  refine le_trans ?_ le_sup_left
  exact le_iSup‚ÇÇ (Œ± := ‚Ñù‚â•0‚àû) x h",":= by
  rw [hausdorffEdist_def]
  refine le_trans ?_ le_sup_left
  exact le_sup_left"
Mathlib/LinearAlgebra/FiniteDimensional.lean,Submodule.eq_top_of_finrank_eq,_root_.Submodule.eq_top_of_finrank_eq,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    @LinearIndependent.image_subtype _ _ _ _ _ _ _ _ _ (Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent (by simpa using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]","error:  type mismatch
  h‚úù
has type
  LinearIndependent (Œπ := ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) K ‚áëbS : Prop
but is expected to have type
  LinearIndependent K fun (x : ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) ‚Ü¶ ‚Üëx : Prop
warning:  `finite_of_linearIndependent` has been deprecated, use `LinearIndependent.set_finite_of_isNoetherian` instead
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  no goals to be solved
error:  unknown identifier 'eq_top_of_finrank_eq'","theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ‚ä§ ",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    @LinearIndependent.image_subtype _ _ _ _ _ _ _ _ (Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
             finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]"
Mathlib/Algebra/FreeAlgebra.lean,FreeAlgebra.induction,induction,0bcbc985a529d2af125537fab684cb3a98de2f6f,":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) :=
    by
    ext
    simp [Subtype.coind]
  suffices : a = lift R of a
  ¬∑ rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a","error:  unexpected token ':'; expected term
error:  unsolved goals
case w.h
R : Type u_1
inst‚úù : CommSemiring R
X : Type u_2
C : FreeAlgebra R X ‚Üí Prop
h_grade0 : ‚àÄ (r : R), C ((algebraMap R (FreeAlgebra R X)) r)
h_grade1 : ‚àÄ (x : X), C (Œπ R x)
h_mul : ‚àÄ (a b : FreeAlgebra R X), C a ‚Üí C b ‚Üí C (a * b)
h_add : ‚àÄ (a b : FreeAlgebra R X), C a ‚Üí C b ‚Üí C (a + b)
a : FreeAlgebra R X
s : Subalgebra R (FreeAlgebra R X) :=
  { carrier := C, mul_mem' := ‚ãØ, one_mem' := ‚ãØ, add_mem' := ‚ãØ, zero_mem' := ‚ãØ, algebraMap_mem' := h_grade0 }
of : X ‚Üí ‚Ü•s := Subtype.coind (Œπ R) h_grade1
x‚úù : X
‚ä¢ Œπ R x‚úù = ‚Üë(of x‚úù)","theorem induction {C : FreeAlgebra R X ‚Üí Prop}
    (h_grade0 : ‚àÄ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ‚àÄ x, C (Œπ R x))
    (h_mul : ‚àÄ a b, C a ‚Üí C b ‚Üí C (a * b)) (h_add : ‚àÄ a b, C a ‚Üí C b ‚Üí C (a + b))
    (a : FreeAlgebra R X) : C a ",":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a",":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X ‚Üí s := Subtype.coind (Œπ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) :=
    by
    ext
    simp [Subtype.coind]
  suffices a = lift R of a by rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a"
Mathlib/LinearAlgebra/FiniteDimensional.lean,Submodule.eq_top_of_finrank_eq,_root_.Submodule.eq_top_of_finrank_eq,b011c17e9c6a01496da5c0aebc4ba8e3bb736da2,":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]","error:  type mismatch
  h‚úù
has type
  LinearIndependent (Œπ := ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) K ‚áëbS : Prop
but is expected to have type
  LinearIndependent K fun (x : ‚Üë(Basis.ofVectorSpaceIndex K ‚Ü•S)) ‚Ü¶ ‚Üëx : Prop
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  no goals to be solved
error:  unknown identifier 'eq_top_of_finrank_eq'","theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ‚ä§ ",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((‚Üë) : S ‚Üí V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
            finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((‚Üë) : ((‚Üë) '' Basis.ofVectorSpaceIndex K S : Set V) ‚Üí V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa using b.linearIndependent)).fintype
  have : (‚Üë) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ‚Üê finrank_eq_card_basis bS, ‚Üê
             finrank_eq_card_basis b, h])
  rw [‚Üê b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ‚Üê this, ‚Üê Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]"
Mathlib/LinearAlgebra/Orientation.lean,Orientation.map_eq_neg_iff_det_neg,map_eq_neg_iff_det_neg,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  cases isEmpty_or_nonempty Œπ
  ¬∑ have H : finrank R M = 0 := h.symm.trans Fintype.card_eq_zero
    simp [LinearMap.det_eq_one_of_finrank_eq_zero H, Module.Ray.ne_neg_self x]
  have H : 0 < finrank R M := by
    rw [‚Üê h]
    exact Fintype.card_pos
  haveI : FiniteDimensional R M := finiteDimensional_of_finrank H
  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, LinearEquiv.coe_det]",error:  unknown identifier 'finiteDimensional_of_finrank',"theorem map_eq_neg_iff_det_neg (x : Orientation R M Œπ) (f : M ‚âÉ‚Çó[R] M)
    (h : Fintype.card Œπ = finrank R M) :
    Orientation.map Œπ f x = -x ‚Üî LinearMap.det (f : M ‚Üí‚Çó[R] M) < 0 ",":= by
  cases isEmpty_or_nonempty Œπ
  ¬∑ have H : finrank R M = 0 := h.symm.trans Fintype.card_eq_zero
    simp [LinearMap.det_eq_one_of_finrank_eq_zero H, Module.Ray.ne_neg_self x]
  have H : 0 < finrank R M := by
    rw [‚Üê h]
    exact Fintype.card_pos
  haveI : FiniteDimensional R M := of_finrank_pos H
  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, LinearEquiv.coe_det]",":= by
  cases isEmpty_or_nonempty Œπ
  ¬∑ have H : finrank R M = 0 := h.symm.trans Fintype.card_eq_zero
    simp [LinearMap.det_eq_one_of_finrank_eq_zero H, Module.Ray.ne_neg_self x]
  have H : 0 < finrank R M := by
    rw [‚Üê h]
    exact Fintype.card_pos
  haveI : FiniteDimensional R M := finiteDimensional_of_finrank H
  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, LinearEquiv.coe_det]"
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.evaln_prim,evaln_prim,6085d5e27552de2d43997b4a52a8d9fcd4686071,":= by
  suffices Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) from
    (Primrec.option_bind
      (Primrec.list_get?.comp‚ÇÇ (this.comp‚ÇÇ (_root_.Primrec.const ())
        (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to‚ÇÇ).of_eq
      fun ‚ü®‚ü®k, c‚ü©, n‚ü© => by simp [evaln_map]
  refine Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => ?_
  simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
    Nat.pair_unpair, Option.some_inj]
  refine List.map_congr fun n => ?_
  have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
    simp
  rw [this]
  generalize ofNat Code p.unpair.2 = c
  match p.unpair.1 with | 0 => simp [evaln] | k' + 1 => ?_
  set k := k' + 1
  intro nk
  simp only [List.mem_range, Nat.lt_succ_iff] at nk
  have hg {k' c' n}
      (hl : Nat.pair k' (encode c') < Nat.pair k (encode c)) :
      lup ((List.range (Nat.pair k (encode c))).map fun n =>
        (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
        evaln k' c' n := by
    simp [lup, List.get?_range hl, evaln_map, Bind.bind]
  cases c with
    simp only [bind, pure, evaln, nk, guard_true, unpaired, pair_unpair, Option.some_bind]
  | pair cf cg =>
    let ‚ü®lf, lg‚ü© := encode_lt_pair cf cg
    rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
    cases evaln k cf n <;> [rfl; cases evaln k cg n <;> rfl]
  | comp cf cg =>
    let ‚ü®lf, lg‚ü© := encode_lt_comp cf cg
    rw [hg (Nat.pair_lt_pair_right _ lg)]
    cases evaln k cg n <;> [rfl; simp [hg (Nat.pair_lt_pair_right _ lf)]]
  | prec cf cg =>
    let ‚ü®lf, lg‚ü© := encode_lt_prec cf cg
    rw [hg (Nat.pair_lt_pair_right _ lf)]
    cases n.unpair.2 <;> [rfl; simp only [decode_eq_ofNat, Option.some.injEq]]
    rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
    cases evaln k' _ _ <;> [rfl; simp [hg (Nat.pair_lt_pair_right _ lg)]]
  | rfind' cf =>
    have lf := encode_lt_rfind' cf
    rw [hg (Nat.pair_lt_pair_right _ lf)]
    cases' evaln k cf n with x <;> [rfl; skip]
    simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
    cases x <;> simp only [rec_zero, reduceIte]
    rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]","error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ this (_root_.Primrec.const ())
argument
  _root_.Primrec.const ()
has type
  Primrec fun x ‚Ü¶ () : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.915700 : Prop
error:  unsolved goals
this :
  Primrec‚ÇÇ fun x n ‚Ü¶
    let a := ofNat (‚Ñï √ó Code) n;
    List.map (evaln a.1 a.2) (List.range a.1)
x‚úù : (‚Ñï √ó Code) √ó ‚Ñï
k : ‚Ñï
c : Code
n : ‚Ñï
‚ä¢ evaln (unpair (?m.925942 this (k, c) n)).1 (ofNat Code (unpair (?m.925942 this (k, c) n)).2)
      (?m.925943 this (k, c) n) =
    evaln k c n
error:  unsolved goals
‚ä¢ Primrec fun a ‚Ü¶ evaln a.1.1 a.1.2 a.2",theorem evaln_prim : Primrec fun a : (‚Ñï √ó Code) √ó ‚Ñï => evaln a.1.1 a.1.2 a.2 ,":=
  have :
    Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr_left fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      ¬∑ simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        ‚àÄ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) ‚Üí
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k‚ÇÅ c‚ÇÅ n‚ÇÅ hl
        simp [lup, List.getElem?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      ¬∑ cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        ¬∑ rfl
        cases evaln k cg n <;> rfl
      ¬∑ cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      ¬∑ cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        ¬∑ rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      ¬∑ have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        ¬∑ rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to‚ÇÇ).of_eq
    fun ‚ü®‚ü®k, c‚ü©, n‚ü© => by simp [evaln_map]",":= by
  suffices Primrec‚ÇÇ fun (_ : Unit) (n : ‚Ñï) =>
      let a := ofNat (‚Ñï √ó Code) n
      (List.range a.1).map (evaln a.1 a.2) from
    (Primrec.option_bind
      (Primrec.list_get?.comp (this.comp‚ÇÇ (_root_.Primrec.const ())
        (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to‚ÇÇ).of_eq
      fun ‚ü®‚ü®k, c‚ü©, n‚ü© => by simp [evaln_map]
  refine Primrec.nat_strong_rec ?_ (hG.comp Primrec.snd).to‚ÇÇ fun _ p => ?_
  simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
    Nat.pair_unpair, Option.some_inj]
  refine List.map_congr fun n => ?_
  have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
    simp
  rw [this]
  generalize ofNat Code p.unpair.2 = c
  match p.unpair.1 with | 0 => simp [evaln] | k' + 1 => ?_
  set k := k' + 1
  intro nk
  simp only [List.mem_range, Nat.lt_succ_iff] at nk
  have hg {k' c' n}
      (hl : Nat.pair k' (encode c') < Nat.pair k (encode c)) :
      lup ((List.range (Nat.pair k (encode c))).map fun n =>
        (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
        evaln k' c' n := by
    simp [lup, List.get?_range hl, evaln_map, Bind.bind]
  cases c with
    simp only [bind, pure, evaln, nk, guard_true, unpaired, pair_unpair, Option.some_bind]
  | pair cf cg =>
    let ‚ü®lf, lg‚ü© := encode_lt_comp cf cg
    rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
    cases evaln k cf n <;> [rfl; cases evaln k cg n <;> rfl]
  | comp cf cg =>
    let ‚ü®lf, lg‚ü© := encode_lt_comp cf cg
    rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
    cases evaln k cf n <;> [rfl; cases evaln k cg n <;> rfl]
  | comp cf cg =>
    let ‚ü®lf, lg‚ü© := encode_lt_comp cf cg
    rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
    cases evaln k cf n <;> [rfl; cases evaln k cg n <;> rfl]
  | comp cf cg =>
    let ‚ü®lf, lg‚ü© := encode_lt_comp cf cg
    rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
    cases evaln k cf n <;> [rfl; cases evaln k cg n <;> rfl]
  | comp cf cg =>
    let ‚ü®lf, lg‚ü© := encode_lt_comp cf cg
    rw [hg (Nat.pair_lt_pair_right _ lf)]
    cases' evaln k cf n with x <;> [rfl; skip]
    simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
    cases x <;> simp only [rec_zero, reduceIte]
    rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.tendsto_self_mul_Gamma_nhds_zero,tendsto_self_mul_Gamma_nhds_zero,cf5995283f32dd2e0ccb43bc9901c4e7ba9fed97,":= by
  rw [show ùìù (1 : ‚ÑÇ) = ùìù (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]]
  convert (Tendsto.mono_left _ nhdsWithin_le_nhds).congr'
    (eventuallyEq_of_mem self_mem_nhdsWithin Complex.Gamma_add_one)
  refine' ContinuousAt.comp (g := Gamma) _ (continuous_id.add continuous_const).continuousAt
  refine' (Complex.differentiableAt_Gamma _ fun m => _).continuousAt
  rw [zero_add, ‚Üê ofReal_nat_cast, ‚Üê ofReal_neg, ‚Üê ofReal_one, Ne, ofReal_inj]
  refine' (lt_of_le_of_lt _ zero_lt_one).ne'
  exact neg_nonpos.mpr (Nat.cast_nonneg _)","error:  unknown identifier 'ofReal_nat_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.127050
case convert_1
m : ‚Ñï
‚ä¢ 1 ‚â† -‚Üëm",theorem tendsto_self_mul_Gamma_nhds_zero : Tendsto (fun z : ‚ÑÇ => z * Gamma z) (ùìù[‚â†] 0) (ùìù 1) ,":= by
  rw [show ùìù (1 : ‚ÑÇ) = ùìù (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]]
  convert (Tendsto.mono_left _ nhdsWithin_le_nhds).congr'
    (eventuallyEq_of_mem self_mem_nhdsWithin Complex.Gamma_add_one)
  refine ContinuousAt.comp (g := Gamma) ?_ (continuous_id.add continuous_const).continuousAt
  refine (Complex.differentiableAt_Gamma _ fun m => ?_).continuousAt
  rw [zero_add, ‚Üê ofReal_natCast, ‚Üê ofReal_neg, ‚Üê ofReal_one, Ne, ofReal_inj]
  refine (lt_of_le_of_lt ?_ zero_lt_one).ne'
  exact neg_nonpos.mpr (Nat.cast_nonneg _)",":= by
  rw [show ùìù (1 : ‚ÑÇ) = ùìù (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]]
  convert (Tendsto.mono_left _ nhdsWithin_le_nhds).congr'
    (eventuallyEq_of_mem self_mem_nhdsWithin Complex.Gamma_add_one)
  refine ContinuousAt.comp (g := Gamma) ?_ (continuous_id.add continuous_const).continuousAt
  refine (Complex.differentiableAt_Gamma _ fun m => ?_).continuousAt
  rw [zero_add, ‚Üê ofReal_natCast, ‚Üê ofReal_neg, ‚Üê ofReal_one, Ne, ofReal_inj]
  refine (lt_of_le_of_lt ?_ zero_lt_one).ne'
  exact neg_nonpos.mpr (Nat.cast_nonneg _)"
Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean,isLittleO_zpow_exp_pos_mul_atTop,isLittleO_zpow_exp_pos_mul_atTop,e24d0042f0fd176848590f8a296e5c675237f634,":= by
  simpa only [rpow_int_cast] using isLittleO_rpow_exp_pos_mul_atTop k hb","error:  ambiguous, possible interpretations 
  ENNReal.rpow_int_cast : ‚àÄ (x : ‚Ñù‚â•0‚àû) (n : ‚Ñ§), x ^ ‚Üën = x ^ n
  
  Real.rpow_int_cast : ‚àÄ (x : ‚Ñù) (n : ‚Ñ§), x ^ ‚Üën = x ^ n
error:  type mismatch
  h‚úù
has type
  (fun x ‚Ü¶ x ^ ‚Üëk) =o[atTop] fun x ‚Ü¶ rexp (b * x) : Prop
but is expected to have type
  (fun x ‚Ü¶ x ^ k) =o[atTop] fun x ‚Ü¶ rexp (b * x) : Prop","theorem isLittleO_zpow_exp_pos_mul_atTop (k : ‚Ñ§) {b : ‚Ñù} (hb : 0 < b) :
    (fun x : ‚Ñù => x ^ k) =o[atTop] fun x => exp (b * x) ",":= by
  simpa only [Real.rpow_intCast] using isLittleO_rpow_exp_pos_mul_atTop k hb",":= by
  simpa using isLittleO_rpow_exp_pos_mul_atTop k hb"
Mathlib/Algebra/Order/Archimedean.lean,existsUnique_zsmul_near_of_pos,existsUnique_zsmul_near_of_pos,daa535fc320141e24b1bc6af2e4928f53d12eb9d,":=
  by
  let s : Set ‚Ñ§ := { n : ‚Ñ§ | n ‚Ä¢ a ‚â§ g }
  obtain ‚ü®k, hk : -g ‚â§ k ‚Ä¢ a‚ü© := Archimedean.arch (-g) ha
  have h_ne : s.Nonempty := ‚ü®-k, by simpa using neg_le_neg hk‚ü©
  obtain ‚ü®k, hk‚ü© := Archimedean.arch g ha
  have h_bdd : ‚àÄ n ‚àà s, n ‚â§ (k : ‚Ñ§) := by
    intro n hn
    apply (zsmul_le_zsmul_iff ha).mp
    rw [‚Üê coe_nat_zsmul] at hk
    exact le_trans hn hk
  obtain ‚ü®m, hm, hm'‚ü© := Int.exists_greatest_of_bdd ‚ü®k, h_bdd‚ü© h_ne
  have hm'' : g < (m + 1) ‚Ä¢ a := by
    contrapose! hm'
    exact ‚ü®m + 1, hm', lt_add_one _‚ü©
  refine' ‚ü®m, ‚ü®hm, hm''‚ü©, fun n hn => (hm' n hn.1).antisymm <| Int.le_of_lt_add_one _‚ü©
  rw [‚Üê zsmul_lt_zsmul_iff ha]
  exact lt_of_le_of_lt hm hn.2","error:  type mismatch
  h‚úù
has type
  -(k ‚Ä¢ a) ‚â§ g : Prop
but is expected to have type
  -‚Üëk ‚àà s : Prop
warning:  `coe_nat_zsmul` has been deprecated, use `natCast_zsmul` instead","theorem existsUnique_zsmul_near_of_pos {a : Œ±} (ha : 0 < a) (g : Œ±) :
    ‚àÉ! k : ‚Ñ§, k ‚Ä¢ a ‚â§ g ‚àß g < (k + 1) ‚Ä¢ a ",":= by
  let s : Set ‚Ñ§ := { n : ‚Ñ§ | n ‚Ä¢ a ‚â§ g }
  obtain ‚ü®k, hk : -g ‚â§ k ‚Ä¢ a‚ü© := Archimedean.arch (-g) ha
  have h_ne : s.Nonempty := ‚ü®-k, by simpa [s] using neg_le_neg hk‚ü©
  obtain ‚ü®k, hk‚ü© := Archimedean.arch g ha
  have h_bdd : ‚àÄ n ‚àà s, n ‚â§ (k : ‚Ñ§) := by
    intro n hn
    apply (zsmul_le_zsmul_iff ha).mp
    rw [‚Üê natCast_zsmul] at hk
    exact le_trans hn hk
  obtain ‚ü®m, hm, hm'‚ü© := Int.exists_greatest_of_bdd ‚ü®k, h_bdd‚ü© h_ne
  have hm'' : g < (m + 1) ‚Ä¢ a := by
    contrapose! hm'
    exact ‚ü®m + 1, hm', lt_add_one _‚ü©
  refine ‚ü®m, ‚ü®hm, hm''‚ü©, fun n hn => (hm' n hn.1).antisymm <| Int.le_of_lt_add_one ?_‚ü©
  rw [‚Üê zsmul_lt_zsmul_iff ha]
  exact lt_of_le_of_lt hm hn.2",":=
  by
  let s : Set ‚Ñ§ := { n : ‚Ñ§ | n ‚Ä¢ a ‚â§ g }
  obtain ‚ü®k, hk : -g ‚â§ k ‚Ä¢ a‚ü© := Archimedean.arch (-g) ha
  have h_ne : s.Nonempty := ‚ü®-k, by simpa using neg_le_neg hk‚ü©
  obtain ‚ü®k, hk‚ü© := Archimedean.arch g ha
  have h_bdd : ‚àÄ n ‚àà s, n ‚â§ (k : ‚Ñ§) := by
    intro n hn
    apply (zsmul_le_zsmul_iff ha).mp
    rw [‚Üê coe_natCast] at hk
    exact le_trans hn hk
  obtain ‚ü®m, hm, hm'‚ü© := Int.exists_greatest_of_bdd ‚ü®k, h_bdd‚ü© h_ne
  have hm'' : g < (m + 1) ‚Ä¢ a := by
    contrapose! hm'
    exact ‚ü®m + 1, hm', lt_add_one _‚ü©
  refine ‚ü®m, ‚ü®hm, hm''‚ü©, fun n hn => (hm' n hn.1).antisymm <| Int.le_of_lt_add_one ?_‚ü©
  rw [‚Üê zsmul_lt_zsmul_iff ha]
  exact lt_of_le_of_lt hm hn.2"
Mathlib/Analysis/InnerProductSpace/PiL2.lean,Orthonormal.exists_orthonormalBasis_extension,Orthonormal.exists_orthonormalBasis_extension,06295115e02029d99354c51425dc11539f40347b,":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.finite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine' ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu _, _, _‚ü©
  ¬∑ simpa using hu‚ÇÄ_max
  ¬∑ simpa using hu‚ÇÄs
  ¬∑ simp","error:  type mismatch
  h‚úù
has type
  span ùïú u‚ÇÄ = ‚ä§ : Prop
but is expected to have type
  span ùïú ‚Üëu = ‚ä§ : Prop
error:  type mismatch
  h‚úù
has type
  u‚ÇÄ ‚äá v : Prop
but is expected to have type
  v ‚äÜ ‚Üëu : Prop","theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal ùïú ((‚Üë) : v ‚Üí E)) :
    ‚àÉ (u : Finset E) (b : OrthonormalBasis u ùïú E), v ‚äÜ u ‚àß ‚áëb = ((‚Üë) : u ‚Üí E) ",":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.setFinite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_‚ü©
  ¬∑ simpa [u] using hu‚ÇÄ_max
  ¬∑ simpa [u] using hu‚ÇÄs
  ¬∑ simp",":= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.finite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_‚ü©
  ¬∑ simpa using hu‚ÇÄ_max
  ¬∑ simpa using hu‚ÇÄs
  ¬∑ simp"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,821d503181d6030794806a9ac2fb2b1f5dd5dfb3,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Œµ hŒµ).mono fun y hy => _
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",error:  simp made no progress,"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto"
Mathlib/Analysis/Calculus/FDeriv/Basic.lean,HasFDerivWithinAt.of_nhdsWithin_eq_bot,HasFDerivWithinAt.of_nhdsWithin_eq_bot,5ef74df5e417f4c5830ecf7f3e69a800274c3b4e,":= by
  rw [‚Üê hasFDerivWithinAt_diff_singleton x, HasFDerivWithinAt, h]
  apply isLittleO_bot","error:  tactic 'apply' failed, failed to unify
  ?f =o[‚ä•] ?g
with
  HasFDerivAtFilter f f' x ‚ä•
ùïú : Type u_1
inst‚úù‚Å∏ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ùïú E
F : Type u_3
inst‚úù‚Åµ : NormedAddCommGroup F
inst‚úù‚Å¥ : NormedSpace ùïú F
G : Type u_4
inst‚úù¬≥ : NormedAddCommGroup G
inst‚úù¬≤ : NormedSpace ùïú G
G' : Type u_5
inst‚úù¬π : NormedAddCommGroup G'
inst‚úù : NormedSpace ùïú G'
f f‚ÇÄ f‚ÇÅ g : E ‚Üí F
f' f‚ÇÄ' f‚ÇÅ' g' e : E ‚ÜíL[ùïú] F
x : E
s t : Set E
L L‚ÇÅ L‚ÇÇ : Filter E
h : ùìù[s \ {x}] x = ‚ä•
‚ä¢ HasFDerivAtFilter f f' x ‚ä•","theorem HasFDerivWithinAt.of_nhdsWithin_eq_bot (h : ùìù[s\{x}] x = ‚ä•) :
    HasFDerivWithinAt f f' s x ",":= by
  rw [‚Üê hasFDerivWithinAt_diff_singleton x, HasFDerivWithinAt, h, hasFDerivAtFilter_iff_isLittleO]
  apply isLittleO_bot",":= by
  rw [‚Üê hasFDerivWithinAt_diff_singleton x, HasFDerivWithinAt, h]"
Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean,MeasureTheory.tendstoInMeasure_of_tendsto_ae_of_stronglyMeasurable,tendstoInMeasure_of_tendsto_ae_of_stronglyMeasurable,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  refine' fun Œµ hŒµ => ENNReal.tendsto_atTop_zero.mpr fun Œ¥ hŒ¥ => _
  by_cases hŒ¥i : Œ¥ = ‚àû
  ¬∑ simp only [hŒ¥i, imp_true_iff, le_top, exists_const]
  lift Œ¥ to ‚Ñù‚â•0 using hŒ¥i
  rw [gt_iff_lt, ENNReal.coe_pos, ‚Üê NNReal.coe_pos] at hŒ¥
  obtain ‚ü®t, _, ht, hunif‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg hŒ¥
  rw [ENNReal.ofReal_coe_nnreal] at ht
  rw [Metric.tendstoUniformlyOn_iff] at hunif
  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 (hunif Œµ hŒµ)
  refine' ‚ü®N, fun n hn => _‚ü©
  suffices : { x : Œ± | Œµ ‚â§ dist (f n x) (g x) } ‚äÜ t; exact (measure_mono this).trans ht
  rw [‚Üê Set.compl_subset_compl]
  intro x hx
  rw [Set.mem_compl_iff, Set.nmem_setOf_iff, dist_comm, not_le]
  exact hN n hn x hx",error:  unexpected token ':'; expected term,"theorem tendstoInMeasure_of_tendsto_ae_of_stronglyMeasurable [IsFiniteMeasure Œº]
    (hf : ‚àÄ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)
    (hfg : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (g x))) : TendstoInMeasure Œº f atTop g ",":= by
  refine fun Œµ hŒµ => ENNReal.tendsto_atTop_zero.mpr fun Œ¥ hŒ¥ => ?_
  by_cases hŒ¥i : Œ¥ = ‚àû
  ¬∑ simp only [hŒ¥i, imp_true_iff, le_top, exists_const]
  lift Œ¥ to ‚Ñù‚â•0 using hŒ¥i
  rw [gt_iff_lt, ENNReal.coe_pos, ‚Üê NNReal.coe_pos] at hŒ¥
  obtain ‚ü®t, _, ht, hunif‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg hŒ¥
  rw [ENNReal.ofReal_coe_nnreal] at ht
  rw [Metric.tendstoUniformlyOn_iff] at hunif
  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 (hunif Œµ hŒµ)
  refine ‚ü®N, fun n hn => ?_‚ü©
  suffices { x : Œ± | Œµ ‚â§ dist (f n x) (g x) } ‚äÜ t from (measure_mono this).trans ht
  rw [‚Üê Set.compl_subset_compl]
  intro x hx
  rw [Set.mem_compl_iff, Set.nmem_setOf_iff, dist_comm, not_le]
  exact hN n hn x hx",":= by
  refine fun Œµ hŒµ => ENNReal.tendsto_atTop_zero.mpr fun Œ¥ hŒ¥ => ?_
  by_cases hŒ¥i : Œ¥ = ‚àû
  ¬∑ simp only [hŒ¥i, imp_true_iff, le_top, exists_const]
  lift Œ¥ to ‚Ñù‚â•0 using hŒ¥i
  rw [gt_iff_lt, ENNReal.coe_pos, ‚Üê NNReal.coe_pos] at hŒ¥
  obtain ‚ü®t, _, ht, hunif‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg hŒ¥
  rw [ENNReal.ofReal_coe_nnreal] at ht
  rw [Metric.tendstoUniformlyOn_iff] at hunif
  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 (hunif Œµ hŒµ)
  refine ‚ü®N, fun n hn => ?_‚ü©
  suffices { x : Œ± | Œµ ‚â§ dist (f n x) (g x) } ‚äÜ t; exact (measure_mono this).trans ht
  rw [‚Üê Set.compl_subset_compl]
  intro x hx
  rw [Set.mem_compl_iff, Set.nmem_setOf_iff, dist_comm, not_le]
  exact hN n hn x hx"
Mathlib/Analysis/Calculus/LocalExtr/Polynomial.lean,Polynomial.card_roots_le_derivative,card_roots_le_derivative,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":=
  calc
    Multiset.card p.roots = ‚àë x in p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x in p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x in p.roots.toFinset, (p.rootMultiplicity x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x in p.roots.toFinset, p.derivative.rootMultiplicity x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x in p.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x in p.derivative.roots.toFinset \ p.roots.toFinset,
            p.derivative.roots.count x) + 1) := by
      simp only [‚Üê count_roots]
      refine' add_le_add_left (add_le_add_right ((Finset.card_eq_sum_ones _).trans_le _) _) _
      refine' Finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| _
      rw [Multiset.count_pos, ‚Üê Multiset.mem_toFinset]
      exact (Finset.mem_sdiff.1 hx).1
    _ = Multiset.card (derivative p).roots + 1 := by
      rw [‚Üê add_assoc, ‚Üê Finset.sum_union Finset.disjoint_sdiff, Finset.union_sdiff_self_eq_union, ‚Üê
        Multiset.toFinset_sum_count_eq, ‚Üê Finset.sum_subset (Finset.subset_union_right _ _)]
      intro x _ hx‚ÇÇ
      simpa only [Multiset.mem_toFinset, Multiset.count_eq_zero] using hx‚ÇÇ","error:  function expected at
  Finset.subset_union_right ?m.14170
term has type
  ?m.14169 ‚àà ?m.14167 ‚à™ ?m.14168","theorem card_roots_le_derivative (p : ‚Ñù[X]) :
    Multiset.card p.roots ‚â§ Multiset.card (derivative p).roots + 1 ",":=
  calc
    Multiset.card p.roots = ‚àë x ‚àà p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.rootMultiplicity x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.rootMultiplicity x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x ‚àà p.derivative.roots.toFinset \ p.roots.toFinset,
            p.derivative.roots.count x) + 1) := by
      simp only [‚Üê count_roots]
      refine add_le_add_left (add_le_add_right ((Finset.card_eq_sum_ones _).trans_le ?_) _) _
      refine Finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| ?_
      rw [Multiset.count_pos, ‚Üê Multiset.mem_toFinset]
      exact (Finset.mem_sdiff.1 hx).1
    _ = Multiset.card (derivative p).roots + 1 := by
      rw [‚Üê add_assoc, ‚Üê Finset.sum_union Finset.disjoint_sdiff, Finset.union_sdiff_self_eq_union, ‚Üê
        Multiset.toFinset_sum_count_eq, ‚Üê Finset.sum_subset Finset.subset_union_right]
      intro x _ hx‚ÇÇ
      simpa only [Multiset.mem_toFinset, Multiset.count_eq_zero] using hx‚ÇÇ",":=
  calc
    Multiset.card p.roots = ‚àë x ‚àà p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (‚àë x ‚àà p.roots.toFinset, (p.roots.count x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ‚â§ (‚àë x ‚àà p.roots.toFinset, p.derivative.roots.count x) +
          ((‚àë x ‚àà p.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
 "
Mathlib/Algebra/BigOperators/Finprod.lean,finprod_mul_distrib,finprod_mul_distrib,1e6b6c1919bb062a9b0fb6873d11444837c77e88,":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset _ hf (Finset.subset_union_left _ _),
      finprod_eq_prod_of_mulSupport_toFinset_subset _ hg (Finset.subset_union_right _ _), ‚Üê
      Finset.prod_mul_distrib]
    apply finprod_eq_prod_of_mulSupport_subset
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf, hg‚ü©
    simp [hf, hg]","error:  function expected at
  Finset.subset_union_left ?m.86793
term has type
  ?m.86792 ‚àà ?m.86790 ‚à™ ?m.86791
error:  function expected at
  Finset.subset_union_right ?m.86952
term has type
  ?m.86951 ‚àà ?m.86949 ‚à™ ?m.86950
error:  rcases tactic failed: a‚úù : x ‚àà ‚Üë?m.87073 ‚Üí False is not an inductive datatype","theorem finprod_mul_distrib (hf : (mulSupport f).Finite) (hg : (mulSupport g).Finite) :
    ‚àè·∂† i, f i * g i = (‚àè·∂† i, f i) * ‚àè·∂† i, g i ",":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset f hf Finset.subset_union_left,
      finprod_eq_prod_of_mulSupport_toFinset_subset g hg Finset.subset_union_right, ‚Üê
      Finset.prod_mul_distrib]
    refine finprod_eq_prod_of_mulSupport_subset _ ?_
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf, hg‚ü©
    simp [hf, hg]",":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset _ hf (Finset.subset_union_left),
      finprod_eq_prod_of_mulSupport_toFinset_subset _ hg (Finset.subset_union_right), ‚Üê
      Finset.prod_mul_distrib]
    apply finprod_eq_prod_of_mulSupport_subset
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf, hg‚ü©
    simp [hf, hg]"
Mathlib/Geometry/Manifold/IntegralCurve.lean,IsIntegralCurve.isIntegralCurveAt,IsIntegralCurve.isIntegralCurveAt,2c4d77d7fd709133772709da9ffb1d698ecbcd0a,":= ‚ü®1, zero_lt_one, fun t _ => h t‚ü©","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  (ùìù t).1 {x | (fun t ‚Ü¶ HasMFDerivAt ùìò(‚Ñù, ‚Ñù) I Œ≥ t (ContinuousLinearMap.smulRight 1 (v (Œ≥ t)))) x}","lemma IsIntegralCurve.isIntegralCurveAt (h : IsIntegralCurve Œ≥ v) (t : ‚Ñù) :
    IsIntegralCurveAt Œ≥ v t ",":= isIntegralCurveAt_iff.mpr ‚ü®univ, Filter.univ_mem, fun t _ ‚Ü¶ h t‚ü©",":= ‚ü®1, zero_lt_one, fun t _ => h t‚ü©"
Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean,geometric_hahn_banach_open,geometric_hahn_banach_open,592e720e2651f6e8a7faf0968b75697c3bcd3b55,":= by
  obtain rfl | ‚ü®a‚ÇÄ, ha‚ÇÄ‚ü© := s.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 0, by simp, fun b _hb => le_rfl‚ü©
  obtain rfl | ‚ü®b‚ÇÄ, hb‚ÇÄ‚ü© := t.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 1, fun a _ha => zero_lt_one, by simp‚ü©
  let x‚ÇÄ := b‚ÇÄ - a‚ÇÄ
  let C := x‚ÇÄ +·µ• (s - t)
  have : (0 : E) ‚àà C :=
    ‚ü®a‚ÇÄ - b‚ÇÄ, sub_mem_sub ha‚ÇÄ hb‚ÇÄ, by simp_rw [vadd_eq_add, sub_add_sub_cancel', sub_self]‚ü©
  have : Convex ‚Ñù C := (hs‚ÇÅ.sub ht).vadd _
  have : x‚ÇÄ ‚àâ C := by
    intro hx‚ÇÄ
    rw [‚Üê add_zero x‚ÇÄ] at hx‚ÇÄ
    exact disj.zero_not_mem_sub_set (vadd_mem_vadd_set_iff.1 hx‚ÇÄ)
  obtain ‚ü®f, hf‚ÇÅ, hf‚ÇÇ‚ü© := separate_convex_open_set ‚Äπ0 ‚àà C‚Ä∫ ‚Äπ_‚Ä∫ (hs‚ÇÇ.sub_right.vadd _) ‚Äπx‚ÇÄ ‚àâ C‚Ä∫
  have : f b‚ÇÄ = f a‚ÇÄ + 1 := by simp [‚Üê hf‚ÇÅ]
  have forall_le : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a ‚â§ f b := by
    intro a ha b hb
    have := hf‚ÇÇ (x‚ÇÄ + (a - b)) (vadd_mem_vadd_set <| sub_mem_sub ha hb)
    simp only [f.map_add, f.map_sub, hf‚ÇÅ] at this
    linarith
  refine' ‚ü®f, sInf (f '' t), image_subset_iff.1 (_ : f '' s ‚äÜ Iio (sInf (f '' t))), fun b hb => _‚ü©
  ¬∑ rw [‚Üê interior_Iic]
    refine' interior_maximal (image_subset_iff.2 fun a ha => _) (f.isOpenMap_of_ne_zero _ _ hs‚ÇÇ)
    ¬∑ exact le_csInf (Nonempty.image _ ‚ü®_, hb‚ÇÄ‚ü©) (ball_image_of_ball <| forall_le _ ha)
    ¬∑ rintro rfl
      simp at hf‚ÇÅ
  ¬∑ exact csInf_le ‚ü®f a‚ÇÄ, ball_image_of_ball <| forall_le _ ha‚ÇÄ‚ü© (mem_image_of_mem _ hb)","error:  simp made no progress
error:  unsolved goals
ùïú : Type u_1
E : Type u_2
inst‚úù‚Å¥ : TopologicalSpace E
inst‚úù¬≥ : AddCommGroup E
inst‚úù¬≤ : TopologicalAddGroup E
inst‚úù¬π : Module ‚Ñù E
inst‚úù : ContinuousSMul ‚Ñù E
s t : Set E
x y : E
hs‚ÇÅ : Convex ‚Ñù s
hs‚ÇÇ : IsOpen s
ht : Convex ‚Ñù t
disj : Disjoint s t
a‚ÇÄ : E
ha‚ÇÄ : a‚ÇÄ ‚àà s
b‚ÇÄ : E
hb‚ÇÄ : b‚ÇÄ ‚àà t
x‚ÇÄ : E := b‚ÇÄ - a‚ÇÄ
C : Set E := x‚ÇÄ +·µ• (s - t)
this‚úù¬π : 0 ‚àà C
this‚úù : Convex ‚Ñù C
this : x‚ÇÄ ‚àâ C
f : E ‚ÜíL[‚Ñù] ‚Ñù
hf‚ÇÅ : f x‚ÇÄ = 1
hf‚ÇÇ : ‚àÄ x ‚àà C, f x < 1
‚ä¢ f b‚ÇÄ = f a‚ÇÄ + f x‚ÇÄ
warning:  `Set.ball_image_of_ball` has been deprecated, use `Set.forall_mem_image` instead
warning:  `Set.ball_image_of_ball` has been deprecated, use `Set.forall_mem_image` instead","theorem geometric_hahn_banach_open (hs‚ÇÅ : Convex ‚Ñù s) (hs‚ÇÇ : IsOpen s) (ht : Convex ‚Ñù t)
    (disj : Disjoint s t) : ‚àÉ (f : E ‚ÜíL[‚Ñù] ‚Ñù) (u : ‚Ñù), (‚àÄ a ‚àà s, f a < u) ‚àß ‚àÄ b ‚àà t, u ‚â§ f b ",":= by
  obtain rfl | ‚ü®a‚ÇÄ, ha‚ÇÄ‚ü© := s.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 0, by simp, fun b _hb => le_rfl‚ü©
  obtain rfl | ‚ü®b‚ÇÄ, hb‚ÇÄ‚ü© := t.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 1, fun a _ha => zero_lt_one, by simp‚ü©
  let x‚ÇÄ := b‚ÇÄ - a‚ÇÄ
  let C := x‚ÇÄ +·µ• (s - t)
  have : (0 : E) ‚àà C :=
    ‚ü®a‚ÇÄ - b‚ÇÄ, sub_mem_sub ha‚ÇÄ hb‚ÇÄ, by simp_rw [x‚ÇÄ, vadd_eq_add, sub_add_sub_cancel', sub_self]‚ü©
  have : Convex ‚Ñù C := (hs‚ÇÅ.sub ht).vadd _
  have : x‚ÇÄ ‚àâ C := by
    intro hx‚ÇÄ
    rw [‚Üê add_zero x‚ÇÄ] at hx‚ÇÄ
    exact disj.zero_not_mem_sub_set (vadd_mem_vadd_set_iff.1 hx‚ÇÄ)
  obtain ‚ü®f, hf‚ÇÅ, hf‚ÇÇ‚ü© := separate_convex_open_set ‚Äπ0 ‚àà C‚Ä∫ ‚Äπ_‚Ä∫ (hs‚ÇÇ.sub_right.vadd _) ‚Äπx‚ÇÄ ‚àâ C‚Ä∫
  have : f b‚ÇÄ = f a‚ÇÄ + 1 := by simp [x‚ÇÄ, ‚Üê hf‚ÇÅ]
  have forall_le : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a ‚â§ f b := by
    intro a ha b hb
    have := hf‚ÇÇ (x‚ÇÄ + (a - b)) (vadd_mem_vadd_set <| sub_mem_sub ha hb)
    simp only [f.map_add, f.map_sub, hf‚ÇÅ] at this
    linarith
  refine ‚ü®f, sInf (f '' t), image_subset_iff.1 (?_ : f '' s ‚äÜ Iio (sInf (f '' t))), fun b hb => ?_‚ü©
  ¬∑ rw [‚Üê interior_Iic]
    refine interior_maximal (image_subset_iff.2 fun a ha => ?_) (f.isOpenMap_of_ne_zero ?_ _ hs‚ÇÇ)
    ¬∑ exact le_csInf (Nonempty.image _ ‚ü®_, hb‚ÇÄ‚ü©) (forall_mem_image.2 <| forall_le _ ha)
    ¬∑ rintro rfl
      simp at hf‚ÇÅ
  ¬∑ exact csInf_le ‚ü®f a‚ÇÄ, forall_mem_image.2 <| forall_le _ ha‚ÇÄ‚ü© (mem_image_of_mem _ hb)",":= by
  obtain rfl | ‚ü®a‚ÇÄ, ha‚ÇÄ‚ü© := s.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 0, by simp, fun b _hb => le_rfl‚ü©
  obtain rfl | ‚ü®b‚ÇÄ, hb‚ÇÄ‚ü© := t.eq_empty_or_nonempty
  ¬∑ exact ‚ü®0, 1, fun a _ha => zero_lt_one, by simp‚ü©
  let x‚ÇÄ := b‚ÇÄ - a‚ÇÄ
  let C := x‚ÇÄ +·µ• (s - t)
  have : (0 : E) ‚àà C :=
    ‚ü®a‚ÇÄ - b‚ÇÄ, sub_mem_sub ha‚ÇÄ hb‚ÇÄ, by simp_rw [vadd_eq_add, sub_add_sub_cancel', sub_self]‚ü©
  have : Convex ‚Ñù C := (hs‚ÇÅ.sub ht).vadd _
  have : x‚ÇÄ ‚àâ C := by
    intro hx‚ÇÄ
    rw [‚Üê add_zero x‚ÇÄ] at hx‚ÇÄ
    exact disj.zero_not_mem_sub_set (vadd_mem_vadd_set_iff.1 hx‚ÇÄ)
  obtain ‚ü®f, hf‚ÇÅ, hf‚ÇÇ‚ü© := separate_convex_open_set ‚Äπ0 ‚àà C‚Ä∫ ‚Äπ_‚Ä∫ (hs‚ÇÇ.sub_right.vadd _) ‚Äπx‚ÇÄ ‚àâ C‚Ä∫
  have : f b‚ÇÄ = f a‚ÇÄ + 1 := by simp [‚Üê hf‚ÇÅ]
  have forall_le : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a ‚â§ f b := by
    intro a ha b hb
    have := hf‚ÇÇ (x‚ÇÄ + (a - b)) (vadd_mem_vadd_set <| sub_mem_sub ha hb)
    simp only [f.map_add, f.map_sub, hf‚ÇÅ] at this
    linarith
  refine ‚ü®f, sInf (f '' t), image_subset_iff.1 (_ : f '' s ‚äÜ Iio (sInf (f '' t))), fun b hb => ?_‚ü©
  ¬∑ rw [‚Üê interior_Iic]
    refine interior_maximal (image_subset_iff.2 fun a ha => ?_) (f.isOpenMap_of_ne_zero _ _ hs‚ÇÇ)
    ¬∑ exact le_csInf (Nonempty.image _ ‚ü®_, hb‚ÇÄ‚ü©) (ball_image_of_ball <| forall_le _ ha)
    ¬∑ rintro rfl
      simp at hf‚ÇÅ
  ¬∑ exact csInf_le ‚ü®f a‚ÇÄ, ball_image_of_ball <| forall_le _ ha‚ÇÄ‚ü© (mem_image_of_mem _ hb)"
Mathlib/NumberTheory/Modular.lean,ModularGroup.tendsto_normSq_coprime_pair,tendsto_normSq_coprime_pair,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, ofReal_mul_im, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := by
    have := @LinearEquiv.closedEmbedding_of_injective ‚Ñù _ (Fin 2 ‚Üí ‚Ñù) _ _ ‚ÑÇ _ _ _ f
    exact this hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * 1
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
x‚úù : Fin 2 ‚Üí ‚Ñù
‚ä¢ f x‚úù = ‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)
error:  unknown identifier 'ofReal_int_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.22014
case h
g : SL(2, ‚Ñ§)
z : ‚Ñç
this : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
f_def : ‚áëf = fun p ‚Ü¶ ‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)
x‚úù : Fin 2 ‚Üí ‚Ñ§
‚ä¢ normSq (‚Üë(x‚úù 0) * ‚Üëz + ‚Üë(x‚úù 1)) = normSq (‚Üë‚Üë(x‚úù 0) * ‚Üëz + ‚Üë‚Üë(x‚úù 1))
error:  unknown identifier 'ofReal_mul_im'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.33650
case h.h.head
g‚úù : SL(2, ‚Ñ§)
z : ‚Ñç
this‚úù : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight ‚Üëz + œÄ‚ÇÅ.smulRight 1
f_def : ‚áëf = fun p ‚Ü¶ ‚Üë(p 0) * ‚Üëz + ‚Üë(p 1)
this : (fun p ‚Ü¶ normSq (‚Üë(p 0) * ‚Üëz + ‚Üë(p 1))) = ‚áënormSq ‚àò ‚áëf ‚àò fun p ‚Ü¶ Int.cast ‚àò p
g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù := LinearMap.pi ![imLm, imLm ‚àò‚Çó (‚Üëz ‚Ä¢ (‚Üë‚ÜëconjAe).toLinearMap)]
c : Fin 2 ‚Üí ‚Ñù
hz : (‚Üëz).im ‚â† 0
‚ä¢ (‚Üëz).im‚Åª¬π * ((‚Üë(c 0) * ‚Üëz).im + (‚Üë(c 1)).im) = c 0
error:  invalid use of field notation with `@` modifier
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem tendsto_normSq_coprime_pair :
    Filter.Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * z + p 1)) cofinite atTop ",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0
  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1
  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_intCast, ofReal_intCast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)",":= by
  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule
  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1
  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by
    ext1
    dsimp only [LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight, LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =
      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = ‚ä• := by
    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=
      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]
    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0
      rw [f_def, add_im, ofReal_mul_im, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := by
    have := @LinearEquiv.closedEmbedding_of_injective ‚Ñù _ (Fin 2 ‚Üí ‚Ñù) _ _ ‚ÑÇ _ _ _ f
    exact this hf
  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite
    ¬∑ rw [coprod·µ¢_cofinite]
    ¬∑ rw [coprod·µ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)"
Mathlib/MeasureTheory/Function/ContinuousMapDense.lean,MeasureTheory.Mem‚Ñíp.exists_hasCompactSupport_integral_rpow_sub_le,Mem‚Ñíp.exists_hasCompactSupport_integral_rpow_sub_le,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  have I : 0 < Œµ ^ (1 / p) := Real.rpow_pos_of_pos hŒµ _
  have A : ENNReal.ofReal (Œµ ^ (1 / p)) ‚â† 0 := by
    simp only [Ne.def, ENNReal.ofReal_eq_zero, not_le, I]
  have B : ENNReal.ofReal p ‚â† 0 := by simpa only [Ne.def, ENNReal.ofReal_eq_zero, not_le] using hp
  rcases hf.exists_hasCompactSupport_snorm_sub_le ENNReal.coe_ne_top A with
    ‚ü®g, g_support, hg, g_cont, g_mem‚ü©
  change snorm _ (ENNReal.ofReal p) _ ‚â§ _ at hg
  refine' ‚ü®g, g_support, _, g_cont, g_mem‚ü©
  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,
    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,
    Real.rpow_le_rpow_iff _ hŒµ.le (inv_pos.2 hp)] at hg
  exact integral_nonneg fun x => Real.rpow_nonneg (norm_nonneg _) _","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.36991 ‚Üí ?m.36991 ‚Üí Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.37136 ‚Üí ?m.37136 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  0 < p : Prop
but is expected to have type
  ENNReal.ofReal p ‚â† 0 : Prop","theorem Mem‚Ñíp.exists_hasCompactSupport_integral_rpow_sub_le
    [WeaklyLocallyCompactSpace Œ±] [Œº.Regular]
    {p : ‚Ñù} (hp : 0 < p) {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f (ENNReal.ofReal p) Œº) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :
    ‚àÉ g : Œ± ‚Üí E,
      HasCompactSupport g ‚àß
        (‚à´ x, ‚Äñf x - g x‚Äñ ^ p ‚àÇŒº) ‚â§ Œµ ‚àß Continuous g ‚àß Mem‚Ñíp g (ENNReal.ofReal p) Œº ",":= by
  have I : 0 < Œµ ^ (1 / p) := Real.rpow_pos_of_pos hŒµ _
  have A : ENNReal.ofReal (Œµ ^ (1 / p)) ‚â† 0 := by
    simp only [Ne, ENNReal.ofReal_eq_zero, not_le, I]
  have B : ENNReal.ofReal p ‚â† 0 := by simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hp
  rcases hf.exists_hasCompactSupport_snorm_sub_le ENNReal.coe_ne_top A with
    ‚ü®g, g_support, hg, g_cont, g_mem‚ü©
  change snorm _ (ENNReal.ofReal p) _ ‚â§ _ at hg
  refine ‚ü®g, g_support, ?_, g_cont, g_mem‚ü©
  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,
    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,
    Real.rpow_le_rpow_iff _ hŒµ.le (inv_pos.2 hp)] at hg
  positivity",":= by
  have I : 0 < Œµ ^ (1 / p) := Real.rpow_pos_of_pos hŒµ _
  have A : ENNReal.ofReal (Œµ ^ (1 / p)) ‚â† 0 := by
    simp only [Ne, ENNReal.ofReal_eq_zero, not_le, I]
  have B : ENNReal.ofReal p ‚â† 0 := by simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hp
  rcases hf.exists_hasCompactSupport_snorm_sub_le ENNReal.coe_ne_top A with
    ‚ü®g, g_support, hg, g_cont, g_mem‚ü©
  change snorm _ (ENNReal.ofReal p) _ ‚â§ _ at hg
  refine ‚ü®g, g_support, ?_, g_cont, g_mem‚ü©
  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,
    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,
    Real.rpow_le_rpow_iff _ hŒµ.le (inv_pos.2 hp)] at hg
  exact integral_nonneg fun x => Real.rpow_nonneg (norm_nonneg _) _"
Mathlib/Probability/Distributions/Gamma.lean,ProbabilityTheory.isProbabilityMeasureGamma,isProbabilityMeasureGamma,3d69118e33807ea8f6444d90463243ab546355c1,"  measure_univ := by simp [gammaMeasure, lintegral_gammaPdf_eq_one ha hr]","error:  unknown identifier 'lintegral_gammaPdf_eq_one'
error:  unsolved goals
a r : ‚Ñù
ha : 0 < a
hr : 0 < r
‚ä¢ ‚à´‚Åª (a_1 : ‚Ñù), gammaPDF a r a_1 = 1","lemma isProbabilityMeasureGamma {a r : ‚Ñù} (ha : 0 < a) (hr : 0 < r) :
    IsProbabilityMeasure (gammaMeasure a r) where
","  measure_univ := by simp [gammaMeasure, lintegral_gammaPDF_eq_one ha hr]",":= by simp [gammaMeasure, lintegral_gammaPdf_eq_one ha hr]"
Mathlib/RingTheory/Finiteness.lean,Submodule.fg_induction,fg_induction,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
    obtain ‚ü®s, rfl‚ü© := hN
    induction s
    ¬∑ rw [Finset.coe_empty, Submodule.span_empty, ‚Üê Submodule.span_zero_singleton]
      apply h‚ÇÅ
    ¬∑ rw [Finset.coe_insert, Submodule.span_insert]
      apply h‚ÇÇ <;> apply_assumption","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë‚àÖ
case intro.mk
R‚úù : Type u_1
M‚úù : Type u_2
inst‚úù‚Å∑ : Semiring R‚úù
inst‚úù‚Å∂ : AddCommMonoid M‚úù
inst‚úù‚Åµ : Module R‚úù M‚úù
P‚úù : Type u_3
inst‚úù‚Å¥ : AddCommMonoid P‚úù
inst‚úù¬≥ : Module R‚úù P‚úù
f : M‚úù ‚Üí‚Çó[R‚úù] P‚úù
R : Type u_4
M : Type u_5
inst‚úù¬≤ : Semiring R
inst‚úù¬π : AddCommMonoid M
inst‚úù : Module R M
P : Submodule R M ‚Üí Prop
h‚ÇÅ : ‚àÄ (x : M), P (span R {x})
h‚ÇÇ : ‚àÄ (M‚ÇÅ M‚ÇÇ : Submodule R M), P M‚ÇÅ ‚Üí P M‚ÇÇ ‚Üí P (M‚ÇÅ ‚äî M‚ÇÇ)
val‚úù : Multiset M
nodup‚úù : val‚úù.Nodup
‚ä¢ P (span R ‚Üë{ val := val‚úù, nodup := nodup‚úù })
error:  no goals to be solved
warning:  Module.Finite does not have a doc string","theorem fg_induction (R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]
    (P : Submodule R M ‚Üí Prop) (h‚ÇÅ : ‚àÄ x, P (Submodule.span R {x}))
    (h‚ÇÇ : ‚àÄ M‚ÇÅ M‚ÇÇ, P M‚ÇÅ ‚Üí P M‚ÇÇ ‚Üí P (M‚ÇÅ ‚äî M‚ÇÇ)) (N : Submodule R M) (hN : N.FG) : P N ",":= by
  classical
    obtain ‚ü®s, rfl‚ü© := hN
    induction s using Finset.induction
    ¬∑ rw [Finset.coe_empty, Submodule.span_empty, ‚Üê Submodule.span_zero_singleton]
      apply h‚ÇÅ
    ¬∑ rw [Finset.coe_insert, Submodule.span_insert]
      apply h‚ÇÇ <;> apply_assumption",":= by
  classical
    obtain ‚ü®s, rfl‚ü© := hN
    induction s
    ¬∑ rw [Submodule.span_empty, ‚Üê Submodule.span_zero_singleton]
      apply h‚ÇÅ
    ¬∑ rw [Finset.coe_insert, Submodule.span_insert]
      apply h‚ÇÇ <;> apply_assumption"
Mathlib/NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean,ZMod.Ico_map_valMinAbs_natAbs_eq_Ico_map_id,Ico_map_valMinAbs_natAbs_eq_Ico_map_id,aa86c765b1f9ce27899c6416c8a03f6ca3f86caa,":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,
      pos_iff_ne_zero, natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x, ‚àÉ _ : x ‚àà Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine' ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®_, _‚ü©, _‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne.def, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [nat_cast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel' _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
      ¬∑ erw [mul_neg, mul_div_cancel' _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,
          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.15005 ‚Üí ?m.15005 ‚Üí Prop
error:  unsolved goals
case refine'_1.a
p : ‚Ñï
hp : Fact (Nat.Prime p)
a : ZMod p
hap : a ‚â† 0
he : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2
hep : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p
hpe : ‚àÄ {x : ‚Ñï}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x
hmem : ‚àÄ x ‚àà Ico 1 (p / 2).succ, (a * ‚Üëx).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ
b : ‚Ñï
hb : b ‚àà Ico 1 (p / 2).succ
‚ä¢ (‚Üëb * a‚Åª¬π).valMinAbs.natAbs ‚â† 0
warning:  `ZMod.nat_cast_natAbs_valMinAbs` has been deprecated, use `ZMod.natCast_natAbs_valMinAbs` instead
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead","theorem Ico_map_valMinAbs_natAbs_eq_Ico_map_id (p : ‚Ñï) [hp : Fact p.Prime] (a : ZMod p)
    (hap : a ‚â† 0) : ((Ico 1 (p / 2).succ).1.map fun (x : ‚Ñï) => (a * x).valMinAbs.natAbs) =
    (Ico 1 (p / 2).succ).1.map fun a => a ",":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,
      pos_iff_ne_zero, natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x, ‚àÉ _ : x ‚àà Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®?_, ?_‚ü©, ?_‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [natCast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel‚ÇÄ _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
      ¬∑ erw [mul_neg, mul_div_cancel‚ÇÄ _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,
          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)",":= by
  have he : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x ‚â† 0 ‚àß x ‚â§ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ‚àÄ {x}, x ‚àà Ico 1 (p / 2).succ ‚Üí ¬¨p ‚à£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ‚àÄ (x : ‚Ñï) (hx : x ‚àà Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ‚àà Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,
      pos_iff_ne_zero, natAbs_valMinAbs_le _]
  have hsurj : ‚àÄ (b : ‚Ñï) (hb : b ‚àà Ico 1 (p / 2).succ),
      ‚àÉ x, ‚àÉ _ : x ‚àà Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine ‚ü®(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ‚ü®_, ?_‚ü©, ?_‚ü©
    ¬∑ apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne, _root_.mul_eq_zero, or_self_iff]
    ¬∑ apply lt_succ_of_le; apply natAbs_valMinAbs_le
    ¬∑ rw [nat_cast_natAbs_valMinAbs]
      split_ifs
      ¬∑ erw [mul_div_cancel' _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)"
Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean,Polynomial.natTrailingDegree_eq_support_min',natTrailingDegree_eq_support_min',bc769a9f781a01550bc7da7431e6157f3b3d6c81,":= by
  rw [natTrailingDegree, trailingDegree, ‚Üê Finset.coe_min', ENat.some_eq_coe, ENat.toNat_coe]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (‚Üë?n).toNat
R : Type u
S : Type v
a b : R
n m : ‚Ñï
inst‚úù : Semiring R
p q r : R[X]
h : p ‚â† 0
‚ä¢ Option.getD (‚Üë(p.support.min' ?m.31767)) 0 = p.support.min' ‚ãØ","theorem natTrailingDegree_eq_support_min' (h : p ‚â† 0) :
    natTrailingDegree p = p.support.min' (nonempty_support_iff.mpr h) ",":= by
  apply le_antisymm
  ¬∑ apply le_min'
    intro y hy
    exact natTrailingDegree_le_of_mem_supp y hy
  ¬∑ apply Finset.min'_le
    exact mem_support_iff.mpr (trailingCoeff_nonzero_iff_nonzero.mpr h)",":= by
  rw [natTrailingDegree, trailingDegree, ‚Üê Finset.coe_min', ENat.some_eq_coe, ENat.toNat_coe]"
Mathlib/NumberTheory/DiophantineApproximation.lean,Real.exists_rat_eq_convergent',exists_rat_eq_convergent',457e481f5e9c0969401919077d4f5efc34fed55d,":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    rcases le_or_lt (u : ‚Ñù) Œæ with ht | ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      rcases eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ | HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine' ‚ü®(fract_lt_one Œæ).le, _‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_ofNat, inv_div, sub_div, mul_div_cancel _ Hv, add_sub_cancel'_right]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë(OfNat.ofNat ?n)
case h
v‚úù : ‚Ñ§
hv : 2 ‚â§ v‚úù
v : ‚Ñï
ih : ‚àÄ m < v, ‚àÄ {Œæ : ‚Ñù} {u : ‚Ñ§}, ContfracLegendre.Ass Œæ u ‚Üëm ‚Üí ‚àÉ n, ‚Üëu / ‚Üëm = Œæ.convergent n
Œæ : ‚Ñù
u : ‚Ñ§
h : ContfracLegendre.Ass Œæ u ‚Üëv
ht : 1 < v
huv‚ÇÄ : 0 < u - ‚åäŒæ‚åã * ‚Üëv
huv‚ÇÅ : u - ‚åäŒæ‚åã * ‚Üëv < ‚Üëv
Hv : ‚Üëv ‚â† 0
huv‚ÇÅ' : (u - ‚åäŒæ‚åã * ‚Üëv).toNat < v
inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π ‚Üëv ‚Üë(u - ‚åäŒæ‚åã * ‚Üëv).toNat
n : ‚Ñï
hn : ‚Üë‚Üëv / ‚Üë(u - ‚åäŒæ‚åã * ‚Üëv).toNat = (fract Œæ)‚Åª¬π.convergent n
‚ä¢ ‚Üëu / ‚Üëv = ‚Üë‚åäŒæ‚åã + (‚Üë‚Üëv / (‚Üëu - ‚Üë‚åäŒæ‚åã * ‚Üëv))‚Åª¬π","theorem exists_rat_eq_convergent' {v : ‚Ñï} (h' : ContfracLegendre.Ass Œæ u v) :
    ‚àÉ n, (u / v : ‚Ñö) = Œæ.convergent n ",":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    rcases le_or_lt (u : ‚Ñù) Œæ with ht | ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      rcases eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ | HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine ‚ü®(fract_lt_one Œæ).le, ?_‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_natCast, inv_div, sub_div, mul_div_cancel_right‚ÇÄ _ Hv, add_sub_cancel]",":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Œæ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  ¬∑ replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Œæ).trans_lt h)
  ¬∑ rw [Nat.cast_one, div_one]
    obtain ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h
    rcases le_or_lt (u : ‚Ñù) Œæ with ht | ht
    ¬∑ use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h‚ÇÇ).2) <;> norm_num
    ¬∑ replace h‚ÇÅ := lt_sub_iff_add_lt'.mp (h‚ÇÅ rfl)
      have hŒæ‚ÇÅ : ‚åäŒæ‚åã = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ‚ü®(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h‚ÇÅ).le, ht‚ü©
      rcases eq_or_ne Œæ ‚åäŒæ‚åã with HŒæ | HŒæ
      ¬∑ rw [HŒæ, hŒæ‚ÇÅ, cast_sub, cast_one, ‚Üê sub_eq_add_neg, sub_lt_sub_iff_left] at h‚ÇÅ
        exact False.elim (lt_irrefl _ <| h‚ÇÅ.trans one_half_lt_one)
      ¬∑ have hŒæ‚ÇÇ : ‚åä(fract Œæ)‚Åª¬π‚åã = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HŒæ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HŒæ) zero_lt_two]
          refine ‚ü®(fract_lt_one Œæ).le, ?_‚ü©
          rw [fract, hŒæ‚ÇÅ, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h‚ÇÅ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hŒæ‚ÇÅ, hŒæ‚ÇÇ, cast_sub, cast_one]
  ¬∑ obtain ‚ü®huv‚ÇÄ, huv‚ÇÅ‚ü© := aux‚ÇÇ (Nat.cast_le.mpr ht) h
    have Hv : (v : ‚Ñö) ‚â† 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv‚ÇÅ' : (u - ‚åäŒæ‚åã * v).toNat < v := by zify; rwa [toNat_of_nonneg huv‚ÇÄ.le]
    have inv : ContfracLegendre.Ass (fract Œæ)‚Åª¬π v (u - ‚åäŒæ‚åã * ‚Üëv).toNat :=
      (toNat_of_nonneg huv‚ÇÄ.le).symm ‚ñ∏ invariant (Nat.cast_le.mpr ht) h
    obtain ‚ü®n, hn‚ü© := ih (u - ‚åäŒæ‚åã * v).toNat huv‚ÇÅ' inv
    use n + 1
    rw [convergent_succ, ‚Üê hn,
      (mod_cast toNat_of_nonneg huv‚ÇÄ.le : ((u - ‚åäŒæ‚åã * v).toNat : ‚Ñö) = u - ‚åäŒæ‚åã * v),
      cast_ofNat, inv_div, sub_div, mul_div_cancel _ Hv, add_sub_cancel'_right]"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/RingTheory/Ideal/Norm.lean,Ideal.exists_mul_add_mem_pow_succ,Ideal.exists_mul_add_mem_pow_succ,d664a4757e1d5d6999ae3ca588b989e1039faee2,":= by
  suffices eq_b : P ^ i = Ideal.span {a} ‚äî P ^ (i + 1)
  ¬∑ rw [eq_b] at c_mem
    simp only [mul_comm a]
    exact Ideal.mem_span_singleton_sup.mp c_mem
  refine (Ideal.eq_prime_pow_of_succ_lt_of_le hP (lt_of_le_of_ne le_sup_right ?_)
    (sup_le (Ideal.span_le.mpr (Set.singleton_subset_iff.mpr a_mem))
      (Ideal.pow_succ_lt_pow hP i).le)).symm
  contrapose! a_not_mem with this
  rw [this]
  exact mem_sup.mpr ‚ü®a, mem_span_singleton_self a, 0, by simp, by simp‚ü©","error:  unexpected token '¬∑'; expected 'by' or 'from'
error:  application type mismatch
  Ideal.exists_mul_add_mem_pow_succ ?m.54182 a c
argument
  c
has type
  S : Type u_1
but is expected to have type
  ?m.54182 ‚àà ?m.54166 ^ ?m.54168 : Prop
error:  application type mismatch
  Ideal.exists_mul_add_mem_pow_succ hP
argument
  hP
has type
  P ‚â† ‚ä• : Prop
but is expected to have type
  S : Type u_1","theorem Ideal.exists_mul_add_mem_pow_succ [IsDedekindDomain S] {i : ‚Ñï} (a c : S) (a_mem : a ‚àà P ^ i)
    (a_not_mem : a ‚àâ P ^ (i + 1)) (c_mem : c ‚àà P ^ i) :
    ‚àÉ d : S, ‚àÉ e ‚àà P ^ (i + 1), a * d + e = c ",":= by
  suffices eq_b : P ^ i = Ideal.span {a} ‚äî P ^ (i + 1) by
    rw [eq_b] at c_mem
    simp only [mul_comm a]
    exact Ideal.mem_span_singleton_sup.mp c_mem
  refine (Ideal.eq_prime_pow_of_succ_lt_of_le hP (lt_of_le_of_ne le_sup_right ?_)
    (sup_le (Ideal.span_le.mpr (Set.singleton_subset_iff.mpr a_mem))
      (Ideal.pow_succ_lt_pow hP i).le)).symm
  contrapose! a_not_mem with this
  rw [this]
  exact mem_sup.mpr ‚ü®a, mem_span_singleton_self a, 0, by simp, by simp‚ü©",":= by
  suffices eq_b : P ^ i = Ideal.span {a} ‚äî P ^ (i + 1)
  ¬∑ rw [eq_b] at c_mem
    simp only [mul_comm a]
    exact Ideal.mem_span_singleton_sup.mp c_mem
  refine (Ideal.eq_prime_pow_of_succ_lt_of_le hP (lt_of_le_of_ne le_sup_right ?_)
    (sup_le (Ideal.span_le.mpr (Set.singleton_subset_iff.mpr a_mem))
      (Ideal.pow_succ_lt_pow hP i).le)).symm
  contrapose! a_not_mem with this
  rw [this]
  exact mem_sup.mpr ‚ü®a, mem_span_singleton_self a, 0, by simp, by simp‚ü©"
Mathlib/GroupTheory/Coset.lean,mem_own_leftCoset,mem_own_leftCoset,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  suffices a * 1 ‚àà a ‚Ä¢ ‚Üës by simpa
  mem_leftCoset a (one_mem s : 1 ‚àà s)","error:  failed to synthesize
  HSMul Œ± (Submonoid Œ±) ?m.21959
use `set_option diagnostics true` to get diagnostic information
error:  type mismatch
  mem_leftCoset a (one_mem s)
has type
  a * 1 ‚àà a ‚Ä¢ ‚Üës : Prop
but is expected to have type
  a * 1 ‚àà a ‚Ä¢ s : Prop
error:  tactic 'assumption' failed
Œ± : Type u_1
inst‚úù : Monoid Œ±
s : Submonoid Œ±
a : Œ±
this : a ‚àà a ‚Ä¢ s
‚ä¢ a ‚àà a ‚Ä¢ ‚Üës",theorem mem_own_leftCoset (a : Œ±) : a ‚àà a ‚Ä¢ (s : Set Œ±) ,":=
  suffices a * 1 ‚àà a ‚Ä¢ (s : Set Œ±) by simpa
  mem_leftCoset a (one_mem s : 1 ‚àà s)",":=
  suffices a * 1 ‚àà a ‚Ä¢ ‚Üës by simpa
  mem_leftCoset a (one_mem s)"
Mathlib/RingTheory/DedekindDomain/FiniteAdeleRing.lean,DedekindDomain.ProdAdicCompletions.IsFiniteAdele.one,one,9e34a191034458a56331f976ff7400a26407c888,":= by
  rw [IsFiniteAdele, Filter.eventually_cofinite]
  have h_empty :
    {v : HeightOneSpectrum R | ¬¨(1 : v.adicCompletion K) ‚àà v.adicCompletionIntegers K} = ‚àÖ := by
    ext v; rw [mem_empty_iff_false, iff_false_iff]; intro hv
    rw [mem_setOf] at hv; apply hv; rw [mem_adicCompletionIntegers]
    exact le_of_eq Valued.v.map_one'
  simp_rw [Pi.one_apply, h_empty]
  convert finite_empty",error:  simp made no progress,theorem one : (1 : K_hat R K).IsFiniteAdele ,":= by
  rw [IsFiniteAdele, Filter.eventually_cofinite]
  have h_empty :
    {v : HeightOneSpectrum R | ¬¨(1 : v.adicCompletion K) ‚àà v.adicCompletionIntegers K} = ‚àÖ := by
    ext v; rw [mem_empty_iff_false, iff_false_iff]; intro hv
    rw [mem_setOf] at hv; apply hv; rw [mem_adicCompletionIntegers]
    exact le_of_eq Valued.v.map_one'
  convert finite_empty",":= by
  rw [IsFiniteAdele, Filter.eventually_cofinite]
  have h_empty :
    {v : HeightOneSpectrum R | ¬¨(1 : v.adicCompletion K) ‚àà v.adicCompletionIntegers K} = ‚àÖ := by
    ext v; rw [mem_empty_iff_false, iff_false_iff]; intro hv
    rw [mem_setOf] at hv; apply hv; rw [mem_adicCompletionIntegers]
    exact le_of_eq Valued.v.map_one'
  simp_rw [Pi.one_apply, h_empty]"
Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean,CochainComplex.HomComplex.Cochain.comp_assoc,comp_assoc,2c367bb7cdc3187abec81c2896087d55449d9b24,":= by
  substs h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ‚ÇÉ
  ext ‚ü®p, q, hpq‚ü©
  dsimp
  rw [comp_v _ _ rfl p (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ z‚ÇÇ rfl p (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith), assoc]","error:  unknown identifier 'p'
error:  unknown identifier 'p'
error:  unknown identifier 'q'","lemma comp_assoc {n‚ÇÅ n‚ÇÇ n‚ÇÉ n‚ÇÅ‚ÇÇ n‚ÇÇ‚ÇÉ n‚ÇÅ‚ÇÇ‚ÇÉ : ‚Ñ§}
    (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ) (z‚ÇÉ : Cochain K L n‚ÇÉ)
    (h‚ÇÅ‚ÇÇ : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) (h‚ÇÇ‚ÇÉ : n‚ÇÇ + n‚ÇÉ = n‚ÇÇ‚ÇÉ) (h‚ÇÅ‚ÇÇ‚ÇÉ : n‚ÇÅ + n‚ÇÇ + n‚ÇÉ = n‚ÇÅ‚ÇÇ‚ÇÉ) :
    (z‚ÇÅ.comp z‚ÇÇ h‚ÇÅ‚ÇÇ).comp z‚ÇÉ (show n‚ÇÅ‚ÇÇ + n‚ÇÉ = n‚ÇÅ‚ÇÇ‚ÇÉ by rw [‚Üê h‚ÇÅ‚ÇÇ, h‚ÇÅ‚ÇÇ‚ÇÉ]) =
      z‚ÇÅ.comp (z‚ÇÇ.comp z‚ÇÉ h‚ÇÇ‚ÇÉ) (by rw [‚Üê h‚ÇÇ‚ÇÉ, ‚Üê h‚ÇÅ‚ÇÇ‚ÇÉ, add_assoc]) ",":= by
  substs h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ‚ÇÉ
  ext p q hpq
  rw [comp_v _ _ rfl p (p + n‚ÇÅ + n‚ÇÇ) q (add_assoc _ _ _).symm (by omega),
    comp_v z‚ÇÅ z‚ÇÇ rfl p (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) (by omega) (by omega),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by omega) (by omega),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by omega) (by omega), assoc]",":= by
  substs h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ‚ÇÉ
  ext ‚ü®p, q, hpq‚ü©
  dsimp
  rw [comp_v _ _ rfl p (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ z‚ÇÇ rfl p (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith),
    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by linarith) (by linarith"
Mathlib/GroupTheory/Perm/Cycle/Type.lean,Equiv.Perm.card_fixedPoints_modEq,card_fixedPoints_modEq,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  let œÉ : Œ± ‚âÉ Œ± := ‚ü®f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)‚ü©
  have hœÉ : œÉ ^ p ^ n = 1
  ¬∑ rw [FunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End Œ± ‚Ü¶ g) rfl (fun g h ‚Ü¶ rfl) f (p ^ n)).symm.trans hf
  suffices : Fintype.card f.fixedPoints = (support œÉ)·∂ú.card
  ¬∑ exact this ‚ñ∏ (card_compl_support_modEq hœÉ).symm
  suffices : f.fixedPoints = (support œÉ)·∂ú
  ¬∑ simp only [this]; apply Fintype.card_coe
  simp [Set.ext_iff, IsFixedPt]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
Œ± : Type u_1
inst‚úù¬π : Fintype Œ±
inst‚úù : DecidableEq Œ±
f : Function.End Œ±
p n : ‚Ñï
hp : Fact (Nat.Prime p)
hf : f ^ p ^ n = 1
œÉ : Œ± ‚âÉ Œ± := { toFun := f, invFun := f ^ (p ^ n - 1), left_inv := ‚ãØ, right_inv := ‚ãØ }
hœÉ : œÉ ^ p ^ n = 1
‚ä¢ Fintype.card Œ± ‚â° Fintype.card ‚Üë(fixedPoints f) [MOD p]","theorem card_fixedPoints_modEq [DecidableEq Œ±] {f : Function.End Œ±} {p n : ‚Ñï}
    [hp : Fact p.Prime] (hf : f ^ p ^ n = 1) :
    Fintype.card Œ± ‚â° Fintype.card f.fixedPoints [MOD p] ",":= by
  let œÉ : Œ± ‚âÉ Œ± := ‚ü®f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)‚ü©
  have hœÉ : œÉ ^ p ^ n = 1 := by
    rw [DFunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End Œ± ‚Ü¶ g) rfl (fun g h ‚Ü¶ rfl) f (p ^ n)).symm.trans hf
  suffices Fintype.card f.fixedPoints = (support œÉ)·∂ú.card from
    this ‚ñ∏ (card_compl_support_modEq hœÉ).symm
  suffices f.fixedPoints = (support œÉ)·∂ú by
    simp only [this]; apply Fintype.card_coe
  simp [œÉ, Set.ext_iff, IsFixedPt]",":= by
  let œÉ : Œ± ‚âÉ Œ± := ‚ü®f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)‚ü©
  have hœÉ : œÉ ^ p ^ n = 1 := by
    rw [FunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End Œ± ‚Ü¶ g) rfl (fun g h ‚Ü¶ rfl) f (p ^ n)).symm.trans hf
  suffices : Fintype.card f.fixedPoints = (support œÉ)·∂ú.card
  ¬∑ exact this ‚ñ∏ (card_compl_support_modEq hœÉ).symm
  suffices f.fixedPoints = (support œÉ)·∂ú by
    simp only [this]; apply Fintype.card_coe
  simp [Set.ext_iff, IsFixedPt]"
Mathlib/Analysis/ConstantSpeed.lean,hasConstantSpeedOnWith_zero_iff,hasConstantSpeedOnWith_zero_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp [HasConstantSpeedOnWith]
  simp only [zero_mul, ENNReal.ofReal_zero, ‚Üê eVariationOn.eq_zero_iff]
  constructor
  ¬∑ by_contra!
    obtain ‚ü®h, hfs‚ü© := this
    simp_rw [ne_eq, eVariationOn.eq_zero_iff] at hfs h
    push_neg at hfs
    obtain ‚ü®x, xs, y, ys, hxy‚ü© := hfs
    rcases le_total x y with (xy | yx)
    ¬∑ exact hxy (h xs ys x ‚ü®xs, le_rfl, xy‚ü© y ‚ü®ys, xy, le_rfl‚ü©)
    ¬∑ rw [edist_comm] at hxy
      exact hxy (h ys xs y ‚ü®ys, le_rfl, yx‚ü© x ‚ü®xs, yx, le_rfl‚ü©)
  ¬∑ rintro h x _ y _
    refine' le_antisymm _ zero_le'
    rw [‚Üê h]
    exact eVariationOn.mono f (inter_subset_left s (Icc x y))","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set ‚Ñù : Type
but is expected to have type
  ?m.16196 ‚àà ?m.16194 ‚à© ?m.16195 : Prop","theorem hasConstantSpeedOnWith_zero_iff :
    HasConstantSpeedOnWith f s 0 ‚Üî ‚àÄ·µâ (x ‚àà s) (y ‚àà s), edist (f x) (f y) = 0 ",":= by
  dsimp [HasConstantSpeedOnWith]
  simp only [zero_mul, ENNReal.ofReal_zero, ‚Üê eVariationOn.eq_zero_iff]
  constructor
  ¬∑ by_contra!
    obtain ‚ü®h, hfs‚ü© := this
    simp_rw [ne_eq, eVariationOn.eq_zero_iff] at hfs h
    push_neg at hfs
    obtain ‚ü®x, xs, y, ys, hxy‚ü© := hfs
    rcases le_total x y with (xy | yx)
    ¬∑ exact hxy (h xs ys x ‚ü®xs, le_rfl, xy‚ü© y ‚ü®ys, xy, le_rfl‚ü©)
    ¬∑ rw [edist_comm] at hxy
      exact hxy (h ys xs y ‚ü®ys, le_rfl, yx‚ü© x ‚ü®xs, yx, le_rfl‚ü©)
  ¬∑ rintro h x _ y _
    refine le_antisymm ?_ zero_le'
    rw [‚Üê h]
    exact eVariationOn.mono f inter_subset_left",":= by
  dsimp [HasConstantSpeedOnWith]
  simp only [zero_mul, ENNReal.ofReal_zero, ‚Üê eVariationOn.eq_zero_iff]
  constructor
  ¬∑ by_contra!
    obtain ‚ü®h, hfs‚ü© := this
    simp_rw [ne_eq, eVariationOn.eq_zero_iff] at hfs h
    push_neg at hfs
    obtain ‚ü®x, xs, y, ys, hxy‚ü© := hfs
    rcases le_total x y with (xy | yx)
    ¬∑ exact hxy (h xs ys x ‚ü®xs, le_rfl, xy‚ü© y ‚ü®ys, xy, le_rfl‚ü©)
    ¬∑ rw [edist_comm] at hxy
      exact hxy (h ys xs y ‚ü®ys, le_rfl, yx‚ü© x ‚ü®xs, yx, le_rfl‚ü©)
  ¬∑ rintro h x _ y _
    refine le_antisymm ?_ zero_le'
    rw [‚Üê h]
    exact eVariationOn.mono f inter_subset_left"
Mathlib/Data/List/Cycle.lean,Cycle.subsingleton_nil,subsingleton_nil,a36d8932e98ea1d7efcdd316318586a6329f53a3,":=
  zero_le_one","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
error:  failed to synthesize
  ZeroLEOneClass ‚Ñï
use `set_option diagnostics true` to get diagnostic information",theorem subsingleton_nil : Subsingleton (@nil Œ±) ,:= Nat.zero_le _,":=
  zero_le_one"
Mathlib/Probability/Cdf.lean,ProbabilityTheory.tendsto_cdf_atBot,tendsto_cdf_atBot,c4988d10a696972769fd676cb9977e896bf0a01b,:= tendsto_condCdf_atBot _ _,error:  unknown identifier 'tendsto_condCdf_atBot',lemma tendsto_cdf_atBot : Tendsto (cdf Œº) atBot (ùìù 0) ,:= tendsto_condCDF_atBot _ _,:= tendsto_condCDF_atBot _ _
Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean,WeierstrassCurve.Projective.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,a83fc959459475e93bffd2243ee0a7c1d9f53d34,":= by
  use (isUnit_Y_of_Z_eq_zero hP hPz).unit / (isUnit_Y_of_Z_eq_zero hQ hQz).unit
  simp only [Units.smul_def, smul_fin3, X_eq_zero_of_Z_eq_zero hQ.left hQz, hQz, mul_zero,
    Units.val_div_eq_div_val, IsUnit.unit_spec, (isUnit_Y_of_Z_eq_zero hQ hQz).div_mul_cancel]
  conv_rhs => rw [‚Üê fin3_def P, X_eq_zero_of_Z_eq_zero hP.left hPz, hPz]","error:  unknown identifier 'isUnit_Y_of_Z_eq_zero'
error:  unknown identifier 'isUnit_Y_of_Z_eq_zero'
error:  unknown identifier 'X_eq_zero_of_Z_eq_zero'
error:  unknown identifier 'isUnit_Y_of_Z_eq_zero'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ![P 0, P 1, P 2]
R : Type u
inst‚úù¬π : CommRing R
W‚úù : Projective R
F : Type u
inst‚úù : Field F
W : Projective F
P Q : Fin 3 ‚Üí F
hP : W.Nonsingular P
hQ : W.Nonsingular Q
hPz : P 2 = 0
hQz : Q 2 = 0
| P","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©",":= by
  use (isUnit_Y_of_Z_eq_zero hP hPz).unit / (isUnit_Y_of_Z_eq_zero hQ hQz).unit
  simp only [Units.smul_def, smul_fin3, X_eq_zero_of_Z_eq_zero hQ.left hQz, hQz, mul_zero,
    Units.val_div_eq_div_val, IsUnit.unit_spec, (isUnit_Y_of_Z_eq_zero hQ hQz).div_mul_cancel]
  conv_rhs => rw [‚Üê fin3_def P, X_eq_zero_of_Z_eq_zero hP.left hPz, hPz]"
Mathlib/NumberTheory/DirichletCharacter/Basic.lean,DirichletCharacter.even_or_odd,even_or_odd,820f97a377780dd93a62e169ef9f405c7ae8d3d0,":= by
  suffices : œà (-1) ^ 2 = 1
  ¬∑ convert sq_eq_one_iff.mp this
  ¬∑ rw [‚Üê map_pow _, neg_one_sq, map_one]",error:  unexpected token ':'; expected term,lemma even_or_odd [NoZeroDivisors S] : œà.Even ‚à® œà.Odd ,":= by
  suffices œà (-1) ^ 2 = 1 by convert sq_eq_one_iff.mp this
  rw [‚Üê map_pow _, neg_one_sq, map_one]",":= by
  suffices œà (-1) ^ 2 = 1
  ¬∑ convert sq_eq_one_iff.mp this
  ¬∑ rw [‚Üê map_pow _, neg_one_sq, map_one]"
Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean,WeierstrassCurve.Œ®_odd,Œ®_odd,eda04d24f539d275bf9161920e57d3d1d3781080,":= by
  repeat erw [Œ®_ofNat]
  simp_rw [preŒ®'_odd, if_neg (m + 2).not_even_two_mul_add_one, Nat.even_add_one, ite_not]
  split_ifs <;> C_simp <;> rw [C_Œ®‚ÇÇSq_eq] <;> ring1","error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.121555
case pos
R : Type r
S : Type s
inst‚úù¬π : CommRing R
inst‚úù : CommRing S
W : WeierstrassCurve R
m : ‚Ñï
h‚úù : Even m
‚ä¢ (C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3 * C W.Œ®‚ÇÇSq ^ 2 - C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3 * 1) *
      1 =
    C (W.preŒ®' (m + 4)) * W.œà‚ÇÇ * (C (W.preŒ®' (m + 2)) * W.œà‚ÇÇ) ^ 3 -
        C (W.preŒ®' (m + 1)) * 1 * (C (W.preŒ®' (m + 3)) * 1) ^ 3 +
      W.toAffine.polynomial * (16 * W.toAffine.polynomial - 8 * W.œà‚ÇÇ ^ 2) *
        (C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3)
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.121557
case neg
R : Type r
S : Type s
inst‚úù¬π : CommRing R
inst‚úù : CommRing S
W : WeierstrassCurve R
m : ‚Ñï
h‚úù : ¬¨Even m
‚ä¢ (C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3 * 1 - C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3 * C W.Œ®‚ÇÇSq ^ 2) *
      1 =
    C (W.preŒ®' (m + 4)) * 1 * (C (W.preŒ®' (m + 2)) * 1) ^ 3 -
        C (W.preŒ®' (m + 1)) * W.œà‚ÇÇ * (C (W.preŒ®' (m + 3)) * W.œà‚ÇÇ) ^ 3 +
      W.toAffine.polynomial * (16 * W.toAffine.polynomial - 8 * W.œà‚ÇÇ ^ 2) *
        (-C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3)
error:  ring failed, ring expressions not equal
R : Type r
S : Type s
inst‚úù¬π : CommRing R
inst‚úù : CommRing S
W : WeierstrassCurve R
m : ‚Ñï
h‚úù : Even m
‚ä¢ C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3 * C W.Œ®‚ÇÇSq ^ 2 - C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3 =
    -(C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3 * W.œà‚ÇÇ ^ 2 * W.toAffine.polynomial * 8) +
        C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3 * W.œà‚ÇÇ ^ 4 +
      (C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3 * W.toAffine.polynomial ^ 2 * 16 -
        C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3)
error:  ring failed, ring expressions not equal
R : Type r
S : Type s
inst‚úù¬π : CommRing R
inst‚úù : CommRing S
W : WeierstrassCurve R
m : ‚Ñï
h‚úù : ¬¨Even m
‚ä¢ C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3 - C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3 * C W.Œ®‚ÇÇSq ^ 2 =
    C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3 +
        C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3 * W.œà‚ÇÇ ^ 2 * W.toAffine.polynomial * 8 +
      (-(C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3 * W.œà‚ÇÇ ^ 4) -
        C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3 * W.toAffine.polynomial ^ 2 * 16)
error:  unsolved goals
case pos
R : Type r
S : Type s
inst‚úù¬π : CommRing R
inst‚úù : CommRing S
W : WeierstrassCurve R
m : ‚Ñï
h‚úù : Even m
‚ä¢ (C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3 * C W.Œ®‚ÇÇSq ^ 2 - C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3 * 1) *
      1 =
    C (W.preŒ®' (m + 4)) * W.œà‚ÇÇ * (C (W.preŒ®' (m + 2)) * W.œà‚ÇÇ) ^ 3 -
        C (W.preŒ®' (m + 1)) * 1 * (C (W.preŒ®' (m + 3)) * 1) ^ 3 +
      W.toAffine.polynomial * (16 * W.toAffine.polynomial - 8 * W.œà‚ÇÇ ^ 2) *
        (C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3)

case neg
R : Type r
S : Type s
inst‚úù¬π : CommRing R
inst‚úù : CommRing S
W : WeierstrassCurve R
m : ‚Ñï
h‚úù : ¬¨Even m
‚ä¢ (C (W.preŒ®' (m + 4)) * C (W.preŒ®' (m + 2)) ^ 3 * 1 - C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3 * C W.Œ®‚ÇÇSq ^ 2) *
      1 =
    C (W.preŒ®' (m + 4)) * 1 * (C (W.preŒ®' (m + 2)) * 1) ^ 3 -
        C (W.preŒ®' (m + 1)) * W.œà‚ÇÇ * (C (W.preŒ®' (m + 3)) * W.œà‚ÇÇ) ^ 3 +
      W.toAffine.polynomial * (16 * W.toAffine.polynomial - 8 * W.œà‚ÇÇ ^ 2) *
        (-C (W.preŒ®' (m + 1)) * C (W.preŒ®' (m + 3)) ^ 3)","lemma Œ®_odd (m : ‚Ñï) : W.Œ® (2 * (m + 2) + 1) =
    W.Œ® (m + 4) * W.Œ® (m + 2) ^ 3 - W.Œ® (m + 1) * W.Œ® (m + 3) ^ 3 +
      W.toAffine.polynomial * (16 * W.toAffine.polynomial - 8 * W.œà‚ÇÇ ^ 2) * C
        (if Even m then W.preŒ®' (m + 4) * W.preŒ®' (m + 2) ^ 3
          else -W.preŒ®' (m + 1) * W.preŒ®' (m + 3) ^ 3) ",":= by
  repeat erw [Œ®_ofNat]
  simp_rw [preŒ®'_odd, if_neg (m + 2).not_even_two_mul_add_one, Nat.even_add_one, ite_not]
  split_ifs <;> C_simp <;> rw [C_Œ®‚ÇÇSq] <;> ring1",":= by
  repeat erw [Œ®_ofNat]
  simp_rw [preŒ®'_odd, if_neg (m + 2).not_even_two_mul_add_one, Nat.even_add_one, ite_not]
  split_ifs <;> C_simp <;> rw [C_Œ®‚ÇÇSq_eq] <;> ring"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpi_tfae,effectiveEpi_tfae,55619a095ad7cce23fe9818f4cf5fefa1fabf54e,":= by
  1 ‚Üí 2
  | _ => inferInstance
  2 ‚Üî 3 := epi_iff_surjective œÄ
  3 ‚Üí 1 := fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©","error:  unexpected token; expected '{' or tactic
error:  unsolved goals
B X : Profinite
œÄ : X ‚ü∂ B
‚ä¢ [EffectiveEpi œÄ, Epi œÄ, Function.Surjective ‚áëœÄ].TFAE","theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (œÄ : X ‚ü∂ B) :
    TFAE
    [ EffectiveEpi œÄ
    , Epi œÄ
    , Function.Surjective œÄ
    ] ",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",":= by
  1 ‚Üí 2
  | _ => inferInstance
  2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©"
Mathlib/RingTheory/AdicCompletion/Functoriality.lean,AdicCompletion.sumInv_comp_sum,sumInv_comp_sum,40d79d41004006c6e4f66c519a41ca9b41548378,":= by
  ext j x
  apply DirectSum.ext (AdicCompletion I R) (fun i ‚Ü¶ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, LinearMap.adicCompletion_mk,
    component_sumInv, mk_apply_coe, LinearMap.adicCauchy_apply_coe, Submodule.mkQ_apply,
    LinearMap.id_comp]
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  ¬∑ next h => subst h; simp
  ¬∑ simp","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.348185 ‚Üí+* ?m.348186) ‚Üí
    (M : Type ?u.348182) ‚Üí
      (M‚ÇÇ : Type ?u.348181) ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          [inst_1 : AddCommMonoid M‚ÇÇ] ‚Üí
            [inst : Module ?m.348185 M] ‚Üí [inst : Module ?m.348186 M‚ÇÇ] ‚Üí Type (max ?u.348182 ?u.348181)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.348415 ‚Üí+* ?m.348416) ‚Üí
    (M : Type ?u.348412) ‚Üí
      (M‚ÇÇ : Type ?u.348411) ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          [inst_1 : AddCommMonoid M‚ÇÇ] ‚Üí
            [inst : Module ?m.348415 M] ‚Üí [inst : Module ?m.348416 M‚ÇÇ] ‚Üí Type (max ?u.348412 ?u.348411)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (component ?R ?Œπ ?M ?i) ((lof ?R ?Œπ ?M ?j) ?b)
case h
R : Type u_1
inst‚úù¬π¬≤ : CommRing R
I : Ideal R
M‚úù : Type u_2
inst‚úù¬π¬π : AddCommGroup M‚úù
inst‚úù¬π‚Å∞ : Module R M‚úù
N : Type u_3
inst‚úù‚Åπ : AddCommGroup N
inst‚úù‚Å∏ : Module R N
P : Type u_4
inst‚úù‚Å∑ : AddCommGroup P
inst‚úù‚Å∂ : Module R P
T : Type u_5
inst‚úù‚Åµ : AddCommGroup T
inst‚úù‚Å¥ : Module (AdicCompletion I R) T
Œπ : Type u_6
inst‚úù¬≥ : DecidableEq Œπ
M : Œπ ‚Üí Type u_7
inst‚úù¬≤ : (i : Œπ) ‚Üí AddCommGroup (M i)
inst‚úù¬π : (i : Œπ) ‚Üí Module R (M i)
inst‚úù : Fintype Œπ
j : Œπ
x : AdicCauchySequence I (M j)
i : Œπ
n : ‚Ñï
‚ä¢ ‚Üë((map I (component R Œπ M i)) ((map I (lof R Œπ M j)) ((mk I (M j)) x))) n =
    ‚Üë(if h : j = i then Eq.recOn h ((mk I (M j)) x) else 0) n",theorem sumInv_comp_sum : sumInv I M ‚àò‚Çó sum I M = LinearMap.id ,":= by
  ext j x
  apply DirectSum.ext (AdicCompletion I R) (fun i ‚Ü¶ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, map_mk, component_sumInv,
    mk_apply_coe, AdicCauchySequence.map_apply_coe, Submodule.mkQ_apply, LinearMap.id_comp]
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  ¬∑ next h => subst h; simp
  ¬∑ simp",":= by
  ext j x
  apply DirectSum.ext (AdicCompletion I R) (fun i ‚Ü¶ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, LinearMap.adicCompletion_mk,
    component_sumInv, mk_apply_coe, LinearMap.adicCauchy_apply_coe, Submodule.mkQ_apply,
    LinearMap.id_comp]
  split
  ¬∑ next h => subst h; simp
  ¬∑ simp"
Mathlib/Analysis/Complex/CauchyIntegral.lean,Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r; exact ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R; exact ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (¬∑ + ¬∑) c ‚àò exp
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R; exact hc.comp hdg.continuous.continuousOn h_maps
  replace hd :
    ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z
  ¬∑ refine' fun z hz => (hd (g z) ‚ü®_, hz.2‚ü©).comp z (hdg _)
    simpa [dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd","error:  unexpected token ';'; expected '|'
error:  unsolved goals
case intro.intro
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚ÑÇ E
inst‚úù : CompleteSpace E
c : ‚ÑÇ
f : ‚ÑÇ ‚Üí E
s : Set ‚ÑÇ
a : ‚Ñù
h0 : 0 < rexp a
b : ‚Ñù
hle : a ‚â§ b
hd : ‚àÄ z ‚àà (ball c (rexp b) \ closedBall c (rexp a)) \ s, DifferentiableAt ‚ÑÇ f z
A : Set ‚ÑÇ := closedBall c (rexp b) \ ball c (rexp a)
R : Set ‚ÑÇ := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
g : ‚ÑÇ ‚Üí ‚ÑÇ := (fun x x_1 ‚Ü¶ x + x_1) c ‚àò cexp
hdg : Differentiable ‚ÑÇ g
hs : (g ‚Åª¬π' s).Countable
h_maps : MapsTo g R A
hc : ContinuousOn (f ‚àò g) R
‚ä¢ ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, I ‚Ä¢ f (circleMap c (rexp b) Œ∏) = ‚à´ (Œ∏ : ‚Ñù) in 0 ..2 * œÄ, I ‚Ä¢ f (circleMap c (rexp a) Œ∏)","theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ‚ÑÇ}
    {r R : ‚Ñù} (h0 : 0 < r) (hle : r ‚â§ R) {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ‚àÄ z ‚àà (ball c R \ closedBall c r) \ s, DifferentiableAt ‚ÑÇ f z) :
    (‚àÆ z in C(c, R), (z - c)‚Åª¬π ‚Ä¢ f z) = ‚àÆ z in C(c, r), (z - c)‚Åª¬π ‚Ä¢ f z ",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r := ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R := ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left‚ÇÄ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine fun z hz => (hd (g z) ‚ü®?_, hz.2‚ü©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd",":= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r; exact ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R; exact ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (¬∑ + ¬∑) c ‚àò exp
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R; exact hc.comp hdg.continuous.continuousOn h_maps
  replace hd :
    ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z
  ¬∑ refine fun z hz => (hd (g z) ‚ü®_, hz.2‚ü©).comp z (hdg _)
    simpa [dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd"
Mathlib/Computability/Ackermann.lean,ack_succ_right_le_ack_succ_left,ack_succ_right_le_ack_succ_left,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases' n with n n
  ¬∑ simp
  ¬∑ rw [ack_succ_succ, succ_eq_add_one]
    apply ack_mono_right m (le_trans _ <| add_add_one_le_ack _ n)
    omega","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
m n : ‚Ñï
‚ä¢ ack m (n + 1 + 1) ‚â§ ack m (ack (m + 1) n)",theorem ack_succ_right_le_ack_succ_left (m n : ‚Ñï) : ack m (n + 1) ‚â§ ack (m + 1) n ,":= by
  cases' n with n n
  ¬∑ simp
  ¬∑ rw [ack_succ_succ]
    apply ack_mono_right m (le_trans _ <| add_add_one_le_ack _ n)
    omega",":= by
  cases' n with n n
  ¬∑ simp
  ¬∑ rw [ack_succ_succ, succ_eq_add_one]
    apply ack_mono_right m (le_trans <| add_add_one_le_ack _ n)
    omega"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding',exists_extension_norm_eq_of_closedEmbedding',e2fa63869cbb917d67cfce82b3f2789ce68018df,":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel_left, pow_succ, mul_assoc]
      refine' (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := (mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine' tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 _)
    refine' squeeze_zero (fun _ => dist_nonneg) hgf _
    rw [‚Üê zero_mul ‚Äñf‚Äñ]
    refine' (tendsto_pow_atTop_nhds_zero_of_lt_one _ _).mul tendsto_const_nhds <;> norm_num1
  refine' ‚ü®limUnder atTop g, le_antisymm _ _, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine'
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq _
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _","error:  application type mismatch
  LE.le.trans (hF_dist (f - (g n).compContinuous e)) (mul_le_mul_of_nonneg_left ?m.115481 ?m.115895)
argument
  mul_le_mul_of_nonneg_left ?m.115481 ?m.115895
has type
  2 / 3 * ‚Äñf - (g n).compContinuous e‚Äñ ‚â§ 2 / 3 * ?m.115476 : Prop
but is expected to have type
  2 / 3 * ‚Äñf - (g n).compContinuous e‚Äñ ‚â§ (2 / 3) ^ n * (2 / 3 * ‚Äñf‚Äñ) : Prop
error:  no goals to be solved","theorem exists_extension_norm_eq_of_closedEmbedding' (f : X ‚Üí·µá ‚Ñù) (e : C(X, Y))
    (he : ClosedEmbedding e) : ‚àÉ g : Y ‚Üí·µá ‚Ñù, ‚Äñg‚Äñ = ‚Äñf‚Äñ ‚àß g.compContinuous e = f ",":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [‚Üê zero_mul ‚Äñf‚Äñ]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ‚ü®limUnder atTop g, le_antisymm ?_ ?_, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _",":= by
  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he
  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by
    intro n
    induction' n with n ihn
    ¬∑ simp [g0]
    ¬∑ rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [‚Üê dist_eq_norm']
  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ùìù <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [‚Üê zero_mul ‚Äñf‚Äñ]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ‚ü®limUnder atTop g, le_antisymm ?_ ?_, hge‚ü©
  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]
    refine
      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]
  ¬∑ rw [‚Üê hge]
    exact norm_compContinuous_le _ _"
Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean,Behrend.roth_lower_bound,roth_lower_bound,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  let n := nValue N
  have hn : 0 < (n : ‚Ñù) := cast_pos.2 (nValue_pos <| hN.trans' <| by norm_num1)
  have hd : 0 < dValue N := dValue_pos (hN.trans' <| by norm_num1)
  have hN‚ÇÄ : 0 < (N : ‚Ñù) := cast_pos.2 (hN.trans' <| by norm_num1)
  have hn‚ÇÇ : 2 < n := three_le_nValue <| hN.trans' <| by norm_num1
  have : (2 * dValue N - 1) ^ n ‚â§ N := le_N (hN.trans' <| by norm_num1)
  calc
    _ ‚â§ (N ^ (nValue N : ‚Ñù)‚Åª¬π / rexp 1 : ‚Ñù) ^ (n - 2) / n := ?_
    _ < _ := by gcongr; exacts [(tsub_pos_of_lt hn‚ÇÇ).ne', bound hN]
    _ ‚â§ rothNumberNat ((2 * dValue N - 1) ^ n) := bound_aux hd.ne' hn‚ÇÇ.le
    _ ‚â§ rothNumberNat N := mod_cast rothNumberNat.mono this
  rw [‚Üê rpow_natCast, div_rpow (rpow_nonneg hN‚ÇÄ.le _) (exp_pos _).le, ‚Üê rpow_mul hN‚ÇÄ.le,
    inv_mul_eq_div, cast_sub hn‚ÇÇ.le, cast_two, same_sub_div hn.ne', exp_one_rpow,
    div_div, rpow_sub hN‚ÇÄ, rpow_one, div_div, div_eq_mul_inv]
  refine mul_le_mul_of_nonneg_left ?_ (cast_nonneg _)
  rw [mul_inv, mul_inv, ‚Üê exp_neg, ‚Üê rpow_neg (cast_nonneg _), neg_sub, ‚Üê div_eq_mul_inv]
  have : exp (-4 * ‚àö(log N)) = exp (-2 * ‚àö(log N)) * exp (-2 * ‚àö(log N)) := by
    rw [‚Üê exp_add, ‚Üê add_mul]
    norm_num
  rw [this]
  refine mul_le_mul ?_ (exp_neg_two_mul_le <| Real.sqrt_pos.2 <| log_pos? _).le (exp_pos _).le <|
      rpow_nonneg (cast_nonneg _) _
  ¬∑ rw [‚Üê le_log_iff_exp_le (rpow_pos_of_pos hN‚ÇÄ _), log_rpow hN‚ÇÄ, ‚Üê le_div_iff, mul_div_assoc,
      div_sqrt, neg_mul, neg_le_neg_iff, div_mul_eq_mul_div, div_le_iff hn]
    ¬∑ exact mul_le_mul_of_nonneg_left (le_ceil _) zero_le_two
    refine Real.sqrt_pos.2 (log_pos ?_)
    rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)","error:  unknown identifier 'log_pos?'
error:  no goals to be solved","theorem roth_lower_bound_explicit (hN : 4096 ‚â§ N) :
    (N : ‚Ñù) * exp (-4 * ‚àö(log N)) < rothNumberNat N ",":= by
  let n := nValue N
  have hn : 0 < (n : ‚Ñù) := cast_pos.2 (nValue_pos <| hN.trans' <| by norm_num1)
  have hd : 0 < dValue N := dValue_pos (hN.trans' <| by norm_num1)
  have hN‚ÇÄ : 0 < (N : ‚Ñù) := cast_pos.2 (hN.trans' <| by norm_num1)
  have hn‚ÇÇ : 2 < n := three_le_nValue <| hN.trans' <| by norm_num1
  have : (2 * dValue N - 1) ^ n ‚â§ N := le_N (hN.trans' <| by norm_num1)
  calc
    _ ‚â§ (N ^ (nValue N : ‚Ñù)‚Åª¬π / rexp 1 : ‚Ñù) ^ (n - 2) / n := ?_
    _ < _ := by gcongr; exacts [(tsub_pos_of_lt hn‚ÇÇ).ne', bound hN]
    _ ‚â§ rothNumberNat ((2 * dValue N - 1) ^ n) := bound_aux hd.ne' hn‚ÇÇ.le
    _ ‚â§ rothNumberNat N := mod_cast rothNumberNat.mono this
  rw [‚Üê rpow_natCast, div_rpow (rpow_nonneg hN‚ÇÄ.le _) (exp_pos _).le, ‚Üê rpow_mul hN‚ÇÄ.le,
    inv_mul_eq_div, cast_sub hn‚ÇÇ.le, cast_two, same_sub_div hn.ne', exp_one_rpow,
    div_div, rpow_sub hN‚ÇÄ, rpow_one, div_div, div_eq_mul_inv]
  refine mul_le_mul_of_nonneg_left ?_ (cast_nonneg _)
  rw [mul_inv, mul_inv, ‚Üê exp_neg, ‚Üê rpow_neg (cast_nonneg _), neg_sub, ‚Üê div_eq_mul_inv]
  have : exp (-4 * ‚àö(log N)) = exp (-2 * ‚àö(log N)) * exp (-2 * ‚àö(log N)) := by
    rw [‚Üê exp_add, ‚Üê add_mul]
    norm_num
  rw [this]
  refine mul_le_mul ?_ (exp_neg_two_mul_le <| Real.sqrt_pos.2 <| log_pos ?_).le (exp_pos _).le <|
      rpow_nonneg (cast_nonneg _) _
  ¬∑ rw [‚Üê le_log_iff_exp_le (rpow_pos_of_pos hN‚ÇÄ _), log_rpow hN‚ÇÄ, ‚Üê le_div_iff, mul_div_assoc,
      div_sqrt, neg_mul, neg_le_neg_iff, div_mul_eq_mul_div, div_le_iff hn]
    ¬∑ exact mul_le_mul_of_nonneg_left (le_ceil _) zero_le_two
    refine Real.sqrt_pos.2 (log_pos ?_)
    rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)",":= by
  let n := nValue N
  have hn : 0 < (n : ‚Ñù) := cast_pos.2 (nValue_pos <| hN.trans' <| by norm_num1)
  have hd : 0 < dValue N := dValue_pos (hN.trans' <| by norm_num1)
  have hN‚ÇÄ : 0 < (N : ‚Ñù) := cast_pos.2 (hN.trans' <| by norm_num1)
  have hn‚ÇÇ : 2 < n := three_le_nValue <| hN.trans' <| by norm_num1
  have : (2 * dValue N - 1) ^ n ‚â§ N := le_N (hN.trans' <| by norm_num1)
  calc
    _ ‚â§ (N ^ (nValue N : ‚Ñù)‚Åª¬π / rexp 1 : ‚Ñù) ^ (n - 2) / n := ?_
    _ < _ := by gcongr; exacts [(tsub_pos_of_lt hn‚ÇÇ).ne', bound hN]
    _ ‚â§ rothNumberNat ((2 * dValue N - 1) ^ n) := bound_aux hd.ne' hn‚ÇÇ.le
    _ ‚â§ rothNumberNat N := mod_cast rothNumberNat.mono this
  rw [‚Üê rpow_natCast, div_rpow (rpow_nonneg hN‚ÇÄ.le _) (exp_pos _).le, ‚Üê rpow_mul hN‚ÇÄ.le,
    inv_mul_eq_div, cast_sub hn‚ÇÇ.le, cast_two, same_sub_div hn.ne', exp_one_rpow,
    div_div, rpow_sub hN‚ÇÄ, rpow_one, div_div, div_eq_mul_inv]
  refine mul_le_mul_of_nonneg_left ?_ (cast_nonneg _)
  rw [mul_inv, mul_inv, ‚Üê exp_neg, ‚Üê rpow_neg (cast_nonneg _), neg_sub, ‚Üê div_eq_mul_inv]
  have : exp (-4 * ‚àö(log N)) = exp (-2 * ‚àö(log N)) * exp (-2 * ‚àö(log N)) := by
    rw [‚Üê exp_add, ‚Üê add_mul]
    norm_num
  rw [this]
  refine mul_le_mul ?_ (exp_neg_two_mul_le <| Real.sqrt_pos.2 <| log_pos? ?_).le (exp_pos _).le <|
      rpow_nonneg (cast_nonneg _) _
  ¬∑ rw [‚Üê le_log_iff_exp_le (rpow_pos_of_pos hN‚ÇÄ _), log_rpow hN‚ÇÄ, ‚Üê le_div_iff, mul_div_assoc,
      div_sqrt, neg_mul, neg_le_neg_iff, div_mul_eq_mul_div, div_le_iff hn]
    ¬∑ exact mul_le_mul_of_nonneg_left (le_ceil _) zero_le_two
    refine Real.sqrt_pos.2 (log_pos ?_)
    rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  ¬∑ rw [one_lt_cast]
  "
Mathlib/Data/Multiset/Basic.lean,Multiset.filter_attach',filter_attach',0f4b7a5517f03c73769c78233b0171b31784c97b,":= by
  classical
  refine' Multiset.map_injective Subtype.val_injective _
  rw [map_filter' _ Subtype.val_injective]
  simp only [Function.comp, Subtype.exists, coe_mk,
    exists_and_right, exists_eq_right, attach_map_val, map_map, map_coe, id.def]","warning:  @cons does not have a doc string
warning:  `List.filter_congr'` has been deprecated, use `List.filter_congr` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.323264 ‚Üí ?m.323264
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type v
Œ≥ : Type u_2
s : Multiset Œ±
p : { a // a ‚àà s } ‚Üí Prop
inst‚úù¬π : DecidableEq Œ±
inst‚úù : DecidablePred p
‚ä¢ filter (fun b ‚Ü¶ ‚àÉ (x : b ‚àà s), p ‚ü®b, ‚ãØ‚ü©) s =
    map (fun x ‚Ü¶ ‚Üë(Subtype.map id ‚ãØ x)) (filter (fun x ‚Ü¶ ‚àÉ (h : x ‚àà s), p ‚ü®x, h‚ü©) s).attach
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead","lemma filter_attach' (s : Multiset Œ±) (p : {a // a ‚àà s} ‚Üí Prop) [DecidableEq Œ±]
    [DecidablePred p] :
    s.attach.filter p =
      (s.filter fun x ‚Ü¶ ‚àÉ h, p ‚ü®x, h‚ü©).attach.map (Subtype.map id fun x ‚Ü¶ mem_of_mem_filter) ",":= by
  classical
  refine Multiset.map_injective Subtype.val_injective ?_
  rw [map_filter' _ Subtype.val_injective]
  simp only [Function.comp, Subtype.exists, coe_mk, Subtype.map,
    exists_and_right, exists_eq_right, attach_map_val, map_map, map_coe, id]",":= by
  classical
  refine Multiset.map_injective Subtype.val_injective ?_
  simp only [Function.comp, Subtype.exists, coe_mk,
    exists_and_right, exists_eq_right, attach_map_val, map_map, map_coe, id]"
Mathlib/LinearAlgebra/Semisimple.lean,Module.End.IsSemisimple.of_mem_adjoin_pair,IsSemisimple.of_mem_adjoin_pair,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R :=
    (AdjoinRoot.powerBasis' <| minpoly.monic <| Algebra.IsIntegral.isIntegral f).finite
  have : Finite R S :=
    (AdjoinRoot.powerBasis' <| (minpoly.monic <| Algebra.IsIntegral.isIntegral g).map _).finite
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ, ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.comp_apply, minpoly.aeval, œÜ.map_zero]","error:  type mismatch
  IsScalarTower.of_algebraMap_eq fun x ‚Ü¶ rfl
has type
  IsScalarTower K K ?m.177547 : Prop
but is expected to have type
  IsScalarTower K R S : Prop
error:  application type mismatch
  of_mem_adjoin_pair comm
argument
  comm
has type
  Commute f g : Prop
but is expected to have type
  ?m.182310 ‚àà Algebra.adjoin ?m.182304 {?m.182307, ?m.182308} : Prop
error:  application type mismatch
  of_mem_adjoin_pair comm
argument
  comm
has type
  Commute f g : Prop
but is expected to have type
  ?m.184990 ‚àà Algebra.adjoin ?m.184984 {?m.184987, ?m.184988} : Prop
error:  application type mismatch
  of_mem_adjoin_pair comm
argument
  comm
has type
  Commute f g : Prop
but is expected to have type
  ?m.187651 ‚àà Algebra.adjoin ?m.187645 {?m.187648, ?m.187649} : Prop","theorem IsSemisimple.of_mem_adjoin_pair {a : End K M} (ha : a ‚àà Algebra.adjoin K {f, g}) :
    a.IsSemisimple ",":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R :=
    (AdjoinRoot.powerBasis' <| minpoly.monic <| Algebra.IsIntegral.isIntegral f).finite
  have : Finite R S :=
    (AdjoinRoot.powerBasis' <| (minpoly.monic <| Algebra.IsIntegral.isIntegral g).map _).finite
  set_option maxSynthPendingDepth 2 in
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ, ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.comp_apply, minpoly.aeval, œÜ.map_zero]",":= by
  let R := K[X] ‚ß∏ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R :=
    (AdjoinRoot.powerBasis' <| minpoly.monic <| Algebra.IsIntegral.isIntegral f).finite
  have : Finite R S :=
    (AdjoinRoot.powerBasis' <| (minpoly.monic <| Algebra.IsIntegral.isIntegral g).map _).finite
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ‚Ü¶ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ‚ñ∏ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ‚Üê Ideal.isRadical_iff_quotient_reduced, ‚Üê isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let œÜ : S ‚Üí‚Çê[K] End K M := Ideal.Quotient.lift‚Çê _ (eval‚ÇÇAlgHom' (Ideal.Quotient.lift‚Çê _ (aeval f)
    fun a ‚Ü¶ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ‚â§ RingHom.ker _)
  rotate_left 1
  ¬∑ rw [Ideal.span, ‚Üê minpoly.ker_aeval_eq_span_minpoly]; exact id
  ¬∑ rintro ‚ü®p‚ü©; exact p.induction_on (fun k ‚Ü¶ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ‚Ü¶ by simpa using hp.add_left hq)
      fun n k ‚Ü¶ by simpa [R, pow_succ', ‚Üê mul_assoc _ _ X] using (¬∑.mul_left comm)
  ¬∑ simpa only [RingHom.mem_ker, eval‚ÇÇAlgHom'_apply, eval‚ÇÇ_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ‚â§ œÜ.range := Algebra.adjoin_le fun x ‚Ü¶ by
    rintro (hx | hx) <;> rw [hx]
    ¬∑ exact ‚ü®AdjoinRoot.of _ (AdjoinRoot.root _), (eval‚ÇÇ_C _ _).trans (aeval_X f)‚ü©
    ¬∑ exact ‚ü®AdjoinRoot.root _, eval‚ÇÇ_X _ _‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, œÜ.comp_apply, minpoly.aeval, œÜ.map_zero]"
Mathlib/Data/Multiset/Basic.lean,Multiset.filter_attach',filter_attach',5634c52c4ae1e260b29c94e98579196bf4c10d44,":= by
  classical
  refine' Multiset.map_injective Subtype.val_injective _
  rw [map_filter' _ Subtype.val_injective]
  simp only [Function.comp, Subtype.exists, coe_mk, Subtype.map,
    exists_and_right, exists_eq_right, attach_map_val, map_map, map_coe, id.def]","warning:  @cons does not have a doc string
warning:  `List.filter_congr'` has been deprecated, use `List.filter_congr` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.323267 ‚Üí ?m.323267
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type v
Œ≥ : Type u_2
s : Multiset Œ±
p : { a // a ‚àà s } ‚Üí Prop
inst‚úù¬π : DecidableEq Œ±
inst‚úù : DecidablePred p
‚ä¢ filter (fun b ‚Ü¶ ‚àÉ (x : b ‚àà s), p ‚ü®b, ‚ãØ‚ü©) s = map (fun x ‚Ü¶ id ‚Üëx) (filter (fun x ‚Ü¶ ‚àÉ (h : x ‚àà s), p ‚ü®x, h‚ü©) s).attach
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead","lemma filter_attach' (s : Multiset Œ±) (p : {a // a ‚àà s} ‚Üí Prop) [DecidableEq Œ±]
    [DecidablePred p] :
    s.attach.filter p =
      (s.filter fun x ‚Ü¶ ‚àÉ h, p ‚ü®x, h‚ü©).attach.map (Subtype.map id fun x ‚Ü¶ mem_of_mem_filter) ",":= by
  classical
  refine Multiset.map_injective Subtype.val_injective ?_
  rw [map_filter' _ Subtype.val_injective]
  simp only [Function.comp, Subtype.exists, coe_mk, Subtype.map,
    exists_and_right, exists_eq_right, attach_map_val, map_map, map_coe, id]",":= by
  classical
  refine Multiset.map_injective Subtype.val_injective ?_
  simp only [Function.comp, Subtype.exists, coe_mk, Subtype.map,
    exists_and_right, exists_eq_right, attach_map_val, map_map, map_coe, id]"
Mathlib/Geometry/Manifold/BumpFunction.lean,SmoothBumpFunction.nhdsWithin_range_basis,nhdsWithin_range_basis,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  refine' ((nhdsWithin_hasBasis nhds_basis_closedBall _).restrict_subset
    (extChartAt_target_mem_nhdsWithin _ _)).to_has_basis' _ _
  ¬∑ rintro R ‚ü®hR0, hsub‚ü©
    exact ‚ü®‚ü®‚ü®R / 2, R, half_pos hR0, half_lt_self hR0‚ü©, hsub‚ü©, trivial, Subset.rfl‚ü©
  ¬∑ exact fun f _ => inter_mem (mem_nhdsWithin_of_mem_nhds <| closedBall_mem_nhds _ f.rOut_pos)
      self_mem_nhdsWithin","error:  invalid field 'to_has_basis'', the environment does not contain 'Filter.HasBasis.to_has_basis''
  HasBasis.restrict_subset (nhdsWithin_hasBasis nhds_basis_closedBall (range ‚Üë?m.54002))
    (extChartAt_target_mem_nhdsWithin ?m.54002 ?m.54004)
has type
  (ùìù[range ‚Üë?m.54002] ‚Üë(extChartAt ?m.54002 ?m.54004) ?m.54004).HasBasis
    (fun i ‚Ü¶
      0 < i ‚àß
        closedBall (‚Üë(extChartAt ?m.54002 ?m.54004) ?m.54004) i ‚à© range ‚Üë?m.54002 ‚äÜ
          (extChartAt ?m.54002 ?m.54004).target)
    fun i ‚Ü¶ closedBall (‚Üë(extChartAt ?m.54002 ?m.54004) ?m.54004) i ‚à© range ‚Üë?m.54002
error:  no goals to be solved","theorem nhdsWithin_range_basis :
    (ùìù[range I] extChartAt I c c).HasBasis (fun _ : SmoothBumpFunction I c => True) fun f =>
      closedBall (extChartAt I c c) f.rOut ‚à© range I ",":= by
  refine ((nhdsWithin_hasBasis nhds_basis_closedBall _).restrict_subset
    (extChartAt_target_mem_nhdsWithin _ _)).to_hasBasis' ?_ ?_
  ¬∑ rintro R ‚ü®hR0, hsub‚ü©
    exact ‚ü®‚ü®‚ü®R / 2, R, half_pos hR0, half_lt_self hR0‚ü©, hsub‚ü©, trivial, Subset.rfl‚ü©
  ¬∑ exact fun f _ => inter_mem (mem_nhdsWithin_of_mem_nhds <| closedBall_mem_nhds _ f.rOut_pos)
      self_mem_nhdsWithin",":= by
  refine ((nhdsWithin_hasBasis nhds_basis_closedBall _).restrict_subset
    (extChartAt_target_mem_nhdsWithin _ _)).to_has_basis' ?_ ?_
  ¬∑ rintro R ‚ü®hR0, hsub‚ü©
    exact ‚ü®‚ü®‚ü®R / 2, R, half_pos hR0, half_lt_self hR0‚ü©, hsub‚ü©, trivial, Subset.rfl‚ü©
  ¬∑ exact fun f _ => inter_mem (mem_nhdsWithin_of_mem_nhds <| closedBall_mem_nhds _ f.rOut_pos)
      self_mem_nhdsWithin"
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Œ¥_comp_œÉ_of_gt,Œ¥_comp_œÉ_of_gt,d7f8050468d4e16195b721085d9c4536194abc3e,":= by
  ext ‚ü®k, hk‚ü©
  rcases i with ‚ü®i, hi‚ü©
  rcases j with ‚ü®j, hj‚ü©
  simp? at H hk says simp only [Fin.castSucc_mk, Fin.mk_lt_mk, len_mk] at H hk
  dsimp [Œ¥, œÉ, Fin.predAbove, Fin.succAbove]
  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, ge_iff_le,
    Fin.coe_castLT, dite_eq_ite, Fin.coe_castSucc, Fin.val_succ]
  split_ifs
  all_goals try simp <;> linarith
  all_goals cases k <;> simp at * <;> linarith","error:  linarith failed to find a contradiction
case neg.zero.h1.h
n i : ‚Ñï
hi : i < n + 2
j : ‚Ñï
hj : j < n + 1
H : j < i
hk : 0 < n + 1 + 1
h‚úù¬π : 0 < i + 1
h‚úù : ¬¨j < 0
a‚úù : 0 < if 0 < i then 0 else 1
‚ä¢ False
failed
error:  linarith failed to find a contradiction
case neg.succ.h1.h
n i : ‚Ñï
hi : i < n + 2
j : ‚Ñï
hj : j < n + 1
H : j < i
n‚úù : ‚Ñï
hk : n‚úù + 1 < n + 1 + 1
h‚úù¬π : n‚úù + 1 < i + 1
h‚úù : ¬¨j < n‚úù + 1
a‚úù : n‚úù + 1 < if n‚úù + 1 < i then n‚úù + 1 else n‚úù + 1 + 1
‚ä¢ False
failed
error:  unsolved goals
case neg.zero
n i : ‚Ñï
hi : i < n + 2
j : ‚Ñï
hj : j < n + 1
H : j < i
hk : 0 < n + 1 + 1
h‚úù¬π : 0 < i + 1
h‚úù : ¬¨j < 0
‚ä¢ 0 = if 0 < i then 0 else 1

case neg.succ
n i : ‚Ñï
hi : i < n + 2
j : ‚Ñï
hj : j < n + 1
H : j < i
n‚úù : ‚Ñï
hk : n‚úù + 1 < n + 1 + 1
h‚úù¬π : n‚úù + 1 < i + 1
h‚úù : ¬¨j < n‚úù + 1
‚ä¢ n‚úù + 1 = if n‚úù + 1 < i then n‚úù + 1 else n‚úù + 1 + 1","theorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Œ¥ i.succ ‚â´ œÉ (Fin.castSucc j) = œÉ j ‚â´ Œ¥ i ",":= by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]",":= by
  ext ‚ü®k, hk‚ü©
  rcases i with ‚ü®i, hi‚ü©
  rcases j with ‚ü®j, hj‚ü©
  simp? at H hk says simp only [Fin.castSucc_mk, Fin.mk_lt_mk, len_mk] at H hk
  dsimp [Œ¥, œÉ, Fin.predAbove, Fin.succAbove]
  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, ge_iff_le,
    Fin.coe_castLT, dite_eq_ite, Fin.coe_castSucc, Fin.val_succ]
  split_ifs
  all_goals try simp <;> linarith
  all_goals cases k <;> simp at * <;> linarith"
Mathlib/Analysis/SpecialFunctions/Integrals.lean,intervalIntegral.intervalIntegrable_rpow',intervalIntegrable_rpow',b15c6ea0b0ad3ac6e15420c45ece165eca6725cc,":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg_of_nonneg hx.1.le
    ¬∑ refine' (continuousOn_id.rpow_const _).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine' m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    rw [Pi.smul_apply]
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]","error:  no goals to be solved
warning:  `rpow_nonneg_of_nonneg` has been deprecated, use `Real.rpow_nonneg` instead","theorem intervalIntegrable_rpow' {r : ‚Ñù} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",":= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg_of_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const _).div_const ?_; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    rw [Pi.smul_apply]
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]"
Mathlib/GroupTheory/PGroup.lean,IsPGroup.disjoint_of_ne,disjoint_of_ne,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rw [Subgroup.disjoint_def]
  intro x hx‚ÇÅ hx‚ÇÇ
  obtain ‚ü®n‚ÇÅ, hn‚ÇÅ‚ü© := iff_orderOf.mp hH‚ÇÅ ‚ü®x, hx‚ÇÅ‚ü©
  obtain ‚ü®n‚ÇÇ, hn‚ÇÇ‚ü© := iff_orderOf.mp hH‚ÇÇ ‚ü®x, hx‚ÇÇ‚ü©
  rw [‚Üê orderOf_subgroup, Subgroup.coe_mk] at hn‚ÇÅ hn‚ÇÇ
  have : p‚ÇÅ ^ n‚ÇÅ = p‚ÇÇ ^ n‚ÇÇ := by rw [‚Üê hn‚ÇÅ, ‚Üê hn‚ÇÇ]
  rcases n‚ÇÅ.eq_zero_or_pos with (rfl | hn‚ÇÅ)
  ¬∑ simpa using hn‚ÇÅ
  ¬∑ exact absurd (eq_of_prime_pow_eq hp‚ÇÅ.out.prime hp‚ÇÇ.out.prime hn‚ÇÅ this) hne","error:  unknown identifier 'orderOf_subgroup'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.84985
case intro.intro
p : ‚Ñï
G : Type u_1
inst‚úù : Group G
p‚ÇÅ p‚ÇÇ : ‚Ñï
hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)
hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)
hne : p‚ÇÅ ‚â† p‚ÇÇ
H‚ÇÅ H‚ÇÇ : Subgroup G
hH‚ÇÅ : IsPGroup p‚ÇÅ ‚Ü•H‚ÇÅ
hH‚ÇÇ : IsPGroup p‚ÇÇ ‚Ü•H‚ÇÇ
x : G
hx‚ÇÅ : x ‚àà H‚ÇÅ
hx‚ÇÇ : x ‚àà H‚ÇÇ
n‚ÇÅ : ‚Ñï
hn‚ÇÅ : orderOf ‚ü®x, hx‚ÇÅ‚ü© = p‚ÇÅ ^ n‚ÇÅ
n‚ÇÇ : ‚Ñï
hn‚ÇÇ : orderOf ‚ü®x, hx‚ÇÇ‚ü© = p‚ÇÇ ^ n‚ÇÇ
‚ä¢ x = 1","theorem disjoint_of_ne (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact p‚ÇÅ.Prime] [hp‚ÇÇ : Fact p‚ÇÇ.Prime] (hne : p‚ÇÅ ‚â† p‚ÇÇ)
    (H‚ÇÅ H‚ÇÇ : Subgroup G) (hH‚ÇÅ : IsPGroup p‚ÇÅ H‚ÇÅ) (hH‚ÇÇ : IsPGroup p‚ÇÇ H‚ÇÇ) : Disjoint H‚ÇÅ H‚ÇÇ ",":= by
  rw [Subgroup.disjoint_def]
  intro x hx‚ÇÅ hx‚ÇÇ
  obtain ‚ü®n‚ÇÅ, hn‚ÇÅ‚ü© := iff_orderOf.mp hH‚ÇÅ ‚ü®x, hx‚ÇÅ‚ü©
  obtain ‚ü®n‚ÇÇ, hn‚ÇÇ‚ü© := iff_orderOf.mp hH‚ÇÇ ‚ü®x, hx‚ÇÇ‚ü©
  rw [Subgroup.orderOf_mk] at hn‚ÇÅ hn‚ÇÇ
  have : p‚ÇÅ ^ n‚ÇÅ = p‚ÇÇ ^ n‚ÇÇ := by rw [‚Üê hn‚ÇÅ, ‚Üê hn‚ÇÇ]
  rcases n‚ÇÅ.eq_zero_or_pos with (rfl | hn‚ÇÅ)
  ¬∑ simpa using hn‚ÇÅ
  ¬∑ exact absurd (eq_of_prime_pow_eq hp‚ÇÅ.out.prime hp‚ÇÇ.out.prime hn‚ÇÅ this) hne",":= by
  rw [Subgroup.disjoint_def]
  intro x hx‚ÇÅ hx‚ÇÇ
  obtain ‚ü®n‚ÇÅ, hn‚ÇÅ‚ü© := iff_orderOf.mp hH‚ÇÅ ‚ü®x, hx‚ÇÅ‚ü©
  obtain ‚ü®n‚ÇÇ, hn‚ÇÇ‚ü© := iff_orderOf.mp hH‚ÇÇ ‚ü®x, hx‚ÇÇ‚ü©
  rw [‚Üê orderOf_subgroup, Subgroup.coe_mk] at hn‚ÇÅ hn‚ÇÇ
  have : p‚ÇÅ ^ n‚ÇÅ = p‚ÇÇ ^ n‚ÇÇ := by rw [‚Üê hn‚ÇÅ, ‚Üê hn‚ÇÇ]
  rcases n‚ÇÅ.eq_zero_or_pos with (rfl | hn‚ÇÅ)
  ¬∑ simpa using hn‚ÇÅ
  ¬∑ exact absurd (eq_of_prime_pow_eq hp‚ÇÅ.out.prime hp‚ÇÇ.out.prime hn‚ÇÅ this) hne"
Mathlib/Data/Set/Countable.lean,Set.countable_setOf_finite_subset,countable_setOf_finite_subset,87c5a5a812b43358ca77ed7cb1211985afb5b9b7,":= by
  haveI := hs.to_subtype
  refine' Countable.mono _ (countable_range fun t : Finset s => Subtype.val '' (t : Set s))
  rintro t ‚ü®ht, hts‚ü©
  lift t to Set s using hts
  lift t to Finset s using ht.of_finite_image (Subtype.val_injective.injOn _)
  exact mem_range_self _","error:  application type mismatch
  Finite.of_finite_image ht (Injective.injOn Subtype.val_injective ?m.10739)
argument
  Injective.injOn Subtype.val_injective ?m.10739
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Subtype ?m.10716‚¶Ñ, x‚ÇÇ ‚àà ?m.10737 ‚Üí ‚Üë?m.10738 = ‚Üëx‚ÇÇ ‚Üí ?m.10738 = x‚ÇÇ : Prop
but is expected to have type
  InjOn Subtype.val t : Prop","theorem countable_setOf_finite_subset {s : Set Œ±} (hs : s.Countable) :
    { t | Set.Finite t ‚àß t ‚äÜ s }.Countable ",":= by
  have := hs.to_subtype
  refine (countable_range fun t : Finset s => Subtype.val '' (t : Set s)).mono ?_
  rintro t ‚ü®ht, hts‚ü©
  lift t to Set s using hts
  lift t to Finset s using ht.of_finite_image Subtype.val_injective.injOn
  exact mem_range_self _",":= by
  haveI := hs.to_subtype
  refine Countable.mono ?_ (countable_range fun t : Finset s => Subtype.val '' (t : Set s))
  rintro t ‚ü®ht, hts‚ü©
  lift t to Set s using hts
  lift t to Finset s using ht.of_finite_image (Subtype.val_injective.injOn)
  exact mem_range_self _"
Mathlib/Topology/LocalAtTarget.lean,inducing_iff_inducing_of_iSup_eq_top,inducing_iff_inducing_of_iSup_eq_top,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp_rw [inducing_subtype_val.inducing_iff, inducing_iff_nhds, restrictPreimage,
    MapsTo.coe_restrict, restrict_eq, ‚Üê @Filter.comap_comap _ _ _ _ _ f]
  constructor
  ¬∑ intro H i x
    rw [Function.comp_apply, ‚Üê H, ‚Üê inducing_subtype_val.nhds_eq_comap]
  ¬∑ intro H x
    obtain ‚ü®i, hi‚ü© :=
      Opens.mem_iSup.mp
        (show f x ‚àà iSup U by
          rw [hU]
          trivial)
    erw [‚Üê OpenEmbedding.map_nhds_eq (h.1 _ (U i).2).openEmbedding_subtype_val ‚ü®x, hi‚ü©]
    rw [(H i) ‚ü®x, hi‚ü©, Filter.subtype_coe_map_comap, Function.comp_apply, Subtype.coe_mk,
      inf_eq_left, Filter.le_principal_iff]
    exact Filter.preimage_mem_comap ((U i).2.mem_nhds hi)","error:  invalid field 'inducing_iff', the environment does not contain 'Inducing.inducing_iff'
  inducing_subtype_val
has type
  Inducing Subtype.val
error:  simp made no progress
warning:  Used `tac1 <;> tac2` where `(tac1; tac2)` would suffice
note: this linter can be disabled with `set_option linter.unnecessarySeqFocus false`","theorem inducing_iff_inducing_of_iSup_eq_top (h : Continuous f) :
    Inducing f ‚Üî ‚àÄ i, Inducing ((U i).1.restrictPreimage f) ",":= by
  simp_rw [‚Üê inducing_subtype_val.of_comp_iff, inducing_iff_nhds, restrictPreimage,
    MapsTo.coe_restrict, restrict_eq, ‚Üê @Filter.comap_comap _ _ _ _ _ f]
  constructor
  ¬∑ intro H i x
    rw [Function.comp_apply, ‚Üê H, ‚Üê inducing_subtype_val.nhds_eq_comap]
  ¬∑ intro H x
    obtain ‚ü®i, hi‚ü© :=
      Opens.mem_iSup.mp
        (show f x ‚àà iSup U by
          rw [hU]
          trivial)
    erw [‚Üê OpenEmbedding.map_nhds_eq (h.1 _ (U i).2).openEmbedding_subtype_val ‚ü®x, hi‚ü©]
    rw [(H i) ‚ü®x, hi‚ü©, Filter.subtype_coe_map_comap, Function.comp_apply, Subtype.coe_mk,
      inf_eq_left, Filter.le_principal_iff]
    exact Filter.preimage_mem_comap ((U i).2.mem_nhds hi)",":= by
  simp_rw [inducing_subtype_val.inducing_iff, inducing_iff_nhds, restrictPreimage,
    MapsTo.coe_restrict, restrict_eq, ‚Üê @Filter.comap_comap _ _ _ _ _ f]
  constructor
  ¬∑ intro H i x
    rw [Function.comp_apply, ‚Üê H, ‚Üê inducing_subtype_val.nhds_eq_comap]
  ¬∑ intro H x
    obtain ‚ü®i, hi‚ü© :=
      Opens.mem_iSup.mp
        (show f x ‚àà iSup U by
          rw [hU]
          trivial)
    erw [‚Üê OpenEmbedding.map_nhds_eq (h.1 _ (U i).2).openEmbedding_subtype_val ‚ü®x, hi‚ü©]
    rw [(H i) ‚ü®x, hi‚ü©, Filter.subtype_coe_map_comap, Function.comp_apply, Subtype.coe_mk,
      inf_eq_left, Filter.le_principal_iff]
    exact Filter.preimage_mem_comap ((U i).2.mem_nhds hi)"
Mathlib/MeasureTheory/Measure/GiryMonad.lean,MeasureTheory.Measure.bind_bind,bind_bind,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext1 s hs
  erw [bind_apply hs hg, bind_apply hs ((measurable_bind' hg).comp hf),
    lintegral_bind hf ((measurable_coe hs).comp hg)]
  conv_rhs => enter [2, a]; erw [bind_apply hs hg]","error:  unsolved goals
case h
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬≤ : MeasurableSpace Œ±
inst‚úù¬π : MeasurableSpace Œ≤
Œ≥ : Type u_3
inst‚úù : MeasurableSpace Œ≥
m : Measure Œ±
f : Œ± ‚Üí Measure Œ≤
g : Œ≤ ‚Üí Measure Œ≥
hf : Measurable f
hg : Measurable g
s : Set Œ≥
hs : MeasurableSet s
‚ä¢ ‚à´‚Åª (a : Œ±), ‚à´‚Åª (x : Œ≤), ((fun Œº ‚Ü¶ Œº s) ‚àò g) x ‚àÇf a ‚àÇm = ‚à´‚Åª (a : Œ±), ‚à´‚Åª (a : Œ≤), (g a) s ‚àÇf a ‚àÇm","theorem bind_bind {Œ≥} [MeasurableSpace Œ≥] {m : Measure Œ±} {f : Œ± ‚Üí Measure Œ≤} {g : Œ≤ ‚Üí Measure Œ≥}
    (hf : Measurable f) (hg : Measurable g) : bind (bind m f) g = bind m fun a => bind (f a) g ",":= by
  ext1 s hs
  erw [bind_apply hs hg, bind_apply hs ((measurable_bind' hg).comp hf),
    lintegral_bind hf ((measurable_coe hs).comp hg)]
  conv_rhs => enter [2, a]; erw [bind_apply hs hg]
  rfl",":= by
  ext1 s hs
  erw [bind_apply hs hg, bind_apply hs ((measurable_bind' hg).comp hf), lintegral_bind hf ((measurable_coe hs).comp hg)]
  conv_rhs => enter [2, a]; erw [bind_apply hs hg]"
Mathlib/MeasureTheory/Decomposition/SignedLebesgue.lean,MeasureTheory.SignedMeasure.singularPart_add,singularPart_add,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  conv_rhs =>
    rw [‚Üê toSignedMeasure_toJordanDecomposition s, JordanDecomposition.toSignedMeasure]
  rw [singularPart, rnDeriv,
    withDensity·µ•_sub' (integrable_toReal_of_lintegral_ne_top _ _)
      (integrable_toReal_of_lintegral_ne_top _ _),
    withDensity·µ•_toReal, withDensity·µ•_toReal, sub_eq_add_neg, sub_eq_add_neg,
    add_comm (s.toJordanDecomposition.posPart.singularPart Œº).toSignedMeasure, ‚Üê add_assoc,
    add_assoc (-(s.toJordanDecomposition.negPart.singularPart Œº).toSignedMeasure),
    ‚Üê toSignedMeasure_add, add_comm, ‚Üê add_assoc, ‚Üê neg_add, ‚Üê toSignedMeasure_add, add_comm,
    ‚Üê sub_eq_add_neg]
  convert rfl
  ¬∑ exact s.toJordanDecomposition.posPart.haveLebesgueDecomposition_add Œº
  ¬∑ rw [add_comm]
    exact s.toJordanDecomposition.negPart.haveLebesgueDecomposition_add Œº
  all_goals
    first
    | exact (lintegral_rnDeriv_lt_top _ _).ne
    | measurability",error:  failed to rewrite using equation theorems for 'MeasureTheory.SignedMeasure.rnDeriv',"theorem singularPart_add_withDensity_rnDeriv_eq [s.HaveLebesgueDecomposition Œº] :
    s.singularPart Œº + Œº.withDensity·µ• (s.rnDeriv Œº) = s ",":= by
  conv_rhs =>
    rw [‚Üê toSignedMeasure_toJordanDecomposition s, JordanDecomposition.toSignedMeasure]
  rw [singularPart, rnDeriv_def,
    withDensity·µ•_sub' (integrable_toReal_of_lintegral_ne_top _ _)
      (integrable_toReal_of_lintegral_ne_top _ _),
    withDensity·µ•_toReal, withDensity·µ•_toReal, sub_eq_add_neg, sub_eq_add_neg,
    add_comm (s.toJordanDecomposition.posPart.singularPart Œº).toSignedMeasure, ‚Üê add_assoc,
    add_assoc (-(s.toJordanDecomposition.negPart.singularPart Œº).toSignedMeasure),
    ‚Üê toSignedMeasure_add, add_comm, ‚Üê add_assoc, ‚Üê neg_add, ‚Üê toSignedMeasure_add, add_comm,
    ‚Üê sub_eq_add_neg]
  ¬∑ convert rfl
    ¬∑ exact s.toJordanDecomposition.posPart.haveLebesgueDecomposition_add Œº
    ¬∑ rw [add_comm]
      exact s.toJordanDecomposition.negPart.haveLebesgueDecomposition_add Œº
  all_goals
    first
    | exact (lintegral_rnDeriv_lt_top _ _).ne
    | measurability",":= by
  conv_rhs =>
    rw [‚Üê toSignedMeasure_toJordanDecomposition s, JordanDecomposition.toSignedMeasure]
  rw [singularPart, rnDeriv,
    withDensity·µ•_sub' (integrable_toReal_of_lintegral_ne_top _ _)
      (integrable_toReal_of_lintegral_ne_top _ _),
    withDensity·µ•_toReal, withDensity·µ•_toReal, sub_eq_add_neg, sub_eq_add_neg,
    add_comm (s.toJordanDecomposition.posPart.singularPart Œº).toSignedMeasure, ‚Üê add_assoc,
    add_assoc (-(s.toJordanDecomposition.negPart.singularPart Œº).toSignedMeasure),
    ‚Üê toSignedMeasure_add, add_comm, ‚Üê add_assoc, ‚Üê neg_add, ‚Üê toSignedMeasure_add, add_comm,
    ‚Üê sub_eq_add_neg]
  convert rfl
  ¬∑ exact s.toJordanDecomposition.posPart.haveLebesgueDecomposition_add Œº
  ¬∑ rw [add_comm]
    exact s.toJordanDecomposition.negPart.haveLebesgueDecomposition_add Œº
  all_goals
    first
    | exact (lintegral_rnDeriv_lt_top _ _).ne
    | measurability"
Mathlib/Topology/Metrizable/Urysohn.lean,TopologicalSpace.exists_inducing_l_infty,exists_inducing_l_infty,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono (inter_subset_left _ _)).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine' ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, _‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine' ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm _ _‚ü©
  ¬∑ refine' (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => _
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine' (eventually_all_finite h_fin).2 fun UV _ => _
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => ?_
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine' ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 _
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => ?_‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _","error:  function expected at
  inter_subset_left ?m.504
term has type
  ?m.503 ‚àà ?m.501","theorem exists_inducing_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Inducing f ",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => ?_
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => ?_‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.isometry_extend (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le,norm_volume_sub_integral_face_upper_sub_lower_smul_le,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
      ¬∑ intro y hy
        refine' (hŒµ y hy).trans (mul_le_mul_of_nonneg_left _ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.bounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(¬∑ ‚àò ¬∑), Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine' norm_integral_le_of_le_const (fun y hy => (this y hy).trans _) volume
      rw [mul_assoc (2 * Œµ)]
      exact mul_le_mul_of_nonneg_left (I.diam_Icc_le_of_distortion_le i hc)
        (mul_nonneg zero_le_two h0.le)
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case convert_2
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
y : Fin n ‚Üí ‚Ñù
hy : y ‚àà Box.Icc (I.face i)
g : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
hfc : ContinuousOn (fun y ‚Ü¶ a + f' (y - x) + g y) (Box.Icc I)
Hi :
  ‚àÄ x_1 ‚àà Set.Icc (I.lower i) (I.upper i),
    Integrable (I.face i) ‚ä• ((fun y ‚Ü¶ a + f' (y - x) + g y) ‚àò e x_1) BoxAdditiveMap.volume
hg : g = fun y ‚Ü¶ (fun y ‚Ü¶ a + f' (y - x) + g y) y - a - f' (y - x)
this : ‚àÄ z ‚àà Set.Icc (I.lower i) (I.upper i), e z y ‚àà Box.Icc I
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
error:  unsolved goals
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
hfc : ContinuousOn f (Box.Icc I)
x : Fin (n + 1) ‚Üí ‚Ñù
hxI : x ‚àà Box.Icc I
a : E
Œµ : ‚Ñù
h0 : 0 < Œµ
hŒµ : ‚àÄ y ‚àà Box.Icc I, ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ
c : ‚Ñù‚â•0
hc : I.distortion ‚â§ c
e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := i.insertNth
Hl : I.lower i ‚àà Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i ‚àà Set.Icc (I.lower i) (I.upper i)
Hi : ‚àÄ x ‚àà Set.Icc (I.lower i) (I.upper i), Integrable (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume
this :
  ‚àÄ y ‚àà Box.Icc (I.face i),
    ‚Äñf' (Pi.single i (I.upper i - I.lower i)) - (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§ 2 * Œµ * diam (Box.Icc I)
‚ä¢ ‚Äñ(‚àè j : Fin (n + 1), (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
        (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
          integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ ‚â§
    2 * Œµ * ‚Üëc * ‚àè j : Fin (n + 1), (I.upper j - I.lower j)","theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E}
    {f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) ‚Üí ‚Ñù}
    (hxI : x ‚àà (Box.Icc I)) {a : E} {Œµ : ‚Ñù} (h0 : 0 < Œµ)
    (hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ) {c : ‚Ñù‚â•0}
    (hc : I.distortion ‚â§ c) :
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
      (integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.lower i))
          BoxAdditiveMap.volume)‚Äñ ‚â§
      2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) ",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ‚àÄ y ‚àà Box.Icc (I.face i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I) := by
        intro y hy
        refine (hŒµ y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [‚Üê dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))
  calc
    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -
            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =
        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•
            (fun x : Fin n ‚Üí ‚Ñù =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‚Äñ := by
      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,
        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,
        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(¬∑ ‚àò ¬∑), Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]
    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * Œµ)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by
      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]
      ac_rfl",":= by
  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)
  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),
      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§
        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _
    ¬∑ congr 1
      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) (I.lower i) y
      simp only [‚Üê this, f'.map_sub]; abel
    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e "
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.null_of_frequently_le_of_frequently_ge,null_of_frequently_le_of_frequently_ge,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ‚ü®o, xo, o_open, Œºo‚ü© : ‚àÉ o : Set Œ±, x ‚àà o ‚àß IsOpen o ‚àß Œº o < ‚àû :=
    Measure.exists_isOpen_measure_lt_top Œº x
  refine ‚ü®s ‚à© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_‚ü©
  let s' := s ‚à© o
  by_contra h
  apply lt_irrefl (œÅ s')
  calc
    œÅ s' ‚â§ c * Œº s' := v.measure_le_of_frequently_le (c ‚Ä¢ Œº) hœÅ s' fun x hx => hc x hx.1
    _ < d * Œº s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono (inter_subset_right _ _)) Œºo).ne
    _ ‚â§ œÅ s' :=
      v.measure_le_of_frequently_le œÅ ((Measure.AbsolutelyContinuous.refl Œº).smul d) s' fun x hx =>
        hd x hx.1","error:  function expected at
  inter_subset_right ?m.58097
term has type
  ?m.58096 ‚àà ?m.58095","theorem null_of_frequently_le_of_frequently_ge {c d : ‚Ñù‚â•0} (hcd : c < d) (s : Set Œ±)
    (hc : ‚àÄ x ‚àà s, ‚àÉ·∂† a in v.filterAt x, œÅ a ‚â§ c * Œº a)
    (hd : ‚àÄ x ‚àà s, ‚àÉ·∂† a in v.filterAt x, (d : ‚Ñù‚â•0‚àû) * Œº a ‚â§ œÅ a) : Œº s = 0 ",":= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ‚ü®o, xo, o_open, Œºo‚ü© : ‚àÉ o : Set Œ±, x ‚àà o ‚àß IsOpen o ‚àß Œº o < ‚àû :=
    Measure.exists_isOpen_measure_lt_top Œº x
  refine ‚ü®s ‚à© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_‚ü©
  let s' := s ‚à© o
  by_contra h
  apply lt_irrefl (œÅ s')
  calc
    œÅ s' ‚â§ c * Œº s' := v.measure_le_of_frequently_le (c ‚Ä¢ Œº) hœÅ s' fun x hx => hc x hx.1
    _ < d * Œº s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono inter_subset_right) Œºo).ne
    _ ‚â§ œÅ s' :=
      v.measure_le_of_frequently_le œÅ ((Measure.AbsolutelyContinuous.refl Œº).smul d) s' fun x hx =>
        hd x hx.1",":= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ‚ü®o, xo, o_open, Œºo‚ü© : ‚àÉ o : Set Œ±, x ‚àà o ‚àß IsOpen o ‚àß Œº o < ‚àû :=
    Measure.exists_isOpen_measure_lt_top Œº x
  refine ‚ü®s ‚à© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_‚ü©
  let s' := s ‚à© o
  by_contra h
  apply lt_irrefl (œÅ s')
  calc
    œÅ s' ‚â§ c * Œº s' := v.measure_le_of_frequently_le (c ‚Ä¢ Œº) hœÅ s' fun x hx => hc x hx.1
    _ < d * Œº s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt inter_subset_right) Œºo).ne
    _ ‚â§ œÅ s' :=
      v.measure_le_of_frequently_le œÅ ((Measure.AbsolutelyContinuous.refl Œº).smul d) s' fun x hx =>
        hd x hx.1"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Œµ hŒµ).mono fun y hy => _
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_op_norm (n.2 - x)",error:  unexpected token ';'; expected '|',"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tend"
Mathlib/Topology/UniformSpace/Compact.lean,nhdsSet_diagonal_eq_uniformity,nhdsSet_diagonal_eq_uniformity,481b74fd30711d0cf0727798094b6f44f65e6b0f,":= by
  refine' nhdsSet_diagonal_le_uniformity.antisymm _
  have :
    (ùì§ (Œ± √ó Œ±)).HasBasis (fun U => U ‚àà ùì§ Œ±) fun U =>
      (fun p : (Œ± √ó Œ±) √ó Œ± √ó Œ± => ((p.1.1, p.2.1), p.1.2, p.2.2)) ‚Åª¬π' U √óÀ¢ U :=
    by
    rw [uniformity_prod_eq_comap_prod]
    exact (ùì§ Œ±).basis_sets.prod_self.comap _
  refine' (isCompact_diagonal.nhdsSet_basis_uniformity this).ge_iff.2 fun U hU => _
  exact mem_of_superset hU fun ‚ü®x, y‚ü© hxy => mem_union·µ¢‚ÇÇ.2
    ‚ü®(x, x), rfl, refl_mem_uniformity hU, hxy‚ü©",error:  unknown identifier 'mem_union·µ¢‚ÇÇ',theorem nhdsSet_diagonal_eq_uniformity [CompactSpace Œ±] : ùìùÀ¢ (diagonal Œ±) = ùì§ Œ± ,":= by
  refine nhdsSet_diagonal_le_uniformity.antisymm ?_
  have :
    (ùì§ (Œ± √ó Œ±)).HasBasis (fun U => U ‚àà ùì§ Œ±) fun U =>
      (fun p : (Œ± √ó Œ±) √ó Œ± √ó Œ± => ((p.1.1, p.2.1), p.1.2, p.2.2)) ‚Åª¬π' U √óÀ¢ U := by
    rw [uniformity_prod_eq_comap_prod]
    exact (ùì§ Œ±).basis_sets.prod_self.comap _
  refine (isCompact_diagonal.nhdsSet_basis_uniformity this).ge_iff.2 fun U hU => ?_
  exact mem_of_superset hU fun ‚ü®x, y‚ü© hxy => mem_iUnion‚ÇÇ.2
    ‚ü®(x, x), rfl, refl_mem_uniformity hU, hxy‚ü©",":= by
  refine nhdsSet_diagonal_le_uniformity.antisymm ?_
  have :
    (ùì§ (Œ± √ó Œ±)).HasBasis (fun U => U ‚àà ùì§ Œ±) fun U =>
      (fun p : (Œ± √ó Œ±) √ó Œ± √ó Œ± => ((p.1.1, p.2.1), p.1.2, p.2.2)) ‚Åª¬π' U √óÀ¢ U :=
    by
    rw [uniformity_prod_eq_comap_prod]
    exact (ùì§ Œ±).basis_sets.prod_self.comap _
  refine (isCompact_diagonal.nhdsSet_basis_uniformity this).ge_iff.2 fun U hU => ?_
  exact mem_of_superset hU fun ‚ü®x, y‚ü© hxy => mem_union·µ¢‚ÇÇ.2
    ‚ü®(x, x), rfl, refl_mem_uniformity hU, hxy‚ü©"
Mathlib/Order/Heyting/Basic.lean,LE.le.disjoint_compl_right,LE.le.disjoint_compl_right,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":=
  disjoint_compl_right.mono_left h","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  disjoint_compl_right
has type
  a ‚â§ b ‚Üí Disjoint a b·∂ú",theorem LE.le.disjoint_compl_right (h : a ‚â§ b) : Disjoint a b·∂ú ,":=
  _root_.disjoint_compl_right.mono_left h",":=
  disjoint_compl_right.mono_left"
Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean,CochainComplex.HomComplex.Œ¥_map,Œ¥_map,711caa31c35612f144d606cbe322e50891d53146,":= by
  by_cases hnm : n + 1 = m
  . ext p q hpq
    dsimp
    simp only [Œ¥_v n m hnm _ p q hpq (q-1) (p+1) rfl rfl,
      Functor.map_add, Functor.map_comp, Functor.map_zsmul,
      Cochain.map_v, Functor.mapHomologicalComplex_obj_d]
  . simp only [Œ¥_shape _ _ hnm, Cochain.map_zero]","error:  unsolved goals
case pos.h
C : Type u
inst‚úù‚Å∂ : Category.{v, u} C
inst‚úù‚Åµ : Preadditive C
R : Type u_1
inst‚úù‚Å¥ : Ring R
inst‚úù¬≥ : Linear R C
F G K L : CochainComplex C ‚Ñ§
n m : ‚Ñ§
D : Type u_2
inst‚úù¬≤ : Category.{u_3, u_2} D
inst‚úù¬π : Preadditive D
z z' : Cochain K L n
f : K ‚ü∂ L
Œ¶ : C ‚•§ D
inst‚úù : Œ¶.Additive
hnm : n + 1 = m
p q : ‚Ñ§
hpq : p + m = q
‚ä¢ Œ¶.map (z.v p (q - 1) ‚ãØ) ‚â´ Œ¶.map (L.d (q - 1) q) + m.negOnePow ‚Ä¢ Œ¶.map (K.d p (p + 1)) ‚â´ Œ¶.map (z.v (p + 1) q ‚ãØ) =
    Œ¶.map (z.v p (q - 1) ‚ãØ) ‚â´ Œ¶.map (L.d (q - 1) q) + Œ¶.map (m.negOnePow ‚Ä¢ K.d p (p + 1) ‚â´ z.v (p + 1) q ‚ãØ)",lemma Œ¥_map : Œ¥ n m (z.map Œ¶) = (Œ¥ n m z).map Œ¶ ,":= by
  by_cases hnm : n + 1 = m
  ¬∑ ext p q hpq
    dsimp
    simp only [Œ¥_v n m hnm _ p q hpq (q-1) (p+1) rfl rfl,
      Functor.map_add, Functor.map_comp, Functor.map_units_smul,
      Cochain.map_v, Functor.mapHomologicalComplex_obj_d]
  ¬∑ simp only [Œ¥_shape _ _ hnm, Cochain.map_zero]",":= by
  by_cases hnm : n + 1 = m
  ¬∑ ext p q hpq
    dsimp
    simp only [Œ¥_v n m hnm _ p q hpq (q-1) (p+1) rfl rfl,
      Functor.map_add, Functor.map_comp, Functor.map_zsmul,
      Cochain.map_v, Functor.mapHomologicalComplex_obj_d]
    simp only [Œ¥_shape _ _ hnm, Cochain.map_zero]"
Mathlib/CategoryTheory/Abelian/RightDerived.lean,CategoryTheory.Functor.rightDerived_map_eq,Functor.rightDerived_map_eq,9072ff84a0d139a344bf9eed4a00c4cd27596c79,":= by
  rw [‚Üê cancel_mono (Q.isoRightDerivedObj F n).hom,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,","error:  unexpected token 'noncomputable'; expected ']'
error:  unsolved goals
C : Type u
inst‚úù‚Åµ : Category.{v, u} C
D : Type u_1
inst‚úù‚Å¥ : Category.{u_2, u_1} D
inst‚úù¬≥ : Abelian C
inst‚úù¬≤ : HasInjectiveResolutions C
inst‚úù¬π : Abelian D
F : C ‚•§ D
inst‚úù : F.Additive
n : ‚Ñï
X Y : C
f : X ‚ü∂ Y
P : InjectiveResolution X
Q : InjectiveResolution Y
g : P.cocomplex ‚ü∂ Q.cocomplex
w : P.Œπ ‚â´ g = (CochainComplex.single‚ÇÄ C).map f ‚â´ Q.Œπ
‚ä¢ (P.isoRightDerivedObj F n).hom ‚â´
      (F.mapHomologicalComplex (ComplexShape.up ‚Ñï) ‚ãô HomologicalComplex.homologyFunctor D (ComplexShape.up ‚Ñï) n).map g =
    ((P.isoRightDerivedObj F n).hom ‚â´
        (F.mapHomologicalComplex (ComplexShape.up ‚Ñï) ‚ãô HomologicalComplex.homologyFunctor D (ComplexShape.up ‚Ñï) n).map
            g ‚â´
          (Q.isoRightDerivedObj F n).inv) ‚â´
      (Q.isoRightDerivedObj F n).hom

C : Type u
inst‚úù‚Åµ : Category.{v, u} C
D : Type u_1
inst‚úù‚Å¥ : Category.{u_2, u_1} D
inst‚úù¬≥ : Abelian C
inst‚úù¬≤ : HasInjectiveResolutions C
inst‚úù¬π : Abelian D
F : C ‚•§ D
inst‚úù : F.Additive
n : ‚Ñï
X Y : C
f : X ‚ü∂ Y
P : InjectiveResolution X
Q : InjectiveResolution Y
g : P.cocomplex ‚ü∂ Q.cocomplex
w : P.Œπ ‚â´ g = (CochainComplex.single‚ÇÄ C).map f ‚â´ Q.Œπ
‚ä¢ P.Œπ.f 0 ‚â´ g.f 0 = f ‚â´ Q.Œπ.f 0","theorem Functor.rightDerived_map_eq (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) {X Y : C} (f : X ‚ü∂ Y)
    {P : InjectiveResolution X} {Q : InjectiveResolution Y} (g : P.cocomplex ‚ü∂ Q.cocomplex)
    (w : P.Œπ ‚â´ g = (CochainComplex.single‚ÇÄ C).map f ‚â´ Q.Œπ) :
    (F.rightDerived n).map f =
      (P.isoRightDerivedObj F n).hom ‚â´
        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map g ‚â´
          (Q.isoRightDerivedObj F n).inv ",":= by
  rw [‚Üê cancel_mono (Q.isoRightDerivedObj F n).hom,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    assoc, assoc, Iso.inv_hom_id, comp_id]
  rw [‚Üê HomologicalComplex.comp_f, w, HomologicalComplex.comp_f,
    CochainComplex.single‚ÇÄ_map_f_zero]",":= by
  rw [‚Üê cancel_mono (Q.isoRightDerivedObj F n).hom,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n]"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Œµ hŒµ).mono fun y hy => _
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  simp made no progress
warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metri"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,2ba547a6481ef513d87a606a16c441262be9e648,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  simp made no progress
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff]"
Mathlib/Computability/TMToPartrec.lean,Turing.PartrecToTM2.tr_ret_respects,tr_ret_respects,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  induction k generalizing v s with
  | halt => exact ‚ü®_, rfl, TransGen.single rfl‚ü©
  | cons‚ÇÅ fs as k _ =>
    obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := trNormal_respects fs (Cont.cons‚ÇÇ v k) as none
    refine ‚ü®s', h‚ÇÅ, TransGen.head rfl ?_‚ü©; simp
    refine (move‚ÇÇ_ok (by decide) ?_ (splitAtPred_false _)).trans ?_; ¬∑ rfl
    simp only [TM2.step, Option.mem_def, Option.elim, id_eq, elim_update_main, elim_main, elim_aux,
      List.append_nil, elim_update_aux]
    refine (move‚ÇÇ_ok (by decide) ?_ ?_).trans ?_
    pick_goal 4
    ¬∑ rfl
    pick_goal 4
    ¬∑ exact
        splitAtPred_eq _ _ _ (some Œì'.cons‚Çó) _
          (fun x h => Bool.decide_false (trList_ne_cons‚Çó _ _ h)) ‚ü®rfl, rfl‚ü©
    refine (move‚ÇÇ_ok (by decide) ?_ (splitAtPred_false _)).trans ?_; ¬∑ rfl
    simp only [TM2.step, Option.mem_def, Option.elim, elim_update_stack, elim_main,
      List.append_nil, elim_update_main,  id_eq, elim_update_aux, ne_eq, Function.update_noteq,
      elim_aux, elim_stack]
    exact h‚ÇÇ
  | cons‚ÇÇ ns k IH =>
    obtain ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü© := IH (ns.headI :: v) none
    exact ‚ü®c, h‚ÇÅ, TransGen.head rfl <| head_stack_ok.trans h‚ÇÇ‚ü©
  | comp f k _ =>
    obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := trNormal_respects f k v s
    exact ‚ü®_, h‚ÇÅ, TransGen.head rfl h‚ÇÇ‚ü©
  | fix f k IH =>
    rw [stepRet]
    have :
      if v.headI = 0 then natEnd (trList v).head?.iget = true ‚àß (trList v).tail = trList v.tail
      else
        natEnd (trList v).head?.iget = false ‚àß
          (trList v).tail = (trNat v.headI).tail ++ Œì'.cons :: trList v.tail := by
      cases' v with n
      ¬∑ exact ‚ü®rfl, rfl‚ü©
      cases' n with n
      ¬∑ simp
      rw [trList, List.headI, trNat, Nat.cast_succ, Num.add_one, Num.succ, List.tail]
      cases (n : Num).succ' <;> exact ‚ü®rfl, rfl‚ü©
    by_cases h : v.headI = 0 <;> simp only [h, ite_true, ite_false] at this ‚ä¢
    ¬∑ obtain ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü© := IH v.tail (trList v).head?
      refine ‚ü®c, h‚ÇÅ, TransGen.head rfl ?_‚ü©
      simp only [Option.mem_def, TM2.stepAux, trContStack, contStack, elim_main, this, cond_true,
        elim_update_main]
      exact h‚ÇÇ
    ¬∑ obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := trNormal_respects f (Cont.fix f k) v.tail (some Œì'.cons)
      refine ‚ü®_, h‚ÇÅ, TransGen.head rfl <| TransGen.trans ?_ h‚ÇÇ‚ü©
      simp only [Option.mem_def, TM2.stepAux, elim_main, this.1, cond_false, elim_update_main,
        trCont]
      convert clear_ok (splitAtPred_eq _ _ (trNat v.headI).tail (some Œì'.cons) _ _ _) using 2
      ¬∑ simp
        convert rfl
      ¬∑ exact fun x h => trNat_natEnd _ _ (List.tail_subset _ h)
      ¬∑ exact ‚ü®rfl, this.2‚ü©","error:  don't know how to synthesize implicit argument 'b'
  @TransGen.trans (TM2.Cfg (fun x ‚Ü¶ Œì') Œõ' (Option Œì')) (fun a b ‚Ü¶ b ‚àà TM2.step tr a)
    {
      l :=
        some
          (move‚ÇÇ (fun s ‚Ü¶ decide (s = Œì'.cons‚Çó)) stack main
            (move‚ÇÇ (fun x ‚Ü¶ false) aux stack (trNormal fs (trCont k).cons‚ÇÇ))),
      var := none, stk := elim [] [] (trList v) (trContStack (Cont.cons‚ÇÅ fs as k)) }
    { l := some (move‚ÇÇ (fun x ‚Ü¶ false) aux stack (trNormal fs (trCont k).cons‚ÇÇ)), var := none,
      stk :=
        update
          (update (elim [] [] (trList v) (trContStack (Cont.cons‚ÇÅ fs as k))) stack
            (?m.296335.elim id List.cons ?m.296336))
          main (?m.296334 ++ elim [] [] (trList v) (trContStack (Cont.cons‚ÇÅ fs as k)) main) }
    s' (move‚ÇÇ_ok (of_decide_eq_true (Eq.refl true)) ?m.296339 ?m.296340) ?m.296356
context:
fs : Code
as : List ‚Ñï
k : Cont
a_ih‚úù :
  ‚àÄ (v : List ‚Ñï) (s : Option Œì'),
    ‚àÉ b‚ÇÇ,
      TrCfg (stepRet k v) b‚ÇÇ ‚àß
        Reaches‚ÇÅ (TM2.step tr) { l := some (Œõ'.ret (trCont k)), var := s, stk := elim (trList v) [] [] (trContStack k) }
          b‚ÇÇ
v : List ‚Ñï
s : Option Œì'
s' : Cfg'
h‚ÇÅ : TrCfg (stepNormal fs (Cont.cons‚ÇÇ v k) as) s'
h‚ÇÇ :
  Reaches‚ÇÅ (TM2.step tr)
    { l := some (trNormal fs (trCont (Cont.cons‚ÇÇ v k))), var := none,
      stk := elim (trList as) [] [] (trContStack (Cont.cons‚ÇÇ v k)) }
    s'
‚ä¢ TM2.Cfg (fun x ‚Ü¶ Œì') Œõ' (Option Œì')
error:  don't know how to synthesize implicit argument 'L‚ÇÇ'
  @move‚ÇÇ_ok (fun s ‚Ü¶ decide (s = Œì'.cons‚Çó)) stack main (move‚ÇÇ (fun x ‚Ü¶ false) aux stack (trNormal fs (trCont k).cons‚ÇÇ))
    none ?m.296334 ?m.296335 ?m.296336 (elim [] [] (trList v) (trContStack (Cont.cons‚ÇÅ fs as k)))
    (of_decide_eq_true (Eq.refl true)) ?m.296339 ?m.296340
context:
fs : Code
as : List ‚Ñï
k : Cont
a_ih‚úù :
  ‚àÄ (v : List ‚Ñï) (s : Option Œì'),
    ‚àÉ b‚ÇÇ,
      TrCfg (stepRet k v) b‚ÇÇ ‚àß
        Reaches‚ÇÅ (TM2.step tr) { l := some (Œõ'.ret (trCont k)), var := s, stk := elim (trList v) [] [] (trContStack k) }
          b‚ÇÇ
v : List ‚Ñï
s : Option Œì'
s' : Cfg'
h‚ÇÅ : TrCfg (stepNormal fs (Cont.cons‚ÇÇ v k) as) s'
h‚ÇÇ :
  Reaches‚ÇÅ (TM2.step tr)
    { l := some (trNormal fs (trCont (Cont.cons‚ÇÇ v k))), var := none,
      stk := elim (trList as) [] [] (trContStack (Cont.cons‚ÇÇ v k)) }
    s'
‚ä¢ List Œì'
error:  don't know how to synthesize implicit argument 'o'
  @move‚ÇÇ_ok (fun s ‚Ü¶ decide (s = Œì'.cons‚Çó)) stack main (move‚ÇÇ (fun x ‚Ü¶ false) aux stack (trNormal fs (trCont k).cons‚ÇÇ))
    none ?m.296334 ?m.296335 ?m.296336 (elim [] [] (trList v) (trContStack (Cont.cons‚ÇÅ fs as k)))
    (of_decide_eq_true (Eq.refl true)) ?m.296339 ?m.296340
context:
fs : Code
as : List ‚Ñï
k : Cont
a_ih‚úù :
  ‚àÄ (v : List ‚Ñï) (s : Option Œì'),
    ‚àÉ b‚ÇÇ,
      TrCfg (stepRet k v) b‚ÇÇ ‚àß
        Reaches‚ÇÅ (TM2.step tr) { l := some (Œõ'.ret (trCont k)), var := s, stk := elim (trList v) [] [] (trContStack k) }
          b‚ÇÇ
v : List ‚Ñï
s : Option Œì'
s' : Cfg'
h‚ÇÅ : TrCfg (stepNormal fs (Cont.cons‚ÇÇ v k) as) s'
h‚ÇÇ :
  Reaches‚ÇÅ (TM2.step tr)
    { l := some (trNormal fs (trCont (Cont.cons‚ÇÇ v k))), var := none,
      stk := elim (trList as) [] [] (trContStack (Cont.cons‚ÇÇ v k)) }
    s'
‚ä¢ Option Œì'
error:  don't know how to synthesize implicit argument 'L‚ÇÅ'
  @move‚ÇÇ_ok (fun s ‚Ü¶ decide (s = Œì'.cons‚Çó)) stack main (move‚ÇÇ (fun x ‚Ü¶ false) aux stack (trNormal fs (trCont k).cons‚ÇÇ))
    none ?m.296334 ?m.296335 ?m.296336 (elim [] [] (trList v) (trContStack (Cont.cons‚ÇÅ fs as k)))
    (of_decide_eq_true (Eq.refl true)) ?m.296339 ?m.296340
context:
fs : Code
as : List ‚Ñï
k : Cont
a_ih‚úù :
  ‚àÄ (v : List ‚Ñï) (s : Option Œì'),
    ‚àÉ b‚ÇÇ,
      TrCfg (stepRet k v) b‚ÇÇ ‚àß
        Reaches‚ÇÅ (TM2.step tr) { l := some (Œõ'.ret (trCont k)), var := s, stk := elim (trList v) [] [] (trContStack k) }
          b‚ÇÇ
v : List ‚Ñï
s : Option Œì'
s' : Cfg'
h‚ÇÅ : TrCfg (stepNormal fs (Cont.cons‚ÇÇ v k) as) s'
h‚ÇÇ :
  Reaches‚ÇÅ (TM2.step tr)
    { l := some (trNormal fs (trCont (Cont.cons‚ÇÇ v k))), var := none,
      stk := elim (trList as) [] [] (trContStack (Cont.cons‚ÇÇ v k)) }
    s'
‚ä¢ List Œì'","theorem tr_ret_respects (k v s) : ‚àÉ b‚ÇÇ,
    TrCfg (stepRet k v) b‚ÇÇ ‚àß
      Reaches‚ÇÅ (TM2.step tr)
        ‚ü®some (Œõ'.ret (trCont k)), s, K'.elim (trList v) [] [] (trContStack k)‚ü© b‚ÇÇ ",":= by
  induction k generalizing v s with
  | halt => exact ‚ü®_, rfl, TransGen.single rfl‚ü©
  | cons‚ÇÅ fs as k _ =>
    obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := trNormal_respects fs (Cont.cons‚ÇÇ v k) as none
    refine ‚ü®s', h‚ÇÅ, TransGen.head rfl ?_‚ü©; simp
    refine (move‚ÇÇ_ok (by decide) ?_ (splitAtPred_false _)).trans ?_; ¬∑ rfl
    simp only [TM2.step, Option.mem_def, Option.elim, id_eq, elim_update_main, elim_main, elim_aux,
      List.append_nil, elim_update_aux]
    refine (move‚ÇÇ_ok (L‚ÇÅ := ?_) (o := ?_) (L‚ÇÇ := ?_) (by decide) rfl ?_).trans ?_
    pick_goal 4
    ¬∑ exact splitAtPred_eq _ _ _ (some Œì'.cons‚Çó) _
        (fun x h => Bool.decide_false (trList_ne_cons‚Çó _ _ h)) ‚ü®rfl, rfl‚ü©
    refine (move‚ÇÇ_ok (by decide) ?_ (splitAtPred_false _)).trans ?_; ¬∑ rfl
    simp only [TM2.step, Option.mem_def, Option.elim, elim_update_stack, elim_main,
      List.append_nil, elim_update_main,  id_eq, elim_update_aux, ne_eq, Function.update_noteq,
      elim_aux, elim_stack]
    exact h‚ÇÇ
  | cons‚ÇÇ ns k IH =>
    obtain ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü© := IH (ns.headI :: v) none
    exact ‚ü®c, h‚ÇÅ, TransGen.head rfl <| head_stack_ok.trans h‚ÇÇ‚ü©
  | comp f k _ =>
    obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := trNormal_respects f k v s
    exact ‚ü®_, h‚ÇÅ, TransGen.head rfl h‚ÇÇ‚ü©
  | fix f k IH =>
    rw [stepRet]
    have :
      if v.headI = 0 then natEnd (trList v).head?.iget = true ‚àß (trList v).tail = trList v.tail
      else
        natEnd (trList v).head?.iget = false ‚àß
          (trList v).tail = (trNat v.headI).tail ++ Œì'.cons :: trList v.tail := by
      cases' v with n
      ¬∑ exact ‚ü®rfl, rfl‚ü©
      cases' n with n
      ¬∑ simp
      rw [trList, List.headI, trNat, Nat.cast_succ, Num.add_one, Num.succ, List.tail]
      cases (n : Num).succ' <;> exact ‚ü®rfl, rfl‚ü©
    by_cases h : v.headI = 0 <;> simp only [h, ite_true, ite_false] at this ‚ä¢
    ¬∑ obtain ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü© := IH v.tail (trList v).head?
      refine ‚ü®c, h‚ÇÅ, TransGen.head rfl ?_‚ü©
      simp only [Option.mem_def, TM2.stepAux, trContStack, contStack, elim_main, this, cond_true,
        elim_update_main]
      exact h‚ÇÇ
    ¬∑ obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := trNormal_respects f (Cont.fix f k) v.tail (some Œì'.cons)
      refine ‚ü®_, h‚ÇÅ, TransGen.head rfl <| TransGen.trans ?_ h‚ÇÇ‚ü©
      simp only [Option.mem_def, TM2.stepAux, elim_main, this.1, cond_false, elim_update_main,
        trCont]
      convert clear_ok (splitAtPred_eq _ _ (trNat v.headI).tail (some Œì'.cons) _ _ _) using 2
      ¬∑ simp
        convert rfl
      ¬∑ exact fun x h => trNat_natEnd _ _ (List.tail_subset _ h)
      ¬∑ exact ‚ü®rfl, this.2‚ü©",":= by
  induction k generalizing v s with
  | halt => exact ‚ü®_, rfl, TransGen.single rfl‚ü©
  | cons‚ÇÅ fs as k _ =>
    obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := trNormal_respects fs (Cont.cons‚ÇÇ v k) as none
    refine ‚ü®s', h‚ÇÅ, TransGen.head rfl ?_‚ü©; simp
    refine (move‚ÇÇ_ok (by decide) ?_ (splitAtPred_false _)).trans ?_; ¬∑ rfl
    simp only [TM2.step, Option.mem_def, Option.elim, id_eq, elim_update_main, elim_main, elim_aux,
      List.append_nil, elim_update_main, id_eq, elim_update_aux, ne_eq, Function.update_noteq,
      elim_aux, elim_stack]
    exact h‚ÇÇ
  | cons‚ÇÇ ns k IH =>
    obtain ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü© := IH (ns.headI :: v) none
    exact ‚ü®c, h‚ÇÅ, TransGen.head rfl <| head_stack_ok.trans h‚ÇÇ‚ü©
  | comp f k _ =>
    obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := trNormal_respects f k v s
    exact ‚ü®_, h‚ÇÅ, TransGen.head rfl h‚ÇÇ‚ü©
  | fix f k IH =>
    rw [stepRet]
    have :
      if v.headI = 0 then natEnd (trList v).head?.iget = true ‚àß (trList v).tail = trList v.tail
      else
        natEnd (trList v).head?.iget = false ‚àß
          (trList v).tail = (trNat v.headI).tail ++ Œì'.cons :: trList v.tail := by
      cases' v with n
      ¬∑ exact ‚ü®rfl, rfl‚ü©
      cases' n with n
      ¬∑ simp
      rw [trList, List.headI, trNat, Nat.cast_succ, Num.add_one, Num.succ, List.tail]
      cases (n : Num).succ' <;> exact ‚ü®rfl, rfl‚ü©
    by_cases h : v.headI = 0 <;> simp only [h, ite_true, ite_false] at this ‚ä¢
    ¬∑ obtain ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü© := IH v.tail (trList v).head?
      refine ‚ü®c, h‚ÇÅ, TransGen.head rfl ?_‚ü©
      simp only [Option.mem_def, TM2.stepAux, trContStack, contStack, elim_main, this, cond_true,
        elim_update_main]
      exact h‚ÇÇ
    ¬∑ obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := trNormal_respects f (Cont.fix f k) v.tail (some Œì'.cons)
      refine ‚ü®_, h‚ÇÅ, TransGen.head rfl <| TransGen.trans ?_ h‚ÇÇ‚ü©
      simp only [Option.mem_def, TM2.stepAux, elim_main, this, cond_true,
        elim_update_main]
      exact h‚ÇÇ
    ¬∑ obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := trNormal_respects f (Cont.fix f k) v.tail (some Œì'.cons)
      refine ‚ü®_, h‚ÇÅ, TransGen.head rfl <| TransGen.trans ?_ h‚ÇÇ‚ü©
      simp only [Option.mem_def, TM2.stepAux, elim_main, this, cond_true,
        elim_update_main]
      exact h‚ÇÇ
    ¬∑ obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := trNormal_respects f (Cont.fix f k) v.tail (some Œì'.cons)
      refine ‚ü®_, h‚ÇÅ, TransGen.head rfl <| TransGen.trans ?_ h‚ÇÇ‚ü©
      simp only [Option.mem_def, TM2.stepAux, elim_main, this, cond_true,
        elim_update_main]
      exact h‚ÇÇ
    "
Mathlib/RingTheory/Trace.lean,Algebra.trace_algebraMap,trace_algebraMap,8dba065d4a693e23ed06348923cd5effc765cb75,":= by
  haveI := Classical.decEq Œπ
  rw [trace_apply, LinearMap.trace_eq_matrix_trace R b, Matrix.trace]
  convert Finset.sum_const x
  simp only [AlgHom.commutes, toMatrix_algebraMap, diag_apply, Matrix.scalar_apply_eq]","error:  unknown constant 'Matrix.scalar_apply_eq'
error:  unsolved goals
case h.e'_2.a
R : Type u_1
S : Type u_2
T : Type u_3
inst‚úù‚Å∏ : CommRing R
inst‚úù‚Å∑ : CommRing S
inst‚úù‚Å∂ : CommRing T
inst‚úù‚Åµ : Algebra R S
inst‚úù‚Å¥ : Algebra R T
K : Type u_4
L : Type u_5
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
Œπ Œ∫ : Type w
inst‚úù : Fintype Œπ
b : Basis Œπ R S
x : R
this : DecidableEq Œπ
x‚úù : Œπ
a‚úù : x‚úù ‚àà Finset.univ
‚ä¢ (scalar Œπ) x x‚úù x‚úù = x",theorem trace_algebraMap_of_basis (x : R) : trace R S (algebraMap R S x) = Fintype.card Œπ ‚Ä¢ x ,":= by
  haveI := Classical.decEq Œπ
  rw [trace_apply, LinearMap.trace_eq_matrix_trace R b, Matrix.trace]
  convert Finset.sum_const x
  simp [-coe_lmul_eq_mul]",":= by
  have := Classical.decEq Œπ
  rw [trace_apply, LinearMap.trace_eq_matrix_trace R b, Matrix.trace]
  convert Finset.sum_const x
  simp only [AlgHom.commutes, toMatrix_algebraMap, diag_apply, Matrix.scalar_apply_eq]"
Mathlib/Order/WithBot.lean,WithTop.coe_le_coe,coe_le_coe,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  some_le_some",error:  unknown identifier 'some_le_some',theorem coe_le_coe : (a : WithBot Œ±) ‚â§ b ‚Üî a ‚â§ b ,":= by
  simp [LE.le]",":=
  some_le_coe"
Mathlib/RingTheory/RootsOfUnity/Basic.lean,IsPrimitiveRoot.nthRoots_one_eq_biUnion_primitiveRoots,nthRoots_one_eq_biUnion_primitiveRoots,0e2adf9b7dd1ae6f3701d440e18e7c1074937d0a,":= by
  symm
  apply Finset.eq_of_subset_of_card_le
  ¬∑ intro x
    simp only [nthRootsFinset, ‚Üê Multiset.toFinset_eq (nthRoots_nodup h), exists_prop,
      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,
      Nat.mem_divisors, and_true_iff, Ne.def, PNat.ne_zero, PNat.pos, not_false_iff]
    rintro ‚ü®a, ‚ü®d, hd‚ü©, ha‚ü©
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, MulZeroClass.zero_mul]
      exact n.ne_zero
    rw [mem_primitiveRoots hazero] at ha
    rw [hd, pow_mul, ha.pow_eq_one, one_pow]
  ¬∑ apply le_of_eq
    rw [h.card_nthRootsFinset, Finset.card_biUnion]
    ¬∑ nth_rw 1 [‚Üê Nat.sum_totient n]
      refine' sum_congr rfl _
      simp only [Nat.mem_divisors]
      rintro k ‚ü®‚ü®d, hd‚ü©, -‚ü©
      rw [mul_comm] at hd
      rw [(h.pow n.pos hd).card_primitiveRoots]
    ¬∑ intro i _ j _ hdiff
      exact disjoint hdiff","error:  application type mismatch
  Multiset.toFinset_eq (nthRoots_nodup h)
argument
  nthRoots_nodup h
has type
  ?m.275951 ‚â† 0 ‚Üí (nthRoots ‚Üën ?m.275951).Nodup : Prop
but is expected to have type
  ?m.275934.Nodup : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.276404 ‚Üí ?m.276404 ‚Üí Prop
error:  type mismatch
  PNat.ne_zero n
has type
  ‚Üën ‚â† 0 : Prop
but is expected to have type
  ‚Üën = 0 : Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  False
case h.intro.intro.intro
M : Type u_1
N : Type u_2
G : Type u_3
R : Type u_4
S : Type u_5
F : Type u_6
inst‚úù‚Å¥ : CommMonoid M
inst‚úù¬≥ : CommMonoid N
inst‚úù¬≤ : DivisionCommMonoid G
k l : ‚Ñï
inst‚úù¬π : CommRing R
Œ∂‚úù : RÀ£
h‚úù : IsPrimitiveRoot Œ∂‚úù k
inst‚úù : IsDomain R
Œ∂ : R
n : ‚Ñï+
h : IsPrimitiveRoot Œ∂ ‚Üën
x : R
a : ‚Ñï
ha : IsPrimitiveRoot x a
d : a ‚à£ ‚Üën
hd : ‚Üën ‚â† 0
hazero : 0 < a
‚ä¢ x ‚àà (nthRoots (‚Üën) 1).toFinset","theorem nthRoots_one_eq_biUnion_primitiveRoots' {Œ∂ : R} {n : ‚Ñï+} (h : IsPrimitiveRoot Œ∂ n) :
    nthRootsFinset n R = (Nat.divisors ‚Üën).biUnion fun i => primitiveRoots i R ",":= by
  symm
  apply Finset.eq_of_subset_of_card_le
  ¬∑ intro x
    simp only [nthRootsFinset, ‚Üê Multiset.toFinset_eq (nthRoots_one_nodup h), exists_prop,
      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,
      Nat.mem_divisors, and_true_iff, Ne, PNat.ne_zero, PNat.pos, not_false_iff]
    rintro ‚ü®a, ‚ü®d, hd‚ü©, ha‚ü©
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, zero_mul]
      exact n.ne_zero
    rw [mem_primitiveRoots hazero] at ha
    rw [hd, pow_mul, ha.pow_eq_one, one_pow]
  ¬∑ apply le_of_eq
    rw [h.card_nthRootsFinset, Finset.card_biUnion]
    ¬∑ nth_rw 1 [‚Üê Nat.sum_totient n]
      refine sum_congr rfl ?_
      simp only [Nat.mem_divisors]
      rintro k ‚ü®‚ü®d, hd‚ü©, -‚ü©
      rw [mul_comm] at hd
      rw [(h.pow n.pos hd).card_primitiveRoots]
    ¬∑ intro i _ j _ hdiff
      exact disjoint hdiff",":= by
  symm
  apply Finset.eq_of_subset_of_card_le
  ¬∑ intro x
    simp only [nthRootsFinset, ‚Üê Multiset.toFinset_eq (nthRoots_nodup h), exists_prop,
      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,
      Nat.mem_divisors, and_true_iff, Ne, PNat.ne_zero, PNat.pos, not_false_iff]
    rintro ‚ü®a, ‚ü®d, hd‚ü©, ha‚ü©
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, MulZeroClass.zero_mul]
      exact n.ne_zero
    rw [mem_primitiveRoots hazero] at ha
    rw [hd, pow_mul, ha.pow_eq_one, one_pow]
  ¬∑ apply le_of_eq
    rw [h.card_nthRootsFinset, Finset.card_biUnion]
    ¬∑ nth_rw 1 [‚Üê Nat.sum_totient n]
      refine sum_congr rfl ?_
      simp only [Nat.mem_divisors]
      rintro k ‚ü®‚ü®d, hd‚ü©, -‚ü©
      rw [mul_comm] at hd
      rw [(h.pow n.pos hd).card_primitiveRoots]
    ¬∑ intro i _ j _ hdiff
      exact disjoint hdiff"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.OuterMeasure.mkMetric_mono_smul,mkMetric_mono_smul,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  classical
  rcases (mem_nhdsWithin_Ici_iff_exists_Ico_subset' zero_lt_one).1 hle with ‚ü®r, hr0, hr‚ü©
  refine fun s =>
    le_of_tendsto_of_tendsto (mkMetric'.tendsto_pre _ s)
      (ENNReal.Tendsto.const_mul (mkMetric'.tendsto_pre _ s) (Or.inr hc))
      (mem_of_superset (Ioo_mem_nhdsWithin_Ioi ‚ü®le_rfl, hr0‚ü©) fun r' hr' => _)
  simp only [mem_setOf_eq, mkMetric'.pre, RingHom.id_apply]
  rw [‚Üê smul_eq_mul, ‚Üê smul_apply, smul_boundedBy hc]
  refine le_boundedBy.2 (fun t => (boundedBy_le _).trans _) _
  simp only [smul_eq_mul, Pi.smul_apply, extend, iInf_eq_if]
  split_ifs with ht
  ¬∑ apply hr
    exact ‚ü®zero_le _, ht.trans_lt hr'.2‚ü©
  ¬∑ simp [h0]","error:  don't know how to synthesize placeholder
context:
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬π : EMetricSpace X
inst‚úù : EMetricSpace Y
m‚ÇÅ m‚ÇÇ : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû
c : ‚Ñù‚â•0‚àû
hc : c ‚â† ‚ä§
h0 : c ‚â† 0
hle : m‚ÇÅ ‚â§·∂†[ùìù[‚â•] 0] c ‚Ä¢ m‚ÇÇ
r : ‚Ñù‚â•0‚àû
hr0 : r ‚àà Ioi 0
hr : Ico 0 r ‚äÜ {x | (fun x ‚Ü¶ m‚ÇÅ x ‚â§ (c ‚Ä¢ m‚ÇÇ) x) x}
s : Set X
r' : ‚Ñù‚â•0‚àû
hr' : r' ‚àà Ioo 0 r
‚ä¢ r' ‚àà
    {x |
      (fun x ‚Ü¶
          (fun r ‚Ü¶ (mkMetric'.pre (fun s ‚Ü¶ m‚ÇÅ (diam s)) r) s) x ‚â§
            (fun b ‚Ü¶ c * (mkMetric'.pre (fun s ‚Ü¶ m‚ÇÇ (diam s)) b) s) x)
        x}
error:  unsolved goals
case intro.intro
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬π : EMetricSpace X
inst‚úù : EMetricSpace Y
m‚ÇÅ m‚ÇÇ : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû
c : ‚Ñù‚â•0‚àû
hc : c ‚â† ‚ä§
h0 : c ‚â† 0
hle : m‚ÇÅ ‚â§·∂†[ùìù[‚â•] 0] c ‚Ä¢ m‚ÇÇ
r : ‚Ñù‚â•0‚àû
hr0 : r ‚àà Ioi 0
hr : Ico 0 r ‚äÜ {x | (fun x ‚Ü¶ m‚ÇÅ x ‚â§ (c ‚Ä¢ m‚ÇÇ) x) x}
‚ä¢ mkMetric m‚ÇÅ ‚â§ c ‚Ä¢ mkMetric m‚ÇÇ","theorem mkMetric_mono_smul {m‚ÇÅ m‚ÇÇ : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû} {c : ‚Ñù‚â•0‚àû} (hc : c ‚â† ‚àû) (h0 : c ‚â† 0)
    (hle : m‚ÇÅ ‚â§·∂†[ùìù[‚â•] 0] c ‚Ä¢ m‚ÇÇ) : (mkMetric m‚ÇÅ : OuterMeasure X) ‚â§ c ‚Ä¢ mkMetric m‚ÇÇ ",":= by
  classical
  rcases (mem_nhdsWithin_Ici_iff_exists_Ico_subset' zero_lt_one).1 hle with ‚ü®r, hr0, hr‚ü©
  refine fun s =>
    le_of_tendsto_of_tendsto (mkMetric'.tendsto_pre _ s)
      (ENNReal.Tendsto.const_mul (mkMetric'.tendsto_pre _ s) (Or.inr hc))
      (mem_of_superset (Ioo_mem_nhdsWithin_Ioi ‚ü®le_rfl, hr0‚ü©) fun r' hr' => ?_)
  simp only [mem_setOf_eq, mkMetric'.pre, RingHom.id_apply]
  rw [‚Üê smul_eq_mul, ‚Üê smul_apply, smul_boundedBy hc]
  refine le_boundedBy.2 (fun t => (boundedBy_le _).trans ?_) _
  simp only [smul_eq_mul, Pi.smul_apply, extend, iInf_eq_if]
  split_ifs with ht
  ¬∑ apply hr
    exact ‚ü®zero_le _, ht.trans_lt hr'.2‚ü©
  ¬∑ simp [h0]",":= by
  classical
  rcases (mem_nhdsWithin_Ici_iff_exists_Ico_subset' zero_lt_one).1 hle with ‚ü®r, hr0, hr‚ü©
  refine fun s =>
    le_of_tendsto_of_tendsto (mkMetric'.tendsto_pre _ s)
      (ENNReal.Tendsto.const_mul (mkMetric'.tendsto_pre _ s) (Or.inr hc))
      (mem_of_superset (Ioo_mem_nhdsWithin_Ioi ‚ü®le_rfl, hr0‚ü©) fun r' hr' => ?_)
  simp only [mem_setOf_eq, mkMetric'.pre, RingHom.id_apply]
  rw [‚Üê smul_eq_mul, ‚Üê smul_apply, smul_boundedBy hc]
  refine le_boundedBy.2 (fun t => (boundedBy_le _).trans _) ?_
  simp only [smul_eq_mul, Pi.smul_apply, extend, iInf_eq_if]
  split_ifs with ht
  ¬∑ apply hr
    exact ‚ü®zero_le _, ht.trans_lt hr'.2‚ü©
  ¬∑ simp [h0]"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpi_tfae,effectiveEpi_tfae,d69a871e2141b3cc58e70cb9524c317c9844ffd7,":= by
  tfae
    1 ‚Üí 2 := fun _ ‚Ü¶ inferInstance
    2 ‚Üî 3 := epi_iff_surjective œÄ
    3 ‚Üí 1 := fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©","error:  unknown tactic
error:  unsolved goals
B X : Profinite
œÄ : X ‚ü∂ B
‚ä¢ [EffectiveEpi œÄ, Epi œÄ, Function.Surjective ‚áëœÄ].TFAE","theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (œÄ : X ‚ü∂ B) :
    TFAE
    [ EffectiveEpi œÄ
    , Epi œÄ
    , Function.Surjective œÄ
    ] ",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
  tfae_have 3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©
  tfae_finish",":= by
  tfae_have 1 ‚Üí 2
  ¬∑ exact fun _ ‚Ü¶ inferInstance
    2 ‚Üî 3
  ¬∑ exact epi_iff_surjective œÄ
    3 ‚Üí 1
  ¬∑ exact fun hœÄ ‚Ü¶ ‚ü®‚ü®struct œÄ hœÄ‚ü©‚ü©"
Mathlib/Algebra/Divisibility/Basic.lean,dvd_pow,dvd_pow,c9e4823690302d3379b7308a7a90735845de4ed2,"  | 0,     hn => (hn rfl).elim
  | n + 1, _  => by rw [pow_succ]; exact hab.mul_right _","error:  type mismatch
  Dvd.dvd.mul_right hab ?m.7292
has type
  a ‚à£ b * ?m.7292 : Prop
but is expected to have type
  a ‚à£ b ^ n * b : Prop","lemma dvd_pow (hab : a ‚à£ b) : ‚àÄ {n : ‚Ñï} (_ : n ‚â† 0), a ‚à£ b ^ n
","  | 0,     hn => (hn rfl).elim
  | n + 1, _  => by rw [pow_succ']; exact hab.mul_right _",":= by
  | 0,    hn => (hn rfl).elim
  | n + 1, _  => by rw [pow_succ]; exact hab.mul_right _"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  simp made no progress
warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñf' n.1 x - g' x‚Äñ * ‚Äñn.2 - x‚Äñ : Prop
but is expected to have type
  ‚Äñ(f' n.1 x - g' x) (n.2 - x)‚Äñ ‚â§ ‚Äñ(Prod.map (fun n ‚Ü¶ g' x - f' n x) id n).1‚Äñ * ‚Äñx - n.2‚Äñ : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff]"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,b50a8b2e9760b6f582390d3948a953c553480df1,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 ‚Üí ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 ‚Üí ?m.124403
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_image,
        Finset.mem_image, Finset.mem_image, Finset.mem_image, Finset.mem_imag"
Mathlib/RingTheory/FiniteType.lean,Algebra.FiniteType.iff_quotient_freeAlgebra,iff_quotient_freeAlgebra,19cfe36a7ab0262701db2043cd019a1861daadc8,":= by
  constructor
  ¬∑ rintro ‚ü®s, hs‚ü©
    refine ‚ü®s, FreeAlgebra.lift _ (‚Üë), ?_‚ü©
    intro x
    have hrw : (‚Üës : Set A) = ‚ü®fun x : A => x ‚àà s.val‚ü© := rfl
    rw [‚Üê Set.mem_range, ‚Üê AlgHom.coe_range]
    sorry
  ¬∑ rintro ‚ü®s, ‚ü®f, hsur‚ü©‚ü©
    exact FiniteType.of_surjective (FiniteType.freeAlgebra R s) f hsur","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  A ‚Üí Prop","theorem iff_quotient_freeAlgebra :
    FiniteType R A ‚Üî
      ‚àÉ (s : Finset A) (f : FreeAlgebra R s ‚Üí‚Çê[R] A), Surjective f ",":= by
  constructor
  ¬∑ rintro ‚ü®s, hs‚ü©
    refine ‚ü®s, FreeAlgebra.lift _ (‚Üë), ?_‚ü©
    intro x
    have hrw : (‚Üës : Set A) = fun x : A => x ‚àà s.val := rfl
    rw [‚Üê Set.mem_range, ‚Üê AlgHom.coe_range]
    erw [‚Üê adjoin_eq_range_freeAlgebra_lift, ‚Üê hrw, hs]
    exact Set.mem_univ x
  ¬∑ rintro ‚ü®s, ‚ü®f, hsur‚ü©‚ü©
    exact FiniteType.of_surjective (FiniteType.freeAlgebra R s) f hsur",":= by
  constructor
  ¬∑ rintro ‚ü®s, hs‚ü©
    refine ‚ü®s, FreeAlgebra.lift _ (‚Üë), ?_‚ü©
    intro x
    have hrw : (‚Üës : Set A) = ‚ü®fun x : A => x ‚àà s.val‚ü© := rfl
    rw [‚Üê Set.mem_range, ‚Üê AlgHom.coe_range]
    sorry
  ¬∑ rintro ‚ü®s, ‚ü®f, hsur‚ü©‚ü©
    exact FiniteType.of_surjective (FiniteType.freeAlgebra R s) f hsur"
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt,mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt,a76dc22f3a90e5ab96e9284d30276a87a4324a5d,":= by
  induction' n with n hn
  ¬∑ simpa using hz
  ¬∑ rw [_root_.pow_succ, mul_smul] at hz
    exact
      hn
        (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint
          (IsIntegral.smul _ hzint) hz hei)","error:  application type mismatch
  mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (IsIntegral.smul (p ^ n) hzint) hz
argument
  hz
has type
  p ^ n ‚Ä¢ p ‚Ä¢ z ‚àà adjoin R {B.gen} : Prop
but is expected to have type
  p ‚Ä¢ p ^ n ‚Ä¢ z ‚àà adjoin R {B.gen} : Prop","theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ‚Ñï} {z : L} (hzint : IsIntegral R z)
    (hz : p ^ n ‚Ä¢ z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) :
    z ‚àà adjoin R ({B.gen} : Set L) ",":= by
  induction' n with n hn
  ¬∑ simpa using hz
  ¬∑ rw [_root_.pow_succ', mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)",":= by
  induction' n with n hn
  ¬∑ simpa using hz
  ¬∑ rw [_root_.pow_succ, mul_smul] at hz
    exact
      hn
        (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint
          (IsIntegral.smul _ hzint) hz hei)"
Mathlib/Topology/MetricSpace/Polish.lean,IsClosed.isClopenable,_root_.IsClosed.isClopenable,63ea835fad879edf561b4e899d4f49874a770a73,":= by
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫
  ¬∑ simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    convert And.intro (isOpen_univ (X := s)) (isOpen_empty (X := (s·∂ú : Set Œ±)))
      <;> ext ‚ü®x, hx‚ü© <;> simpa using hx","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : TopologicalSpace Œ±
inst‚úù : PolishSpace Œ±
s : Set Œ±
hs : IsClosed s
this‚úù : PolishSpace ‚Üës
t : Set Œ± := s·∂ú
this : PolishSpace ‚Üët
f : ‚Üës ‚äï ‚Üët ‚âÉ Œ± := sorryAx (‚Üës ‚äï ‚Üët ‚âÉ Œ±) true
hle : coinduced (‚áëf) instTopologicalSpaceSum ‚â§ inst‚úù¬π
‚ä¢ IsClopenable s","theorem _root_.IsClosed.isClopenable [TopologicalSpace Œ±] [PolishSpace Œ±] {s : Set Œ±}
    (hs : IsClosed s) : IsClopenable s ",":= by
  classical
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫ := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    simp [f, preimage_preimage]",":= by
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫
  ¬∑ simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    convert And.intro (isOpen_univ (X := s)) (isOpen_empty (X := (s·∂ú : Set Œ±)))
      <;> ext ‚ü®x, hx‚ü© <;> simpa using hx"
Mathlib/SetTheory/Cardinal/Ordinal.lean,Cardinal.mul_eq_self,mul_eq_self,07a9a67eb79df5177b97c8a40c2e4a425c44b22e,":= by
  refine' le_antisymm _ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine' Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => _) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  skip
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine' le_of_forall_lt fun o h => _
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine'
    lt_of_le_of_lt (_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p))))
      _
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit
    ¬∑ exact
        ‚ü®(Set.embeddingOfSubset _ _ this).trans
            ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine' (Equiv.Set.insert _).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein (¬∑ < ¬∑) (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices : (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß
    ¬∑ exact (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type","error:  unexpected token '¬∑'; expected 'by' or 'from'
error:  unsolved goals
case intro.intro.intro.refine'_2
c‚úù : Cardinal.{u_1}
h‚úù : ‚Ñµ‚ÇÄ ‚â§ c‚úù
c : Cardinal.{u_1}
x‚úù : ‚àÄ y < c, Acc (fun x x_1 ‚Ü¶ x < x_1) y
Œ± : Type u_1
IH : ‚àÄ y < ‚ü¶Œ±‚üß, ‚Ñµ‚ÇÄ ‚â§ y ‚Üí y * y ‚â§ y
ol : ‚Ñµ‚ÇÄ ‚â§ ‚ü¶Œ±‚üß
r : Œ± ‚Üí Œ± ‚Üí Prop
wo : IsWellOrder Œ± r
e : (#Œ±).ord = type r
this‚úù¬π : LinearOrder Œ± := linearOrderOfSTO r
this‚úù : IsWellOrder Œ± fun x x_1 ‚Ü¶ x < x_1
g : Œ± √ó Œ± ‚Üí Œ± := fun p ‚Ü¶ max p.1 p.2
f : Œ± √ó Œ± ‚Ü™ Ordinal.{u_1} √ó Œ± √ó Œ± := { toFun := fun p ‚Ü¶ (typein (fun x x_1 ‚Ü¶ x < x_1) (g p), p), inj' := ‚ãØ }
s : Œ± √ó Œ± ‚Üí Œ± √ó Œ± ‚Üí Prop := ‚áëf ‚Åª¬π'o Prod.Lex (fun x x_1 ‚Ü¶ x < x_1) (Prod.Lex (fun x x_1 ‚Ü¶ x < x_1) fun x x_1 ‚Ü¶ x < x_1)
this : IsWellOrder (Œ± √ó Œ±) s
p : Œ± √ó Œ±
h : typein s p < type s
‚ä¢ (succ (typein (fun x x_1 ‚Ü¶ x < x_1) (g p))).card * (succ (typein (fun x x_1 ‚Ü¶ x < x_1) (g p))).card < #Œ±",theorem mul_eq_self {c : Cardinal} (h : ‚Ñµ‚ÇÄ ‚â§ c) : c * c = c ,":= by
  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => ?_) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine le_of_forall_lt fun o h => ?_
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine lt_of_le_of_lt
    (?_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p)))) ?_
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [s, f, Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit from
      ‚ü®(Set.embeddingOfSubset _ _ this).trans
        ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine (Equiv.Set.insert ?_).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein (¬∑ < ¬∑) (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß from (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type",":= by
  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => ?_) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  skip
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine le_of_forall_lt fun o h => ?_
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine
    lt_of_le_of_lt (_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p)))
      ?_
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit
    ¬∑ exact
        ‚ü®(Set.embeddingOfSubset _ _ this).trans
            ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine (Equiv.Set.insert _).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein LT.lt (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß
    ¬∑ exact (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type"
Mathlib/NumberTheory/DiophantineApproximation.lean,Rat.den_le_and_le_num_le_of_sub_lt_one_div_den_sq,den_le_and_le_num_le_of_sub_lt_one_div_den_sq,457e481f5e9c0969401919077d4f5efc34fed55d,":= by
  have hq‚ÇÄ : (0 : ‚Ñö) < q.den := Nat.cast_pos.mpr q.pos
  replace h : |Œæ * q.den - q.num| < 1 / q.den := by
    rw [‚Üê mul_lt_mul_right hq‚ÇÄ] at h
    conv_lhs at h => rw [‚Üê abs_of_pos hq‚ÇÄ, ‚Üê abs_mul, sub_mul, mul_den_eq_num]
    rwa [sq, div_mul, mul_div_cancel_left _ hq‚ÇÄ.ne'] at h
  constructor
  ¬∑ rcases eq_or_ne Œæ q with (rfl | H)
    ¬∑ exact le_rfl
    ¬∑ have hŒæ‚ÇÄ : (0 : ‚Ñö) < Œæ.den := Nat.cast_pos.mpr Œæ.pos
      rw [‚Üê Rat.num_div_den Œæ, div_mul_eq_mul_div, div_sub' _ _ _ hŒæ‚ÇÄ.ne', abs_div, abs_of_pos hŒæ‚ÇÄ,
        div_lt_iff hŒæ‚ÇÄ, div_mul_comm, mul_one] at h
      refine' Nat.cast_le.mp ((one_lt_div hq‚ÇÄ).mp <| lt_of_le_of_lt _ h).le
      norm_cast
      rw [mul_comm _ q.num]
      exact Int.one_le_abs (sub_ne_zero_of_ne <| mt Rat.eq_iff_mul_eq_mul.mpr H)
  ¬∑ obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© :=
      abs_sub_lt_iff.mp
        (h.trans_le <|
          (one_div_le zero_lt_one hq‚ÇÄ).mp <| (@one_div_one ‚Ñö _).symm ‚ñ∏ Nat.cast_le.mpr q.pos)
    rw [sub_lt_iff_lt_add, add_comm] at h‚ÇÅ h‚ÇÇ
    rw [‚Üê sub_lt_iff_lt_add] at h‚ÇÇ
    norm_cast at h‚ÇÅ h‚ÇÇ
    exact
      ‚ü®sub_le_iff_le_add.mpr (Int.ceil_le.mpr h‚ÇÅ.le), sub_le_iff_le_add.mp (Int.le_floor.mpr h‚ÇÇ.le)‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.38074 * ?m.38099 / ?m.38074
Œæ q : ‚Ñö
h : |Œæ * ‚Üëq.den - ‚Üëq.num| < 1 / (‚Üëq.den * ‚Üëq.den / ‚Üëq.den)
hq‚ÇÄ : 0 < ‚Üëq.den
‚ä¢ |Œæ * ‚Üëq.den - ‚Üëq.num| < 1 / ‚Üëq.den
error:  application type mismatch
  mul_div_cancel_left ?m.38074 (LT.lt.ne' hq‚ÇÄ)
argument
  LT.lt.ne' hq‚ÇÄ
has type
  ‚Üëq.den ‚â† 0 : Prop
but is expected to have type
  ?m.38072 : Type ?u.38071","theorem den_le_and_le_num_le_of_sub_lt_one_div_den_sq {Œæ q : ‚Ñö}
    (h : |Œæ - q| < 1 / (q.den : ‚Ñö) ^ 2) :
    q.den ‚â§ Œæ.den ‚àß ‚åàŒæ * q.den‚åâ - 1 ‚â§ q.num ‚àß q.num ‚â§ ‚åäŒæ * q.den‚åã + 1 ",":= by
  have hq‚ÇÄ : (0 : ‚Ñö) < q.den := Nat.cast_pos.mpr q.pos
  replace h : |Œæ * q.den - q.num| < 1 / q.den := by
    rw [‚Üê mul_lt_mul_right hq‚ÇÄ] at h
    conv_lhs at h => rw [‚Üê abs_of_pos hq‚ÇÄ, ‚Üê abs_mul, sub_mul, mul_den_eq_num]
    rwa [sq, div_mul, mul_div_cancel_left‚ÇÄ _ hq‚ÇÄ.ne'] at h
  constructor
  ¬∑ rcases eq_or_ne Œæ q with (rfl | H)
    ¬∑ exact le_rfl
    ¬∑ have hŒæ‚ÇÄ : (0 : ‚Ñö) < Œæ.den := Nat.cast_pos.mpr Œæ.pos
      rw [‚Üê Rat.num_div_den Œæ, div_mul_eq_mul_div, div_sub' _ _ _ hŒæ‚ÇÄ.ne', abs_div, abs_of_pos hŒæ‚ÇÄ,
        div_lt_iff hŒæ‚ÇÄ, div_mul_comm, mul_one] at h
      refine Nat.cast_le.mp ((one_lt_div hq‚ÇÄ).mp <| lt_of_le_of_lt ?_ h).le
      norm_cast
      rw [mul_comm _ q.num]
      exact Int.one_le_abs (sub_ne_zero_of_ne <| mt Rat.eq_iff_mul_eq_mul.mpr H)
  ¬∑ obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© :=
      abs_sub_lt_iff.mp
        (h.trans_le <|
          (one_div_le zero_lt_one hq‚ÇÄ).mp <| (@one_div_one ‚Ñö _).symm ‚ñ∏ Nat.cast_le.mpr q.pos)
    rw [sub_lt_iff_lt_add, add_comm] at h‚ÇÅ h‚ÇÇ
    rw [‚Üê sub_lt_iff_lt_add] at h‚ÇÇ
    norm_cast at h‚ÇÅ h‚ÇÇ
    exact
      ‚ü®sub_le_iff_le_add.mpr (Int.ceil_le.mpr h‚ÇÅ.le), sub_le_iff_le_add.mp (Int.le_floor.mpr h‚ÇÇ.le)‚ü©",":= by
  have hq‚ÇÄ : (0 : ‚Ñö) < q.den := Nat.cast_pos.mpr q.pos
  replace h : |Œæ * q.den - q.num| < 1 / q.den := by
    rw [‚Üê mul_lt_mul_right hq‚ÇÄ] at h
    conv_lhs at h => rw [‚Üê abs_of_pos hq‚ÇÄ, ‚Üê abs_mul, sub_mul, mul_den_eq_num]
    rwa [sq, div_mul, mul_div_cancel_left _ hq‚ÇÄ.ne'] at h
  constructor
  ¬∑ rcases eq_or_ne Œæ q with (rfl | H)
    ¬∑ exact le_rfl
    ¬∑ have hŒæ‚ÇÄ : (0 : ‚Ñö) < Œæ.den := Nat.cast_pos.mpr Œæ.pos
      rw [‚Üê Rat.num_div_den Œæ, div_mul_eq_mul_div, div_sub' _ _ _ hŒæ‚ÇÄ.ne', abs_div, abs_of_pos hŒæ‚ÇÄ,
        div_lt_iff hŒæ‚ÇÄ, div_mul_comm, mul_one] at h
      refine Nat.cast_le.mp ((one_lt_div hq‚ÇÄ).mp <| lt_of_le_of_lt ?_ h).le
      norm_cast
      rw [mul_comm _ q.num]
      exact Int.one_le_abs (sub_ne_zero_of_ne <| mt Rat.eq_iff_mul_eq_mul.mpr H)
  ¬∑ obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© :=
      abs_sub_lt_iff.mp
        (h.trans_le <|
          (one_div_le zero_lt_one hq‚ÇÄ).mp <| (@one_div_one ‚Ñö _).symm ‚ñ∏ Nat.cast_le.mpr q.pos)
    rw [sub_lt_iff_lt_add, add_comm] at h‚ÇÅ h‚ÇÇ
    rw [‚Üê sub_lt_iff_lt_add] at h‚ÇÇ
    norm_cast at h‚ÇÅ h‚ÇÇ
    exact
      ‚ü®sub_le_iff_le_add.mpr (Int.ceil_le.mpr h‚ÇÅ.le), sub_le_iff_le_add.mp (Int.le_floor.mpr h‚ÇÇ.le)‚ü©"
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt,mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt,0f24aee7da46f85fee5cacc716172444ce31e582,":= by
  induction' n with n hn
  ¬∑ simpa using hz
  ¬∑ rw [_root_.pow_succ, mul_smul] at hz
    exact
      hn
        (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint
          (isIntegral_smul _ hzint) hz hei)",error:  unknown identifier 'isIntegral_smul',"theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ‚Ñï} {z : L} (hzint : IsIntegral R z)
    (hz : p ^ n ‚Ä¢ z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) :
    z ‚àà adjoin R ({B.gen} : Set L) ",":= by
  induction' n with n hn
  ¬∑ simpa using hz
  ¬∑ rw [_root_.pow_succ', mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)",":= by
  induction' n with n hn
  ¬∑ simpa using hz
  ¬∑ rw [_root_.pow_succ, mul_smul] at hz
    exact
      hn
        (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint
          (isIntegral_smul _ hzint) hz hei)"
Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean,MeasureTheory.ae_bdd_liminf_atTop_of_snorm_bdd,ae_bdd_liminf_atTop_of_snorm_bdd,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  by_cases hp' : p = ‚àû
  ¬∑ subst hp'
    simp_rw [snorm_exponent_top] at hbdd
    have : ‚àÄ n, ‚àÄ·µê x ‚àÇŒº, (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < R + 1 := fun n =>
      ae_lt_of_essSup_lt
        (lt_of_le_of_lt (hbdd n) <| ENNReal.lt_add_right ENNReal.coe_ne_top one_ne_zero)
    rw [‚Üê ae_all_iff] at this
    filter_upwards [this] with x hx using lt_of_le_of_lt
        (liminf_le_of_frequently_le' <| frequently_of_forall fun n => (hx n).le)
        (ENNReal.add_lt_top.2 ‚ü®ENNReal.coe_lt_top, ENNReal.one_lt_top‚ü©)
  filter_upwards [ae_bdd_liminf_atTop_rpow_of_snorm_bdd hfmeas hbdd] with x hx
  have hppos : 0 < p.toReal := ENNReal.toReal_pos hp hp'
  have :
    liminf (fun n => (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p.toReal) atTop =
      liminf (fun n => (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) atTop ^ p.toReal := by
    change
      liminf (fun n => ENNReal.orderIsoRpow p.toReal hppos (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) atTop =
        ENNReal.orderIsoRpow p.toReal hppos (liminf (fun n => (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) atTop)
    refine (OrderIso.liminf_apply (ENNReal.orderIsoRpow p.toReal _) ?_ ?_?? _ _).symm <;>
      isBoundedDefault
  rw [this] at hx
  rw [‚Üê ENNReal.rpow_one (liminf (fun n => ‚Äñf n x‚Äñ‚Çä) atTop), ‚Üê mul_inv_cancel hppos.ne.symm,
    ENNReal.rpow_mul]
  exact ENNReal.rpow_lt_top_of_nonneg (inv_nonneg.2 hppos.le) hx.ne","error:  don't know how to synthesize placeholder for argument 'hgu_co'
context:
Œ± : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
m m0 : MeasurableSpace Œ±
p‚úù : ‚Ñù‚â•0‚àû
q : ‚Ñù
Œº ŒΩ : Measure Œ±
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : MeasurableSpace E
inst‚úù : OpensMeasurableSpace E
R : ‚Ñù‚â•0
p : ‚Ñù‚â•0‚àû
hp : p ‚â† 0
f : ‚Ñï ‚Üí Œ± ‚Üí E
hfmeas : ‚àÄ (n : ‚Ñï), Measurable (f n)
hbdd : ‚àÄ (n : ‚Ñï), snorm (f n) p Œº ‚â§ ‚ÜëR
hp' : ¬¨p = ‚ä§
x : Œ±
hx : liminf (fun n ‚Ü¶ ‚Üë‚Äñf n x‚Äñ‚Çä ^ p.toReal) atTop < ‚ä§
hppos : 0 < p.toReal
‚ä¢ IsCoboundedUnder (fun x x_1 ‚Ü¶ x ‚â• x_1) atTop fun x_1 ‚Ü¶ (ENNReal.orderIsoRpow p.toReal hppos) ‚Üë‚Äñf x_1 x‚Äñ‚Çä
error:  don't know how to synthesize placeholder for argument 'hgu'
context:
Œ± : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
m m0 : MeasurableSpace Œ±
p‚úù : ‚Ñù‚â•0‚àû
q : ‚Ñù
Œº ŒΩ : Measure Œ±
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : MeasurableSpace E
inst‚úù : OpensMeasurableSpace E
R : ‚Ñù‚â•0
p : ‚Ñù‚â•0‚àû
hp : p ‚â† 0
f : ‚Ñï ‚Üí Œ± ‚Üí E
hfmeas : ‚àÄ (n : ‚Ñï), Measurable (f n)
hbdd : ‚àÄ (n : ‚Ñï), snorm (f n) p Œº ‚â§ ‚ÜëR
hp' : ¬¨p = ‚ä§
x : Œ±
hx : liminf (fun n ‚Ü¶ ‚Üë‚Äñf n x‚Äñ‚Çä ^ p.toReal) atTop < ‚ä§
hppos : 0 < p.toReal
‚ä¢ IsBoundedUnder (fun x x_1 ‚Ü¶ x ‚â• x_1) atTop fun x_1 ‚Ü¶ (ENNReal.orderIsoRpow p.toReal hppos) ‚Üë‚Äñf x_1 x‚Äñ‚Çä","theorem ae_bdd_liminf_atTop_of_snorm_bdd {p : ‚Ñù‚â•0‚àû} (hp : p ‚â† 0) {f : ‚Ñï ‚Üí Œ± ‚Üí E}
    (hfmeas : ‚àÄ n, Measurable (f n)) (hbdd : ‚àÄ n, snorm (f n) p Œº ‚â§ R) :
    ‚àÄ·µê x ‚àÇŒº, liminf (fun n => (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) atTop < ‚àû ",":= by
  by_cases hp' : p = ‚àû
  ¬∑ subst hp'
    simp_rw [snorm_exponent_top] at hbdd
    have : ‚àÄ n, ‚àÄ·µê x ‚àÇŒº, (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < R + 1 := fun n =>
      ae_lt_of_essSup_lt
        (lt_of_le_of_lt (hbdd n) <| ENNReal.lt_add_right ENNReal.coe_ne_top one_ne_zero)
    rw [‚Üê ae_all_iff] at this
    filter_upwards [this] with x hx using lt_of_le_of_lt
        (liminf_le_of_frequently_le' <| frequently_of_forall fun n => (hx n).le)
        (ENNReal.add_lt_top.2 ‚ü®ENNReal.coe_lt_top, ENNReal.one_lt_top‚ü©)
  filter_upwards [ae_bdd_liminf_atTop_rpow_of_snorm_bdd hfmeas hbdd] with x hx
  have hppos : 0 < p.toReal := ENNReal.toReal_pos hp hp'
  have :
    liminf (fun n => (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p.toReal) atTop =
      liminf (fun n => (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) atTop ^ p.toReal := by
    change
      liminf (fun n => ENNReal.orderIsoRpow p.toReal hppos (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) atTop =
        ENNReal.orderIsoRpow p.toReal hppos (liminf (fun n => (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) atTop)
    refine (OrderIso.liminf_apply (ENNReal.orderIsoRpow p.toReal _) ?_ ?_ ?_ ?_).symm <;>
      isBoundedDefault
  rw [this] at hx
  rw [‚Üê ENNReal.rpow_one (liminf (fun n => ‚Äñf n x‚Äñ‚Çä) atTop), ‚Üê mul_inv_cancel hppos.ne.symm,
    ENNReal.rpow_mul]
  exact ENNReal.rpow_lt_top_of_nonneg (inv_nonneg.2 hppos.le) hx.ne",":= by
  by_cases hp' : p = ‚àû
  ¬∑ subst hp'
    simp_rw [snorm_exponent_top] at hbdd
    have : ‚àÄ n, ‚àÄ·µê x ‚àÇŒº, (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < R + 1 := fun n =>
      ae_lt_of_essSup_lt
        (lt_of_le_of_lt (hbdd n) <| ENNReal.lt_add_right ENNReal.coe_ne_top one_ne_zero)
    rw [‚Üê ae_all_iff] at this
    filter_upwards [this] with x hx using lt_of_le_of_lt
        (liminf_le_of_frequently_le' <| frequently_of_forall fun n => (hx n).le)
        (ENNReal.add_lt_top.2 ‚ü®ENNReal.coe_lt_top, ENNReal.one_lt_top‚ü©)
  filter_upwards [ae_bdd_liminf_atTop_rpow_of_snorm_bdd hfmeas hbdd] with x hx
  have hppos : 0 < p.toReal := ENNReal.toReal_pos hp hp'
  have :
    liminf (fun n => (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p.toReal) atTop =
      liminf (fun n => (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) atTop ^ p.toReal := by
    change
      liminf (fun n => ENNReal.orderIsoRpow p.toReal hppos (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) atTop =
        ENNReal.orderIsoRpow p.toReal hppos (liminf (fun n => (‚Äñf n x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) atTop)
    refine (OrderIso.liminf_apply (ENNReal.orderIsoRpow p.toReal _) ?_ ?_?_ ?_ ?_).symm <;>
      isBoundedDefault
  rw [this] at hx
  rw [‚Üê ENNReal.rpow_one (liminf (fun n => ‚Äñf n x‚Äñ‚Çä) atTop), ‚Üê mul_inv_cancel hppos.ne.symm,
    ENNReal.rpow_mul]
  exact ENNReal.rpow_lt_top_of_nonneg (inv_nonneg.2 hppos.le) hx.ne"
Mathlib/Data/Seq/Computation.lean,Computation.liftRel_think_left,liftRel_think_left,3c930599229893e1b6a931304cf4efff4a01b172,":=
  and_congr (forall_congr' fun _ => imp_congr mem_think_iff Iff.rfl)
    (forall_congr' fun _ =>
      imp_congr Iff.rfl <| exists_congr fun _ => and_congr mem_think_iff Iff.rfl)","error:  unknown identifier 'mem_think_iff'
error:  unknown identifier 'mem_think_iff'","theorem liftRel_think_left (R : Œ± ‚Üí Œ≤ ‚Üí Prop) (ca : Computation Œ±) (cb : Computation Œ≤) :
    LiftRel R (think ca) cb ‚Üî LiftRel R ca cb ",":=
  and_congr (forall_congr' fun _ => imp_congr ‚ü®of_think_mem, think_mem‚ü© Iff.rfl)
    (forall_congr' fun _ =>
      imp_congr Iff.rfl <| exists_congr fun _ => and_congr ‚ü®of_think_mem, think_mem‚ü© Iff.rfl)",":=
  and_congr (forall_congr fun _ => imp_congr mem_think_iff Iff.rfl)
    (forall_congr' fun _ =>
      imp_congr Iff.rfl <| exists_congr fun _ => and_congr mem_think_iff Iff.rfl)"
Mathlib/Analysis/LocallyConvex/Basic.lean,Balanced.absorbs_self,Balanced.absorbs_self,513593924376092791e22fba3b83ac9cd9eb3061,":= by
  refine' ‚ü®1, fun a ha x hx => _‚ü©
  rw [mem_smul_set_iff_inv_smul_mem‚ÇÄ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]
  refine' hA a‚Åª¬π _ (smul_mem_smul_set hx)
  rw [norm_inv]
  exact inv_le_one ha","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  (Bornology.cobounded ùïú).1 {x | (fun a ‚Ü¶ A ‚äÜ a ‚Ä¢ A) x}
error:  no goals to be solved",theorem Balanced.absorbs_self (hA : Balanced ùïú A) : Absorbs ùïú A A ,":=
  .of_norm ‚ü®1, fun _ => hA.subset_smul‚ü©",":= by
  refine ‚ü®1, fun a ha x hx => ?_‚ü©
  rw [mem_smul_set_iff_inv_smul_mem‚ÇÄ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]
  refine hA a‚Åª¬π _ (smul_mem_smul_set hx) ?_"
Mathlib/Analysis/Calculus/FormalMultilinearSeries.lean,FormalMultilinearSeries.coeff_iterate_fslope,coeff_iterate_fslope,0c824fb54f74f0c66db893166b73e377be2feb6f,":= by
  induction k generalizing p with
  | zero => rfl
  | succ k ih => simp [ih]","error:  unsolved goals
case succ
ùïú : Type u
ùïú' : Type u'
E : Type v
F : Type w
G : Type x
inst‚úù¬≤ : NontriviallyNormedField ùïú
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
n‚úù n k : ‚Ñï
ih : ‚àÄ {p : FormalMultilinearSeries ùïú ùïú E}, (fslope^[k] p).coeff n = p.coeff (n + k)
p : FormalMultilinearSeries ùïú ùïú E
‚ä¢ p.coeff (n + k + 1) = p.coeff (n + (k + 1))",theorem coeff_iterate_fslope (k n : ‚Ñï) : (fslope^[k] p).coeff n = p.coeff (n + k) ,":= by
  induction k generalizing p with
  | zero => rfl
  | succ k ih => simp [ih, add_assoc]",":= by
  induction k generalizing p with
  | zero => rfl
  | succ k ih => simp [ih]"
Mathlib/Topology/UniformSpace/Cauchy.lean,TotallyBounded.closure,TotallyBounded.closure,14167e48d13e9c2d72cbdff0431a8edba6021c34,":=
  uniformity_hasBasis_closed.totallyBounded_iff.2 fun V hV =>
    let ‚ü®t, htf, hst‚ü© := h V hV.1
    ‚ü®t, htf,
      closure_minimal hst <|
        isClosed_bunion·µ¢ htf fun _ _ => hV.2.preimage (continuous_id.prod_mk continuous_const)‚ü©",error:  unknown identifier 'isClosed_bunion·µ¢',theorem TotallyBounded.closure {s : Set Œ±} (h : TotallyBounded s) : TotallyBounded (closure s) ,":=
  uniformity_hasBasis_closed.totallyBounded_iff.2 fun V hV =>
    let ‚ü®t, htf, hst‚ü© := h V hV.1
    ‚ü®t, htf,
      closure_minimal hst <|
        htf.isClosed_biUnion fun _ _ => hV.2.preimage (continuous_id.prod_mk continuous_const)‚ü©",":=
  uniformity_hasBasis_closed.totallyBounded_iff.2 fun V hV =>
    let ‚ü®t, htf, hst‚ü© := h V hV.1
    ‚ü®t, htf,
      closure_minimal hst <|
        isClosed_biUnion htf fun _ _ => hV.2.preimage (continuous_id.prod_mk continuous_const)‚ü©"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicAt.order_eq_int_iff,order_eq_int_iff,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_nat, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
      ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel', zpow_ofNat, zpow_ofNat]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©","warning:  `WithTop.coe_nat` has been deprecated, use `WithTop.coe_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚ä§ - ‚Üë?m.79514
case pos
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí E
x : ùïú
hf : MeromorphicAt f x
n : ‚Ñ§
h : ‚ãØ.order = ‚ä§
‚ä¢ ‚ä§ - ‚Üë‚Üë(Exists.choose hf) = ‚Üën ‚Üî ‚àÉ g, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z
warning:  `WithTop.coe_nat` has been deprecated, use `WithTop.coe_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë?m.80098 - ‚Üë?m.80099
case neg.intro
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f : ùïú ‚Üí E
x : ùïú
hf : MeromorphicAt f x
n : ‚Ñ§
h‚úù : ¬¨‚ãØ.order = ‚ä§
m : ‚Ñï
h : ‚Üëm = ‚ãØ.order
‚ä¢ ‚Üë‚Üëm - ‚Üë‚Üë(Exists.choose hf) = ‚Üën ‚Üî ‚àÉ g, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z","lemma order_eq_int_iff {f : ùïú ‚Üí E} {x : ùïú} (hf : MeromorphicAt f x) (n : ‚Ñ§) : hf.order = n ‚Üî
    ‚àÉ g : ùïú ‚Üí E, AnalyticAt ùïú g x ‚àß g x ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù[‚â†] x, f z = (z - x) ^ n ‚Ä¢ g z ",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_natCast, ‚Üê coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
        ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©",":= by
  unfold order
  by_cases h : hf.choose_spec.order = ‚ä§
  ¬∑ rw [h, WithTop.map_top, ‚Üê WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ‚ü®g, hg_an, hg_ne, hg_eq‚ü© ‚Ü¶ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ‚Üê AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ‚ä¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ‚Üê mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  ¬∑ obtain ‚ü®m, h‚ü© := WithTop.ne_top_iff_exists.mp h
    rw [‚Üê h, WithTop.map_coe, ‚Üê WithTop.coe_nat, ‚Üê WithTop.coe_sub, WithTop.coe_inj]
    obtain ‚ü®g, hg_an, hg_ne, hg_eq‚ü© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù[‚â†] x, f z = (z - x) ^ (‚Üëm - ‚Üëhf.choose : ‚Ñ§) ‚Ä¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [‚Üê smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ‚Üê mul_smul,
      ‚Üê zpow_add‚ÇÄ (sub_ne_zero.mpr hz), ‚Üê add_sub_assoc, add_sub_cancel_left, zpow_ofNat]
    exact ‚ü®fun h ‚Ü¶ ‚ü®g, hg_an, hg_ne, h ‚ñ∏ hg_eq‚ü©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ‚ü®g, hg_an, hg_ne, hg_eq‚ü©‚ü©"
Mathlib/Topology/MetricSpace/Polish.lean,IsClosed.isClopenable,_root_.IsClosed.isClopenable,62d1e98c9775031911b945f049f84047fafbe5e1,":= by
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫ := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    simp [preimage_preimage]","error:  failed to synthesize
  DecidablePred fun x ‚Ü¶ x ‚àà s
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  And.intro continuous_subtype_val
argument
  continuous_subtype_val
has type
  Continuous Subtype.val : Prop
but is expected to have type
  Continuous (‚áëf ‚àò Sum.inl) : Prop
error:  unsolved goals
case refine_2
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : TopologicalSpace Œ±
inst‚úù : PolishSpace Œ±
s : Set Œ±
hs : IsClosed s
this‚úù : PolishSpace ‚Üës
t : Set Œ± := s·∂ú
this : PolishSpace ‚Üët
f : ‚Üës ‚äï ‚Üët ‚âÉ Œ± := sorryAx (‚Üës ‚äï ‚Üët ‚âÉ Œ±) true
hle : coinduced (‚áëf) instTopologicalSpaceSum ‚â§ inst‚úù¬π
‚ä¢ IsOpen ((fun x ‚Ü¶ f (Sum.inl x)) ‚Åª¬π' s) ‚àß IsOpen ((fun x ‚Ü¶ f (Sum.inr x)) ‚Åª¬π' s)","theorem _root_.IsClosed.isClopenable [TopologicalSpace Œ±] [PolishSpace Œ±] {s : Set Œ±}
    (hs : IsClosed s) : IsClopenable s ",":= by
  classical
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫ := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    simp [f, preimage_preimage]",":= by
  haveI : PolishSpace s := hs.polishSpace
  let t : Set Œ± := s·∂ú
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫ := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ‚Üê continuous_iff_coinduced_le]
    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©
  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©
  ¬∑ rw [‚Üê f.induced_symm]
    exact f.symm.polishSpace_induced
  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]
    simp [preimage_preimage]"
Mathlib/Probability/Distributions/Uniform.lean,PMF.uniformOfFintype_apply,uniformOfFintype_apply,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp [uniformOfFintype, Finset.mem_univ, if_true, uniformOfFinset_apply]
  rfl",error:  no goals to be solved,theorem uniformOfFintype_apply (a : Œ±) : uniformOfFintype Œ± a = (Fintype.card Œ± : ‚Ñù‚â•0‚àû)‚Åª¬π ,":= by
  simp [uniformOfFintype, Finset.mem_univ, if_true, uniformOfFinset_apply]",":= by
  simp [uniformOfFintype, Finset.mem_univ]"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.tendstoInMeasure_iff_tendsto_Lp,tendstoInMeasure_iff_tendsto_Lp,ff33d25c791a3fac407c782b49018fcb63700d0d,":=
  ‚ü®fun h => tendsto_Lp_of_tendstoInMeasure Œº hp hp' (fun n => (hf n).1) hg h.2 h.1, fun h =>
    ‚ü®tendstoInMeasure_of_tendsto_snorm (lt_of_lt_of_le zero_lt_one hp).ne.symm
        (fun n => (hf n).aestronglyMeasurable) hg.aestronglyMeasurable h,
      unifIntegrable_of_tendsto_Lp Œº hp hp' hf hg h‚ü©‚ü©","error:  application type mismatch
  tendsto_Lp_of_tendstoInMeasure Œº
argument
  Œº
has type
  Measure Œ± : Type u_1
but is expected to have type
  1 ‚â§ ?m.210482 : Prop
error:  application type mismatch
  unifIntegrable_of_tendsto_Lp Œº
argument
  Œº
has type
  Measure Œ± : Type u_1
but is expected to have type
  1 ‚â§ ?m.215110 : Prop","theorem tendstoInMeasure_iff_tendsto_Lp [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû)
    (hf : ‚àÄ n, Mem‚Ñíp (f n) p Œº) (hg : Mem‚Ñíp g p Œº) :
    TendstoInMeasure Œº f atTop g ‚àß UnifIntegrable f p Œº ‚Üî
      Tendsto (fun n => snorm (f n - g) p Œº) atTop (ùìù 0) ",":=
  ‚ü®fun h => tendsto_Lp_of_tendstoInMeasure hp hp' (fun n => (hf n).1) hg h.2 h.1, fun h =>
    ‚ü®tendstoInMeasure_of_tendsto_snorm (lt_of_lt_of_le zero_lt_one hp).ne.symm
        (fun n => (hf n).aestronglyMeasurable) hg.aestronglyMeasurable h,
      unifIntegrable_of_tendsto_Lp hp hp' hf hg h‚ü©‚ü©",":=
  ‚ü®fun h => tendsto_Lp_of_tendstoInMeasure Œº hp hp' (fun n => (hf n).1) hg h.2 h.1, fun h =>
    ‚ü®tendstoInMeasure_of_tendsto_snorm (lt_of_lt_of_le zero_lt_one hp).ne.symm
        (fun n => (hf n).aestronglyMeasurable) hg.aestronglyMeasurable h,
      unifIntegrable_of_tendsto_Lp Œº hp hp' hf hg h‚ü©‚ü©"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,49b8ee5c731881e8d562a13d37f3ee3fd50b8092,":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine' ‚ü®[], rfl.le, show œÜ = 1 from _‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine' ‚ü®x::l, Nat.succ_le_succ hl, _‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg ((¬∑ * ¬∑) œÅ) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Åµ : _root_.RCLike ùïú
inst‚úù‚Å¥ : NormedAddCommGroup E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
inst‚úù : FiniteDimensional ‚Ñù F
œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F
hn :
  finrank ‚Ñù
      ‚Ü•(LinearMap.ker
            (ContinuousLinearMap.id ‚Ñù F -
              ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }))·óÆ ‚â§
    0
‚ä¢ LinearMap.ker
      (ContinuousLinearMap.id ‚Ñù F -
        ‚Üë{ toLinearEquiv := œÜ.toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) =
    ‚ä§","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ‚Ñù F] {n : ‚Ñï}
    (œÜ : F ‚âÉ‚Çó·µ¢[‚Ñù] F) (hn : finrank ‚Ñù (ker (ContinuousLinearMap.id ‚Ñù F - œÜ))·óÆ ‚â§ n) :
    ‚àÉ l : List F, l.length ‚â§ n ‚àß œÜ = (l.map fun v => reflection (‚Ñù ‚àô v)·óÆ).prod ",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by omega : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      omega
    obtain ‚ü®l, hl, hœÜl‚ü© := IH (œÅ * œÜ) this
    refine ‚ü®x::l, Nat.succ_le_succ hl, ?_‚ü©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (œÅ * ¬∑) hœÜl
    dsimp only at this
    rwa [‚Üê mul_assoc, reflection_mul_reflection, one_mul] at this",":= by
  induction' n with n IH generalizing œÜ
  ¬∑ 
    refine ‚ü®[], rfl.le, show œÜ = 1 from ?_‚ü©
    have : ker (ContinuousLinearMap.id ‚Ñù F - œÜ) = ‚ä§ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  ¬∑ 
    let W := ker (ContinuousLinearMap.id ‚Ñù F - œÜ)
    have hW : ‚àÄ w ‚àà W, œÜ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ‚Ñù W·óÆ ‚â§ n
    ¬∑ obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ‚ü© := IH œÜ hn'
      exact ‚ü®V, hV‚ÇÅ.trans n.le_succ, hV‚ÇÇ‚ü©
    haveI : Nontrivial W·óÆ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ‚Ñù W·óÆ)
    obtain ‚ü®v, hv‚ü© := exists_ne (0 : W·óÆ)
    have hœÜv : œÜ v ‚àà W·óÆ := by
      intro w hw
      rw [‚Üê hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ‚àâ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - œÜ v
    let œÅ := reflection (‚Ñù ‚àô x)·óÆ
    let V := ker (ContinuousLinearMap.id ‚Ñù F - œÜ.trans œÅ)
    have hV : ‚àÄ w, œÅ (œÜ w) = w ‚Üí w ‚àà V := by
      intro w hw
      change w - œÅ (œÜ w) = 0
      rw [sub_eq_zero, hw]
    have H‚ÇÇV : W ‚â§ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hœÜv _ hw
    have H‚ÇÅV : (v : F) ‚àà V := by
      apply hV
      have : œÅ v = œÜ v := reflection_sub (œÜ.norm_map v).symm
      rw [‚Üê this]
      exact reflection_reflection _ _
    have : finrank ‚Ñù V·óÆ ‚â§ n := by
      change finrank ‚Ñù W·óÆ ‚â§ n + 1 at hn
      have : finrank ‚Ñù W + 1 ‚â§ finrank ‚Ñù V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ‚ü®H‚ÇÇV, v, H‚ÇÅV, hv'‚ü©)
      have : finrank ‚Ñù V + finrank ‚Ñù V·óÆ = finrank ‚Ñù F := V.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_add_finrank_orthogonal
      have : finrank ‚Ñù W + finrank ‚Ñù W·óÆ = finrank ‚Ñù F := W.finrank_ad"
Mathlib/Topology/OmegaCompletePartialOrder.lean,notBelow_isOpen,notBelow_isOpen,4fafac3c913ccc407e26d1bc00d7f75cec309030,":= by
  have h : Monotone (notBelow y) := fun x z hle ‚Ü¶ mt hle.trans
  change œâScottContinuous fun x ‚Ü¶ x ‚àà (notBelow y)
  rw [‚Üê continuous'_iff_œâScottContinuous]
  refine ‚ü®h, fun c ‚Ü¶ eq_of_forall_ge_iff fun z ‚Ü¶ ?_‚ü©
  simp only [œâSup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]","error:  unknown identifier 'œâScottContinuous'
error:  unknown identifier 'continuous'_iff_œâScottContinuous'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.30292
Œ± : Type u_1
inst‚úù : OmegaCompletePartialOrder Œ±
y : Scott Œ±
h : Monotone (notBelow y)
‚ä¢ sorryAx (Sort ?u.30117) true
error:  invalid occurrence of universe level 'u_3' at 'scottContinuous_of_continuous', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  notBelow_isOpen.{u_2, u_3} (f y)
at declaration body
  fun {Œ± : Type u_1} {Œ≤ : Type u_2} [OmegaCompletePartialOrder Œ±] [OmegaCompletePartialOrder Œ≤] (f : Scott Œ± ‚Üí Scott Œ≤)
      (hf : _root_.Continuous f) ‚Ü¶
    let_fun h : Monotone f := fun (x y : Scott Œ±) (h : x ‚â§ y) ‚Ü¶
      let_fun hf : IsUpperSet {x : Scott Œ± | ¬¨f x ‚â§ f y} :=
        IsOpen.isUpperSet Œ± (IsOpen.preimage hf (notBelow_isOpen (f y)));
      Eq.mp
        (Eq.trans
          (Eq.trans
            (implies_congr (Eq.refl ¬¨f x ‚â§ f y)
              (Eq.trans (congrArg Not (Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.5 (f y)))
                Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.6))
            Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.7)
          Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.8)
        (hf h);
    Exists.intro h fun (c : Chain (Scott Œ±)) ‚Ü¶
      eq_of_forall_ge_iff fun (z : Scott Œ≤) ‚Ü¶
        Exists.casesOn (IsOpen.preimage hf (notBelow_isOpen z))
          fun (hf : Monotone fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z)
            (hf' :
              OmegaCompletePartialOrder.Continuous { toFun := fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z, monotone' := hf }) ‚Ü¶
          Eq.mpr (id (congrArg (fun (_a : Prop) ‚Ü¶ _a) (Eq.symm (propext not_iff_not))))
            (Eq.mpr
              (id
                (congr
                  (congrArg Iff
                    (Eq.trans
                      (Eq.mp
                        (congr
                          (congrArg (fun (x : Œ± ‚Üío Prop) ‚Ü¶ Eq (x (œâSup c)))
                            ((fun {Œ± : Type u_1} {Œ≤ : Type} [Preorder Œ±] [Preorder Œ≤] (toFun toFun_1 : Œ± ‚Üí Œ≤)
                                  (e_toFun : toFun = toFun_1) ‚Ü¶
                                Eq.rec (motive := fun (toFun_2 : Œ± ‚Üí Œ≤) (e_toFun : toFun = toFun_2) ‚Ü¶
                                  ‚àÄ (monotone' : Monotone toFun),
                                    { toFun := toFun, monotone' := monotone' } =
                                      { toFun := toFun_2, monotone' := e_toFun ‚ñ∏ monotone' })
                                  (fun (monotone' : Monotone toFun) ‚Ü¶
                                    Eq.refl { toFun := toFun, monotone' := monotone' })
                                  e_toFun)
                              (fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z) (fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z)
                              (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf))
                          (congrArg (fun (x : Œ± ‚Üío Prop) ‚Ü¶ œâSup (c.map x))
                            ((fun {Œ± : Type u_1} {Œ≤ : Type} [Preorder Œ±] [Preorder Œ≤] (toFun toFun_1 : Œ± ‚Üí Œ≤)
                                  (e_toFun : toFun = toFun_1) ‚Ü¶
                                Eq.rec (motive := fun (toFun_2 : Œ± ‚Üí Œ≤) (e_toFun : toFun = toFun_2) ‚Ü¶
                                  ‚àÄ (monotone' : Monotone toFun),
                                    { toFun := toFun, monotone' := monotone' } =
                                      { toFun := toFun_2, monotone' := e_toFun ‚ñ∏ monotone' })
                                  (fun (monotone' : Monotone toFun) ‚Ü¶
                                    Eq.refl { toFun := toFun, monotone' := monotone' })
                                  e_toFun)
                              (fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z) (fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z)
                              (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf)))
                        (hf' c))
                      (congrArg Exists
                        (funext fun (a : Prop) ‚Ü¶
                          congrArg (fun (x : Prop) ‚Ü¶ x ‚àß a)
                            (Eq.trans Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.10
                              (congrArg Exists
                                (funext fun (y : ‚Ñï) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.11)))))))
                  (Eq.trans
                    (congrArg Not
                      (Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.9 (c.map { toFun := f, monotone' := h }) z))
                    Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.12)))
              (Or.casesOn
                (Decidable.iff_iff_and_or_not_and_not.mp
                  (Eq.to_iff
                    (Eq.mp
                      (congr
                        (congrArg (fun (x : Œ± ‚Üío Prop) ‚Ü¶ Eq (x (œâSup c)))
                          ((fun {Œ± : Type u_1} {Œ≤ : Type} [Preorder Œ±] [Preorder Œ≤] (toFun toFun_1 : Œ± ‚Üí Œ≤)
                                (e_toFun : toFun = toFun_1) ‚Ü¶
                              Eq.rec (motive := fun (toFun_2 : Œ± ‚Üí Œ≤) (e_toFun : toFun = toFun_2) ‚Ü¶
                                ‚àÄ (monotone' : Monotone toFun),
                                  { toFun := toFun, monotone' := monotone' } =
                                    { toFun := toFun_2, monotone' := e_toFun ‚ñ∏ monotone' })
                                (fun (monotone' : Monotone toFun) ‚Ü¶ Eq.refl { toFun := toFun, monotone' := monotone' })
                                e_toFun)
                            (fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z) (fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z)
                            (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf))
                        (congrArg (fun (x : Œ± ‚Üío Prop) ‚Ü¶ œâSup (c.map x))
                          ((fun {Œ± : Type u_1} {Œ≤ : Type} [Preorder Œ±] [Preorder Œ≤] (toFun toFun_1 : Œ± ‚Üí Œ≤)
                                (e_toFun : toFun = toFun_1) ‚Ü¶
                              Eq.rec (motive := fun (toFun_2 : Œ± ‚Üí Œ≤) (e_toFun : toFun = toFun_2) ‚Ü¶
                                ‚àÄ (monotone' : Monotone toFun),
                                  { toFun := toFun, monotone' := monotone' } =
                                    { toFun := toFun_2, monotone' := e_toFun ‚ñ∏ monotone' })
                                (fun (monotone' : Monotone toFun) ‚Ü¶ Eq.refl { toFun := toFun, monotone' := monotone' })
                                e_toFun)
                            (fun (x : Œ±) ‚Ü¶ x ‚àà f ‚Åª¬π' notBelow z) (fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z)
                            (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf)))
                      (hf' c))))
                (fun
                    (h :
                      ¬¨f (œâSup c) ‚â§ z ‚àß
                        œâSup
                          (c.map
                            { toFun := fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z,
                              monotone' :=
                                (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) ‚ñ∏ hf })) ‚Ü¶
                  And.casesOn h
                    fun (left : ¬¨f (œâSup c) ‚â§ z)
                      (right :
                        œâSup
                          (c.map
                            { toFun := fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z,
                              monotone' :=
                                (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) ‚ñ∏ hf })) ‚Ü¶
                    {
                      mp := fun (a : ‚àÉ (a : Prop), (‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî a) ‚àß a) ‚Ü¶
                        Exists.casesOn a fun (w : Prop) (h : (‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî w) ‚àß w) ‚Ü¶
                          And.casesOn h fun (left : ‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî w) (right : w) ‚Ü¶
                            Exists.casesOn left fun (w_1 : ‚Ñï) (h : ¬¨f (c w_1) ‚â§ z ‚Üî w) ‚Ü¶
                              Or.casesOn (Decidable.iff_iff_and_or_not_and_not.mp h)
                                (fun (h : ¬¨f (c w_1) ‚â§ z ‚àß w) ‚Ü¶
                                  And.casesOn h fun (left : ¬¨f (c w_1) ‚â§ z) (right : w) ‚Ü¶ Exists.intro w_1 left)
                                fun (h : ¬¨¬¨f (c w_1) ‚â§ z ‚àß ¬¨w) ‚Ü¶
                                And.casesOn h fun (left : ¬¨¬¨f (c w_1) ‚â§ z) (right_1 : ¬¨w) ‚Ü¶ absurd right right_1,
                      mpr := fun (a : ‚àÉ (x : ‚Ñï), ¬¨f (c x) ‚â§ z) ‚Ü¶
                        Exists.casesOn a fun (w : ‚Ñï) (h : ¬¨f (c w) ‚â§ z) ‚Ü¶
                          Exists.intro (¬¨f (c w) ‚â§ z) ‚ü®Exists.intro w Iff.rfl, h‚ü© })
                fun
                  (h :
                    ¬¨¬¨f (œâSup c) ‚â§ z ‚àß
                      ¬¨œâSup
                          (c.map
                            { toFun := fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z,
                              monotone' :=
                                (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) ‚ñ∏ hf })) ‚Ü¶
                And.casesOn h
                  fun (left : ¬¨¬¨f (œâSup c) ‚â§ z)
                    (right :
                      ¬¨œâSup
                          (c.map
                            { toFun := fun (x : Œ±) ‚Ü¶ ¬¨f x ‚â§ z,
                              monotone' :=
                                (funext fun (x : Œ±) ‚Ü¶ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) ‚ñ∏ hf })) ‚Ü¶
                  {
                    mp := fun (a : ‚àÉ (a : Prop), (‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî a) ‚àß a) ‚Ü¶
                      Exists.casesOn a fun (w : Prop) (h : (‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî w) ‚àß w) ‚Ü¶
                        And.casesOn h fun (left : ‚àÉ (y : ‚Ñï), ¬¨f (c y) ‚â§ z ‚Üî w) (right : w) ‚Ü¶
                          Exists.casesOn left fun (w_1 : ‚Ñï) (h : ¬¨f (c w_1) ‚â§ z ‚Üî w) ‚Ü¶
                            Or.casesOn (Decidable.iff_iff_and_or_not_and_not.mp h)
                              (fun (h : ¬¨f (c w_1) ‚â§ z ‚àß w) ‚Ü¶
                                And.casesOn h fun (left : ¬¨f (c w_1) ‚â§ z) (right : w) ‚Ü¶ Exists.intro w_1 left)
                              fun (h : ¬¨¬¨f (c w_1) ‚â§ z ‚àß ¬¨w) ‚Ü¶
                              And.casesOn h fun (left : ¬¨¬¨f (c w_1) ‚â§ z) (right_1 : ¬¨w) ‚Ü¶ absurd right right_1,
                    mpr := fun (a : ‚àÉ (x : ‚Ñï), ¬¨f (c x) ‚â§ z) ‚Ü¶
                      Exists.casesOn a fun (w : ‚Ñï) (h : ¬¨f (c w) ‚â§ z) ‚Ü¶
                        Exists.intro (¬¨f (c w) ‚â§ z) ‚ü®Exists.intro w Iff.rfl, h‚ü© }))",theorem notBelow_isOpen : IsOpen (notBelow y) ,":= by
  have h : Monotone (notBelow y) := fun x z hle ‚Ü¶ mt hle.trans
  refine ‚ü®h, fun c ‚Ü¶ eq_of_forall_ge_iff fun z ‚Ü¶ ?_‚ü©
  simp only [œâSup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]",":= by
  have h : Monotone (notBelow y) := fun x z hle ‚Ü¶ mt hle.trans
  change œâScottContinuous fun x ‚Ü¶ x ‚àà (notBelow y)
  rw [‚Üê continuous'_iff_œâScottContinuous]
  refine ‚ü®h, fun c ‚Ü¶ eq_of_forall_ge_iff fun z ‚Ü¶ ?_‚ü©
  simp only [œâSup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]"
Mathlib/Geometry/Manifold/VectorBundle/Basic.lean,Bundle.contMDiffWithinAt_totalSpace,contMDiffWithinAt_totalSpace,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe, extChartAt_self_apply,
    modelWithCornersSelf_coe, id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]","error:  ambiguous, possible interpretations 
  _root_.id_def : ‚àÄ (a : ?m.25447), id a = a
  
  Function.id_def : id = fun x ‚Ü¶ x
error:  simp made no progress","theorem contMDiffWithinAt_totalSpace (f : M ‚Üí TotalSpace F E) {s : Set M} {x‚ÇÄ : M} :
    ContMDiffWithinAt IM (IB.prod ùìò(ùïú, F)) n f s x‚ÇÄ ‚Üî
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s x‚ÇÄ ‚àß
      ContMDiffWithinAt IM ùìò(ùïú, F) n (fun x ‚Ü¶ (trivializationAt F E (f x‚ÇÄ).proj (f x)).2) s x‚ÇÄ ",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,
    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, ‚Üê chartedSpaceSelf_prod]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ‚Üê FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe, extChartAt_self_apply,
    modelWithCornersSelf_coe, id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ‚Åª¬π' (trivializationAt F E (f x‚ÇÄ).proj).baseSet ‚àà ùìù[s] x‚ÇÄ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  ¬∑ simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  ¬∑ simp only [mfld_simps]"
Mathlib/Logic/Equiv/List.lean,Denumerable.lower_raise,lower_raise,2235ae5100e2af7f16bea313637531b24bf8e1e0,"  | [], n => rfl
  | m :: l, n => by rw [raise, lower, add_tsub_cancel_right, lower_raise l]","error:  failed to synthesize
  OrderedSub ‚Ñï
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  ContravariantClass ‚Ñï ‚Ñï (fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : Denumerable Œ±
inst‚úù : Denumerable Œ≤
m : ‚Ñï
l : List ‚Ñï
n : ‚Ñï
‚ä¢ OrderedSub ‚Ñï

Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : Denumerable Œ±
inst‚úù : Denumerable Œ≤
m : ‚Ñï
l : List ‚Ñï
n : ‚Ñï
‚ä¢ ContravariantClass ‚Ñï ‚Ñï (fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1","theorem lower_raise : ‚àÄ l n, lower (raise l n) n = l
","  | [], n => rfl
  | m :: l, n => by rw [raise, lower, Nat.add_sub_cancel_right, lower_raise l]",":=
  | [], n => rfl
  | m :: l, n => by rw [raise, lower, add_tsub_cancel_right, lower_raise l]"
Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean,Finset.mul_pluennecke_petridis,mul_pluennecke_petridis,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  induction' C using Finset.induction_on with x C _ ih
  ¬∑ simp
  set A' := A ‚à© (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have h‚ÇÄ : A' * {x} = A * {x} ‚à© (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have h‚ÇÅ : A * B * C' = A * B * C ‚à™ (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine' (sup_sdiff_eq_sup _).symm
    rw [mul_right_comm, mul_right_comm A, h‚ÇÄ]
    exact mul_subset_mul_right (inter_subset_right _ _)
  have h‚ÇÇ : A' * B * {x} ‚äÜ A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right <| inter_subset_left _ _)
  have h‚ÇÉ : (A * B * C').card ‚â§ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [h‚ÇÅ]
    refine' (card_union_le _ _).trans_eq _
    rw [card_sdiff h‚ÇÇ, ‚Üê add_tsub_assoc_of_le (card_le_card h‚ÇÇ), card_mul_singleton,
      card_mul_singleton]
  refine' (mul_le_mul_right' h‚ÇÉ _).trans _
  rw [tsub_mul, add_mul]
  refine' (tsub_le_tsub (add_le_add_right ih _) <| hA _ <| inter_subset_left _ _).trans_eq _
  rw [‚Üê mul_add, ‚Üê mul_tsub, ‚Üê hA', hC', insert_eq, mul_union, ‚Üê card_mul_singleton A x, ‚Üê
    card_mul_singleton A' x, add_comm (card _), h‚ÇÄ,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]","error:  function expected at
  inter_subset_right ?m.23523
term has type
  ?m.23522 ‚àà ?m.23521
error:  function expected at
  inter_subset_left ?m.25626
term has type
  ?m.25625 ‚àà ?m.25623
error:  function expected at
  inter_subset_left ?m.30577
term has type
  ?m.30576 ‚àà ?m.30574
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  A ‚à© (A * C / {x})
case insert
Œ± : Type u_1
inst‚úù¬π : CommGroup Œ±
inst‚úù : DecidableEq Œ±
A B C‚úù : Finset Œ±
hA : ‚àÄ A' ‚äÜ A, (A * B).card * A'.card ‚â§ (A' * B).card * A.card
x : Œ±
C : Finset Œ±
a‚úù : x ‚àâ C
ih : (A * B * C).card * A.card ‚â§ (A * B).card * (A * C).card
A' : Finset Œ± := A ‚à© (A * C / {x})
hA' : A' = A ‚à© (A * C / {x})
C' : Finset Œ± := insert x C
hC' : C' = insert x C
h‚ÇÄ : A' * {x} = A * {x} ‚à© (A * C)
h‚ÇÅ : A * B * C' = A * B * C ‚à™ (A * B * {x}) \ (A' * B * {x})
h‚ÇÇ : A' * B * {x} ‚äÜ A * B * {x}
h‚ÇÉ : (A * B * C').card ‚â§ (A * B * C).card + (A * B).card - (A' * B).card
‚ä¢ (A * B).card * ((A * C).card + A.card - A'.card) = (A * B).card * (A * C').card","theorem mul_pluennecke_petridis (C : Finset Œ±)
    (hA : ‚àÄ A' ‚äÜ A, (A * B).card * A'.card ‚â§ (A' * B).card * A.card) :
    (A * B * C).card * A.card ‚â§ (A * B).card * (A * C).card ",":= by
  induction' C using Finset.induction_on with x C _ ih
  ¬∑ simp
  set A' := A ‚à© (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have h‚ÇÄ : A' * {x} = A * {x} ‚à© (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have h‚ÇÅ : A * B * C' = A * B * C ‚à™ (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine (sup_sdiff_eq_sup ?_).symm
    rw [mul_right_comm, mul_right_comm A, h‚ÇÄ]
    exact mul_subset_mul_right inter_subset_right
  have h‚ÇÇ : A' * B * {x} ‚äÜ A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right inter_subset_left)
  have h‚ÇÉ : (A * B * C').card ‚â§ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [h‚ÇÅ]
    refine (card_union_le _ _).trans_eq ?_
    rw [card_sdiff h‚ÇÇ, ‚Üê add_tsub_assoc_of_le (card_le_card h‚ÇÇ), card_mul_singleton,
      card_mul_singleton]
  refine (mul_le_mul_right' h‚ÇÉ _).trans ?_
  rw [tsub_mul, add_mul]
  refine (tsub_le_tsub (add_le_add_right ih _) <| hA _ inter_subset_left).trans_eq ?_
  rw [‚Üê mul_add, ‚Üê mul_tsub, ‚Üê hA', hC', insert_eq, mul_union, ‚Üê card_mul_singleton A x, ‚Üê
    card_mul_singleton A' x, add_comm (card _), h‚ÇÄ,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]",":= by
  induction' C using Finset.induction_on with x C _ ih
  ¬∑ simp
  set A' := A ‚à© (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have h‚ÇÄ : A' * {x} = A * {x} ‚à© (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have h‚ÇÅ : A * B * C' = A * B * C ‚à™ (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine (sup_sdiff_eq_sup ?_).symm
    rw [mul_right_comm, mul_right_comm A, h‚ÇÄ]
    exact mul_subset_mul_right inter_subset_right
  have h‚ÇÇ : A' * B * {x} ‚äÜ A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right inter_subset_left)
  have h‚ÇÉ : (A * B * C').card ‚â§ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [h‚ÇÅ]
    refine (card_union_le _ _).trans_eq ?_
    rw [card_sdiff h‚ÇÇ, ‚Üê add_tsub_assoc_of_le (card_le_card h‚ÇÇ), card_mul_singleton,
      card_mul_singleton]
  refine (mul_le_mul_right' h‚ÇÉ ?_).trans ?_
  rw [tsub_mul, add_mul]
  refine (tsub_le_tsub (add_le_add_right ih _) <| hA _ <| inter_subset_left).trans_eq ?_
  rw [‚Üê mul_add, ‚Üê mul_tsub, ‚Üê hA', hC', insert_eq, mul_union, ‚Üê card_mul_singleton A x, ‚Üê
    card_mul_singleton A' x, add_comm (card _), h‚ÇÄ,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]"
Mathlib/Algebra/BigOperators/Finprod.lean,finprod_mul_distrib,finprod_mul_distrib,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset _ hf (Finset.subset_union_left _ _),
      finprod_eq_prod_of_mulSupport_toFinset_subset _ hg (Finset.subset_union_right _ _), ‚Üê
      Finset.prod_mul_distrib]
    refine' finprod_eq_prod_of_mulSupport_subset _ _
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf, hg‚ü©
    simp [hf, hg]","error:  function expected at
  Finset.subset_union_left ?m.86793
term has type
  ?m.86792 ‚àà ?m.86790 ‚à™ ?m.86791
error:  function expected at
  Finset.subset_union_right ?m.86952
term has type
  ?m.86951 ‚àà ?m.86949 ‚à™ ?m.86950
error:  simp made no progress","theorem finprod_mul_distrib (hf : (mulSupport f).Finite) (hg : (mulSupport g).Finite) :
    ‚àè·∂† i, f i * g i = (‚àè·∂† i, f i) * ‚àè·∂† i, g i ",":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset f hf Finset.subset_union_left,
      finprod_eq_prod_of_mulSupport_toFinset_subset g hg Finset.subset_union_right, ‚Üê
      Finset.prod_mul_distrib]
    refine finprod_eq_prod_of_mulSupport_subset _ ?_
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf, hg‚ü©
    simp [hf, hg]",":= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset _ hf (Finset.subset_union_left,
      finprod_eq_prod_of_mulSupport_toFinset_subset _ hg (Finset.subset_union_right), ‚Üê
      Finset.prod_mul_distrib]
    refine finprod_eq_prod_of_mulSupport_subset ?_ ?_
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ‚ü®hf, hg‚ü©
    simp [hf, hg]"
Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean,CochainComplex.HomComplex.Œ¥_shape,Œ¥_shape,9072ff84a0d139a344bf9eed4a00c4cd27596c79,":= by
  ext p q hpq
  dsimp [Œ¥, Cochain.v, Cochain.mk]
  rw [F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  ¬∑ rfl
  all_goals
    change ¬¨ _=_
    rintro h
    apply hnm
    linarith","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case h.a
C : Type u
inst‚úù¬≥ : Category.{v, u} C
inst‚úù¬≤ : Preadditive C
R : Type u_1
inst‚úù¬π : Ring R
inst‚úù : Linear R C
F G K L : CochainComplex C ‚Ñ§
n m : ‚Ñ§
hnm : ¬¨n + 1 = m
z : Cochain F G n
p q : ‚Ñ§
hpq : p + m = q
‚ä¢ ¬¨(ComplexShape.up ‚Ñ§).Rel (p + n) q",lemma Œ¥_shape (hnm : ¬¨ n + 1 = m) (z : Cochain F G n) : Œ¥ n m z = 0 ,":= by
  ext p q hpq
  dsimp only [Œ¥]
  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  all_goals
    simp only [ComplexShape.up_Rel]
    exact fun _ => hnm (by omega)",":= by
  ext p q hpq
  dsimp [Œ¥, Cochain.v, Cochain.mk]
  rw [F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  ¬∑ rfl
  all_goals
    change ¬¨ _=>
    rintro h
    apply hnm
    linarith"
Mathlib/Topology/Sheaves/SheafCondition/UniqueGluing.lean,TopCat.Presheaf.isSheaf_of_isSheafUniqueGluing_types,isSheaf_of_isSheafUniqueGluing_types,4cf1162dddb1c9eb77df8a17815b1dea87bb892c,":= by
  rw [isSheaf_iff_isSheafEqualizerProducts]
  intro Œπ U
  refine' ‚ü®Fork.IsLimit.mk' _ _‚ü©
  intro s
  have h_compatible :
    ‚àÄ x : s.pt, F.IsCompatible U ((F.piOpensIsoSectionsFamily U).hom (s.Œπ x)) := by
    intro x
    rw [compatible_iff_leftRes_eq_rightRes]
    convert congr_fun s.condition x
  choose m m_spec m_uniq using fun x : s.pt =>
    Fsh U ((piOpensIsoSectionsFamily F U).hom (s.Œπ x)) (h_compatible x)
  refine' ‚ü®m, _, _‚ü©
  ¬∑ 
    refine limit.hom_ext fun ‚ü®i‚ü© => funext fun x => ?_
    simp [res]
    exact m_spec x i
  ¬∑ intro l hl
    ext x
    apply m_uniq
    rw [isGluing_iff_eq_res]
    exact congr_fun hl x","error:  unknown identifier 'isSheaf_iff_isSheafEqualizerProducts'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.14468
C : Type u
inst‚úù¬π : Category.{v, u} C
inst‚úù : ConcreteCategory C
X : TopCat
F : Presheaf (Type u) X
Œπ : Type x
U : Œπ ‚Üí Opens ‚ÜëX
Fsh : F.IsSheafUniqueGluing
‚ä¢ F.IsSheaf",theorem isSheaf_of_isSheafUniqueGluing_types (Fsh : F.IsSheafUniqueGluing) : F.IsSheaf ,":=
  (isSheaf_iff_isSheafUniqueGluing_types F).mpr Fsh",":= by
  rw [isSheaf_iff_isSheafEqualizerProducts]
  intro Œπ U
  refine ‚ü®Fork.IsLimit.mk' _ ?_‚ü©
  intro s
  have h_compatible :
    ‚àÄ x : s.pt, F.IsCompatible U ((F.piOpensIsoSectionsFamily U).hom (s.Œπ x)) := by
    intro x
    rw [compatible_iff_leftRes_eq_rightRes]
    convert congr_fun s.condition x
  choose m m_spec m_uniq using fun x : s.pt =>
    Fsh U ((piOpensIsoSectionsFamily F U).hom (s.Œπ x)) (h_compatible x)
  refine ‚ü®m, ?_, ?_‚ü©
  ¬∑ 
    refine limit.hom_ext fun ‚ü®i‚ü© => funext fun x => ?_
    simp [res]
    exact m_spec x i
  ¬∑ intro l hl
    ext x
    apply m_uniq
    rw [isGluing_iff_eq_res]
    exact congr_fun hl x"
Mathlib/Algebra/Category/ModuleCat/Free.lean,ModuleCat.linearIndependent_leftExact,linearIndependent_leftExact,b87ae0155ddc0e5ed5896dcbc918e59a3d30fc43,":=
  linearIndependent_sum.mpr
  ‚ü®(congr_arg (fun f ‚Ü¶ LinearIndependent R f) huv).mpr
    ((LinearMap.linearIndependent_iff (f : N ‚Üí‚Çó[R] M)
    (LinearMap.ker_eq_bot.mpr ((mono_iff_injective _).mp hm))).mpr hv),
    LinearIndependent.of_comp g hw, disjoint_span_sum hw hu he huv‚ü©","error:  unknown identifier 'N'
error:  unknown identifier 'M'
error:  unknown identifier 'f'
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'linearIndependent_leftExact'
error:  application type mismatch
  linearIndependent_shortExact hS'
argument
  hS'
has type
  S.ShortExact : Prop
but is expected to have type
  LinearIndependent ?m.67223 ?m.67227 : Prop",theorem linearIndependent_leftExact : LinearIndependent R u ,":= by
  rw [linearIndependent_sum]
  refine ‚ü®?_, LinearIndependent.of_comp S.g hw, disjoint_span_sum hS hw huv‚ü©
  rw [huv, LinearMap.linearIndependent_iff S.f]; swap
  ¬∑ rw [LinearMap.ker_eq_bot, ‚Üê mono_iff_injective]
    infer_instance
  exact hv",":=
  linearIndependent_sum.mpr
  ‚ü®(congr_arg (fun f ‚Ü¶ LinearIndependent R f) huv).mpr
    ((LinearMap.linearIndependent_iff (f : N ‚Üí‚Çó[R] M)
    (LinearMap.ker_eq_bot.mpr ((mono_iff_injective _).mp hm))).mpr hv),
    LinearIndependent.of_comp g hw, disjoint_span_sum hw he huv‚ü©"
Mathlib/Algebra/Polynomial/Module/Basic.lean,PolynomialModule.monomial_smul_single,monomial_smul_single,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp only [LinearMap.mul_apply, Polynomial.aeval_monomial, LinearMap.pow_apply,
    Module.algebraMap_end_apply, smul_def]
  induction i generalizing r j m with
  | zero =>
    rw [Nat.zero_eq, Function.iterate_zero, zero_add]
    exact Finsupp.smul_single r j m
  | succ n hn =>
    rw [Function.iterate_succ, Function.comp_apply, Nat.succ_eq_add_one, add_assoc, ‚Üê hn]
    congr 2
    rw [Nat.one_add]
    exact Finsupp.mapDomain_single","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case zero
R : Type u_1
M : Type u_2
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : AddCommGroup M
inst‚úù‚Å¥ : Module R M
I : Ideal R
S : Type u_3
inst‚úù¬≥ : CommSemiring S
inst‚úù¬≤ : Algebra S R
inst‚úù¬π : Module S M
inst‚úù : IsScalarTower S R M
r : R
j : ‚Ñï
m : M
‚ä¢ r ‚Ä¢ (‚áë(Finsupp.lmapDomain M R Nat.succ))^[0] ((single R j) m) = (single R (0 + j)) (r ‚Ä¢ m)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
R : Type u_1
M : Type u_2
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : AddCommGroup M
inst‚úù‚Å¥ : Module R M
I : Ideal R
S : Type u_3
inst‚úù¬≥ : CommSemiring S
inst‚úù¬≤ : Algebra S R
inst‚úù¬π : Module S M
inst‚úù : IsScalarTower S R M
n : ‚Ñï
hn :
  ‚àÄ (r : R) (j : ‚Ñï) (m : M), r ‚Ä¢ (‚áë(Finsupp.lmapDomain M R Nat.succ))^[n] ((single R j) m) = (single R (n + j)) (r ‚Ä¢ m)
r : R
j : ‚Ñï
m : M
‚ä¢ r ‚Ä¢ (‚áë(Finsupp.lmapDomain M R Nat.succ))^[n] ((Finsupp.lmapDomain M R Nat.succ) ((single R j) m)) =
    (single R (n + 1 + j)) (r ‚Ä¢ m)","theorem monomial_smul_single (i : ‚Ñï) (r : R) (j : ‚Ñï) (m : M) :
    monomial i r ‚Ä¢ single R j m = single R (i + j) (r ‚Ä¢ m) ",":= by
  simp only [LinearMap.mul_apply, Polynomial.aeval_monomial, LinearMap.pow_apply,
    Module.algebraMap_end_apply, smul_def]
  induction i generalizing r j m with
  | zero =>
    rw [Function.iterate_zero, zero_add]
    exact Finsupp.smul_single r j m
  | succ n hn =>
    rw [Function.iterate_succ, Function.comp_apply, add_assoc, ‚Üê hn]
    congr 2
    rw [Nat.one_add]
    exact Finsupp.mapDomain_single",":= by
  simp only [LinearMap.mul_apply, Polynomial.aeval_monomial, LinearMap.pow_apply,
    Module.algebraMap_end_apply, smul_def]
  induction i generalizing r j m with
  | zero =>
    rw [Nat.zero_eq, Function.iterate_zero, zero_add]
    exact Finsupp.smul_single r j m
  | succ n hn =>
    rw [Nat.iterate_succ, Function.comp_apply, Nat.succ_eq_add_one, add_assoc, ‚Üê hn]
    congr 2
    rw [Nat.one_add]
    exact Finsupp.mapDomain_single"
Mathlib/Data/DFinsupp/Basic.lean,DFinsupp.prod_add_index,prod_add_index,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":=
  have f_eq : (‚àè i in f.support ‚à™ g.support, h i (f i)) = f.prod h :=
    (Finset.prod_subset (Finset.subset_union_left _ _) <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (‚àè i in f.support ‚à™ g.support, h i (g i)) = g.prod h :=
    (Finset.prod_subset (Finset.subset_union_right _ _) <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  calc
    (‚àè i in (f + g).support, h i ((f + g) i)) = ‚àè i in f.support ‚à™ g.support, h i ((f + g) i) :=
      Finset.prod_subset support_add <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]
    _ = (‚àè i in f.support ‚à™ g.support, h i (f i)) * ‚àè i in f.support ‚à™ g.support, h i (g i) := by
      { simp [h_add, Finset.prod_mul_distrib] }
    _ = _ := by rw [f_eq, g_eq]","error:  function expected at
  Finset.subset_union_left ?m.703129
term has type
  ?m.703128 ‚àà ?m.703126 ‚à™ ?m.703127
error:  function expected at
  Finset.subset_union_right ?m.703451
term has type
  ?m.703450 ‚àà ?m.703448 ‚à™ ?m.703449","theorem prod_add_index [‚àÄ i, AddCommMonoid (Œ≤ i)] [‚àÄ (i) (x : Œ≤ i), Decidable (x ‚â† 0)]
    [CommMonoid Œ≥] {f g : Œ†‚ÇÄ i, Œ≤ i} {h : ‚àÄ i, Œ≤ i ‚Üí Œ≥} (h_zero : ‚àÄ i, h i 0 = 1)
    (h_add : ‚àÄ i b‚ÇÅ b‚ÇÇ, h i (b‚ÇÅ + b‚ÇÇ) = h i b‚ÇÅ * h i b‚ÇÇ) : (f + g).prod h = f.prod h * g.prod h ",":=
  have f_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (f i)) = f.prod h :=
    (Finset.prod_subset Finset.subset_union_left <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (g i)) = g.prod h :=
    (Finset.prod_subset Finset.subset_union_right <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  calc
    (‚àè i ‚àà (f + g).support, h i ((f + g) i)) = ‚àè i ‚àà f.support ‚à™ g.support, h i ((f + g) i) :=
      Finset.prod_subset support_add <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]
    _ = (‚àè i ‚àà f.support ‚à™ g.support, h i (f i)) * ‚àè i ‚àà f.support ‚à™ g.support, h i (g i) := by
      { simp [h_add, Finset.prod_mul_distrib] }
    _ = _ := by rw [f_eq, g_eq]",":=
  have f_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (f i)) = f.prod h :=
    (Finset.prod_subset (Finset.subset_union_left <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (g i)) = g.prod h :=
    (Finset.prod_subset (Finset.subset_union_right <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (g i)) = g.prod h :=
    (Finset.prod_subset (Finset.subset_union_right <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (‚àè i ‚àà f.support ‚à™ g.support, h i (g i)) = g.prod h :=
    (Finset.prod_subset (Finset.subset_union_right <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  calc
    (‚àè i ‚àà (f + g).support, h i ((f + g) i)) = ‚àè i ‚àà f.support ‚à™ g.support, h i (g i) :=
      Finset.prod_subset support_add <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  calc
    (‚àè i ‚àà (f + g).support, h i ((f + g) i)) = ‚àè i ‚àà f.support ‚à™ g.support, h i (g i) :=
      Finset.prod_subset support_add <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  calc
    (‚àè i ‚àà (f + g).support, h i ((f + g) i)) = ‚àè i ‚àà f.support ‚à™ g.support, h i (g i) := by
      { simp [h_add, Finset.prod_mul_distrib] }
    _ = _ := by rw [f_eq, g_eq]"
Mathlib/CategoryTheory/MorphismProperty/Basic.lean,CategoryTheory.MorphismProperty.map_id_eq_isoClosure,map_id_eq_isoClosure,6830b5e612c6f4431fee7e89ec01560ae5118e5e,":= by
  apply subset_antisymm
  ¬∑ rw [map_subset_iff _ _ _ P.isoClosure_respectsIso]
    intro X Y f hf
    exact P.subset_isoClosure _ hf
  ¬∑ intro X Y f hf
    exact hf","error:  failed to synthesize
  HasSubset (MorphismProperty C)
use `set_option diagnostics true` to get diagnostic information","lemma map_id_eq_isoClosure (P : MorphismProperty C) :
    P.map (ùü≠ _) = P.isoClosure ",":= by
  apply le_antisymm
  ¬∑ rw [map_le_iff P.isoClosure_respectsIso]
    intro X Y f hf
    exact P.le_isoClosure _ hf
  ¬∑ intro X Y f hf
    exact hf",":= by
  apply subset_antisymm
  ¬∑ rw [map_subset_iff _ _ P.isoClosure_respectsIso]
    intro X Y f hf
    exact hf"
Mathlib/RingTheory/DedekindDomain/FiniteAdeleRing.lean,DedekindDomain.ProdAdicCompletions.IsFiniteAdele.one,one,39b465c300b32fbcfed8cc0269db25884e291c91,":= by
  rw [IsFiniteAdele, Filter.eventually_cofinite]
  have h_empty :
    {v : HeightOneSpectrum R | ¬¨(1 : v.adicCompletion K) ‚àà v.adicCompletionIntegers K} = ‚àÖ := by
    ext v; rw [mem_empty_iff_false, iff_false_iff]; intro hv
    rw [mem_setOf] at hv ; apply hv; rw [mem_adicCompletionIntegers]
    exact le_of_eq Valued.v.map_one'
  simp_rw [Pi.one_apply, h_empty]
  convert finite_empty",error:  simp made no progress,theorem one : (1 : K_hat R K).IsFiniteAdele ,":= by
  rw [IsFiniteAdele, Filter.eventually_cofinite]
  have h_empty :
    {v : HeightOneSpectrum R | ¬¨(1 : v.adicCompletion K) ‚àà v.adicCompletionIntegers K} = ‚àÖ := by
    ext v; rw [mem_empty_iff_false, iff_false_iff]; intro hv
    rw [mem_setOf] at hv; apply hv; rw [mem_adicCompletionIntegers]
    exact le_of_eq Valued.v.map_one'
  convert finite_empty",":= by
  rw [IsFiniteAdele, Filter.eventually_cofinite]
  have h_empty :
    {v : HeightOneSpectrum R | ¬¨(1 : v.adicCompletion K) ‚àà v.adicCompletionIntegers K} = ‚àÖ := by
    ext v; rw [mem_empty_iff_false, iff_false_iff]; intro hv
    rw [mem_setOf] at hv ; apply hv; rw [mem_adicCompletionIntegers]
    exact le_of_eq Valued.v.map_one'
  simp_rw [Pi.one_apply, h_empty]"
Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean,Complex.continuousAt_ofReal_cpow,continuousAt_ofReal_cpow,2009db69c1211eafea457d1c3902f31370dac23f,":= by
  rcases lt_trichotomy (0 : ‚Ñù) x with (hx | rfl | hx)
  ¬∑ 
    have : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    refine' (continuousAt_cpow (Or.inl _)).comp this
    rwa [ofReal_re]
  ¬∑ 
    have A : ContinuousAt (fun p => p.1 ^ p.2 : ‚ÑÇ √ó ‚ÑÇ ‚Üí ‚ÑÇ) ‚ü®‚Üë(0 : ‚Ñù), y‚ü© := by
      rw [ofReal_zero]
      apply continuousAt_cpow_zero_of_re_pos
      tauto
    have B : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) ‚ü®0, y‚ü© :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    exact @ContinuousAt.comp (‚Ñù √ó ‚ÑÇ) (‚ÑÇ √ó ‚ÑÇ) ‚ÑÇ _ _ _ _ (fun p => ‚ü®‚Üëp.1, p.2‚ü©) ‚ü®0, y‚ü© A B
  ¬∑ 
    suffices ContinuousAt (fun p => (-(p.1 : ‚ÑÇ)) ^ p.2 * exp (œÄ * I * p.2) : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine' this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) _)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) :=
      ContinuousAt.prod_map continuous_ofReal.continuousAt.neg continuousAt_id
    apply ContinuousAt.mul
    ¬∑ refine' (continuousAt_cpow (Or.inl _)).comp A
      rwa [neg_re, ofReal_re, neg_pos]
    ¬∑ exact (continuous_exp.comp (continuous_const.mul continuous_snd)).continuousAt","error:  application type mismatch
  @ContinuousAt.comp (‚Ñù √ó ‚ÑÇ) (‚ÑÇ √ó ‚ÑÇ) ‚ÑÇ ?m.62391 ?m.62392 ?m.62393 ?m.62394 fun p ‚Ü¶ ?m.62402 p
argument
  fun p ‚Ü¶ ?m.62402 p
has type
  (p : ?m.62396) ‚Üí ?m.62401 p : Sort (imax ?u.62395 ?u.62398)
but is expected to have type
  ‚Ñù √ó ‚ÑÇ : Type
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  ‚ÑÇ √ó ‚ÑÇ ‚Üí ‚ÑÇ
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  ?m.62401 p","theorem continuousAt_ofReal_cpow (x : ‚Ñù) (y : ‚ÑÇ) (h : 0 < y.re ‚à® x ‚â† 0) :
    ContinuousAt (fun p => (p.1 : ‚ÑÇ) ^ p.2 : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) ",":= by
  rcases lt_trichotomy (0 : ‚Ñù) x with (hx | rfl | hx)
  ¬∑ 
    have : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    refine (continuousAt_cpow (Or.inl ?_)).comp this
    rwa [ofReal_re]
  ¬∑ 
    have A : ContinuousAt (fun p => p.1 ^ p.2 : ‚ÑÇ √ó ‚ÑÇ ‚Üí ‚ÑÇ) ‚ü®‚Üë(0 : ‚Ñù), y‚ü© := by
      rw [ofReal_zero]
      apply continuousAt_cpow_zero_of_re_pos
      tauto
    have B : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) ‚ü®0, y‚ü© :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    exact A.comp_of_eq B rfl
  ¬∑ 
    suffices ContinuousAt (fun p => (-(p.1 : ‚ÑÇ)) ^ p.2 * exp (œÄ * I * p.2) : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) :=
      ContinuousAt.prod_map continuous_ofReal.continuousAt.neg continuousAt_id
    apply ContinuousAt.mul
    ¬∑ refine (continuousAt_cpow (Or.inl ?_)).comp A
      rwa [neg_re, ofReal_re, neg_pos]
    ¬∑ exact (continuous_exp.comp (continuous_const.mul continuous_snd)).continuousAt",":= by
  rcases lt_trichotomy (0 : ‚Ñù) x with (hx | rfl | hx)
  ¬∑ 
    have : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    refine (continuousAt_cpow (Or.inl ?_)).comp this
    rwa [ofReal_re]
  ¬∑ 
    have A : ContinuousAt (fun p => p.1 ^ p.2 : ‚ÑÇ √ó ‚ÑÇ ‚Üí ‚ÑÇ) ‚ü®‚Üë(0 : ‚Ñù), y‚ü© := by
      rw [ofReal_zero]
      apply continuousAt_cpow_zero_of_re_pos
      tauto
    have B : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) ‚ü®0, y‚ü© :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    exact @ContinuousAt.comp (‚Ñù √ó ‚ÑÇ) (‚ÑÇ √ó ‚ÑÇ) ‚ÑÇ _ _ _ _ (fun p => ‚ü®‚Üëp.1, p.2‚ü©) ‚ü®0, y‚ü© A B
  ¬∑ 
    suffices ContinuousAt (fun p => (-(p.1 : ‚ÑÇ)) ^ p.2 * exp (œÄ * I * p.2) : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (f"
Mathlib/LinearAlgebra/Span.lean,Submodule.iSup_toAddSubmonoid,iSup_toAddSubmonoid,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  refine le_antisymm (fun x => ?_) (iSup_le fun i => toAddSubmonoid_mono <| le_iSup _ i)
  simp_rw [iSup_eq_span, AddSubmonoid.iSup_eq_closure, mem_toAddSubmonoid, coe_toAddSubmonoid]
  intro hx
  refine Submodule.span_induction hx (fun x hx => ?_)? _ (fun x y hx hy => ?_) fun r x hx => ?_
  ¬∑ exact AddSubmonoid.subset_closure hx
  ¬∑ exact AddSubmonoid.zero_mem _
  ¬∑ exact AddSubmonoid.add_mem _ hx hy
  ¬∑ refine AddSubmonoid.closure_induction hx ?_ ?_ ?_
    ¬∑ rintro x ‚ü®_, ‚ü®i, rfl‚ü©, hix : x ‚àà p i‚ü©
      apply AddSubmonoid.subset_closure (Set.mem_iUnion.mpr ‚ü®i, _‚ü©)
      exact smul_mem _ r hix
    ¬∑ rw [smul_zero]
      exact AddSubmonoid.zero_mem _
    ¬∑ intro x y hx hy
      rw [smul_add]
      exact AddSubmonoid.add_mem _ hx hy","error:  failed to elaborate eliminator, insufficient number of arguments, expected type:
  x ‚àà AddSubmonoid.closure (‚ãÉ i, ‚Üë(p i))
error:  unexpected token '?'; expected 'binder_predicate'","theorem iSup_toAddSubmonoid {Œπ : Sort*} (p : Œπ ‚Üí Submodule R M) :
    (‚®Ü i, p i).toAddSubmonoid = ‚®Ü i, (p i).toAddSubmonoid ",":= by
  refine le_antisymm (fun x => ?_) (iSup_le fun i => toAddSubmonoid_mono <| le_iSup _ i)
  simp_rw [iSup_eq_span, AddSubmonoid.iSup_eq_closure, mem_toAddSubmonoid, coe_toAddSubmonoid]
  intro hx
  refine Submodule.span_induction hx (fun x hx => ?_) ?_ (fun x y hx hy => ?_) fun r x hx => ?_
  ¬∑ exact AddSubmonoid.subset_closure hx
  ¬∑ exact AddSubmonoid.zero_mem _
  ¬∑ exact AddSubmonoid.add_mem _ hx hy
  ¬∑ refine AddSubmonoid.closure_induction hx ?_ ?_ ?_
    ¬∑ rintro x ‚ü®_, ‚ü®i, rfl‚ü©, hix : x ‚àà p i‚ü©
      apply AddSubmonoid.subset_closure (Set.mem_iUnion.mpr ‚ü®i, _‚ü©)
      exact smul_mem _ r hix
    ¬∑ rw [smul_zero]
      exact AddSubmonoid.zero_mem _
    ¬∑ intro x y hx hy
      rw [smul_add]
      exact AddSubmonoid.add_mem _ hx hy",":= by
  refine le_antisymm (fun x => ?_) (iSup_le fun i => toAddSubmonoid_mono <| le_iSup _ i)
  simp_rw [iSup_eq_span, AddSubmonoid.iSup_eq_closure, mem_toAddSubmonoid, coe_toAddSubmonoid]
  intro hx
  refine Submodule.span_induction hx (fun x hx => ?_) (fun x y hx hy => ?_) fun r x hx => ?_
  ¬∑ exact AddSubmonoid.subset_closure hx
  ¬∑ exact AddSubmonoid.zero_mem _
  ¬∑ exact AddSubmonoid.add_mem _ hx hy
  ¬∑ refine AddSubmonoid.closure_induction hx ?_ ?_ ?_
    ¬∑ rintro x ‚ü®_, ‚ü®i, rfl‚ü©, hix : x ‚àà p i‚ü©
      apply AddSubmonoid.subset_closure (Set.mem_iUnion.mpr ‚ü®i, ?_‚ü©)
      exact smul_mem _ r hix
    ¬∑ rw [smul_zero]
      exact AddSubmonoid.zero_mem _
    ¬∑ intro x y hx hy
      rw [smul_add]
      exact AddSubmonoid.add_mem _ hx hy"
Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean,Collinear.oangle_sign_of_sameRay_vsub,_root_.Collinear.oangle_sign_of_sameRay_vsub,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _
          (Set.mem_singleton _)))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÉ‚ÇÑ
    rw [‚Üê Real.Angle.sign_eq_zero_iff] at hs‚ÇÅ‚ÇÖ‚ÇÇ hs‚ÇÉ‚ÇÖ‚ÇÑ
    rw [hs‚ÇÅ‚ÇÖ‚ÇÇ, hs‚ÇÉ‚ÇÖ‚ÇÑ]
  ¬∑ let s : Set (P √ó P √ó P) :=
      (fun x : line[‚Ñù, p‚ÇÅ, p‚ÇÇ] √ó V => (x.1, p‚ÇÖ, x.2 +·µ• (x.1 : P))) ''
        Set.univ √óÀ¢ {v | SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) v ‚àß v ‚â† 0}
    have hco : IsConnected s :=
      haveI : ConnectedSpace line[‚Ñù, p‚ÇÅ, p‚ÇÇ] := AddTorsor.connectedSpace _ _
      (isConnected_univ.prod (isConnected_setOf_sameRay_and_ne_zero
        (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm))).image _
        (continuous_fst.subtype_val.prod_mk (continuous_const.prod_mk
          (continuous_snd.vadd continuous_fst.subtype_val))).continuousOn
    have hf : ContinuousOn (fun p : P √ó P √ó P => ‚à° p.1 p.2.1 p.2.2) s := by
      refine' ContinuousAt.continuousOn fun p hp => continuousAt_oangle _ _
      all_goals
        simp_rw [Set.mem_image, Set.mem_prod, Set.mem_univ, true_and_iff, Prod.ext_iff] at hp
        obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
        dsimp only at hp ‚ä¢
        obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
        dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
        obtain ‚ü®hvr, -‚ü© := hv
        rintro rfl
        refine' hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan _).2 (collinear_pair _ _ _))
      ¬∑ exact hq
      ¬∑ refine' vadd_mem_of_mem_direction _ hq
        rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
        obtain ‚ü®r, -, rfl‚ü© := hvr
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hsp : ‚àÄ p : P √ó P √ó P, p ‚àà s ‚Üí ‚à° p.1 p.2.1 p.2.2 ‚â† 0 ‚àß ‚à° p.1 p.2.1 p.2.2 ‚â† œÄ := by
      intro p hp
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff] at hp
      obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
      dsimp only at hp ‚ä¢
      obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
      dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
      obtain ‚ü®hvr, hv0‚ü© := hv
      rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
      obtain ‚ü®r, -, rfl‚ü© := hvr
      change q ‚àà line[‚Ñù, p‚ÇÅ, p‚ÇÇ] at hq
      rw [oangle_ne_zero_and_ne_pi_iff_affineIndependent]
      refine' affineIndependent_of_ne_of_mem_of_not_mem_of_mem _ hq
          (fun h => hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan h).2 (collinear_pair _ _ _))) _
      ¬∑ rwa [‚Üê @vsub_ne_zero V, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, neg_ne_zero]
      ¬∑ refine' vadd_mem_of_mem_direction _ hq
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hp‚ÇÅp‚ÇÇs : (p‚ÇÅ, p‚ÇÖ, p‚ÇÇ) ‚àà s := by
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff, Prod.ext_iff]
      refine' ‚ü®‚ü®‚ü®p‚ÇÅ, left_mem_affineSpan_pair _ _ _‚ü©, p‚ÇÇ -·µ• p‚ÇÅ‚ü©,
        ‚ü®SameRay.rfl, vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm‚ü©, _‚ü©
      simp
    have hp‚ÇÉp‚ÇÑs : (p‚ÇÉ, p‚ÇÖ, p‚ÇÑ) ‚àà s := by
      simp_rw [Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff, Prod.ext_iff]
      refine' ‚ü®‚ü®‚ü®p‚ÇÉ, hc.mem_affineSpan_of_mem_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _))) hp‚ÇÅp‚ÇÇ‚ü©, p‚ÇÑ -·µ• p‚ÇÉ‚ü©,
        ‚ü®hr, vsub_ne_zero.2 hp‚ÇÉp‚ÇÑ.symm‚ü©, _‚ü©
      simp
    convert Real.Angle.sign_eq_of_continuousOn hco hf hsp hp‚ÇÉp‚ÇÑs hp‚ÇÅp‚ÇÇs","warning:  @oangle does not have a doc string
error:  simp made no progress
error:  simp made no progress
error:  unknown identifier 'hq'
error:  unknown identifier 'hq'
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress","theorem _root_.Collinear.oangle_sign_of_sameRay_vsub {p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P} (p‚ÇÖ : P) (hp‚ÇÅp‚ÇÇ : p‚ÇÅ ‚â† p‚ÇÇ)
    (hp‚ÇÉp‚ÇÑ : p‚ÇÉ ‚â† p‚ÇÑ) (hc : Collinear ‚Ñù ({p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P))
    (hr : SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) (p‚ÇÑ -·µ• p‚ÇÉ)) : (‚à° p‚ÇÅ p‚ÇÖ p‚ÇÇ).sign = (‚à° p‚ÇÉ p‚ÇÖ p‚ÇÑ).sign ",":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _
          (Set.mem_singleton _)))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÉ‚ÇÑ
    rw [‚Üê Real.Angle.sign_eq_zero_iff] at hs‚ÇÅ‚ÇÖ‚ÇÇ hs‚ÇÉ‚ÇÖ‚ÇÑ
    rw [hs‚ÇÅ‚ÇÖ‚ÇÇ, hs‚ÇÉ‚ÇÖ‚ÇÑ]
  ¬∑ let s : Set (P √ó P √ó P) :=
      (fun x : line[‚Ñù, p‚ÇÅ, p‚ÇÇ] √ó V => (x.1, p‚ÇÖ, x.2 +·µ• (x.1 : P))) ''
        Set.univ √óÀ¢ {v | SameRay ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ) v ‚àß v ‚â† 0}
    have hco : IsConnected s :=
      haveI : ConnectedSpace line[‚Ñù, p‚ÇÅ, p‚ÇÇ] := AddTorsor.connectedSpace _ _
      (isConnected_univ.prod (isConnected_setOf_sameRay_and_ne_zero
        (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm))).image _
        (continuous_fst.subtype_val.prod_mk (continuous_const.prod_mk
          (continuous_snd.vadd continuous_fst.subtype_val))).continuousOn
    have hf : ContinuousOn (fun p : P √ó P √ó P => ‚à° p.1 p.2.1 p.2.2) s := by
      refine ContinuousAt.continuousOn fun p hp => continuousAt_oangle ?_ ?_
      all_goals
        simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_univ, true_and_iff, Prod.ext_iff] at hp
        obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
        dsimp only at hp ‚ä¢
        obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
        dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
        obtain ‚ü®hvr, -‚ü© := hv
        rintro rfl
        refine hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan ?_).2 (collinear_pair _ _ _))
      ¬∑ exact hq
      ¬∑ refine vadd_mem_of_mem_direction ?_ hq
        rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
        obtain ‚ü®r, -, rfl‚ü© := hvr
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hsp : ‚àÄ p : P √ó P √ó P, p ‚àà s ‚Üí ‚à° p.1 p.2.1 p.2.2 ‚â† 0 ‚àß ‚à° p.1 p.2.1 p.2.2 ‚â† œÄ := by
      intro p hp
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff] at hp
      obtain ‚ü®q‚ÇÅ, q‚ÇÖ, q‚ÇÇ‚ü© := p
      dsimp only at hp ‚ä¢
      obtain ‚ü®‚ü®‚ü®q, hq‚ü©, v‚ü©, hv, rfl, rfl, rfl‚ü© := hp
      dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ‚ä¢
      obtain ‚ü®hvr, hv0‚ü© := hv
      rw [‚Üê exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm)] at hvr
      obtain ‚ü®r, -, rfl‚ü© := hvr
      change q ‚àà line[‚Ñù, p‚ÇÅ, p‚ÇÇ] at hq
      rw [oangle_ne_zero_and_ne_pi_iff_affineIndependent]
      refine affineIndependent_of_ne_of_mem_of_not_mem_of_mem ?_ hq
          (fun h => hc‚ÇÖ‚ÇÅ‚ÇÇ ((collinear_insert_iff_of_mem_affineSpan h).2 (collinear_pair _ _ _))) ?_
      ¬∑ rwa [‚Üê @vsub_ne_zero V, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, neg_ne_zero]
      ¬∑ refine vadd_mem_of_mem_direction ?_ hq
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hp‚ÇÅp‚ÇÇs : (p‚ÇÅ, p‚ÇÖ, p‚ÇÇ) ‚àà s := by
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine ‚ü®‚ü®‚ü®p‚ÇÅ, left_mem_affineSpan_pair ‚Ñù _ _‚ü©, p‚ÇÇ -·µ• p‚ÇÅ‚ü©,
        ‚ü®SameRay.rfl, vsub_ne_zero.2 hp‚ÇÅp‚ÇÇ.symm‚ü©, ?_‚ü©
      simp
    have hp‚ÇÉp‚ÇÑs : (p‚ÇÉ, p‚ÇÖ, p‚ÇÑ) ‚àà s := by
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine ‚ü®‚ü®‚ü®p‚ÇÉ, hc.mem_affineSpan_of_mem_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _))) hp‚ÇÅp‚ÇÇ‚ü©, p‚ÇÑ -·µ• p‚ÇÉ‚ü©,
        ‚ü®hr, vsub_ne_zero.2 hp‚ÇÉp‚ÇÑ.symm‚ü©, ?_‚ü©
      simp
    convert Real.Angle.sign_eq_of_continuousOn hco hf hsp hp‚ÇÉp‚ÇÑs hp‚ÇÅp‚ÇÇs",":= by
  by_cases hc‚ÇÖ‚ÇÅ‚ÇÇ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ} : Set P)
  ¬∑ have hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp‚ÇÅp‚ÇÇ).2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hc‚ÇÖ‚ÇÉ‚ÇÑ : Collinear ‚Ñù ({p‚ÇÖ, p‚ÇÉ, p‚ÇÑ} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ Set.mem_insert _ _))) hp‚ÇÉp‚ÇÑ).1 hc‚ÇÖ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ
    rw [Set.insert_comm] at hc‚ÇÖ‚ÇÅ‚ÇÇ hc‚ÇÖ‚ÇÉ‚ÇÑ
    have hs‚ÇÅ‚ÇÖ‚ÇÇ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc‚ÇÖ‚ÇÅ‚ÇÇ
    have hs‚ÇÉ‚ÇÖ‚ÇÑ := oangle_eq_zero_or_eq_pi_iff_collinear.2"
Mathlib/Analysis/Calculus/LHopital.lean,deriv.lhopital_zero_right_on_Ioo,lhopital_zero_right_on_Ioo,4da4e0ebfbf51ecc2e064d04970434177efdead3,":= by
  have sub : ‚àÄ x ‚àà Ioo a b, Ioo a x ‚äÜ Ioo a b := fun x hx =>
    Ioo_subset_Ioo (le_refl a) (le_of_lt hx.2)
  have hg : ‚àÄ x ‚àà Ioo a b, g x ‚â† 0 := by
    intro x hx h
    have : Tendsto g (ùìù[<] x) (ùìù 0) := by
      rw [‚Üê h, ‚Üê nhdsWithin_Ioo_eq_nhdsWithin_Iio hx.1]
      exact ((hgg' x hx).continuousAt.continuousWithinAt.mono <| sub x hx).tendsto
    obtain ‚ü®y, hyx, hy‚ü© : ‚àÉ c ‚àà Ioo a x, g' c = 0 :=
      exists_hasDerivAt_eq_zero' hx.1 hga this fun y hy => hgg' y <| sub x hx hy
    exact hg' y (sub x hx hyx) hy
  have : ‚àÄ x ‚àà Ioo a b, ‚àÉ c ‚àà Ioo a x, f x * g' c = g x * f' c := by
    intro x hx
    rw [‚Üê sub_zero (f x), ‚Üê sub_zero (g x)]
    exact exists_ratio_hasDerivAt_eq_ratio_slope' g g' hx.1 f f' (fun y hy => hgg' y <| sub x hx hy)
      (fun y hy => hff' y <| sub x hx hy) hga hfa
      (tendsto_nhdsWithin_of_tendsto_nhds (hgg' x hx).continuousAt.tendsto)
      (tendsto_nhdsWithin_of_tendsto_nhds (hff' x hx).continuousAt.tendsto)
  choose! c hc using this
  have : ‚àÄ x ‚àà Ioo a b, ((fun x' => f' x' / g' x') ‚àò c) x = f x / g x := by
    intro x hx
    rcases hc x hx with ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    field_simp [hg x hx, hg' (c x) ((sub x hx) h‚ÇÅ)]
    simp only [h‚ÇÇ]
    rw [mul_comm]
  have cmp : ‚àÄ x ‚àà Ioo a b, a < c x ‚àß c x < x := fun x hx => (hc x hx).1
  rw [‚Üê nhdsWithin_Ioo_eq_nhdsWithin_Ioi hab]
  apply tendsto_nhdsWithin_congr this
  apply hdiv.comp
  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _
    (tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds
      (tendsto_nhdsWithin_of_tendsto_nhds tendsto_id) ?_ ?_?) _
  all_goals
    apply eventually_nhdsWithin_of_forall
    intro x hx
    have := cmp x hx
    try simp
    linarith [this]","error:  don't know how to synthesize placeholder for argument 'h2'
context:
a b : ‚Ñù
hab : a < b
l : Filter ‚Ñù
f f' g g' : ‚Ñù ‚Üí ‚Ñù
hff' : ‚àÄ x ‚àà Ioo a b, HasDerivAt f (f' x) x
hgg' : ‚àÄ x ‚àà Ioo a b, HasDerivAt g (g' x) x
hg' : ‚àÄ x ‚àà Ioo a b, g' x ‚â† 0
hfa : Tendsto f (ùìù[>] a) (ùìù 0)
hga : Tendsto g (ùìù[>] a) (ùìù 0)
hdiv : Tendsto (fun x ‚Ü¶ f' x / g' x) (ùìù[>] a) l
sub : ‚àÄ x ‚àà Ioo a b, Ioo a x ‚äÜ Ioo a b
hg : ‚àÄ x ‚àà Ioo a b, g x ‚â† 0
c : ‚Ñù ‚Üí ‚Ñù
hc : ‚àÄ x ‚àà Ioo a b, c x ‚àà Ioo a x ‚àß f x * g' (c x) = g x * f' (c x)
this : ‚àÄ x ‚àà Ioo a b, ((fun x' ‚Ü¶ f' x' / g' x') ‚àò c) x = f x / g x
cmp : ‚àÄ x ‚àà Ioo a b, a < c x ‚àß c x < x
‚ä¢ ‚àÄ·∂† (x : ‚Ñù) in ùìù[Ioo a b] a, c x ‚àà Ioi a
error:  unsolved goals
a b : ‚Ñù
hab : a < b
l : Filter ‚Ñù
f f' g g' : ‚Ñù ‚Üí ‚Ñù
hff' : ‚àÄ x ‚àà Ioo a b, HasDerivAt f (f' x) x
hgg' : ‚àÄ x ‚àà Ioo a b, HasDerivAt g (g' x) x
hg' : ‚àÄ x ‚àà Ioo a b, g' x ‚â† 0
hfa : Tendsto f (ùìù[>] a) (ùìù 0)
hga : Tendsto g (ùìù[>] a) (ùìù 0)
hdiv : Tendsto (fun x ‚Ü¶ f' x / g' x) (ùìù[>] a) l
sub : ‚àÄ x ‚àà Ioo a b, Ioo a x ‚äÜ Ioo a b
hg : ‚àÄ x ‚àà Ioo a b, g x ‚â† 0
c : ‚Ñù ‚Üí ‚Ñù
hc : ‚àÄ x ‚àà Ioo a b, c x ‚àà Ioo a x ‚àß f x * g' (c x) = g x * f' (c x)
this : ‚àÄ x ‚àà Ioo a b, ((fun x' ‚Ü¶ f' x' / g' x') ‚àò c) x = f x / g x
cmp : ‚àÄ x ‚àà Ioo a b, a < c x ‚àß c x < x
‚ä¢ Tendsto c (ùìù[Ioo a b] a) (ùìù[>] a)","theorem lhopital_zero_right_on_Ioo (hff' : ‚àÄ x ‚àà Ioo a b, HasDerivAt f (f' x) x)
    (hgg' : ‚àÄ x ‚àà Ioo a b, HasDerivAt g (g' x) x) (hg' : ‚àÄ x ‚àà Ioo a b, g' x ‚â† 0)
    (hfa : Tendsto f (ùìù[>] a) (ùìù 0)) (hga : Tendsto g (ùìù[>] a) (ùìù 0))
    (hdiv : Tendsto (fun x => f' x / g' x) (ùìù[>] a) l) :
    Tendsto (fun x => f x / g x) (ùìù[>] a) l ",":= by
  have sub : ‚àÄ x ‚àà Ioo a b, Ioo a x ‚äÜ Ioo a b := fun x hx =>
    Ioo_subset_Ioo (le_refl a) (le_of_lt hx.2)
  have hg : ‚àÄ x ‚àà Ioo a b, g x ‚â† 0 := by
    intro x hx h
    have : Tendsto g (ùìù[<] x) (ùìù 0) := by
      rw [‚Üê h, ‚Üê nhdsWithin_Ioo_eq_nhdsWithin_Iio hx.1]
      exact ((hgg' x hx).continuousAt.continuousWithinAt.mono <| sub x hx).tendsto
    obtain ‚ü®y, hyx, hy‚ü© : ‚àÉ c ‚àà Ioo a x, g' c = 0 :=
      exists_hasDerivAt_eq_zero' hx.1 hga this fun y hy => hgg' y <| sub x hx hy
    exact hg' y (sub x hx hyx) hy
  have : ‚àÄ x ‚àà Ioo a b, ‚àÉ c ‚àà Ioo a x, f x * g' c = g x * f' c := by
    intro x hx
    rw [‚Üê sub_zero (f x), ‚Üê sub_zero (g x)]
    exact exists_ratio_hasDerivAt_eq_ratio_slope' g g' hx.1 f f' (fun y hy => hgg' y <| sub x hx hy)
      (fun y hy => hff' y <| sub x hx hy) hga hfa
      (tendsto_nhdsWithin_of_tendsto_nhds (hgg' x hx).continuousAt.tendsto)
      (tendsto_nhdsWithin_of_tendsto_nhds (hff' x hx).continuousAt.tendsto)
  choose! c hc using this
  have : ‚àÄ x ‚àà Ioo a b, ((fun x' => f' x' / g' x') ‚àò c) x = f x / g x := by
    intro x hx
    rcases hc x hx with ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    field_simp [hg x hx, hg' (c x) ((sub x hx) h‚ÇÅ)]
    simp only [h‚ÇÇ]
    rw [mul_comm]
  have cmp : ‚àÄ x ‚àà Ioo a b, a < c x ‚àß c x < x := fun x hx => (hc x hx).1
  rw [‚Üê nhdsWithin_Ioo_eq_nhdsWithin_Ioi hab]
  apply tendsto_nhdsWithin_congr this
  apply hdiv.comp
  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _
    (tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds
      (tendsto_nhdsWithin_of_tendsto_nhds tendsto_id) ?_ ?_) ?_
  all_goals
    apply eventually_nhdsWithin_of_forall
    intro x hx
    have := cmp x hx
    try simp
    linarith [this]",":= by
  have sub : ‚àÄ x ‚àà Ioo a b, Ioo a x ‚äÜ Ioo a b := fun x hx =>
    Ioo_subset_Ioo (le_refl a) (le_of_lt hx.2)
  have hg : ‚àÄ x ‚àà Ioo a b, g x ‚â† 0 := by
    intro x hx h
    have : Tendsto g (ùìù[<] x) (ùìù 0) := by
      rw [‚Üê h, ‚Üê nhdsWithin_Ioo_eq_nhdsWithin_Iio hx.1]
      exact ((hgg' x hx).continuousAt.continuousWithinAt.mono <| sub x hx).tendsto
    obtain ‚ü®y, hyx, hy‚ü© : ‚àÉ c ‚àà Ioo a x, g' c = 0 :=
      exists_hasDerivAt_eq_zero' hx.1 hga this fun y hy => hgg' y <| sub x hx hy
    exact hg' y (sub x hx hyx) hy
  have : ‚àÄ x ‚àà Ioo a b, ‚àÉ c ‚àà Ioo a x, f x * g' c = g x * f' c := by
    intro x hx
    rw [‚Üê sub_zero (f x), ‚Üê sub_zero (g x)]
    exact exists_ratio_hasDerivAt_eq_ratio_slope' g g' hx.1 f f' (fun y hy => hgg' y <| sub x hx hy)
      (fun y hy => hff' y <| sub x hx hy) hga hfa
      (tendsto_nhdsWithin_of_tendsto_nhds (hgg' x hx).continuousAt.tendsto)
      (tendsto_nhdsWithin_of_tendsto_nhds (hff' x hx).continuousAt.tendsto)
  choose! c hc using this
  have : ‚àÄ x ‚àà Ioo a b, ((fun x' => f' x' / g' x') ‚àò c) x = f x / g x := by
    intro x hx
    rcases hc x hx with ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    field_simp [hg x hx, hg' (c x) ((sub x hx) h‚ÇÅ)]
    simp only [h‚ÇÇ]
    rw [mul_comm]
  have cmp : ‚àÄ x ‚àà Ioo a b, a < c x ‚àß c x < x := fun x hx => (hc x hx).1
  rw [‚Üê nhdsWithin_Ioo_eq_nhdsWithin_Ioi hab]
  apply tendsto_nhdsWithin_congr this
  apply hdiv.comp
  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _
    (tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds
      (tendsto_nhdsWithin_of_tendsto_nhds tendsto_id) ?_ ?_) ?_
  all_goals
    apply eventually_nhdsWithin_of_forall
    intro x hx
    have := cmp x hx
    try simp
    linarith [this]"
Mathlib/SetTheory/Cardinal/Ordinal.lean,Cardinal.mul_eq_self,mul_eq_self,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  refine' le_antisymm _ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine' Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => _) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  skip
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine' le_of_forall_lt fun o h => _
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine'
    lt_of_le_of_lt (_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p))))
      _
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit from
      ‚ü®(Set.embeddingOfSubset _ _ this).trans
        ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine' (Equiv.Set.insert _).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein (¬∑ < ¬∑) (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß from (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type","error:  invalid field 'imp_right', the environment does not contain 'Order.Preimage.imp_right'
  h
has type
  (‚áëf ‚Åª¬π'o Prod.Lex (fun x x_1 ‚Ü¶ x < x_1) (Prod.Lex (fun x x_1 ‚Ü¶ x < x_1) fun x x_1 ‚Ü¶ x < x_1)) q p
error:  invalid field 'imp_right', the environment does not contain 'Prod.Lex.imp_right'
  h
has type
  Prod.Lex (fun x x_1 ‚Ü¶ x < x_1) (Prod.Lex (fun x x_1 ‚Ü¶ x < x_1) fun x x_1 ‚Ü¶ x < x_1) (f q) (f p)",theorem mul_eq_self {c : Cardinal} (h : ‚Ñµ‚ÇÄ ‚â§ c) : c * c = c ,":= by
  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => ?_) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine le_of_forall_lt fun o h => ?_
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine lt_of_le_of_lt
    (?_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p)))) ?_
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [s, f, Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit from
      ‚ü®(Set.embeddingOfSubset _ _ this).trans
        ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine (Equiv.Set.insert ?_).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein (¬∑ < ¬∑) (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß from (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type",":= by
  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun Œ± IH ol => ?_) h
  rcases ord_eq Œ± with ‚ü®r, wo, e‚ü©
  skip
  letI := linearOrderOfSTO r
  haveI : IsWellOrder Œ± (¬∑ < ¬∑) := wo
  let g : Œ± √ó Œ± ‚Üí Œ± := fun p => max p.1 p.2
  let f : Œ± √ó Œ± ‚Ü™ Ordinal √ó Œ± √ó Œ± :=
    ‚ü®fun p : Œ± √ó Œ± => (typein (¬∑ < ¬∑) (g p), p), fun p q => congr_arg Prod.snd‚ü©
  let s := f ‚Åª¬π'o Prod.Lex (¬∑ < ¬∑) (Prod.Lex (¬∑ < ¬∑) (¬∑ < ¬∑))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ‚â§ type r by exact card_le_card this
  refine le_of_forall_lt fun o h => ?_
  rcases typein_surj s h with ‚ü®p, rfl‚ü©
  rw [‚Üê e, lt_ord]
  refine
    lt_of_le_of_lt (_ : _ ‚â§ card (succ (typein (¬∑ < ¬∑) (g p))) * card (succ (typein (¬∑ < ¬∑) (g p)))
      ?_
  ¬∑ have : { q | s q p } ‚äÜ insert (g p) { x | x < g p } √óÀ¢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set Œ±) ‚âÉ Sum { x | r x (g p) } PUnit from
      ‚ü®(Set.embeddingOfSubset _ _ this).trans
        ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding‚ü©
    refine (Equiv.Set.insert _).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein LT.lt (g p)))) ‚Ñµ‚ÇÄ with qo qo
  ¬∑ exact (mul_lt_aleph0 qo qo).trans_le ol
  ¬∑ suffices (succ (typein LT.lt (g p))).card < ‚ü¶Œ±‚üß from (IH _ this qo).trans_lt this
    rw [‚Üê lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type"
Mathlib/Probability/ConditionalProbability.lean,ProbabilityTheory.cond_cond_eq_cond_inter',cond_cond_eq_cond_inter',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 :=
      le_antisymm (le_trans (measure_mono (Set.inter_subset_left _ _)) hst.le) bot_le
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (Œº.toOuterMeasure.pos_of_subset_ne_zero (Set.inter_subset_left _ _) hst).ne'
    simp [*, hms.inter hmt, cond_apply, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, mul_comm, ‚Üê
      mul_assoc, ENNReal.mul_inv_cancel]","warning:  @cond does not have a doc string
warning:  @cond does not have a doc string
error:  function expected at
  inter_subset_left ?m.28251
term has type
  ?m.28250 ‚àà ?m.28248
warning:  `MeasureTheory.OuterMeasure.pos_of_subset_ne_zero` has been deprecated, use `MeasureTheory.measure_pos_of_superset` instead
error:  function expected at
  inter_subset_left ?m.30975
term has type
  ?m.30974 ‚àà ?m.30972
error:  unsolved goals
case h.inr
Œ© : Type u_1
Œ©' : Type u_2
Œ± : Type u_3
m : MeasurableSpace Œ©
m' : MeasurableSpace Œ©'
Œº : Measure Œ©
s t : Set Œ©
hms : MeasurableSet s
hmt : MeasurableSet t
hcs : Œº s ‚â† ‚ä§
u : Set Œ©
a‚úù : MeasurableSet u
hst : Œº (s ‚à© t) ‚â† 0
hcs' : Œº s ‚â† 0
‚ä¢ Œº s * Œº (s ‚à© t ‚à© u) * (Œº s)‚Åª¬π * (Œº (s ‚à© t))‚Åª¬π = Œº (s ‚à© t ‚à© u) * (Œº (s ‚à© t))‚Åª¬π","lemma cond_cond_eq_cond_inter' (hms : MeasurableSet s) (hmt : MeasurableSet t) (hcs : Œº s ‚â† ‚àû) :
    Œº[|s][|t] = Œº[|s ‚à© t] ",":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (measure_pos_of_superset Set.inter_subset_left hst).ne'
    simp [*, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Œº s)‚Åª¬π]",":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Œº (s ‚à© t)) 0
  ¬∑ have : Œº (s ‚à© t ‚à© u) = 0 :=
      le_antisymm (le_trans (measure_mono Set.inter_subset_left) hst.le) bot_le
    simp [this, ‚Üê Set.inter_assoc]
  ¬∑ have hcs' : Œº s ‚â† 0 :=
      (Œº.toOuterMeasure.pos_of_subset_ne_zero Set.inter_subset_left hst).ne'
    simp [*, hms.inter hmt, cond_apply, ‚Üê mul_assoc, ‚Üê Set.inter_assoc, ENNReal.mul_inv, mul_comm, ‚Üê
      mul_assoc, ENNReal.mul_inv_cancel]"
Mathlib/Data/Nat/Log.lean,Nat.pow_le_iff_le_log,pow_le_iff_le_log,76620f7bc93be67fe98a87948024801e42a6f815,":= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => exact iff_of_true hy.bot_lt (zero_le _)
  | succ x =>
    rw [log]; split_ifs with h
    ¬∑ have b_pos : 0 < b := zero_le_one.trans_lt hb
      rw [succ_eq_add_one, add_le_add_iff_right, ‚Üê
        ih (y / b) (div_lt_self hy.bot_lt hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', mul_comm]
    ¬∑ exact iff_of_false (fun hby => h ‚ü®(le_self_pow x.succ_ne_zero _).trans hby, hb‚ü©)
        (not_succ_le_zero _)","error:  application type mismatch
  iff_of_true (Ne.bot_lt ?m.6914)
argument
  Ne.bot_lt ?m.6914
has type
  ‚ä• < ?m.4897 : Prop
but is expected to have type
  b ^ 0 ‚â§ y : Prop
error:  application type mismatch
  Ne.bot_lt hy
argument
  hy
has type
  y ‚â† 0 : Prop
but is expected to have type
  y ‚â† ‚ä• : Prop
error:  unknown identifier 'zero_le_one.trans_lt'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case pos
b : ‚Ñï
hb : 1 < b
y : ‚Ñï
ih : ‚àÄ m < y, ‚àÄ {x : ‚Ñï}, m ‚â† 0 ‚Üí (b ^ x ‚â§ m ‚Üî x ‚â§ log b m)
hy : y ‚â† 0
x : ‚Ñï
h : b ‚â§ y ‚àß 1 < b
b_pos : 0 < b
‚ä¢ b ^ (x + 1) ‚â§ y ‚Üî x + 1 ‚â§ log b (y / b) + 1","theorem pow_le_iff_le_log {b : ‚Ñï} (hb : 1 < b) {x y : ‚Ñï} (hy : y ‚â† 0) :
    b ^ x ‚â§ y ‚Üî x ‚â§ log b y ",":= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => dsimp; omega
  | succ x =>
    rw [log]; split_ifs with h
    ¬∑ have b_pos : 0 < b := lt_of_succ_lt hb
      rw [Nat.add_le_add_iff_right, ‚Üê ih (y / b) (div_lt_self
        (Nat.pos_iff_ne_zero.2 hy) hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', Nat.mul_comm]
    ¬∑ exact iff_of_false (fun hby => h ‚ü®(le_self_pow x.succ_ne_zero _).trans hby, hb‚ü©)
        (not_succ_le_zero _)",":= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => exact iff_of_true hy.bot_lt (zero_le _)
  | succ x =>
    rw [log]; split_ifs with h
    ¬∑ have b_pos : 0 < b := zero_le_one.trans_lt hb
      rw [succ_eq_add_one, add_le_add_iff_right, ‚Üê
        ih (y / b) (div_lt_self hy.bot_lt hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', mul_comm]
    ¬∑ exact iff_of_false (fun hby => h ‚ü®(le_self_pow x.succ_ne_zero _).trans hby, hb‚ü©)
        (not_succ_le_zero _)"
Mathlib/Algebra/DirectLimit.lean,Module.DirectLimit.map_comp,map_comp,f9a92ed3d67873862051aaeedcedfa1472745048,":=
  DFunLike.ext _ _ fun x ‚Ü¶ (isEmpty_or_nonempty Œπ).elim (by subsingleton) fun _ ‚Ü¶
    x.induction_on fun i g ‚Ü¶ by simp","error:  unknown tactic
error:  unsolved goals
R : Type u
inst‚úù¬π¬π : Ring R
Œπ : Type v
inst‚úù¬π‚Å∞ : Preorder Œπ
G : Œπ ‚Üí Type w
inst‚úù‚Åπ : (i : Œπ) ‚Üí AddCommGroup (G i)
inst‚úù‚Å∏ : (i : Œπ) ‚Üí Module R (G i)
f : (i j : Œπ) ‚Üí i ‚â§ j ‚Üí G i ‚Üí‚Çó[R] G j
inst‚úù‚Å∑ : DecidableEq Œπ
P : Type u‚ÇÅ
inst‚úù‚Å∂ : AddCommGroup P
inst‚úù‚Åµ : Module R P
g : (i : Œπ) ‚Üí G i ‚Üí‚Çó[R] P
Hg : ‚àÄ (i j : Œπ) (hij : i ‚â§ j) (x : G i), (g j) ((f i j hij) x) = (g i) x
G' : Œπ ‚Üí Type v'
inst‚úù‚Å¥ : (i : Œπ) ‚Üí AddCommGroup (G' i)
inst‚úù¬≥ : (i : Œπ) ‚Üí Module R (G' i)
f' : (i j : Œπ) ‚Üí i ‚â§ j ‚Üí G' i ‚Üí‚Çó[R] G' j
G'' : Œπ ‚Üí Type v''
inst‚úù¬≤ : (i : Œπ) ‚Üí AddCommGroup (G'' i)
inst‚úù¬π : (i : Œπ) ‚Üí Module R (G'' i)
f'' : (i j : Œπ) ‚Üí i ‚â§ j ‚Üí G'' i ‚Üí‚Çó[R] G'' j
inst‚úù : IsDirected Œπ fun x x_1 ‚Ü¶ x ‚â§ x_1
g‚ÇÅ : (i : Œπ) ‚Üí G i ‚Üí‚Çó[R] G' i
g‚ÇÇ : (i : Œπ) ‚Üí G' i ‚Üí‚Çó[R] G'' i
hg‚ÇÅ : ‚àÄ (i j : Œπ) (h : i ‚â§ j), g‚ÇÅ j ‚àò‚Çó f i j h = f' i j h ‚àò‚Çó g‚ÇÅ i
hg‚ÇÇ : ‚àÄ (i j : Œπ) (h : i ‚â§ j), g‚ÇÇ j ‚àò‚Çó f' i j h = f'' i j h ‚àò‚Çó g‚ÇÇ i
x : DirectLimit G f
‚ä¢ IsEmpty Œπ ‚Üí ?m.223200","lemma map_comp [IsDirected Œπ (¬∑ ‚â§ ¬∑)]
    (g‚ÇÅ : (i : Œπ) ‚Üí G i ‚Üí‚Çó[R] G' i) (g‚ÇÇ : (i : Œπ) ‚Üí G' i ‚Üí‚Çó[R] G'' i)
    (hg‚ÇÅ : ‚àÄ i j h, g‚ÇÅ j ‚àò‚Çó f i j h = f' i j h ‚àò‚Çó g‚ÇÅ i)
    (hg‚ÇÇ : ‚àÄ i j h, g‚ÇÇ j ‚àò‚Çó f' i j h = f'' i j h ‚àò‚Çó g‚ÇÇ i) :
    (map g‚ÇÇ hg‚ÇÇ ‚àò‚Çó map g‚ÇÅ hg‚ÇÅ :
      DirectLimit G f ‚Üí‚Çó[R] DirectLimit G'' f'') =
    (map (fun i ‚Ü¶ g‚ÇÇ i ‚àò‚Çó g‚ÇÅ i) fun i j h ‚Ü¶ by
        rw [LinearMap.comp_assoc, hg‚ÇÅ i, ‚Üê LinearMap.comp_assoc, hg‚ÇÇ i, LinearMap.comp_assoc] :
      DirectLimit G f ‚Üí‚Çó[R] DirectLimit G'' f'') ",":=
  DFunLike.ext _ _ fun x ‚Ü¶ (isEmpty_or_nonempty Œπ).elim (fun _ ‚Ü¶ Subsingleton.elim _ _) fun _ ‚Ü¶
    x.induction_on fun i g ‚Ü¶ by simp",":=
  DFunLike.ext _ _ fun x ‚Ü¶ (isEmpty_or_nonempty Œπ).elim (by subsingleton) fun _ ‚Ü¶
    x.induction_on fun i g ‚Ü¶ by simp"
Mathlib/Topology/Algebra/InfiniteSum/Basic.lean,Function.Injective.tprod_eq,Function.Injective.tprod_eq,5bc1ad1d20d0d38fd328824a49d24b475a371d9e,":= by
  have : mulSupport f = g '' mulSupport (f ‚àò g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [‚Üê Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  ¬∑ have hfg_fin : (mulSupport (f ‚àò g)).Finite := hf_fin.preimage (hg.injOn _)
    lift g to Œ≥ ‚Ü™ Œ≤ using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ‚Üê Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ‚Ü¶ rfl
    simp [this]
  ¬∑ have hf_fin' : ¬¨ Set.Finite (mulSupport (f ‚àò g)) := by
      rwa [this, Set.finite_image_iff (hg.injOn _)] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      hg.hasProd_iff (mulSupport_subset_iff'.1 hf)]","error:  application type mismatch
  Set.Finite.preimage (injOn hg ?m.107093)
argument
  injOn hg ?m.107093
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Œ≥‚¶Ñ, x‚ÇÇ ‚àà ?m.107091 ‚Üí g ?m.107092 = g x‚ÇÇ ‚Üí ?m.107092 = x‚ÇÇ : Prop
but is expected to have type
  Set.InjOn ?m.107033 (?m.107033 ‚Åª¬π' ?m.107034) : Prop
error:  application type mismatch
  Set.finite_image_iff (injOn hg ?m.112448)
argument
  injOn hg ?m.112448
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Œ≥‚¶Ñ, x‚ÇÇ ‚àà ?m.112446 ‚Üí g ?m.112447 = g x‚ÇÇ ‚Üí ?m.112447 = x‚ÇÇ : Prop
but is expected to have type
  Set.InjOn ?m.112425 ?m.112424 : Prop
error:  unsolved goals
case neg
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œ¥ : Type u_4
inst‚úù¬π : CommMonoid Œ±
inst‚úù : TopologicalSpace Œ±
f‚úù g‚úù : Œ≤ ‚Üí Œ±
a a‚ÇÅ a‚ÇÇ : Œ±
g : Œ≥ ‚Üí Œ≤
hg : Injective g
f : Œ≤ ‚Üí Œ±
hf : mulSupport f ‚äÜ Set.range g
this : mulSupport f = g '' mulSupport (f ‚àò g)
hf_fin : ¬¨(mulSupport f).Finite
hf_fin' : ¬¨(mulSupport (f ‚àò g)).Finite
‚ä¢ (if h : ‚àÉ a, HasProd f a then Exists.choose ‚ãØ else 1) =
    if h : ‚àÉ a, HasProd (fun b ‚Ü¶ f b) a then Exists.choose ‚ãØ else 1","theorem Function.Injective.tprod_eq {g : Œ≥ ‚Üí Œ≤} (hg : Injective g) {f : Œ≤ ‚Üí Œ±}
    (hf : mulSupport f ‚äÜ Set.range g) : ‚àè' c, f (g c) = ‚àè' b, f b ",":= by
  have : mulSupport f = g '' mulSupport (f ‚àò g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [‚Üê Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  ¬∑ have hfg_fin : (mulSupport (f ‚àò g)).Finite := hf_fin.preimage hg.injOn
    lift g to Œ≥ ‚Ü™ Œ≤ using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ‚Üê Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ‚Ü¶ rfl
    simp [this]
  ¬∑ have hf_fin' : ¬¨ Set.Finite (mulSupport (f ‚àò g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      funext fun a => propext <| hg.hasProd_iff (mulSupport_subset_iff'.1 hf) (a := a)]",":= by
  have : mulSupport f = g '' mulSupport (f ‚àò g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [‚Üê Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  ¬∑ have hfg_fin : (mulSupport (f ‚àò g)).Finite := hf_fin.preimage (hg.injOn _)
    lift g to Œ≥ ‚Ü™ Œ≤ using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ‚Üê Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ‚Ü¶ rfl
    simp [this]
  ¬∑ have hf_fin' : ¬¨ Set.Finite (mulSupport (f ‚àò g)) := by
      rwa [this, Set.finite_image_iff (hg.injOn _)] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      hg.hasProd_iff mulSupport_subset_iff'.1 hf]"
Mathlib/NumberTheory/Padics/PadicVal.lean,padicValRat.le_padicValRat_add_of_le,le_padicValRat_add_of_le,6aa938732f4bd703b82127542018850f5874e784,":=
  if hq : q = 0 then by simpa [hq] using h
  else
    if hr : r = 0 then by simp [hr]
    else by
      have hqn : q.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hq
      have hqd : (q.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hqreq : q + r = (q.num * r.den + q.den * r.num) /. (q.den * r.den) := Rat.add_num_den _ _
      have hqrd : q.num * r.den + q.den * r.num ‚â† 0 := Rat.mk_num_ne_zero_of_ne_zero hqr hqreq
      conv_lhs => rw [‚Üê @Rat.num_den q]
      rw [hqreq, padicValRat_le_padicValRat_iff hqn hqrd hqd (mul_ne_zero hqd hrd), ‚Üê
        multiplicity_le_multiplicity_iff, mul_left_comm,
        multiplicity.mul (Nat.prime_iff_prime_int.1 hp.1), add_mul]
      rw [‚Üê @Rat.num_den q, ‚Üê @Rat.num_den r, padicValRat_le_padicValRat_iff hqn hrn hqd hrd, ‚Üê
        multiplicity_le_multiplicity_iff] at h
      calc
        _ ‚â§
            min (multiplicity (‚Üëp) (q.num * r.den * q.den))
              (multiplicity (‚Üëp) (‚Üëq.den * r.num * ‚Üëq.den)) :=
          le_min
            (by rw [@multiplicity.mul _ _ _ _ (_ * _) _ (Nat.prime_iff_prime_int.1 hp.1), add_comm])
            (by
              rw [mul_assoc,
                  @multiplicity.mul _ _ _ _ (q.den : ‚Ñ§) (_ * _)
                    (Nat.prime_iff_prime_int.1 hp.1)]
              exact add_le_add_left h _)
        _ ‚â§ _ := min_le_multiplicity_add","error:  unknown constant 'Rat.num_ne_zero_of_ne_zero'
error:  unknown constant 'Rat.num_ne_zero_of_ne_zero'
error:  invalid use of field notation with `@` modifier
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.41714
p : ‚Ñï
hp : Fact (Nat.Prime p)
q r : ‚Ñö
hqr : q + r ‚â† 0
h : padicValRat p q ‚â§ padicValRat p r
hq : ¬¨q = 0
hr : ¬¨r = 0
hqn : q.num ‚â† 0
hqd : ‚Üëq.den ‚â† 0
hrn : r.num ‚â† 0
hrd : ‚Üër.den ‚â† 0
hqreq : q + r = (q.num * ‚Üër.den + ‚Üëq.den * r.num) /. (‚Üëq.den * ‚Üër.den)
hqrd : q.num * ‚Üër.den + ‚Üëq.den * r.num ‚â† 0
| padicValRat p q
warning:  unused variable `hp`
note: this linter can be disabled with `set_option linter.unusedVariables false`","theorem le_padicValRat_add_of_le {q r : ‚Ñö} (hqr : q + r ‚â† 0)
    (h : padicValRat p q ‚â§ padicValRat p r) : padicValRat p q ‚â§ padicValRat p (q + r) ",":=
  if hq : q = 0 then by simpa [hq] using h
  else
    if hr : r = 0 then by simp [hr]
    else by
      have hqn : q.num ‚â† 0 := Rat.num_ne_zero.2 hq
      have hqd : (q.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero.2 hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hqreq : q + r = (q.num * r.den + q.den * r.num) /. (q.den * r.den) := Rat.add_num_den _ _
      have hqrd : q.num * r.den + q.den * r.num ‚â† 0 := Rat.mk_num_ne_zero_of_ne_zero hqr hqreq
      conv_lhs => rw [‚Üê q.num_divInt_den]
      rw [hqreq, padicValRat_le_padicValRat_iff hqn hqrd hqd (mul_ne_zero hqd hrd), ‚Üê
        multiplicity_le_multiplicity_iff, mul_left_comm,
        multiplicity.mul (Nat.prime_iff_prime_int.1 hp.1), add_mul]
      rw [‚Üê q.num_divInt_den, ‚Üê r.num_divInt_den, padicValRat_le_padicValRat_iff hqn hrn hqd hrd, ‚Üê
        multiplicity_le_multiplicity_iff] at h
      calc
        _ ‚â§
            min (multiplicity (‚Üëp) (q.num * r.den * q.den))
              (multiplicity (‚Üëp) (‚Üëq.den * r.num * ‚Üëq.den)) :=
          le_min
            (by rw [@multiplicity.mul _ _ _ _ (_ * _) _ (Nat.prime_iff_prime_int.1 hp.1), add_comm])
            (by
              rw [mul_assoc,
                  @multiplicity.mul _ _ _ _ (q.den : ‚Ñ§) (_ * _)
                    (Nat.prime_iff_prime_int.1 hp.1)]
              exact add_le_add_left h _)
        _ ‚â§ _ := min_le_multiplicity_add",":=
  if hq : q = 0 then by simpa [hq] using h
  else
    if hr : r = 0 then by simp [hr]
    else by
      have hqn : q.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hq
      have hqd : (q.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := mod_cast Rat.den_nz _
      have hrn : r.num ‚â† 0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : ‚Ñ§) ‚â† 0 := m"
Mathlib/GroupTheory/Perm/Cycle/Type.lean,Equiv.Perm.card_fixedPoints_modEq,card_fixedPoints_modEq,161c69c1dbf66cf3c7ec4f648a61551d044a43e4,":= by
  let œÉ : Œ± ‚âÉ Œ± := ‚ü®f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)‚ü©
  have hœÉ : œÉ ^ p ^ n = 1
  ¬∑ rw [DFunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End Œ± ‚Ü¶ g) rfl (fun g h ‚Ü¶ rfl) f (p ^ n)).symm.trans hf
  suffices : Fintype.card f.fixedPoints = (support œÉ)·∂ú.card
  ¬∑ exact this ‚ñ∏ (card_compl_support_modEq hœÉ).symm
  suffices : f.fixedPoints = (support œÉ)·∂ú
  ¬∑ simp only [this]; apply Fintype.card_coe
  simp [Set.ext_iff, IsFixedPt]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
Œ± : Type u_1
inst‚úù¬π : Fintype Œ±
inst‚úù : DecidableEq Œ±
f : Function.End Œ±
p n : ‚Ñï
hp : Fact (Nat.Prime p)
hf : f ^ p ^ n = 1
œÉ : Œ± ‚âÉ Œ± := { toFun := f, invFun := f ^ (p ^ n - 1), left_inv := ‚ãØ, right_inv := ‚ãØ }
hœÉ : œÉ ^ p ^ n = 1
‚ä¢ Fintype.card Œ± ‚â° Fintype.card ‚Üë(fixedPoints f) [MOD p]","theorem card_fixedPoints_modEq [DecidableEq Œ±] {f : Function.End Œ±} {p n : ‚Ñï}
    [hp : Fact p.Prime] (hf : f ^ p ^ n = 1) :
    Fintype.card Œ± ‚â° Fintype.card f.fixedPoints [MOD p] ",":= by
  let œÉ : Œ± ‚âÉ Œ± := ‚ü®f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)‚ü©
  have hœÉ : œÉ ^ p ^ n = 1 := by
    rw [DFunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End Œ± ‚Ü¶ g) rfl (fun g h ‚Ü¶ rfl) f (p ^ n)).symm.trans hf
  suffices Fintype.card f.fixedPoints = (support œÉ)·∂ú.card from
    this ‚ñ∏ (card_compl_support_modEq hœÉ).symm
  suffices f.fixedPoints = (support œÉ)·∂ú by
    simp only [this]; apply Fintype.card_coe
  simp [œÉ, Set.ext_iff, IsFixedPt]",":= by
  let œÉ : Œ± ‚âÉ Œ± := ‚ü®f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)‚ü©
  have hœÉ : œÉ ^ p ^ n = 1 := by
    rw [DFunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End Œ± ‚Ü¶ g) rfl (fun g h ‚Ü¶ rfl) f (p ^ n)).symm.trans hf
  suffices : Fintype.card f.fixedPoints = (support œÉ)·∂ú.card
  ¬∑ exact this ‚ñ∏ (card_compl_support_modEq hœÉ).symm
  suffices f.fixedPoints = (support œÉ)·∂ú by
    simp only [this]; apply Fintype.card_coe
  simp [Set.ext_iff, IsFixedPt]"
Mathlib/Analysis/LocallyConvex/WithSeminorms.lean,SeminormFamily.basisSets_intersect,basisSets_intersect,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
    rcases p.basisSets_iff.mp hU with ‚ü®s, r‚ÇÅ, hr‚ÇÅ, hU‚ü©
    rcases p.basisSets_iff.mp hV with ‚ü®t, r‚ÇÇ, hr‚ÇÇ, hV‚ü©
    use ((s ‚à™ t).sup p).ball 0 (min r‚ÇÅ r‚ÇÇ)
    refine ‚ü®p.basisSets_mem (s ‚à™ t) (lt_min_iff.mpr ‚ü®hr‚ÇÅ, hr‚ÇÇ‚ü©), ?_‚ü©
    rw [hU, hV, ball_finset_sup_eq_iInter _ _ _ (lt_min_iff.mpr ‚ü®hr‚ÇÅ, hr‚ÇÇ‚ü©),
      ball_finset_sup_eq_iInter _ _ _ hr‚ÇÅ, ball_finset_sup_eq_iInter _ _ _ hr‚ÇÇ]
    exact
      Set.subset_inter
        (Set.iInter‚ÇÇ_mono' fun i hi =>
          ‚ü®i, Finset.subset_union_left _ _ hi, ball_mono <| min_le_left _ _‚ü©)
        (Set.iInter‚ÇÇ_mono' fun i hi =>
          ‚ü®i, Finset.subset_union_right _ _ hi, ball_mono <| min_le_right _ _‚ü©)","error:  function expected at
  Finset.subset_union_left ?m.25600
term has type
  ?m.25599 ‚àà ?m.25597 ‚à™ ?m.25598
error:  function expected at
  Finset.subset_union_right ?m.26759
term has type
  ?m.26758 ‚àà ?m.26756 ‚à™ ?m.26757","theorem basisSets_intersect (U V : Set E) (hU : U ‚àà p.basisSets) (hV : V ‚àà p.basisSets) :
    ‚àÉ z ‚àà p.basisSets, z ‚äÜ U ‚à© V ",":= by
  classical
    rcases p.basisSets_iff.mp hU with ‚ü®s, r‚ÇÅ, hr‚ÇÅ, hU‚ü©
    rcases p.basisSets_iff.mp hV with ‚ü®t, r‚ÇÇ, hr‚ÇÇ, hV‚ü©
    use ((s ‚à™ t).sup p).ball 0 (min r‚ÇÅ r‚ÇÇ)
    refine ‚ü®p.basisSets_mem (s ‚à™ t) (lt_min_iff.mpr ‚ü®hr‚ÇÅ, hr‚ÇÇ‚ü©), ?_‚ü©
    rw [hU, hV, ball_finset_sup_eq_iInter _ _ _ (lt_min_iff.mpr ‚ü®hr‚ÇÅ, hr‚ÇÇ‚ü©),
      ball_finset_sup_eq_iInter _ _ _ hr‚ÇÅ, ball_finset_sup_eq_iInter _ _ _ hr‚ÇÇ]
    exact
      Set.subset_inter
        (Set.iInter‚ÇÇ_mono' fun i hi =>
          ‚ü®i, Finset.subset_union_left hi, ball_mono <| min_le_left _ _‚ü©)
        (Set.iInter‚ÇÇ_mono' fun i hi =>
          ‚ü®i, Finset.subset_union_right hi, ball_mono <| min_le_right _ _‚ü©)",":= by
  classical
    rcases p.basisSets_iff.mp hU with ‚ü®s, r‚ÇÅ, hr‚ÇÅ, hU‚ü©
    rcases p.basisSets_iff.mp hV with ‚ü®t, r‚ÇÇ, hr‚ÇÇ, hV‚ü©
    use ((s ‚à™ t).sup p).ball 0 (min r‚ÇÅ r‚ÇÇ)
    refine ‚ü®p.basisSets_mem (s ‚à™ t) (lt_min_iff.mpr ‚ü®hr‚ÇÅ, hr‚ÇÇ‚ü©), ?_‚ü©
    rw [hU, hV, ball_finset_sup_eq_iInter _ _ _ hr‚ÇÅ, ball_finset_sup_eq_iInter _ _ _ hr‚ÇÇ]
    exact
      Set.subset_inter
        (Set.iInter‚ÇÇ_mono' fun i hi =>
          ‚ü®i, Finset.subset_union_left _ _ hi, ball_mono <| min_le_right _ _‚ü©)"
Mathlib/Analysis/NormedSpace/Dual.lean,NormedSpace.smul_mem_polar,smul_mem_polar,7dc162787d2a79bf721a83a87f641ace70251b17,":= by
  by_cases c_zero : c = 0
  ¬∑ simp only [c_zero, inv_zero, zero_smul]
    exact (dualPairing ùïú E).flip.zero_mem_polar _
  have eq : ‚àÄ z, ‚Äñc‚Åª¬π ‚Ä¢ x' z‚Äñ = ‚Äñc‚Åª¬π‚Äñ * ‚Äñx' z‚Äñ := fun z => norm_smul c‚Åª¬π _
  have le : ‚àÄ z, z ‚àà s ‚Üí ‚Äñc‚Åª¬π ‚Ä¢ x' z‚Äñ ‚â§ ‚Äñc‚Åª¬π‚Äñ * ‚Äñc‚Äñ := by
    intro z hzs
    rw [eq z]
    apply mul_le_mul (le_of_eq rfl) (hc z hzs) (norm_nonneg _) (norm_nonneg _)
  have cancel : ‚Äñc‚Åª¬π‚Äñ * ‚Äñc‚Äñ = 1 := by
    simp only [c_zero, norm_eq_zero, Ne.def, not_false_iff, inv_mul_cancel, norm_inv]
  rwa [cancel] at le","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.95120 ‚Üí ?m.95120 ‚Üí Prop
error:  unsolved goals
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : SeminormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
s : Set E
x' : Dual ùïú E
c : ùïú
hc : ‚àÄ z ‚àà s, ‚Äñx' z‚Äñ ‚â§ ‚Äñc‚Äñ
c_zero : ¬¨c = 0
eq : ‚àÄ (z : E), ‚Äñc‚Åª¬π ‚Ä¢ x' z‚Äñ = ‚Äñc‚Åª¬π‚Äñ * ‚Äñx' z‚Äñ
le : ‚àÄ z ‚àà s, ‚Äñc‚Åª¬π ‚Ä¢ x' z‚Äñ ‚â§ ‚Äñc‚Åª¬π‚Äñ * ‚Äñc‚Äñ
‚ä¢ ‚Äñc‚Äñ‚Åª¬π * ‚Äñc‚Äñ = 1","theorem smul_mem_polar {s : Set E} {x' : Dual ùïú E} {c : ùïú} (hc : ‚àÄ z, z ‚àà s ‚Üí ‚Äñx' z‚Äñ ‚â§ ‚Äñc‚Äñ) :
    c‚Åª¬π ‚Ä¢ x' ‚àà polar ùïú s ",":= by
  by_cases c_zero : c = 0
  ¬∑ simp only [c_zero, inv_zero, zero_smul]
    exact (dualPairing ùïú E).flip.zero_mem_polar _
  have eq : ‚àÄ z, ‚Äñc‚Åª¬π ‚Ä¢ x' z‚Äñ = ‚Äñc‚Åª¬π‚Äñ * ‚Äñx' z‚Äñ := fun z => norm_smul c‚Åª¬π _
  have le : ‚àÄ z, z ‚àà s ‚Üí ‚Äñc‚Åª¬π ‚Ä¢ x' z‚Äñ ‚â§ ‚Äñc‚Åª¬π‚Äñ * ‚Äñc‚Äñ := by
    intro z hzs
    rw [eq z]
    apply mul_le_mul (le_of_eq rfl) (hc z hzs) (norm_nonneg _) (norm_nonneg _)
  have cancel : ‚Äñc‚Åª¬π‚Äñ * ‚Äñc‚Äñ = 1 := by
    simp only [c_zero, norm_eq_zero, Ne, not_false_iff, inv_mul_cancel, norm_inv]
  rwa [cancel] at le",":= by
  by_cases c_zero : c = 0
  ¬∑ simp only [c_zero, inv_zero, zero_smul]
    exact (dualPairing ùïú E).flip.zero_mem_polar _
  have eq : ‚àÄ z, ‚Äñc‚Åª¬π ‚Ä¢ x' z‚Äñ = ‚Äñc‚Åª¬π‚Äñ * ‚Äñx' z‚Äñ := fun z => norm_smul c‚Åª¬π _
  have le : ‚àÄ z, z ‚àà s ‚Üí ‚Äñc‚Åª¬π ‚Ä¢ x' z‚Äñ ‚â§ ‚Äñc‚Åª¬π‚Äñ * ‚Äñc‚Äñ := by
    intro z hzs
    rw [eq z]
    apply mul_le_mul (le_of_eq rfl) (hc z hzs) (norm_nonneg _) (norm_nonneg _)
  have cancel : ‚Äñc‚Åª¬π‚Äñ * ‚Äñc‚Äñ = 1 := by
    simp only [c_zero, norm_eq_zero, Ne, not_false_iff, inv_mul_cancel, norm_inv]"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.aemeasurable_fderivWithin,aemeasurable_fderivWithin,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine' aemeasurable_of_unif_approx fun Œµ Œµpos => _
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, _‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
              (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine' ‚ü®g, g_meas.aemeasurable, _‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n ‚Ü¶ Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine' ae_sum_iff.2 fun n => _
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono (inter_subset_left _ _)
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono (inter_subset_right _ _) le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1","error:  function expected at
  inter_subset_left ?m.375907
term has type
  ?m.375906 ‚àà ?m.375904
error:  function expected at
  inter_subset_left ?m.377059
term has type
  ?m.377058 ‚àà ?m.377056
error:  function expected at
  inter_subset_right ?m.377638
term has type
  ?m.377637 ‚àà ?m.377636","theorem aemeasurable_fderivWithin (hs : MeasurableSet s)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (Œº.restrict s) ",":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, _‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
              (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ‚ü®g, g_meas.aemeasurable, ?_‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n ‚Ü¶ Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1",":= by
  refine aemeasurable_of_unif_approx fun Œµ Œµpos => ?_
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ, le_of_lt Œµpos‚ü©
  have Œ¥pos : 0 < Œ¥ := Œµpos
  obtain ‚ü®t, A, t_disj, t_meas, t_cover, ht, ?_‚ü© :
    ‚àÉ (t : ‚Ñï ‚Üí Set E) (A : ‚Ñï ‚Üí E ‚ÜíL[‚Ñù] E),
      Pairwise (Disjoint on t) ‚àß
        (‚àÄ n : ‚Ñï, MeasurableSet (t n)) ‚àß
          (s ‚äÜ ‚ãÉ n : ‚Ñï, t n) ‚àß
            (‚àÄ n : ‚Ñï, ApproximatesLinearOn f (A n) (s ‚à© t n) Œ¥) ‚àß
             (s.Nonempty ‚Üí ‚àÄ n, ‚àÉ y ‚àà s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Œ¥) fun _ =>
      Œ¥pos.ne'
  obtain ‚ü®g, g_meas, hg‚ü© :
      ‚àÉ g : E ‚Üí E ‚ÜíL[‚Ñù] E, Measurable g ‚àß ‚àÄ (n : ‚Ñï) (x : E), x ‚àà t n ‚Üí g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ‚ü®g, g_meas.aemeasurable, ?_‚ü©
  suffices H : ‚àÄ·µê x : E ‚àÇsum fun n ‚Ü¶ Œº.restrict (s ‚à© t n), dist (g x) (f' x) ‚â§ Œµ by
    have : Œº.restrict s ‚â§ sum fun n => Œº.restrict (s ‚à© t n) := by
      have : s = ‚ãÉ n, s ‚à© t n := by
        rw [‚Üê inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E‚ÇÅ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), ‚Äñf' x - A n‚Äñ‚Çä ‚â§ Œ¥ :=
    (ht n).norm_fderiv_sub_le Œº (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E‚ÇÇ : ‚àÄ·µê x : E ‚àÇŒº.restrict (s ‚à© t n), g x = A n := by
    suffices H : ‚àÄ·µê x : E ‚àÇŒº.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E‚ÇÅ, E‚ÇÇ] with x hx1 hx2
  rw [‚Üê nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.mul_le_addHaar_image_of_lt_det,mul_le_addHaar_image_of_lt_det,60e2ebb714fa61b2422f9c1cd4cff5fd09169c21,":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine' Tendsto.mul (tendsto_const_nhds.mul _) tendsto_id
      refine' (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ _
      simpa only [tsub_zero, inv_eq_zero, Ne.def] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toPartialEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target
  ¬∑ change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne.def] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne.def, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem mul_le_addHaar_image_of_lt_det (A : E ‚ÜíL[‚Ñù] E) {m : ‚Ñù‚â•0}
    (hm : (m : ‚Ñù‚â•0‚àû) < ENNReal.ofReal |A.det|) :
    ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù‚â•0),
      ‚àÄ (s : Set E) (f : E ‚Üí E), ApproximatesLinearOn f A s Œ¥ ‚Üí (m : ‚Ñù‚â•0‚àû) * Œº s ‚â§ Œº (f '' s) ",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ filter_upwards
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, inv_eq_zero, Ne] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 Œ¥‚ÇÄ Œ¥‚ÇÄpos
  filter_upwards [L1, L2]
  intro Œ¥ h1Œ¥ h2Œ¥ s f hf
  have hf' : ApproximatesLinearOn f (B : E ‚ÜíL[‚Ñù] E) s Œ¥ := by convert hf
  let F := hf'.toPartialEquiv h1Œ¥
  suffices H : Œº (F.symm '' F.target) ‚â§ (m‚Åª¬π : ‚Ñù‚â•0) * Œº F.target by
    change (m : ‚Ñù‚â•0‚àû) * Œº F.source ‚â§ Œº F.target
    rwa [‚Üê F.symm_image_target_eq_source, mul_comm, ‚Üê ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ‚Üê ENNReal.coe_inv mpos.ne']
    ¬∑ apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne] using mpos.ne'
    ¬∑ simp only [ENNReal.coe_ne_top, true_or_iff, Ne, not_false_iff]
  exact hŒ¥‚ÇÄ _ _ ((hf'.to_inv h1Œ¥).mono_num h2Œ¥.le)",":= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  ¬∑ apply eventually_of_forall
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ‚â† 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E ‚ÜíL[‚Ñù] E).det| < (m‚Åª¬π : ‚Ñù‚â•0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ‚ä¢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ‚ü®Œ¥‚ÇÄ, Œ¥‚ÇÄpos, hŒ¥‚ÇÄ‚ü© :
    ‚àÉ Œ¥ : ‚Ñù‚â•0,
      0 < Œ¥ ‚àß
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t := by
    have :
      ‚àÄ·∂† Œ¥ : ‚Ñù‚â•0 in ùìù[>] 0,
        ‚àÄ (t : Set E) (g : E ‚Üí E),
          ApproximatesLinearOn g (B.symm : E ‚ÜíL[‚Ñù] E) t Œ¥ ‚Üí Œº (g '' t) ‚â§ ‚Üëm‚Åª¬π * Œº t :=
      addHaar_image_le_mul_of_det_lt Œº B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ‚ü®Œ¥‚ÇÄ, h, h'‚ü©
    exact ‚ü®Œ¥‚ÇÄ, h', h‚ü©
  have L1 : ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), Subsingleton E ‚à® Œ¥ < ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π := by
    by_cases h : Subsingleton E
    ¬∑ simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ‚àÄ·∂† Œ¥ in ùìù (0 : ‚Ñù‚â•0), ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥ < Œ¥‚ÇÄ := by
    have :
      Tendsto (fun Œ¥ => ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - Œ¥)‚Åª¬π * Œ¥) (ùìù 0)
        (ùìù (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * (‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä‚Åª¬π - 0)‚Åª¬π * 0)) := by
      rcases eq_or_ne ‚Äñ(B.symm : E ‚ÜíL[‚Ñù] E)‚Äñ‚Çä 0 with (H | H)
      ¬∑ simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, tsub_zero] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv‚ÇÄ ?_
      simpa only [tsub_zero, tsub_zero, tsub_zero, tsub_zero] using tendsto_const_nhds
      refine Tendsto.mul ("
Mathlib/Topology/Homotopy/HomotopyGroup.lean,GenLoop.homotopicFrom,homotopicFrom,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  refine Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, ?_, ?_‚ü©?, _‚ü©
  pick_goal 3
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ rw [H.eq_fst]; exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    first
    | rw [H.apply_zero]
    | rw [H.apply_one]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv","warning:  GenLoop does not have a doc string
error:  unexpected token '?'; expected '‚ü©'","theorem homotopicFrom (i : N) {p q : Œ©^ N X x} :
    (toLoop i p).Homotopic (toLoop i q) ‚Üí Homotopic p q ",":= by
  refine Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, ?_, ?_‚ü©, ?_‚ü©
  pick_goal 3
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
        Function.uncurry_apply_pair]
      rw [H.eq_fst]
      exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
      Function.uncurry_apply_pair, ContinuousMap.HomotopyWith.apply_zero,
      ContinuousMap.HomotopyWith.apply_one, ne_eq, Path.coe_toContinuousMap, toLoop_apply_coe,
      ContinuousMap.curry_apply, ContinuousMap.comp_apply]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv",":= by
  refine Nonempty.map fun H => ‚ü®‚ü®homotopyFrom i H, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ rintro t y ‚ü®j, jH‚ü©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    ¬∑ rw [H.eq_fst]; exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    ¬∑ rw [p.2 _ ‚ü®j, jH‚ü©]; apply boundary; exact ‚ü®‚ü®j, h‚ü©, jH‚ü©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    first
    | rw [H.apply_zero]
    | rw [H.apply_one]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv"
Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean,WeierstrassCurve.Projective.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,4af78db5561dc403dfe87b4d65db41f803d0b39c,":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,  equation_iff,
      Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons, mul_zero,
      Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, zero_pow,
      zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or] at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]‚ü©","error:  application type mismatch
  div_mul_cancel ?m.248578 hQ
argument
  hQ
has type
  ¬¨Q 1 = 0 : Prop
but is expected to have type
  ?m.248576 : Type ?u.248575
error:  unsolved goals
R : Type u
inst‚úù¬π : CommRing R
W‚úù : Projective R
F : Type u
inst‚úù : Field F
W : Projective F
P Q : Fin 3 ‚Üí F
hPz : P 2 = 0
hQz : Q 2 = 0
hP : ¬¨P 1 = 0
hQ : ¬¨Q 1 = 0
‚ä¢ ![0, P 1 / Q 1 * Q 1, 0] = ![0, P 1, 0]","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel‚ÇÄ _ hQ]‚ü©",":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff, equation_iff,
      Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons, mul_zero,
      Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, zero_pow,
      zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or] at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ‚ü®Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]‚ü©"
Mathlib/Analysis/Calculus/InverseFunctionTheorem/ContDiff.lean,ContDiffAt.to_localInverse,to_localInverse,5d4fa55028ca22525074d4c2141f8f2a04dc0e32,":= by
  have := hf.localInverse_apply_image hf' hn
  apply (hf.toLocalHomeomorph f hf' hn).contDiffAt_symm
    (image_mem_toLocalHomeomorph_target hf hf' hn)
  ¬∑ convert hf'
  ¬∑ convert hf","error:  invalid field 'toLocalHomeomorph', the environment does not contain 'ContDiffAt.toLocalHomeomorph'
  hf
has type
  ContDiffAt ùïÇ n f a
error:  invalid field 'toLocalHomeomorph', the environment does not contain 'ContDiffWithinAt.toLocalHomeomorph'
  hf
has type
  ContDiffWithinAt ùïÇ n f Set.univ a
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hf
has type
  ‚àÄ (m : ‚Ñï), ‚Üëm ‚â§ n ‚Üí ‚àÉ u ‚àà nhdsWithin a (insert a Set.univ), ‚àÉ p, HasFTaylorSeriesUpToOn (‚Üëm) f p u","theorem to_localInverse {n : ‚Ñï‚àû} (hf : ContDiffAt ùïÇ n f a)
    (hf' : HasFDerivAt f (f' : E ‚ÜíL[ùïÇ] F) a) (hn : 1 ‚â§ n) :
    ContDiffAt ùïÇ n (hf.localInverse hf' hn) (f a) ",":= by
  have := hf.localInverse_apply_image hf' hn
  apply (hf.toPartialHomeomorph f hf' hn).contDiffAt_symm
    (image_mem_toPartialHomeomorph_target hf hf' hn)
  ¬∑ convert hf'
  ¬∑ convert hf",":= by
  have := hf.localInverse_apply_image hf' hn
  apply (hf.toLocalHomeomorph f hf' hn).contDiffAt_symm
    (image_mem_toLocalHomeomorph_target hf hf' hn)
  ¬∑ convert hf'"
Mathlib/FieldTheory/Separable.lean,Polynomial.separable_X_pow_sub_C,separable_X_pow_sub_C,c7bd9bd10c613e1788107ba753e252f069560f87,":= by
  nontriviality R
  rcases n.eq_zero_or_pos with (rfl | hpos)
  ¬∑ simp at hn
  apply (separable_def' (X ^ n - C (u : R))).2
  obtain ‚ü®n', hn'‚ü© := hn.exists_left_inv
  refine' ‚ü®-C ‚Üëu‚Åª¬π, C (‚Üëu‚Åª¬π : R) * C n' * X, _‚ü©
  rw [derivative_sub, derivative_C, sub_zero, derivative_pow X n, derivative_X, mul_one]
  calc
    -C ‚Üëu‚Åª¬π * (X ^ n - C ‚Üëu) + C ‚Üëu‚Åª¬π * C n' * X * (‚Üën * X ^ (n - 1)) =
        C (‚Üëu‚Åª¬π * ‚Üëu) - C ‚Üëu‚Åª¬π * X ^ n + C ‚Üëu‚Åª¬π * C (n' * ‚Üën) * (X * X ^ (n - 1)) := by
      simp only [C.map_mul, C_eq_nat_cast]
      ring
    _ = 1 := by
      simp only [Units.inv_mul, hn', C.map_one, mul_one, ‚Üê pow_succ,
        Nat.sub_add_cancel (show 1 ‚â§ n from hpos), sub_add_cancel]","warning:  `Polynomial.C_eq_nat_cast` has been deprecated, use `Polynomial.C_eq_natCast` instead
error:  unsolved goals
R : Type u
inst‚úù : CommRing R
n : ‚Ñï
u : RÀ£
hn : IsUnit ‚Üën
a‚úù : Nontrivial R
hpos : n > 0
n' : R
hn' : n' * ‚Üën = 1
‚ä¢ 1 - C ‚Üëu‚Åª¬π * X ^ n + C ‚Üëu‚Åª¬π * (X * X ^ (n - 1)) = 1","theorem separable_X_pow_sub_C_unit {n : ‚Ñï} (u : RÀ£) (hn : IsUnit (n : R)) :
    Separable (X ^ n - C (u : R)) ",":= by
  nontriviality R
  rcases n.eq_zero_or_pos with (rfl | hpos)
  ¬∑ simp at hn
  apply (separable_def' (X ^ n - C (u : R))).2
  obtain ‚ü®n', hn'‚ü© := hn.exists_left_inv
  refine ‚ü®-C ‚Üëu‚Åª¬π, C (‚Üëu‚Åª¬π : R) * C n' * X, ?_‚ü©
  rw [derivative_sub, derivative_C, sub_zero, derivative_pow X n, derivative_X, mul_one]
  calc
    -C ‚Üëu‚Åª¬π * (X ^ n - C ‚Üëu) + C ‚Üëu‚Åª¬π * C n' * X * (‚Üën * X ^ (n - 1)) =
        C (‚Üëu‚Åª¬π * ‚Üëu) - C ‚Üëu‚Åª¬π * X ^ n + C ‚Üëu‚Åª¬π * C (n' * ‚Üën) * (X * X ^ (n - 1)) := by
      simp only [C.map_mul, C_eq_natCast]
      ring
    _ = 1 := by
      simp only [Units.inv_mul, hn', C.map_one, mul_one, ‚Üê pow_succ',
        Nat.sub_add_cancel (show 1 ‚â§ n from hpos), sub_add_cancel]",":= by
  nontriviality R
  rcases n.eq_zero_or_pos with (rfl | hpos)
  ¬∑ simp at hn
  apply (separable_def' (X ^ n - C (u : R))).2
  obtain ‚ü®n', hn'‚ü© := hn.exists_left_inv
  refine ‚ü®-C ‚Üëu‚Åª¬π, C (‚Üëu‚Åª¬π : R) * C n' * X, ?_‚ü©
  rw [derivative_sub, derivative_C, sub_zero, derivative_pow X n, derivative_X, mul_one]
  calc
    -C ‚Üëu‚Åª¬π * (X ^ n - C ‚Üëu) + C ‚Üëu‚Åª¬π * C n' * X * (‚Üën * X ^ (n - 1)) =
        C (‚Üëu‚Åª¬π * ‚Üëu) - C ‚Üëu‚Åª¬π * X ^ n + C ‚Üëu‚Åª¬π * C (n' * ‚Üën) * (X * X ^ (n - 1)) := by
      simp only [C.map_mul, C_eq_natCast]
      ring
    _ = 1 := by
      simp only [Units.inv_mul, hn', C.map_one, mul_one, ‚Üê pow_succ,
        Nat.sub_add_cancel (show 1 ‚â§ n from hpos), sub_add_cancel]"
Mathlib/RingTheory/Ideal/Operations.lean,Ideal.prod_eq_bot,prod_eq_bot,cf251fadc95a820147ab6a516521a10d1dabd216,":= by
  rw [bot_eq_zero, prod_zero_iff_exists_zero]
  simp","error:  unknown identifier 'prod_zero_iff_exists_zero'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.301514
R‚úù : Type u
Œπ : Type u_1
inst‚úù¬≤ : CommSemiring R‚úù
I J K L : Ideal R‚úù
R : Type u_2
inst‚úù¬π : CommRing R
inst‚úù : IsDomain R
s : Multiset (Ideal R)
‚ä¢ s.prod = 0 ‚Üî ‚àÉ I ‚àà s, I = 0","theorem prod_eq_bot {R : Type*} [CommRing R] [IsDomain R] {s : Multiset (Ideal R)} :
    s.prod = ‚ä• ‚Üî ‚àÉ I ‚àà s, I = ‚ä• ",":= by
  simp",":= by
  rw [bot_eq_zero, prod_zero_iff_exists_zero]"
Mathlib/Algebra/Algebra/Hom.lean,RingHom.toIntAlgHom_injective,toIntAlgHom_injective,997e544cc107a670c989a8e6943e61e19978185e,":=
  fun _ _ e ‚Ü¶ FunLike.ext _ _ (fun x ‚Ü¶ FunLike.congr_fun e x)","warning:  AlgHom does not have a doc string
warning:  AlgHom does not have a doc string
error:  unknown constant 'FunLike.ext'","lemma toIntAlgHom_injective [Ring R] [Ring S] [Algebra ‚Ñ§ R] [Algebra ‚Ñ§ S] :
    Function.Injective (RingHom.toIntAlgHom : (R ‚Üí+* S) ‚Üí _) ",":=
  fun _ _ e ‚Ü¶ DFunLike.ext _ _ (fun x ‚Ü¶ DFunLike.congr_fun e x)",":=
  fun _ _ e ‚Ü¶ FunLike.ext _ _ (fun x : FunLike.congr_fun e x)"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.sum_weightedHomogeneousComponent,sum_weightedHomogeneousComponent,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  classical
  rw [finsum_eq_sum _ (weightedHomogeneousComponent_finsupp œÜ)]
  ext1 d
  simp only [coeff_sum, coeff_weightedHomogeneousComponent]
  rw [Finset.sum_eq_single (weightedDegree' w d)]
  ¬∑ rw [if_pos rfl]
  ¬∑ intro m _ hm'
    rw [if_neg hm'.symm]
  ¬∑ intro hm
    rw [if_pos rfl]
    simp only [Finite.mem_toFinset, mem_support, Ne.def, Classical.not_not] at hm
    have := coeff_weightedHomogeneousComponent (w := w) (weightedDegree' w d) œÜ d
    rw [hm, if_pos rfl, coeff_zero] at this
    exact this.symm","error:  unknown identifier 'weightedDegree''
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  if ?m.95273 = ?m.95273 then ?m.95275 else ?m.95276
case a
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
n : M
œÜ œà : MvPolynomial œÉ R
d : œÉ ‚Üí‚ÇÄ ‚Ñï
‚ä¢ (if (weightedDegree w) d = sorryAx M true then coeff d œÜ else 0) = coeff d œÜ
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  if ?m.95318 = ?m.95318 then ?m.95320 else ?m.95321
case a.h‚ÇÅ
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
n : M
œÜ œà : MvPolynomial œÉ R
d : œÉ ‚Üí‚ÇÄ ‚Ñï
hm : sorryAx M true ‚àâ ‚ãØ.toFinset
‚ä¢ (if (weightedDegree w) d = sorryAx M true then coeff d œÜ else 0) = 0","theorem sum_weightedHomogeneousComponent :
    (finsum fun m => weightedHomogeneousComponent w m œÜ) = œÜ ",":= by
  classical
  rw [finsum_eq_sum _ (weightedHomogeneousComponent_finsupp œÜ)]
  ext1 d
  simp only [coeff_sum, coeff_weightedHomogeneousComponent]
  rw [Finset.sum_eq_single (weightedDegree w d)]
  ¬∑ rw [if_pos rfl]
  ¬∑ intro m _ hm'
    rw [if_neg hm'.symm]
  ¬∑ intro hm
    rw [if_pos rfl]
    simp only [Finite.mem_toFinset, mem_support, Ne, Classical.not_not] at hm
    have := coeff_weightedHomogeneousComponent (w := w) (weightedDegree w d) œÜ d
    rw [hm, if_pos rfl, coeff_zero] at this
    exact this.symm",":= by
  classical
  rw [finsum_eq_sum _ (weightedHomogeneousComponent_finsupp œÜ)]
  ext1 d
  simp only [coeff_sum, coeff_weightedHomogeneousComponent]
  rw [Finset.sum_eq_single (weightedDegree' w d)]
  ¬∑ rw [if_pos rfl]
  ¬∑ intro m _ hm'
    rw [if_neg hm'.symm]
  ¬∑ intro hm
    rw [if_pos rfl]
    simp only [Finite.mem_toFinset, mem_support, Ne, Classical.not_not] at hm
    have := coeff_weightedHomogeneousComponent (w := w) (weightedDegree' w d) œÜ d
    rw [hm, if_pos rfl, coeff_zero] at this"
Mathlib/Topology/Metrizable/Urysohn.lean,TopologicalSpace.exists_inducing_l_infty,exists_inducing_l_infty,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono (inter_subset_left _ _)).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine' ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, _‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine' ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm _ _‚ü©
  ¬∑ refine' (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => _
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine' (eventually_all_finite h_fin).2 fun UV _ => _
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine' this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => _
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine' ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 _
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine' ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => _‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _","error:  function expected at
  inter_subset_left ?m.504
term has type
  ?m.503 ‚àà ?m.501","theorem exists_inducing_l_infty : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Inducing f ",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le Œ¥0.le).2 fun UV => ?_
    rcases le_total Œ¥ (Œµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa [sub_zero])]
  ¬∑ refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V ‚ü®hVB, hxV‚ü©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©
    refine ‚ü®Œµ UV, (Œµ01 UV).1, fun y (hy : dist (F y) (F x) < Œµ UV) => ?_‚ü©
    replace hy : dist (F y UV) (F x UV) < Œµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _",":= by
  rcases exists_countable_basis X with ‚ü®B, hBc, -, hB‚ü©
  let s : Set (Set X √ó Set X) := { UV ‚àà B √óÀ¢ B | closure UV.1 ‚äÜ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ‚ä•
  haveI : DiscreteTopology s := ‚ü®rfl‚ü©
  rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : X ‚Üí s ‚Üí·µá ‚Ñù, Inducing f
  ¬∑ exact ‚ü®fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ‚Ñï ‚Üí·µá ‚Ñù)).embedding.toInducing.comp hf‚ü©
  have hd : ‚àÄ UV : s, Disjoint (closure UV.1.1) UV.1.2·∂ú :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ‚ü®Œµ, Œµ01, hŒµ‚ü© : ‚àÉ Œµ : s ‚Üí ‚Ñù, (‚àÄ UV, Œµ UV ‚àà Ioc (0 : ‚Ñù) 1) ‚àß Tendsto Œµ cofinite (ùìù 0) := by
    rcases posSumOfEncodable zero_lt_one s with ‚ü®Œµ, Œµ0, c, hŒµc, hc1‚ü©
    refine ‚ü®Œµ, fun UV => ‚ü®Œµ0 UV, ?_‚ü©, hŒµc.summable.tendsto_cofinite_zero‚ü©
    exact (le_hasSum hŒµc UV fun _ _ => (Œµ0 _).le).trans hc1
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù),
      EqOn f 0 UV.1.1 ‚àß EqOn f (fun _ => Œµ UV) UV.1.2·∂ú ‚àß ‚àÄ x, f x ‚àà Icc 0 (Œµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©
    exact ‚ü®Œµ UV ‚Ä¢ f, fun x hx => by simp [hf‚ÇÄ (subset_closure hx)], fun x hx => by simp [hf‚ÇÅ hx],
      fun x => ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü©
  choose f hf0 hfŒµ hf0Œµ using this
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1 :=
    fun UV x => Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _)
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := fun x =>
    ‚ü®‚ü®fun UV => f UV x, continuous_of_discreteTopology‚ü©, 1,
      fun UV‚ÇÅ UV‚ÇÇ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ‚ü®F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_‚ü©
  ¬∑ refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Œ¥ Œ¥0 => ?_
    have h_fin : { UV : s | Œ¥ ‚â§ Œµ UV }.Finite := by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0)
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Œ¥0)
    refine this.mono fun y hy => (BoundedContinuousFunction.isometry_extend (hf01 _ _) (hf01 _ _)‚ü©
  have hF : ‚àÄ x UV, F x UV = f UV"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Œµ hŒµ).mono fun y hy => _
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",error:  unexpected token ';'; expected '|',"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ
    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by
      rw [Metric.tendsto_nhds] at h1 ‚ä¢
      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; ¬∑ simp [hx]
    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)
      (l.curry (ùìù x)) (ùìù 0) by
    rw [Metric.tendsto_nhds] at this ‚ä¢
    intro Œµ hŒµ
    specialize this Œµ hŒµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @IsROrC.norm_ofReal ùïú _ _, IsROrC.ofReal_inv, ‚Üê norm_smul]
  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E =>
          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ùìù (0 : G) = ùìù (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  simp only
  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ‚ä¢
    rw [‚Üê smul_sub] at hn
    rwa [sub_zero]
  ¬∑ 
    rw [Metric.tendsto_nhds]
    intro Œµ hŒµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Œµ hŒµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ‚ä¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
  ¬∑ 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by
      rw [Metric.tend"
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,7088139429bcf36357f4c44f3beff1a1374a13e1,":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp (config := { unfoldPartialApp := true }) only [inversion]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [Pi.smul_apply _, reflection_orthogonalComplement_singleton_eq_neg,
      real_inner_self_eq_norm_sq, two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Pi.smul_apply _, Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ F ‚ÜíL[‚Ñù] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚Ñù E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
a b c d y z : F
r R : ‚Ñù
x : F
hx : (fun x ‚Ü¶ c + x) x ‚â† c
‚ä¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x ‚Ü¶ c + x) x) c) ^ 2 ‚Ä¢
      ‚Üë{ toLinearEquiv := (reflection (Submodule.span ‚Ñù {(fun x ‚Ü¶ c + x) x - c})·óÆ).toLinearEquiv, continuous_toFun := ‚ãØ,
          continuous_invFun := ‚ãØ })
    ((fun x ‚Ü¶ c + x) x)","theorem hasFDerivAt_inversion (hx : x ‚â† c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 ‚Ä¢ (reflection (‚Ñù ‚àô (x - c))·óÆ : F ‚ÜíL[‚Ñù] F)) x ",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (?_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",":= by
  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©
  have : HasFDerivAt (inversion c R) (_ : F ‚ÜíL[‚Ñù] F) (c + x) := by
    simp (config := { unfoldPartialApp := true }) only [inversion]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_
  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by
      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']
    simp [Pi.smul_apply _, reflection_orthogonalComplement_singleton_eq_neg,
      real_inner_self_eq_norm_sq, two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  ¬∑ simp [Pi.smul_apply _, Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]"
Mathlib/Analysis/NormedSpace/MazurUlam.lean,IsometryEquiv.midpoint_fixed,midpoint_fixed,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  set z := midpoint ‚Ñù x y
  set s := { e : PE ‚âÉ·µ¢ PE | e x = x ‚àß e y = y }
  haveI : Nonempty s := ‚ü®‚ü®IsometryEquiv.refl PE, rfl, rfl‚ü©‚ü©
  have h_bdd : BddAbove (range fun e : s => dist ((e : PE ‚âÉ·µ¢ PE) z) z) := by
    refine' ‚ü®dist x z + dist x z, forall_range_iff.2 <| Subtype.forall.2 _‚ü©
    rintro e ‚ü®hx, _‚ü©
    calc
      dist (e z) z ‚â§ dist (e z) x + dist x z := dist_triangle (e z) x z
      _ = dist (e x) (e z) + dist x z := by rw [hx, dist_comm]
      _ = dist x z + dist x z := by erw [e.dist_eq x z]
  set R : PE ‚âÉ·µ¢ PE := (pointReflection ‚Ñù z).toIsometryEquiv
  set f : PE ‚âÉ·µ¢ PE ‚Üí PE ‚âÉ·µ¢ PE := fun e => ((e.trans R).trans e.symm).trans R
  have hf_dist : ‚àÄ e, dist (f e z) z = 2 * dist (e z) z := by
    intro e
    dsimp
    rw [dist_pointReflection_fixed, ‚Üê e.dist_eq, e.apply_symm_apply,
      dist_pointReflection_self_real, dist_comm]
  have hf_maps_to : MapsTo f s s := by
    rintro e ‚ü®hx, hy‚ü©
    constructor <;> simp [hx, hy, e.symm_apply_eq.2 hx.symm, e.symm_apply_eq.2 hy.symm]
  set c := ‚®Ü e : s, dist ((e : PE ‚âÉ·µ¢ PE) z) z
  have : c ‚â§ c / 2 := by
    apply ciSup_le
    rintro ‚ü®e, he‚ü©
    simp only [Subtype.coe_mk, le_div_iff' (zero_lt_two' ‚Ñù), ‚Üê hf_dist]
    exact le_ciSup h_bdd ‚ü®f e, hf_maps_to he‚ü©
  replace : c ‚â§ 0 := by linarith
  refine' fun e hx hy => dist_le_zero.1 (le_trans _ this)
  exact le_ciSup h_bdd ‚ü®e, hx, hy‚ü©","warning:  `Set.forall_range_iff` has been deprecated, use `Set.forall_mem_range` instead
error:  dsimp made no progress
error:  simp made no progress
error:  simp made no progress
error:  unsolved goals
case intro.left
E : Type u_1
PE : Type u_2
F : Type u_3
PF : Type u_4
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : MetricSpace PE
inst‚úù‚Å¥ : NormedAddTorsor E PE
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : NormedSpace ‚Ñù F
inst‚úù¬π : MetricSpace PF
inst‚úù : NormedAddTorsor F PF
x y : PE
z : PE := midpoint ‚Ñù x y
s : Set (PE ‚âÉ·µ¢ PE) := {e | e x = x ‚àß e y = y}
this : Nonempty ‚Üës
h_bdd : BddAbove (range fun e ‚Ü¶ dist (‚Üëe z) z)
R : PE ‚âÉ·µ¢ PE := (pointReflection ‚Ñù z).toIsometryEquiv
f : PE ‚âÉ·µ¢ PE ‚Üí PE ‚âÉ·µ¢ PE := fun e ‚Ü¶ ((e.trans R).trans e.symm).trans R
hf_dist : ‚àÄ (e : PE ‚âÉ·µ¢ PE), dist ((f e) z) z = 2 * dist (e z) z
e : PE ‚âÉ·µ¢ PE
hx : e x = x
hy : e y = y
‚ä¢ (f e) x = x

case intro.right
E : Type u_1
PE : Type u_2
F : Type u_3
PF : Type u_4
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : MetricSpace PE
inst‚úù‚Å¥ : NormedAddTorsor E PE
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : NormedSpace ‚Ñù F
inst‚úù¬π : MetricSpace PF
inst‚úù : NormedAddTorsor F PF
x y : PE
z : PE := midpoint ‚Ñù x y
s : Set (PE ‚âÉ·µ¢ PE) := {e | e x = x ‚àß e y = y}
this : Nonempty ‚Üës
h_bdd : BddAbove (range fun e ‚Ü¶ dist (‚Üëe z) z)
R : PE ‚âÉ·µ¢ PE := (pointReflection ‚Ñù z).toIsometryEquiv
f : PE ‚âÉ·µ¢ PE ‚Üí PE ‚âÉ·µ¢ PE := fun e ‚Ü¶ ((e.trans R).trans e.symm).trans R
hf_dist : ‚àÄ (e : PE ‚âÉ·µ¢ PE), dist ((f e) z) z = 2 * dist (e z) z
e : PE ‚âÉ·µ¢ PE
hx : e x = x
hy : e y = y
‚ä¢ (f e) y = y","theorem midpoint_fixed {x y : PE} :
    ‚àÄ e : PE ‚âÉ·µ¢ PE, e x = x ‚Üí e y = y ‚Üí e (midpoint ‚Ñù x y) = midpoint ‚Ñù x y ",":= by
  set z := midpoint ‚Ñù x y
  set s := { e : PE ‚âÉ·µ¢ PE | e x = x ‚àß e y = y }
  haveI : Nonempty s := ‚ü®‚ü®IsometryEquiv.refl PE, rfl, rfl‚ü©‚ü©
  have h_bdd : BddAbove (range fun e : s => dist ((e : PE ‚âÉ·µ¢ PE) z) z) := by
    refine ‚ü®dist x z + dist x z, forall_mem_range.2 <| Subtype.forall.2 ?_‚ü©
    rintro e ‚ü®hx, _‚ü©
    calc
      dist (e z) z ‚â§ dist (e z) x + dist x z := dist_triangle (e z) x z
      _ = dist (e x) (e z) + dist x z := by rw [hx, dist_comm]
      _ = dist x z + dist x z := by erw [e.dist_eq x z]
  set R : PE ‚âÉ·µ¢ PE := (pointReflection ‚Ñù z).toIsometryEquiv
  set f : PE ‚âÉ·µ¢ PE ‚Üí PE ‚âÉ·µ¢ PE := fun e => ((e.trans R).trans e.symm).trans R
  have hf_dist : ‚àÄ e, dist (f e z) z = 2 * dist (e z) z := by
    intro e
    dsimp [f, R]
    rw [dist_pointReflection_fixed, ‚Üê e.dist_eq, e.apply_symm_apply,
      dist_pointReflection_self_real, dist_comm]
  have hf_maps_to : MapsTo f s s := by
    rintro e ‚ü®hx, hy‚ü©
    constructor <;> simp [f, R, z, hx, hy, e.symm_apply_eq.2 hx.symm, e.symm_apply_eq.2 hy.symm]
  set c := ‚®Ü e : s, dist ((e : PE ‚âÉ·µ¢ PE) z) z
  have : c ‚â§ c / 2 := by
    apply ciSup_le
    rintro ‚ü®e, he‚ü©
    simp only [Subtype.coe_mk, le_div_iff' (zero_lt_two' ‚Ñù), ‚Üê hf_dist]
    exact le_ciSup h_bdd ‚ü®f e, hf_maps_to he‚ü©
  replace : c ‚â§ 0 := by linarith
  refine fun e hx hy => dist_le_zero.1 (le_trans ?_ this)
  exact le_ciSup h_bdd ‚ü®e, hx, hy‚ü©",":= by
  set z := midpoint ‚Ñù x y
  set s := { e : PE ‚âÉ·µ¢ PE | e x = x ‚àß e y = y }
  haveI : Nonempty s := ‚ü®‚ü®IsometryEquiv.refl PE, rfl, rfl‚ü©‚ü©
  have h_bdd : BddAbove (range fun e : s => dist ((e : PE ‚âÉ·µ¢ PE) z) z) := by
    refine ‚ü®dist x z + dist x z, forall_range_iff.2 <| Subtype.forall.2 ?_‚ü©
    rintro e ‚ü®hx, _‚ü©
    calc
      dist (e z) z ‚â§ dist (e z) x + dist x z := dist_triangle (e z) x z
      _ = dist (e x) (e z) + dist x z := by rw [hx, dist_comm]
      _ = dist x z + dist x z := by erw [e.dist_eq x z]
  set R : PE ‚âÉ·µ¢ PE := (pointReflection ‚Ñù z).toIsometryEquiv
  set f : PE ‚âÉ·µ¢ PE ‚Üí PE ‚âÉ·µ¢ PE := fun e => ((e.trans R).trans e.symm).trans R
  have hf_dist : ‚àÄ e, dist (f e z) z = 2 * dist (e z) z := by
    intro e
    dsimp
    rw [dist_pointReflection_fixed, ‚Üê e.dist_eq, e.apply_symm_apply,
      dist_pointReflection_self_real, dist_comm]
  have hf_maps_to : MapsTo f s s := by
    rintro e ‚ü®hx, hy‚ü©
    constructor <;> simp [hx, hy, e.symm_apply_eq.2 hx.symm, e.symm_apply_eq.2 hy.symm]
  set c := ‚®Ü e : s, dist ((e : PE ‚âÉ·µ¢ PE) z) z
  have : c ‚â§ c / 2 := by
    apply ciSup_le
    rintro ‚ü®e, he‚ü©
    simp only [Subtype.coe_mk, le_div_iff' (zero_lt_two' ‚Ñù), ‚Üê hf_dist]
    exact le_ciSup h_bdd ‚ü®f e, hf_maps_to he‚ü©
  replace : c ‚â§ 0 := by linarith
  refine fun e hx hy => dist_le_zero.1 (le_trans ?_ this)
  exact le_ciSup h_bdd ‚ü®e, hx, hy‚ü©"
