STARTING: verification of proofs from predicted_proof column in dataset from models/byt5_small/by_file/test_by_file_by_t5_small_tuned_prediction.csv - 2024-09-07 20:46:30.960965
STARTING: Lean repo copy creation
DONE: Lean repo copy creation
STARTING: retrieve cache
installing leantar 0.1.13
Attempting to download 4738 file(s)
Decompressing 4738 file(s)
Unpacked in 109996 ms
Completed successfully!
DONE: retrieved cache
Working on Mathlib/Algebra/Algebra/Hom.lean - 2024-09-07 22:09:16.597835.
---1/200---
For theorem RingHom.toIntAlgHom_injective in Mathlib/Algebra/Algebra/Hom.lean:
lemma toIntAlgHom_injective [Ring R] [Ring S] [Algebra ℤ R] [Algebra ℤ S] :
    Function.Injective (RingHom.toIntAlgHom : (R →+* S) → _) 


Original valid proof:
:=
  fun _ _ e ↦ DFunLike.ext _ _ (fun x ↦ DFunLike.congr_fun e x)


Verifying proof (Commit 997e544cc107a670c989a8e6943e61e19978185e):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Algebra/BigOperators/Finprod.lean - 2024-09-07 22:09:30.611511.
---2/200---
For theorem finprod_mul_distrib in Mathlib/Algebra/BigOperators/Finprod.lean:
theorem finprod_mul_distrib (hf : (mulSupport f).Finite) (hg : (mulSupport g).Finite) :
    ∏ᶠ i, f i * g i = (∏ᶠ i, f i) * ∏ᶠ i, g i 


Original valid proof:
:= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset f hf Finset.subset_union_left,
      finprod_eq_prod_of_mulSupport_toFinset_subset g hg Finset.subset_union_right, ←
      Finset.prod_mul_distrib]
    refine finprod_eq_prod_of_mulSupport_subset _ ?_
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ⟨hf, hg⟩
    simp [hf, hg]


Verifying proof (Commit a388d938162d1410e5399da3595dcff6614a5ffe):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finse

Attempt failure.

---3/200---
For theorem finprod_mul_distrib in Mathlib/Algebra/BigOperators/Finprod.lean:
theorem finprod_mul_distrib (hf : (mulSupport f).Finite) (hg : (mulSupport g).Finite) :
    ∏ᶠ i, f i * g i = (∏ᶠ i, f i) * ∏ᶠ i, g i 


Original valid proof:
:= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset f hf Finset.subset_union_left,
      finprod_eq_prod_of_mulSupport_toFinset_subset g hg Finset.subset_union_right, ←
      Finset.prod_mul_distrib]
    refine finprod_eq_prod_of_mulSupport_subset _ ?_
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ⟨hf, hg⟩
    simp [hf, hg]


Verifying proof (Commit 1e6b6c1919bb062a9b0fb6873d11444837c77e88):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.

Attempt failure.

---4/200---
For theorem finprod_mul_distrib in Mathlib/Algebra/BigOperators/Finprod.lean:
theorem finprod_mul_distrib (hf : (mulSupport f).Finite) (hg : (mulSupport g).Finite) :
    ∏ᶠ i, f i * g i = (∏ᶠ i, f i) * ∏ᶠ i, g i 


Original valid proof:
:= by
  classical
    rw [finprod_eq_prod_of_mulSupport_toFinset_subset f hf Finset.subset_union_left,
      finprod_eq_prod_of_mulSupport_toFinset_subset g hg Finset.subset_union_right, ←
      Finset.prod_mul_distrib]
    refine finprod_eq_prod_of_mulSupport_subset _ ?_
    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,
      mem_union, mem_mulSupport]
    intro x
    contrapose!
    rintro ⟨hf, hg⟩
    simp [hf, hg]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

Working on Mathlib/Algebra/BigOperators/Finsupp.lean - 2024-09-07 22:09:53.534406.
---5/200---
For theorem Finsupp.univ_sum_single in Mathlib/Algebra/BigOperators/Finsupp.lean:
theorem univ_sum_single [Fintype α] [AddCommMonoid M] (f : α →₀ M) :
    ∑ a : α, single a (f a) = f 


Original valid proof:
:= by
  classical
  refine DFunLike.coe_injective ?_
  simp_rw [coe_finset_sum, single_eq_pi_single, Finset.univ_sum_single]


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ_iff,
     

Attempt failure.

Working on Mathlib/Algebra/Category/ModuleCat/Free.lean - 2024-09-07 22:10:02.496653.
---6/200---
For theorem ModuleCat.linearIndependent_leftExact in Mathlib/Algebra/Category/ModuleCat/Free.lean:
theorem linearIndependent_leftExact : LinearIndependent R u 


Original valid proof:
:= by
  rw [linearIndependent_sum]
  refine ⟨?_, LinearIndependent.of_comp S.g hw, disjoint_span_sum hS hw huv⟩
  rw [huv, LinearMap.linearIndependent_iff S.f]; swap
  · rw [LinearMap.ker_eq_bot, ← mono_iff_injective]
    infer_instance
  exact hv


Verifying proof (Commit b87ae0155ddc0e5ed5896dcbc918e59a3d30fc43):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

Attempt failure.

Working on Mathlib/Algebra/DirectLimit.lean - 2024-09-07 22:10:13.489933.
---7/200---
For theorem Module.DirectLimit.map_comp in Mathlib/Algebra/DirectLimit.lean:
lemma map_comp [IsDirected ι (· ≤ ·)]
    (g₁ : (i : ι) → G i →ₗ[R] G' i) (g₂ : (i : ι) → G' i →ₗ[R] G'' i)
    (hg₁ : ∀ i j h, g₁ j ∘ₗ f i j h = f' i j h ∘ₗ g₁ i)
    (hg₂ : ∀ i j h, g₂ j ∘ₗ f' i j h = f'' i j h ∘ₗ g₂ i) :
    (map g₂ hg₂ ∘ₗ map g₁ hg₁ :
      DirectLimit G f →ₗ[R] DirectLimit G'' f'') =
    (map (fun i ↦ g₂ i ∘ₗ g₁ i) fun i j h ↦ by
        rw [LinearMap.comp_assoc, hg₁ i, ← LinearMap.comp_assoc, hg₂ i, LinearMap.comp_assoc] :
      DirectLimit G f →ₗ[R] DirectLimit G'' f'') 


Original valid proof:
:=
  DFunLike.ext _ _ fun x ↦ (isEmpty_or_nonempty ι).elim (fun _ ↦ Subsingleton.elim _ _) fun _ ↦
    x.induction_on fun i g ↦ by simp


Verifying proof (Commit f9a92ed3d67873862051aaeedcedfa1472745048):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Algebra/Divisibility/Basic.lean - 2024-09-07 22:10:29.807903.
---8/200---
For theorem dvd_pow in Mathlib/Algebra/Divisibility/Basic.lean:
lemma dvd_pow (hab : a ∣ b) : ∀ {n : ℕ} (_ : n ≠ 0), a ∣ b ^ n



Original valid proof:
  | 0,     hn => (hn rfl).elim
  | n + 1, _  => by rw [pow_succ']; exact hab.mul_right _


Verifying proof (Commit c9e4823690302d3379b7308a7a90735845de4ed2):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Algebra/FreeAlgebra.lean - 2024-09-07 22:10:33.222644.
---9/200---
For theorem FreeAlgebra.induction in Mathlib/Algebra/FreeAlgebra.lean:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a 


Original valid proof:
:= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X → s := Subtype.coind (ι R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a


Verifying proof (Commit 0bcbc985a529d2af125537fab684cb3a98de2f6f):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean - 2024-09-07 22:10:40.122048.
---10/200---
For theorem CochainComplex.HomComplex.δ_map in Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean:
lemma δ_map : δ n m (z.map Φ) = (δ n m z).map Φ 


Original valid proof:
:= by
  by_cases hnm : n + 1 = m
  · ext p q hpq
    dsimp
    simp only [δ_v n m hnm _ p q hpq (q-1) (p+1) rfl rfl,
      Functor.map_add, Functor.map_comp, Functor.map_units_smul,
      Cochain.map_v, Functor.mapHomologicalComplex_obj_d]
  · simp only [δ_shape _ _ hnm, Cochain.map_zero]


Verifying proof (Commit 9072ff84a0d139a344bf9eed4a00c4cd27596c79):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image

Attempt failure.

---11/200---
For theorem CochainComplex.HomComplex.Cochain.comp_assoc in Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean:
lemma comp_assoc {n₁ n₂ n₃ n₁₂ n₂₃ n₁₂₃ : ℤ}
    (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂) (z₃ : Cochain K L n₃)
    (h₁₂ : n₁ + n₂ = n₁₂) (h₂₃ : n₂ + n₃ = n₂₃) (h₁₂₃ : n₁ + n₂ + n₃ = n₁₂₃) :
    (z₁.comp z₂ h₁₂).comp z₃ (show n₁₂ + n₃ = n₁₂₃ by rw [← h₁₂, h₁₂₃]) =
      z₁.comp (z₂.comp z₃ h₂₃) (by rw [← h₂₃, ← h₁₂₃, add_assoc]) 


Original valid proof:
:= by
  substs h₁₂ h₂₃ h₁₂₃
  ext p q hpq
  rw [comp_v _ _ rfl p (p + n₁ + n₂) q (add_assoc _ _ _).symm (by omega),
    comp_v z₁ z₂ rfl p (p + n₁) (p + n₁ + n₂) (by omega) (by omega),
    comp_v z₁ (z₂.comp z₃ rfl) (add_assoc n₁ n₂ n₃).symm p (p + n₁) q (by omega) (by omega),
    comp_v z₂ z₃ rfl (p + n₁) (p + n₁ + n₂) q (by omega) (by omega), assoc]


Verifying proof (Commit 2c367bb7cdc3187abec81c2896087d55449d9b24):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---12/200---
For theorem CochainComplex.HomComplex.δ_map in Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean:
lemma δ_map : δ n m (z.map Φ) = (δ n m z).map Φ 


Original valid proof:
:= by
  by_cases hnm : n + 1 = m
  · ext p q hpq
    dsimp
    simp only [δ_v n m hnm _ p q hpq (q-1) (p+1) rfl rfl,
      Functor.map_add, Functor.map_comp, Functor.map_units_smul,
      Cochain.map_v, Functor.mapHomologicalComplex_obj_d]
  · simp only [δ_shape _ _ hnm, Cochain.map_zero]


Verifying proof (Commit 711caa31c35612f144d606cbe322e50891d53146):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

---13/200---
For theorem CochainComplex.HomComplex.δ_shape in Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean:
lemma δ_shape (hnm : ¬ n + 1 = m) (z : Cochain F G n) : δ n m z = 0 


Original valid proof:
:= by
  ext p q hpq
  dsimp only [δ]
  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  all_goals
    simp only [ComplexShape.up_Rel]
    exact fun _ => hnm (by omega)


Verifying proof (Commit 9072ff84a0d139a344bf9eed4a00c4cd27596c79):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Algebra/Order/Archimedean.lean - 2024-09-07 22:11:28.848684.
---14/200---
For theorem archimedean_iff_rat_lt in Mathlib/Algebra/Order/Archimedean.lean:
theorem archimedean_iff_rat_lt : Archimedean α ↔ ∀ x : α, ∃ q : ℚ, x < q where



Original valid proof:
  mp := @exists_rat_gt α _
  mpr H := archimedean_iff_nat_lt.2 fun x ↦
    let ⟨q, h⟩ := H x; ⟨⌈q⌉₊, lt_of_lt_of_le h <| mod_cast Nat.le_ceil _⟩


Verifying proof (Commit 03690a4c3252f422184189d0b6a6dd8d1c55d551):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
          Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,

Attempt failure.

---15/200---
For theorem existsUnique_zsmul_near_of_pos in Mathlib/Algebra/Order/Archimedean.lean:
theorem existsUnique_zsmul_near_of_pos {a : α} (ha : 0 < a) (g : α) :
    ∃! k : ℤ, k • a ≤ g ∧ g < (k + 1) • a 


Original valid proof:
:= by
  let s : Set ℤ := { n : ℤ | n • a ≤ g }
  obtain ⟨k, hk : -g ≤ k • a⟩ := Archimedean.arch (-g) ha
  have h_ne : s.Nonempty := ⟨-k, by simpa [s] using neg_le_neg hk⟩
  obtain ⟨k, hk⟩ := Archimedean.arch g ha
  have h_bdd : ∀ n ∈ s, n ≤ (k : ℤ) := by
    intro n hn
    apply (zsmul_le_zsmul_iff ha).mp
    rw [← natCast_zsmul] at hk
    exact le_trans hn hk
  obtain ⟨m, hm, hm'⟩ := Int.exists_greatest_of_bdd ⟨k, h_bdd⟩ h_ne
  have hm'' : g < (m + 1) • a := by
    contrapose! hm'
    exact ⟨m + 1, hm', lt_add_one _⟩
  refine ⟨m, ⟨hm, hm''⟩, fun n hn => (hm' n hn.1).antisymm <| Int.le_of_lt_add_one ?_⟩
  rw [← zsmul_lt_zsmul_iff ha]
  exact lt_of_le_of_lt hm hn.2


Verifying proof (Commit daa535fc320141e24b1bc6af2e4928f53d12eb9d):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

Attempt failure.

Working on Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean - 2024-09-07 22:11:40.560774.
---16/200---
For theorem Polynomial.natTrailingDegree_eq_support_min' in Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean:
theorem natTrailingDegree_eq_support_min' (h : p ≠ 0) :
    natTrailingDegree p = p.support.min' (nonempty_support_iff.mpr h) 


Original valid proof:
:= by
  apply le_antisymm
  · apply le_min'
    intro y hy
    exact natTrailingDegree_le_of_mem_supp y hy
  · apply Finset.min'_le
    exact mem_support_iff.mpr (trailingCoeff_nonzero_iff_nonzero.mpr h)


Verifying proof (Commit bc769a9f781a01550bc7da7431e6157f3b3d6c81):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Algebra/Polynomial/Module/Basic.lean - 2024-09-07 22:11:46.405573.
---17/200---
For theorem PolynomialModule.monomial_smul_single in Mathlib/Algebra/Polynomial/Module/Basic.lean:
theorem monomial_smul_single (i : ℕ) (r : R) (j : ℕ) (m : M) :
    monomial i r • single R j m = single R (i + j) (r • m) 


Original valid proof:
:= by
  simp only [LinearMap.mul_apply, Polynomial.aeval_monomial, LinearMap.pow_apply,
    Module.algebraMap_end_apply, smul_def]
  induction i generalizing r j m with
  | zero =>
    rw [Function.iterate_zero, zero_add]
    exact Finsupp.smul_single r j m
  | succ n hn =>
    rw [Function.iterate_succ, Function.comp_apply, add_assoc, ← hn]
    congr 2
    rw [Nat.one_add]
    exact Finsupp.mapDomain_single


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean - 2024-09-07 22:11:57.051047.
---18/200---
For theorem WeierstrassCurve.Ψ_odd in Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean:
lemma Ψ_odd (m : ℕ) : W.Ψ (2 * (m + 2) + 1) =
    W.Ψ (m + 4) * W.Ψ (m + 2) ^ 3 - W.Ψ (m + 1) * W.Ψ (m + 3) ^ 3 +
      W.toAffine.polynomial * (16 * W.toAffine.polynomial - 8 * W.ψ₂ ^ 2) * C
        (if Even m then W.preΨ' (m + 4) * W.preΨ' (m + 2) ^ 3
          else -W.preΨ' (m + 1) * W.preΨ' (m + 3) ^ 3) 


Original valid proof:
:= by
  repeat erw [Ψ_ofNat]
  simp_rw [preΨ'_odd, if_neg (m + 2).not_even_two_mul_add_one, Nat.even_add_one, ite_not]
  split_ifs <;> C_simp <;> rw [C_Ψ₂Sq] <;> ring1


Verifying proof (Commit eda04d24f539d275bf9161920e57d3d1d3781080):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean - 2024-09-07 22:13:08.312223.
---19/200---
For theorem WeierstrassCurve.Projective.equiv_of_Z_eq_zero in Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean:
lemma equiv_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q 


Original valid proof:
:= by
  rw [fin3_def P, hPz] at hP ⊢
  rw [fin3_def Q, hQz] at hQ ⊢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ⟨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel₀ _ hQ]⟩


Verifying proof (Commit 403f0036f3625bbf32f578e4b9f9f7ff5d5648bd):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

Attempt failure.

---20/200---
For theorem WeierstrassCurve.Projective.equiv_of_Z_eq_zero in Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean:
lemma equiv_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q 


Original valid proof:
:= by
  rw [fin3_def P, hPz] at hP ⊢
  rw [fin3_def Q, hQz] at hQ ⊢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ⟨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel₀ _ hQ]⟩


Verifying proof (Commit a83fc959459475e93bffd2243ee0a7c1d9f53d34):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---21/200---
For theorem WeierstrassCurve.Projective.equiv_of_Z_eq_zero in Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean:
lemma equiv_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q 


Original valid proof:
:= by
  rw [fin3_def P, hPz] at hP ⊢
  rw [fin3_def Q, hQz] at hQ ⊢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ⟨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel₀ _ hQ]⟩


Verifying proof (Commit 4af78db5561dc403dfe87b4d65db41f803d0b39c):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/AlgebraicTopology/SimplexCategory.lean - 2024-09-07 22:13:39.477454.
---22/200---
For theorem SimplexCategory.δ_comp_σ_of_gt in Mathlib/AlgebraicTopology/SimplexCategory.lean:
theorem δ_comp_σ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    δ i.succ ≫ σ (Fin.castSucc j) = σ j ≫ δ i 


Original valid proof:
:= by
  ext k : 3
  dsimp [δ, σ]
  rcases le_or_lt k i with (hik | hik)
  · rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    · rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    · rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  · rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]


Verifying proof (Commit d7f8050468d4e16195b721085d9c4536194abc3e):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

Working on Mathlib/Analysis/Analytic/Meromorphic.lean - 2024-09-07 22:13:46.822525.
---23/200---
For theorem MeromorphicAt.order_eq_int_iff in Mathlib/Analysis/Analytic/Meromorphic.lean:
lemma order_eq_int_iff {f : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℤ) : hf.order = n ↔
    ∃ g : 𝕜 → E, AnalyticAt 𝕜 g x ∧ g x ≠ 0 ∧ ∀ᶠ z in 𝓝[≠] x, f z = (z - x) ^ n • g z 


Original valid proof:
:= by
  unfold order
  by_cases h : hf.choose_spec.order = ⊤
  · rw [h, WithTop.map_top, ← WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ⟨g, hg_an, hg_ne, hg_eq⟩ ↦ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ← AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ⊢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ← mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  · obtain ⟨m, h⟩ := WithTop.ne_top_iff_exists.mp h
    rw [← h, WithTop.map_coe, ← WithTop.coe_natCast, ← coe_sub, WithTop.coe_inj]
    obtain ⟨g, hg_an, hg_ne, hg_eq⟩ := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ∀ᶠ (z : 𝕜) in 𝓝[≠] x, f z = (z - x) ^ (↑m - ↑hf.choose : ℤ) • g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [← smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ← mul_smul,
        ← zpow_add₀ (sub_ne_zero.mpr hz), ← add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ⟨fun h ↦ ⟨g, hg_an, hg_ne, h ▸ hg_eq⟩,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ⟨g, hg_an, hg_ne, hg_eq⟩⟩


Verifying proof (Commit 1df5e9f2d5d2defceda7b95892bf4c4bb80859af):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---24/200---
For theorem MeromorphicAt.order_eq_int_iff in Mathlib/Analysis/Analytic/Meromorphic.lean:
lemma order_eq_int_iff {f : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℤ) : hf.order = n ↔
    ∃ g : 𝕜 → E, AnalyticAt 𝕜 g x ∧ g x ≠ 0 ∧ ∀ᶠ z in 𝓝[≠] x, f z = (z - x) ^ n • g z 


Original valid proof:
:= by
  unfold order
  by_cases h : hf.choose_spec.order = ⊤
  · rw [h, WithTop.map_top, ← WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ⟨g, hg_an, hg_ne, hg_eq⟩ ↦ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ← AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ⊢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ← mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  · obtain ⟨m, h⟩ := WithTop.ne_top_iff_exists.mp h
    rw [← h, WithTop.map_coe, ← WithTop.coe_natCast, ← coe_sub, WithTop.coe_inj]
    obtain ⟨g, hg_an, hg_ne, hg_eq⟩ := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ∀ᶠ (z : 𝕜) in 𝓝[≠] x, f z = (z - x) ^ (↑m - ↑hf.choose : ℤ) • g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [← smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ← mul_smul,
        ← zpow_add₀ (sub_ne_zero.mpr hz), ← add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ⟨fun h ↦ ⟨g, hg_an, hg_ne, h ▸ hg_eq⟩,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ⟨g, hg_an, hg_ne, hg_eq⟩⟩


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Analysis/Analytic/Uniqueness.lean - 2024-09-07 22:14:20.381228.
---25/200---
For theorem AnalyticOn.eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux in Mathlib/Analysis/Analytic/Uniqueness.lean:
theorem eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux [CompleteSpace F] {f : E → F} {U : Set E}
    (hf : AnalyticOn 𝕜 f U) (hU : IsPreconnected U) {z₀ : E} (h₀ : z₀ ∈ U) (hfz₀ : f =ᶠ[𝓝 z₀] 0) :
    EqOn f 0 U 


Original valid proof:
:= by
  let u := {x | f =ᶠ[𝓝 x] 0}
  suffices main : closure u ∩ U ⊆ u by
    have Uu : U ⊆ u :=
      hU.subset_of_closure_inter_subset isOpen_setOf_eventually_nhds ⟨z₀, h₀, hfz₀⟩ main
    intro z hz
    simpa using mem_of_mem_nhds (Uu hz)
  rintro x ⟨xu, xU⟩
  rcases hf x xU with ⟨p, r, hp⟩
  obtain ⟨y, yu, hxy⟩ : ∃ y ∈ u, edist x y < r / 2 :=
    EMetric.mem_closure_iff.1 xu (r / 2) (ENNReal.half_pos hp.r_pos.ne')
  let q := p.changeOrigin (y - x)
  have has_series : HasFPowerSeriesOnBall f q y (r / 2) := by
    have A : (‖y - x‖₊ : ℝ≥0∞) < r / 2 := by rwa [edist_comm, edist_eq_coe_nnnorm_sub] at hxy
    have := hp.changeOrigin (A.trans_le ENNReal.half_le_self)
    simp only [add_sub_cancel] at this
    apply this.mono (ENNReal.half_pos hp.r_pos.ne')
    apply ENNReal.le_sub_of_add_le_left ENNReal.coe_ne_top
    apply (add_le_add A.le (le_refl (r / 2))).trans (le_of_eq _)
    exact ENNReal.add_halves _
  have M : EMetric.ball y (r / 2) ∈ 𝓝 x := EMetric.isOpen_ball.mem_nhds hxy
  filter_upwards [M] with z hz
  have A : HasSum (fun n : ℕ => q n fun _ : Fin n => z - y) (f z) := has_series.hasSum_sub hz
  have B : HasSum (fun n : ℕ => q n fun _ : Fin n => z - y) 0 := by
    have : HasFPowerSeriesAt 0 q y := has_series.hasFPowerSeriesAt.congr yu
    convert hasSum_zero (α := F) using 2
    ext n
    exact this.apply_eq_zero n _
  exact HasSum.unique A B


Verifying proof (Commit 4a37a8e778eb3014aeb05af1b09f6de104536d53):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean - 2024-09-07 22:14:27.270412.
---26/200---
For theorem BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le in Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}
    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)
    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}
    (hc : I.distortion ≤ c) :
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
          BoxAdditiveMap.volume)‖ ≤
      2 * ε * c * ∏ j, (I.upper j - I.lower j) 


Original valid proof:
:= by
  set e : ℝ → (Fin n → ℝ) → (Fin (n + 1) → ℝ) := i.insertNth (α := fun _ ↦ ℝ)
  have Hl : I.lower i ∈ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ∈ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ∀ x ∈ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ⊥ (f ∘ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ∀ y ∈ Box.Icc (I.face i),
      ‖f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‖ ≤
        2 * ε * diam (Box.Icc I) := fun y hy ↦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * ‖y - x‖ at hε
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‖g (e (I.lower i) y) - g (e (I.upper i) y)‖ ≤ _
    · congr 1
      have := Fin.insertNth_sub_same (α := fun _ ↦ ℝ) i (I.upper i) (I.lower i) y
      simp only [← this, f'.map_sub]; abel
    · have : ∀ z ∈ Icc (I.lower i) (I.upper i), e z y ∈ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hε : ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * diam (Box.Icc I) := by
        intro y hy
        refine (hε y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [← dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hε _ (this _ Hl)) (hε _ (this _ Hu))
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
            (integral (I.face i) ⊥ (f ∘ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ⊥ (f ∘ e (I.lower i)) BoxAdditiveMap.volume)‖ =
        ‖integral.{0, u, u} (I.face i) ⊥
            (fun x : Fin n → ℝ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‖ := by
      rw [← integral_sub (Hi _ Hu) (Hi _ Hl), ← Box.volume_face_mul i, mul_smul, ← Box.volume_apply,
        ← BoxAdditiveMap.toSMul_apply, ← integral_const, ← BoxAdditiveMap.volume,
        ← integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(· ∘ ·), Pi.sub_def, ← f'.map_smul, ← Pi.single_smul', smul_eq_mul, mul_one]
    _ ≤ (volume (I.face i : Set (Fin n → ℝ))).toReal * (2 * ε * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * ε)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
      rw [← Measure.toBoxAdditive_apply, Box.volume_apply, ← I.volume_face_mul i]
      ac_rfl


Verifying proof (Commit 01cbe052ff3f63d184556afa56666d0df4fed183):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---27/200---
For theorem BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le in Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}
    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)
    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}
    (hc : I.distortion ≤ c) :
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
          BoxAdditiveMap.volume)‖ ≤
      2 * ε * c * ∏ j, (I.upper j - I.lower j) 


Original valid proof:
:= by
  set e : ℝ → (Fin n → ℝ) → (Fin (n + 1) → ℝ) := i.insertNth (α := fun _ ↦ ℝ)
  have Hl : I.lower i ∈ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ∈ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ∀ x ∈ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ⊥ (f ∘ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ∀ y ∈ Box.Icc (I.face i),
      ‖f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‖ ≤
        2 * ε * diam (Box.Icc I) := fun y hy ↦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * ‖y - x‖ at hε
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‖g (e (I.lower i) y) - g (e (I.upper i) y)‖ ≤ _
    · congr 1
      have := Fin.insertNth_sub_same (α := fun _ ↦ ℝ) i (I.upper i) (I.lower i) y
      simp only [← this, f'.map_sub]; abel
    · have : ∀ z ∈ Icc (I.lower i) (I.upper i), e z y ∈ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hε : ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * diam (Box.Icc I) := by
        intro y hy
        refine (hε y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [← dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hε _ (this _ Hl)) (hε _ (this _ Hu))
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
            (integral (I.face i) ⊥ (f ∘ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ⊥ (f ∘ e (I.lower i)) BoxAdditiveMap.volume)‖ =
        ‖integral.{0, u, u} (I.face i) ⊥
            (fun x : Fin n → ℝ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‖ := by
      rw [← integral_sub (Hi _ Hu) (Hi _ Hl), ← Box.volume_face_mul i, mul_smul, ← Box.volume_apply,
        ← BoxAdditiveMap.toSMul_apply, ← integral_const, ← BoxAdditiveMap.volume,
        ← integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(· ∘ ·), Pi.sub_def, ← f'.map_smul, ← Pi.single_smul', smul_eq_mul, mul_one]
    _ ≤ (volume (I.face i : Set (Fin n → ℝ))).toReal * (2 * ε * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * ε)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
      rw [← Measure.toBoxAdditive_apply, Box.volume_apply, ← I.volume_face_mul i]
      ac_rfl


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Basic.lean - 2024-09-07 22:14:59.131871.
---28/200---
For theorem HasFDerivWithinAt.of_nhdsWithin_eq_bot in Mathlib/Analysis/Calculus/FDeriv/Basic.lean:
theorem HasFDerivWithinAt.of_nhdsWithin_eq_bot (h : 𝓝[s\{x}] x = ⊥) :
    HasFDerivWithinAt f f' s x 


Original valid proof:
:= by
  rw [← hasFDerivWithinAt_diff_singleton x, HasFDerivWithinAt, h, hasFDerivAtFilter_iff_isLittleO]
  apply isLittleO_bot


Verifying proof (Commit 5ef74df5e417f4c5830ecf7f3e69a800274c3b4e):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    simp only [Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Fu

Attempt failure.

Working on Mathlib/Analysis/Calculus/FormalMultilinearSeries.lean - 2024-09-07 22:15:15.664644.
---29/200---
For theorem FormalMultilinearSeries.coeff_iterate_fslope in Mathlib/Analysis/Calculus/FormalMultilinearSeries.lean:
theorem coeff_iterate_fslope (k n : ℕ) : (fslope^[k] p).coeff n = p.coeff (n + k) 


Original valid proof:
:= by
  induction k generalizing p with
  | zero => rfl
  | succ k ih => simp [ih, add_assoc]


Verifying proof (Commit 0c824fb54f74f0c66db893166b73e377be2feb6f):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Analysis/Calculus/InverseFunctionTheorem/ContDiff.lean - 2024-09-07 22:15:30.821746.
---30/200---
For theorem ContDiffAt.to_localInverse in Mathlib/Analysis/Calculus/InverseFunctionTheorem/ContDiff.lean:
theorem to_localInverse {n : ℕ∞} (hf : ContDiffAt 𝕂 n f a)
    (hf' : HasFDerivAt f (f' : E →L[𝕂] F) a) (hn : 1 ≤ n) :
    ContDiffAt 𝕂 n (hf.localInverse hf' hn) (f a) 


Original valid proof:
:= by
  have := hf.localInverse_apply_image hf' hn
  apply (hf.toPartialHomeomorph f hf' hn).contDiffAt_symm
    (image_mem_toPartialHomeomorph_target hf hf' hn)
  · convert hf'
  · convert hf


Verifying proof (Commit 5d4fa55028ca22525074d4c2141f8f2a04dc0e32):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

Attempt failure.

Working on Mathlib/Analysis/Calculus/LHopital.lean - 2024-09-07 22:15:40.334063.
---31/200---
For theorem deriv.lhopital_zero_right_on_Ioo in Mathlib/Analysis/Calculus/LHopital.lean:
theorem lhopital_zero_right_on_Ioo (hff' : ∀ x ∈ Ioo a b, HasDerivAt f (f' x) x)
    (hgg' : ∀ x ∈ Ioo a b, HasDerivAt g (g' x) x) (hg' : ∀ x ∈ Ioo a b, g' x ≠ 0)
    (hfa : Tendsto f (𝓝[>] a) (𝓝 0)) (hga : Tendsto g (𝓝[>] a) (𝓝 0))
    (hdiv : Tendsto (fun x => f' x / g' x) (𝓝[>] a) l) :
    Tendsto (fun x => f x / g x) (𝓝[>] a) l 


Original valid proof:
:= by
  have sub : ∀ x ∈ Ioo a b, Ioo a x ⊆ Ioo a b := fun x hx =>
    Ioo_subset_Ioo (le_refl a) (le_of_lt hx.2)
  have hg : ∀ x ∈ Ioo a b, g x ≠ 0 := by
    intro x hx h
    have : Tendsto g (𝓝[<] x) (𝓝 0) := by
      rw [← h, ← nhdsWithin_Ioo_eq_nhdsWithin_Iio hx.1]
      exact ((hgg' x hx).continuousAt.continuousWithinAt.mono <| sub x hx).tendsto
    obtain ⟨y, hyx, hy⟩ : ∃ c ∈ Ioo a x, g' c = 0 :=
      exists_hasDerivAt_eq_zero' hx.1 hga this fun y hy => hgg' y <| sub x hx hy
    exact hg' y (sub x hx hyx) hy
  have : ∀ x ∈ Ioo a b, ∃ c ∈ Ioo a x, f x * g' c = g x * f' c := by
    intro x hx
    rw [← sub_zero (f x), ← sub_zero (g x)]
    exact exists_ratio_hasDerivAt_eq_ratio_slope' g g' hx.1 f f' (fun y hy => hgg' y <| sub x hx hy)
      (fun y hy => hff' y <| sub x hx hy) hga hfa
      (tendsto_nhdsWithin_of_tendsto_nhds (hgg' x hx).continuousAt.tendsto)
      (tendsto_nhdsWithin_of_tendsto_nhds (hff' x hx).continuousAt.tendsto)
  choose! c hc using this
  have : ∀ x ∈ Ioo a b, ((fun x' => f' x' / g' x') ∘ c) x = f x / g x := by
    intro x hx
    rcases hc x hx with ⟨h₁, h₂⟩
    field_simp [hg x hx, hg' (c x) ((sub x hx) h₁)]
    simp only [h₂]
    rw [mul_comm]
  have cmp : ∀ x ∈ Ioo a b, a < c x ∧ c x < x := fun x hx => (hc x hx).1
  rw [← nhdsWithin_Ioo_eq_nhdsWithin_Ioi hab]
  apply tendsto_nhdsWithin_congr this
  apply hdiv.comp
  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _
    (tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds
      (tendsto_nhdsWithin_of_tendsto_nhds tendsto_id) ?_ ?_) ?_
  all_goals
    apply eventually_nhdsWithin_of_forall
    intro x hx
    have := cmp x hx
    try simp
    linarith [this]


Verifying proof (Commit 4da4e0ebfbf51ecc2e064d04970434177efdead3):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
          Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,

Attempt failure.

Working on Mathlib/Analysis/Calculus/LocalExtr/Polynomial.lean - 2024-09-07 22:15:48.711276.
---32/200---
For theorem Polynomial.card_roots_le_derivative in Mathlib/Analysis/Calculus/LocalExtr/Polynomial.lean:
theorem card_roots_le_derivative (p : ℝ[X]) :
    Multiset.card p.roots ≤ Multiset.card (derivative p).roots + 1 


Original valid proof:
:=
  calc
    Multiset.card p.roots = ∑ x ∈ p.roots.toFinset, p.roots.count x :=
      (Multiset.toFinset_sum_count_eq _).symm
    _ = ∑ x ∈ p.roots.toFinset, (p.roots.count x - 1 + 1) :=
      (Eq.symm <| Finset.sum_congr rfl fun x hx => tsub_add_cancel_of_le <|
        Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx)
    _ = (∑ x ∈ p.roots.toFinset, (p.rootMultiplicity x - 1)) + p.roots.toFinset.card := by
      simp only [Finset.sum_add_distrib, Finset.card_eq_sum_ones, count_roots]
    _ ≤ (∑ x ∈ p.roots.toFinset, p.derivative.rootMultiplicity x) +
          ((p.derivative.roots.toFinset \ p.roots.toFinset).card + 1) :=
      (add_le_add
        (Finset.sum_le_sum fun x _ => rootMultiplicity_sub_one_le_derivative_rootMultiplicity _ _)
        p.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ)
    _ ≤ (∑ x ∈ p.roots.toFinset, p.derivative.roots.count x) +
          ((∑ x ∈ p.derivative.roots.toFinset \ p.roots.toFinset,
            p.derivative.roots.count x) + 1) := by
      simp only [← count_roots]
      refine add_le_add_left (add_le_add_right ((Finset.card_eq_sum_ones _).trans_le ?_) _) _
      refine Finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| ?_
      rw [Multiset.count_pos, ← Multiset.mem_toFinset]
      exact (Finset.mem_sdiff.1 hx).1
    _ = Multiset.card (derivative p).roots + 1 := by
      rw [← add_assoc, ← Finset.sum_union Finset.disjoint_sdiff, Finset.union_sdiff_self_eq_union, ←
        Multiset.toFinset_sum_count_eq, ← Finset.sum_subset Finset.subset_union_right]
      intro x _ hx₂
      simpa only [Multiset.mem_toFinset, Multiset.count_eq_zero] using hx₂


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

Working on Mathlib/Analysis/Calculus/Monotone.lean - 2024-09-07 22:15:55.365855.
---33/200---
For theorem MonotoneOn.ae_differentiableWithinAt_of_mem in Mathlib/Analysis/Calculus/Monotone.lean:
theorem MonotoneOn.ae_differentiableWithinAt_of_mem {f : ℝ → ℝ} {s : Set ℝ} (hf : MonotoneOn f s) :
    ∀ᵐ x, x ∈ s → DifferentiableWithinAt ℝ f s x 


Original valid proof:
:= by
  apply ae_of_mem_of_ae_of_mem_inter_Ioo
  intro a b as bs _
  obtain ⟨g, hg, gf⟩ : ∃ g : ℝ → ℝ, Monotone g ∧ EqOn f g (s ∩ Icc a b) :=
    (hf.mono inter_subset_left).exists_monotone_extension
      (hf.map_bddBelow inter_subset_left ⟨a, fun x hx => hx.2.1, as⟩)
      (hf.map_bddAbove inter_subset_left ⟨b, fun x hx => hx.2.2, bs⟩)
  filter_upwards [hg.ae_differentiableAt] with x hx
  intro h'x
  apply hx.differentiableWithinAt.congr_of_eventuallyEq _ (gf ⟨h'x.1, h'x.2.1.le, h'x.2.2.le⟩)
  have : Ioo a b ∈ 𝓝[s] x := nhdsWithin_le_nhds (Ioo_mem_nhds h'x.2.1 h'x.2.2)
  filter_upwards [self_mem_nhdsWithin, this] with y hy h'y
  exact gf ⟨hy, h'y.1.le, h'y.2.le⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean - 2024-09-07 22:16:32.403518.
---34/200---
For theorem hasFDerivAt_of_tendstoUniformlyOn in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 821d503181d6030794806a9ac2fb2b1f5dd5dfb3):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

---35/200---
For theorem hasFDerivAt_of_tendstoUniformly in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 821d503181d6030794806a9ac2fb2b1f5dd5dfb3):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

---36/200---
For theorem hasFDerivAt_of_tendstoUniformly in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---37/200---
For theorem hasFDerivAt_of_tendstoUniformly in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---38/200---
For theorem hasFDerivAt_of_tendstoUniformly in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 2ba547a6481ef513d87a606a16c441262be9e648):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.

Attempt failure.

---39/200---
For theorem hasFDerivAt_of_tendstoUniformlyOn in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.

Attempt failure.

---40/200---
For theorem hasFDerivAt_of_tendstoUniformly in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 0939faa78a0c4506a8aee4e86b897d6e84c6cb96):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finse

Attempt failure.

Working on Mathlib/Analysis/Complex/CauchyIntegral.lean - 2024-09-07 22:17:45.126608.
---41/200---
For theorem Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable in Mathlib/Analysis/Complex/CauchyIntegral.lean:
theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ℂ}
    {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ∀ z ∈ (ball c R \ closedBall c r) \ s, DifferentiableAt ℂ f z) :
    (∮ z in C(c, R), (z - c)⁻¹ • f z) = ∮ z in C(c, r), (z - c)⁻¹ • f z 


Original valid proof:
:= by
  set A := closedBall c R \ ball c r
  obtain ⟨a, rfl⟩ : ∃ a, Real.exp a = r := ⟨Real.log r, Real.exp_log h0⟩
  obtain ⟨b, rfl⟩ : ∃ b, Real.exp b = R := ⟨Real.log R, Real.exp_log (h0.trans_le hle)⟩
  rw [Real.exp_le_exp] at hle
  suffices
    (∫ θ in (0)..2 * π, I • f (circleMap c (Real.exp b) θ)) =
      ∫ θ in (0)..2 * π, I • f (circleMap c (Real.exp a) θ) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ← exp_add, smul_smul, ←
      div_eq_mul_inv, mul_div_cancel_left₀ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] ×ℂ [[0, 2 * π]]
  set g : ℂ → ℂ := (c + exp ·)
  have hdg : Differentiable ℂ g := differentiable_exp.const_add _
  replace hs : (g ⁻¹' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ⟨h, -⟩; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ∘ g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ∀ z ∈ Ioo (min a b) (max a b) ×ℂ Ioo (min 0 (2 * π)) (max 0 (2 * π)) \ g ⁻¹' s,
      DifferentiableAt ℂ (f ∘ g) z := by
    refine fun z hz => (hd (g z) ⟨?_, hz.2⟩).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ← exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ⟨a, 0⟩ ⟨b, 2 * π⟩ _ hs hc hd


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Analysis/ConstantSpeed.lean - 2024-09-07 22:18:01.329510.
---42/200---
For theorem hasConstantSpeedOnWith_zero_iff in Mathlib/Analysis/ConstantSpeed.lean:
theorem hasConstantSpeedOnWith_zero_iff :
    HasConstantSpeedOnWith f s 0 ↔ ∀ᵉ (x ∈ s) (y ∈ s), edist (f x) (f y) = 0 


Original valid proof:
:= by
  dsimp [HasConstantSpeedOnWith]
  simp only [zero_mul, ENNReal.ofReal_zero, ← eVariationOn.eq_zero_iff]
  constructor
  · by_contra!
    obtain ⟨h, hfs⟩ := this
    simp_rw [ne_eq, eVariationOn.eq_zero_iff] at hfs h
    push_neg at hfs
    obtain ⟨x, xs, y, ys, hxy⟩ := hfs
    rcases le_total x y with (xy | yx)
    · exact hxy (h xs ys x ⟨xs, le_rfl, xy⟩ y ⟨ys, xy, le_rfl⟩)
    · rw [edist_comm] at hxy
      exact hxy (h ys xs y ⟨ys, le_rfl, yx⟩ x ⟨xs, yx, le_rfl⟩)
  · rintro h x _ y _
    refine le_antisymm ?_ zero_le'
    rw [← h]
    exact eVariationOn.mono f inter_subset_left


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Analysis/Convex/Segment.lean - 2024-09-07 22:18:15.998837.
---43/200---
For theorem openSegment_subset_union in Mathlib/Analysis/Convex/Segment.lean:
theorem openSegment_subset_union (x y : E) {z : E} (hz : z ∈ range (lineMap x y : 𝕜 → E)) :
    openSegment 𝕜 x y ⊆ insert z (openSegment 𝕜 x z ∪ openSegment 𝕜 z y) 


Original valid proof:
:= by
  rcases hz with ⟨c, rfl⟩
  simp only [openSegment_eq_image_lineMap, ← mapsTo']
  rintro a ⟨h₀, h₁⟩
  rcases lt_trichotomy a c with (hac | rfl | hca)
  · right
    left
    have hc : 0 < c := h₀.trans hac
    refine ⟨a / c, ⟨div_pos h₀ hc, (div_lt_one hc).2 hac⟩, ?_⟩
    simp only [← homothety_eq_lineMap, ← homothety_mul_apply, div_mul_cancel₀ _ hc.ne']
  · left
    rfl
  · right
    right
    have hc : 0 < 1 - c := sub_pos.2 (hca.trans h₁)
    simp only [← lineMap_apply_one_sub y]
    refine
      ⟨(a - c) / (1 - c), ⟨div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right h₁ _⟩,
        ?_⟩
    simp only [← homothety_eq_lineMap, ← homothety_mul_apply, sub_mul, one_mul,
      div_mul_cancel₀ _ hc.ne', sub_sub_sub_cancel_right]


Verifying proof (Commit ed737e5773cdf087080f52542509535e7446ced4):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean - 2024-09-07 22:18:27.233750.
---44/200---
For theorem NNReal.strictConcaveOn_rpow in Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean:
lemma strictConcaveOn_rpow {p : ℝ} (hp₀ : 0 < p) (hp₁ : p < 1) :
    StrictConcaveOn ℝ≥0 univ fun x : ℝ≥0 ↦ x ^ p 


Original valid proof:
:= by
  have hp₀' : 0 < 1 / p := div_pos zero_lt_one hp₀
  have hp₁' : 1 < 1 / p := by rw [one_lt_div hp₀]; exact hp₁
  let f := NNReal.orderIsoRpow (1 / p) hp₀'
  have h₁ : StrictConvexOn ℝ≥0 univ f := by
    refine ⟨convex_univ, fun x _ y _ hxy a b ha hb hab => ?_⟩
    exact (strictConvexOn_rpow hp₁').2 x.2 y.2 (by simp [hxy]) ha hb (by simp; norm_cast)
  have h₂ : ∀ x, f.symm x = x ^ p := by simp [f, NNReal.orderIsoRpow_symm_eq]
  refine ⟨convex_univ, fun x mx y my hxy a b ha hb hab => ?_⟩
  simp only [← h₂]
  exact (f.strictConcaveOn_symm h₁).2 mx my hxy ha hb hab


Verifying proof (Commit 693fd79515903b10b1d31f10dccfc49e633cf7ee):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

Attempt failure.

Working on Mathlib/Analysis/Convolution.lean - 2024-09-07 22:18:34.081578.
---45/200---
For theorem MeasureTheory.hasFDerivAt_convolution_right_with_param in Mathlib/Analysis/Convolution.lean:
theorem hasFDerivAt_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}
    (hs : IsOpen s) (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)
    (hf : LocallyIntegrable f μ) (hg : ContDiffOn 𝕜 1 (↿g) (s ×ˢ univ)) (q₀ : P × G)
    (hq₀ : q₀.1 ∈ s) :
    HasFDerivAt (fun q : P × G => (f ⋆[L, μ] g q.1) q.2)
      ((f ⋆[L.precompR (P × G), μ] fun x : G => fderiv 𝕜 (↿g) (q₀.1, x)) q₀.2) q₀ 


Original valid proof:
:= by
  let g' := fderiv 𝕜 ↿g
  have A : ∀ p ∈ s, Continuous (g p) := fun p hp ↦ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ∀ q : P × G, q.1 ∈ s → s ×ˢ univ ∈ 𝓝 q := fun q hq ↦ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ∀ p x, p ∈ s → x ∉ k → g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : kᶜ ∈ 𝓝 x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ∈ 𝓝 p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ⟨p, y⟩ ⟨hp, hy⟩
    exact hgs p y hp hy
  obtain ⟨ε, C, εpos, h₀ε, hε⟩ :
      ∃ ε C, 0 < ε ∧ ball q₀.1 ε ⊆ s ∧ ∀ p x, ‖p - q₀.1‖ < ε → ‖g' (p, x)‖ ≤ C := by
    have A : IsCompact ({q₀.1} ×ˢ k) := isCompact_singleton.prod hk
    obtain ⟨t, kt, t_open, ht⟩ : ∃ t, {q₀.1} ×ˢ k ⊆ t ∧ IsOpen t ∧ IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s ×ˢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq₀, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ⟨ε, εpos, hε, h'ε⟩ :
      ∃ ε : ℝ, 0 < ε ∧ thickening ε ({q₀.fst} ×ˢ k) ⊆ t ∧ ball q₀.1 ε ⊆ s := by
      obtain ⟨ε, εpos, hε⟩ : ∃ ε : ℝ, 0 < ε ∧ thickening ε (({q₀.fst} : Set P) ×ˢ k) ⊆ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ⟨δ, δpos, hδ⟩ : ∃ δ : ℝ, 0 < δ ∧ ball q₀.1 δ ⊆ s := Metric.isOpen_iff.1 hs _ hq₀
      refine ⟨min ε δ, lt_min εpos δpos, ?_, ?_⟩
      · exact Subset.trans (thickening_mono (min_le_left _ _) _) hε
      · exact Subset.trans (ball_subset_ball (min_le_right _ _)) hδ
    obtain ⟨C, Cpos, hC⟩ : ∃ C, 0 < C ∧ g' '' t ⊆ closedBall 0 C := ht.subset_closedBall_lt 0 0
    refine ⟨ε, C, εpos, h'ε, fun p x hp => ?_⟩
    have hps : p ∈ s := h'ε (mem_ball_iff_norm.2 hp)
    by_cases hx : x ∈ k
    · have H : (p, x) ∈ t := by
        apply hε
        refine mem_thickening_iff.2 ⟨(q₀.1, x), ?_, ?_⟩
        · simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        · rw [← dist_eq_norm] at hp
          simpa only [Prod.dist_eq, εpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ∈ closedBall (0 : P × G →L[𝕜] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    · have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ∀ᶠ x : P × G in 𝓝 q₀, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) μ := by
    filter_upwards [A' q₀ hq₀]
    rintro ⟨p, x⟩ ⟨hp, -⟩
    refine (HasCompactSupport.convolutionExists_right L ?_ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q₀.1 (q₀.2 - a))) μ := by
    have M : HasCompactSupport (g q₀.1) := HasCompactSupport.intro hk fun x hx => hgs q₀.1 x hq₀ hx
    apply M.convolutionExists_right L hf (A q₀.1 hq₀) q₀.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q₀.fst, q₀.snd - a))) μ := by
    have T : HasCompactSupport fun y => g' (q₀.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q₀.1 x hq₀ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P × G) : _) T hf _ q₀.2).1
    have : ContinuousOn g' (s ×ˢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq₀
  set K' := (-k + {q₀.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ⟨U, U_open, K'U, hU⟩ : ∃ U, IsOpen U ∧ K' ⊆ U ∧ IntegrableOn f U μ :=
    hf.integrableOn_nhds_isCompact hK'
  obtain ⟨δ, δpos, δε, hδ⟩ : ∃ δ, (0 : ℝ) < δ ∧ δ ≤ ε ∧ K' + ball 0 δ ⊆ U := by
    obtain ⟨V, V_mem, hV⟩ : ∃ V ∈ 𝓝 (0 : G), K' + V ⊆ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ⟨δ, δpos, hδ⟩
    refine ⟨min δ ε, lt_min δpos εpos, min_le_right δ ε, ?_⟩
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hδ)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (𝕜 := 𝕜) (𝕜₂ := 𝕜) (E := E)
    (F := (P × G →L[𝕜] E') →L[𝕜] P × G →L[𝕜] F) (σ₁₂ := RingHom.id 𝕜)
  let bound : G → ℝ := indicator U fun t => ‖(L.precompR (P × G))‖ * ‖f t‖ * C
  have I4 : ∀ᵐ a : G ∂μ, ∀ x : P × G, dist x q₀ < δ →
      ‖L.precompR (P × G) (f a) (g' (x.fst, x.snd - a))‖ ≤ bound a := by
    filter_upwards with a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q₀.2 δ ⊆ U := by
      apply Subset.trans _ hδ
      rw [K'_def, add_assoc]
      apply add_subset_add
      · rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h₀ε _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le δε
      · simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    · intro y
      exact hε _ _ (((le_max_left _ _).trans_lt hx).trans_le δε)
    · rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound μ := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ∀ᵐ a : G ∂μ, ∀ x : P × G, dist x q₀ < δ →
      HasFDerivAt (fun x : P × G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    filter_upwards with a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s ×ˢ univ ∈ 𝓝 (x.1, x.2 - a) := by
      apply A'
      apply h₀ε
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) δε
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P × G => (x.1, x.2 - a)) (ContinuousLinearMap.id 𝕜 (P × G)) x := by
      have : (fun x : P × G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, _root_.id, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le δpos I1 I2 I3 I4 I5 I6


Verifying proof (Commit c8e0e8e80426a957d3b0b5ef46be522d07640e5a):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Analysis/Fourier/FourierTransform.lean - 2024-09-07 22:19:12.042536.
---46/200---
For theorem VectorFourier.fourierIntegral_continuous in Mathlib/Analysis/Fourier/FourierTransform.lean:
theorem fourierIntegral_continuous [FirstCountableTopology W] (he : Continuous e)
    (hL : Continuous fun p : V × W ↦ L p.1 p.2) {f : V → E} (hf : Integrable f μ) :
    Continuous (fourierIntegral e μ L f) 


Original valid proof:
:= by
  apply continuous_of_dominated
  · exact fun w ↦ ((fourierIntegral_convergent_iff he hL w).2 hf).1
  · exact fun w ↦ ae_of_all _ fun v ↦ le_of_eq (norm_circle_smul _ _)
  · exact hf.norm
  · refine ae_of_all _ fun v ↦ (he.comp ?_).smul continuous_const
    exact (hL.comp (continuous_prod_mk.mpr ⟨continuous_const, continuous_id⟩)).neg


Verifying proof (Commit 102773d74ceb3ea7655230d0ea35a3ae873e0581):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean - 2024-09-07 22:19:31.009165.
---47/200---
For theorem gramSchmidt_orthogonal in Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean:
theorem gramSchmidt_orthogonal (f : ι → E) {a b : ι} (h₀ : a ≠ b) :
    ⟪gramSchmidt 𝕜 f a, gramSchmidt 𝕜 f b⟫ = 0 


Original valid proof:
:= by
  suffices ∀ a b : ι, a < b → ⟪gramSchmidt 𝕜 f a, gramSchmidt 𝕜 f b⟫ = 0 by
    cases' h₀.lt_or_lt with ha hb
    · exact this _ _ ha
    · rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear h₀ a b
  intro a b h₀
  revert a
  apply wellFounded_lt.induction b
  intro b ih a h₀
  simp only [gramSchmidt_def 𝕜 f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr h₀)]
  · by_cases h : gramSchmidt 𝕜 f a = 0
    · simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    · rw [RCLike.ofReal_pow, ← inner_self_eq_norm_sq_to_K, div_mul_cancel₀, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hia₁ hia₂
  · rw [inner_eq_zero_symm]
    exact ih a h₀ i hia₁
  · exact ih i (mem_Iio.1 hi) a hia₂


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    · refine ⟨fun h => ?_, fun h => ?_⟩
      · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
         · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine 

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/PiL2.lean - 2024-09-07 22:19:41.939957.
---48/200---
For theorem Orthonormal.exists_orthonormalBasis_extension in Mathlib/Analysis/InnerProductSpace/PiL2.lean:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) 


Original valid proof:
:= by
  obtain ⟨u₀, hu₀s, hu₀, hu₀_max⟩ := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu₀] at hu₀_max
  have hu₀_finite : u₀.Finite := hu₀.linearIndependent.setFinite
  let u : Finset E := hu₀_finite.toFinset
  let fu : ↥u ≃ ↥u₀ := hu₀_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal 𝕜 ((↑) : u → E) := by simpa using hu₀.comp _ fu.injective
  refine ⟨u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_⟩
  · simpa [u] using hu₀_max
  · simpa [u] using hu₀s
  · simp


Verifying proof (Commit 06295115e02029d99354c51425dc11539f40347b):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Projection.lean - 2024-09-07 22:20:03.533014.
---49/200---
For theorem LinearIsometryEquiv.reflections_generate_dim_aux in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod 


Original valid proof:
:= by
  induction' n with n IH generalizing φ
  · 
    refine ⟨[], rfl.le, show φ = 1 from ?_⟩
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  · 
    let W := ker (ContinuousLinearMap.id ℝ F - φ)
    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ℝ Wᗮ ≤ n
    · obtain ⟨V, hV₁, hV₂⟩ := IH φ hn'
      exact ⟨V, hV₁.trans n.le_succ, hV₂⟩
    haveI : Nontrivial Wᗮ := nontrivial_of_finrank_pos (by omega : 0 < finrank ℝ Wᗮ)
    obtain ⟨v, hv⟩ := exists_ne (0 : Wᗮ)
    have hφv : φ v ∈ Wᗮ := by
      intro w hw
      rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ∉ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - φ v
    let ρ := reflection (ℝ ∙ x)ᗮ
    let V := ker (ContinuousLinearMap.id ℝ F - φ.trans ρ)
    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by
      intro w hw
      change w - ρ (φ w) = 0
      rw [sub_eq_zero, hw]
    have H₂V : W ≤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hw
    have H₁V : (v : F) ∈ V := by
      apply hV
      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
      rw [← this]
      exact reflection_reflection _ _
    have : finrank ℝ Vᗮ ≤ n := by
      change finrank ℝ Wᗮ ≤ n + 1 at hn
      have : finrank ℝ W + 1 ≤ finrank ℝ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)
      have : finrank ℝ V + finrank ℝ Vᗮ = finrank ℝ F := V.finrank_add_finrank_orthogonal
      have : finrank ℝ W + finrank ℝ Wᗮ = finrank ℝ F := W.finrank_add_finrank_orthogonal
      omega
    obtain ⟨l, hl, hφl⟩ := IH (ρ * φ) this
    refine ⟨x::l, Nat.succ_le_succ hl, ?_⟩
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (ρ * ·) hφl
    dsimp only at this
    rwa [← mul_assoc, reflection_mul_reflection, one_mul] at this


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---50/200---
For theorem LinearIsometryEquiv.reflections_generate_dim_aux in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod 


Original valid proof:
:= by
  induction' n with n IH generalizing φ
  · 
    refine ⟨[], rfl.le, show φ = 1 from ?_⟩
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  · 
    let W := ker (ContinuousLinearMap.id ℝ F - φ)
    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ℝ Wᗮ ≤ n
    · obtain ⟨V, hV₁, hV₂⟩ := IH φ hn'
      exact ⟨V, hV₁.trans n.le_succ, hV₂⟩
    haveI : Nontrivial Wᗮ := nontrivial_of_finrank_pos (by omega : 0 < finrank ℝ Wᗮ)
    obtain ⟨v, hv⟩ := exists_ne (0 : Wᗮ)
    have hφv : φ v ∈ Wᗮ := by
      intro w hw
      rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ∉ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - φ v
    let ρ := reflection (ℝ ∙ x)ᗮ
    let V := ker (ContinuousLinearMap.id ℝ F - φ.trans ρ)
    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by
      intro w hw
      change w - ρ (φ w) = 0
      rw [sub_eq_zero, hw]
    have H₂V : W ≤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hw
    have H₁V : (v : F) ∈ V := by
      apply hV
      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
      rw [← this]
      exact reflection_reflection _ _
    have : finrank ℝ Vᗮ ≤ n := by
      change finrank ℝ Wᗮ ≤ n + 1 at hn
      have : finrank ℝ W + 1 ≤ finrank ℝ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)
      have : finrank ℝ V + finrank ℝ Vᗮ = finrank ℝ F := V.finrank_add_finrank_orthogonal
      have : finrank ℝ W + finrank ℝ Wᗮ = finrank ℝ F := W.finrank_add_finrank_orthogonal
      omega
    obtain ⟨l, hl, hφl⟩ := IH (ρ * φ) this
    refine ⟨x::l, Nat.succ_le_succ hl, ?_⟩
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (ρ * ·) hφl
    dsimp only at this
    rwa [← mul_assoc, reflection_mul_reflection, one_mul] at this


Verifying proof (Commit d925bcb6a40d20ae582767f1a25d9e5251b014c6):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

---51/200---
For theorem LinearIsometryEquiv.reflections_generate_dim_aux in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod 


Original valid proof:
:= by
  induction' n with n IH generalizing φ
  · 
    refine ⟨[], rfl.le, show φ = 1 from ?_⟩
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  · 
    let W := ker (ContinuousLinearMap.id ℝ F - φ)
    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ℝ Wᗮ ≤ n
    · obtain ⟨V, hV₁, hV₂⟩ := IH φ hn'
      exact ⟨V, hV₁.trans n.le_succ, hV₂⟩
    haveI : Nontrivial Wᗮ := nontrivial_of_finrank_pos (by omega : 0 < finrank ℝ Wᗮ)
    obtain ⟨v, hv⟩ := exists_ne (0 : Wᗮ)
    have hφv : φ v ∈ Wᗮ := by
      intro w hw
      rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ∉ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - φ v
    let ρ := reflection (ℝ ∙ x)ᗮ
    let V := ker (ContinuousLinearMap.id ℝ F - φ.trans ρ)
    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by
      intro w hw
      change w - ρ (φ w) = 0
      rw [sub_eq_zero, hw]
    have H₂V : W ≤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hw
    have H₁V : (v : F) ∈ V := by
      apply hV
      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
      rw [← this]
      exact reflection_reflection _ _
    have : finrank ℝ Vᗮ ≤ n := by
      change finrank ℝ Wᗮ ≤ n + 1 at hn
      have : finrank ℝ W + 1 ≤ finrank ℝ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)
      have : finrank ℝ V + finrank ℝ Vᗮ = finrank ℝ F := V.finrank_add_finrank_orthogonal
      have : finrank ℝ W + finrank ℝ Wᗮ = finrank ℝ F := W.finrank_add_finrank_orthogonal
      omega
    obtain ⟨l, hl, hφl⟩ := IH (ρ * φ) this
    refine ⟨x::l, Nat.succ_le_succ hl, ?_⟩
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (ρ * ·) hφl
    dsimp only at this
    rwa [← mul_assoc, reflection_mul_reflection, one_mul] at this


Verifying proof (Commit 49b8ee5c731881e8d562a13d37f3ee3fd50b8092):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.

Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/Basic.lean - 2024-09-07 22:22:29.225221.
---52/200---
For theorem Balanced.absorbs_self in Mathlib/Analysis/LocallyConvex/Basic.lean:
theorem Balanced.absorbs_self (hA : Balanced 𝕜 A) : Absorbs 𝕜 A A 


Original valid proof:
:=
  .of_norm ⟨1, fun _ => hA.subset_smul⟩


Verifying proof (Commit 513593924376092791e22fba3b83ac9cd9eb3061):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finse

Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/WithSeminorms.lean - 2024-09-07 22:22:39.091657.
---53/200---
For theorem SeminormFamily.basisSets_intersect in Mathlib/Analysis/LocallyConvex/WithSeminorms.lean:
theorem basisSets_intersect (U V : Set E) (hU : U ∈ p.basisSets) (hV : V ∈ p.basisSets) :
    ∃ z ∈ p.basisSets, z ⊆ U ∩ V 


Original valid proof:
:= by
  classical
    rcases p.basisSets_iff.mp hU with ⟨s, r₁, hr₁, hU⟩
    rcases p.basisSets_iff.mp hV with ⟨t, r₂, hr₂, hV⟩
    use ((s ∪ t).sup p).ball 0 (min r₁ r₂)
    refine ⟨p.basisSets_mem (s ∪ t) (lt_min_iff.mpr ⟨hr₁, hr₂⟩), ?_⟩
    rw [hU, hV, ball_finset_sup_eq_iInter _ _ _ (lt_min_iff.mpr ⟨hr₁, hr₂⟩),
      ball_finset_sup_eq_iInter _ _ _ hr₁, ball_finset_sup_eq_iInter _ _ _ hr₂]
    exact
      Set.subset_inter
        (Set.iInter₂_mono' fun i hi =>
          ⟨i, Finset.subset_union_left hi, ball_mono <| min_le_left _ _⟩)
        (Set.iInter₂_mono' fun i hi =>
          ⟨i, Finset.subset_union_right hi, ball_mono <| min_le_right _ _⟩)


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---54/200---
For theorem SeminormFamily.basisSets_intersect in Mathlib/Analysis/LocallyConvex/WithSeminorms.lean:
theorem basisSets_intersect (U V : Set E) (hU : U ∈ p.basisSets) (hV : V ∈ p.basisSets) :
    ∃ z ∈ p.basisSets, z ⊆ U ∩ V 


Original valid proof:
:= by
  classical
    rcases p.basisSets_iff.mp hU with ⟨s, r₁, hr₁, hU⟩
    rcases p.basisSets_iff.mp hV with ⟨t, r₂, hr₂, hV⟩
    use ((s ∪ t).sup p).ball 0 (min r₁ r₂)
    refine ⟨p.basisSets_mem (s ∪ t) (lt_min_iff.mpr ⟨hr₁, hr₂⟩), ?_⟩
    rw [hU, hV, ball_finset_sup_eq_iInter _ _ _ (lt_min_iff.mpr ⟨hr₁, hr₂⟩),
      ball_finset_sup_eq_iInter _ _ _ hr₁, ball_finset_sup_eq_iInter _ _ _ hr₂]
    exact
      Set.subset_inter
        (Set.iInter₂_mono' fun i hi =>
          ⟨i, Finset.subset_union_left hi, ball_mono <| min_le_left _ _⟩)
        (Set.iInter₂_mono' fun i hi =>
          ⟨i, Finset.subset_union_right hi, ball_mono <| min_le_right _ _⟩)


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Dual.lean - 2024-09-07 22:23:07.446236.
---55/200---
For theorem NormedSpace.smul_mem_polar in Mathlib/Analysis/NormedSpace/Dual.lean:
theorem smul_mem_polar {s : Set E} {x' : Dual 𝕜 E} {c : 𝕜} (hc : ∀ z, z ∈ s → ‖x' z‖ ≤ ‖c‖) :
    c⁻¹ • x' ∈ polar 𝕜 s 


Original valid proof:
:= by
  by_cases c_zero : c = 0
  · simp only [c_zero, inv_zero, zero_smul]
    exact (dualPairing 𝕜 E).flip.zero_mem_polar _
  have eq : ∀ z, ‖c⁻¹ • x' z‖ = ‖c⁻¹‖ * ‖x' z‖ := fun z => norm_smul c⁻¹ _
  have le : ∀ z, z ∈ s → ‖c⁻¹ • x' z‖ ≤ ‖c⁻¹‖ * ‖c‖ := by
    intro z hzs
    rw [eq z]
    apply mul_le_mul (le_of_eq rfl) (hc z hzs) (norm_nonneg _) (norm_nonneg _)
  have cancel : ‖c⁻¹‖ * ‖c‖ = 1 := by
    simp only [c_zero, norm_eq_zero, Ne, not_false_iff, inv_mul_cancel, norm_inv]
  rwa [cancel] at le


Verifying proof (Commit 7dc162787d2a79bf721a83a87f641ace70251b17):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean - 2024-09-07 22:23:17.078279.
---56/200---
For theorem geometric_hahn_banach_open in Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean:
theorem geometric_hahn_banach_open (hs₁ : Convex ℝ s) (hs₂ : IsOpen s) (ht : Convex ℝ t)
    (disj : Disjoint s t) : ∃ (f : E →L[ℝ] ℝ) (u : ℝ), (∀ a ∈ s, f a < u) ∧ ∀ b ∈ t, u ≤ f b 


Original valid proof:
:= by
  obtain rfl | ⟨a₀, ha₀⟩ := s.eq_empty_or_nonempty
  · exact ⟨0, 0, by simp, fun b _hb => le_rfl⟩
  obtain rfl | ⟨b₀, hb₀⟩ := t.eq_empty_or_nonempty
  · exact ⟨0, 1, fun a _ha => zero_lt_one, by simp⟩
  let x₀ := b₀ - a₀
  let C := x₀ +ᵥ (s - t)
  have : (0 : E) ∈ C :=
    ⟨a₀ - b₀, sub_mem_sub ha₀ hb₀, by simp_rw [x₀, vadd_eq_add, sub_add_sub_cancel', sub_self]⟩
  have : Convex ℝ C := (hs₁.sub ht).vadd _
  have : x₀ ∉ C := by
    intro hx₀
    rw [← add_zero x₀] at hx₀
    exact disj.zero_not_mem_sub_set (vadd_mem_vadd_set_iff.1 hx₀)
  obtain ⟨f, hf₁, hf₂⟩ := separate_convex_open_set ‹0 ∈ C› ‹_› (hs₂.sub_right.vadd _) ‹x₀ ∉ C›
  have : f b₀ = f a₀ + 1 := by simp [x₀, ← hf₁]
  have forall_le : ∀ a ∈ s, ∀ b ∈ t, f a ≤ f b := by
    intro a ha b hb
    have := hf₂ (x₀ + (a - b)) (vadd_mem_vadd_set <| sub_mem_sub ha hb)
    simp only [f.map_add, f.map_sub, hf₁] at this
    linarith
  refine ⟨f, sInf (f '' t), image_subset_iff.1 (?_ : f '' s ⊆ Iio (sInf (f '' t))), fun b hb => ?_⟩
  · rw [← interior_Iic]
    refine interior_maximal (image_subset_iff.2 fun a ha => ?_) (f.isOpenMap_of_ne_zero ?_ _ hs₂)
    · exact le_csInf (Nonempty.image _ ⟨_, hb₀⟩) (forall_mem_image.2 <| forall_le _ ha)
    · rintro rfl
      simp at hf₁
  · exact csInf_le ⟨f a₀, forall_mem_image.2 <| forall_le _ ha₀⟩ (mem_image_of_mem _ hb)


Verifying proof (Commit 592e720e2651f6e8a7faf0968b75697c3bcd3b55):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/MazurUlam.lean - 2024-09-07 22:23:26.065888.
---57/200---
For theorem IsometryEquiv.midpoint_fixed in Mathlib/Analysis/NormedSpace/MazurUlam.lean:
theorem midpoint_fixed {x y : PE} :
    ∀ e : PE ≃ᵢ PE, e x = x → e y = y → e (midpoint ℝ x y) = midpoint ℝ x y 


Original valid proof:
:= by
  set z := midpoint ℝ x y
  set s := { e : PE ≃ᵢ PE | e x = x ∧ e y = y }
  haveI : Nonempty s := ⟨⟨IsometryEquiv.refl PE, rfl, rfl⟩⟩
  have h_bdd : BddAbove (range fun e : s => dist ((e : PE ≃ᵢ PE) z) z) := by
    refine ⟨dist x z + dist x z, forall_mem_range.2 <| Subtype.forall.2 ?_⟩
    rintro e ⟨hx, _⟩
    calc
      dist (e z) z ≤ dist (e z) x + dist x z := dist_triangle (e z) x z
      _ = dist (e x) (e z) + dist x z := by rw [hx, dist_comm]
      _ = dist x z + dist x z := by erw [e.dist_eq x z]
  set R : PE ≃ᵢ PE := (pointReflection ℝ z).toIsometryEquiv
  set f : PE ≃ᵢ PE → PE ≃ᵢ PE := fun e => ((e.trans R).trans e.symm).trans R
  have hf_dist : ∀ e, dist (f e z) z = 2 * dist (e z) z := by
    intro e
    dsimp [f, R]
    rw [dist_pointReflection_fixed, ← e.dist_eq, e.apply_symm_apply,
      dist_pointReflection_self_real, dist_comm]
  have hf_maps_to : MapsTo f s s := by
    rintro e ⟨hx, hy⟩
    constructor <;> simp [f, R, z, hx, hy, e.symm_apply_eq.2 hx.symm, e.symm_apply_eq.2 hy.symm]
  set c := ⨆ e : s, dist ((e : PE ≃ᵢ PE) z) z
  have : c ≤ c / 2 := by
    apply ciSup_le
    rintro ⟨e, he⟩
    simp only [Subtype.coe_mk, le_div_iff' (zero_lt_two' ℝ), ← hf_dist]
    exact le_ciSup h_bdd ⟨f e, hf_maps_to he⟩
  replace : c ≤ 0 := by linarith
  refine fun e hx hy => dist_le_zero.1 (le_trans ?_ this)
  exact le_ciSup h_bdd ⟨e, hx, hy⟩


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Star/Spectrum.lean - 2024-09-07 22:23:33.684774.
---58/200---
For theorem IsSelfAdjoint.mem_spectrum_eq_re in Mathlib/Analysis/NormedSpace/Star/Spectrum.lean:
theorem IsSelfAdjoint.mem_spectrum_eq_re [StarModule ℂ A] {a : A} (ha : IsSelfAdjoint a) {z : ℂ}
    (hz : z ∈ spectrum ℂ a) : z = z.re 


Original valid proof:
:= by
  have hu := exp_mem_unitary_of_mem_skewAdjoint ℂ (ha.smul_mem_skewAdjoint conj_I)
  let Iu := Units.mk0 I I_ne_zero
  have : NormedSpace.exp ℂ (I • z) ∈ spectrum ℂ (NormedSpace.exp ℂ (I • a)) := by
    simpa only [Units.smul_def, Units.val_mk0] using
      spectrum.exp_mem_exp (Iu • a) (smul_mem_smul_iff.mpr hz)
  exact Complex.ext (ofReal_re _) <| by
    simpa only [← Complex.exp_eq_exp_ℂ, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,
      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using
      spectrum.subset_circle_of_unitary hu this


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Units.lean - 2024-09-07 22:23:47.544339.
---59/200---
For theorem Ideal.closure_ne_top in Mathlib/Analysis/NormedSpace/Units.lean:
theorem closure_ne_top (I : Ideal R) (hI : I ≠ ⊤) : I.closure ≠ ⊤ 


Original valid proof:
:= by
  have h := closure_minimal (coe_subset_nonunits hI) nonunits.isClosed
  simpa only [I.closure.eq_top_iff_one, Ne] using mt (@h 1) one_not_mem_nonunits


Verifying proof (Commit 61ddcfa78d90f5773ac5739822ee3721851aa662):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finse

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean - 2024-09-07 22:23:54.703079.
---60/200---
For theorem Complex.tendsto_self_mul_Gamma_nhds_zero in Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean:
theorem tendsto_self_mul_Gamma_nhds_zero : Tendsto (fun z : ℂ => z * Gamma z) (𝓝[≠] 0) (𝓝 1) 


Original valid proof:
:= by
  rw [show 𝓝 (1 : ℂ) = 𝓝 (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]]
  convert (Tendsto.mono_left _ nhdsWithin_le_nhds).congr'
    (eventuallyEq_of_mem self_mem_nhdsWithin Complex.Gamma_add_one)
  refine ContinuousAt.comp (g := Gamma) ?_ (continuous_id.add continuous_const).continuousAt
  refine (Complex.differentiableAt_Gamma _ fun m => ?_).continuousAt
  rw [zero_add, ← ofReal_natCast, ← ofReal_neg, ← ofReal_one, Ne, ofReal_inj]
  refine (lt_of_le_of_lt ?_ zero_lt_one).ne'
  exact neg_nonpos.mpr (Nat.cast_nonneg _)


Verifying proof (Commit cf5995283f32dd2e0ccb43bc9901c4e7ba9fed97):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finse

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Integrals.lean - 2024-09-07 22:24:19.579195.
---61/200---
For theorem intervalIntegral.intervalIntegrable_rpow' in Mathlib/Analysis/SpecialFunctions/Integrals.lean:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b 


Original valid proof:
:= by
  suffices ∀ c : ℝ, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ∀ c : ℝ, 0 ≤ c → IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ∀ x ∈ Ioo 0 c, HasDerivAt (fun x : ℝ => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ≠ 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    · intro x hx; apply rpow_nonneg hx.1.le
    · refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  · exact this c hc
  · rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * π))
    rw [intervalIntegrable_iff] at m ⊢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ≤ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]


Verifying proof (Commit 229bb6cbcc9a67aabf677431de0faf2f1866dbf7):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---62/200---
For theorem intervalIntegral.intervalIntegrable_rpow' in Mathlib/Analysis/SpecialFunctions/Integrals.lean:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b 


Original valid proof:
:= by
  suffices ∀ c : ℝ, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ∀ c : ℝ, 0 ≤ c → IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ∀ x ∈ Ioo 0 c, HasDerivAt (fun x : ℝ => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ≠ 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    · intro x hx; apply rpow_nonneg hx.1.le
    · refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  · exact this c hc
  · rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * π))
    rw [intervalIntegrable_iff] at m ⊢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ≤ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]


Verifying proof (Commit b15c6ea0b0ad3ac6e15420c45ece165eca6725cc):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean - 2024-09-07 22:24:48.226240.
---63/200---
For theorem isLittleO_zpow_exp_pos_mul_atTop in Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean:
theorem isLittleO_zpow_exp_pos_mul_atTop (k : ℤ) {b : ℝ} (hb : 0 < b) :
    (fun x : ℝ => x ^ k) =o[atTop] fun x => exp (b * x) 


Original valid proof:
:= by
  simpa only [Real.rpow_intCast] using isLittleO_rpow_exp_pos_mul_atTop k hb


Verifying proof (Commit e24d0042f0fd176848590f8a296e5c675237f634):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean - 2024-09-07 22:24:56.457213.
---64/200---
For theorem Complex.continuousAt_ofReal_cpow in Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean:
theorem continuousAt_ofReal_cpow (x : ℝ) (y : ℂ) (h : 0 < y.re ∨ x ≠ 0) :
    ContinuousAt (fun p => (p.1 : ℂ) ^ p.2 : ℝ × ℂ → ℂ) (x, y) 


Original valid proof:
:= by
  rcases lt_trichotomy (0 : ℝ) x with (hx | rfl | hx)
  · 
    have : ContinuousAt (fun p => ⟨↑p.1, p.2⟩ : ℝ × ℂ → ℂ × ℂ) (x, y) :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    refine (continuousAt_cpow (Or.inl ?_)).comp this
    rwa [ofReal_re]
  · 
    have A : ContinuousAt (fun p => p.1 ^ p.2 : ℂ × ℂ → ℂ) ⟨↑(0 : ℝ), y⟩ := by
      rw [ofReal_zero]
      apply continuousAt_cpow_zero_of_re_pos
      tauto
    have B : ContinuousAt (fun p => ⟨↑p.1, p.2⟩ : ℝ × ℂ → ℂ × ℂ) ⟨0, y⟩ :=
      continuous_ofReal.continuousAt.prod_map continuousAt_id
    exact A.comp_of_eq B rfl
  · 
    suffices ContinuousAt (fun p => (-(p.1 : ℂ)) ^ p.2 * exp (π * I * p.2) : ℝ × ℂ → ℂ) (x, y) by
      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)
      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm
    have A : ContinuousAt (fun p => ⟨-↑p.1, p.2⟩ : ℝ × ℂ → ℂ × ℂ) (x, y) :=
      ContinuousAt.prod_map continuous_ofReal.continuousAt.neg continuousAt_id
    apply ContinuousAt.mul
    · refine (continuousAt_cpow (Or.inl ?_)).comp A
      rwa [neg_re, ofReal_re, neg_pos]
    · exact (continuous_exp.comp (continuous_const.mul continuous_snd)).continuousAt


Verifying proof (Commit 2009db69c1211eafea457d1c3902f31370dac23f):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/Pseudoelements.lean - 2024-09-07 22:25:06.114340.
---65/200---
For theorem CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono in Mathlib/CategoryTheory/Abelian/Pseudoelements.lean:
theorem pseudo_injective_of_mono {P Q : C} (f : P ⟶ Q) [Mono f] : Function.Injective f 


Original valid proof:
:= by
  intro abar abar'
  refine Quotient.inductionOn₂ abar abar' fun a a' ha => ?_
  apply Quotient.sound
  have : (⟦(a.hom ≫ f : Over Q)⟧ : Quotient (setoid Q)) = ⟦↑(a'.hom ≫ f)⟧ := by convert ha
  have ⟨R, p, q, ep, Eq, comm⟩ := Quotient.exact this
  exact ⟨R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact comm⟩


Verifying proof (Commit 1cb1056b5a19f416d3fae3469d51eedb4f5b48cb):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/RightDerived.lean - 2024-09-07 22:25:12.833963.
---66/200---
For theorem CategoryTheory.Functor.rightDerived_map_eq in Mathlib/CategoryTheory/Abelian/RightDerived.lean:
theorem Functor.rightDerived_map_eq (F : C ⥤ D) [F.Additive] (n : ℕ) {X Y : C} (f : X ⟶ Y)
    {P : InjectiveResolution X} {Q : InjectiveResolution Y} (g : P.cocomplex ⟶ Q.cocomplex)
    (w : P.ι ≫ g = (CochainComplex.single₀ C).map f ≫ Q.ι) :
    (F.rightDerived n).map f =
      (P.isoRightDerivedObj F n).hom ≫
        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map g ≫
          (Q.isoRightDerivedObj F n).inv 


Original valid proof:
:= by
  rw [← cancel_mono (Q.isoRightDerivedObj F n).hom,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    assoc, assoc, Iso.inv_hom_id, comp_id]
  rw [← HomologicalComplex.comp_f, w, HomologicalComplex.comp_f,
    CochainComplex.single₀_map_f_zero]


Verifying proof (Commit 9072ff84a0d139a344bf9eed4a00c4cd27596c79):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/CategoryTheory/Adjunction/Reflective.lean - 2024-09-07 22:25:20.726676.
---67/200---
For theorem CategoryTheory.equivEssImageOfReflective_map_counitIso_app_hom in Mathlib/CategoryTheory/Adjunction/Reflective.lean:
lemma equivEssImageOfReflective_map_counitIso_app_hom [Reflective i]
    (X : Functor.EssImageSubcategory i) :



Original valid proof:
  (Functor.essImageInclusion i).map (equivEssImageOfReflective_counitIso_app X).hom =
    inv (NatTrans.app (reflectorAdjunction i).unit X.obj) := by
    simp only [Functor.comp_obj, Functor.essImageInclusion_obj, Functor.toEssImage_obj_obj,
      equivEssImageOfReflective_counitIso_app, asIso, Iso.symm_mk, Functor.essImageInclusion_map,
      Functor.id_obj]
    rfl


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.me

Attempt failure.

Working on Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean - 2024-09-07 22:25:24.627816.
---68/200---
For theorem CategoryTheory.MorphismProperty.LeftFraction.comp₀_rel in Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean:
lemma comp₀_rel {X Y Z : C} (z₁ : W.LeftFraction X Y) (z₂ : W.LeftFraction Y Z)
    (z₃ z₃' : W.LeftFraction z₁.Y' z₂.Y') (h₃ : z₂.f ≫ z₃.s = z₁.s ≫ z₃.f)
    (h₃' : z₂.f ≫ z₃'.s = z₁.s ≫ z₃'.f) :
    LeftFractionRel (z₁.comp₀ z₂ z₃) (z₁.comp₀ z₂ z₃') 


Original valid proof:
:= by
  obtain ⟨z₄, fac⟩ := exists_leftFraction (RightFraction.mk z₃.s z₃.hs z₃'.s)
  dsimp at fac
  have eq : z₁.s ≫ z₃.f ≫ z₄.f = z₁.s ≫ z₃'.f ≫ z₄.s := by
    rw [← reassoc_of% h₃, ← reassoc_of% h₃', fac]
  obtain ⟨Y, t, ht, fac'⟩ := HasLeftCalculusOfFractions.ext _ _ _ z₁.hs eq
  simp only [assoc] at fac'
  refine ⟨Y, z₄.f ≫ t, z₄.s ≫ t, ?_, ?_, ?_⟩
  · simp only [comp₀, assoc, reassoc_of% fac]
  · simp only [comp₀, assoc, fac']
  · simp only [comp₀, assoc, ← reassoc_of% fac]
    exact W.comp_mem _ _ z₂.hs (W.comp_mem _ _ z₃'.hs (W.comp_mem _ _ z₄.hs ht))


Verifying proof (Commit b492f764dc62b80a0be745055df26ce5b018a24a):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/CategoryTheory/MorphismProperty/Basic.lean - 2024-09-07 22:25:30.665020.
---69/200---
For theorem CategoryTheory.MorphismProperty.map_id_eq_isoClosure in Mathlib/CategoryTheory/MorphismProperty/Basic.lean:
lemma map_id_eq_isoClosure (P : MorphismProperty C) :
    P.map (𝟭 _) = P.isoClosure 


Original valid proof:
:= by
  apply le_antisymm
  · rw [map_le_iff P.isoClosure_respectsIso]
    intro X Y f hf
    exact P.le_isoClosure _ hf
  · intro X Y f hf
    exact hf


Verifying proof (Commit 6830b5e612c6f4431fee7e89ec01560ae5118e5e):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean - 2024-09-07 22:25:34.718523.
---70/200---
For theorem Behrend.roth_lower_bound in Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean:
theorem roth_lower_bound_explicit (hN : 4096 ≤ N) :
    (N : ℝ) * exp (-4 * √(log N)) < rothNumberNat N 


Original valid proof:
:= by
  let n := nValue N
  have hn : 0 < (n : ℝ) := cast_pos.2 (nValue_pos <| hN.trans' <| by norm_num1)
  have hd : 0 < dValue N := dValue_pos (hN.trans' <| by norm_num1)
  have hN₀ : 0 < (N : ℝ) := cast_pos.2 (hN.trans' <| by norm_num1)
  have hn₂ : 2 < n := three_le_nValue <| hN.trans' <| by norm_num1
  have : (2 * dValue N - 1) ^ n ≤ N := le_N (hN.trans' <| by norm_num1)
  calc
    _ ≤ (N ^ (nValue N : ℝ)⁻¹ / rexp 1 : ℝ) ^ (n - 2) / n := ?_
    _ < _ := by gcongr; exacts [(tsub_pos_of_lt hn₂).ne', bound hN]
    _ ≤ rothNumberNat ((2 * dValue N - 1) ^ n) := bound_aux hd.ne' hn₂.le
    _ ≤ rothNumberNat N := mod_cast rothNumberNat.mono this
  rw [← rpow_natCast, div_rpow (rpow_nonneg hN₀.le _) (exp_pos _).le, ← rpow_mul hN₀.le,
    inv_mul_eq_div, cast_sub hn₂.le, cast_two, same_sub_div hn.ne', exp_one_rpow,
    div_div, rpow_sub hN₀, rpow_one, div_div, div_eq_mul_inv]
  refine mul_le_mul_of_nonneg_left ?_ (cast_nonneg _)
  rw [mul_inv, mul_inv, ← exp_neg, ← rpow_neg (cast_nonneg _), neg_sub, ← div_eq_mul_inv]
  have : exp (-4 * √(log N)) = exp (-2 * √(log N)) * exp (-2 * √(log N)) := by
    rw [← exp_add, ← add_mul]
    norm_num
  rw [this]
  refine mul_le_mul ?_ (exp_neg_two_mul_le <| Real.sqrt_pos.2 <| log_pos ?_).le (exp_pos _).le <|
      rpow_nonneg (cast_nonneg _) _
  · rw [← le_log_iff_exp_le (rpow_pos_of_pos hN₀ _), log_rpow hN₀, ← le_div_iff, mul_div_assoc,
      div_sqrt, neg_mul, neg_le_neg_iff, div_mul_eq_mul_div, div_le_iff hn]
    · exact mul_le_mul_of_nonneg_left (le_ceil _) zero_le_two
    refine Real.sqrt_pos.2 (log_pos ?_)
    rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  · rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean - 2024-09-07 22:25:45.414382.
---71/200---
For theorem Finset.mul_pluennecke_petridis in Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean:
theorem mul_pluennecke_petridis (C : Finset α)
    (hA : ∀ A' ⊆ A, (A * B).card * A'.card ≤ (A' * B).card * A.card) :
    (A * B * C).card * A.card ≤ (A * B).card * (A * C).card 


Original valid proof:
:= by
  induction' C using Finset.induction_on with x C _ ih
  · simp
  set A' := A ∩ (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have h₀ : A' * {x} = A * {x} ∩ (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have h₁ : A * B * C' = A * B * C ∪ (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine (sup_sdiff_eq_sup ?_).symm
    rw [mul_right_comm, mul_right_comm A, h₀]
    exact mul_subset_mul_right inter_subset_right
  have h₂ : A' * B * {x} ⊆ A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right inter_subset_left)
  have h₃ : (A * B * C').card ≤ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [h₁]
    refine (card_union_le _ _).trans_eq ?_
    rw [card_sdiff h₂, ← add_tsub_assoc_of_le (card_le_card h₂), card_mul_singleton,
      card_mul_singleton]
  refine (mul_le_mul_right' h₃ _).trans ?_
  rw [tsub_mul, add_mul]
  refine (tsub_le_tsub (add_le_add_right ih _) <| hA _ inter_subset_left).trans_eq ?_
  rw [← mul_add, ← mul_tsub, ← hA', hC', insert_eq, mul_union, ← card_mul_singleton A x, ←
    card_mul_singleton A' x, add_comm (card _), h₀,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Compression/UV.lean - 2024-09-07 22:25:51.644421.
---72/200---
For theorem UV.shadow_compression_subset_compression_shadow in Mathlib/Combinatorics/SetFamily/Compression/UV.lean:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) 


Original valid proof:
:= by
  set 𝒜' := 𝓒 u v 𝒜
  suffices H : ∀ s ∈ ∂ 𝒜',
      s ∉ ∂ 𝒜 → u ⊆ s ∧ Disjoint v s ∧ (s ∪ v) \ u ∈ ∂ 𝒜 ∧ (s ∪ v) \ u ∉ ∂ 𝒜' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ∈ 𝒜.shadow
    swap
    · obtain ⟨hus, hvs, h, _⟩ := H _ hs' hs
      exact Or.inr ⟨hs, _, h, compress_of_disjoint_of_le' hvs hus⟩
    refine Or.inl ⟨hs, ?_⟩
    rw [compress]
    split_ifs with huvs
    swap
    · exact hs
    rw [mem_shadow_iff] at hs'
    obtain ⟨t, Ht, a, hat, rfl⟩ := hs'
    have hav : a ∉ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ≤ t := huvs.2.trans (erase_subset _ t)
    have ht : t ∈ 𝒜 := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ∈ u
    · obtain ⟨b, hbv, Hcomp⟩ := huv a hau
      refine mem_shadow_iff_insert_mem.2 ⟨b, not_mem_sdiff_of_mem_right hbv, ?_⟩
      rw [← Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ←
        erase_union_of_mem hau] at hsb
    · refine mem_shadow_iff.2
        ⟨(t ⊔ u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_⟩
      · rw [sup_eq_union, mem_sdiff, mem_union]
        exact ⟨Or.inl hat, hav⟩
      · rw [← erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hs𝒜' hs𝒜
  have m : ∀ y, y ∉ s → insert y s ∉ 𝒜 := fun y h a => hs𝒜 (mem_shadow_iff_insert_mem.2 ⟨y, h, a⟩)
  obtain ⟨x, _, _⟩ := mem_shadow_iff_insert_mem.1 hs𝒜'
  have hus : u ⊆ insert x s := le_of_mem_compression_of_not_mem ‹_ ∈ 𝒜'› (m _ ‹x ∉ s›)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have : (insert x s ∪ v) \ u ∈ 𝒜 := sup_sdiff_mem_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ∉ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‹Disjoint v u›.sdiff_eq_left
  have : x ∉ u := by
    intro hxu
    obtain ⟨y, hyv, hxy⟩ := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ∪ v) \ u ∪ erase u x) \ erase v y ∈ 𝒜 := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‹v \ u = v›]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‹x ∈ u›, erase_union_distrib,
      erase_insert ‹x ∉ s›, erase_eq_of_not_mem ‹x ∉ v›, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ⊆ s := by rwa [← erase_eq_of_not_mem ‹x ∉ u›, ← subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ⟨hus, hsv.symm, ⟨x, ?_, ?_⟩, ?_⟩
  · exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ⟨‹x ∉ s›, ‹x ∉ v›⟩)
  · rwa [← insert_sdiff_of_not_mem _ ‹x ∉ u›, ← insert_union]
  rintro ⟨w, hwB, hw𝒜'⟩
  have : v ⊆ insert w ((s ∪ v) \ u) :=
    (subset_sdiff.2 ⟨subset_union_right, hvu⟩).trans (subset_insert _ _)
  by_cases hwu : w ∈ u
  · obtain ⟨z, hz, hxy⟩ := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ∪ v) \ u) ∈ 𝒜 := mem_of_mem_compression hw𝒜' ‹_› (aux huv)
    have : (insert w ((s ∪ v) \ u) ∪ erase u w) \ erase v z ∈ 𝒜 := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‹_›) ?_
      rw [← sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‹w ∈ u›,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‹z ∈ v›), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ← Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ∘ hwB ∘ mem_union_left _)
  have : (insert w ((s ∪ v) \ u) ∪ u) \ v ∈ 𝒜 :=
    sup_sdiff_mem_of_mem_compression ‹insert w ((s ∪ v) \ u) ∈ 𝒜'› ‹_›
      (disjoint_insert_right.2 ⟨‹_›, disjoint_sdiff⟩)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ∘ hwB ∘ mem_union_right _), union_sdiff_cancel_right hsv]


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---73/200---
For theorem UV.shadow_compression_subset_compression_shadow in Mathlib/Combinatorics/SetFamily/Compression/UV.lean:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) 


Original valid proof:
:= by
  set 𝒜' := 𝓒 u v 𝒜
  suffices H : ∀ s ∈ ∂ 𝒜',
      s ∉ ∂ 𝒜 → u ⊆ s ∧ Disjoint v s ∧ (s ∪ v) \ u ∈ ∂ 𝒜 ∧ (s ∪ v) \ u ∉ ∂ 𝒜' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ∈ 𝒜.shadow
    swap
    · obtain ⟨hus, hvs, h, _⟩ := H _ hs' hs
      exact Or.inr ⟨hs, _, h, compress_of_disjoint_of_le' hvs hus⟩
    refine Or.inl ⟨hs, ?_⟩
    rw [compress]
    split_ifs with huvs
    swap
    · exact hs
    rw [mem_shadow_iff] at hs'
    obtain ⟨t, Ht, a, hat, rfl⟩ := hs'
    have hav : a ∉ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ≤ t := huvs.2.trans (erase_subset _ t)
    have ht : t ∈ 𝒜 := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ∈ u
    · obtain ⟨b, hbv, Hcomp⟩ := huv a hau
      refine mem_shadow_iff_insert_mem.2 ⟨b, not_mem_sdiff_of_mem_right hbv, ?_⟩
      rw [← Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ←
        erase_union_of_mem hau] at hsb
    · refine mem_shadow_iff.2
        ⟨(t ⊔ u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_⟩
      · rw [sup_eq_union, mem_sdiff, mem_union]
        exact ⟨Or.inl hat, hav⟩
      · rw [← erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hs𝒜' hs𝒜
  have m : ∀ y, y ∉ s → insert y s ∉ 𝒜 := fun y h a => hs𝒜 (mem_shadow_iff_insert_mem.2 ⟨y, h, a⟩)
  obtain ⟨x, _, _⟩ := mem_shadow_iff_insert_mem.1 hs𝒜'
  have hus : u ⊆ insert x s := le_of_mem_compression_of_not_mem ‹_ ∈ 𝒜'› (m _ ‹x ∉ s›)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have : (insert x s ∪ v) \ u ∈ 𝒜 := sup_sdiff_mem_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ∉ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‹Disjoint v u›.sdiff_eq_left
  have : x ∉ u := by
    intro hxu
    obtain ⟨y, hyv, hxy⟩ := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ∪ v) \ u ∪ erase u x) \ erase v y ∈ 𝒜 := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‹v \ u = v›]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‹x ∈ u›, erase_union_distrib,
      erase_insert ‹x ∉ s›, erase_eq_of_not_mem ‹x ∉ v›, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ⊆ s := by rwa [← erase_eq_of_not_mem ‹x ∉ u›, ← subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ⟨hus, hsv.symm, ⟨x, ?_, ?_⟩, ?_⟩
  · exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ⟨‹x ∉ s›, ‹x ∉ v›⟩)
  · rwa [← insert_sdiff_of_not_mem _ ‹x ∉ u›, ← insert_union]
  rintro ⟨w, hwB, hw𝒜'⟩
  have : v ⊆ insert w ((s ∪ v) \ u) :=
    (subset_sdiff.2 ⟨subset_union_right, hvu⟩).trans (subset_insert _ _)
  by_cases hwu : w ∈ u
  · obtain ⟨z, hz, hxy⟩ := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ∪ v) \ u) ∈ 𝒜 := mem_of_mem_compression hw𝒜' ‹_› (aux huv)
    have : (insert w ((s ∪ v) \ u) ∪ erase u w) \ erase v z ∈ 𝒜 := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‹_›) ?_
      rw [← sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‹w ∈ u›,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‹z ∈ v›), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ← Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ∘ hwB ∘ mem_union_left _)
  have : (insert w ((s ∪ v) \ u) ∪ u) \ v ∈ 𝒜 :=
    sup_sdiff_mem_of_mem_compression ‹insert w ((s ∪ v) \ u) ∈ 𝒜'› ‹_›
      (disjoint_insert_right.2 ⟨‹_›, disjoint_sdiff⟩)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ∘ hwB ∘ mem_union_right _), union_sdiff_cancel_right hsv]


Verifying proof (Commit 2d8928f07c222f171d2f9371935aa5b8359f9d44):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Shadow.lean - 2024-09-07 22:26:02.399712.
---74/200---
For theorem Finset.mem_upShadow_iff_exists_sdiff in Mathlib/Combinatorics/SetFamily/Shadow.lean:
lemma mem_upShadow_iff_exists_sdiff : t ∈ ∂⁺ 𝒜 ↔ ∃ s ∈ 𝒜, s ⊆ t ∧ (t \ s).card = 1 


Original valid proof:
:= by
  simp_rw [mem_upShadow_iff, ← covBy_iff_card_sdiff_eq_one, covBy_iff_exists_insert]


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Computability/Ackermann.lean - 2024-09-07 22:26:08.709989.
---75/200---
For theorem ack_succ_right_le_ack_succ_left in Mathlib/Computability/Ackermann.lean:
theorem ack_succ_right_le_ack_succ_left (m n : ℕ) : ack m (n + 1) ≤ ack (m + 1) n 


Original valid proof:
:= by
  cases' n with n n
  · simp
  · rw [ack_succ_succ]
    apply ack_mono_right m (le_trans _ <| add_add_one_le_ack _ n)
    omega


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.

Attempt failure.

Working on Mathlib/Computability/PartrecCode.lean - 2024-09-07 22:26:13.997110.
---76/200---
For theorem Nat.Partrec.Code.evaln_prim in Mathlib/Computability/PartrecCode.lean:
theorem evaln_prim : Primrec fun a : (ℕ × Code) × ℕ => evaln a.1.1 a.1.2 a.2 


Original valid proof:
:=
  have :
    Primrec₂ fun (_ : Unit) (n : ℕ) =>
      let a := ofNat (ℕ × Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to₂ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr_left fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      · simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        ∀ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) →
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k₁ c₁ n₁ hl
        simp [lup, List.getElem?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      · cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        · rfl
        cases evaln k cg n <;> rfl
      · cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        · rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      · cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        · rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        · rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      · have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        · rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to₂).of_eq
    fun ⟨⟨k, c⟩, n⟩ => by simp [evaln_map]


Verifying proof (Commit 6085d5e27552de2d43997b4a52a8d9fcd4686071):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

Working on Mathlib/Computability/RegularExpressions.lean - 2024-09-07 22:26:24.493441.
---77/200---
For theorem RegularExpression.star_rmatch_iff in Mathlib/Computability/RegularExpressions.lean:
theorem star_rmatch_iff (P : RegularExpression α) :
    ∀ x : List α, (star P).rmatch x ↔ ∃ S : List (List α), x
          = S.join ∧ ∀ t ∈ S, t ≠ [] ∧ P.rmatch t 


Original valid proof:
:=
  fun x => by
    have IH := fun t (_h : List.length t < List.length x) => star_rmatch_iff P t
    clear star_rmatch_iff
    constructor
    · cases' x with a x
      · intro _h
        use []; dsimp; tauto
      · rw [rmatch, deriv, mul_rmatch_iff]
        rintro ⟨t, u, hs, ht, hu⟩
        have hwf : u.length < (List.cons a x).length := by
          rw [hs, List.length_cons, List.length_append]
          omega
        rw [IH _ hwf] at hu
        rcases hu with ⟨S', hsum, helem⟩
        use (a :: t) :: S'
        constructor
        · simp [hs, hsum]
        · intro t' ht'
          cases ht' with
          | head ht' =>
            simp only [ne_eq, not_false_iff, true_and, rmatch]
            exact ht
          | tail _ ht' => exact helem t' ht'
    · rintro ⟨S, hsum, helem⟩
      cases' x with a x
      · rfl
      · rw [rmatch, deriv, mul_rmatch_iff]
        cases' S with t' U
        · exact ⟨[], [], by tauto⟩
        · cases' t' with b t
          · simp only [forall_eq_or_imp, List.mem_cons] at helem
            simp only [eq_self_iff_true, not_true, Ne, false_and_iff] at helem
          simp only [List.join, List.cons_append, List.cons_eq_cons] at hsum
          refine ⟨t, U.join, hsum.2, ?_, ?_⟩
          · specialize helem (b :: t) (by simp)
            rw [rmatch] at helem
            convert helem.2
            exact hsum.1
          · have hwf : U.join.length < (List.cons a x).length := by
              rw [hsum.1, hsum.2]
              simp only [List.length_append, List.length_join, List.length]
              omega
            rw [IH _ hwf]
            refine ⟨U, rfl, fun t h => helem t ?_⟩
            right
            assumption
  termination_by t => (P, t.length)


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

Working on Mathlib/Computability/TMToPartrec.lean - 2024-09-07 22:26:28.826408.
---78/200---
For theorem Turing.PartrecToTM2.tr_ret_respects in Mathlib/Computability/TMToPartrec.lean:
theorem tr_ret_respects (k v s) : ∃ b₂,
    TrCfg (stepRet k v) b₂ ∧
      Reaches₁ (TM2.step tr)
        ⟨some (Λ'.ret (trCont k)), s, K'.elim (trList v) [] [] (trContStack k)⟩ b₂ 


Original valid proof:
:= by
  induction k generalizing v s with
  | halt => exact ⟨_, rfl, TransGen.single rfl⟩
  | cons₁ fs as k _ =>
    obtain ⟨s', h₁, h₂⟩ := trNormal_respects fs (Cont.cons₂ v k) as none
    refine ⟨s', h₁, TransGen.head rfl ?_⟩; simp
    refine (move₂_ok (by decide) ?_ (splitAtPred_false _)).trans ?_; · rfl
    simp only [TM2.step, Option.mem_def, Option.elim, id_eq, elim_update_main, elim_main, elim_aux,
      List.append_nil, elim_update_aux]
    refine (move₂_ok (L₁ := ?_) (o := ?_) (L₂ := ?_) (by decide) rfl ?_).trans ?_
    pick_goal 4
    · exact splitAtPred_eq _ _ _ (some Γ'.consₗ) _
        (fun x h => Bool.decide_false (trList_ne_consₗ _ _ h)) ⟨rfl, rfl⟩
    refine (move₂_ok (by decide) ?_ (splitAtPred_false _)).trans ?_; · rfl
    simp only [TM2.step, Option.mem_def, Option.elim, elim_update_stack, elim_main,
      List.append_nil, elim_update_main,  id_eq, elim_update_aux, ne_eq, Function.update_noteq,
      elim_aux, elim_stack]
    exact h₂
  | cons₂ ns k IH =>
    obtain ⟨c, h₁, h₂⟩ := IH (ns.headI :: v) none
    exact ⟨c, h₁, TransGen.head rfl <| head_stack_ok.trans h₂⟩
  | comp f k _ =>
    obtain ⟨s', h₁, h₂⟩ := trNormal_respects f k v s
    exact ⟨_, h₁, TransGen.head rfl h₂⟩
  | fix f k IH =>
    rw [stepRet]
    have :
      if v.headI = 0 then natEnd (trList v).head?.iget = true ∧ (trList v).tail = trList v.tail
      else
        natEnd (trList v).head?.iget = false ∧
          (trList v).tail = (trNat v.headI).tail ++ Γ'.cons :: trList v.tail := by
      cases' v with n
      · exact ⟨rfl, rfl⟩
      cases' n with n
      · simp
      rw [trList, List.headI, trNat, Nat.cast_succ, Num.add_one, Num.succ, List.tail]
      cases (n : Num).succ' <;> exact ⟨rfl, rfl⟩
    by_cases h : v.headI = 0 <;> simp only [h, ite_true, ite_false] at this ⊢
    · obtain ⟨c, h₁, h₂⟩ := IH v.tail (trList v).head?
      refine ⟨c, h₁, TransGen.head rfl ?_⟩
      simp only [Option.mem_def, TM2.stepAux, trContStack, contStack, elim_main, this, cond_true,
        elim_update_main]
      exact h₂
    · obtain ⟨s', h₁, h₂⟩ := trNormal_respects f (Cont.fix f k) v.tail (some Γ'.cons)
      refine ⟨_, h₁, TransGen.head rfl <| TransGen.trans ?_ h₂⟩
      simp only [Option.mem_def, TM2.stepAux, elim_main, this.1, cond_false, elim_update_main,
        trCont]
      convert clear_ok (splitAtPred_eq _ _ (trNat v.headI).tail (some Γ'.cons) _ _ _) using 2
      · simp
        convert rfl
      · exact fun x h => trNat_natEnd _ _ (List.tail_subset _ h)
      · exact ⟨rfl, this.2⟩


Verifying proof (Commit 8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finse

Attempt failure.

Working on Mathlib/Data/DFinsupp/Basic.lean - 2024-09-07 22:26:37.114478.
---79/200---
For theorem DFinsupp.prod_add_index in Mathlib/Data/DFinsupp/Basic.lean:
theorem prod_add_index [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]
    [CommMonoid γ] {f g : Π₀ i, β i} {h : ∀ i, β i → γ} (h_zero : ∀ i, h i 0 = 1)
    (h_add : ∀ i b₁ b₂, h i (b₁ + b₂) = h i b₁ * h i b₂) : (f + g).prod h = f.prod h * g.prod h 


Original valid proof:
:=
  have f_eq : (∏ i ∈ f.support ∪ g.support, h i (f i)) = f.prod h :=
    (Finset.prod_subset Finset.subset_union_left <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  have g_eq : (∏ i ∈ f.support ∪ g.support, h i (g i)) = g.prod h :=
    (Finset.prod_subset Finset.subset_union_right <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]).symm
  calc
    (∏ i ∈ (f + g).support, h i ((f + g) i)) = ∏ i ∈ f.support ∪ g.support, h i ((f + g) i) :=
      Finset.prod_subset support_add <| by
        simp (config := { contextual := true }) [mem_support_iff, h_zero]
    _ = (∏ i ∈ f.support ∪ g.support, h i (f i)) * ∏ i ∈ f.support ∪ g.support, h i (g i) := by
      { simp [h_add, Finset.prod_mul_distrib] }
    _ = _ := by rw [f_eq, g_eq]


Verifying proof (Commit 0ef23fba776dbe5bb848bbfc3337bedef4a59c82):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

Attempt failure.

Working on Mathlib/Data/Fin/Basic.lean - 2024-09-07 22:26:51.053188.
---80/200---
For theorem Fin.one_eq_zero_iff in Mathlib/Data/Fin/Basic.lean:
theorem one_eq_zero_iff [NeZero n] : (1 : Fin n) = 0 ↔ n = 1 


Original valid proof:
:= by
  obtain _ | _ | n := n <;> simp [Fin.ext_iff]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean - 2024-09-07 22:26:56.144100.
---81/200---
For theorem List.Nat.antidiagonalTuple_one in Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean:
theorem antidiagonalTuple_one (n : ℕ) : antidiagonalTuple 1 n = [![n]] 


Original valid proof:
:= by
  simp_rw [antidiagonalTuple, antidiagonal, List.range_succ, List.map_append, List.map_singleton,
    tsub_self, List.append_bind, List.bind_singleton, List.bind_map]
  conv_rhs => rw [← List.nil_append [![n]]]
  congr 1
  simp_rw [List.bind_eq_nil, List.mem_range, List.map_eq_nil]
  intro x hx
  obtain ⟨m, rfl⟩ := Nat.exists_eq_add_of_lt hx
  rw [add_assoc, add_tsub_cancel_left, antidiagonalTuple_zero_succ]


Verifying proof (Commit 4153c8119ca54207385194d365e0847cb9c5ca45):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

Working on Mathlib/Data/List/Cycle.lean - 2024-09-07 22:27:00.573138.
---82/200---
For theorem Cycle.subsingleton_nil in Mathlib/Data/List/Cycle.lean:
theorem subsingleton_nil : Subsingleton (@nil α) 


Original valid proof:
:= Nat.zero_le _


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

Working on Mathlib/Data/List/Indexes.lean - 2024-09-07 22:27:06.290592.
---83/200---
For theorem List.map_enumFrom_eq_zipWith in Mathlib/Data/List/Indexes.lean:
theorem map_enumFrom_eq_zipWith : ∀ (l : List α) (n : ℕ) (f : ℕ → α → β),
    map (uncurry f) (enumFrom n l) = zipWith (fun i ↦ f (i + n)) (range (length l)) l 


Original valid proof:
:= by
  intro l
  generalize e : l.length = len
  revert l
  induction' len with len ih <;> intros l e n f
  · have : l = [] := by
      cases l
      · rfl
      · contradiction
    rw [this]; rfl
  · cases' l with head tail
    · contradiction
    · simp only [map, uncurry_apply_pair, range_succ_eq_map, zipWith, Nat.zero_add,
        zipWith_map_left]
      rw [ih]
      · suffices (fun i ↦ f (i + (n + 1))) = ((fun i ↦ f (i + n)) ∘ Nat.succ) by
          rw [this]
          rfl
        funext n' a
        simp only [comp, Nat.add_assoc, Nat.add_comm, Nat.add_succ]
      simp only [length_cons, Nat.succ.injEq] at e; exact e


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Data/Multiset/Basic.lean - 2024-09-07 22:27:10.026415.
---84/200---
For theorem Multiset.filter_attach' in Mathlib/Data/Multiset/Basic.lean:
lemma filter_attach' (s : Multiset α) (p : {a // a ∈ s} → Prop) [DecidableEq α]
    [DecidablePred p] :
    s.attach.filter p =
      (s.filter fun x ↦ ∃ h, p ⟨x, h⟩).attach.map (Subtype.map id fun x ↦ mem_of_mem_filter) 


Original valid proof:
:= by
  classical
  refine Multiset.map_injective Subtype.val_injective ?_
  rw [map_filter' _ Subtype.val_injective]
  simp only [Function.comp, Subtype.exists, coe_mk, Subtype.map,
    exists_and_right, exists_eq_right, attach_map_val, map_map, map_coe, id]


Verifying proof (Commit 0f4b7a5517f03c73769c78233b0171b31784c97b):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    · refine ⟨fun h => ?_, fun h => ?_⟩
      · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
         · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
           · refine ⟨fun h => ?_, fun h => ?_⟩
           · refine ⟨fun h => ?_, fun h => ?_⟩
           · refine ⟨fun h => ?_, fun h => ?_⟩
           · refine ⟨fun h => ?_, fun h => ?_⟩
           · refine ⟨fun h => ?_, fun h => ?_⟩
           · refine ⟨fun h => 

Attempt failure.

---85/200---
For theorem Multiset.filter_attach' in Mathlib/Data/Multiset/Basic.lean:
lemma filter_attach' (s : Multiset α) (p : {a // a ∈ s} → Prop) [DecidableEq α]
    [DecidablePred p] :
    s.attach.filter p =
      (s.filter fun x ↦ ∃ h, p ⟨x, h⟩).attach.map (Subtype.map id fun x ↦ mem_of_mem_filter) 


Original valid proof:
:= by
  classical
  refine Multiset.map_injective Subtype.val_injective ?_
  rw [map_filter' _ Subtype.val_injective]
  simp only [Function.comp, Subtype.exists, coe_mk, Subtype.map,
    exists_and_right, exists_eq_right, attach_map_val, map_map, map_coe, id]


Verifying proof (Commit 5634c52c4ae1e260b29c94e98579196bf4c10d44):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

Working on Mathlib/Data/Nat/Log.lean - 2024-09-07 22:27:27.730285.
---86/200---
For theorem Nat.pow_le_iff_le_log in Mathlib/Data/Nat/Log.lean:
theorem pow_le_iff_le_log {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) :
    b ^ x ≤ y ↔ x ≤ log b y 


Original valid proof:
:= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => dsimp; omega
  | succ x =>
    rw [log]; split_ifs with h
    · have b_pos : 0 < b := lt_of_succ_lt hb
      rw [Nat.add_le_add_iff_right, ← ih (y / b) (div_lt_self
        (Nat.pos_iff_ne_zero.2 hy) hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', Nat.mul_comm]
    · exact iff_of_false (fun hby => h ⟨(le_self_pow x.succ_ne_zero _).trans hby, hb⟩)
        (not_succ_le_zero _)


Verifying proof (Commit 76620f7bc93be67fe98a87948024801e42a6f815):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Data/Num/Lemmas.lean - 2024-09-07 22:27:31.071224.
---87/200---
For theorem PosNum.succ_to_nat in Mathlib/Data/Num/Lemmas.lean:
theorem succ_to_nat : ∀ n, (succ n : ℕ) = n + 1



Original valid proof:
  | 1 => rfl
  | bit0 p => rfl
  | bit1 p =>
    (congr_arg _root_.bit0 (succ_to_nat p)).trans <|
      show ↑p + 1 + ↑p + 1 = ↑p + ↑p + 1 + 1 by simp [add_left_comm]


Verifying proof (Commit fc94d7cf19de72da26bfb583fdb140d8737abb30):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Data/Rat/Lemmas.lean - 2024-09-07 22:27:43.788531.
---88/200---
For theorem Rat.den_mk in Mathlib/Data/Rat/Lemmas.lean:
theorem den_mk (n d : ℤ) : (n /. d).den = if d = 0 then 1 else d.natAbs / n.gcd d 


Original valid proof:
:= by
  have (m : ℕ) : Int.natAbs (m + 1) = m + 1 := by
    rw [← Nat.cast_one, ← Nat.cast_add, Int.natAbs_cast]
  rcases d with ((_ | _) | _) <;>
    simp [divInt, mkRat, Rat.normalize, Nat.succPNat, Int.sign, Int.gcd,
      if_neg (Nat.cast_add_one_ne_zero _), this]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finse

Attempt failure.

Working on Mathlib/Data/Seq/Computation.lean - 2024-09-07 22:27:48.015767.
---89/200---
For theorem Computation.liftRel_think_left in Mathlib/Data/Seq/Computation.lean:
theorem liftRel_think_left (R : α → β → Prop) (ca : Computation α) (cb : Computation β) :
    LiftRel R (think ca) cb ↔ LiftRel R ca cb 


Original valid proof:
:=
  and_congr (forall_congr' fun _ => imp_congr ⟨of_think_mem, think_mem⟩ Iff.rfl)
    (forall_congr' fun _ =>
      imp_congr Iff.rfl <| exists_congr fun _ => and_congr ⟨of_think_mem, think_mem⟩ Iff.rfl)


Verifying proof (Commit 3c930599229893e1b6a931304cf4efff4a01b172):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Data/Set/Countable.lean - 2024-09-07 22:27:52.473463.
---90/200---
For theorem Set.countable_setOf_finite_subset in Mathlib/Data/Set/Countable.lean:
theorem countable_setOf_finite_subset {s : Set α} (hs : s.Countable) :
    { t | Set.Finite t ∧ t ⊆ s }.Countable 


Original valid proof:
:= by
  have := hs.to_subtype
  refine (countable_range fun t : Finset s => Subtype.val '' (t : Set s)).mono ?_
  rintro t ⟨ht, hts⟩
  lift t to Set s using hts
  lift t to Finset s using ht.of_finite_image Subtype.val_injective.injOn
  exact mem_range_self _


Verifying proof (Commit 87c5a5a812b43358ca77ed7cb1211985afb5b9b7):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Data/Set/Finite.lean - 2024-09-07 22:27:56.418096.
---91/200---
For theorem Set.Finite.exists_not_mem in Mathlib/Data/Set/Finite.lean:
lemma Finite.exists_not_mem (hs : s.Finite) : ∃ a, a ∉ s 


Original valid proof:
:= by
  by_contra! h; exact infinite_univ (hs.subset fun a _ ↦ h _)


Verifying proof (Commit 0e1fb8d54955c6fdc7263b0eb58946a3a50c37a4):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/FieldTheory/Separable.lean - 2024-09-07 22:28:03.585653.
---92/200---
For theorem Polynomial.separable_X_pow_sub_C in Mathlib/FieldTheory/Separable.lean:
theorem separable_X_pow_sub_C_unit {n : ℕ} (u : Rˣ) (hn : IsUnit (n : R)) :
    Separable (X ^ n - C (u : R)) 


Original valid proof:
:= by
  nontriviality R
  rcases n.eq_zero_or_pos with (rfl | hpos)
  · simp at hn
  apply (separable_def' (X ^ n - C (u : R))).2
  obtain ⟨n', hn'⟩ := hn.exists_left_inv
  refine ⟨-C ↑u⁻¹, C (↑u⁻¹ : R) * C n' * X, ?_⟩
  rw [derivative_sub, derivative_C, sub_zero, derivative_pow X n, derivative_X, mul_one]
  calc
    -C ↑u⁻¹ * (X ^ n - C ↑u) + C ↑u⁻¹ * C n' * X * (↑n * X ^ (n - 1)) =
        C (↑u⁻¹ * ↑u) - C ↑u⁻¹ * X ^ n + C ↑u⁻¹ * C (n' * ↑n) * (X * X ^ (n - 1)) := by
      simp only [C.map_mul, C_eq_natCast]
      ring
    _ = 1 := by
      simp only [Units.inv_mul, hn', C.map_one, mul_one, ← pow_succ',
        Nat.sub_add_cancel (show 1 ≤ n from hpos), sub_add_cancel]


Verifying proof (Commit c7bd9bd10c613e1788107ba753e252f069560f87):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean - 2024-09-07 22:28:11.823022.
---93/200---
For theorem Collinear.oangle_sign_of_sameRay_vsub in Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean:
theorem _root_.Collinear.oangle_sign_of_sameRay_vsub {p₁ p₂ p₃ p₄ : P} (p₅ : P) (hp₁p₂ : p₁ ≠ p₂)
    (hp₃p₄ : p₃ ≠ p₄) (hc : Collinear ℝ ({p₁, p₂, p₃, p₄} : Set P))
    (hr : SameRay ℝ (p₂ -ᵥ p₁) (p₄ -ᵥ p₃)) : (∡ p₁ p₅ p₂).sign = (∡ p₃ p₅ p₄).sign 


Original valid proof:
:= by
  by_cases hc₅₁₂ : Collinear ℝ ({p₅, p₁, p₂} : Set P)
  · have hc₅₁₂₃₄ : Collinear ℝ ({p₅, p₁, p₂, p₃, p₄} : Set P) :=
      (hc.collinear_insert_iff_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) hp₁p₂).2 hc₅₁₂
    have hc₅₃₄ : Collinear ℝ ({p₅, p₃, p₄} : Set P) :=
      (hc.collinear_insert_iff_of_ne
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _
          (Set.mem_singleton _)))) hp₃p₄).1 hc₅₁₂₃₄
    rw [Set.insert_comm] at hc₅₁₂ hc₅₃₄
    have hs₁₅₂ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc₅₁₂
    have hs₃₅₄ := oangle_eq_zero_or_eq_pi_iff_collinear.2 hc₅₃₄
    rw [← Real.Angle.sign_eq_zero_iff] at hs₁₅₂ hs₃₅₄
    rw [hs₁₅₂, hs₃₅₄]
  · let s : Set (P × P × P) :=
      (fun x : line[ℝ, p₁, p₂] × V => (x.1, p₅, x.2 +ᵥ (x.1 : P))) ''
        Set.univ ×ˢ {v | SameRay ℝ (p₂ -ᵥ p₁) v ∧ v ≠ 0}
    have hco : IsConnected s :=
      haveI : ConnectedSpace line[ℝ, p₁, p₂] := AddTorsor.connectedSpace _ _
      (isConnected_univ.prod (isConnected_setOf_sameRay_and_ne_zero
        (vsub_ne_zero.2 hp₁p₂.symm))).image _
        (continuous_fst.subtype_val.prod_mk (continuous_const.prod_mk
          (continuous_snd.vadd continuous_fst.subtype_val))).continuousOn
    have hf : ContinuousOn (fun p : P × P × P => ∡ p.1 p.2.1 p.2.2) s := by
      refine ContinuousAt.continuousOn fun p hp => continuousAt_oangle ?_ ?_
      all_goals
        simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_univ, true_and_iff, Prod.ext_iff] at hp
        obtain ⟨q₁, q₅, q₂⟩ := p
        dsimp only at hp ⊢
        obtain ⟨⟨⟨q, hq⟩, v⟩, hv, rfl, rfl, rfl⟩ := hp
        dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ⊢
        obtain ⟨hvr, -⟩ := hv
        rintro rfl
        refine hc₅₁₂ ((collinear_insert_iff_of_mem_affineSpan ?_).2 (collinear_pair _ _ _))
      · exact hq
      · refine vadd_mem_of_mem_direction ?_ hq
        rw [← exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp₁p₂.symm)] at hvr
        obtain ⟨r, -, rfl⟩ := hvr
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hsp : ∀ p : P × P × P, p ∈ s → ∡ p.1 p.2.1 p.2.2 ≠ 0 ∧ ∡ p.1 p.2.1 p.2.2 ≠ π := by
      intro p hp
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff] at hp
      obtain ⟨q₁, q₅, q₂⟩ := p
      dsimp only at hp ⊢
      obtain ⟨⟨⟨q, hq⟩, v⟩, hv, rfl, rfl, rfl⟩ := hp
      dsimp only [Subtype.coe_mk, Set.mem_setOf] at hv ⊢
      obtain ⟨hvr, hv0⟩ := hv
      rw [← exists_nonneg_left_iff_sameRay (vsub_ne_zero.2 hp₁p₂.symm)] at hvr
      obtain ⟨r, -, rfl⟩ := hvr
      change q ∈ line[ℝ, p₁, p₂] at hq
      rw [oangle_ne_zero_and_ne_pi_iff_affineIndependent]
      refine affineIndependent_of_ne_of_mem_of_not_mem_of_mem ?_ hq
          (fun h => hc₅₁₂ ((collinear_insert_iff_of_mem_affineSpan h).2 (collinear_pair _ _ _))) ?_
      · rwa [← @vsub_ne_zero V, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, neg_ne_zero]
      · refine vadd_mem_of_mem_direction ?_ hq
        rw [direction_affineSpan]
        exact smul_vsub_rev_mem_vectorSpan_pair _ _ _
    have hp₁p₂s : (p₁, p₅, p₂) ∈ s := by
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine ⟨⟨⟨p₁, left_mem_affineSpan_pair ℝ _ _⟩, p₂ -ᵥ p₁⟩,
        ⟨SameRay.rfl, vsub_ne_zero.2 hp₁p₂.symm⟩, ?_⟩
      simp
    have hp₃p₄s : (p₃, p₅, p₄) ∈ s := by
      simp_rw [s, Set.mem_image, Set.mem_prod, Set.mem_setOf, Set.mem_univ, true_and_iff,
        Prod.ext_iff]
      refine ⟨⟨⟨p₃, hc.mem_affineSpan_of_mem_of_ne (Set.mem_insert _ _)
        (Set.mem_insert_of_mem _ (Set.mem_insert _ _))
        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _))) hp₁p₂⟩, p₄ -ᵥ p₃⟩,
        ⟨hr, vsub_ne_zero.2 hp₃p₄.symm⟩, ?_⟩
      simp
    convert Real.Angle.sign_eq_of_continuousOn hco hf hsp hp₃p₄s hp₁p₂s


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
          Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Inversion/Calculus.lean - 2024-09-07 22:28:26.076676.
---94/200---
For theorem EuclideanGeometry.hasFDerivAt_inversion in Mathlib/Geometry/Euclidean/Inversion/Calculus.lean:
theorem hasFDerivAt_inversion (hx : x ≠ c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 • (reflection (ℝ ∙ (x - c))ᗮ : F →L[ℝ] F)) x 


Original valid proof:
:= by
  rcases add_left_surjective c x with ⟨x, rfl⟩
  have : HasFDerivAt (inversion c R) (?_ : F →L[ℝ] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (𝕜 := ℝ) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ℝ ∙ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ↦ ?_)
  · have : ((‖x‖ ^ 2) ^ 2)⁻¹ * (‖x‖ ^ 2) = (‖x‖ ^ 2)⁻¹ := by
      rw [← div_eq_inv_mul, sq (‖x‖ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  · simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]


Verifying proof (Commit 7088139429bcf36357f4c44f3beff1a1374a13e1):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

Attempt failure.

Working on Mathlib/Geometry/Manifold/BumpFunction.lean - 2024-09-07 22:28:33.458451.
---95/200---
For theorem SmoothBumpFunction.nhdsWithin_range_basis in Mathlib/Geometry/Manifold/BumpFunction.lean:
theorem nhdsWithin_range_basis :
    (𝓝[range I] extChartAt I c c).HasBasis (fun _ : SmoothBumpFunction I c => True) fun f =>
      closedBall (extChartAt I c c) f.rOut ∩ range I 


Original valid proof:
:= by
  refine ((nhdsWithin_hasBasis nhds_basis_closedBall _).restrict_subset
    (extChartAt_target_mem_nhdsWithin _ _)).to_hasBasis' ?_ ?_
  · rintro R ⟨hR0, hsub⟩
    exact ⟨⟨⟨R / 2, R, half_pos hR0, half_lt_self hR0⟩, hsub⟩, trivial, Subset.rfl⟩
  · exact fun f _ => inter_mem (mem_nhdsWithin_of_mem_nhds <| closedBall_mem_nhds _ f.rOut_pos)
      self_mem_nhdsWithin


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Geometry/Manifold/IntegralCurve.lean - 2024-09-07 22:28:43.476015.
---96/200---
For theorem IsIntegralCurve.isIntegralCurveAt in Mathlib/Geometry/Manifold/IntegralCurve.lean:
lemma IsIntegralCurve.isIntegralCurveAt (h : IsIntegralCurve γ v) (t : ℝ) :
    IsIntegralCurveAt γ v t 


Original valid proof:
:= isIntegralCurveAt_iff.mpr ⟨univ, Filter.univ_mem, fun t _ ↦ h t⟩


Verifying proof (Commit 2c4d77d7fd709133772709da9ffb1d698ecbcd0a):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Geometry/Manifold/VectorBundle/Basic.lean - 2024-09-07 22:28:57.126901.
---97/200---
For theorem Bundle.contMDiffWithinAt_totalSpace in Mathlib/Geometry/Manifold/VectorBundle/Basic.lean:
theorem contMDiffWithinAt_totalSpace (f : M → TotalSpace F E) {s : Set M} {x₀ : M} :
    ContMDiffWithinAt IM (IB.prod 𝓘(𝕜, F)) n f s x₀ ↔
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s x₀ ∧
      ContMDiffWithinAt IM 𝓘(𝕜, F) n (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).2) s x₀ 


Original valid proof:
:= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ← FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,
    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, ← chartedSpaceSelf_prod]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ⁻¹' (trivializationAt F E (f x₀).proj).baseSet ∈ 𝓝[s] x₀ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  · simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  · simp only [mfld_simps]


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    simp only [Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Fu

Attempt failure.

Working on Mathlib/GroupTheory/Coset.lean - 2024-09-07 22:29:09.216943.
---98/200---
For theorem mem_own_leftCoset in Mathlib/GroupTheory/Coset.lean:
theorem mem_own_leftCoset (a : α) : a ∈ a • (s : Set α) 


Original valid proof:
:=
  suffices a * 1 ∈ a • (s : Set α) by simpa
  mem_leftCoset a (one_mem s : 1 ∈ s)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/GroupTheory/OrderOfElement.lean - 2024-09-07 22:29:35.671699.
---99/200---
For theorem IsOfFinOrder.apply in Mathlib/GroupTheory/OrderOfElement.lean:
theorem IsOfFinOrder.apply {η : Type*} {Gs : η → Type*} [∀ i, Monoid (Gs i)] {x : ∀ i, Gs i}
    (h : IsOfFinOrder x) : ∀ i, IsOfFinOrder (x i) 


Original valid proof:
:= by
  obtain ⟨n, npos, hn⟩ := h.exists_pow_eq_one
  exact fun _ => isOfFinOrder_iff_pow_eq_one.mpr ⟨n, npos, (congr_fun hn.symm _).symm⟩


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

Attempt failure.

Working on Mathlib/GroupTheory/PGroup.lean - 2024-09-07 22:29:45.034876.
---100/200---
For theorem IsPGroup.disjoint_of_ne in Mathlib/GroupTheory/PGroup.lean:
theorem disjoint_of_ne (p₁ p₂ : ℕ) [hp₁ : Fact p₁.Prime] [hp₂ : Fact p₂.Prime] (hne : p₁ ≠ p₂)
    (H₁ H₂ : Subgroup G) (hH₁ : IsPGroup p₁ H₁) (hH₂ : IsPGroup p₂ H₂) : Disjoint H₁ H₂ 


Original valid proof:
:= by
  rw [Subgroup.disjoint_def]
  intro x hx₁ hx₂
  obtain ⟨n₁, hn₁⟩ := iff_orderOf.mp hH₁ ⟨x, hx₁⟩
  obtain ⟨n₂, hn₂⟩ := iff_orderOf.mp hH₂ ⟨x, hx₂⟩
  rw [Subgroup.orderOf_mk] at hn₁ hn₂
  have : p₁ ^ n₁ = p₂ ^ n₂ := by rw [← hn₁, ← hn₂]
  rcases n₁.eq_zero_or_pos with (rfl | hn₁)
  · simpa using hn₁
  · exact absurd (eq_of_prime_pow_eq hp₁.out.prime hp₂.out.prime hn₁ this) hne


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/GroupTheory/Perm/Cycle/Type.lean - 2024-09-07 22:29:51.783409.
---101/200---
For theorem Equiv.Perm.card_fixedPoints_modEq in Mathlib/GroupTheory/Perm/Cycle/Type.lean:
theorem card_fixedPoints_modEq [DecidableEq α] {f : Function.End α} {p n : ℕ}
    [hp : Fact p.Prime] (hf : f ^ p ^ n = 1) :
    Fintype.card α ≡ Fintype.card f.fixedPoints [MOD p] 


Original valid proof:
:= by
  let σ : α ≃ α := ⟨f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)⟩
  have hσ : σ ^ p ^ n = 1 := by
    rw [DFunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End α ↦ g) rfl (fun g h ↦ rfl) f (p ^ n)).symm.trans hf
  suffices Fintype.card f.fixedPoints = (support σ)ᶜ.card from
    this ▸ (card_compl_support_modEq hσ).symm
  suffices f.fixedPoints = (support σ)ᶜ by
    simp only [this]; apply Fintype.card_coe
  simp [σ, Set.ext_iff, IsFixedPt]


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

---102/200---
For theorem Equiv.Perm.card_fixedPoints_modEq in Mathlib/GroupTheory/Perm/Cycle/Type.lean:
theorem card_fixedPoints_modEq [DecidableEq α] {f : Function.End α} {p n : ℕ}
    [hp : Fact p.Prime] (hf : f ^ p ^ n = 1) :
    Fintype.card α ≡ Fintype.card f.fixedPoints [MOD p] 


Original valid proof:
:= by
  let σ : α ≃ α := ⟨f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)⟩
  have hσ : σ ^ p ^ n = 1 := by
    rw [DFunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End α ↦ g) rfl (fun g h ↦ rfl) f (p ^ n)).symm.trans hf
  suffices Fintype.card f.fixedPoints = (support σ)ᶜ.card from
    this ▸ (card_compl_support_modEq hσ).symm
  suffices f.fixedPoints = (support σ)ᶜ by
    simp only [this]; apply Fintype.card_coe
  simp [σ, Set.ext_iff, IsFixedPt]


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

---103/200---
For theorem Equiv.Perm.card_fixedPoints_modEq in Mathlib/GroupTheory/Perm/Cycle/Type.lean:
theorem card_fixedPoints_modEq [DecidableEq α] {f : Function.End α} {p n : ℕ}
    [hp : Fact p.Prime] (hf : f ^ p ^ n = 1) :
    Fintype.card α ≡ Fintype.card f.fixedPoints [MOD p] 


Original valid proof:
:= by
  let σ : α ≃ α := ⟨f, f ^ (p ^ n - 1),
    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),
    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)⟩
  have hσ : σ ^ p ^ n = 1 := by
    rw [DFunLike.ext'_iff, coe_pow]
    exact (hom_coe_pow (fun g : Function.End α ↦ g) rfl (fun g h ↦ rfl) f (p ^ n)).symm.trans hf
  suffices Fintype.card f.fixedPoints = (support σ)ᶜ.card from
    this ▸ (card_compl_support_modEq hσ).symm
  suffices f.fixedPoints = (support σ)ᶜ by
    simp only [this]; apply Fintype.card_coe
  simp [σ, Set.ext_iff, IsFixedPt]


Verifying proof (Commit 161c69c1dbf66cf3c7ec4f648a61551d044a43e4):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/GroupTheory/Sylow.lean - 2024-09-07 22:30:10.619652.
---104/200---
For theorem Sylow.exists_subgroup_le_card_le in Mathlib/GroupTheory/Sylow.lean:
lemma exists_subgroup_le_card_le {k p : ℕ} (hp : p.Prime) (h : IsPGroup p G) {H : Subgroup G}
    (hk : k ≤ Nat.card H) (hk₀ : k ≠ 0) : ∃ H' ≤ H, Nat.card H' ≤ k ∧ k < p * Nat.card H' 


Original valid proof:
:= by
  obtain ⟨m, hmk, hkm⟩ : ∃ s, p ^ s ≤ k ∧ k < p ^ (s + 1) :=
    exists_nat_pow_near (Nat.one_le_iff_ne_zero.2 hk₀) hp.one_lt
  obtain ⟨H', H'H, H'card⟩ := exists_subgroup_le_card_pow_prime_of_le_card hp h (hmk.trans hk)
  refine ⟨H', H'H, ?_⟩
  simpa only [pow_succ', H'card] using And.intro hmk hkm


Verifying proof (Commit a2d4b97db742cef33d7ce3404f92ab85330707e5):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/LinearAlgebra/FiniteDimensional.lean - 2024-09-07 22:30:22.258356.
---105/200---
For theorem Submodule.eq_top_of_finrank_eq in Mathlib/LinearAlgebra/FiniteDimensional.lean:
theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ⊤ 


Original valid proof:
:= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((↑) : ((↑) '' Basis.ofVectorSpaceIndex K S : Set V) → V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((↑) : S → V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (↑) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ← finrank_eq_card_basis bS, ←
            finrank_eq_card_basis b, h])
  rw [← b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ← this, ← Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]


Verifying proof (Commit bd925b6a47d15c0626631368b8cd4b10dac20b33):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---106/200---
For theorem Submodule.eq_top_of_finrank_eq in Mathlib/LinearAlgebra/FiniteDimensional.lean:
theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ⊤ 


Original valid proof:
:= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((↑) : ((↑) '' Basis.ofVectorSpaceIndex K S : Set V) → V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((↑) : S → V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (↑) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ← finrank_eq_card_basis bS, ←
            finrank_eq_card_basis b, h])
  rw [← b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ← this, ← Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]


Verifying proof (Commit 693fd79515903b10b1d31f10dccfc49e633cf7ee):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---107/200---
For theorem Submodule.eq_top_of_finrank_eq in Mathlib/LinearAlgebra/FiniteDimensional.lean:
theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ⊤ 


Original valid proof:
:= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((↑) : ((↑) '' Basis.ofVectorSpaceIndex K S : Set V) → V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((↑) : S → V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (↑) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ← finrank_eq_card_basis bS, ←
            finrank_eq_card_basis b, h])
  rw [← b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ← this, ← Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]


Verifying proof (Commit b011c17e9c6a01496da5c0aebc4ba8e3bb736da2):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/PosDef.lean - 2024-09-07 22:31:03.931613.
---108/200---
For theorem QuadraticForm.posDef_of_toMatrix' in Mathlib/LinearAlgebra/Matrix/PosDef.lean:
theorem posDef_of_toMatrix' [DecidableEq n] {Q : QuadraticForm ℝ (n → ℝ)}
    (hQ : Q.toMatrix'.PosDef) : Q.PosDef 


Original valid proof:
:= by
  rw [← toQuadraticForm_associated ℝ Q,
    ← LinearMap.toMatrix₂'.left_inv ((associatedHom (R := ℝ) ℝ) Q)]
  exact hQ.toQuadraticForm'


Verifying proof (Commit b82e978679b451490878b9d55401f33dea523113):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/LinearAlgebra/Orientation.lean - 2024-09-07 22:31:18.527234.
---109/200---
For theorem Orientation.map_eq_neg_iff_det_neg in Mathlib/LinearAlgebra/Orientation.lean:
theorem map_eq_neg_iff_det_neg (x : Orientation R M ι) (f : M ≃ₗ[R] M)
    (h : Fintype.card ι = finrank R M) :
    Orientation.map ι f x = -x ↔ LinearMap.det (f : M →ₗ[R] M) < 0 


Original valid proof:
:= by
  cases isEmpty_or_nonempty ι
  · have H : finrank R M = 0 := h.symm.trans Fintype.card_eq_zero
    simp [LinearMap.det_eq_one_of_finrank_eq_zero H, Module.Ray.ne_neg_self x]
  have H : 0 < finrank R M := by
    rw [← h]
    exact Fintype.card_pos
  haveI : FiniteDimensional R M := of_finrank_pos H
  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, LinearEquiv.coe_det]


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/LinearAlgebra/Semisimple.lean - 2024-09-07 22:31:28.940048.
---110/200---
For theorem Module.End.IsSemisimple.of_mem_adjoin_pair in Mathlib/LinearAlgebra/Semisimple.lean:
theorem IsSemisimple.of_mem_adjoin_pair {a : End K M} (ha : a ∈ Algebra.adjoin K {f, g}) :
    a.IsSemisimple 


Original valid proof:
:= by
  let R := K[X] ⧸ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R :=
    (AdjoinRoot.powerBasis' <| minpoly.monic <| Algebra.IsIntegral.isIntegral f).finite
  have : Finite R S :=
    (AdjoinRoot.powerBasis' <| (minpoly.monic <| Algebra.IsIntegral.isIntegral g).map _).finite
  set_option maxSynthPendingDepth 2 in
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ↦ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ▸ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ← Ideal.isRadical_iff_quotient_reduced, ← isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let φ : S →ₐ[K] End K M := Ideal.Quotient.liftₐ _ (eval₂AlgHom' (Ideal.Quotient.liftₐ _ (aeval f)
    fun a ↦ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ≤ RingHom.ker _)
  rotate_left 1
  · rw [Ideal.span, ← minpoly.ker_aeval_eq_span_minpoly]; exact id
  · rintro ⟨p⟩; exact p.induction_on (fun k ↦ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ↦ by simpa using hp.add_left hq)
      fun n k ↦ by simpa [R, pow_succ, ← mul_assoc _ _ X] using (·.mul_left comm)
  · simpa only [RingHom.mem_ker, eval₂AlgHom'_apply, eval₂_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ≤ φ.range := Algebra.adjoin_le fun x ↦ by
    rintro (hx | hx) <;> rw [hx]
    · exact ⟨AdjoinRoot.of _ (AdjoinRoot.root _), (eval₂_C _ _).trans (aeval_X f)⟩
    · exact ⟨AdjoinRoot.root _, eval₂_X _ _⟩
  obtain ⟨p, rfl⟩ := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, φ.comp_apply, minpoly.aeval, φ.map_zero]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/LinearAlgebra/Span.lean - 2024-09-07 22:31:37.528057.
---111/200---
For theorem Submodule.iSup_toAddSubmonoid in Mathlib/LinearAlgebra/Span.lean:
theorem iSup_toAddSubmonoid {ι : Sort*} (p : ι → Submodule R M) :
    (⨆ i, p i).toAddSubmonoid = ⨆ i, (p i).toAddSubmonoid 


Original valid proof:
:= by
  refine le_antisymm (fun x => ?_) (iSup_le fun i => toAddSubmonoid_mono <| le_iSup _ i)
  simp_rw [iSup_eq_span, AddSubmonoid.iSup_eq_closure, mem_toAddSubmonoid, coe_toAddSubmonoid]
  intro hx
  refine Submodule.span_induction hx (fun x hx => ?_) ?_ (fun x y hx hy => ?_) fun r x hx => ?_
  · exact AddSubmonoid.subset_closure hx
  · exact AddSubmonoid.zero_mem _
  · exact AddSubmonoid.add_mem _ hx hy
  · refine AddSubmonoid.closure_induction hx ?_ ?_ ?_
    · rintro x ⟨_, ⟨i, rfl⟩, hix : x ∈ p i⟩
      apply AddSubmonoid.subset_closure (Set.mem_iUnion.mpr ⟨i, _⟩)
      exact smul_mem _ r hix
    · rw [smul_zero]
      exact AddSubmonoid.zero_mem _
    · intro x y hx hy
      rw [smul_add]
      exact AddSubmonoid.add_mem _ hx hy


Verifying proof (Commit ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Logic/Equiv/List.lean - 2024-09-07 22:31:47.477844.
---112/200---
For theorem Denumerable.lower_raise in Mathlib/Logic/Equiv/List.lean:
theorem lower_raise : ∀ l n, lower (raise l n) n = l



Original valid proof:
  | [], n => rfl
  | m :: l, n => by rw [raise, lower, Nat.add_sub_cancel_right, lower_raise l]


Verifying proof (Commit 2235ae5100e2af7f16bea313637531b24bf8e1e0):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ_iff,
      Finset.mem_univ,

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Besicovitch.lean - 2024-09-07 22:31:51.539523.
---113/200---
For theorem Besicovitch.exists_disjoint_closedBall_covering_ae in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (μ : Measure α)
    [IsFiniteMeasure μ] (f : α → Set ℝ) (s : Set α)
    (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :
    ∃ t : Set (α × ℝ), t.Countable ∧ (∀ p ∈ t, p.1 ∈ s) ∧ (∀ p ∈ t, p.2 ∈ f p.1) ∧
      μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) = 0 ∧
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 


Original valid proof:
:= by
  rcases HasBesicovitchCovering.no_satelliteConfig (α := α) with ⟨N, τ, hτ, hN⟩
  let P : Finset (α × ℝ) → Prop := fun t =>
    ((t : Set (α × ℝ)).PairwiseDisjoint fun p => closedBall p.1 p.2) ∧
      (∀ p : α × ℝ, p ∈ t → p.1 ∈ s) ∧ ∀ p : α × ℝ, p ∈ t → p.2 ∈ f p.1
  have :
      ∀ t : Finset (α × ℝ), P t → ∃ u : Finset (α × ℝ), t ⊆ u ∧ P u ∧
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u), closedBall p.1 p.2) ≤
          N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) := by
    intro t ht
    set B := ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ∀ x ∈ s', ∃ r ∈ f x ∩ Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ∈ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      · rcases hf x xs 1 zero_lt_one with ⟨r, hr, h'r⟩
        exact ⟨r, ⟨hr, h'r⟩, by simp only [hB, empty_disjoint]⟩
      · let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ⟨r, hr, h'r⟩
        refine ⟨r, ⟨hr, ⟨h'r.1, h'r.2.trans_le (min_le_right _ _)⟩⟩, ?_⟩
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ⟨v, vs', hμv, hv⟩ :
      ∃ v : Finset α,
        ↑v ⊆ s' ∧
          μ (s' \ ⋃ x ∈ v, closedBall x (r x)) ≤ N / (N + 1) * μ s' ∧
            (v : Set α).PairwiseDisjoint fun x : α => closedBall x (r x) :=
      haveI rI : ∀ x ∈ s', r x ∈ Ioo (0 : ℝ) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure μ hτ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ⟨t ∪ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ⟨?_, ?_, ?_⟩, ?_⟩
    · simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ⟨p', p'v, rfl⟩
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ← Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : α × ℝ => closedBall x.1 x.2) hp
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.1 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.2 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact (hr p' (vs' p'v)).1.1
    · convert hμv using 2
      rw [Finset.set_biUnion_union, ← diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ∅
  have u_succ : ∀ n : ℕ, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ∀ n, P (u n) := by
    intro n
    induction' n with n IH
    · simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall₂_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    · rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ⟨⋃ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_⟩
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  · have A :
      ∀ n,
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ ⋃ n : ℕ, (u n : Set (α × ℝ))), closedBall p.fst p.snd) ≤
          μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr μ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (α × ℝ))) n)
    have B :
        ∀ n, μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) ≤
          (N / (N + 1) : ℝ≥0∞) ^ n * μ s := by
      intro n
      induction' n with n IH
      · simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n.succ), closedBall p.fst p.snd) ≤
            N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ≤ (N / (N + 1) : ℝ≥0∞) ^ n.succ * μ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ℕ => ((N : ℝ≥0∞) / (N + 1)) ^ n * μ s) atTop (𝓝 (0 * μ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top μ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      · conv_lhs => rw [← add_zero (N : ℝ≥0∞)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      · simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      · simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  · refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [← Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1


Verifying proof (Commit fb54f94c133c9225bec877b481995fc98cd3a253):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---114/200---
For theorem Besicovitch.exists_disjoint_closedBall_covering_ae in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (μ : Measure α)
    [IsFiniteMeasure μ] (f : α → Set ℝ) (s : Set α)
    (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :
    ∃ t : Set (α × ℝ), t.Countable ∧ (∀ p ∈ t, p.1 ∈ s) ∧ (∀ p ∈ t, p.2 ∈ f p.1) ∧
      μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) = 0 ∧
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 


Original valid proof:
:= by
  rcases HasBesicovitchCovering.no_satelliteConfig (α := α) with ⟨N, τ, hτ, hN⟩
  let P : Finset (α × ℝ) → Prop := fun t =>
    ((t : Set (α × ℝ)).PairwiseDisjoint fun p => closedBall p.1 p.2) ∧
      (∀ p : α × ℝ, p ∈ t → p.1 ∈ s) ∧ ∀ p : α × ℝ, p ∈ t → p.2 ∈ f p.1
  have :
      ∀ t : Finset (α × ℝ), P t → ∃ u : Finset (α × ℝ), t ⊆ u ∧ P u ∧
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u), closedBall p.1 p.2) ≤
          N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) := by
    intro t ht
    set B := ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ∀ x ∈ s', ∃ r ∈ f x ∩ Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ∈ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      · rcases hf x xs 1 zero_lt_one with ⟨r, hr, h'r⟩
        exact ⟨r, ⟨hr, h'r⟩, by simp only [hB, empty_disjoint]⟩
      · let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ⟨r, hr, h'r⟩
        refine ⟨r, ⟨hr, ⟨h'r.1, h'r.2.trans_le (min_le_right _ _)⟩⟩, ?_⟩
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ⟨v, vs', hμv, hv⟩ :
      ∃ v : Finset α,
        ↑v ⊆ s' ∧
          μ (s' \ ⋃ x ∈ v, closedBall x (r x)) ≤ N / (N + 1) * μ s' ∧
            (v : Set α).PairwiseDisjoint fun x : α => closedBall x (r x) :=
      haveI rI : ∀ x ∈ s', r x ∈ Ioo (0 : ℝ) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure μ hτ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ⟨t ∪ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ⟨?_, ?_, ?_⟩, ?_⟩
    · simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ⟨p', p'v, rfl⟩
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ← Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : α × ℝ => closedBall x.1 x.2) hp
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.1 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.2 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact (hr p' (vs' p'v)).1.1
    · convert hμv using 2
      rw [Finset.set_biUnion_union, ← diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ∅
  have u_succ : ∀ n : ℕ, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ∀ n, P (u n) := by
    intro n
    induction' n with n IH
    · simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall₂_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    · rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ⟨⋃ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_⟩
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  · have A :
      ∀ n,
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ ⋃ n : ℕ, (u n : Set (α × ℝ))), closedBall p.fst p.snd) ≤
          μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr μ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (α × ℝ))) n)
    have B :
        ∀ n, μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) ≤
          (N / (N + 1) : ℝ≥0∞) ^ n * μ s := by
      intro n
      induction' n with n IH
      · simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n.succ), closedBall p.fst p.snd) ≤
            N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ≤ (N / (N + 1) : ℝ≥0∞) ^ n.succ * μ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ℕ => ((N : ℝ≥0∞) / (N + 1)) ^ n * μ s) atTop (𝓝 (0 * μ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top μ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      · conv_lhs => rw [← add_zero (N : ℝ≥0∞)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      · simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      · simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  · refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [← Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---115/200---
For theorem Besicovitch.exists_disjoint_closedBall_covering_ae in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (μ : Measure α)
    [IsFiniteMeasure μ] (f : α → Set ℝ) (s : Set α)
    (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :
    ∃ t : Set (α × ℝ), t.Countable ∧ (∀ p ∈ t, p.1 ∈ s) ∧ (∀ p ∈ t, p.2 ∈ f p.1) ∧
      μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) = 0 ∧
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 


Original valid proof:
:= by
  rcases HasBesicovitchCovering.no_satelliteConfig (α := α) with ⟨N, τ, hτ, hN⟩
  let P : Finset (α × ℝ) → Prop := fun t =>
    ((t : Set (α × ℝ)).PairwiseDisjoint fun p => closedBall p.1 p.2) ∧
      (∀ p : α × ℝ, p ∈ t → p.1 ∈ s) ∧ ∀ p : α × ℝ, p ∈ t → p.2 ∈ f p.1
  have :
      ∀ t : Finset (α × ℝ), P t → ∃ u : Finset (α × ℝ), t ⊆ u ∧ P u ∧
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u), closedBall p.1 p.2) ≤
          N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) := by
    intro t ht
    set B := ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ∀ x ∈ s', ∃ r ∈ f x ∩ Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ∈ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      · rcases hf x xs 1 zero_lt_one with ⟨r, hr, h'r⟩
        exact ⟨r, ⟨hr, h'r⟩, by simp only [hB, empty_disjoint]⟩
      · let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ⟨r, hr, h'r⟩
        refine ⟨r, ⟨hr, ⟨h'r.1, h'r.2.trans_le (min_le_right _ _)⟩⟩, ?_⟩
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ⟨v, vs', hμv, hv⟩ :
      ∃ v : Finset α,
        ↑v ⊆ s' ∧
          μ (s' \ ⋃ x ∈ v, closedBall x (r x)) ≤ N / (N + 1) * μ s' ∧
            (v : Set α).PairwiseDisjoint fun x : α => closedBall x (r x) :=
      haveI rI : ∀ x ∈ s', r x ∈ Ioo (0 : ℝ) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure μ hτ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ⟨t ∪ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ⟨?_, ?_, ?_⟩, ?_⟩
    · simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ⟨p', p'v, rfl⟩
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ← Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : α × ℝ => closedBall x.1 x.2) hp
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.1 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.2 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact (hr p' (vs' p'v)).1.1
    · convert hμv using 2
      rw [Finset.set_biUnion_union, ← diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ∅
  have u_succ : ∀ n : ℕ, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ∀ n, P (u n) := by
    intro n
    induction' n with n IH
    · simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall₂_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    · rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ⟨⋃ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_⟩
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  · have A :
      ∀ n,
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ ⋃ n : ℕ, (u n : Set (α × ℝ))), closedBall p.fst p.snd) ≤
          μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr μ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (α × ℝ))) n)
    have B :
        ∀ n, μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) ≤
          (N / (N + 1) : ℝ≥0∞) ^ n * μ s := by
      intro n
      induction' n with n IH
      · simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n.succ), closedBall p.fst p.snd) ≤
            N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ≤ (N / (N + 1) : ℝ≥0∞) ^ n.succ * μ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ℕ => ((N : ℝ≥0∞) / (N + 1)) ^ n * μ s) atTop (𝓝 (0 * μ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top μ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      · conv_lhs => rw [← add_zero (N : ℝ≥0∞)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      · simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      · simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  · refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [← Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1


Verifying proof (Commit b50a8b2e9760b6f582390d3948a953c553480df1):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Differentiation.lean - 2024-09-07 22:32:23.650397.
---116/200---
For theorem VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem ae_tendsto_measure_inter_div_of_measurableSet {s : Set α} (hs : MeasurableSet s) :
    ∀ᵐ x ∂μ, Tendsto (fun a => μ (s ∩ a) / μ a) (v.filterAt x) (𝓝 (s.indicator 1 x)) 


Original valid proof:
:= by
  haveI : IsLocallyFiniteMeasure (μ.restrict s) :=
    isLocallyFiniteMeasure_of_le restrict_le_self
  filter_upwards [ae_tendsto_rnDeriv v (μ.restrict s), rnDeriv_restrict_self μ hs]
  intro x hx h'x
  simpa only [h'x, restrict_apply' hs, inter_comm] using hx


Verifying proof (Commit 5f16c539a4048e107d2e8f76816e95423850fb6d):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

Attempt failure.

---117/200---
For theorem VitaliFamily.le_mul_withDensity in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem le_mul_withDensity {s : Set α} (hs : MeasurableSet s) {t : ℝ≥0} (ht : 1 < t) :
    ρ s ≤ t * μ.withDensity (v.limRatioMeas hρ) s 


Original valid proof:
:= by
  have t_ne_zero' : t ≠ 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ℝ≥0∞) ≠ 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ν := μ.withDensity (v.limRatioMeas hρ)
  let f := v.limRatioMeas hρ
  have f_meas : Measurable f := v.limRatioMeas_measurable hρ
  have A : ρ (s ∩ f ⁻¹' {0}) ≤ (t • ν) (s ∩ f ⁻¹' {0}) := by
    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))
    exact v.measure_limRatioMeas_zero hρ
  have B : ρ (s ∩ f ⁻¹' {∞}) ≤ (t • ν) (s ∩ f ⁻¹' {∞}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply hρ
    rw [← nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hρ).le
  have C :
    ∀ n : ℤ,
      ρ (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) ≤
        (t • ν) (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))
    have M : MeasurableSet (s ∩ f ⁻¹' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ν, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      ρ (s ∩ f ⁻¹' I) ≤ (t : ℝ≥0∞) ^ (n + 1) * μ (s ∩ f ⁻¹' I) := by
        rw [← ENNReal.coe_zpow t_ne_zero']
        apply v.measure_le_mul_of_subset_limRatioMeas_lt hρ
        intro x hx
        apply hx.2.2.trans_le (le_of_eq _)
        rw [ENNReal.coe_zpow t_ne_zero']
      _ = ∫⁻ _ in s ∩ f ⁻¹' I, (t : ℝ≥0∞) ^ (n + 1) ∂μ := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ ≤ ∫⁻ x in s ∩ f ⁻¹' I, t * f x ∂μ := by
        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => ?_))
        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]
        exact mul_le_mul_left' hx.2.1 _
      _ = t * ∫⁻ x in s ∩ f ⁻¹' I, f x ∂μ := lintegral_const_mul _ f_meas
  calc
    ρ s =
      ρ (s ∩ f ⁻¹' {0}) + ρ (s ∩ f ⁻¹' {∞}) +
        ∑' n : ℤ, ρ (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ρ f_meas hs ht
    _ ≤
        (t • ν) (s ∩ f ⁻¹' {0}) + (t • ν) (s ∩ f ⁻¹' {∞}) +
          ∑' n : ℤ, (t • ν) (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = (t • ν) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t • ν) f_meas hs ht).symm


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---118/200---
For theorem VitaliFamily.null_of_frequently_le_of_frequently_ge in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem null_of_frequently_le_of_frequently_ge {c d : ℝ≥0} (hcd : c < d) (s : Set α)
    (hc : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, ρ a ≤ c * μ a)
    (hd : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, (d : ℝ≥0∞) * μ a ≤ ρ a) : μ s = 0 


Original valid proof:
:= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ⟨o, xo, o_open, μo⟩ : ∃ o : Set α, x ∈ o ∧ IsOpen o ∧ μ o < ∞ :=
    Measure.exists_isOpen_measure_lt_top μ x
  refine ⟨s ∩ o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_⟩
  let s' := s ∩ o
  by_contra h
  apply lt_irrefl (ρ s')
  calc
    ρ s' ≤ c * μ s' := v.measure_le_of_frequently_le (c • μ) hρ s' fun x hx => hc x hx.1
    _ < d * μ s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono inter_subset_right) μo).ne
    _ ≤ ρ s' :=
      v.measure_le_of_frequently_le ρ ((Measure.AbsolutelyContinuous.refl μ).smul d) s' fun x hx =>
        hd x hx.1


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/MeasureTheory/Decomposition/SignedLebesgue.lean - 2024-09-07 22:32:57.108465.
---119/200---
For theorem MeasureTheory.SignedMeasure.singularPart_add in Mathlib/MeasureTheory/Decomposition/SignedLebesgue.lean:
theorem singularPart_add_withDensity_rnDeriv_eq [s.HaveLebesgueDecomposition μ] :
    s.singularPart μ + μ.withDensityᵥ (s.rnDeriv μ) = s 


Original valid proof:
:= by
  conv_rhs =>
    rw [← toSignedMeasure_toJordanDecomposition s, JordanDecomposition.toSignedMeasure]
  rw [singularPart, rnDeriv_def,
    withDensityᵥ_sub' (integrable_toReal_of_lintegral_ne_top _ _)
      (integrable_toReal_of_lintegral_ne_top _ _),
    withDensityᵥ_toReal, withDensityᵥ_toReal, sub_eq_add_neg, sub_eq_add_neg,
    add_comm (s.toJordanDecomposition.posPart.singularPart μ).toSignedMeasure, ← add_assoc,
    add_assoc (-(s.toJordanDecomposition.negPart.singularPart μ).toSignedMeasure),
    ← toSignedMeasure_add, add_comm, ← add_assoc, ← neg_add, ← toSignedMeasure_add, add_comm,
    ← sub_eq_add_neg]
  · convert rfl
    · exact s.toJordanDecomposition.posPart.haveLebesgueDecomposition_add μ
    · rw [add_comm]
      exact s.toJordanDecomposition.negPart.haveLebesgueDecomposition_add μ
  all_goals
    first
    | exact (lintegral_rnDeriv_lt_top _ _).ne
    | measurability


Verifying proof (Commit b492f764dc62b80a0be745055df26ce5b018a24a):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

Working on Mathlib/MeasureTheory/Function/ContinuousMapDense.lean - 2024-09-07 22:33:07.085001.
---120/200---
For theorem MeasureTheory.Memℒp.exists_hasCompactSupport_integral_rpow_sub_le in Mathlib/MeasureTheory/Function/ContinuousMapDense.lean:
theorem Memℒp.exists_hasCompactSupport_integral_rpow_sub_le
    [WeaklyLocallyCompactSpace α] [μ.Regular]
    {p : ℝ} (hp : 0 < p) {f : α → E} (hf : Memℒp f (ENNReal.ofReal p) μ) {ε : ℝ} (hε : 0 < ε) :
    ∃ g : α → E,
      HasCompactSupport g ∧
        (∫ x, ‖f x - g x‖ ^ p ∂μ) ≤ ε ∧ Continuous g ∧ Memℒp g (ENNReal.ofReal p) μ 


Original valid proof:
:= by
  have I : 0 < ε ^ (1 / p) := Real.rpow_pos_of_pos hε _
  have A : ENNReal.ofReal (ε ^ (1 / p)) ≠ 0 := by
    simp only [Ne, ENNReal.ofReal_eq_zero, not_le, I]
  have B : ENNReal.ofReal p ≠ 0 := by simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hp
  rcases hf.exists_hasCompactSupport_snorm_sub_le ENNReal.coe_ne_top A with
    ⟨g, g_support, hg, g_cont, g_mem⟩
  change snorm _ (ENNReal.ofReal p) _ ≤ _ at hg
  refine ⟨g, g_support, ?_, g_cont, g_mem⟩
  rwa [(hf.sub g_mem).snorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,
    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,
    Real.rpow_le_rpow_iff _ hε.le (inv_pos.2 hp)] at hg
  positivity


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean - 2024-09-07 22:33:15.693247.
---121/200---
For theorem MeasureTheory.tendstoInMeasure_of_tendsto_ae_of_stronglyMeasurable in Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean:
theorem tendstoInMeasure_of_tendsto_ae_of_stronglyMeasurable [IsFiniteMeasure μ]
    (hf : ∀ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)
    (hfg : ∀ᵐ x ∂μ, Tendsto (fun n => f n x) atTop (𝓝 (g x))) : TendstoInMeasure μ f atTop g 


Original valid proof:
:= by
  refine fun ε hε => ENNReal.tendsto_atTop_zero.mpr fun δ hδ => ?_
  by_cases hδi : δ = ∞
  · simp only [hδi, imp_true_iff, le_top, exists_const]
  lift δ to ℝ≥0 using hδi
  rw [gt_iff_lt, ENNReal.coe_pos, ← NNReal.coe_pos] at hδ
  obtain ⟨t, _, ht, hunif⟩ := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg hδ
  rw [ENNReal.ofReal_coe_nnreal] at ht
  rw [Metric.tendstoUniformlyOn_iff] at hunif
  obtain ⟨N, hN⟩ := eventually_atTop.1 (hunif ε hε)
  refine ⟨N, fun n hn => ?_⟩
  suffices { x : α | ε ≤ dist (f n x) (g x) } ⊆ t from (measure_mono this).trans ht
  rw [← Set.compl_subset_compl]
  intro x hx
  rw [Set.mem_compl_iff, Set.nmem_setOf_iff, dist_comm, not_le]
  exact hN n hn x hx


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

Working on Mathlib/MeasureTheory/Function/Jacobian.lean - 2024-09-07 22:33:23.442046.
---122/200---
For theorem MeasureTheory.mul_le_addHaar_image_of_lt_det in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem mul_le_addHaar_image_of_lt_det (A : E →L[ℝ] E) {m : ℝ≥0}
    (hm : (m : ℝ≥0∞) < ENNReal.ofReal |A.det|) :
    ∀ᶠ δ in 𝓝[>] (0 : ℝ≥0),
      ∀ (s : Set E) (f : E → E), ApproximatesLinearOn f A s δ → (m : ℝ≥0∞) * μ s ≤ μ (f '' s) 


Original valid proof:
:= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  · filter_upwards
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ≠ 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E →L[ℝ] E).det| < (m⁻¹ : ℝ≥0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ⊢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ⟨δ₀, δ₀pos, hδ₀⟩ :
    ∃ δ : ℝ≥0,
      0 < δ ∧
        ∀ (t : Set E) (g : E → E),
          ApproximatesLinearOn g (B.symm : E →L[ℝ] E) t δ → μ (g '' t) ≤ ↑m⁻¹ * μ t := by
    have :
      ∀ᶠ δ : ℝ≥0 in 𝓝[>] 0,
        ∀ (t : Set E) (g : E → E),
          ApproximatesLinearOn g (B.symm : E →L[ℝ] E) t δ → μ (g '' t) ≤ ↑m⁻¹ * μ t :=
      addHaar_image_le_mul_of_det_lt μ B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ⟨δ₀, h, h'⟩
    exact ⟨δ₀, h', h⟩
  have L1 : ∀ᶠ δ in 𝓝 (0 : ℝ≥0), Subsingleton E ∨ δ < ‖(B.symm : E →L[ℝ] E)‖₊⁻¹ := by
    by_cases h : Subsingleton E
    · simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ∀ᶠ δ in 𝓝 (0 : ℝ≥0), ‖(B.symm : E →L[ℝ] E)‖₊ * (‖(B.symm : E →L[ℝ] E)‖₊⁻¹ - δ)⁻¹ * δ < δ₀ := by
    have :
      Tendsto (fun δ => ‖(B.symm : E →L[ℝ] E)‖₊ * (‖(B.symm : E →L[ℝ] E)‖₊⁻¹ - δ)⁻¹ * δ) (𝓝 0)
        (𝓝 (‖(B.symm : E →L[ℝ] E)‖₊ * (‖(B.symm : E →L[ℝ] E)‖₊⁻¹ - 0)⁻¹ * 0)) := by
      rcases eq_or_ne ‖(B.symm : E →L[ℝ] E)‖₊ 0 with (H | H)
      · simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv₀ ?_
      simpa only [tsub_zero, inv_eq_zero, Ne] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 δ₀ δ₀pos
  filter_upwards [L1, L2]
  intro δ h1δ h2δ s f hf
  have hf' : ApproximatesLinearOn f (B : E →L[ℝ] E) s δ := by convert hf
  let F := hf'.toPartialEquiv h1δ
  suffices H : μ (F.symm '' F.target) ≤ (m⁻¹ : ℝ≥0) * μ F.target by
    change (m : ℝ≥0∞) * μ F.source ≤ μ F.target
    rwa [← F.symm_image_target_eq_source, mul_comm, ← ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ← ENNReal.coe_inv mpos.ne']
    · apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne] using mpos.ne'
    · simp only [ENNReal.coe_ne_top, true_or_iff, Ne, not_false_iff]
  exact hδ₀ _ _ ((hf'.to_inv h1δ).mono_num h2δ.le)


Verifying proof (Commit 7088139429bcf36357f4c44f3beff1a1374a13e1):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---123/200---
For theorem MeasureTheory.aemeasurable_fderivWithin in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem aemeasurable_fderivWithin (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (μ.restrict s) 


Original valid proof:
:= by
  refine aemeasurable_of_unif_approx fun ε εpos => ?_
  let δ : ℝ≥0 := ⟨ε, le_of_lt εpos⟩
  have δpos : 0 < δ := εpos
  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, _⟩ :
    ∃ (t : ℕ → Set E) (A : ℕ → E →L[ℝ] E),
      Pairwise (Disjoint on t) ∧
        (∀ n : ℕ, MeasurableSet (t n)) ∧
          (s ⊆ ⋃ n : ℕ, t n) ∧
            (∀ n : ℕ, ApproximatesLinearOn f (A n) (s ∩ t n) δ) ∧
              (s.Nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => δ) fun _ =>
      δpos.ne'
  obtain ⟨g, g_meas, hg⟩ :
      ∃ g : E → E →L[ℝ] E, Measurable g ∧ ∀ (n : ℕ) (x : E), x ∈ t n → g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ⟨g, g_meas.aemeasurable, ?_⟩
  suffices H : ∀ᵐ x : E ∂sum fun n ↦ μ.restrict (s ∩ t n), dist (g x) (f' x) ≤ ε by
    have : μ.restrict s ≤ sum fun n => μ.restrict (s ∩ t n) := by
      have : s = ⋃ n, s ∩ t n := by
        rw [← inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E₁ : ∀ᵐ x : E ∂μ.restrict (s ∩ t n), ‖f' x - A n‖₊ ≤ δ :=
    (ht n).norm_fderiv_sub_le μ (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E₂ : ∀ᵐ x : E ∂μ.restrict (s ∩ t n), g x = A n := by
    suffices H : ∀ᵐ x : E ∂μ.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E₁, E₂] with x hx1 hx2
  rw [← nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1


Verifying proof (Commit 0939faa78a0c4506a8aee4e86b897d6e84c6cb96):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---124/200---
For theorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]
    (f : E → F) (s : Set E) (f' : E → E →L[ℝ] F) (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x)
    (r : (E →L[ℝ] F) → ℝ≥0) (rpos : ∀ A, r A ≠ 0) :
    ∃ (t : ℕ → Set E) (A : ℕ → E →L[ℝ] F),
      (∀ n, IsClosed (t n)) ∧
        (s ⊆ ⋃ n, t n) ∧
          (∀ n, ApproximatesLinearOn f (A n) (s ∩ t n) (r (A n))) ∧
            (s.Nonempty → ∀ n, ∃ y ∈ s, A n = f' y) 


Original valid proof:
:= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  · refine ⟨fun _ => ∅, fun _ => 0, ?_, ?_, ?_, ?_⟩ <;> simp
  obtain ⟨T, T_count, hT⟩ :
    ∃ T : Set s,
      T.Countable ∧ ⋃ x ∈ T, ball (f' (x : E)) (r (f' x)) = ⋃ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ⟨u, _, u_pos, u_lim⟩ :
    ∃ u : ℕ → ℝ, StrictAnti u ∧ (∀ n : ℕ, 0 < u n) ∧ Tendsto u atTop (𝓝 0) :=
    exists_seq_strictAnti_tendsto (0 : ℝ)
  let M : ℕ → T → Set E := fun n z =>
    {x | x ∈ s ∧ ∀ y ∈ s ∩ ball x (u n), ‖f y - f x - f' z (y - x)‖ ≤ r (f' z) * ‖y - x‖}
  have s_subset : ∀ x ∈ s, ∃ (n : ℕ) (z : T), x ∈ M n z := by
    intro x xs
    obtain ⟨z, zT, hz⟩ : ∃ z ∈ T, f' x ∈ ball (f' (z : E)) (r (f' z)) := by
      have : f' x ∈ ⋃ z ∈ T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ⟨⟨x, xs⟩, ?_⟩
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion₂, bex_def] at this
    obtain ⟨ε, εpos, hε⟩ : ∃ ε : ℝ, 0 < ε ∧ ‖f' x - f' z‖ + ε ≤ r (f' z) := by
      refine ⟨r (f' z) - ‖f' x - f' z‖, ?_, le_of_eq (by abel)⟩
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ⟨δ, δpos, hδ⟩ :
      ∃ (δ : ℝ), 0 < δ ∧ ball x δ ∩ s ⊆ {y | ‖f y - f x - (f' x) (y - x)‖ ≤ ε * ‖y - x‖} :=
      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def εpos)
    obtain ⟨n, hn⟩ : ∃ n, u n < δ := ((tendsto_order.1 u_lim).2 _ δpos).exists
    refine ⟨n, ⟨z, zT⟩, ⟨xs, ?_⟩⟩
    intro y hy
    calc
      ‖f y - f x - (f' z) (y - x)‖ = ‖f y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‖ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ≤ ‖f y - f x - (f' x) (y - x)‖ + ‖(f' x - f' z) (y - x)‖ := norm_add_le _ _
      _ ≤ ε * ‖y - x‖ + ‖f' x - f' z‖ * ‖y - x‖ := by
        refine add_le_add (hδ ?_) (ContinuousLinearMap.le_opNorm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ≤ r (f' z) * ‖y - x‖ := by
        rw [← add_mul, add_comm]
        gcongr
  have closure_M_subset : ∀ n z, s ∩ closure (M n z) ⊆ M n z := by
    rintro n z x ⟨xs, hx⟩
    refine ⟨xs, fun y hy => ?_⟩
    obtain ⟨a, aM, a_lim⟩ : ∃ a : ℕ → E, (∀ k, a k ∈ M n z) ∧ Tendsto a atTop (𝓝 x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ℕ => ‖f y - f (a k) - (f' z) (y - a k)‖) atTop
        (𝓝 ‖f y - f x - (f' z) (y - x)‖) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (𝓝 (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ℕ => (r (f' z) : ℝ) * ‖y - a k‖) atTop (𝓝 (r (f' z) * ‖y - x‖)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ∀ᶠ k in atTop, ‖f y - f (a k) - (f' z) (y - a k)‖ ≤ r (f' z) * ‖y - a k‖ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (𝓝 (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ⟨hy.1, hk⟩
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ⟨d, hd⟩
  let K : ℕ → T → ℕ → Set E := fun n z p => closure (M n z) ∩ closedBall (d p) (u n / 3)
  have K_approx : ∀ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ∩ K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ∈ M n z := closure_M_subset _ _ ⟨hy.1, hy.2.1⟩
    refine yM.2 _ ⟨hx.1, ?_⟩
    calc
      dist x y ≤ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ≤ u n / 3 + u n / 3 := add_le_add hx.2.2 hy.2.2
      _ < u n := by linarith [u_pos n]
  have K_closed : ∀ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ⟨F, hF⟩ : ∃ F : ℕ → ℕ × T × ℕ, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases hs with ⟨x, xs⟩
      rcases s_subset x xs with ⟨n, z, _⟩
      exact ⟨z⟩
    inhabit ↥T
    exact ⟨_, Encodable.surjective_decode_iget (ℕ × T × ℕ)⟩
  refine
    ⟨fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => ?_, fun q => K_approx _ _ _, fun _ q => ⟨(F q).2.1, (F q).2.1.1.2, rfl⟩⟩
  obtain ⟨n, z, hnz⟩ : ∃ (n : ℕ) (z : T), x ∈ M n z := s_subset x xs
  obtain ⟨p, hp⟩ : ∃ p : ℕ, x ∈ closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ⟨p, hp⟩ : ∃ p : ℕ, d p ∈ ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ⟨p, (mem_ball'.1 hp).le⟩
  obtain ⟨q, hq⟩ : ∃ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ⟨q, _⟩
  simp (config := { zeta := false }) only [K, hq, mem_inter_iff, hp, and_true]
  exact subset_closure hnz


Verifying proof (Commit 775e01228dac511545eaea91c9d7e90a5ffa55b4):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
          Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,

Attempt failure.

---125/200---
For theorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]
    (f : E → F) (s : Set E) (f' : E → E →L[ℝ] F) (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x)
    (r : (E →L[ℝ] F) → ℝ≥0) (rpos : ∀ A, r A ≠ 0) :
    ∃ (t : ℕ → Set E) (A : ℕ → E →L[ℝ] F),
      (∀ n, IsClosed (t n)) ∧
        (s ⊆ ⋃ n, t n) ∧
          (∀ n, ApproximatesLinearOn f (A n) (s ∩ t n) (r (A n))) ∧
            (s.Nonempty → ∀ n, ∃ y ∈ s, A n = f' y) 


Original valid proof:
:= by
  rcases eq_empty_or_nonempty s with (rfl | hs)
  · refine ⟨fun _ => ∅, fun _ => 0, ?_, ?_, ?_, ?_⟩ <;> simp
  obtain ⟨T, T_count, hT⟩ :
    ∃ T : Set s,
      T.Countable ∧ ⋃ x ∈ T, ball (f' (x : E)) (r (f' x)) = ⋃ x : s, ball (f' x) (r (f' x)) :=
    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball
  obtain ⟨u, _, u_pos, u_lim⟩ :
    ∃ u : ℕ → ℝ, StrictAnti u ∧ (∀ n : ℕ, 0 < u n) ∧ Tendsto u atTop (𝓝 0) :=
    exists_seq_strictAnti_tendsto (0 : ℝ)
  let M : ℕ → T → Set E := fun n z =>
    {x | x ∈ s ∧ ∀ y ∈ s ∩ ball x (u n), ‖f y - f x - f' z (y - x)‖ ≤ r (f' z) * ‖y - x‖}
  have s_subset : ∀ x ∈ s, ∃ (n : ℕ) (z : T), x ∈ M n z := by
    intro x xs
    obtain ⟨z, zT, hz⟩ : ∃ z ∈ T, f' x ∈ ball (f' (z : E)) (r (f' z)) := by
      have : f' x ∈ ⋃ z ∈ T, ball (f' (z : E)) (r (f' z)) := by
        rw [hT]
        refine mem_iUnion.2 ⟨⟨x, xs⟩, ?_⟩
        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt
      rwa [mem_iUnion₂, bex_def] at this
    obtain ⟨ε, εpos, hε⟩ : ∃ ε : ℝ, 0 < ε ∧ ‖f' x - f' z‖ + ε ≤ r (f' z) := by
      refine ⟨r (f' z) - ‖f' x - f' z‖, ?_, le_of_eq (by abel)⟩
      simpa only [sub_pos] using mem_ball_iff_norm.mp hz
    obtain ⟨δ, δpos, hδ⟩ :
      ∃ (δ : ℝ), 0 < δ ∧ ball x δ ∩ s ⊆ {y | ‖f y - f x - (f' x) (y - x)‖ ≤ ε * ‖y - x‖} :=
      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def εpos)
    obtain ⟨n, hn⟩ : ∃ n, u n < δ := ((tendsto_order.1 u_lim).2 _ δpos).exists
    refine ⟨n, ⟨z, zT⟩, ⟨xs, ?_⟩⟩
    intro y hy
    calc
      ‖f y - f x - (f' z) (y - x)‖ = ‖f y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)‖ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ≤ ‖f y - f x - (f' x) (y - x)‖ + ‖(f' x - f' z) (y - x)‖ := norm_add_le _ _
      _ ≤ ε * ‖y - x‖ + ‖f' x - f' z‖ * ‖y - x‖ := by
        refine add_le_add (hδ ?_) (ContinuousLinearMap.le_opNorm _ _)
        rw [inter_comm]
        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy
      _ ≤ r (f' z) * ‖y - x‖ := by
        rw [← add_mul, add_comm]
        gcongr
  have closure_M_subset : ∀ n z, s ∩ closure (M n z) ⊆ M n z := by
    rintro n z x ⟨xs, hx⟩
    refine ⟨xs, fun y hy => ?_⟩
    obtain ⟨a, aM, a_lim⟩ : ∃ a : ℕ → E, (∀ k, a k ∈ M n z) ∧ Tendsto a atTop (𝓝 x) :=
      mem_closure_iff_seq_limit.1 hx
    have L1 :
      Tendsto (fun k : ℕ => ‖f y - f (a k) - (f' z) (y - a k)‖) atTop
        (𝓝 ‖f y - f x - (f' z) (y - x)‖) := by
      apply Tendsto.norm
      have L : Tendsto (fun k => f (a k)) atTop (𝓝 (f x)) := by
        apply (hf' x xs).continuousWithinAt.tendsto.comp
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim
        exact eventually_of_forall fun k => (aM k).1
      apply Tendsto.sub (tendsto_const_nhds.sub L)
      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)
    have L2 : Tendsto (fun k : ℕ => (r (f' z) : ℝ) * ‖y - a k‖) atTop (𝓝 (r (f' z) * ‖y - x‖)) :=
      (tendsto_const_nhds.sub a_lim).norm.const_mul _
    have I : ∀ᶠ k in atTop, ‖f y - f (a k) - (f' z) (y - a k)‖ ≤ r (f' z) * ‖y - a k‖ := by
      have L : Tendsto (fun k => dist y (a k)) atTop (𝓝 (dist y x)) :=
        tendsto_const_nhds.dist a_lim
      filter_upwards [(tendsto_order.1 L).2 _ hy.2]
      intro k hk
      exact (aM k).2 y ⟨hy.1, hk⟩
    exact le_of_tendsto_of_tendsto L1 L2 I
  rcases TopologicalSpace.exists_dense_seq E with ⟨d, hd⟩
  let K : ℕ → T → ℕ → Set E := fun n z p => closure (M n z) ∩ closedBall (d p) (u n / 3)
  have K_approx : ∀ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s ∩ K n z p) (r (f' z)) := by
    intro n z p x hx y hy
    have yM : y ∈ M n z := closure_M_subset _ _ ⟨hy.1, hy.2.1⟩
    refine yM.2 _ ⟨hx.1, ?_⟩
    calc
      dist x y ≤ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _
      _ ≤ u n / 3 + u n / 3 := add_le_add hx.2.2 hy.2.2
      _ < u n := by linarith [u_pos n]
  have K_closed : ∀ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>
    isClosed_closure.inter isClosed_ball
  obtain ⟨F, hF⟩ : ∃ F : ℕ → ℕ × T × ℕ, Function.Surjective F := by
    haveI : Encodable T := T_count.toEncodable
    have : Nonempty T := by
      rcases hs with ⟨x, xs⟩
      rcases s_subset x xs with ⟨n, z, _⟩
      exact ⟨z⟩
    inhabit ↥T
    exact ⟨_, Encodable.surjective_decode_iget (ℕ × T × ℕ)⟩
  refine
    ⟨fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,
      fun x xs => ?_, fun q => K_approx _ _ _, fun _ q => ⟨(F q).2.1, (F q).2.1.1.2, rfl⟩⟩
  obtain ⟨n, z, hnz⟩ : ∃ (n : ℕ) (z : T), x ∈ M n z := s_subset x xs
  obtain ⟨p, hp⟩ : ∃ p : ℕ, x ∈ closedBall (d p) (u n / 3) := by
    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]
    obtain ⟨p, hp⟩ : ∃ p : ℕ, d p ∈ ball x (u n / 3) := hd.exists_mem_open isOpen_ball this
    exact ⟨p, (mem_ball'.1 hp).le⟩
  obtain ⟨q, hq⟩ : ∃ q, F q = (n, z, p) := hF _
  apply mem_iUnion.2 ⟨q, _⟩
  simp (config := { zeta := false }) only [K, hq, mem_inter_iff, hp, and_true]
  exact subset_closure hnz


Verifying proof (Commit ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---126/200---
For theorem MeasureTheory.aemeasurable_fderivWithin in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem aemeasurable_fderivWithin (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (μ.restrict s) 


Original valid proof:
:= by
  refine aemeasurable_of_unif_approx fun ε εpos => ?_
  let δ : ℝ≥0 := ⟨ε, le_of_lt εpos⟩
  have δpos : 0 < δ := εpos
  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, _⟩ :
    ∃ (t : ℕ → Set E) (A : ℕ → E →L[ℝ] E),
      Pairwise (Disjoint on t) ∧
        (∀ n : ℕ, MeasurableSet (t n)) ∧
          (s ⊆ ⋃ n : ℕ, t n) ∧
            (∀ n : ℕ, ApproximatesLinearOn f (A n) (s ∩ t n) δ) ∧
              (s.Nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => δ) fun _ =>
      δpos.ne'
  obtain ⟨g, g_meas, hg⟩ :
      ∃ g : E → E →L[ℝ] E, Measurable g ∧ ∀ (n : ℕ) (x : E), x ∈ t n → g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ⟨g, g_meas.aemeasurable, ?_⟩
  suffices H : ∀ᵐ x : E ∂sum fun n ↦ μ.restrict (s ∩ t n), dist (g x) (f' x) ≤ ε by
    have : μ.restrict s ≤ sum fun n => μ.restrict (s ∩ t n) := by
      have : s = ⋃ n, s ∩ t n := by
        rw [← inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E₁ : ∀ᵐ x : E ∂μ.restrict (s ∩ t n), ‖f' x - A n‖₊ ≤ δ :=
    (ht n).norm_fderiv_sub_le μ (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E₂ : ∀ᵐ x : E ∂μ.restrict (s ∩ t n), g x = A n := by
    suffices H : ∀ᵐ x : E ∂μ.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E₁, E₂] with x hx1 hx2
  rw [← nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---127/200---
For theorem MeasureTheory.aemeasurable_fderivWithin in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem aemeasurable_fderivWithin (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (μ.restrict s) 


Original valid proof:
:= by
  refine aemeasurable_of_unif_approx fun ε εpos => ?_
  let δ : ℝ≥0 := ⟨ε, le_of_lt εpos⟩
  have δpos : 0 < δ := εpos
  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, _⟩ :
    ∃ (t : ℕ → Set E) (A : ℕ → E →L[ℝ] E),
      Pairwise (Disjoint on t) ∧
        (∀ n : ℕ, MeasurableSet (t n)) ∧
          (s ⊆ ⋃ n : ℕ, t n) ∧
            (∀ n : ℕ, ApproximatesLinearOn f (A n) (s ∩ t n) δ) ∧
              (s.Nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => δ) fun _ =>
      δpos.ne'
  obtain ⟨g, g_meas, hg⟩ :
      ∃ g : E → E →L[ℝ] E, Measurable g ∧ ∀ (n : ℕ) (x : E), x ∈ t n → g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine ⟨g, g_meas.aemeasurable, ?_⟩
  suffices H : ∀ᵐ x : E ∂sum fun n ↦ μ.restrict (s ∩ t n), dist (g x) (f' x) ≤ ε by
    have : μ.restrict s ≤ sum fun n => μ.restrict (s ∩ t n) := by
      have : s = ⋃ n, s ∩ t n := by
        rw [← inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have E₁ : ∀ᵐ x : E ∂μ.restrict (s ∩ t n), ‖f' x - A n‖₊ ≤ δ :=
    (ht n).norm_fderiv_sub_le μ (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have E₂ : ∀ᵐ x : E ∂μ.restrict (s ∩ t n), g x = A n := by
    suffices H : ∀ᵐ x : E ∂μ.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [E₁, E₂] with x hx1 hx2
  rw [← nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---128/200---
For theorem MeasureTheory.mul_le_addHaar_image_of_lt_det in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem mul_le_addHaar_image_of_lt_det (A : E →L[ℝ] E) {m : ℝ≥0}
    (hm : (m : ℝ≥0∞) < ENNReal.ofReal |A.det|) :
    ∀ᶠ δ in 𝓝[>] (0 : ℝ≥0),
      ∀ (s : Set E) (f : E → E), ApproximatesLinearOn f A s δ → (m : ℝ≥0∞) * μ s ≤ μ (f '' s) 


Original valid proof:
:= by
  apply nhdsWithin_le_nhds
  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)
  · filter_upwards
    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]
  have hA : A.det ≠ 0 := by
    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm
  let B := A.toContinuousLinearEquivOfDetNeZero hA
  have I : ENNReal.ofReal |(B.symm : E →L[ℝ] E).det| < (m⁻¹ : ℝ≥0) := by
    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,
      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm ⊢
    exact NNReal.inv_lt_inv mpos.ne' hm
  obtain ⟨δ₀, δ₀pos, hδ₀⟩ :
    ∃ δ : ℝ≥0,
      0 < δ ∧
        ∀ (t : Set E) (g : E → E),
          ApproximatesLinearOn g (B.symm : E →L[ℝ] E) t δ → μ (g '' t) ≤ ↑m⁻¹ * μ t := by
    have :
      ∀ᶠ δ : ℝ≥0 in 𝓝[>] 0,
        ∀ (t : Set E) (g : E → E),
          ApproximatesLinearOn g (B.symm : E →L[ℝ] E) t δ → μ (g '' t) ≤ ↑m⁻¹ * μ t :=
      addHaar_image_le_mul_of_det_lt μ B.symm I
    rcases (this.and self_mem_nhdsWithin).exists with ⟨δ₀, h, h'⟩
    exact ⟨δ₀, h', h⟩
  have L1 : ∀ᶠ δ in 𝓝 (0 : ℝ≥0), Subsingleton E ∨ δ < ‖(B.symm : E →L[ℝ] E)‖₊⁻¹ := by
    by_cases h : Subsingleton E
    · simp only [h, true_or_iff, eventually_const]
    simp only [h, false_or_iff]
    apply Iio_mem_nhds
    simpa only [h, false_or_iff, inv_pos] using B.subsingleton_or_nnnorm_symm_pos
  have L2 :
    ∀ᶠ δ in 𝓝 (0 : ℝ≥0), ‖(B.symm : E →L[ℝ] E)‖₊ * (‖(B.symm : E →L[ℝ] E)‖₊⁻¹ - δ)⁻¹ * δ < δ₀ := by
    have :
      Tendsto (fun δ => ‖(B.symm : E →L[ℝ] E)‖₊ * (‖(B.symm : E →L[ℝ] E)‖₊⁻¹ - δ)⁻¹ * δ) (𝓝 0)
        (𝓝 (‖(B.symm : E →L[ℝ] E)‖₊ * (‖(B.symm : E →L[ℝ] E)‖₊⁻¹ - 0)⁻¹ * 0)) := by
      rcases eq_or_ne ‖(B.symm : E →L[ℝ] E)‖₊ 0 with (H | H)
      · simpa only [H, zero_mul] using tendsto_const_nhds
      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id
      refine (Tendsto.sub tendsto_const_nhds tendsto_id).inv₀ ?_
      simpa only [tsub_zero, inv_eq_zero, Ne] using H
    simp only [mul_zero] at this
    exact (tendsto_order.1 this).2 δ₀ δ₀pos
  filter_upwards [L1, L2]
  intro δ h1δ h2δ s f hf
  have hf' : ApproximatesLinearOn f (B : E →L[ℝ] E) s δ := by convert hf
  let F := hf'.toPartialEquiv h1δ
  suffices H : μ (F.symm '' F.target) ≤ (m⁻¹ : ℝ≥0) * μ F.target by
    change (m : ℝ≥0∞) * μ F.source ≤ μ F.target
    rwa [← F.symm_image_target_eq_source, mul_comm, ← ENNReal.le_div_iff_mul_le, div_eq_mul_inv,
      mul_comm, ← ENNReal.coe_inv mpos.ne']
    · apply Or.inl
      simpa only [ENNReal.coe_eq_zero, Ne] using mpos.ne'
    · simp only [ENNReal.coe_ne_top, true_or_iff, Ne, not_false_iff]
  exact hδ₀ _ _ ((hf'.to_inv h1δ).mono_num h2δ.le)


Verifying proof (Commit 60e2ebb714fa61b2422f9c1cd4cff5fd09169c21):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean - 2024-09-07 22:35:13.904664.
---129/200---
For theorem MeasureTheory.ae_bdd_liminf_atTop_of_snorm_bdd in Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean:
theorem ae_bdd_liminf_atTop_of_snorm_bdd {p : ℝ≥0∞} (hp : p ≠ 0) {f : ℕ → α → E}
    (hfmeas : ∀ n, Measurable (f n)) (hbdd : ∀ n, snorm (f n) p μ ≤ R) :
    ∀ᵐ x ∂μ, liminf (fun n => (‖f n x‖₊ : ℝ≥0∞)) atTop < ∞ 


Original valid proof:
:= by
  by_cases hp' : p = ∞
  · subst hp'
    simp_rw [snorm_exponent_top] at hbdd
    have : ∀ n, ∀ᵐ x ∂μ, (‖f n x‖₊ : ℝ≥0∞) < R + 1 := fun n =>
      ae_lt_of_essSup_lt
        (lt_of_le_of_lt (hbdd n) <| ENNReal.lt_add_right ENNReal.coe_ne_top one_ne_zero)
    rw [← ae_all_iff] at this
    filter_upwards [this] with x hx using lt_of_le_of_lt
        (liminf_le_of_frequently_le' <| frequently_of_forall fun n => (hx n).le)
        (ENNReal.add_lt_top.2 ⟨ENNReal.coe_lt_top, ENNReal.one_lt_top⟩)
  filter_upwards [ae_bdd_liminf_atTop_rpow_of_snorm_bdd hfmeas hbdd] with x hx
  have hppos : 0 < p.toReal := ENNReal.toReal_pos hp hp'
  have :
    liminf (fun n => (‖f n x‖₊ : ℝ≥0∞) ^ p.toReal) atTop =
      liminf (fun n => (‖f n x‖₊ : ℝ≥0∞)) atTop ^ p.toReal := by
    change
      liminf (fun n => ENNReal.orderIsoRpow p.toReal hppos (‖f n x‖₊ : ℝ≥0∞)) atTop =
        ENNReal.orderIsoRpow p.toReal hppos (liminf (fun n => (‖f n x‖₊ : ℝ≥0∞)) atTop)
    refine (OrderIso.liminf_apply (ENNReal.orderIsoRpow p.toReal _) ?_ ?_ ?_ ?_).symm <;>
      isBoundedDefault
  rw [this] at hx
  rw [← ENNReal.rpow_one (liminf (fun n => ‖f n x‖₊) atTop), ← mul_inv_cancel hppos.ne.symm,
    ENNReal.rpow_mul]
  exact ENNReal.rpow_lt_top_of_nonneg (inv_nonneg.2 hppos.le) hx.ne


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean - 2024-09-07 22:35:25.236601.
---130/200---
For theorem aestronglyMeasurable_of_tendsto_ae in Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean:
theorem _root_.aestronglyMeasurable_of_tendsto_ae {ι : Type*} [PseudoMetrizableSpace β]
    (u : Filter ι) [NeBot u] [IsCountablyGenerated u] {f : ι → α → β} {g : α → β}
    (hf : ∀ i, AEStronglyMeasurable (f i) μ) (lim : ∀ᵐ x ∂μ, Tendsto (fun n => f n x) u (𝓝 (g x))) :
    AEStronglyMeasurable g μ 


Original valid proof:
:= by
  borelize β
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 ⟨?_, ?_⟩
  · exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  · rcases u.exists_seq_tendsto with ⟨v, hv⟩
    have : ∀ n : ℕ, ∃ t : Set β, IsSeparable t ∧ f (v n) ⁻¹' t ∈ ae μ := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ⟨closure (⋃ i, t i), .closure <| .iUnion t_sep, ?_⟩
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)


Verifying proof (Commit dad539b67d42acd98d4662387f437158d796aa3d):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---131/200---
For theorem aestronglyMeasurable_of_tendsto_ae in Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean:
theorem _root_.aestronglyMeasurable_of_tendsto_ae {ι : Type*} [PseudoMetrizableSpace β]
    (u : Filter ι) [NeBot u] [IsCountablyGenerated u] {f : ι → α → β} {g : α → β}
    (hf : ∀ i, AEStronglyMeasurable (f i) μ) (lim : ∀ᵐ x ∂μ, Tendsto (fun n => f n x) u (𝓝 (g x))) :
    AEStronglyMeasurable g μ 


Original valid proof:
:= by
  borelize β
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 ⟨?_, ?_⟩
  · exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  · rcases u.exists_seq_tendsto with ⟨v, hv⟩
    have : ∀ n : ℕ, ∃ t : Set β, IsSeparable t ∧ f (v n) ⁻¹' t ∈ ae μ := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine ⟨closure (⋃ i, t i), .closure <| .iUnion t_sep, ?_⟩
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)


Verifying proof (Commit 9745238e7313857e6c78443c861f5654ea43d4a5):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/MeasureTheory/Function/UniformIntegrable.lean - 2024-09-07 22:35:47.967433.
---132/200---
For theorem MeasureTheory.tendstoInMeasure_iff_tendsto_Lp in Mathlib/MeasureTheory/Function/UniformIntegrable.lean:
theorem tendstoInMeasure_iff_tendsto_Lp [IsFiniteMeasure μ] (hp : 1 ≤ p) (hp' : p ≠ ∞)
    (hf : ∀ n, Memℒp (f n) p μ) (hg : Memℒp g p μ) :
    TendstoInMeasure μ f atTop g ∧ UnifIntegrable f p μ ↔
      Tendsto (fun n => snorm (f n - g) p μ) atTop (𝓝 0) 


Original valid proof:
:=
  ⟨fun h => tendsto_Lp_of_tendstoInMeasure hp hp' (fun n => (hf n).1) hg h.2 h.1, fun h =>
    ⟨tendstoInMeasure_of_tendsto_snorm (lt_of_lt_of_le zero_lt_one hp).ne.symm
        (fun n => (hf n).aestronglyMeasurable) hg.aestronglyMeasurable h,
      unifIntegrable_of_tendsto_Lp hp hp' hf hg h⟩⟩


Verifying proof (Commit ff33d25c791a3fac407c782b49018fcb63700d0d):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/Bochner.lean - 2024-09-07 22:35:59.555748.
---133/200---
For theorem MeasureTheory.ae_eq_trim_of_stronglyMeasurable in Mathlib/MeasureTheory/Integral/Bochner.lean:
theorem ae_eq_trim_of_stronglyMeasurable [TopologicalSpace γ] [MetrizableSpace γ] (hm : m ≤ m0)
    {f g : β → γ} (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g)
    (hfg : f =ᵐ[μ] g) : f =ᵐ[μ.trim hm] g 


Original valid proof:
:= by
  rwa [EventuallyEq, ae_iff, trim_measurableSet_eq hm]
  exact (hf.measurableSet_eq_fun hg).compl


Verifying proof (Commit 5c3b19457914190f5f82a4845a908a6fa667ed79):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    simp only [Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.co

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/Lebesgue.lean - 2024-09-07 22:36:27.730438.
---134/200---
For theorem MeasureTheory.lintegral_liminf_le' in Mathlib/MeasureTheory/Integral/Lebesgue.lean:
theorem lintegral_liminf_le' {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, AEMeasurable (f n) μ) :
    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ ≤ liminf (fun n => ∫⁻ a, f n a ∂μ) atTop 


Original valid proof:
:=
  calc
    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ = ∫⁻ a, ⨆ n : ℕ, ⨅ i ≥ n, f i a ∂μ := by
      simp only [liminf_eq_iSup_iInf_of_nat]
    _ = ⨆ n : ℕ, ∫⁻ a, ⨅ i ≥ n, f i a ∂μ :=
      (lintegral_iSup' (fun n => aemeasurable_biInf _ (to_countable _) (fun i _ ↦ h_meas i))
        (ae_of_all μ fun a n m hnm => iInf_le_iInf_of_subset fun i hi => le_trans hnm hi))
    _ ≤ ⨆ n : ℕ, ⨅ i ≥ n, ∫⁻ a, f i a ∂μ := iSup_mono fun n => le_iInf₂_lintegral _
    _ = atTop.liminf fun n => ∫⁻ a, f n a ∂μ := Filter.liminf_eq_iSup_iInf_of_nat.symm


Verifying proof (Commit 3f9dee6adf287742f66dfda5079840cb2497af69):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---135/200---
For theorem MeasureTheory.lintegral_add_mul_meas_add_le_le_lintegral in Mathlib/MeasureTheory/Integral/Lebesgue.lean:
theorem lintegral_add_mul_meas_add_le_le_lintegral {f g : α → ℝ≥0∞} (hle : f ≤ᵐ[μ] g)
    (hg : AEMeasurable g μ) (ε : ℝ≥0∞) :
    ∫⁻ a, f a ∂μ + ε * μ { x | f x + ε ≤ g x } ≤ ∫⁻ a, g a ∂μ 


Original valid proof:
:= by
  rcases exists_measurable_le_lintegral_eq μ f with ⟨φ, hφm, hφ_le, hφ_eq⟩
  calc
    ∫⁻ x, f x ∂μ + ε * μ { x | f x + ε ≤ g x } = ∫⁻ x, φ x ∂μ + ε * μ { x | f x + ε ≤ g x } := by
      rw [hφ_eq]
    _ ≤ ∫⁻ x, φ x ∂μ + ε * μ { x | φ x + ε ≤ g x } := by
      gcongr
      exact fun x => (add_le_add_right (hφ_le _) _).trans
    _ = ∫⁻ x, φ x + indicator { x | φ x + ε ≤ g x } (fun _ => ε) x ∂μ := by
      rw [lintegral_add_left hφm, lintegral_indicator₀, setLIntegral_const]
      exact measurableSet_le (hφm.nullMeasurable.measurable'.add_const _) hg.nullMeasurable
    _ ≤ ∫⁻ x, g x ∂μ := lintegral_mono_ae (hle.mono fun x hx₁ => ?_)
  simp only [indicator_apply]; split_ifs with hx₂
  exacts [hx₂, (add_zero _).trans_le <| (hφ_le x).trans hx₁]


Verifying proof (Commit c5594244d6b6e5e0c0a479a4501c34b0ea194fce):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/GiryMonad.lean - 2024-09-07 22:36:55.338167.
---136/200---
For theorem MeasureTheory.Measure.bind_bind in Mathlib/MeasureTheory/Measure/GiryMonad.lean:
theorem bind_bind {γ} [MeasurableSpace γ] {m : Measure α} {f : α → Measure β} {g : β → Measure γ}
    (hf : Measurable f) (hg : Measurable g) : bind (bind m f) g = bind m fun a => bind (f a) g 


Original valid proof:
:= by
  ext1 s hs
  erw [bind_apply hs hg, bind_apply hs ((measurable_bind' hg).comp hf),
    lintegral_bind hf ((measurable_coe hs).comp hg)]
  conv_rhs => enter [2, a]; erw [bind_apply hs hg]
  rfl


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Hausdorff.lean - 2024-09-07 22:37:02.405165.
---137/200---
For theorem MeasureTheory.OuterMeasure.mkMetric_mono_smul in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem mkMetric_mono_smul {m₁ m₂ : ℝ≥0∞ → ℝ≥0∞} {c : ℝ≥0∞} (hc : c ≠ ∞) (h0 : c ≠ 0)
    (hle : m₁ ≤ᶠ[𝓝[≥] 0] c • m₂) : (mkMetric m₁ : OuterMeasure X) ≤ c • mkMetric m₂ 


Original valid proof:
:= by
  classical
  rcases (mem_nhdsWithin_Ici_iff_exists_Ico_subset' zero_lt_one).1 hle with ⟨r, hr0, hr⟩
  refine fun s =>
    le_of_tendsto_of_tendsto (mkMetric'.tendsto_pre _ s)
      (ENNReal.Tendsto.const_mul (mkMetric'.tendsto_pre _ s) (Or.inr hc))
      (mem_of_superset (Ioo_mem_nhdsWithin_Ioi ⟨le_rfl, hr0⟩) fun r' hr' => ?_)
  simp only [mem_setOf_eq, mkMetric'.pre, RingHom.id_apply]
  rw [← smul_eq_mul, ← smul_apply, smul_boundedBy hc]
  refine le_boundedBy.2 (fun t => (boundedBy_le _).trans ?_) _
  simp only [smul_eq_mul, Pi.smul_apply, extend, iInf_eq_if]
  split_ifs with ht
  · apply hr
    exact ⟨zero_le _, ht.trans_lt hr'.2⟩
  · simp [h0]


Verifying proof (Commit ced4d3c0af763b9fd00166e49cf999cf46c891cc):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean - 2024-09-07 22:37:15.803699.
---138/200---
For theorem MeasureTheory.Measure.addHaar_affineSubspace in Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean:
theorem addHaar_affineSubspace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [MeasurableSpace E] [BorelSpace E] [FiniteDimensional ℝ E] (μ : Measure E) [IsAddHaarMeasure μ]
    (s : AffineSubspace ℝ E) (hs : s ≠ ⊤) : μ s = 0 


Original valid proof:
:= by
  rcases s.eq_bot_or_nonempty with (rfl | hne)
  · rw [AffineSubspace.bot_coe, measure_empty]
  rw [Ne, ← AffineSubspace.direction_eq_top_iff_of_nonempty hne] at hs
  rcases hne with ⟨x, hx : x ∈ s⟩
  simpa only [AffineSubspace.coe_direction_eq_vsub_set_right hx, vsub_eq_sub, sub_eq_add_neg,
    image_add_right, neg_neg, measure_preimage_add_right] using addHaar_submodule μ s.direction hs


Verifying proof (Commit 63aaa8cc21050b7a5cb193c6764569918728723b):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/Finite.lean - 2024-09-07 22:37:32.623183.
---139/200---
For theorem ClassGroup.norm_le in Mathlib/NumberTheory/ClassNumber/Finite.lean:
theorem norm_le (a : S) {y : ℤ} (hy : ∀ k, abv (bS.repr a k) ≤ y) :
    abv (Algebra.norm R a) ≤ normBound abv bS * y ^ Fintype.card ι 


Original valid proof:
:= by
  conv_lhs => rw [← bS.sum_repr a]
  rw [Algebra.norm_apply, ← LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ← mul_pow]
  convert Matrix.det_sum_smul_le Finset.univ _ hy using 3
  · rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  · intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ⟨⟨i, j, k⟩, Finset.mem_univ _, rfl⟩


Verifying proof (Commit 690644e30cc42cb5564cbbb1a59a5f2ca1df1bf5):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

Working on Mathlib/NumberTheory/DiophantineApproximation.lean - 2024-09-07 22:37:48.334409.
---140/200---
For theorem Real.exists_rat_eq_convergent' in Mathlib/NumberTheory/DiophantineApproximation.lean:
theorem exists_rat_eq_convergent' {v : ℕ} (h' : ContfracLegendre.Ass ξ u v) :
    ∃ n, (u / v : ℚ) = ξ.convergent n 


Original valid proof:
:= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing ξ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  · replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg ξ).trans_lt h)
  · rw [Nat.cast_one, div_one]
    obtain ⟨_, h₁, h₂⟩ := h
    rcases le_or_lt (u : ℝ) ξ with ht | ht
    · use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h₂).2) <;> norm_num
    · replace h₁ := lt_sub_iff_add_lt'.mp (h₁ rfl)
      have hξ₁ : ⌊ξ⌋ = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ⟨(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h₁).le, ht⟩
      rcases eq_or_ne ξ ⌊ξ⌋ with Hξ | Hξ
      · rw [Hξ, hξ₁, cast_sub, cast_one, ← sub_eq_add_neg, sub_lt_sub_iff_left] at h₁
        exact False.elim (lt_irrefl _ <| h₁.trans one_half_lt_one)
      · have hξ₂ : ⌊(fract ξ)⁻¹⌋ = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr Hξ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr Hξ) zero_lt_two]
          refine ⟨(fract_lt_one ξ).le, ?_⟩
          rw [fract, hξ₁, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h₁ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hξ₁, hξ₂, cast_sub, cast_one]
  · obtain ⟨huv₀, huv₁⟩ := aux₂ (Nat.cast_le.mpr ht) h
    have Hv : (v : ℚ) ≠ 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv₁' : (u - ⌊ξ⌋ * v).toNat < v := by zify; rwa [toNat_of_nonneg huv₀.le]
    have inv : ContfracLegendre.Ass (fract ξ)⁻¹ v (u - ⌊ξ⌋ * ↑v).toNat :=
      (toNat_of_nonneg huv₀.le).symm ▸ invariant (Nat.cast_le.mpr ht) h
    obtain ⟨n, hn⟩ := ih (u - ⌊ξ⌋ * v).toNat huv₁' inv
    use n + 1
    rw [convergent_succ, ← hn,
      (mod_cast toNat_of_nonneg huv₀.le : ((u - ⌊ξ⌋ * v).toNat : ℚ) = u - ⌊ξ⌋ * v),
      cast_natCast, inv_div, sub_div, mul_div_cancel_right₀ _ Hv, add_sub_cancel]


Verifying proof (Commit 457e481f5e9c0969401919077d4f5efc34fed55d):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

---141/200---
For theorem Rat.den_le_and_le_num_le_of_sub_lt_one_div_den_sq in Mathlib/NumberTheory/DiophantineApproximation.lean:
theorem den_le_and_le_num_le_of_sub_lt_one_div_den_sq {ξ q : ℚ}
    (h : |ξ - q| < 1 / (q.den : ℚ) ^ 2) :
    q.den ≤ ξ.den ∧ ⌈ξ * q.den⌉ - 1 ≤ q.num ∧ q.num ≤ ⌊ξ * q.den⌋ + 1 


Original valid proof:
:= by
  have hq₀ : (0 : ℚ) < q.den := Nat.cast_pos.mpr q.pos
  replace h : |ξ * q.den - q.num| < 1 / q.den := by
    rw [← mul_lt_mul_right hq₀] at h
    conv_lhs at h => rw [← abs_of_pos hq₀, ← abs_mul, sub_mul, mul_den_eq_num]
    rwa [sq, div_mul, mul_div_cancel_left₀ _ hq₀.ne'] at h
  constructor
  · rcases eq_or_ne ξ q with (rfl | H)
    · exact le_rfl
    · have hξ₀ : (0 : ℚ) < ξ.den := Nat.cast_pos.mpr ξ.pos
      rw [← Rat.num_div_den ξ, div_mul_eq_mul_div, div_sub' _ _ _ hξ₀.ne', abs_div, abs_of_pos hξ₀,
        div_lt_iff hξ₀, div_mul_comm, mul_one] at h
      refine Nat.cast_le.mp ((one_lt_div hq₀).mp <| lt_of_le_of_lt ?_ h).le
      norm_cast
      rw [mul_comm _ q.num]
      exact Int.one_le_abs (sub_ne_zero_of_ne <| mt Rat.eq_iff_mul_eq_mul.mpr H)
  · obtain ⟨h₁, h₂⟩ :=
      abs_sub_lt_iff.mp
        (h.trans_le <|
          (one_div_le zero_lt_one hq₀).mp <| (@one_div_one ℚ _).symm ▸ Nat.cast_le.mpr q.pos)
    rw [sub_lt_iff_lt_add, add_comm] at h₁ h₂
    rw [← sub_lt_iff_lt_add] at h₂
    norm_cast at h₁ h₂
    exact
      ⟨sub_le_iff_le_add.mpr (Int.ceil_le.mpr h₁.le), sub_le_iff_le_add.mp (Int.le_floor.mpr h₂.le)⟩


Verifying proof (Commit 457e481f5e9c0969401919077d4f5efc34fed55d):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/NumberTheory/DirichletCharacter/Basic.lean - 2024-09-07 22:38:08.963330.
---142/200---
For theorem DirichletCharacter.even_or_odd in Mathlib/NumberTheory/DirichletCharacter/Basic.lean:
lemma even_or_odd [NoZeroDivisors S] : ψ.Even ∨ ψ.Odd 


Original valid proof:
:= by
  suffices ψ (-1) ^ 2 = 1 by convert sq_eq_one_iff.mp this
  rw [← map_pow _, neg_one_sq, map_one]


Verifying proof (Commit 820f97a377780dd93a62e169ef9f405c7ae8d3d0):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finse

Attempt failure.

Working on Mathlib/NumberTheory/FermatPsp.lean - 2024-09-07 22:38:16.137225.
---143/200---
For theorem Nat.exists_infinite_pseudoprimes in Mathlib/NumberTheory/FermatPsp.lean:
theorem exists_infinite_pseudoprimes {b : ℕ} (h : 1 ≤ b) (m : ℕ) :
    ∃ n : ℕ, FermatPsp n b ∧ m ≤ n 


Original valid proof:
:= by
  by_cases b_ge_two : 2 ≤ b
  · have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hp₁ hp₂
    have h₁ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have h₂ : 4 ≤ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have h₃ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt h₂ (by norm_num))
    have h₄ : 0 < b * (b ^ 2 - 1) := mul_pos h₁ h₃
    have h₅ : b * (b ^ 2 - 1) < p := by omega
    have h₆ : ¬p ∣ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt h₄ h₅
    have h₇ : b ≤ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ h₃
    have h₈ : 2 ≤ b * (b ^ 2 - 1) := le_trans b_ge_two h₇
    have h₉ : 2 < p := gt_of_gt_of_ge h₅ h₈
    have h₁₀ := psp_from_prime_gt_p b_ge_two hp₂ h₉
    use psp_from_prime b p
    constructor
    · exact psp_from_prime_psp b_ge_two hp₂ h₉ h₆
    · exact le_trans (show m ≤ p by omega) (le_of_lt h₁₀)
  · have h₁ : b = 1 := by omega
    rw [h₁]
    use 2 * (m + 2)
    have : ¬Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by omega) (by omega)
    exact ⟨fermatPsp_base_one (by omega) this, by omega⟩


Verifying proof (Commit 4ad46d4a6677dcfb96418e03062ff39837a061ae):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean - 2024-09-07 22:38:24.927725.
---144/200---
For theorem ZMod.Ico_map_valMinAbs_natAbs_eq_Ico_map_id in Mathlib/NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean:
theorem Ico_map_valMinAbs_natAbs_eq_Ico_map_id (p : ℕ) [hp : Fact p.Prime] (a : ZMod p)
    (hap : a ≠ 0) : ((Ico 1 (p / 2).succ).1.map fun (x : ℕ) => (a * x).valMinAbs.natAbs) =
    (Ico 1 (p / 2).succ).1.map fun a => a 


Original valid proof:
:= by
  have he : ∀ {x}, x ∈ Ico 1 (p / 2).succ → x ≠ 0 ∧ x ≤ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : ∀ {x}, x ∈ Ico 1 (p / 2).succ → x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : ∀ {x}, x ∈ Ico 1 (p / 2).succ → ¬p ∣ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : ∀ (x : ℕ) (hx : x ∈ Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs ∈ Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,
      pos_iff_ne_zero, natAbs_valMinAbs_le _]
  have hsurj : ∀ (b : ℕ) (hb : b ∈ Ico 1 (p / 2).succ),
      ∃ x, ∃ _ : x ∈ Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine ⟨(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ⟨?_, ?_⟩, ?_⟩
    · apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne, _root_.mul_eq_zero, or_self_iff]
    · apply lt_succ_of_le; apply natAbs_valMinAbs_le
    · rw [natCast_natAbs_valMinAbs]
      split_ifs
      · erw [mul_div_cancel₀ _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
      · erw [mul_neg, mul_div_cancel₀ _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,
          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)


Verifying proof (Commit aa86c765b1f9ce27899c6416c8a03f6ca3f86caa):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/NumberTheory/Modular.lean - 2024-09-07 22:38:35.457189.
---145/200---
For theorem ModularGroup.tendsto_normSq_coprime_pair in Mathlib/NumberTheory/Modular.lean:
theorem tendsto_normSq_coprime_pair :
    Filter.Tendsto (fun p : Fin 2 → ℤ => normSq ((p 0 : ℂ) * z + p 1)) cofinite atTop 


Original valid proof:
:= by
  letI : Module ℝ (Fin 2 → ℝ) := NormedSpace.toModule
  let π₀ : (Fin 2 → ℝ) →ₗ[ℝ] ℝ := LinearMap.proj 0
  let π₁ : (Fin 2 → ℝ) →ₗ[ℝ] ℝ := LinearMap.proj 1
  let f : (Fin 2 → ℝ) →ₗ[ℝ] ℂ := π₀.smulRight (z : ℂ) + π₁.smulRight 1
  have f_def : ⇑f = fun p : Fin 2 → ℝ => (p 0 : ℂ) * ↑z + p 1 := by
    ext1
    dsimp only [π₀, π₁, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 → ℤ => normSq ((p 0 : ℂ) * ↑z + ↑(p 1))) =
      normSq ∘ f ∘ fun p : Fin 2 → ℤ => ((↑) : ℤ → ℝ) ∘ p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_intCast, ofReal_intCast]
  rw [this]
  have hf : LinearMap.ker f = ⊥ := by
    let g : ℂ →ₗ[ℝ] Fin 2 → ℝ :=
      LinearMap.pi ![imLm, imLm.comp ((z : ℂ) • ((conjAe : ℂ →ₐ[ℝ] ℂ) : ℂ →ₗ[ℝ] ℂ))]
    suffices ((z : ℂ).im⁻¹ • g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : ℂ).im ≠ 0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    · show (z : ℂ).im⁻¹ * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    · show (z : ℂ).im⁻¹ * ((z : ℂ) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, ← ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul₀ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have h₂ : Tendsto (fun p : Fin 2 → ℤ => ((↑) : ℤ → ℝ) ∘ p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprodᵢ fun _ => Int.tendsto_coe_cofinite
    · rw [coprodᵢ_cofinite]
    · rw [coprodᵢ_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h₂)


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/NumberTheory/Padics/PadicVal.lean - 2024-09-07 22:38:48.309391.
---146/200---
For theorem padicValRat.le_padicValRat_add_of_le in Mathlib/NumberTheory/Padics/PadicVal.lean:
theorem le_padicValRat_add_of_le {q r : ℚ} (hqr : q + r ≠ 0)
    (h : padicValRat p q ≤ padicValRat p r) : padicValRat p q ≤ padicValRat p (q + r) 


Original valid proof:
:=
  if hq : q = 0 then by simpa [hq] using h
  else
    if hr : r = 0 then by simp [hr]
    else by
      have hqn : q.num ≠ 0 := Rat.num_ne_zero.2 hq
      have hqd : (q.den : ℤ) ≠ 0 := mod_cast Rat.den_nz _
      have hrn : r.num ≠ 0 := Rat.num_ne_zero.2 hr
      have hrd : (r.den : ℤ) ≠ 0 := mod_cast Rat.den_nz _
      have hqreq : q + r = (q.num * r.den + q.den * r.num) /. (q.den * r.den) := Rat.add_num_den _ _
      have hqrd : q.num * r.den + q.den * r.num ≠ 0 := Rat.mk_num_ne_zero_of_ne_zero hqr hqreq
      conv_lhs => rw [← q.num_divInt_den]
      rw [hqreq, padicValRat_le_padicValRat_iff hqn hqrd hqd (mul_ne_zero hqd hrd), ←
        multiplicity_le_multiplicity_iff, mul_left_comm,
        multiplicity.mul (Nat.prime_iff_prime_int.1 hp.1), add_mul]
      rw [← q.num_divInt_den, ← r.num_divInt_den, padicValRat_le_padicValRat_iff hqn hrn hqd hrd, ←
        multiplicity_le_multiplicity_iff] at h
      calc
        _ ≤
            min (multiplicity (↑p) (q.num * r.den * q.den))
              (multiplicity (↑p) (↑q.den * r.num * ↑q.den)) :=
          le_min
            (by rw [@multiplicity.mul _ _ _ _ (_ * _) _ (Nat.prime_iff_prime_int.1 hp.1), add_comm])
            (by
              rw [mul_assoc,
                  @multiplicity.mul _ _ _ _ (q.den : ℤ) (_ * _)
                    (Nat.prime_iff_prime_int.1 hp.1)]
              exact add_le_add_left h _)
        _ ≤ _ := min_le_multiplicity_add


Verifying proof (Commit 6aa938732f4bd703b82127542018850f5874e784):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Order/Filter/Lift.lean - 2024-09-07 22:38:56.222248.
---147/200---
For theorem Filter.HasBasis.mem_lift_iff in Mathlib/Order/Filter/Lift.lean:
theorem HasBasis.mem_lift_iff {ι} {p : ι → Prop} {s : ι → Set α} {f : Filter α}
    (hf : f.HasBasis p s) {β : ι → Type*} {pg : ∀ i, β i → Prop} {sg : ∀ i, β i → Set γ}
    {g : Set α → Filter γ} (hg : ∀ i, (g <| s i).HasBasis (pg i) (sg i)) (gm : Monotone g)
    {s : Set γ} : s ∈ f.lift g ↔ ∃ i, p i ∧ ∃ x, pg i x ∧ sg i x ⊆ s 


Original valid proof:
:= by
  refine (mem_biInf_of_directed ?_ ⟨univ, univ_sets _⟩).trans ?_
  · intro t₁ ht₁ t₂ ht₂
    exact ⟨t₁ ∩ t₂, inter_mem ht₁ ht₂, gm inter_subset_left, gm inter_subset_right⟩
  · simp only [← (hg _).mem_iff]
    exact hf.exists_iff fun t₁ t₂ ht H => gm ht H


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Order/Heyting/Basic.lean - 2024-09-07 22:39:01.458887.
---148/200---
For theorem LE.le.disjoint_compl_right in Mathlib/Order/Heyting/Basic.lean:
theorem LE.le.disjoint_compl_right (h : a ≤ b) : Disjoint a bᶜ 


Original valid proof:
:=
  _root_.disjoint_compl_right.mono_left h


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.

Attempt failure.

Working on Mathlib/Order/MinMax.lean - 2024-09-07 22:39:07.597443.
---149/200---
For theorem min_cases in Mathlib/Order/MinMax.lean:
theorem min_cases (a b : α) : min a b = a ∧ a ≤ b ∨ min a b = b ∧ b < a 


Original valid proof:
:= by
  by_cases h : a ≤ b
  · left
    exact ⟨min_eq_left h, h⟩
  · right
    exact ⟨min_eq_right (le_of_lt (not_le.mp h)), not_le.mp h⟩


Verifying proof (Commit a9a1f7d7266a51942458f829f615d2f63c88c586):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Order/WithBot.lean - 2024-09-07 22:39:10.875725.
---150/200---
For theorem WithTop.coe_le_coe in Mathlib/Order/WithBot.lean:
theorem coe_le_coe : (a : WithBot α) ≤ b ↔ a ≤ b 


Original valid proof:
:= by
  simp [LE.le]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Probability/Cdf.lean - 2024-09-07 22:39:15.742393.
---151/200---
For theorem ProbabilityTheory.tendsto_cdf_atBot in Mathlib/Probability/Cdf.lean:
lemma tendsto_cdf_atBot : Tendsto (cdf μ) atBot (𝓝 0) 


Original valid proof:
:= tendsto_condCDF_atBot _ _


Verifying proof (Commit c4988d10a696972769fd676cb9977e896bf0a01b):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Probability/ConditionalProbability.lean - 2024-09-07 22:39:23.794260.
---152/200---
For theorem ProbabilityTheory.cond_cond_eq_cond_inter' in Mathlib/Probability/ConditionalProbability.lean:
lemma cond_cond_eq_cond_inter' (hms : MeasurableSet s) (hmt : MeasurableSet t) (hcs : μ s ≠ ∞) :
    μ[|s][|t] = μ[|s ∩ t] 


Original valid proof:
:= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (μ (s ∩ t)) 0
  · have : μ (s ∩ t ∩ u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [this, ← Set.inter_assoc]
  · have hcs' : μ s ≠ 0 :=
      (measure_pos_of_superset Set.inter_subset_left hst).ne'
    simp [*, ← mul_assoc, ← Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (μ s)⁻¹]


Verifying proof (Commit b0011bffcf8eff635640aae6c46f410c7fce1773):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---153/200---
For theorem ProbabilityTheory.cond_cond_eq_cond_inter' in Mathlib/Probability/ConditionalProbability.lean:
lemma cond_cond_eq_cond_inter' (hms : MeasurableSet s) (hmt : MeasurableSet t) (hcs : μ s ≠ ∞) :
    μ[|s][|t] = μ[|s ∩ t] 


Original valid proof:
:= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (μ (s ∩ t)) 0
  · have : μ (s ∩ t ∩ u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [this, ← Set.inter_assoc]
  · have hcs' : μ s ≠ 0 :=
      (measure_pos_of_superset Set.inter_subset_left hst).ne'
    simp [*, ← mul_assoc, ← Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (μ s)⁻¹]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Probability/Distributions/Gamma.lean - 2024-09-07 22:39:36.987376.
---154/200---
For theorem ProbabilityTheory.isProbabilityMeasureGamma in Mathlib/Probability/Distributions/Gamma.lean:
lemma isProbabilityMeasureGamma {a r : ℝ} (ha : 0 < a) (hr : 0 < r) :
    IsProbabilityMeasure (gammaMeasure a r) where



Original valid proof:
  measure_univ := by simp [gammaMeasure, lintegral_gammaPDF_eq_one ha hr]


Verifying proof (Commit 3d69118e33807ea8f6444d90463243ab546355c1):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Fi

Attempt failure.

Working on Mathlib/Probability/Distributions/Uniform.lean - 2024-09-07 22:39:50.311669.
---155/200---
For theorem PMF.uniformOfFintype_apply in Mathlib/Probability/Distributions/Uniform.lean:
theorem uniformOfFintype_apply (a : α) : uniformOfFintype α a = (Fintype.card α : ℝ≥0∞)⁻¹ 


Original valid proof:
:= by
  simp [uniformOfFintype, Finset.mem_univ, if_true, uniformOfFinset_apply]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_un

Attempt failure.

Working on Mathlib/Probability/Kernel/MeasurableIntegral.lean - 2024-09-07 22:40:00.448243.
---156/200---
For theorem Measurable.lintegral_kernel_prod_right in Mathlib/Probability/Kernel/MeasurableIntegral.lean:
theorem _root_.Measurable.lintegral_kernel_prod_right {f : α → β → ℝ≥0∞}
    (hf : Measurable (uncurry f)) : Measurable fun a => ∫⁻ b, f a b ∂κ a 


Original valid proof:
:= by
  let F : ℕ → SimpleFunc (α × β) ℝ≥0∞ := SimpleFunc.eapprox (uncurry f)
  have h : ∀ a, ⨆ n, F n a = uncurry f a := SimpleFunc.iSup_eapprox_apply (uncurry f) hf
  simp only [Prod.forall, uncurry_apply_pair] at h
  simp_rw [← h]
  have : ∀ a, (∫⁻ b, ⨆ n, F n (a, b) ∂κ a) = ⨆ n, ∫⁻ b, F n (a, b) ∂κ a := by
    intro a
    rw [lintegral_iSup]
    · exact fun n => (F n).measurable.comp measurable_prod_mk_left
    · exact fun i j hij b => SimpleFunc.monotone_eapprox (uncurry f) hij _
  simp_rw [this]
  refine measurable_iSup fun n => ?_
  refine SimpleFunc.induction
    (P := fun f => Measurable (fun (a : α) => ∫⁻ (b : β), f (a, b) ∂κ a)) ?_ ?_ (F n)
  · intro c t ht
    simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,
      SimpleFunc.coe_zero, Set.piecewise_eq_indicator]
    exact kernel.measurable_lintegral_indicator_const (κ := κ) ht c
  · intro g₁ g₂ _ hm₁ hm₂
    simp only [SimpleFunc.coe_add, Pi.add_apply]
    have h_add :
      (fun a => ∫⁻ b, g₁ (a, b) + g₂ (a, b) ∂κ a) =
        (fun a => ∫⁻ b, g₁ (a, b) ∂κ a) + fun a => ∫⁻ b, g₂ (a, b) ∂κ a := by
      ext1 a
      rw [Pi.add_apply]
      erw [lintegral_add_left (g₁.measurable.comp measurable_prod_mk_left)]
      simp_rw [Function.comp_apply]
    rw [h_add]
    exact Measurable.add hm₁ hm₂


Verifying proof (Commit e6f9a50e9b8db18b96255fd34e1d7e09072168a9):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/RingTheory/AdicCompletion/Functoriality.lean - 2024-09-07 22:40:09.184117.
---157/200---
For theorem AdicCompletion.sumInv_comp_sum in Mathlib/RingTheory/AdicCompletion/Functoriality.lean:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id 


Original valid proof:
:= by
  ext j x
  apply DirectSum.ext (AdicCompletion I R) (fun i ↦ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, map_mk, component_sumInv,
    mk_apply_coe, AdicCauchySequence.map_apply_coe, Submodule.mkQ_apply, LinearMap.id_comp]
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  · next h => subst h; simp
  · simp


Verifying proof (Commit 40d79d41004006c6e4f66c519a41ca9b41548378):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Factorization.lean - 2024-09-07 22:40:30.612253.
---158/200---
For theorem Ideal.finite_mulSupport_inv in Mathlib/RingTheory/DedekindDomain/Factorization.lean:
theorem finite_mulSupport_inv {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      (-((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ))).Finite 


Original valid proof:
:= by
  rw [mulSupport]
  simp_rw [zpow_neg, Ne, inv_eq_one]
  exact finite_mulSupport_coe hI


Verifying proof (Commit 04cf8c4630518d88c67bf9ba4d4db872ea86f7e2):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/FiniteAdeleRing.lean - 2024-09-07 22:40:40.152935.
---159/200---
For theorem DedekindDomain.ProdAdicCompletions.IsFiniteAdele.one in Mathlib/RingTheory/DedekindDomain/FiniteAdeleRing.lean:
theorem one : (1 : K_hat R K).IsFiniteAdele 


Original valid proof:
:= by
  rw [IsFiniteAdele, Filter.eventually_cofinite]
  have h_empty :
    {v : HeightOneSpectrum R | ¬(1 : v.adicCompletion K) ∈ v.adicCompletionIntegers K} = ∅ := by
    ext v; rw [mem_empty_iff_false, iff_false_iff]; intro hv
    rw [mem_setOf] at hv; apply hv; rw [mem_adicCompletionIntegers]
    exact le_of_eq Valued.v.map_one'
  convert finite_empty


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---160/200---
For theorem DedekindDomain.ProdAdicCompletions.IsFiniteAdele.one in Mathlib/RingTheory/DedekindDomain/FiniteAdeleRing.lean:
theorem one : (1 : K_hat R K).IsFiniteAdele 


Original valid proof:
:= by
  rw [IsFiniteAdele, Filter.eventually_cofinite]
  have h_empty :
    {v : HeightOneSpectrum R | ¬(1 : v.adicCompletion K) ∈ v.adicCompletionIntegers K} = ∅ := by
    ext v; rw [mem_empty_iff_false, iff_false_iff]; intro hv
    rw [mem_setOf] at hv; apply hv; rw [mem_adicCompletionIntegers]
    exact le_of_eq Valued.v.map_one'
  convert finite_empty


Verifying proof (Commit 39b465c300b32fbcfed8cc0269db25884e291c91):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

Attempt failure.

Working on Mathlib/RingTheory/FiniteType.lean - 2024-09-07 22:40:59.659816.
---161/200---
For theorem Algebra.FiniteType.iff_quotient_freeAlgebra in Mathlib/RingTheory/FiniteType.lean:
theorem iff_quotient_freeAlgebra :
    FiniteType R A ↔
      ∃ (s : Finset A) (f : FreeAlgebra R s →ₐ[R] A), Surjective f 


Original valid proof:
:= by
  constructor
  · rintro ⟨s, hs⟩
    refine ⟨s, FreeAlgebra.lift _ (↑), ?_⟩
    intro x
    have hrw : (↑s : Set A) = fun x : A => x ∈ s.val := rfl
    rw [← Set.mem_range, ← AlgHom.coe_range]
    erw [← adjoin_eq_range_freeAlgebra_lift, ← hrw, hs]
    exact Set.mem_univ x
  · rintro ⟨s, ⟨f, hsur⟩⟩
    exact FiniteType.of_surjective (FiniteType.freeAlgebra R s) f hsur


Verifying proof (Commit 19cfe36a7ab0262701db2043cd019a1861daadc8):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/RingTheory/Finiteness.lean - 2024-09-07 22:41:11.551807.
---162/200---
For theorem Submodule.fg_induction in Mathlib/RingTheory/Finiteness.lean:
theorem fg_induction (R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]
    (P : Submodule R M → Prop) (h₁ : ∀ x, P (Submodule.span R {x}))
    (h₂ : ∀ M₁ M₂, P M₁ → P M₂ → P (M₁ ⊔ M₂)) (N : Submodule R M) (hN : N.FG) : P N 


Original valid proof:
:= by
  classical
    obtain ⟨s, rfl⟩ := hN
    induction s using Finset.induction
    · rw [Finset.coe_empty, Submodule.span_empty, ← Submodule.span_zero_singleton]
      apply h₁
    · rw [Finset.coe_insert, Submodule.span_insert]
      apply h₂ <;> apply_assumption


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    · refine ⟨fun h => ?_, fun h => ?_⟩
      · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
        · refine ⟨fun h => ?_, fun h => ?_⟩
         · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h => ?_, fun h => ?_⟩
          · refine ⟨fun h

Attempt failure.

Working on Mathlib/RingTheory/Ideal/Basic.lean - 2024-09-07 22:41:21.394354.
---163/200---
For theorem Ideal.span_pow_eq_top in Mathlib/RingTheory/Ideal/Basic.lean:
theorem span_pow_eq_top (s : Set α) (hs : span s = ⊤) (n : ℕ) :
    span ((fun (x : α) => x ^ n) '' s) = ⊤ 


Original valid proof:
:= by
  rw [eq_top_iff_one]
  cases' n with n
  · obtain rfl | ⟨x, hx⟩ := eq_empty_or_nonempty s
    · rw [Set.image_empty, hs]
      trivial
    · exact subset_span ⟨_, hx, pow_zero _⟩
  rw [eq_top_iff_one, span, Finsupp.mem_span_iff_total] at hs
  rcases hs with ⟨f, hf⟩
  have hf : (f.support.sum fun a => f a * a) = 1 := hf 
  have := sum_pow_mem_span_pow f.support (fun a => f a * a) n
  rw [hf, one_pow] at this
  refine span_le.mpr ?_ this
  rintro _ hx
  simp_rw [Set.mem_image] at hx
  rcases hx with ⟨x, _, rfl⟩
  have : span ({(x:α) ^ (n + 1)} : Set α) ≤ span ((fun x : α => x ^ (n + 1)) '' s) := by
    rw [span_le, Set.singleton_subset_iff]
    exact subset_span ⟨x, x.prop, rfl⟩
  refine this ?_
  rw [mul_pow, mem_span_singleton]
  exact ⟨f x ^ (n + 1), mul_comm _ _⟩


Verifying proof (Commit a645d903a5e02e8cbb9215f6195147610bf99954):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finse

Attempt failure.

Working on Mathlib/RingTheory/Ideal/Norm.lean - 2024-09-07 22:41:28.344690.
---164/200---
For theorem Ideal.exists_mul_add_mem_pow_succ in Mathlib/RingTheory/Ideal/Norm.lean:
theorem Ideal.exists_mul_add_mem_pow_succ [IsDedekindDomain S] {i : ℕ} (a c : S) (a_mem : a ∈ P ^ i)
    (a_not_mem : a ∉ P ^ (i + 1)) (c_mem : c ∈ P ^ i) :
    ∃ d : S, ∃ e ∈ P ^ (i + 1), a * d + e = c 


Original valid proof:
:= by
  suffices eq_b : P ^ i = Ideal.span {a} ⊔ P ^ (i + 1) by
    rw [eq_b] at c_mem
    simp only [mul_comm a]
    exact Ideal.mem_span_singleton_sup.mp c_mem
  refine (Ideal.eq_prime_pow_of_succ_lt_of_le hP (lt_of_le_of_ne le_sup_right ?_)
    (sup_le (Ideal.span_le.mpr (Set.singleton_subset_iff.mpr a_mem))
      (Ideal.pow_succ_lt_pow hP i).le)).symm
  contrapose! a_not_mem with this
  rw [this]
  exact mem_sup.mpr ⟨a, mem_span_singleton_self a, 0, by simp, by simp⟩


Verifying proof (Commit d664a4757e1d5d6999ae3ca588b989e1039faee2):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finse

Attempt failure.

Working on Mathlib/RingTheory/Ideal/Operations.lean - 2024-09-07 22:41:41.235820.
---165/200---
For theorem Ideal.prod_eq_bot in Mathlib/RingTheory/Ideal/Operations.lean:
theorem prod_eq_bot {R : Type*} [CommRing R] [IsDomain R] {s : Multiset (Ideal R)} :
    s.prod = ⊥ ↔ ∃ I ∈ s, I = ⊥ 


Original valid proof:
:= by
  simp


Verifying proof (Commit cf251fadc95a820147ab6a516521a10d1dabd216):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finse

Attempt failure.

Working on Mathlib/RingTheory/IntegralDomain.lean - 2024-09-07 22:41:53.039023.
---166/200---
For theorem sum_hom_units in Mathlib/RingTheory/IntegralDomain.lean:
theorem sum_hom_units_eq_zero (f : G →* R) (hf : f ≠ 1) : ∑ g : G, f g = 0 


Original valid proof:
:= by
  classical
    obtain ⟨x, hx⟩ : ∃ x : MonoidHom.range f.toHomUnits,
        ∀ y : MonoidHom.range f.toHomUnits, y ∈ Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x ≠ 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ⟨f.toHomUnits g, g, rfl⟩ with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ≠ 0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ∑ g : G, f g = ∑ g : G, (f.toHomUnits g : R) := rfl
      _ = ∑ u ∈ univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card • (u : R) :=
        (sum_comp ((↑) : Rˣ → R) f.toHomUnits)
      _ = ∑ u ∈ univ.image f.toHomUnits, c • (u : R) :=
        (sum_congr rfl fun u hu => congr_arg₂ _ ?_ rfl)
      _ = ∑ b : MonoidHom.range f.toHomUnits, c • ((b : Rˣ) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c • ∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R) := smul_sum.symm
      _ = c • (0 : R) := congr_arg₂ _ rfl ?_
      _ = (0 : R) := smul_zero _
    · 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      · simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      · exact ⟨1, f.toHomUnits.map_one⟩
    show (∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R)) = 0
    calc
      (∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R))
        = ∑ n ∈ range (orderOf x), ((x : Rˣ) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ ·) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let ⟨n, hn⟩ := hx b
              ⟨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ⊢; rw [pow_mod_orderOf, hn]⟩)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [← mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---167/200---
For theorem sum_hom_units in Mathlib/RingTheory/IntegralDomain.lean:
theorem sum_hom_units_eq_zero (f : G →* R) (hf : f ≠ 1) : ∑ g : G, f g = 0 


Original valid proof:
:= by
  classical
    obtain ⟨x, hx⟩ : ∃ x : MonoidHom.range f.toHomUnits,
        ∀ y : MonoidHom.range f.toHomUnits, y ∈ Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x ≠ 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ⟨f.toHomUnits g, g, rfl⟩ with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ≠ 0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ∑ g : G, f g = ∑ g : G, (f.toHomUnits g : R) := rfl
      _ = ∑ u ∈ univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card • (u : R) :=
        (sum_comp ((↑) : Rˣ → R) f.toHomUnits)
      _ = ∑ u ∈ univ.image f.toHomUnits, c • (u : R) :=
        (sum_congr rfl fun u hu => congr_arg₂ _ ?_ rfl)
      _ = ∑ b : MonoidHom.range f.toHomUnits, c • ((b : Rˣ) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c • ∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R) := smul_sum.symm
      _ = c • (0 : R) := congr_arg₂ _ rfl ?_
      _ = (0 : R) := smul_zero _
    · 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      · simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      · exact ⟨1, f.toHomUnits.map_one⟩
    show (∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R)) = 0
    calc
      (∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R))
        = ∑ n ∈ range (orderOf x), ((x : Rˣ) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ ·) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let ⟨n, hn⟩ := hx b
              ⟨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ⊢; rw [pow_mod_orderOf, hn]⟩)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [← mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean - 2024-09-07 22:42:06.792222.
---168/200---
For theorem MvPolynomial.sum_weightedHomogeneousComponent in Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean:
theorem sum_weightedHomogeneousComponent :
    (finsum fun m => weightedHomogeneousComponent w m φ) = φ 


Original valid proof:
:= by
  classical
  rw [finsum_eq_sum _ (weightedHomogeneousComponent_finsupp φ)]
  ext1 d
  simp only [coeff_sum, coeff_weightedHomogeneousComponent]
  rw [Finset.sum_eq_single (weightedDegree w d)]
  · rw [if_pos rfl]
  · intro m _ hm'
    rw [if_neg hm'.symm]
  · intro hm
    rw [if_pos rfl]
    simp only [Finite.mem_toFinset, mem_support, Ne, Classical.not_not] at hm
    have := coeff_weightedHomogeneousComponent (w := w) (weightedDegree w d) φ d
    rw [hm, if_pos rfl, coeff_zero] at this
    exact this.symm


Verifying proof (Commit c04b29dd6b022753894b2fc21d2d4951e76e339e):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---169/200---
For theorem MvPolynomial.sum_weightedHomogeneousComponent in Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean:
theorem sum_weightedHomogeneousComponent :
    (finsum fun m => weightedHomogeneousComponent w m φ) = φ 


Original valid proof:
:= by
  classical
  rw [finsum_eq_sum _ (weightedHomogeneousComponent_finsupp φ)]
  ext1 d
  simp only [coeff_sum, coeff_weightedHomogeneousComponent]
  rw [Finset.sum_eq_single (weightedDegree w d)]
  · rw [if_pos rfl]
  · intro m _ hm'
    rw [if_neg hm'.symm]
  · intro hm
    rw [if_pos rfl]
    simp only [Finite.mem_toFinset, mem_support, Ne, Classical.not_not] at hm
    have := coeff_weightedHomogeneousComponent (w := w) (weightedDegree w d) φ d
    rw [hm, if_pos rfl, coeff_zero] at this
    exact this.symm


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean - 2024-09-07 22:42:27.355426.
---170/200---
For theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt in Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean:
theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ℕ} {z : L} (hzint : IsIntegral R z)
    (hz : p ^ n • z ∈ adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt 𝓟) :
    z ∈ adjoin R ({B.gen} : Set L) 


Original valid proof:
:= by
  induction' n with n hn
  · simpa using hz
  · rw [_root_.pow_succ', mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)


Verifying proof (Commit a76dc22f3a90e5ab96e9284d30276a87a4324a5d):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_

Attempt failure.

---171/200---
For theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt in Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean:
theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ℕ} {z : L} (hzint : IsIntegral R z)
    (hz : p ^ n • z ∈ adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt 𝓟) :
    z ∈ adjoin R ({B.gen} : Set L) 


Original valid proof:
:= by
  induction' n with n hn
  · simpa using hz
  · rw [_root_.pow_succ', mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)


Verifying proof (Commit 0f24aee7da46f85fee5cacc716172444ce31e582):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/RingTheory/RootsOfUnity/Basic.lean - 2024-09-07 22:42:48.633753.
---172/200---
For theorem IsPrimitiveRoot.nthRoots_one_eq_biUnion_primitiveRoots in Mathlib/RingTheory/RootsOfUnity/Basic.lean:
theorem nthRoots_one_eq_biUnion_primitiveRoots' {ζ : R} {n : ℕ+} (h : IsPrimitiveRoot ζ n) :
    nthRootsFinset n R = (Nat.divisors ↑n).biUnion fun i => primitiveRoots i R 


Original valid proof:
:= by
  symm
  apply Finset.eq_of_subset_of_card_le
  · intro x
    simp only [nthRootsFinset, ← Multiset.toFinset_eq (nthRoots_one_nodup h), exists_prop,
      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,
      Nat.mem_divisors, and_true_iff, Ne, PNat.ne_zero, PNat.pos, not_false_iff]
    rintro ⟨a, ⟨d, hd⟩, ha⟩
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, zero_mul]
      exact n.ne_zero
    rw [mem_primitiveRoots hazero] at ha
    rw [hd, pow_mul, ha.pow_eq_one, one_pow]
  · apply le_of_eq
    rw [h.card_nthRootsFinset, Finset.card_biUnion]
    · nth_rw 1 [← Nat.sum_totient n]
      refine sum_congr rfl ?_
      simp only [Nat.mem_divisors]
      rintro k ⟨⟨d, hd⟩, -⟩
      rw [mul_comm] at hd
      rw [(h.pow n.pos hd).card_primitiveRoots]
    · intro i _ j _ hdiff
      exact disjoint hdiff


Verifying proof (Commit 0e2adf9b7dd1ae6f3701d440e18e7c1074937d0a):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/RingTheory/RootsOfUnity/Minpoly.lean - 2024-09-07 22:42:58.644254.
---173/200---
For theorem IsPrimitiveRoot.separable_minpoly_mod in Mathlib/RingTheory/RootsOfUnity/Minpoly.lean:
theorem separable_minpoly_mod {p : ℕ} [Fact p.Prime] (hdiv : ¬p ∣ n) :
    Separable (map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) 


Original valid proof:
:= by
  have hdvd : map (Int.castRingHom (ZMod p)) (minpoly ℤ μ) ∣ X ^ n - 1 := by
    convert RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p)))
        (minpoly_dvd_x_pow_sub_one h)
    simp only [map_sub, map_pow, coe_mapRingHom, map_X, map_one]
  refine Separable.of_dvd (separable_X_pow_sub_C 1 ?_ one_ne_zero) hdvd
  by_contra hzero
  exact hdiv ((ZMod.natCast_zmod_eq_zero_iff_dvd n p).1 hzero)


Verifying proof (Commit 070b09db52c6f063dd905c04b291f74460734aab):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/RingTheory/Trace.lean - 2024-09-07 22:43:05.582087.
---174/200---
For theorem Algebra.trace_algebraMap in Mathlib/RingTheory/Trace.lean:
theorem trace_algebraMap_of_basis (x : R) : trace R S (algebraMap R S x) = Fintype.card ι • x 


Original valid proof:
:= by
  haveI := Classical.decEq ι
  rw [trace_apply, LinearMap.trace_eq_matrix_trace R b, Matrix.trace]
  convert Finset.sum_const x
  simp [-coe_lmul_eq_mul]


Verifying proof (Commit 8dba065d4a693e23ed06348923cd5effc765cb75):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · simp only [Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
        Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image, Finset.coe_image,
      Finset.coe_image, 

Attempt failure.

Working on Mathlib/SetTheory/Cardinal/Cofinality.lean - 2024-09-07 22:43:21.058100.
---175/200---
For theorem Ordinal.ord_cof_eq in Mathlib/SetTheory/Cardinal/Cofinality.lean:
theorem ord_cof_eq (r : α → α → Prop) [IsWellOrder α r] :
    ∃ S, Unbounded r S ∧ type (Subrel r S) = (cof (type r)).ord 


Original valid proof:
:= by
  let ⟨S, hS, e⟩ := cof_eq r
  let ⟨s, _, e'⟩ := Cardinal.ord_eq S
  let T : Set α := { a | ∃ aS : a ∈ S, ∀ b : S, s b ⟨_, aS⟩ → r b a }
  suffices Unbounded r T by
    refine ⟨T, this, le_antisymm ?_ (Cardinal.ord_le.2 <| cof_type_le this)⟩
    rw [← e, e']
    refine
      (RelEmbedding.ofMonotone
          (fun a : T =>
            (⟨a,
                let ⟨aS, _⟩ := a.2
                aS⟩ :
              S))
          fun a b h => ?_).ordinal_type_le
    rcases a with ⟨a, aS, ha⟩
    rcases b with ⟨b, bS, hb⟩
    change s ⟨a, _⟩ ⟨b, _⟩
    refine ((trichotomous_of s _ _).resolve_left fun hn => ?_).resolve_left ?_
    · exact asymm h (ha _ hn)
    · intro e
      injection e with e
      subst b
      exact irrefl _ h
  intro a
  have : { b : S | ¬r b a }.Nonempty :=
    let ⟨b, bS, ba⟩ := hS a
    ⟨⟨b, bS⟩, ba⟩
  let b := (IsWellFounded.wf : WellFounded s).min _ this
  have ba : ¬r b a := IsWellFounded.wf.min_mem _ this
  refine ⟨b, ⟨b.2, fun c => not_imp_not.1 fun h => ?_⟩, ba⟩
  rw [show ∀ b : S, (⟨b, b.2⟩ : S) = b by intro b; cases b; rfl]
  exact IsWellFounded.wf.not_lt_min _ this (IsOrderConnected.neg_trans h ba)


Verifying proof (Commit ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/SetTheory/Cardinal/Ordinal.lean - 2024-09-07 22:43:28.679645.
---176/200---
For theorem Cardinal.mul_eq_self in Mathlib/SetTheory/Cardinal/Ordinal.lean:
theorem mul_eq_self {c : Cardinal} (h : ℵ₀ ≤ c) : c * c = c 


Original valid proof:
:= by
  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun α IH ol => ?_) h
  rcases ord_eq α with ⟨r, wo, e⟩
  letI := linearOrderOfSTO r
  haveI : IsWellOrder α (· < ·) := wo
  let g : α × α → α := fun p => max p.1 p.2
  let f : α × α ↪ Ordinal × α × α :=
    ⟨fun p : α × α => (typein (· < ·) (g p), p), fun p q => congr_arg Prod.snd⟩
  let s := f ⁻¹'o Prod.Lex (· < ·) (Prod.Lex (· < ·) (· < ·))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ≤ type r by exact card_le_card this
  refine le_of_forall_lt fun o h => ?_
  rcases typein_surj s h with ⟨p, rfl⟩
  rw [← e, lt_ord]
  refine lt_of_le_of_lt
    (?_ : _ ≤ card (succ (typein (· < ·) (g p))) * card (succ (typein (· < ·) (g p)))) ?_
  · have : { q | s q p } ⊆ insert (g p) { x | x < g p } ×ˢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [s, f, Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set α) ≃ Sum { x | r x (g p) } PUnit from
      ⟨(Set.embeddingOfSubset _ _ this).trans
        ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding⟩
    refine (Equiv.Set.insert ?_).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein (· < ·) (g p)))) ℵ₀ with qo qo
  · exact (mul_lt_aleph0 qo qo).trans_le ol
  · suffices (succ (typein LT.lt (g p))).card < ⟦α⟧ from (IH _ this qo).trans_lt this
    rw [← lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type


Verifying proof (Commit c9b014cd7a6879d40f458f2b1099ae28ec9fd5bb):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---177/200---
For theorem Cardinal.mul_eq_self in Mathlib/SetTheory/Cardinal/Ordinal.lean:
theorem mul_eq_self {c : Cardinal} (h : ℵ₀ ≤ c) : c * c = c 


Original valid proof:
:= by
  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun α IH ol => ?_) h
  rcases ord_eq α with ⟨r, wo, e⟩
  letI := linearOrderOfSTO r
  haveI : IsWellOrder α (· < ·) := wo
  let g : α × α → α := fun p => max p.1 p.2
  let f : α × α ↪ Ordinal × α × α :=
    ⟨fun p : α × α => (typein (· < ·) (g p), p), fun p q => congr_arg Prod.snd⟩
  let s := f ⁻¹'o Prod.Lex (· < ·) (Prod.Lex (· < ·) (· < ·))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ≤ type r by exact card_le_card this
  refine le_of_forall_lt fun o h => ?_
  rcases typein_surj s h with ⟨p, rfl⟩
  rw [← e, lt_ord]
  refine lt_of_le_of_lt
    (?_ : _ ≤ card (succ (typein (· < ·) (g p))) * card (succ (typein (· < ·) (g p)))) ?_
  · have : { q | s q p } ⊆ insert (g p) { x | x < g p } ×ˢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [s, f, Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set α) ≃ Sum { x | r x (g p) } PUnit from
      ⟨(Set.embeddingOfSubset _ _ this).trans
        ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding⟩
    refine (Equiv.Set.insert ?_).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein (· < ·) (g p)))) ℵ₀ with qo qo
  · exact (mul_lt_aleph0 qo qo).trans_le ol
  · suffices (succ (typein LT.lt (g p))).card < ⟦α⟧ from (IH _ this qo).trans_lt this
    rw [← lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type


Verifying proof (Commit 07a9a67eb79df5177b97c8a40c2e4a425c44b22e):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---178/200---
For theorem Cardinal.mul_eq_self in Mathlib/SetTheory/Cardinal/Ordinal.lean:
theorem mul_eq_self {c : Cardinal} (h : ℵ₀ ≤ c) : c * c = c 


Original valid proof:
:= by
  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)
  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Quotient.inductionOn c fun α IH ol => ?_) h
  rcases ord_eq α with ⟨r, wo, e⟩
  letI := linearOrderOfSTO r
  haveI : IsWellOrder α (· < ·) := wo
  let g : α × α → α := fun p => max p.1 p.2
  let f : α × α ↪ Ordinal × α × α :=
    ⟨fun p : α × α => (typein (· < ·) (g p), p), fun p q => congr_arg Prod.snd⟩
  let s := f ⁻¹'o Prod.Lex (· < ·) (Prod.Lex (· < ·) (· < ·))
  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder
  suffices type s ≤ type r by exact card_le_card this
  refine le_of_forall_lt fun o h => ?_
  rcases typein_surj s h with ⟨p, rfl⟩
  rw [← e, lt_ord]
  refine lt_of_le_of_lt
    (?_ : _ ≤ card (succ (typein (· < ·) (g p))) * card (succ (typein (· < ·) (g p)))) ?_
  · have : { q | s q p } ⊆ insert (g p) { x | x < g p } ×ˢ insert (g p) { x | x < g p } := by
      intro q h
      simp only [s, f, Preimage, ge_iff_le, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,
        typein_inj, mem_setOf_eq] at h
      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)
    suffices H : (insert (g p) { x | r x (g p) } : Set α) ≃ Sum { x | r x (g p) } PUnit from
      ⟨(Set.embeddingOfSubset _ _ this).trans
        ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding⟩
    refine (Equiv.Set.insert ?_).trans ((Equiv.refl _).sumCongr punitEquivPUnit)
    apply @irrefl _ r
  cases' lt_or_le (card (succ (typein (· < ·) (g p)))) ℵ₀ with qo qo
  · exact (mul_lt_aleph0 qo qo).trans_le ol
  · suffices (succ (typein LT.lt (g p))).card < ⟦α⟧ from (IH _ this qo).trans_lt this
    rw [← lt_ord]
    apply (ord_isLimit ol).2
    rw [mk'_def, e]
    apply typein_lt_type


Verifying proof (Commit 6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

Working on Mathlib/Topology/Algebra/InfiniteSum/Basic.lean - 2024-09-07 22:43:50.109387.
---179/200---
For theorem Function.Injective.tprod_eq in Mathlib/Topology/Algebra/InfiniteSum/Basic.lean:
theorem Function.Injective.tprod_eq {g : γ → β} (hg : Injective g) {f : β → α}
    (hf : mulSupport f ⊆ Set.range g) : ∏' c, f (g c) = ∏' b, f b 


Original valid proof:
:= by
  have : mulSupport f = g '' mulSupport (f ∘ g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [← Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  · have hfg_fin : (mulSupport (f ∘ g)).Finite := hf_fin.preimage hg.injOn
    lift g to γ ↪ β using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ← Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ↦ rfl
    simp [this]
  · have hf_fin' : ¬ Set.Finite (mulSupport (f ∘ g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      funext fun a => propext <| hg.hasProd_iff (mulSupport_subset_iff'.1 hf) (a := a)]


Verifying proof (Commit 5bc1ad1d20d0d38fd328824a49d24b475a371d9e):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Topology/Bases.lean - 2024-09-07 22:43:57.195619.
---180/200---
For theorem TopologicalSpace.IsTopologicalBasis.diff_empty in Mathlib/Topology/Bases.lean:
theorem IsTopologicalBasis.diff_empty {s : Set (Set α)} (h : IsTopologicalBasis s) :
    IsTopologicalBasis (s \ {∅}) 


Original valid proof:
:= by
  refine ⟨?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_⟩
  · rintro t₁ ⟨h₁, -⟩ t₂ ⟨h₂, -⟩ x hx
    obtain ⟨t₃, h₃, hs⟩ := h.exists_subset_inter _ h₁ _ h₂ x hx
    exact ⟨t₃, ⟨h₃, Nonempty.ne_empty ⟨x, hs.1⟩⟩, hs⟩
  · rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti diff_subset) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t ∅
    · exact @isOpen_empty _ (generateFrom _)
    · exact .basic t ⟨ht, he⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Topology/Category/Profinite/EffectiveEpi.lean - 2024-09-07 22:44:04.357439.
---181/200---
For theorem Profinite.effectiveEpi_tfae in Mathlib/Topology/Category/Profinite/EffectiveEpi.lean:
theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ] 


Original valid proof:
:= by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ ↦ ⟨⟨struct π hπ⟩⟩
  tfae_finish


Verifying proof (Commit 65286a1e3e7bcef3a2e6ac0e19374d74e4bf7d6a):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

---182/200---
For theorem Profinite.effectiveEpi_tfae in Mathlib/Topology/Category/Profinite/EffectiveEpi.lean:
theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ] 


Original valid proof:
:= by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ ↦ ⟨⟨struct π hπ⟩⟩
  tfae_finish


Verifying proof (Commit 55619a095ad7cce23fe9818f4cf5fefa1fabf54e):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---183/200---
For theorem Profinite.effectiveEpi_tfae in Mathlib/Topology/Category/Profinite/EffectiveEpi.lean:
theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ] 


Original valid proof:
:= by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ ↦ ⟨⟨struct π hπ⟩⟩
  tfae_finish


Verifying proof (Commit d69a871e2141b3cc58e70cb9524c317c9844ffd7):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Topology/Compactness/Lindelof.lean - 2024-09-07 22:44:42.680392.
---184/200---
For theorem IsLindelof.inter_right in Mathlib/Topology/Compactness/Lindelof.lean:
theorem IsLindelof.inter_right (hs : IsLindelof s) (ht : IsClosed t) : IsLindelof (s ∩ t) 


Original valid proof:
:= by
  intro f hnf _ hstf
  rw [← inf_principal, le_inf_iff] at hstf
  obtain ⟨x, hsx, hx⟩ : ∃ x ∈ s, ClusterPt x f := hs hstf.1
  have hxt : x ∈ t := ht.mem_of_nhdsWithin_neBot <| hx.mono hstf.2
  exact ⟨x, ⟨hsx, hxt⟩, hx⟩

  theorem IsLindelof.inter_left (ht : IsLindelof t) (hs : IsClosed s) : IsLindelof (s ∩ t) :=
  inter_comm t s ▸ ht.inter_right hs

  theorem IsLindelof.diff (hs : IsLindelof s) (ht : IsOpen t) : IsLindelof (s \ t) :=
  hs.inter_right (isClosed_compl_iff.mpr ht)


Verifying proof (Commit 278815fde22e4550579704dd2875cfb94b828e44):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

Working on Mathlib/Topology/Constructions.lean - 2024-09-07 22:44:48.209370.
---185/200---
For theorem nhds_subtype_eq_comap in Mathlib/Topology/Constructions.lean:
theorem nhds_subtype_eq_comap {x : X} {h : p x} : 𝓝 (⟨x, h⟩ : Subtype p) = comap (↑) (𝓝 x) 


Original valid proof:
:=
  nhds_induced _ _


Verifying proof (Commit 9a069d68af1d7bc2ad676d68e44dc963e5910e7b):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun

Attempt failure.

Working on Mathlib/Topology/Homotopy/HomotopyGroup.lean - 2024-09-07 22:44:55.467616.
---186/200---
For theorem GenLoop.homotopicFrom in Mathlib/Topology/Homotopy/HomotopyGroup.lean:
theorem homotopicFrom (i : N) {p q : Ω^ N X x} :
    (toLoop i p).Homotopic (toLoop i q) → Homotopic p q 


Original valid proof:
:= by
  refine Nonempty.map fun H => ⟨⟨homotopyFrom i H, ?_, ?_⟩, ?_⟩
  pick_goal 3
  · rintro t y ⟨j, jH⟩
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    · simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
        Function.uncurry_apply_pair]
      rw [H.eq_fst]
      exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    · rw [p.2 _ ⟨j, jH⟩]; apply boundary; exact ⟨⟨j, h⟩, jH⟩
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
      Function.uncurry_apply_pair, ContinuousMap.HomotopyWith.apply_zero,
      ContinuousMap.HomotopyWith.apply_one, ne_eq, Path.coe_toContinuousMap, toLoop_apply_coe,
      ContinuousMap.curry_apply, ContinuousMap.comp_apply]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv


Verifying proof (Commit ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.

Attempt failure.

Working on Mathlib/Topology/LocalAtTarget.lean - 2024-09-07 22:45:08.007524.
---187/200---
For theorem inducing_iff_inducing_of_iSup_eq_top in Mathlib/Topology/LocalAtTarget.lean:
theorem inducing_iff_inducing_of_iSup_eq_top (h : Continuous f) :
    Inducing f ↔ ∀ i, Inducing ((U i).1.restrictPreimage f) 


Original valid proof:
:= by
  simp_rw [← inducing_subtype_val.of_comp_iff, inducing_iff_nhds, restrictPreimage,
    MapsTo.coe_restrict, restrict_eq, ← @Filter.comap_comap _ _ _ _ _ f]
  constructor
  · intro H i x
    rw [Function.comp_apply, ← H, ← inducing_subtype_val.nhds_eq_comap]
  · intro H x
    obtain ⟨i, hi⟩ :=
      Opens.mem_iSup.mp
        (show f x ∈ iSup U by
          rw [hU]
          trivial)
    erw [← OpenEmbedding.map_nhds_eq (h.1 _ (U i).2).openEmbedding_subtype_val ⟨x, hi⟩]
    rw [(H i) ⟨x, hi⟩, Filter.subtype_coe_map_comap, Function.comp_apply, Subtype.coe_mk,
      inf_eq_left, Filter.le_principal_iff]
    exact Filter.preimage_mem_comap ((U i).2.mem_nhds hi)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.

Attempt failure.

Working on Mathlib/Topology/MetricSpace/HausdorffDistance.lean - 2024-09-07 22:45:13.426055.
---188/200---
For theorem EMetric.infEdist_le_hausdorffEdist_of_mem in Mathlib/Topology/MetricSpace/HausdorffDistance.lean:
theorem infEdist_le_hausdorffEdist_of_mem (h : x ∈ s) : infEdist x t ≤ hausdorffEdist s t 


Original valid proof:
:= by
  rw [hausdorffEdist_def]
  refine le_trans ?_ le_sup_left
  exact le_iSup₂ (α := ℝ≥0∞) x h


Verifying proof (Commit 75499222cc11ae5a47a99ba69c3066b962a0dc6f):
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  · rcases eq_or_ne a 0 with (rfl | h's)
    · rcases eq_or_ne a 0 with (rfl | h's)
      · simp only [mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

Attempt failure.

Working on Mathlib/Topology/MetricSpace/Polish.lean - 2024-09-07 22:45:22.540331.
---189/200---
For theorem IsClosed.isClopenable in Mathlib/Topology/MetricSpace/Polish.lean:
theorem _root_.IsClosed.isClopenable [TopologicalSpace α] [PolishSpace α] {s : Set α}
    (hs : IsClosed s) : IsClopenable s 


Original valid proof:
:= by
  classical
  haveI : PolishSpace s := hs.polishSpace
  let t : Set α := sᶜ
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ⊕ t ≃ α := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ≤ ‹_› := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ← continuous_iff_coinduced_le]
    exact ⟨continuous_subtype_val, continuous_subtype_val⟩
  refine ⟨.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_⟩
  · rw [← f.induced_symm]
    exact f.symm.polishSpace_induced
  · rw [isOpen_coinduced, isOpen_sum_iff]
    simp [f, preimage_preimage]


Verifying proof (Commit 63ea835fad879edf561b4e899d4f49874a770a73):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---190/200---
For theorem IsClosed.isClopenable in Mathlib/Topology/MetricSpace/Polish.lean:
theorem _root_.IsClosed.isClopenable [TopologicalSpace α] [PolishSpace α] {s : Set α}
    (hs : IsClosed s) : IsClopenable s 


Original valid proof:
:= by
  classical
  haveI : PolishSpace s := hs.polishSpace
  let t : Set α := sᶜ
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ⊕ t ≃ α := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ≤ ‹_› := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ← continuous_iff_coinduced_le]
    exact ⟨continuous_subtype_val, continuous_subtype_val⟩
  refine ⟨.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_⟩
  · rw [← f.induced_symm]
    exact f.symm.polishSpace_induced
  · rw [isOpen_coinduced, isOpen_sum_iff]
    simp [f, preimage_preimage]


Verifying proof (Commit 62d1e98c9775031911b945f049f84047fafbe5e1):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    simp only [Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Fu

Attempt failure.

Working on Mathlib/Topology/Metrizable/Urysohn.lean - 2024-09-07 22:45:36.101592.
---191/200---
For theorem TopologicalSpace.exists_inducing_l_infty in Mathlib/Topology/Metrizable/Urysohn.lean:
theorem exists_inducing_l_infty : ∃ f : X → ℕ →ᵇ ℝ, Inducing f 


Original valid proof:
:= by
  rcases exists_countable_basis X with ⟨B, hBc, -, hB⟩
  let s : Set (Set X × Set X) := { UV ∈ B ×ˢ B | closure UV.1 ⊆ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ⊥
  haveI : DiscreteTopology s := ⟨rfl⟩
  rsuffices ⟨f, hf⟩ : ∃ f : X → s →ᵇ ℝ, Inducing f
  · exact ⟨fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ℕ →ᵇ ℝ)).embedding.toInducing.comp hf⟩
  have hd : ∀ UV : s, Disjoint (closure UV.1.1) UV.1.2ᶜ :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ⟨ε, ε01, hε⟩ : ∃ ε : s → ℝ, (∀ UV, ε UV ∈ Ioc (0 : ℝ) 1) ∧ Tendsto ε cofinite (𝓝 0) := by
    rcases posSumOfEncodable zero_lt_one s with ⟨ε, ε0, c, hεc, hc1⟩
    refine ⟨ε, fun UV => ⟨ε0 UV, ?_⟩, hεc.summable.tendsto_cofinite_zero⟩
    exact (le_hasSum hεc UV fun _ _ => (ε0 _).le).trans hc1
  have : ∀ UV : s, ∃ f : C(X, ℝ),
      EqOn f 0 UV.1.1 ∧ EqOn f (fun _ => ε UV) UV.1.2ᶜ ∧ ∀ x, f x ∈ Icc 0 (ε UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ⟨f, hf₀, hf₁, hf01⟩
    exact ⟨ε UV • f, fun x hx => by simp [hf₀ (subset_closure hx)], fun x hx => by simp [hf₁ hx],
      fun x => ⟨mul_nonneg (ε01 _).1.le (hf01 _).1, mul_le_of_le_one_right (ε01 _).1.le (hf01 _).2⟩⟩
  choose f hf0 hfε hf0ε using this
  have hf01 : ∀ UV x, f UV x ∈ Icc (0 : ℝ) 1 :=
    fun UV x => Icc_subset_Icc_right (ε01 _).2 (hf0ε _ _)
  set F : X → s →ᵇ ℝ := fun x =>
    ⟨⟨fun UV => f UV x, continuous_of_discreteTopology⟩, 1,
      fun UV₁ UV₂ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)⟩
  have hF : ∀ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ⟨F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_⟩
  · refine (nhds_basis_closedBall.comap _).ge_iff.2 fun δ δ0 => ?_
    have h_fin : { UV : s | δ ≤ ε UV }.Finite := by simpa only [← not_lt] using hε (gt_mem_nhds δ0)
    have : ∀ᶠ y in 𝓝 x, ∀ UV, δ ≤ ε UV → dist (F y UV) (F x UV) ≤ δ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ δ0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le δ0.le).2 fun UV => ?_
    rcases le_total δ (ε UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0ε _ _) (hf0ε _ _)).trans (by rwa [sub_zero])]
  · refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V ⟨hVB, hxV⟩
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ⟨U, hUB, hxU, hUV⟩
    set UV : ↥s := ⟨(U, V), ⟨hUB, hVB⟩, hUV⟩
    refine ⟨ε UV, (ε01 UV).1, fun y (hy : dist (F y) (F x) < ε UV) => ?_⟩
    replace hy : dist (F y UV) (F x UV) < ε UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfε UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _


Verifying proof (Commit 6be2bec13d4dd1fd901f9a619d053d7549cfe177):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

---192/200---
For theorem TopologicalSpace.exists_inducing_l_infty in Mathlib/Topology/Metrizable/Urysohn.lean:
theorem exists_inducing_l_infty : ∃ f : X → ℕ →ᵇ ℝ, Inducing f 


Original valid proof:
:= by
  rcases exists_countable_basis X with ⟨B, hBc, -, hB⟩
  let s : Set (Set X × Set X) := { UV ∈ B ×ˢ B | closure UV.1 ⊆ UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := ⊥
  haveI : DiscreteTopology s := ⟨rfl⟩
  rsuffices ⟨f, hf⟩ : ∃ f : X → s →ᵇ ℝ, Inducing f
  · exact ⟨fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : ℕ →ᵇ ℝ)).embedding.toInducing.comp hf⟩
  have hd : ∀ UV : s, Disjoint (closure UV.1.1) UV.1.2ᶜ :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain ⟨ε, ε01, hε⟩ : ∃ ε : s → ℝ, (∀ UV, ε UV ∈ Ioc (0 : ℝ) 1) ∧ Tendsto ε cofinite (𝓝 0) := by
    rcases posSumOfEncodable zero_lt_one s with ⟨ε, ε0, c, hεc, hc1⟩
    refine ⟨ε, fun UV => ⟨ε0 UV, ?_⟩, hεc.summable.tendsto_cofinite_zero⟩
    exact (le_hasSum hεc UV fun _ _ => (ε0 _).le).trans hc1
  have : ∀ UV : s, ∃ f : C(X, ℝ),
      EqOn f 0 UV.1.1 ∧ EqOn f (fun _ => ε UV) UV.1.2ᶜ ∧ ∀ x, f x ∈ Icc 0 (ε UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      ⟨f, hf₀, hf₁, hf01⟩
    exact ⟨ε UV • f, fun x hx => by simp [hf₀ (subset_closure hx)], fun x hx => by simp [hf₁ hx],
      fun x => ⟨mul_nonneg (ε01 _).1.le (hf01 _).1, mul_le_of_le_one_right (ε01 _).1.le (hf01 _).2⟩⟩
  choose f hf0 hfε hf0ε using this
  have hf01 : ∀ UV x, f UV x ∈ Icc (0 : ℝ) 1 :=
    fun UV x => Icc_subset_Icc_right (ε01 _).2 (hf0ε _ _)
  set F : X → s →ᵇ ℝ := fun x =>
    ⟨⟨fun UV => f UV x, continuous_of_discreteTopology⟩, 1,
      fun UV₁ UV₂ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)⟩
  have hF : ∀ x UV, F x UV = f UV x := fun _ _ => rfl
  refine ⟨F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_⟩
  · refine (nhds_basis_closedBall.comap _).ge_iff.2 fun δ δ0 => ?_
    have h_fin : { UV : s | δ ≤ ε UV }.Finite := by simpa only [← not_lt] using hε (gt_mem_nhds δ0)
    have : ∀ᶠ y in 𝓝 x, ∀ UV, δ ≤ ε UV → dist (F y UV) (F x UV) ≤ δ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ δ0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le δ0.le).2 fun UV => ?_
    rcases le_total δ (ε UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0ε _ _) (hf0ε _ _)).trans (by rwa [sub_zero])]
  · refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V ⟨hVB, hxV⟩
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ⟨U, hUB, hxU, hUV⟩
    set UV : ↥s := ⟨(U, V), ⟨hUB, hVB⟩, hUV⟩
    refine ⟨ε UV, (ε01 UV).1, fun y (hy : dist (F y) (F x) < ε UV) => ?_⟩
    replace hy : dist (F y UV) (F x UV) < ε UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfε UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Topology/OmegaCompletePartialOrder.lean - 2024-09-07 22:45:49.735693.
---193/200---
For theorem notBelow_isOpen in Mathlib/Topology/OmegaCompletePartialOrder.lean:
theorem notBelow_isOpen : IsOpen (notBelow y) 


Original valid proof:
:= by
  have h : Monotone (notBelow y) := fun x z hle ↦ mt hle.trans
  refine ⟨h, fun c ↦ eq_of_forall_ge_iff fun z ↦ ?_⟩
  simp only [ωSup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]


Verifying proof (Commit 4fafac3c913ccc407e26d1bc00d7f75cec309030):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
      Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Fin

Attempt failure.

Working on Mathlib/Topology/Semicontinuous.lean - 2024-09-07 22:45:54.045880.
---194/200---
For theorem LowerSemicontinuousWithinAt.add' in Mathlib/Topology/Semicontinuous.lean:
theorem LowerSemicontinuousWithinAt.add' {f g : α → γ} (hf : LowerSemicontinuousWithinAt f s x)
    (hg : LowerSemicontinuousWithinAt g s x)
    (hcont : ContinuousAt (fun p : γ × γ => p.1 + p.2) (f x, g x)) :
    LowerSemicontinuousWithinAt (fun z => f z + g z) s x 


Original valid proof:
:= by
  intro y hy
  obtain ⟨u, v, u_open, xu, v_open, xv, h⟩ :
    ∃ u v : Set γ,
      IsOpen u ∧ f x ∈ u ∧ IsOpen v ∧ g x ∈ v ∧ u ×ˢ v ⊆ { p : γ × γ | y < p.fst + p.snd } :=
    mem_nhds_prod_iff'.1 (hcont (isOpen_Ioi.mem_nhds hy))
  by_cases hx₁ : ∃ l, l < f x
  · obtain ⟨z₁, z₁lt, h₁⟩ : ∃ z₁ < f x, Ioc z₁ (f x) ⊆ u :=
      exists_Ioc_subset_of_mem_nhds (u_open.mem_nhds xu) hx₁
    by_cases hx₂ : ∃ l, l < g x
    · obtain ⟨z₂, z₂lt, h₂⟩ : ∃ z₂ < g x, Ioc z₂ (g x) ⊆ v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hx₂
      filter_upwards [hf z₁ z₁lt, hg z₂ z₂lt] with z h₁z h₂z
      have A1 : min (f z) (f x) ∈ u := by
        by_cases H : f z ≤ f x
        · simp [H]
          exact h₁ ⟨h₁z, H⟩
        · simp [le_of_not_le H]
          exact h₁ ⟨z₁lt, le_rfl⟩
      have A2 : min (g z) (g x) ∈ v := by
        by_cases H : g z ≤ g x
        · simp [H]
          exact h₂ ⟨h₂z, H⟩
        · simp [le_of_not_le H]
          exact h₂ ⟨z₂lt, le_rfl⟩
      have : (min (f z) (f x), min (g z) (g x)) ∈ u ×ˢ v := ⟨A1, A2⟩
      calc
        y < min (f z) (f x) + min (g z) (g x) := h this
        _ ≤ f z + g z := add_le_add (min_le_left _ _) (min_le_left _ _)

    · simp only [not_exists, not_lt] at hx₂
      filter_upwards [hf z₁ z₁lt] with z h₁z
      have A1 : min (f z) (f x) ∈ u := by
        by_cases H : f z ≤ f x
        · simp [H]
          exact h₁ ⟨h₁z, H⟩
        · simp [le_of_not_le H]
          exact h₁ ⟨z₁lt, le_rfl⟩
      have : (min (f z) (f x), g x) ∈ u ×ˢ v := ⟨A1, xv⟩
      calc
        y < min (f z) (f x) + g x := h this
        _ ≤ f z + g z := add_le_add (min_le_left _ _) (hx₂ (g z))

  · simp only [not_exists, not_lt] at hx₁
    by_cases hx₂ : ∃ l, l < g x
    · obtain ⟨z₂, z₂lt, h₂⟩ : ∃ z₂ < g x, Ioc z₂ (g x) ⊆ v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hx₂
      filter_upwards [hg z₂ z₂lt] with z h₂z
      have A2 : min (g z) (g x) ∈ v := by
        by_cases H : g z ≤ g x
        · simp [H]
          exact h₂ ⟨h₂z, H⟩
        · simp [le_of_not_le H]
          exact h₂ ⟨z₂lt, le_rfl⟩
      have : (f x, min (g z) (g x)) ∈ u ×ˢ v := ⟨xu, A2⟩
      calc
        y < f x + min (g z) (g x) := h this
        _ ≤ f z + g z := add_le_add (hx₁ (f z)) (min_le_left _ _)
    · simp only [not_exists, not_lt] at hx₁ hx₂
      apply Filter.eventually_of_forall
      intro z
      have : (f x, g x) ∈ u ×ˢ v := ⟨xu, xv⟩
      calc
        y < f x + g x := h this
        _ ≤ f z + g z := add_le_add (hx₁ (f z)) (hx₂ (g z))


Verifying proof (Commit 200b13c6bec9232f07d98e431a27afa078e8f986):
:= by
  classical
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_uni

Attempt failure.

Working on Mathlib/Topology/Sheaves/SheafCondition/UniqueGluing.lean - 2024-09-07 22:46:06.283481.
---195/200---
For theorem TopCat.Presheaf.isSheaf_of_isSheafUniqueGluing_types in Mathlib/Topology/Sheaves/SheafCondition/UniqueGluing.lean:
theorem isSheaf_of_isSheafUniqueGluing_types (Fsh : F.IsSheafUniqueGluing) : F.IsSheaf 


Original valid proof:
:=
  (isSheaf_iff_isSheafUniqueGluing_types F).mpr Fsh


Verifying proof (Commit 4cf1162dddb1c9eb77df8a17815b1dea87bb892c):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Topology/TietzeExtension.lean - 2024-09-07 22:46:27.943389.
---196/200---
For theorem BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding' in Mathlib/Topology/TietzeExtension.lean:
theorem exists_extension_norm_eq_of_closedEmbedding' (f : X →ᵇ ℝ) (e : C(X, Y))
    (he : ClosedEmbedding e) : ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f 


Original valid proof:
:= by
  choose F hF_norm hF_dist using fun f : X →ᵇ ℝ => tietze_extension_step f e he
  set g : ℕ → Y →ᵇ ℝ := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ∀ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ∀ n, dist ((g n).compContinuous e) f ≤ (2 / 3) ^ n * ‖f‖ := by
    intro n
    induction' n with n ihn
    · simp [g0]
    · rw [g_succ n, add_compContinuous, ← dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [← dist_eq_norm']
  have hg_dist : ∀ n, dist (g n) (g (n + 1)) ≤ 1 / 3 * ‖f‖ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‖F (f - (g n).compContinuous e)‖ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ ≤ ‖f - (g n).compContinuous e‖ / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ≤ 1 / 3 * ((2 / 3) ^ n * ‖f‖) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * ‖f‖ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (𝓝 <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [← zero_mul ‖f‖]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ⟨limUnder atTop g, le_antisymm ?_ ?_, hge⟩
  · rw [← dist_zero_left, ← g0]
    refine
      (dist_le_of_le_geometric_of_tendsto₀ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ℝ) = 1 by norm_num1]
  · rw [← hge]
    exact norm_compContinuous_le _ _


Verifying proof (Commit ea54eb89c8a123dcfceeb11bd200d459f2f95413):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

---197/200---
For theorem BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding' in Mathlib/Topology/TietzeExtension.lean:
theorem exists_extension_norm_eq_of_closedEmbedding' (f : X →ᵇ ℝ) (e : C(X, Y))
    (he : ClosedEmbedding e) : ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f 


Original valid proof:
:= by
  choose F hF_norm hF_dist using fun f : X →ᵇ ℝ => tietze_extension_step f e he
  set g : ℕ → Y →ᵇ ℝ := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ∀ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ∀ n, dist ((g n).compContinuous e) f ≤ (2 / 3) ^ n * ‖f‖ := by
    intro n
    induction' n with n ihn
    · simp [g0]
    · rw [g_succ n, add_compContinuous, ← dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [← dist_eq_norm']
  have hg_dist : ∀ n, dist (g n) (g (n + 1)) ≤ 1 / 3 * ‖f‖ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‖F (f - (g n).compContinuous e)‖ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ ≤ ‖f - (g n).compContinuous e‖ / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ≤ 1 / 3 * ((2 / 3) ^ n * ‖f‖) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * ‖f‖ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (𝓝 <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [← zero_mul ‖f‖]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ⟨limUnder atTop g, le_antisymm ?_ ?_, hge⟩
  · rw [← dist_zero_left, ← g0]
    refine
      (dist_le_of_le_geometric_of_tendsto₀ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ℝ) = 1 by norm_num1]
  · rw [← hge]
    exact norm_compContinuous_le _ _


Verifying proof (Commit e2fa63869cbb917d67cfce82b3f2789ce68018df):
:= by
  classical
  induction' s using Finset.induction_on with a s ha ih
  · simp only [Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
        Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ, F

Attempt failure.

Working on Mathlib/Topology/UniformSpace/Cauchy.lean - 2024-09-07 22:46:49.982392.
---198/200---
For theorem TotallyBounded.closure in Mathlib/Topology/UniformSpace/Cauchy.lean:
theorem TotallyBounded.closure {s : Set α} (h : TotallyBounded s) : TotallyBounded (closure s) 


Original valid proof:
:=
  uniformity_hasBasis_closed.totallyBounded_iff.2 fun V hV =>
    let ⟨t, htf, hst⟩ := h V hV.1
    ⟨t, htf,
      closure_minimal hst <|
        htf.isClosed_biUnion fun _ _ => hV.2.preimage (continuous_id.prod_mk continuous_const)⟩


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun

Attempt failure.

---199/200---
For theorem TotallyBounded.closure in Mathlib/Topology/UniformSpace/Cauchy.lean:
theorem TotallyBounded.closure {s : Set α} (h : TotallyBounded s) : TotallyBounded (closure s) 


Original valid proof:
:=
  uniformity_hasBasis_closed.totallyBounded_iff.2 fun V hV =>
    let ⟨t, htf, hst⟩ := h V hV.1
    ⟨t, htf,
      closure_minimal hst <|
        htf.isClosed_biUnion fun _ _ => hV.2.preimage (continuous_id.prod_mk continuous_const)⟩


Verifying proof (Commit 14167e48d13e9c2d72cbdff0431a8edba6021c34):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    refine ⟨fun h => ?_, fun h => ?_⟩
    simp only [Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.co

Attempt failure.

Working on Mathlib/Topology/UniformSpace/Compact.lean - 2024-09-07 22:47:01.858754.
---200/200---
For theorem nhdsSet_diagonal_eq_uniformity in Mathlib/Topology/UniformSpace/Compact.lean:
theorem nhdsSet_diagonal_eq_uniformity [CompactSpace α] : 𝓝ˢ (diagonal α) = 𝓤 α 


Original valid proof:
:= by
  refine nhdsSet_diagonal_le_uniformity.antisymm ?_
  have :
    (𝓤 (α × α)).HasBasis (fun U => U ∈ 𝓤 α) fun U =>
      (fun p : (α × α) × α × α => ((p.1.1, p.2.1), p.1.2, p.2.2)) ⁻¹' U ×ˢ U := by
    rw [uniformity_prod_eq_comap_prod]
    exact (𝓤 α).basis_sets.prod_self.comap _
  refine (isCompact_diagonal.nhdsSet_basis_uniformity this).ge_iff.2 fun U hU => ?_
  exact mem_of_superset hU fun ⟨x, y⟩ hxy => mem_iUnion₂.2
    ⟨(x, x), rfl, refl_mem_uniformity hU, hxy⟩


Verifying proof (Commit 481b74fd30711d0cf0727798094b6f44f65e6b0f):
:= by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    exact ⟨fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
  · refine ⟨fun h => ?_, fun h => ?_⟩
    simp only [Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Function.comp_apply, Function.comp_apply, Function.comp_apply, Function.comp_apply,
      Fu

Attempt failure.

STARTING: Lean repo copy removal
DONE: Lean repo copy removal
Among 200 proof attempts, there were 0 successful and 200 failed attempts at proving their respect theorems.
The rate of successful proof = 0.0.
