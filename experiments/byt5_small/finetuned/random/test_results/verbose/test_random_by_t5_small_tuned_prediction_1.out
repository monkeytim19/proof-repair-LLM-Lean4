STARTING: verification of proofs from predicted_proof column in dataset from models/byt5_small/random/test_random_by_t5_small_tuned_prediction.csv - 2024-09-07 20:37:27.681661
STARTING: Lean repo copy creation
DONE: Lean repo copy creation
STARTING: retrieve cache
installing leantar 0.1.13
Attempting to download 4738 file(s)
Decompressing 4738 file(s)
Unpacked in 502471 ms
Completed successfully!
DONE: retrieved cache
Working on Mathlib/Algebra/AddTorsor.lean - 2024-09-07 21:33:45.154416.
---1/100---
For theorem Equiv.pointReflection_fixed_iff_of_injective_bit0 in Mathlib/Algebra/AddTorsor.lean:
theorem pointReflection_fixed_iff_of_injective_bit0 {x y : P} (h : Injective (bit0 : G â†’ G)) :
    pointReflection x y = y â†” y = x 


Original valid proof:
:= by
  rw [pointReflection_apply, eq_comm, eq_vadd_iff_vsub_eq, â† neg_vsub_eq_vsub_rev,
    neg_eq_iff_add_eq_zero, â† bit0, â† bit0_zero, h.eq_iff, vsub_eq_zero_iff_eq, eq_comm]


Verifying proof (Commit b0c1460c9fd4a5058bcae6b919686bc5e8a0ee37):
:= by
  rw [pointReflection_apply, eq_comm, eq_vadd_iff_vsub_eq, â† neg_vsub_eq_vsub_rev,
    neg_eq_iff_add_eq_zero, â† bit0, â† bit0_zero, h.eq_iff, vsub_eq_zero_iff_eq, eq_comm]
  equiv.point_reflection_fixed_iff_of_injective_bit0

Attempt failure.

Working on Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean - 2024-09-07 21:35:07.886583.
---2/100---
For theorem GeneralizedContinuedFraction.get?_of_eq_some_of_succ_get?_intFractPair_stream in Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean:
theorem get?_of_eq_some_of_succ_get?_intFractPair_stream {ifp_succ_n : IntFractPair K}
    (stream_succ_nth_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) :
    (of v).s.get? n = some âŸ¨1, ifp_succ_n.bâŸ© 


Original valid proof:
:= by
  unfold of IntFractPair.seq1
  simp [Stream'.Seq.map_tail, Stream'.Seq.get?_tail, Stream'.Seq.map_get?, stream_succ_nth_eq]


Verifying proof (Commit 67bb925387960887a3b36a6aab219b9c613883f7):
:= by
  unfold of IntFractPair.seq1
  simp [Seq.map_tail, Seq.get?_tail, Seq.map_get?, stream_succ_nth_eq]

Attempt failure.

---3/100---
For theorem GeneralizedContinuedFraction.of_s_tail in Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean:
theorem of_s_tail : (of v).s.tail = (of (fract v)â»Â¹).s 


Original valid proof:
:=
  Stream'.Seq.ext fun n => Stream'.Seq.get?_tail (of v).s n â–¸ of_s_succ v n


Verifying proof (Commit 67bb925387960887a3b36a6aab219b9c613883f7):
:=
  Seq.ext fun n => Seq.get?_tail (of v).s n â–¸ of_s_succ v n

Attempt failure.

Working on Mathlib/Algebra/DirectLimit.lean - 2024-09-07 21:35:45.320018.
---4/100---
For theorem AddCommGroup.DirectLimit.map_comp in Mathlib/Algebra/DirectLimit.lean:
lemma map_comp [IsDirected Î¹ (Â· â‰¤ Â·)]
    (gâ‚ : (i : Î¹) â†’ G i â†’â‚—[R] G' i) (gâ‚‚ : (i : Î¹) â†’ G' i â†’â‚—[R] G'' i)
    (hgâ‚ : âˆ€ i j h, gâ‚ j âˆ˜â‚— f i j h = f' i j h âˆ˜â‚— gâ‚ i)
    (hgâ‚‚ : âˆ€ i j h, gâ‚‚ j âˆ˜â‚— f' i j h = f'' i j h âˆ˜â‚— gâ‚‚ i) :
    (map gâ‚‚ hgâ‚‚ âˆ˜â‚— map gâ‚ hgâ‚ :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') =
    (map (fun i â†¦ gâ‚‚ i âˆ˜â‚— gâ‚ i) fun i j h â†¦ by
        rw [LinearMap.comp_assoc, hgâ‚ i, â† LinearMap.comp_assoc, hgâ‚‚ i, LinearMap.comp_assoc] :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') 


Original valid proof:
:=
  DFunLike.ext _ _ fun x â†¦ (isEmpty_or_nonempty Î¹).elim (fun _ â†¦ Subsingleton.elim _ _) fun _ â†¦
    x.induction_on fun i g â†¦ by simp


Verifying proof (Commit af1e1921fa808d9f4d24fd674214116943e9fbb8):
:=
  FunLike.ext _ _ fun x â†¦ (isEmpty_or_nonempty Î¹).elim (fun _ â†¦ Subsingleton.elim _ _) fun _ â†¦
    x.induction_on fun i g â†¦ by simp

Attempt failure.

Working on Mathlib/Algebra/Lie/Weights/Basic.lean - 2024-09-07 21:37:42.148131.
---5/100---
For theorem LieModule.disjoint_weightSpace in Mathlib/Algebra/Lie/Weights/Basic.lean:
lemma disjoint_weightSpaceOf [NoZeroSMulDivisors R M] {x : L} {Ï†â‚ Ï†â‚‚ : R} (h : Ï†â‚ â‰  Ï†â‚‚) :
    Disjoint (weightSpaceOf M Ï†â‚ x) (weightSpaceOf M Ï†â‚‚ x) 


Original valid proof:
:= by
  rw [LieSubmodule.disjoint_iff_coe_toSubmodule]
  exact Module.End.disjoint_iSup_genEigenspace _ h


Verifying proof (Commit 61e05975727e0b1a19d0075b994c53596adb3405):
:= by
  rw [LieSubmodule.disjoint_iff_coe_toSubmodule]
  exact Module.End.disjoint_iSup_generalizedEigenspace _ h

Attempt failure.

Working on Mathlib/Algebra/Module/PID.lean - 2024-09-07 21:39:21.575966.
---6/100---
For theorem Module.torsion_by_prime_power_decomposition in Mathlib/Algebra/Module/PID.lean:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    âˆƒ (d : â„•) (k : Fin d â†’ â„•), Nonempty <| N â‰ƒâ‚—[R] â¨ i : Fin d, R â§¸ R âˆ™ p ^ (k i : â„•) 


Original valid proof:
:= by
  obtain âŸ¨d, s, hsâŸ© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  Â· 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      âŸ¨âŸ¨0âŸ©, fun x => by dsimp; rw [â† Submodule.mem_bot R, hs]; exact Submodule.mem_topâŸ©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact âŸ¨0âŸ©
  Â· have : âˆ€ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain âŸ¨j, hjâŸ© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d â†’ N â§¸ R âˆ™ s j := Submodule.Quotient.mk âˆ˜ s âˆ˜ j.succAbove
    have := IH ?_ s' ?_
    Â· obtain âŸ¨k, âŸ¨fâŸ©âŸ© := this
      clear IH
      have : âˆ€ i : Fin d,
          âˆƒ x : N, p ^ k i â€¢ x = 0 âˆ§ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain âŸ¨x, h0, h1âŸ© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine âŸ¨x, h0, ?_âŸ©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine âŸ¨?_, âŸ¨?_âŸ©âŸ©
      Â· exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : â„•)) (finSuccEquiv d a)
      Â· refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R â§¸ _ â†’â‚—[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R âˆ™ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R â§¸ R âˆ™ p ^ @Option.rec _ (fun _ => â„•) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        Â· rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        Â· rw [â† f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, â† LinearMap.comp_assoc,
            â† LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R âˆ™ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    Â· exact (mk_surjective _).forall.mpr fun x =>
        âŸ¨(@hN x).choose, by rw [â† Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]âŸ©
    Â· have hs' := congr_arg (Submodule.map <| mkQ <| R âˆ™ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [â† Function.comp.assoc, Set.range_comp (_ âˆ˜ s), Fin.range_succAbove]
      rw [â† Set.range_comp, â† Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'


Verifying proof (Commit 149993021318d2b426f3d41570396b90e12fcb46):
:= by
  obtain âŸ¨d, s, hsâŸ© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  Â· 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      âŸ¨âŸ¨0âŸ©, fun x => by dsimp; rw [â† Submodule.mem_bot R, hs]; exact Submodule.mem_topâŸ©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact âŸ¨0âŸ©
  Â· have : âˆ€ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain âŸ¨j, hjâŸ© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d â†’ N â§¸ R âˆ™ s j := Submodule.Quotient.mk âˆ˜ s âˆ˜ j.succAbove
    have := IH ?_ s' ?_
    Â· obtain âŸ¨k, âŸ¨fâŸ©âŸ© := this
      clear IH
      have : âˆ€ i : Fin d,
          âˆƒ x : N, p ^ k i â€¢ x = 0 âˆ§ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain âŸ¨x, h0, h1âŸ© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine âŸ¨x, h0, ?_âŸ©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine âŸ¨?_, âŸ¨?_âŸ©âŸ©
      Â· exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : â„•)) (finSuccEquiv d a)
      Â· refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R â§¸ _ â†’â‚—[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R âˆ™ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm)
        Â· rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        Â· rw [â† f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
             LinearEquiv.toLinearMap_symm_apply,
           Function.comp_apply]
      refine âŸ¨?_, âŸ¨?_âŸ©âŸ©
      Â· exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : â„•)) (finSuccEquiv d a)
      Â· refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
               (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R â§¸ _ â†’â‚—[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R âˆ™ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfE

Attempt failure.

Working on Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean - 2024-09-07 21:41:54.918532.
---7/100---
For theorem AlgebraicGeometry.Î“Spec.adjunction_homEquiv_apply in Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatáµ’áµ–}
    (f : (op <| Scheme.Î“.obj <| op X) âŸ¶ R) :
    Î“Spec.adjunction.homEquiv X R f = locallyRingedSpaceAdjunction.homEquiv X.1 R f 


Original valid proof:
:= rfl


Verifying proof (Commit 43339007ce3d59409eaf23093d4981175984328f):
:= by
  dsimp only [adjunction]
  rw [Adjunction.restrictFullyFaithful_homEquiv_apply, Adjunction.homEquiv_unit]
  simp

Attempt failure.

Working on Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean - 2024-09-07 21:45:16.394264.
---8/100---
For theorem AlgebraicTopology.AlternatingCofaceMapComplex.d_squared in Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean:
theorem d_squared (n : â„•) : objD X (n + 1) â‰« objD X n = 0 


Original valid proof:
:= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij âŸ¨i', j'âŸ© hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine âŸ¨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    Â· simp only [Ï†, Fin.castLT_castSucc, Fin.succ_pred]
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa [S] using hij


Verifying proof (Commit 084cfb354233793728fd0ef1054e9b156224e7f6):
:= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff, Fin.val_succ,
      Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa using hij
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa using hij
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa using hij
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa using hij
  Â· 
    rintro âŸ¨i, jâŸ© âŸ¨i', j'âŸ© hij hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine âŸ¨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa using hij
  Â· 
    rintro âŸ¨i, jâŸ© âŸ¨i', j'âŸ© hij

Attempt failure.

Working on Mathlib/Analysis/Analytic/Composition.lean - 2024-09-07 21:45:34.017322.
---9/100---
For theorem HasFPowerSeriesAt.comp in Mathlib/Analysis/Analytic/Composition.lean:
theorem HasFPowerSeriesAt.comp {g : F â†’ G} {f : E â†’ F} {q : FormalMultilinearSeries ğ•œ F G}
    {p : FormalMultilinearSeries ğ•œ E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g âˆ˜ f) (q.comp p) x 


Original valid proof:
:= by
  rcases hg with âŸ¨rg, HgâŸ©
  rcases hf with âŸ¨rf, HfâŸ©
  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with âŸ¨r, r_pos : 0 < r, hrâŸ©
  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© :
    âˆƒ Î´ : â„â‰¥0âˆ, 0 < Î´ âˆ§ âˆ€ {z : E}, z âˆˆ EMetric.ball x Î´ â†’ f z âˆˆ EMetric.ball (f x) rg := by
    have : EMetric.ball (f x) rg âˆˆ ğ“ (f x) := EMetric.ball_mem_nhds _ Hg.r_pos
    rcases EMetric.mem_nhds_iff.1 (Hf.analyticAt.continuousAt this) with âŸ¨Î´, Î´pos, HÎ´âŸ©
    exact âŸ¨Î´, Î´pos, fun hz => HÎ´ hzâŸ©
  let rf' := min rf Î´
  have min_pos : 0 < min rf' r := by
    simp only [rf', r_pos, Hf.r_pos, Î´pos, lt_min_iff, ENNReal.coe_pos, and_self_iff]
  refine âŸ¨min rf' r, ?_âŸ©
  refine
    âŸ¨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),
      min_pos, @fun y hy => ?_âŸ©
  have y_mem : y âˆˆ EMetric.ball (0 : E) rf :=
    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_left _ _))) hy
  have fy_mem : f (x + y) âˆˆ EMetric.ball (f x) rg := by
    apply hÎ´
    have : y âˆˆ EMetric.ball (0 : E) Î´ :=
      (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy
    simpa [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm]
  have A : Tendsto (fun n => âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)
      atTop (ğ“ (f (x + y) - f x)) := by
    have L :
      âˆ€á¶  n in atTop, (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x
        = âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine âŸ¨1, fun n hn => ?_âŸ©
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, â† Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      Tendsto (fun n => (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x) atTop
        (ğ“ (f (x + y) - f x)) :=
      (Hf.hasSum y_mem).tendsto_sum_nat.sub tendsto_const_nhds
    exact Tendsto.congr' L this
  have B :
    Tendsto (fun n => q.partialSum n (âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)) atTop
      (ğ“ (g (f (x + y)))) := by
    have Bâ‚ : ContinuousAt (fun z : F => g (f x + z)) (f (x + y) - f x) := by
      refine ContinuousAt.comp ?_ (continuous_const.add continuous_id).continuousAt
      simp only [add_sub_cancel, _root_.id]
      exact Hg.continuousOn.continuousAt (IsOpen.mem_nhds EMetric.isOpen_ball fy_mem)
    have Bâ‚‚ : f (x + y) - f x âˆˆ EMetric.ball (0 : F) rg := by
      simpa [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub] using fy_mem
    rw [â† EMetric.isOpen_ball.nhdsWithin_eq Bâ‚‚] at A
    convert Hg.tendstoLocallyUniformlyOn.tendsto_comp Bâ‚.continuousWithinAt Bâ‚‚ A
    simp only [add_sub_cancel]
  have C :
    Tendsto
      (fun n => âˆ‘ i âˆˆ compPartialSumTarget 0 n n, q.compAlongComposition p i.2 fun _j => y)
      atTop (ğ“ (g (f (x + y)))) := by
    simpa [comp_partialSum] using B
  have D :
    HasSum (fun i : Î£ n, Composition n => q.compAlongComposition p i.2 fun _j => y)
      (g (f (x + y))) :=
    haveI cau :
      CauchySeq fun s : Finset (Î£ n, Composition n) =>
        âˆ‘ i âˆˆ s, q.compAlongComposition p i.2 fun _j => y := by
      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr) _
      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]
      rintro âŸ¨n, câŸ©
      calc
        â€–(compAlongComposition q p c) fun _j : Fin n => yâ€– â‰¤
            â€–compAlongComposition q p câ€– * âˆ _j : Fin n, â€–yâ€– := by
          apply ContinuousMultilinearMap.le_opNorm
        _ â‰¤ â€–compAlongComposition q p câ€– * (r : â„) ^ n := by
          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
          rw [Finset.prod_const, Finset.card_fin]
          apply pow_le_pow_left (norm_nonneg _)
          rw [EMetric.mem_ball, edist_eq_coe_nnnorm] at hy
          have := le_trans (le_of_lt hy) (min_le_right _ _)
          rwa [ENNReal.coe_le_coe, â† NNReal.coe_le_coe, coe_nnnorm] at this
    tendsto_nhds_of_cauchySeq_of_subseq cau compPartialSumTarget_tendsto_atTop C
  have E : HasSum (fun n => (q.comp p) n fun _j => y) (g (f (x + y))) := by
    apply D.sigma
    intro n
    dsimp [FormalMultilinearSeries.comp]
    convert hasSum_fintype (Î± := G) (Î² := Composition n) _
    simp only [ContinuousMultilinearMap.sum_apply]
    rfl
  rw [Function.comp_apply]
  exact E


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
:= by
  rcases hg with âŸ¨rg, HgâŸ©
  rcases hf with âŸ¨rf, HfâŸ©
  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with âŸ¨r, r_pos : 0 < r, hrâŸ©
  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© :
    âˆƒ Î´ : â„â‰¥0âˆ, 0 < Î´ âˆ§ âˆ€ {z : E}, z âˆˆ EMetric.ball x Î´ â†’ f z âˆˆ EMetric.ball (f x) rg := by
    have : EMetric.ball (f x) rg âˆˆ ğ“ (f x) := EMetric.ball_mem_nhds _ Hg.r_pos
    rcases EMetric.mem_nhds_iff.1 (Hf.analyticAt.continuousAt this) with âŸ¨Î´, Î´pos, HÎ´âŸ©
    exact âŸ¨Î´, Î´pos, fun hz => HÎ´ hzâŸ©
  let rf' := min rf Î´
  have min_pos : 0 < min rf' r := by
    simp only [r_pos, Hf.r_pos, Î´pos, lt_min_iff, ENNReal.coe_pos, and_self_iff]
  refine âŸ¨min rf' r, ?_âŸ©
  refine
    âŸ¨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),
      min_pos, @fun y hy => ?_âŸ©
  have y_mem : y âˆˆ EMetric.ball (0 : E) rf :=
    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy
    simpa [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm]
  have A : Tendsto (fun n => âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)
      atTop (ğ“ (f (x + y) - f x)) := by
    have L :
      âˆ€á¶  n in atTop, (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x
        = âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine âŸ¨1, fun n hn => ?_âŸ©
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, â† Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      Tendsto (fun n => (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x
        = âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine âŸ¨1, fun n hn => ?_âŸ©
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, â† Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      Tendsto (fun n => (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x) atTop
        (ğ“ (f (x + y) - f x)) :=
      (Hf.hasSum y_mem).tendsto_sum_nat.sub tendsto_const_nhds
    exact Tendsto.congr' L this
  have B :
    Tendsto (fun n => q.partialSum n (âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)) atTop
      (ğ“ (g (f (x + y) - f x)) := by
    have L :
      âˆ€á¶  n in atTop, (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x
        = âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine âŸ¨1, fun n hn => ?_âŸ©
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, â† Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      

Attempt failure.

---10/100---
For theorem FormalMultilinearSeries.comp_summable_nnreal in Mathlib/Analysis/Analytic/Composition.lean:
theorem comp_summable_nnreal (q : FormalMultilinearSeries ğ•œ F G) (p : FormalMultilinearSeries ğ•œ E F)
    (hq : 0 < q.radius) (hp : 0 < p.radius) :
    âˆƒ r > (0 : â„â‰¥0),
      Summable fun i : Î£ n, Composition n => â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 


Original valid proof:
:= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©
  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos
  obtain âŸ¨Cq, _hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq :=
    q.nnnorm_mul_pow_le_of_lt_radius hrq.2
  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp := by
    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©
    exact âŸ¨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)âŸ©
  let r0 : â„â‰¥0 := (4 * Cp)â»Â¹
  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))
  set r : â„â‰¥0 := rp * rq * r0
  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos
  have I :
    âˆ€ i : Î£ n : â„•, Composition n, â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 â‰¤ Cq / 4 ^ i.1 := by
    rintro âŸ¨n, câŸ©
    have A := calc
      â€–q c.lengthâ€–â‚Š * rq ^ n â‰¤ â€–q c.lengthâ€–â‚Š * rq ^ c.length :=
        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)
      _ â‰¤ Cq := hCq _
    have B := calc
      (âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n = âˆ i, â€–p (c.blocksFun i)â€–â‚Š * rp ^ c.blocksFun i := by
        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]
      _ â‰¤ âˆ _i : Fin c.length, Cp := Finset.prod_le_prod' fun i _ => hCp _
      _ = Cp ^ c.length := by simp
      _ â‰¤ Cp ^ n := pow_le_pow_right hCp1 c.length_le
    calc
      â€–q.compAlongComposition p câ€–â‚Š * r ^ n â‰¤
          (â€–q c.lengthâ€–â‚Š * âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * r ^ n :=
        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl
      _ = â€–q c.lengthâ€–â‚Š * rq ^ n * ((âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n) * r0 ^ n := by
        ring
      _ â‰¤ Cq * Cp ^ n * r0 ^ n := mul_le_mul' (mul_le_mul' A B) le_rfl
      _ = Cq / 4 ^ n := by
        simp only [r0]
        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']
        ring
  refine âŸ¨r, r_pos, NNReal.summable_of_le I ?_âŸ©
  simp_rw [div_eq_mul_inv]
  refine Summable.mul_left _ ?_
  have : âˆ€ n : â„•, HasSum (fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹) (2 ^ (n - 1) / 4 ^ n) := by
    intro n
    convert hasSum_fintype fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹
    simp [Finset.card_univ, composition_card, div_eq_mul_inv]
  refine NNReal.summable_sigma.2 âŸ¨fun n => (this n).summable, (NNReal.summable_nat_add_iff 1).1 ?_âŸ©
  convert (NNReal.summable_geometric (NNReal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4) using 1
  ext1 n
  rw [(this _).tsum_eq, add_tsub_cancel_right]
  field_simp [â† mul_assoc, pow_succ, mul_pow, show (4 : â„â‰¥0) = 2 * 2 by norm_num,
    mul_right_comm]


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
:= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©
  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos
  obtain âŸ¨Cq, _hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq :=
    q.nnnorm_mul_pow_le_of_lt_radius hrq.2
  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp := by
    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©
    exact âŸ¨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)âŸ©
  let r0 : â„â‰¥0 := (4 * Cp)â»Â¹
  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))
  set r : â„â‰¥0 := rp * rq * r0
  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos
  have I :
    âˆ€ i : Î£ n : â„•, Composition n, â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 â‰¤ Cq / 4 ^ i.1 := by
    rintro âŸ¨n, câŸ©
    have A := calc
      â€–q c.lengthâ€–â‚Š * rq ^ n â‰¤ â€–q c.lengthâ€–â‚Š * rq ^ c.length :=
        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)
      _ â‰¤ Cq := hCq _
    have B := calc
      (âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n = âˆ i, â€–p (c.blocksFun i)â€–â‚Š * rp ^ c.blocksFun i := by
        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]
      _ â‰¤ âˆ _i : Fin c.length, Cp := (Finset.prod_le_prod' fun i _ => hCp _)
      _ = Cp ^ c.length := by simp
      _ â‰¤ Cp ^ n := pow_le_pow_right hCp1 c.length_le
    calc
      â€–q.compAlongComposition p câ€–â‚Š * r ^ n â‰¤
          (â€–q c.lengthâ€–â‚Š * âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * r ^ n :=
        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl
      _ = â€–q c.lengthâ€–â‚Š * rq ^ n * ((âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n) * r0 ^ n := by
        simp only [mul_pow]; ring
      _ â‰¤ Cq * Cp ^ n * r0 ^ n := (mul_le_mul' (mul_le_mul' A B) le_rfl)
      _ = Cq / 4 ^ n := by
        simp only [mul_pow]; ring
      _ â‰¤ Cq * Cp ^ n * r0 ^ n := (mul_le_mul' (mul_le_mul' A B) le_rfl)
      _ = Cq / 4 ^ n := by
        simp only [mul_pow]; ring
      _ â‰¤ Cq * Cp ^ n * r0 ^ n := (mul_le_m

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Partition/Split.lean - 2024-09-07 21:46:41.344082.
---11/100---
For theorem BoxIntegral.Prepartition.inf_splitMany in Mathlib/Analysis/BoxIntegral/Partition/Split.lean:
theorem inf_splitMany {I : Box Î¹} (Ï€ : Prepartition I) (s : Finset (Î¹ Ã— â„)) :
    Ï€ âŠ“ splitMany I s = Ï€.biUnion fun J => splitMany J s 


Original valid proof:
:= by
  induction' s using Finset.induction_on with p s _ ihp
  Â· simp
  Â· simp_rw [splitMany_insert, â† inf_assoc, ihp, inf_split, biUnion_assoc]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
:= by
  induction' s using Finset.induction_on with p s _ ihp
  Â· simp
  Â· simp_rw [splitMany_insert, â† inf_assoc, ihp, inf_split, biUnion_assoc]

Attempt success.

Working on Mathlib/Analysis/Calculus/ContDiff/Bounds.lean - 2024-09-07 21:46:51.071301.
---12/100---
For theorem norm_iteratedFDerivWithin_comp_le_aux in Mathlib/Analysis/Calculus/ContDiff/Bounds.lean:
theorem norm_iteratedFDerivWithin_comp_le_aux {Fu Gu : Type u} [NormedAddCommGroup Fu]
    [NormedSpace ğ•œ Fu] [NormedAddCommGroup Gu] [NormedSpace ğ•œ Gu] {g : Fu â†’ Gu} {f : E â†’ Fu} {n : â„•}
    {s : Set E} {t : Set Fu} {x : E} (hg : ContDiffOn ğ•œ n g t) (hf : ContDiffOn ğ•œ n f s)
    (ht : UniqueDiffOn ğ•œ t) (hs : UniqueDiffOn ğ•œ s) (hst : MapsTo f s t) (hx : x âˆˆ s) {C : â„}
    {D : â„} (hC : âˆ€ i, i â‰¤ n â†’ â€–iteratedFDerivWithin ğ•œ i g t (f x)â€– â‰¤ C)
    (hD : âˆ€ i, 1 â‰¤ i â†’ i â‰¤ n â†’ â€–iteratedFDerivWithin ğ•œ i f s xâ€– â‰¤ D ^ i) :
    â€–iteratedFDerivWithin ğ•œ n (g âˆ˜ f) s xâ€– â‰¤ n ! * C * D ^ n 


Original valid proof:
:= by
  induction' n using Nat.case_strong_induction_on with n IH generalizing Gu
  Â· simpa [norm_iteratedFDerivWithin_zero, Nat.factorial_zero, algebraMap.coe_one, one_mul,
      pow_zero, mul_one, comp_apply] using hC 0 le_rfl
  have M : (n : â„•âˆ) < n.succ := Nat.cast_lt.2 n.lt_succ_self
  have Cnonneg : 0 â‰¤ C := (norm_nonneg _).trans (hC 0 bot_le)
  have Dnonneg : 0 â‰¤ D := by
    have : 1 â‰¤ n + 1 := by simp only [le_add_iff_nonneg_left, zero_le']
    simpa only [pow_one] using (norm_nonneg _).trans (hD 1 le_rfl this)
  have I : âˆ€ i âˆˆ Finset.range (n + 1),
      â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– â‰¤ i ! * C * D ^ i := by
    intro i hi
    simp only [Finset.mem_range_succ_iff] at hi
    apply IH i hi
    Â· apply hg.fderivWithin ht
      simp only [Nat.cast_succ]
      exact add_le_add_right (Nat.cast_le.2 hi) _
    Â· apply hf.of_le (Nat.cast_le.2 (hi.trans n.le_succ))
    Â· intro j hj
      have : â€–iteratedFDerivWithin ğ•œ j (fderivWithin ğ•œ g t) t (f x)â€– =
          â€–iteratedFDerivWithin ğ•œ (j + 1) g t (f x)â€– := by
        rw [iteratedFDerivWithin_succ_eq_comp_right ht (hst hx), comp_apply,
          LinearIsometryEquiv.norm_map]
      rw [this]
      exact hC (j + 1) (add_le_add (hj.trans hi) le_rfl)
    Â· intro j hj h'j
      exact hD j hj (h'j.trans (hi.trans n.le_succ))
  have J : âˆ€ i, â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– â‰¤ D ^ (n - i + 1) := by
    intro i
    have : â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ (n - i + 1) f s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply, LinearIsometryEquiv.norm_map]
    rw [this]
    apply hD
    Â· simp only [le_add_iff_nonneg_left, zero_le']
    Â· apply Nat.succ_le_succ tsub_le_self
  calc
    â€–iteratedFDerivWithin ğ•œ (n + 1) (g âˆ˜ f) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ n (fun y : E => fderivWithin ğ•œ (g âˆ˜ f) s y) s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply,
        LinearIsometryEquiv.norm_map]
    _ = â€–iteratedFDerivWithin ğ•œ n (fun y : E => ContinuousLinearMap.compL ğ•œ E Fu Gu
        (fderivWithin ğ•œ g t (f y)) (fderivWithin ğ•œ f s y)) s xâ€– := by
      have L : (1 : â„•âˆ) â‰¤ n.succ := by simpa only [ENat.coe_one, Nat.one_le_cast] using n.succ_pos
      congr 1
      refine iteratedFDerivWithin_congr (fun y hy => ?_) hx _
      apply fderivWithin.comp _ _ _ hst (hs y hy)
      Â· exact hg.differentiableOn L _ (hst hy)
      Â· exact hf.differentiableOn L _ hy
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1),
        (n.choose i : â„) * â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– *
          â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– := by
      have A : ContDiffOn ğ•œ n (fderivWithin ğ•œ g t âˆ˜ f) s := by
        apply ContDiffOn.comp _ (hf.of_le M.le) hst
        apply hg.fderivWithin ht
        simp only [Nat.cast_succ, le_refl]
      have B : ContDiffOn ğ•œ n (fderivWithin ğ•œ f s) s := by
        apply hf.fderivWithin hs
        simp only [Nat.cast_succ, le_refl]
      exact (ContinuousLinearMap.compL ğ•œ E Fu Gu).norm_iteratedFDerivWithin_le_of_bilinear_of_le_one
        A B hs hx le_rfl (ContinuousLinearMap.norm_compL_le ğ•œ E Fu Gu)
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1), (n.choose i : â„) * (i ! * C * D ^ i) * D ^ (n - i + 1) := by
      gcongr with i hi
      Â· exact I i hi
      Â· exact J i
    _ = âˆ‘ i âˆˆ Finset.range (n + 1),
        (n ! : â„) * ((i ! : â„)â»Â¹ * i !) * C * (D ^ i * D ^ (n - i + 1)) * ((n - i)! : â„)â»Â¹ := by
      congr! 1 with i hi
      simp only [Nat.cast_choose â„ (Finset.mem_range_succ_iff.1 hi), div_eq_inv_mul, mul_inv]
      ring
    _ = âˆ‘ i âˆˆ Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * ((n - i)! : â„)â»Â¹ := by
      congr! with i hi
      Â· apply inv_mul_cancel
        simpa only [Ne, Nat.cast_eq_zero] using i.factorial_ne_zero
      Â· rw [â† pow_add]
        congr 1
        rw [Nat.add_succ, Nat.succ_inj']
        exact Nat.add_sub_of_le (Finset.mem_range_succ_iff.1 hi)
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * 1 := by
      gcongr with i
      apply inv_le_one
      simpa only [Nat.one_le_cast] using (n - i).factorial_pos
    _ = (n + 1)! * C * D ^ (n + 1) := by
      simp only [mul_assoc, mul_one, Finset.sum_const, Finset.card_range, nsmul_eq_mul,
        Nat.factorial_succ, Nat.cast_mul]


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
:= by
  induction' n using Nat.case_strong_induction_on with n IH generalizing Gu
  Â· simpa [norm_iteratedFDerivWithin_zero, Nat.factorial_zero, algebraMap.coe_one, one_mul,
      pow_zero, mul_one, comp_apply] using hC 0 le_rfl
  have M : (n : â„•âˆ) < n.succ := Nat.cast_lt.2 n.lt_succ_self
  have Cnonneg : 0 â‰¤ C := (norm_nonneg _).trans (hC 0 bot_le)
  have Dnonneg : 0 â‰¤ D := by
    have : 1 â‰¤ n + 1 := by simp only [le_add_iff_nonneg_left, zero_le']
    simpa only [pow_one] using (norm_nonneg _).trans (hD 1 le_rfl this)
  have I : âˆ€ i âˆˆ Finset.range (n + 1),
      â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– â‰¤ i ! * C * D ^ i := by
    intro i hi
    simp only [Finset.mem_range_succ_iff] at hi
    apply IH i hi
    Â· apply hg.fderivWithin ht
      simp only [Nat.cast_succ]
      exact add_le_add_right (Nat.cast_le.2 hi) _
    Â· apply hf.of_le (Nat.cast_le.2 (hi.trans n.le_succ))
    Â· intro j hj
      have : â€–iteratedFDerivWithin ğ•œ j (fderivWithin ğ•œ g t) t (f x)â€– =
          â€–iteratedFDerivWithin ğ•œ (j + 1) g t (f x)â€– :=
        by rw [iteratedFDerivWithin_succ_eq_comp_right ht (hst hx), comp_apply,
          LinearIsometryEquiv.norm_map]
      rw [this]
      exact hC (j + 1) (add_le_add (hj.trans hi) le_rfl)
    Â· intro j hj h'j
      exact hD j hj (h'j.trans (hi.trans n.le_succ))
  have J : âˆ€ i, â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ (j + 1) g t (f x)â€– :=
        by rw [iteratedFDerivWithin_succ_eq_comp_right ht (hst hx), comp_apply,
          LinearIsometryEquiv.norm_map]
      rw [this]
      exact hC (j + 1) (add_le_add (hj.trans hi) le_rfl)
    Â· intro j hj h'j
      exact hD j hj (h'j.trans (hi.trans n.le_succ))
  have J : âˆ€ i, â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– â‰¤ D ^ (n - i + 1) := by
    intro i
    have : â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ (n - i + 1) f s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply, LinearIsometryEquiv.norm_map]
    rw [this]
    apply hD
    Â· simp only [le_add_iff_nonneg_left, zero_le']
    Â· apply Nat.succ_le_succ tsub_le_self
  calc
    â€–iteratedFDerivWithin ğ•œ (n + 1) (g âˆ˜ f) s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply, LinearIsometryEquiv.norm_map]
    rw [this]
    apply hD
    Â· simp only [le_add_iff_nonneg_left, zero_le']
    Â· apply Nat.succ_le_succ tsub_le_sel

Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean - 2024-09-07 21:47:16.702307.
---13/100---
For theorem Convex.taylor_approx_two_segment in Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean:
theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v âˆˆ interior s)
    (hw : x + v + w âˆˆ interior s) :
    (fun h : â„ => f (x + h â€¢ v + h â€¢ w)
        - f (x + h â€¢ v) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (h ^ 2 / 2) â€¢ f'' w w) =o[ğ“[>] 0]
      fun h => h ^ 2 


Original valid proof:
:= by
  refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun Îµ Îµpos => ?_) (isBigO_const_mul_self ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) _ _)
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx Îµpos) with âŸ¨Î´, Î´pos, sÎ´âŸ©
  have E1 : âˆ€á¶  h in ğ“[>] (0 : â„), h * (â€–vâ€– + â€–wâ€–) < Î´ := by
    have : Filter.Tendsto (fun h => h * (â€–vâ€– + â€–wâ€–)) (ğ“[>] (0 : â„)) (ğ“ (0 * (â€–vâ€– + â€–wâ€–))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 Î´
    simpa only [zero_mul] using Î´pos
  have E2 : âˆ€á¶  h in ğ“[>] (0 : â„), (h : â„) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      âŸ¨(1 : â„), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2âŸ©
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hÎ´ h_lt_1 hpos
  replace hpos : 0 < h := hpos
  have xt_mem : âˆ€ t âˆˆ Icc (0 : â„) 1, x + h â€¢ v + (t * h) â€¢ w âˆˆ interior s := by
    intro t ht
    have : x + h â€¢ v âˆˆ interior s := s_conv.add_smul_mem_interior xs hv âŸ¨hpos, h_lt_1.leâŸ©
    rw [â† smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    rw [add_assoc, â† smul_add]
    exact s_conv.add_smul_mem_interior xs hw âŸ¨hpos, h_lt_1.leâŸ©
  let g t :=
    f (x + h â€¢ v + (t * h) â€¢ w) - (t * h) â€¢ f' x w - (t * h ^ 2) â€¢ f'' v w -
      ((t * h) ^ 2 / 2) â€¢ f'' w w
  set g' := fun t =>
    f' (x + h â€¢ v + (t * h) â€¢ w) (h â€¢ w) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (t * h ^ 2) â€¢ f'' w w
    with hg'
  have g_deriv : âˆ€ t âˆˆ Icc (0 : â„) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    Â· refine (hf _ ?_).comp_hasDerivWithinAt _ ?_
      Â· exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,
        hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) â€¢ f'' w w)
          ((((2 : â„•) : â„) * (t * h) ^ (2 - 1) * (1 * h) / 2) â€¢ f'' w w) (Icc 0 1) t by
        convert H using 2
        ring
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',
        HasDerivAt.pow, HasDerivAt.mul_const]
  have g'_bound : âˆ€ t âˆˆ Ico (0 : â„) 1, â€–g' tâ€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    intro t ht
    have I : â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ h * (â€–vâ€– + â€–wâ€–) :=
      calc
        â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ â€–h â€¢ vâ€– + â€–(t * h) â€¢ wâ€– := norm_add_le _ _
        _ = h * â€–vâ€– + t * (h * â€–wâ€–) := by
          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,
            mul_assoc]
        _ â‰¤ h * â€–vâ€– + 1 * (h * â€–wâ€–) := by gcongr; exact ht.2.le
        _ = h * (â€–vâ€– + â€–wâ€–) := by ring
    calc
      â€–g' tâ€– = â€–(f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)) (h â€¢ w)â€– := by
        rw [hg']
        have : h * (t * h) = t * (h * h) := by ring
        simp only [ContinuousLinearMap.coe_sub', ContinuousLinearMap.map_add, pow_two,
          ContinuousLinearMap.add_apply, Pi.smul_apply, smul_sub, smul_add, smul_smul, â† sub_sub,
          ContinuousLinearMap.coe_smul', Pi.sub_apply, ContinuousLinearMap.map_smul, this]
      _ â‰¤ â€–f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)â€– * â€–h â€¢ wâ€– :=
        (ContinuousLinearMap.le_opNorm _ _)
      _ â‰¤ Îµ * â€–h â€¢ v + (t * h) â€¢ wâ€– * â€–h â€¢ wâ€– := by
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        have H : x + h â€¢ v + (t * h) â€¢ w âˆˆ Metric.ball x Î´ âˆ© interior s := by
          refine âŸ¨?_, xt_mem t âŸ¨ht.1, ht.2.leâŸ©âŸ©
          rw [add_assoc, add_mem_ball_iff_norm]
          exact I.trans_lt hÎ´
        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel_left] using sÎ´ H
      _ â‰¤ Îµ * (â€–h â€¢ vâ€– + â€–h â€¢ wâ€–) * â€–h â€¢ wâ€– := by
        gcongr
        apply (norm_add_le _ _).trans
        gcongr
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]
        exact mul_le_of_le_one_left (mul_nonneg hpos.le (norm_nonneg _)) ht.2.le
      _ = Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring
  have I : â€–g 1 - g 0â€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    simpa only [mul_one, sub_zero] using
      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)
  convert I using 1
  Â· congr 1
    simp only [g, Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,
      zero_smul, Ne, not_false_iff, bit0_eq_zero, zero_pow]
    abel
  Â· simp only [Real.norm_eq_abs, abs_mul, add_nonneg (norm_nonneg v) (norm_nonneg w), abs_of_nonneg,
      hpos.le, mul_assoc, norm_nonneg, abs_pow]


Verifying proof (Commit 05dd33777bb0a96c66523df7c7d1a34b2d9a1be5):
:= by
  refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun Îµ Îµpos => ?_) (isBigO_const_mul_self ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) _ _)
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx Îµpos) with âŸ¨Î´, Î´pos, sÎ´âŸ©
  have E1 : âˆ€á¶  h in ğ“[>] (0 : â„), h * (â€–vâ€– + â€–wâ€–) < Î´ := by
    have : Filter.Tendsto (fun h => h * (â€–vâ€– + â€–wâ€–)) (ğ“[>] (0 : â„)) (ğ“ (0 * (â€–vâ€– + â€–wâ€–))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 Î´
    simpa only [zero_mul] using Î´pos
  have E2 : âˆ€á¶  h in ğ“[>] (0 : â„), (h : â„) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      âŸ¨(1 : â„), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2âŸ©
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hÎ´ h_lt_1 hpos
  replace hpos : 0 < h := hpos
  have xt_mem : âˆ€ t âˆˆ Icc (0 : â„) 1, x + h â€¢ v + (t * h) â€¢ w âˆˆ interior s := by
    intro t ht
    have : x + h â€¢ v âˆˆ interior s := s_conv.add_smul_mem_interior xs hv âŸ¨hpos, h_lt_1.leâŸ©
    rw [â† smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    rw [add_assoc, â† smul_add]
    exact s_conv.add_smul_mem_interior xs hw âŸ¨hpos, h_lt_1.leâŸ©
  let g t :=
    f (x + h â€¢ v + (t * h) â€¢ w) - (t * h) â€¢ f' x w - (t * h ^ 2) â€¢ f'' v w -
      ((t * h) ^ 2 / 2) â€¢ f'' w w
  set g' := fun t =>
    f' (x + h â€¢ v + (t * h) â€¢ w) (h â€¢ w) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (t * h ^ 2) â€¢ f'' w w
    with hg'
  have g_deriv : âˆ€ t âˆˆ Icc (0 : â„) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    Â· refine (hf _ _).comp_hasDerivWithinAt _ ?_
      Â· exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) â€¢ f'' w w)
          ((((2 : â„•) : â„) * (t * h) ^ (2 - 1) * (1 * h) â€¢ f' x w - (t * h ^ 2) â€¢ f'' w w
    with hg'
  have g_deriv : âˆ€ t âˆˆ Icc (0 : â„) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    Â· refine (hf _ _).comp_hasDerivWithinAt _ ?_
      Â· exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· apply_rules [Ha

Attempt failure.

Working on Mathlib/Analysis/Calculus/LagrangeMultipliers.lean - 2024-09-07 21:47:38.187253.
---14/100---
For theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d in Mathlib/Analysis/Calculus/LagrangeMultipliers.lean:
theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d {f : E â†’ â„} {f' : E â†’L[â„] â„}
    (hextr : IsLocalExtrOn Ï† {x | f x = f xâ‚€} xâ‚€) (hf' : HasStrictFDerivAt f f' xâ‚€)
    (hÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€) : âˆƒ a b : â„, (a, b) â‰  0 âˆ§ a â€¢ f' + b â€¢ Ï†' = 0 


Original valid proof:
:= by
  obtain âŸ¨Î›, Î›â‚€, hÎ›, hfÎ›âŸ© := hextr.exists_linear_map_of_hasStrictFDerivAt hf' hÏ†'
  refine âŸ¨Î› 1, Î›â‚€, ?_, ?_âŸ©
  Â· contrapose! hÎ›
    simp only [Prod.mk_eq_zero] at hÎ› âŠ¢
    refine âŸ¨LinearMap.ext fun x => ?_, hÎ›.2âŸ©
    simpa [hÎ›.1] using Î›.map_smul x 1
  Â· ext x
    have Hâ‚ : Î› (f' x) = f' x * Î› 1 := by
      simpa only [mul_one, Algebra.id.smul_eq_mul] using Î›.map_smul (f' x) 1
    have Hâ‚‚ : f' x * Î› 1 + Î›â‚€ * Ï†' x = 0 := by simpa only [Algebra.id.smul_eq_mul, Hâ‚] using hfÎ› x
    simpa [mul_comm] using Hâ‚‚


Verifying proof (Commit b15c6ea0b0ad3ac6e15420c45ece165eca6725cc):
:= by
  obtain âŸ¨Î›, Î›â‚€, hÎ›, hfÎ›âŸ© := hextr.exists_linear_map_of_hasStrictFDerivAt hf' hÏ†'
  refine âŸ¨Î› 1, Î›â‚€, ?_, ?_âŸ©
  Â· contrapose! hÎ›
    simp only [Prod.mk_eq_zero] at hÎ› âŠ¢
    refine âŸ¨LinearMap.ext fun x => ?_, hÎ›.2âŸ©
    simpa [hÎ›.1] using Î›.map_smul x 1
  Â· ext x
    have Hâ‚ : Î› (f' x) = f' x * Î› 1 := by
      simpa only [mul_one, Algebra.id.smul_eq_mul] using hfÎ› x
    dsimp
    rw [Pi.smul_apply]
    simpa [mul_comm] using Hâ‚‚

Attempt failure.

Working on Mathlib/Analysis/Convex/Caratheodory.lean - 2024-09-07 21:47:49.432846.
---15/100---
For theorem convexHull_eq_union in Mathlib/Analysis/Convex/Caratheodory.lean:
theorem convexHull_eq_union : convexHull ğ•œ s =
    â‹ƒ (t : Finset E) (hss : â†‘t âŠ† s) (hai : AffineIndependent ğ•œ ((â†‘) : t â†’ E)), convexHull ğ•œ â†‘t 


Original valid proof:
:= by
  apply Set.Subset.antisymm
  Â· intro x hx
    simp only [exists_prop, Set.mem_iUnion]
    exact âŸ¨Caratheodory.minCardFinsetOfMemConvexHull hx,
      Caratheodory.minCardFinsetOfMemConvexHull_subseteq hx,
      Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull hx,
      Caratheodory.mem_minCardFinsetOfMemConvexHull hxâŸ©
  Â· iterate 3 convert Set.iUnion_subset _; intro
    exact convexHull_mono â€¹_â€º


Verifying proof (Commit 6b5a6157526632a0d26108670d5a71f9223c87fd):
:= by
  apply Set.Subset.antisymm
  Â· intro x hx
    simp only [exists_prop, Set.mem_union]
    exact âŸ¨Caratheodory.minCardFinsetOfMemConvexHull hx,
      Caratheodory.mem_minCardFinsetOfMemConvexHull hxâŸ©
  Â· iterate 3 convert Set.union_subset _; intro
    exact convexHull_mono â€¹_â€º

Attempt failure.

Working on Mathlib/Analysis/Convex/Intrinsic.lean - 2024-09-07 21:47:57.842724.
---16/100---
For theorem intrinsicClosure_eq_closure in Mathlib/Analysis/Convex/Intrinsic.lean:
theorem intrinsicClosure_eq_closure : intrinsicClosure ğ•œ s = closure s 


Original valid proof:
:= by
  ext x
  simp only [mem_closure_iff, mem_intrinsicClosure]
  refine âŸ¨?_, fun h => âŸ¨âŸ¨x, _âŸ©, ?_, Subtype.coe_mk _ ?_âŸ©âŸ©
  Â· rintro âŸ¨x, h, rflâŸ© t ht hx
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (continuous_induced_dom.isOpen_preimage t ht) hx
    exact âŸ¨z, hzâ‚, hzâ‚‚âŸ©
  Â· rintro _ âŸ¨t, ht, rflâŸ© hx
    obtain âŸ¨y, hyt, hysâŸ© := h _ ht hx
    exact âŸ¨âŸ¨_, subset_affineSpan ğ•œ s hysâŸ©, hyt, hysâŸ©
  Â· by_contra hc
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (affineSpan ğ•œ s).closed_of_finiteDimensional.isOpen_compl hc
    exact hzâ‚ (subset_affineSpan ğ•œ s hzâ‚‚)


Verifying proof (Commit ded82be28af61da8cf3266077ac67ad9bf41c841):
:= by
  ext x
  simp only [mem_closure_iff, mem_intrinsicClosure]
  refine âŸ¨?_, fun h => âŸ¨âŸ¨x, ?_âŸ©?, ?_, Subtype.coe_mk _ ?_âŸ©âŸ©
  Â· rintro âŸ¨x, h, rflâŸ© t ht hx
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (continuous_induced_dom.isOpen_preimage t ht) hx
    exact âŸ¨z, hzâ‚, hzâ‚‚âŸ©
  Â· rintro _ âŸ¨t, ht, rflâŸ© hx
    obtain âŸ¨y, hyt, hysâŸ© := h _ ht hx
    exact âŸ¨âŸ¨_, subset_affineSpan ğ•œ s hysâŸ©, hyt, hysâŸ©
  Â· by_contra hc
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (continuous_induced_dom.isOpen_preimage t ht) hx
    exact âŸ¨z, hzâ‚, hzâ‚‚âŸ©
  Â· rintro _ âŸ¨t, ht, rflâŸ© hx
    obtain âŸ¨y, hyt, hysâŸ© := h _ ht hx
    exact âŸ¨âŸ¨_, subset_affineSpan ğ•œ s hysâŸ©, hyt, hysâŸ©
  Â· by_contra hc
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (continuous_induced_dom.isOpen_preimage t ht) hx
    exact âŸ¨z, hzâ‚, hzâ‚‚âŸ©
  Â· rintro _ âŸ¨t, ht, rflâŸ© hx
    obtain âŸ¨y, hyt, hysâŸ© := h _ ht hx
    exact âŸ¨âŸ¨_, subset_affineSpan ğ•œ s hysâŸ©, hyt, hysâŸ©
  Â· by_contra hc
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (affineSpan ğ•œ s).closed_of_finiteDimensional.isOpen_compl hc
    exact hzâ‚ (subset_affineSpan ğ•œ s hzâ‚‚)

Attempt failure.

Working on Mathlib/Analysis/Convex/Mul.lean - 2024-09-07 21:48:12.638317.
---17/100---
For theorem ConcaveOn.smul' in Mathlib/Analysis/Convex/Mul.lean:
lemma ConcaveOn.smul' (hf : ConcaveOn ğ•œ s f) (hg : ConcaveOn ğ•œ s g) (hfâ‚€ : âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ 0 â‰¤ f x)
    (hgâ‚€ : âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ 0 â‰¤ g x) (hfg : AntivaryOn f g s) : ConcaveOn ğ•œ s (f â€¢ g) 


Original valid proof:
:= by
  refine âŸ¨hf.1, fun x hx y hy a b ha hb hab â†¦ ?_âŸ©
  dsimp
  refine (smul_le_smul (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab)
    (add_nonneg (smul_nonneg ha <| hfâ‚€ hx) <| smul_nonneg hb <| hfâ‚€ hy)
    (hgâ‚€ <| hf.1 hx hy ha hb hab)).trans' ?_
  calc a â€¢ f x â€¢ g x + b â€¢ f y â€¢ g y
        = (a * (a + b)) â€¢ (f x â€¢ g x) + (b * (a + b)) â€¢ (f y â€¢ g y) := by simp_rw [hab, mul_one]
    _ = (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g x + f y â€¢ g y) := by
        simp only [mul_add, add_smul, smul_add, mul_comm _ a]; abel
    _ â‰¤ (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g y + f y â€¢ g x) := by
        gcongr _ + (a * b) â€¢ ?_; exact hfg.smul_add_smul_le_smul_add_smul hx hy
    _ = _ := ?_
  simp only [mul_add, add_smul, smul_add]
  rw [â† smul_smul_smul_comm a, â† smul_smul_smul_comm b, â† smul_smul_smul_comm a b,
    â† smul_smul_smul_comm b b, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_comm b a,
    add_comm ((a * b) â€¢ f x â€¢ g y), add_comm ((a * b) â€¢ f x â€¢ g y), add_add_add_comm]


Verifying proof (Commit 5fb9beab28702fb284701d494bc9b7c5f52fef53):
:= by
  refine âŸ¨hf.1, fun x hx y hy a b ha hb hab â†¦ ?_âŸ©
  dsimp
  refine (smul_le_smul (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab) (add_nonneg
    (smul_nonneg ha $ hgâ‚€ hx) $ smul_nonneg hb $ hgâ‚€ hy) <| hfâ‚€ <| hf.1 hx hy ha hb hab).trans' ?_
  calc a â€¢ f x â€¢ g x + b â€¢ f y â€¢ g y
        = (a * (a + b)) â€¢ (f x â€¢ g x) + (b * (a + b)) â€¢ (f y â€¢ g y) := by simp_rw [hab, mul_one]
    _ = (a * a) â€¢ (f x â€¢ g x) + (b * (a + b)) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g x + f y â€¢ g y) := by
        simp only [mul_add, add_smul, smul_add, mul_comm _ a]; abel
    _ â‰¤ (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g y + f y â€¢ g y) := by
        simp only [mul_add, add_smul, smul_add, mul_comm _ a]; abel
    _ â‰¤ (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g y + f y â€¢ g y) := by
        simp only [mul_add, add_smul, smul_add, mul_comm _ a]; abel
    _ â‰¤ (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g y + f y â€¢ g x) := by
        gcongr _ + (a * b) â€¢ ?_; exact hfg.smul_add_smul_le_smul_add_smul hx hy
    _ = _ := ?_
  simp only [mul_add, add_smul, smul_add]
  rw [â† smul_smul_smul_comm a, â† smul_smul_smul_comm b, â† smul_smul_smul_comm a b,
    â† smul_smul_smul_comm b b, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_comm b a,
    â† smul_smul_smul_comm b b, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_comm b a,
    â† smul_smul_smul_comm b b, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_comm b a,
    â† smul_smul_smul_comm b b, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_comm b a,
    add_comm ((a * b) â€¢ f x â€¢ g y), add_comm ((a * b) â€¢ f x â€¢ g y), add_add_add_comm]

Attempt failure.

Working on Mathlib/Analysis/Convolution.lean - 2024-09-07 21:48:28.905924.
---18/100---
For theorem MeasureTheory.continuousOn_convolution_right_with_param in Mathlib/Analysis/Convolution.lean:
theorem continuousOn_convolution_right_with_param {g : P â†’ G â†’ E'} {s : Set P} {k : Set G}
    (hk : IsCompact k) (hgs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0)
    (hf : LocallyIntegrable f Î¼) (hg : ContinuousOn (â†¿g) (s Ã—Ë¢ univ)) :
    ContinuousOn (fun q : P Ã— G => (f â‹†[L, Î¼] g q.1) q.2) (s Ã—Ë¢ univ) 


Original valid proof:
:= by
  by_cases H : âˆ€ p âˆˆ s, âˆ€ x, g p x = 0
  Â· apply (continuousOn_const (c := 0)).congr
    rintro âŸ¨p, xâŸ© âŸ¨hp, -âŸ©
    apply integral_eq_zero_of_ae (eventually_of_forall (fun y â†¦ ?_))
    simp [H p hp _]
  have : LocallyCompactSpace G := by
    push_neg at H
    rcases H with âŸ¨p, hp, x, hxâŸ©
    have A : support (g p) âŠ† k := support_subset_iff'.2 (fun y hy â†¦ hgs p y hp hy)
    have B : Continuous (g p) := by
      refine hg.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
      simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp
    rcases eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_addGroup hk A B with H|H
    Â· simp [H] at hx
    Â· exact H
  rintro âŸ¨qâ‚€, xâ‚€âŸ© âŸ¨hqâ‚€, -âŸ©
  obtain âŸ¨t, t_comp, htâŸ© : âˆƒ t, IsCompact t âˆ§ t âˆˆ ğ“ xâ‚€ := exists_compact_mem_nhds xâ‚€
  let k' : Set G := (-k) +áµ¥ t
  have k'_comp : IsCompact k' := IsCompact.vadd_set hk.neg t_comp
  let g' : (P Ã— G) â†’ G â†’ E' := fun p x â†¦ g p.1 (p.2 - x)
  let s' : Set (P Ã— G) := s Ã—Ë¢ t
  have A : ContinuousOn g'.uncurry (s' Ã—Ë¢ univ) := by
    have : g'.uncurry = g.uncurry âˆ˜ (fun w â†¦ (w.1.1, w.1.2 - w.2)) := by ext y; rfl
    rw [this]
    refine hg.comp (continuous_fst.fst.prod_mk (continuous_fst.snd.sub
      continuous_snd)).continuousOn ?_
    simp (config := {contextual := true}) [s', MapsTo]
  have B : ContinuousOn (fun a â†¦ âˆ« x, L (f x) (g' a x) âˆ‚Î¼) s' := by
    apply continuousOn_integral_bilinear_of_locally_integrable_of_compact_support L k'_comp A _
      (hf.integrableOn_isCompact k'_comp)
    rintro âŸ¨p, xâŸ© y âŸ¨hp, hxâŸ© hy
    apply hgs p _ hp
    contrapose! hy
    exact âŸ¨y - x, by simpa using hy, x, hx, by simpâŸ©
  apply ContinuousWithinAt.mono_of_mem (B (qâ‚€, xâ‚€) âŸ¨hqâ‚€, mem_of_mem_nhds htâŸ©)
  exact mem_nhdsWithin_prod_iff.2 âŸ¨s, self_mem_nhdsWithin, t, nhdsWithin_le_nhds ht, Subset.rflâŸ©


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
:= by
  by_cases H : âˆ€ p âˆˆ s, âˆ€ x, g p x = 0
  Â· apply (continuousOn_const (c := 0)).congr
    rintro âŸ¨p, xâŸ© âŸ¨hp, -âŸ©
    apply integral_eq_zero_of_ae (eventually_of_forall (fun y â†¦ ?_))
    simp [H p hp _]
  have : LocallyCompactSpace G := by
    push_neg at H
    rcases H with âŸ¨p, hp, x, hxâŸ©
    have A : support (g p) âŠ† k := support_subset_iff'.2 (fun y hy â†¦ hgs p y hp hy)
    have B : Continuous (g p) := by
      refine hg.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
      simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp
    rcases eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_addGroup hk A B with H|H
    Â· simp [H] at hx
    Â· exact H
  rintro âŸ¨qâ‚€, xâ‚€âŸ© âŸ¨hqâ‚€, -âŸ©
  obtain âŸ¨t, t_comp, htâŸ© : âˆƒ t, IsCompact t âˆ§ t âˆˆ ğ“ xâ‚€ := exists_compact_mem_nhds xâ‚€
  let k' : Set G := (-k) +áµ¥ t
  have k'_comp : IsCompact k' := IsCompact.vadd_set hk.neg t_comp
  let g' : (P Ã— G) â†’ G â†’ E' := fun p x â†¦ g p.1 (p.2 - x)
  let s' : Set (P Ã— G) := s Ã—Ë¢ t
  have A : ContinuousOn g'.uncurry (s' Ã—Ë¢ univ) := by
    have : g'.uncurry = g.uncurry âˆ˜ (fun w â†¦ (w.1.1, w.1.2 - w.2)) := by ext y; rfl
    rw [this]
    refine hg.comp (continuous_fst.fst.prod_mk (continuous_fst.snd.sub
      continuous_snd)).continuousOn ?_
    simp (config := {contextual := true}) [MapsTo]
  have B : ContinuousOn (fun a â†¦ âˆ« x, L (f x) (g' a x) âˆ‚Î¼) s' := by
    apply continuousOn_integral_bilinear_of_locally_integrable_of_compact_support L k'_comp A _
      (hf.integrableOn_isCompact k'_comp)
    rintro âŸ¨p, xâŸ© y âŸ¨hp, hxâŸ© hy
    apply hgs p _ hp
    contrapose! hy
    exact âŸ¨y - x, by simpa using hy, x, hx, by simpâŸ©
  apply ContinuousWithinAt.mono_of_mem (B (qâ‚€, xâ‚€) âŸ¨hqâ‚€, mem_of_mem_nhds htâŸ©)
  exact mem_nhdsWithin_prod_iff.2 âŸ¨s, self_mem_nhdsWithin, t, nhdsWithin_le_nhds ht, Subset.rflâŸ©

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Positive.lean - 2024-09-07 21:52:52.797717.
---19/100---
For theorem ContinuousLinearMap.isPositive_one in Mathlib/Analysis/InnerProductSpace/Positive.lean:
theorem isPositive_one : IsPositive (1 : E â†’L[ğ•œ] E) 


Original valid proof:
:=
  âŸ¨isSelfAdjoint_one _, fun _ => inner_self_nonnegâŸ©


Verifying proof (Commit 1c643aca968064296312bf5328c84d0c50cfe5ae):
:=
  âŸ¨.one _, fun _ => inner_self_nonnegâŸ©

Attempt failure.

Working on Mathlib/Analysis/SpecificLimits/Normed.lean - 2024-09-07 21:53:05.407667.
---20/100---
For theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one in Mathlib/Analysis/SpecificLimits/Normed.lean:
theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : â„•) {r : â„} (hr : |r| < 1) :
    Tendsto (fun n â†¦ (n : â„) ^ k * r ^ n : â„• â†’ â„) atTop (ğ“ 0) 


Original valid proof:
:= by
  by_cases h0 : r = 0
  Â· exact tendsto_const_nhds.congr'
      (mem_atTop_sets.2 âŸ¨1, fun n hn â†¦ by simp [zero_lt_one.trans_le hn |>.ne', h0]âŸ©)
  have hr' : 1 < |r|â»Â¹ := one_lt_inv (abs_pos.2 h0) hr
  rw [tendsto_zero_iff_norm_tendsto_zero]
  simpa [div_eq_mul_inv] using tendsto_pow_const_div_const_pow_of_one_lt k hr'


Verifying proof (Commit e234e64075504db13790aa471a4239039c94703b):
:= by
  by_cases h0 : r = 0
  Â· exact tendsto_const_nhds.congr'
      (mem_atTop_sets.2 âŸ¨1, fun n hn â†¦ by simp [zero_lt_one.trans_le hn, h0]âŸ©)
  have hr' : 1 < (|r|)â»Â¹ := one_lt_inv (abs_pos.2 h0) hr
  rw [tendsto_zero_iff_norm_tendsto_zero]
  simpa [div_eq_mul_inv] using tendsto_pow_of_one_lt k hr'

Attempt failure.

Working on Mathlib/CategoryTheory/EqToHom.lean - 2024-09-07 21:53:19.417754.
---21/100---
For theorem CategoryTheory.congrArg_cast_hom_left in Mathlib/CategoryTheory/EqToHom.lean:
theorem congrArg_cast_hom_left {X Y Z : C} (p : X = Y) (q : Y âŸ¶ Z) :
    cast (congrArg (fun W : C => W âŸ¶ Z) p.symm) q = eqToHom p â‰« q 


Original valid proof:
:= by
  cases p
  simp


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  cases p
  simp
  theorem congrArg_mpr_hom_left {X Y Z : C} (p : X = Y) (q : Y âŸ¶ Z) :
    (congrArg (fun W : C => W âŸ¶ Z) p).mpr q = eqToHom p â‰« q := by
  cases p
  simp

Attempt failure.

Working on Mathlib/CategoryTheory/EssentialImage.lean - 2024-09-07 21:53:25.058837.
---22/100---
For theorem CategoryTheory.Functor.essImage_eq_of_natIso in Mathlib/CategoryTheory/EssentialImage.lean:
theorem essImage_eq_of_natIso {F' : C â¥¤ D} (h : F â‰… F') : essImage F = essImage F' 


Original valid proof:
:=
  funext fun _ => propext âŸ¨essImage.ofNatIso h, essImage.ofNatIso h.symmâŸ©


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):
:=
  congrArg Set.ofPred <| funext fun _ => propext âŸ¨essImage.ofNatIso h, essImage.ofNatIso h.symmâŸ©

Attempt failure.

Working on Mathlib/CategoryTheory/GradedObject/Associator.lean - 2024-09-07 21:53:30.246465.
---23/100---
For theorem CategoryTheory.GradedObject.Î¹_mapBifunctorAssociator_inv in Mathlib/CategoryTheory/GradedObject/Associator.lean:
lemma Î¹_mapBifunctorAssociator_inv (iâ‚ : Iâ‚) (iâ‚‚ : Iâ‚‚) (iâ‚ƒ : Iâ‚ƒ) (j : J) (h : r (iâ‚, iâ‚‚, iâ‚ƒ) = j) :
    Î¹MapBifunctorBifunctorâ‚‚â‚ƒMapObj F Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h â‰«
      (mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).inv j =
    ((associator.inv.app (Xâ‚ iâ‚)).app (Xâ‚‚ iâ‚‚)).app (Xâ‚ƒ iâ‚ƒ) â‰«
      Î¹MapBifunctorâ‚â‚‚BifunctorMapObj Fâ‚â‚‚ G Ïâ‚â‚‚ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h 


Original valid proof:
:= by
  rw [â† cancel_mono ((mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom j),
    assoc, assoc, Iso.inv_hom_id_eval, comp_id, Î¹_mapBifunctorAssociator_hom,
    â† NatTrans.comp_app_assoc, â† NatTrans.comp_app, Iso.inv_hom_id_app,
    NatTrans.id_app, NatTrans.id_app, id_comp]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  rw [â† cancel_mono ((mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom j),
    assoc, assoc, iso_inv_hom_id_apply, comp_id, Î¹_mapBifunctorAssociator_hom,
    â† NatTrans.comp_app_assoc, â† NatTrans.comp_app, Iso.inv_hom_id_app,
    NatTrans.id_app, NatTrans.id_app, id_comp]

Attempt failure.

Working on Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean - 2024-09-07 21:53:36.325014.
---24/100---
For theorem CategoryTheory.Pretriangulated.exists_iso_of_arrow_iso in Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean:
lemma exists_iso_of_arrow_iso (Tâ‚ Tâ‚‚ : Triangle C) (hTâ‚ : Tâ‚ âˆˆ distTriang C)
    (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C) (e : Arrow.mk Tâ‚.morâ‚ â‰… Arrow.mk Tâ‚‚.morâ‚) :
    âˆƒ (e' : Tâ‚ â‰… Tâ‚‚), e'.hom.homâ‚ = e.hom.left âˆ§ e'.hom.homâ‚‚ = e.hom.right 


Original valid proof:
:= by
  let Ï† := completeDistinguishedTriangleMorphism Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso Ï†.homâ‚ := by dsimp [Ï†]; infer_instance
  have : IsIso Ï†.homâ‚‚ := by dsimp [Ï†]; infer_instance
  have : IsIso Ï†.homâ‚ƒ := isIsoâ‚ƒ_of_isIsoâ‚â‚‚ Ï† hTâ‚ hTâ‚‚ inferInstance inferInstance
  have : IsIso Ï† := by
    apply Triangle.isIso_of_isIsos
    all_goals infer_instance
  exact âŸ¨asIso Ï†, by simp [Ï†], by simp [Ï†]âŸ©


Verifying proof (Commit afe025caf56711b57f2f34e9ae25ec16a609156d):
:= by
  obtain âŸ¨Ï†, âŸ¨hÏ†â‚, hÏ†â‚‚âŸ©âŸ© :=
    complete_distinguished_triangle_morphism' Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso Ï†.homâ‚ := by rw [hÏ†â‚] ; infer_instance
  have : IsIso Ï†.homâ‚‚ := by rw [hÏ†â‚‚] ; infer_instance
  have : IsIso Ï†.homâ‚ƒ := isIsoâ‚ƒ_of_isIsoâ‚â‚‚ Ï† hTâ‚ hTâ‚‚ inferInstance inferInstance
  exact âŸ¨asIso Ï†, hÏ†â‚, hÏ†â‚‚âŸ©

Attempt failure.

Working on Mathlib/Combinatorics/HalesJewett.lean - 2024-09-07 21:53:47.891607.
---25/100---
For theorem Combinatorics.Line.exists_mono_in_high_dimension in Mathlib/Combinatorics/HalesJewett.lean:
theorem exists_mono_in_high_dimension' :
    âˆ€ (Î± : Type u) [Finite Î±] (Îº : Type max v u) [Finite Îº],
      âˆƒ (Î¹ : Type) (_ : Fintype Î¹), âˆ€ C : (Î¹ â†’ Î±) â†’ Îº, âˆƒ l : Line Î± Î¹, l.IsMono C 


Original valid proof:
:=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_right.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left ?_âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine âŸ¨Sum Î¹ Î¹', inferInstance, ?_âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => ?_âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine Or.inr (mono_of_mono âŸ¨p.line, p.color, ?_âŸ©)
      rintro (_ | _)
      Â· rw [hp, s.is_focused p p_mem]
      Â· apply p.has_color
    refine Or.inl âŸ¨âŸ¨(s.lines.map ?_).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => ?_âŸ©,
            Sum.elim s.focus (l'.map some none), ?_, ?_âŸ©, ?_âŸ©
    Â· refine fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => ?_âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])


Verifying proof (Commit 65f7857d510e130142dbb111786341d695ac399b):
:=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_left.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left ?_âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine âŸ¨Sum Î¹ Î¹', inferInstance, ?_âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => ?_âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine Or.inr (mono_of_mono âŸ¨p.line, p.color, ?_âŸ©)
      rintro (_ | _)
      rw [hp, s

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean - 2024-09-07 21:53:52.900817.
---26/100---
For theorem SimpleGraph.adjMatrix_mul_self_apply_self in Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean:
theorem adjMatrix_mul_self_apply_self [NonAssocSemiring Î±] (i : V) :
    (G.adjMatrix Î± * G.adjMatrix Î±) i i = degree G i 


Original valid proof:
:= by simp [filter_true_of_mem]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by simp

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Coloring.lean - 2024-09-07 21:54:03.545491.
---27/100---
For theorem SimpleGraph.chromaticNumber_pos in Mathlib/Combinatorics/SimpleGraph/Coloring.lean:
theorem chromaticNumber_pos [Nonempty V] {n : â„•} (hc : G.Colorable n) : 0 < G.chromaticNumber 


Original valid proof:
:= by
  rw [hc.chromaticNumber_eq_sInf, Nat.cast_pos]
  apply le_csInf (colorable_set_nonempty_of_colorable hc)
  intro m hm
  by_contra h'
  simp only [not_le] at h'
  obtain âŸ¨i, hiâŸ© := hm.some (Classical.arbitrary V)
  have hâ‚: i < 0 := lt_of_lt_of_le hi (Nat.le_of_lt_succ h')
  exact Nat.not_lt_zero _ hâ‚


Verifying proof (Commit a645d903a5e02e8cbb9215f6195147610bf99954):
:= by
  rw [hc.chromaticNumber_eq_sInf, Nat.cast_pos]
  apply le_csInf (colorable_set_nonempty_of_colorable hc)
  intro m hm
  by_contra h'
  simp only [not_le] at h'
  obtain âŸ¨i, hiâŸ© := hm.some (Classical.arbitrary V)
  have hâ‚ : i < 0 := lt_of_lt_of_le hi (Nat.le_of_lt_succ h')
  exact Nat.not_lt_zero _ hâ‚

Attempt success.

Working on Mathlib/Combinatorics/SimpleGraph/Operations.lean - 2024-09-07 21:54:15.390458.
---28/100---
For theorem SimpleGraph.adj_replaceVertex_iff_of_ne in Mathlib/Combinatorics/SimpleGraph/Operations.lean:
lemma adj_replaceVertex_iff_of_ne_left {w : V} (hw : w â‰  t) :
    (G.replaceVertex s t).Adj s w â†” G.Adj s w 


Original valid proof:
:= by simp [replaceVertex, hw]


Verifying proof (Commit f61a485edf966de0b09bd70c1edc7f254cd1b0ae):
:= by simp [hw]

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean - 2024-09-07 21:54:22.586095.
---29/100---
For theorem Finpartition.equitabilise_aux in Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    âˆƒ Q : Finpartition s,
      (âˆ€ x : Finset Î±, x âˆˆ Q.parts â†’ x.card = m âˆ¨ x.card = m + 1) âˆ§
        (âˆ€ x, x âˆˆ P.parts â†’ (x \ (Q.parts.filter fun y => y âŠ† x).biUnion id).card â‰¤ m) âˆ§
          (Q.parts.filter fun i => card i = m + 1).card = b 


Original valid proof:
:= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  Â· refine âŸ¨âŠ¥, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symmâŸ©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      âŸ¨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _âŸ©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 âˆ§ b = 0
  Â· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Î± := Finpartition âŠ¥) P
    exact âŸ¨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]âŸ©
  simp_rw [not_and_or, â† Ne.eq_def, â† pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain âŸ¨hnâ‚€, hnâ‚, hnâ‚‚, hnâ‚ƒâŸ© : 0 < n âˆ§ n â‰¤ m + 1 âˆ§ n â‰¤ a * m + b * (m + 1) âˆ§
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, â† hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    Â· refine âŸ¨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ â€¹0 < aâ€º), ?_âŸ©
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    Â· refine âŸ¨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º), ?_âŸ©
      rw [â† add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º)]
  by_cases h : âˆ€ u âˆˆ P.parts, card u < m + 1
  Â· obtain âŸ¨t, hts, htnâŸ© := exists_subset_card_eq (hnâ‚‚.trans_eq hs)
    have ht : t.Nonempty := by rwa [â† card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff â€¹t âŠ† sâ€º, htn, hnâ‚ƒ]
    obtain âŸ¨R, hRâ‚, _, hRâ‚ƒâŸ© :=
      @ih (s \ t) (sdiff_ssubset hts â€¹t.Nonemptyâ€º) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_âŸ©
    Â· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    Â· rw [hRâ‚ƒ, if_pos ha]
    rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg ha, tsub_add_cancel_of_le]
    Â· exact hab.resolve_left ha
    Â· intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain âŸ¨u, huâ‚, huâ‚‚âŸ© := h
  obtain âŸ¨t, htu, htnâŸ© := exists_subset_card_eq (hnâ‚.trans huâ‚‚)
  have ht : t.Nonempty := by rwa [â† card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le huâ‚), htn, hnâ‚ƒ]
  obtain âŸ¨R, hRâ‚, hRâ‚‚, hRâ‚ƒâŸ© :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le huâ‚) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine
    âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le huâ‚), ?_, ?_, ?_âŸ©
  Â· simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hRâ‚, htn, hn]
    exact ite_eq_or_eq _ _ _
  Â· conv in _ âˆˆ _ => rw [â† insert_erase huâ‚]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine âŸ¨?_, fun x hx => (card_le_card ?_).trans <| hRâ‚‚ x ?_âŸ©
    Â· simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      Â· rw [sdiff_eq_empty_iff_subset.2 subset_union_left]
        exact bot_le
      refine
        (card_le_card fun i => ?_).trans
          (hRâ‚‚ (u \ t) <| P.mem_avoid.2 âŸ¨u, huâ‚, fun i => hut <| i.antisymm htu, rflâŸ©)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hiâ‚ hiâ‚‚ hiâ‚ƒ =>
        âŸ¨âŸ¨hiâ‚, hiâ‚‚âŸ©, fun x hx hx' => hiâ‚ƒ _ hx <| hx'.trans sdiff_subsetâŸ©
    Â· apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      âŸ¨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) huâ‚ <| ne_of_mem_erase hx).sdiff_eq_leftâŸ©
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  Â· rw [hRâ‚ƒ, if_pos h]
  Â· rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)


Verifying proof (Commit 05c4c02a126a220762b13df794c36c771e2fbb7d):
:= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  Â· refine âŸ¨âŠ¥, by simp, ?_, by simpa using hs.symmâŸ©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      âŸ¨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _âŸ©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 âˆ§ b = 0
  Â· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Î± := Finpartition âŠ¥) P
    exact âŸ¨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]âŸ©
  simp_rw [not_and_or, â† Ne.eq_def, â† pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain âŸ¨hnâ‚€, hnâ‚, hnâ‚‚, hnâ‚ƒâŸ© : 0 < n âˆ§ n â‰¤ m + 1 âˆ§ n â‰¤ a * m + b * (m + 1) âˆ§
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, â† hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    Â· refine âŸ¨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ â€¹0 < aâ€º), ?_âŸ©
      rw [â† add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º)]
  by_cases h : âˆ€ u âˆˆ P.parts, card u < m + 1
  Â· obtain âŸ¨t, hts, htnâŸ© := exists_smaller_set s n (hnâ‚‚.trans_eq hs)
    have ht : t.Nonempty := by rwa [â† card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff â€¹t âŠ† sâ€º, htn, hnâ‚ƒ]
    obtain âŸ¨R, hRâ‚, _, hRâ‚ƒâŸ© :=
      @ih (s \ t) (sdiff_ssubset hts â€¹t.Nonemptyâ€º) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_âŸ©
    Â· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => 

Attempt failure.

Working on Mathlib/Computability/PartrecCode.lean - 2024-09-07 21:54:28.640678.
---30/100---
For theorem Nat.Partrec.Code.pair_prim in Mathlib/Computability/PartrecCode.lean:
theorem pair_prim : Primrecâ‚‚ pair 


Original valid proof:
:=
  Primrecâ‚‚.ofNat_iff.2 <|
    Primrecâ‚‚.encode_iff.1 <|
      nat_add.comp
        (nat_double.comp <|
          nat_double.comp <|
            Primrecâ‚‚.natPair.comp (encode_iff.2 <| (Primrec.ofNat Code).comp fst)
              (encode_iff.2 <| (Primrec.ofNat Code).comp snd))
        (Primrecâ‚‚.const 4)


Verifying proof (Commit 6085d5e27552de2d43997b4a52a8d9fcd4686071):
:=
  Primrec.ofNat_iffâ‚‚.2 <| Primrec.encode_iff.1 <| nat_add.compâ‚‚
    (nat_double.comp <| nat_double.comp <| Primrec.natPair.compâ‚‚
      (encode_iff.2 <| (Primrec.ofNat Code).comp fst)
      (encode_iff.2 <| (Primrec.ofNat Code).comp snd))
    (.const 4)

Attempt failure.

Working on Mathlib/Data/Complex/Basic.lean - 2024-09-07 21:54:48.405547.
---31/100---
For theorem Complex.re_eq_add_conj in Mathlib/Data/Complex/Basic.lean:
theorem re_eq_add_conj (z : â„‚) : (z.re : â„‚) = (z + conj z) / 2 


Original valid proof:
:= by
  simp only [add_conj, ofReal_mul, ofReal_ofNat, mul_div_cancel_leftâ‚€ (z.re : â„‚) two_ne_zero]


Verifying proof (Commit 151eb46ac9da80421706d0822fba0ae70d6ae557):
:= by
  simp only [add_conj, ofReal_mul, ofReal_ofNat, mul_div_cancel_left (z.re : â„‚) two_ne_zero]

Attempt failure.

Working on Mathlib/Data/Fin/Basic.lean - 2024-09-07 21:54:57.357041.
---32/100---
For theorem Fin.castSucc_ne_zero_of_lt in Mathlib/Data/Fin/Basic.lean:
theorem castSucc_ne_zero_of_lt {p i : Fin n} (h : p < i) : castSucc i â‰  0 


Original valid proof:
:= by
  cases n
  Â· exact i.elim0
  Â· rw [castSucc_ne_zero_iff', Ne, ext_iff]
    exact ((zero_le _).trans_lt h).ne'


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  cases n
  Â· exact i.elim0
  Â· rw [castSucc_ne_zero_iff']
    exact ((zero_le _).trans_lt h).ne'

Attempt failure.

---33/100---
For theorem Fin.one_lt_last in Mathlib/Data/Fin/Basic.lean:
theorem one_lt_last [NeZero n] : 1 < last (n + 1) 


Original valid proof:
:= by
  rw [lt_iff_val_lt_val, val_one, val_last, Nat.lt_add_left_iff_pos, Nat.pos_iff_ne_zero]
  exact NeZero.ne n


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= lt_add_iff_pos_left 1).mpr (NeZero.pos n)

Attempt failure.

Working on Mathlib/Data/Fin/VecNotation.lean - 2024-09-07 21:55:13.580463.
---34/100---
For theorem Matrix.vecAlt0_vecAppend in Mathlib/Data/Fin/VecNotation.lean:
theorem vecAlt0_vecAppend (v : Fin n â†’ Î±) : vecAlt0 rfl (vecAppend rfl v v) = v âˆ˜ bit0 


Original valid proof:
:= by
  ext i
  simp_rw [Function.comp, bit0, vecAlt0, vecAppend_eq_ite]
  split_ifs with h <;> congr
  Â· rw [Fin.val_mk] at h
    exact (Nat.mod_eq_of_lt h).symm
  Â· rw [Fin.val_mk, not_lt] at h
    simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_eq_sub_mod h]
    refine (Nat.mod_eq_of_lt ?_).symm
    omega


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  ext i
  simp_rw [Function.comp, bit0, vecAlt0, vecAppend_eq_ite]
  split_ifs with h <;> congr
  Â· rw [Fin.val_mk] at h
    exact (Nat.mod_eq_of_lt h).symm
  Â· rw [Fin.val_mk, not_lt] at h
    simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_eq_sub_mod h]
    refine (Nat.mod_eq_of_lt ?_).symm
    rw [tsub_lt_iff_left h]
    exact add_lt_add i.2 i.2

Attempt failure.

Working on Mathlib/Data/Finsupp/Defs.lean - 2024-09-07 21:55:19.581523.
---35/100---
For theorem Finsupp.single_eq_zero in Mathlib/Data/Finsupp/Defs.lean:
theorem single_eq_zero : single a b = 0 â†” b = 0 


Original valid proof:
:= by
  simp [DFunLike.ext_iff, single_eq_set_indicator]


Verifying proof (Commit 67e80fd089fe45abea632652c43b78eba72d60e3):
:=
  DFinsupp.single_eq_zero

Attempt failure.

Working on Mathlib/Data/List/OfFn.lean - 2024-09-07 21:55:27.523521.
---36/100---
For theorem List.ofFn_succ in Mathlib/Data/List/OfFn.lean:
theorem ofFn_succ {n} (f : Fin (succ n) â†’ Î±) : ofFn f = f 0 :: ofFn fun i => f i.succ 


Original valid proof:
:=
  ext_get (by simp) (fun i hiâ‚ hiâ‚‚ => by
    cases i
    Â· simp
    Â· simp)


Verifying proof (Commit 66caaeed4dccada03ce195a3f9db1c0009ee8118):
:=
  ext_get (by simp) (fun i hiâ‚ hiâ‚‚ => by
    cases i
    Â· simp; rfl
    Â· simp)

Attempt failure.

Working on Mathlib/Data/Multiset/Basic.lean - 2024-09-07 21:55:32.869127.
---37/100---
For theorem Multiset.count_map_eq_count in Mathlib/Data/Multiset/Basic.lean:
theorem count_map_eq_count [DecidableEq Î²] (f : Î± â†’ Î²) (s : Multiset Î±)
    (hf : Set.InjOn f { x : Î± | x âˆˆ s }) (x) (H : x âˆˆ s) : (s.map f).count (f x) = s.count x 


Original valid proof:
:= by
  suffices (filter (fun a : Î± => f x = f a) s).count x = card (filter (fun a : Î± => f x = f a) s) by
    rw [count, countP_map, â† this]
    exact count_filter_of_pos <| rfl
  Â· rw [eq_replicate_card.2 fun b hb => (hf H (mem_filter.1 hb).left _).symm]
    Â· simp only [count_replicate, eq_self_iff_true, if_true, card_replicate]
    Â· simp only [mem_filter, beq_iff_eq, and_imp, @eq_comm _ (f x), imp_self, implies_true]


Verifying proof (Commit e609eeb4638d90bf8185c6ea72c5d41e94387a3b):
:=
  by
  suffices (filter (fun a : Î± => f a => f x) s).count x = card (filter (fun a : Î± => f a => f x) s)
    by
    rw [count, countp_map, â† this]
    exact count_filter_of_pos <| beq_self_eq_true _
  Â· rw [eq_repeat.2
        âŸ¨rfl, fun b hb => eq_comm.1 ((hf H (mem_filter.1 hb).left) _)âŸ©]
    Â· simp only [count_repeat, eq_self_iff_true, if_true, card_repeat]
    Â· simp only [mem_filter, beq_iff_eq, and_imp, @eq_comm _ (f x), imp_self, implies_true]

Attempt failure.

Working on Mathlib/Data/Seq/Parallel.lean - 2024-09-07 21:55:45.315899.
---38/100---
For theorem Computation.exists_of_mem_parallel in Mathlib/Data/Seq/Parallel.lean:
theorem exists_of_mem_parallel {S : WSeq (Computation Î±)} {a} (h : a âˆˆ parallel S) :
    âˆƒ c âˆˆ S, a âˆˆ c 


Original valid proof:
:= by
  suffices
    âˆ€ C, a âˆˆ C â†’ âˆ€ (l : List (Computation Î±)) (S),
      corec parallel.aux1 (l, S) = C â†’ âˆƒ c, (c âˆˆ l âˆ¨ c âˆˆ S) âˆ§ a âˆˆ c from
    let âŸ¨c, h1, h2âŸ© := this _ h [] S rfl
    âŸ¨c, h1.resolve_left <| List.not_mem_nil _, h2âŸ©
  let F : List (Computation Î±) â†’ Sum Î± (List (Computation Î±)) â†’ Prop := by
    intro l a
    cases' a with a l'
    Â· exact âˆƒ c âˆˆ l, a âˆˆ c
    Â· exact âˆ€ a', (âˆƒ c âˆˆ l', a' âˆˆ c) â†’ âˆƒ c âˆˆ l, a' âˆˆ c
  have lem1 : âˆ€ l : List (Computation Î±), F l (parallel.aux2 l) := by
    intro l
    induction' l with c l IH <;> simp only [parallel.aux2, List.foldr]
    Â· intro a h
      rcases h with âŸ¨c, hn, _âŸ©
      exact False.elim <| List.not_mem_nil _ hn
    Â· simp only [parallel.aux2] at IH
      revert IH
      cases' List.foldr (fun c o =>
        match o with
        | Sum.inl a => Sum.inl a
        | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c)) (Sum.inr List.nil) l with a ls <;>
        intro IH <;>
        simp only [parallel.aux2]
      Â· rcases IH with âŸ¨c', cl, acâŸ©
        exact âŸ¨c', List.Mem.tail _ cl, acâŸ©
      Â· induction' h : destruct c with a c' <;> simp only [rmap]
        Â· refine âŸ¨c, List.mem_cons_self _ _, ?_âŸ©
          rw [destruct_eq_pure h]
          apply ret_mem
        Â· intro a' h
          rcases h with âŸ¨d, dm, adâŸ©
          simp? at dm says simp only [List.mem_cons] at dm
          cases' dm with e dl
          Â· rw [e] at ad
            refine âŸ¨c, List.mem_cons_self _ _, ?_âŸ©
            rw [destruct_eq_think h]
            exact think_mem ad
          Â· cases' IH a' âŸ¨d, dl, adâŸ© with d dm
            cases' dm with dm ad
            exact âŸ¨d, List.Mem.tail _ dm, adâŸ©
  intro C aC
  apply memRecOn aC <;> [skip; intro C' IH] <;> intro l S e <;> have e' := congr_arg destruct e <;>
    have := lem1 l <;> simp only [parallel.aux1, corec_eq, destruct_pure, destruct_think] at e' <;>
    revert this e' <;> cases' parallel.aux2 l with a' l' <;> intro this e' <;>
    [injection e' with h'; injection e'; injection e'; injection e' with h']
  Â· rw [h'] at this
    rcases this with âŸ¨c, cl, acâŸ©
    exact âŸ¨c, Or.inl cl, acâŸ©
  Â· induction' e : Seq.destruct S with a <;> rw [e] at h'
    Â· exact
        let âŸ¨d, o, adâŸ© := IH _ _ h'
        let âŸ¨c, cl, acâŸ© := this a âŸ¨d, o.resolve_right (WSeq.not_mem_nil _), adâŸ©
        âŸ¨c, Or.inl cl, acâŸ©
    Â· cases' a with o S'
      cases' o with c <;> simp [parallel.aux1] at h' <;> rcases IH _ _ h' with âŸ¨d, dl | dS', adâŸ©
      Â· exact
          let âŸ¨c, cl, acâŸ© := this a âŸ¨d, dl, adâŸ©
          âŸ¨c, Or.inl cl, acâŸ©
      Â· refine âŸ¨d, Or.inr ?_, adâŸ©
        rw [Seq.destruct_eq_cons e]
        exact Seq.mem_cons_of_mem _ dS'
      Â· simp at dl
        cases' dl with dc dl
        Â· rw [dc] at ad
          refine âŸ¨c, Or.inr ?_, adâŸ©
          rw [Seq.destruct_eq_cons e]
          apply Seq.mem_cons
        Â· exact
            let âŸ¨c, cl, acâŸ© := this a âŸ¨d, dl, adâŸ©
            âŸ¨c, Or.inl cl, acâŸ©
      Â· refine âŸ¨d, Or.inr ?_, adâŸ©
        rw [Seq.destruct_eq_cons e]
        exact Seq.mem_cons_of_mem _ dS'


Verifying proof (Commit 3c930599229893e1b6a931304cf4efff4a01b172):
:= by
  suffices
      âˆ€ C, a âˆˆ C â†’ âˆ€ (l : List (Computation Î±)) (S),
        corec parallel.aux1 (l, S) = C â†’ âˆƒ c, (c âˆˆ l âˆ¨ c âˆˆ WSeq.mk S) âˆ§ a âˆˆ c from
    let âŸ¨c, h1, h2âŸ© := this _ h [] (WSeq.data S) rfl
    âŸ¨c, h1.resolve_left <| List.not_mem_nil _, h2âŸ©
  let F : List (Computation Î±) â†’ Î± âŠ• List (Computation Î±) â†’ Prop := by
    intro l a
    cases' a with a l'
    Â· exact âˆƒ c âˆˆ l, a âˆˆ c
    Â· exact âˆ€ a', (âˆƒ c âˆˆ l', a' âˆˆ c) â†’ âˆƒ c âˆˆ l, a' âˆˆ c
  have lem1 : âˆ€ l : List (Computation Î±), F l (parallel.aux2 l) := by
    intro l
    induction' l with c l IH <;> simp only [parallel.aux2, List.foldr]
    Â· intro a h
      rcases h with âŸ¨c, hn, _âŸ©
      exact False.elim <| List.not_mem_nil _ hn
    Â· simp only [parallel.aux2] at IH
      revert IH
      cases' List.foldr (fun c o =>
        match o with
        | Sum.inl a => Sum.inl a
        | Sum.inr ls => Sum.map id (Â· :: ls) (dest c)) (Sum.inr []) l with a ls <;>
        intro IH <;>
        simp only [parallel.aux2]
      Â· rcases IH with âŸ¨c', cl, acâŸ©
        exact âŸ¨c', List.Mem.tail _ cl, acâŸ©
    Â· cases' a with o S'
      cases' o with h'; injection e' with h']
  Â· rw [â† h']
    rcases this with âŸ¨c, cl, acâŸ©
    exact âŸ¨c, Or.inl cl, acâŸ©
  Â· induction' e : Seq.destruct S with a <;> rw [e] at h'
    Â· exact
        let âŸ¨d, o, adâŸ© := IH _ _ h'
        let âŸ¨c, cl, acâŸ© := this a âŸ¨d, o.resolve_right (WSeq.not_mem_nil _), adâŸ©
        âŸ¨c, Or.inl cl, acâŸ©
  Â· induction' e : Seq.destruct S with a <;> rw [e] at h'
    Â· exact
        let âŸ¨d, o, adâŸ© := IH _ _ h'
        let âŸ¨c, cl, acâŸ© := this a âŸ¨d, o.resolve_right (WSeq.not_mem_nil _), adâŸ©
        âŸ¨c, Or.inl cl, acâŸ©
  Â· induction' e : Seq.destruct S with a <;> rw [e] at h'
    Â· exact
        let âŸ¨d, o, adâŸ© := IH _ _ h'
        let âŸ¨c, cl, acâŸ© := this a âŸ¨d, o.resolve_right (WSeq.not_mem_nil _), adâŸ©
        âŸ¨c, Or.inl cl, acâŸ©
  Â· induction' e : Seq.destruct S with a <;> rw [e] at h'
    Â· exact
        let âŸ¨d, o, adâŸ© := IH _ _ h'
        let âŸ¨c, cl, acâŸ© := this a âŸ¨d, o.resolve_right (WSeq.not_mem_nil _), adâŸ©
        âŸ¨c, Or.inl cl, acâŸ©
  Â· induction' e : Seq.destruct S with a <;> rw [e] at h'
    Â· exact
        let âŸ¨d, o, adâŸ© := IH _ _ h'
        let âŸ¨c, cl, acâŸ© := this a âŸ¨d, o.resolve_right (WSeq.not_mem_nil _), adâŸ©
        âŸ¨c, Or.inl cl, acâŸ©
  Â· induction' e : Seq.destruct S with a <;> rw [e] at h'
    Â· exact
        let âŸ¨d, o, adâŸ© := IH _

Attempt failure.

Working on Mathlib/Data/Set/Basic.lean - 2024-09-07 21:55:50.220114.
---39/100---
For theorem Set.inter_subset_ite in Mathlib/Data/Set/Basic.lean:
theorem inter_subset_ite (t s s' : Set Î±) : s âˆ© s' âŠ† t.ite s s' 


Original valid proof:
:=
  ite_same t (s âˆ© s') â–¸ ite_mono _ inter_subset_left inter_subset_right


Verifying proof (Commit 70dcc1355b9ce0a6754f8d809c95a171072d3aac):
:=
  ite_same t (s âˆ© s') â–¸ ite_mono _ inter_subset_left inter_subset_right

Attempt success.

Working on Mathlib/Data/Set/Subset.lean - 2024-09-07 21:56:01.922459.
---40/100---
For theorem Set.image_val_iInter in Mathlib/Data/Set/Subset.lean:
lemma image_val_iInter [Nonempty Î¹] : (â†‘(â‹‚ i, t i) : Set Î±) = â‹‚ i, (â†‘(t i) : Set Î±) 


Original valid proof:
:=
  Subtype.val_injective.injOn.image_iInter_eq


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:=
  (Subtype.val_injective.injOn _).image_iInter_eq

Attempt failure.

Working on Mathlib/Dynamics/OmegaLimit.lean - 2024-09-07 21:56:27.478315.
---41/100---
For theorem nonempty_omegaLimit_of_isCompact_absorbing in Mathlib/Dynamics/OmegaLimit.lean:
theorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set Î²} (hcâ‚ : IsCompact c)
    (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) (hs : s.Nonempty) : (Ï‰ f Ï• s).Nonempty 


Original valid proof:
:= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚]
  apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed
  Â· rintro âŸ¨uâ‚, huâ‚âŸ© âŸ¨uâ‚‚, huâ‚‚âŸ©
    use âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚âŸ©
    constructor
    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)
  Â· intro u
    have hn : (image2 Ï• (u âˆ© v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hvâ‚)) hs
    exact hn.mono subset_closure
  Â· intro
    apply hcâ‚.of_isClosed_subset isClosed_closure
    calc
      _ âŠ† closure (image2 Ï• v s) := closure_mono (image2_subset inter_subset_right Subset.rfl)
      _ âŠ† c := hvâ‚‚
  Â· exact fun _ â†¦ isClosed_closure


Verifying proof (Commit ffb5dddeb20329610a2c898c4125ae8bea987862):
:= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  rw [omegaLimit_eq_inter_inter _ _ _ hvâ‚]
  apply IsCompact.nonempty_inter_of_directed_nonempty_compact_closed
  Â· rintro âŸ¨uâ‚, huâ‚âŸ© âŸ¨uâ‚‚, huâ‚‚âŸ©
    use âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚âŸ©
    constructor
    all_goals exact closure_mono (image2_subset inter_subset_inter_left _ (by simp)) Subset.rfl)
  Â· intro u
    have hn : (image2 Ï• (u âˆ© v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hvâ‚)) hs
    exact hn.mono subset_closure
  Â· intro
    apply isCompact_of_isClosed_subset hcâ‚ isClosed_closure
    calc
      _ âŠ† closure (image2 Ï• v s) := closure_mono (image2_subset inter_subset_right Subset.rfl)
      _ âŠ† c := hvâ‚‚
      
  Â· exact fun _ â†¦ isClosed_closure

Attempt failure.

Working on Mathlib/FieldTheory/IsAlgClosed/Basic.lean - 2024-09-07 21:56:35.961555.
---42/100---
For theorem IsAlgClosed.algebraMap_surjective_of_isIntegral' in Mathlib/FieldTheory/IsAlgClosed/Basic.lean:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k â†’+* K) (hf : f.IsIntegral) : Function.Surjective f 


Original valid proof:
:=
  let _ : Algebra k K := f.toAlgebra
  have : Algebra.IsIntegral k K := âŸ¨hfâŸ©
  algebraMap_surjective_of_isIntegral


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:=
  @algebraMap_surjective_of_isIntegral k K _ _ _ _ f.toAlgebra hf

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Circumcenter.lean - 2024-09-07 21:56:55.057972.
---43/100---
For theorem Affine.Simplex.circumradius_pos in Mathlib/Geometry/Euclidean/Circumcenter.lean:
theorem circumradius_pos {n : â„•} (s : Simplex â„ P (n + 1)) : 0 < s.circumradius 


Original valid proof:
:= by
  refine lt_of_le_of_ne s.circumradius_nonneg ?_
  intro h
  have hr := s.dist_circumcenter_eq_circumradius
  simp_rw [â† h, dist_eq_zero] at hr
  have h01 := s.independent.injective.ne (by simp : (0 : Fin (n + 2)) â‰  1)
  simp [hr] at h01


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  refine lt_of_le_of_ne s.circumradius_nonneg ?_
  intro h
  have hr := s.dist_circumcenter_eq_circumradius
  simp_rw [â† h, dist_eq_zero] at hr
  have h01 := s.Independent.injective.ne (by simp : (0 : Fin (n + 2)) â‰  1)
  simp [hr] at h01

Attempt failure.

Working on Mathlib/Geometry/Manifold/LocalInvariantProperties.lean - 2024-09-07 21:57:18.354568.
---44/100---
For theorem StructureGroupoid.LocalInvariantProp.liftPropWithinAt_iff in Mathlib/Geometry/Manifold/LocalInvariantProperties.lean:
theorem liftPropWithinAt_iff {f : M â†’ M'} :
    LiftPropWithinAt P f s x â†”
      ContinuousWithinAt f s x âˆ§
        P (chartAt H' (f x) âˆ˜ f âˆ˜ (chartAt H x).symm)
          ((chartAt H x).target âˆ© (chartAt H x).symm â»Â¹' (s âˆ© f â»Â¹' (chartAt H' (f x)).source))
          (chartAt H x x) 


Original valid proof:
:= by
  rw [liftPropWithinAt_iff']
  refine and_congr_right fun hf â†¦ hG.congr_set ?_
  exact PartialHomeomorph.preimage_eventuallyEq_target_inter_preimage_inter hf
    (mem_chart_source H x) (chart_source_mem_nhds H' (f x))


Verifying proof (Commit b06c98e69f01ef8ab665c237468aa64e98a5bcd4):
:= by
  refine and_congr_right fun hf â†¦ hG.congr_set ?_
  exact LocalHomeomorph.preimage_eventuallyEq_target_inter_preimage_inter hf (mem_chart_source H x)
    (chart_source_mem_nhds H' (f x))

Attempt failure.

Working on Mathlib/GroupTheory/GroupAction/Blocks.lean - 2024-09-07 21:57:26.676611.
---45/100---
For theorem MulAction.IsPartition.of_orbits in Mathlib/GroupTheory/GroupAction/Blocks.lean:
theorem IsPartition.of_orbits :
    Setoid.IsPartition (Set.range fun a : X => orbit G a) 


Original valid proof:
:= by
  apply orbit.pairwiseDisjoint.isPartition_of_exists_of_ne_empty
  Â· intro x
    exact âŸ¨_, âŸ¨x, rflâŸ©, mem_orbit_self xâŸ©
  Â· rintro âŸ¨a, ha : orbit G a = âˆ…âŸ©
    exact (MulAction.orbit_nonempty a).ne_empty ha


Verifying proof (Commit 90ee4adef4081d5ea59d0008022888ad5b93d012):
:= by
  constructor
  Â· rintro âŸ¨a, ha : orbit G a = âˆ…âŸ©
    exact Set.Nonempty.ne_empty (MulAction.orbit_nonempty a) ha
  intro a; use orbit G a
  constructor
  Â· simp only [Set.mem_range_self, mem_orbit_self, exists_unique_iff_exists, exists_true_left]
  Â· simp only [Set.mem_range, exists_unique_iff_exists, exists_prop, and_imp, forall_exists_index,
      forall_apply_eq_imp_iff']
    rintro B b âŸ¨rflâŸ© ha
    apply symm
    rw [orbit_eq_iff]
    exact ha

Attempt failure.

Working on Mathlib/LinearAlgebra/Basis.lean - 2024-09-07 21:57:35.447317.
---46/100---
For theorem union_support_maximal_linearIndependent_eq_range_basis in Mathlib/LinearAlgebra/Basis.lean:
theorem union_support_maximal_linearIndependent_eq_range_basis {Î¹ : Type w} (b : Basis Î¹ R M)
    {Îº : Type w'} (v : Îº â†’ M) (i : LinearIndependent R v) (m : i.Maximal) :
    â‹ƒ k, ((b.repr (v k)).support : Set Î¹) = Set.univ 


Original valid proof:
:= by
  by_contra h
  simp only [â† Ne.eq_def, ne_univ_iff_exists_not_mem, mem_iUnion, not_exists_not,
    Finsupp.mem_support_iff, Finset.mem_coe] at h
  obtain âŸ¨b', wâŸ© := h
  let v' : Option Îº â†’ M := fun o => o.elim (b b') v
  have r : range v âŠ† range v' := by
    rintro - âŸ¨k, rflâŸ©
    use some k
    simp only [v', Option.elim_some]
  have r' : b b' âˆ‰ range v := by
    rintro âŸ¨k, pâŸ©
    simpa [w] using congr_arg (fun m => (b.repr m) b') p
  have r'' : range v â‰  range v' := by
    intro e
    have p : b b' âˆˆ range v' := by
      use none
      simp only [v', Option.elim_none]
    rw [â† e] at p
    exact r' p
  have i' : LinearIndependent R ((â†‘) : range v' â†’ M) := by
    apply LinearIndependent.to_subtype_range
    rw [linearIndependent_iff]
    intro l z
    rw [Finsupp.total_option] at z
    simp only [v', Option.elim'] at z
    change _ + Finsupp.total Îº M R v l.some = 0 at z
    have lâ‚€ : l none = 0 := by
      rw [â† eq_neg_iff_add_eq_zero] at z
      replace z := neg_eq_iff_eq_neg.mpr z
      apply_fun fun x => b.repr x b' at z
      simp only [repr_self, map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply,
        Finsupp.smul_single', map_neg, Finsupp.coe_neg] at z
      erw [DFunLike.congr_fun (Finsupp.apply_total R (b.repr : M â†’â‚—[R] Î¹ â†’â‚€ R) v l.some) b'] at z
      simpa [Finsupp.total_apply, w] using z
    have lâ‚ : l.some = 0 := by
      rw [lâ‚€, zero_smul, zero_add] at z
      exact linearIndependent_iff.mp i _ z
    ext (_ | a)
    Â· simp only [lâ‚€, Finsupp.coe_zero, Pi.zero_apply]
    Â· erw [DFunLike.congr_fun lâ‚ a]
      simp only [Finsupp.coe_zero, Pi.zero_apply]
  rw [LinearIndependent.Maximal] at m
  specialize m (range v') i' r
  exact r'' m


Verifying proof (Commit 971a0d73179f0907eda2324b5a10ab2a071e3aae):
:= by
  by_contra h
  simp only [â† Ne.eq_def, ne_univ_iff_exists_not_mem, mem_iUnion, not_exists_not,
    Finsupp.mem_support_iff, Finset.mem_coe] at h
  obtain âŸ¨b', wâŸ© := h
  let v' : Option Îº â†’ M := fun o => o.elim (b b') v
  have r : range v âŠ† range v' := by
    rintro - âŸ¨k, rflâŸ©
    use some k
    simp only [v', Option.elim_some]
  have r' : b b' âˆ‰ range v := by
    rintro âŸ¨k, pâŸ©
    simpa [w] using congr_arg (fun m => (b.repr m) b') p
  have r'' : range v â‰  range v' := by
    intro e
    have p : b b' âˆˆ range v' := by
      use none
      simp only [v', Option.elim_none]
    rw [â† e] at p
    exact r' p
  have i' : LinearIndependent R ((â†‘) : range v' â†’ M) := by
    apply LinearIndependent.to_subtype_range
    rw [linearIndependent_iff]
    intro l z
    rw [Finsupp.total_option] at z
    simp only [v', Option.elim'] at z
    change _ + Finsupp.total Îº M R v l.some = 0 at z
    have lâ‚€ : l none = 0 := by
      rw [â† eq_neg_iff_add_eq_zero] at z
      replace z := neg_eq_iff_eq_neg.mpr z
      apply_fun fun x => b.repr x b' at z
      simp only [repr_self, LinearEquiv.map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply,
        Finsupp.smul_single', LinearEquiv.map_neg, Finsupp.coe_neg] at z
      erw [DFunLike.congr_fun (Finsupp.apply_total R (b.repr : M â†’â‚—[R] Î¹ â†’â‚€ R) v l.some) b'] at z
      simpa [Finsupp.total_apply, w] using z
    have lâ‚ : l.some = 0 := by
      rw [lâ‚€, zero_smul, zero_add] at z
      exact linearIndependent_iff.mp i _ z
    ext (_ | a)
    Â· simp only [lâ‚€, Finsupp.coe_zero, Pi.zero_apply]
    Â· erw [DFunLike.congr_fun lâ‚ a]
      simp only [Finsupp.coe_zero, Pi.zero_apply]
  rw [LinearIndependent.Maximal] at m
  specialize m (range v') i' r
  exact r'' m

Attempt failure.

Working on Mathlib/LinearAlgebra/Finsupp.lean - 2024-09-07 21:57:57.702809.
---47/100---
For theorem LinearMap.splittingOfFunOnFintypeSurjective_splits in Mathlib/LinearAlgebra/Finsupp.lean:
theorem splittingOfFunOnFintypeSurjective_splits [Finite Î±] (f : M â†’â‚—[R] Î± â†’ R)
    (s : Surjective f) : f.comp (splittingOfFunOnFintypeSurjective f s) = LinearMap.id 


Original valid proof:
:= by
  classical
  refine pi_ext' fun x => ext_ring <| funext fun y => ?_
  dsimp [splittingOfFunOnFintypeSurjective]
  rw [linearEquivFunOnFinite_symm_single, Finsupp.sum_single_index, one_smul,
    (s (Finsupp.single x 1)).choose_spec, Finsupp.single_eq_pi_single]
  rw [zero_smul]


Verifying proof (Commit 67e80fd089fe45abea632652c43b78eba72d60e3):
:= by
  classical
  refine pi_ext' fun x => ext_ring <| funext fun y => ?_
  dsimp [splittingOfFunOnFintypeSurjective]
  rw [linearEquivFunOnFintype_symm_single, Finsupp.sum_single_index, one_smul,
    (s (Finsupp.single x 1)).choose_spec, Finsupp.single_eq_pi_single]
  rw [zero_smul]

Attempt failure.

Working on Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean - 2024-09-07 21:58:18.616204.
---48/100---
For theorem Matrix.rank_vecMulVec in Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean:
theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m â†’ K) (v : n â†’ K) : (Matrix.vecMulVec w v).toLin'.rank â‰¤ 1 


Original valid proof:
:= by
  nontriviality K
  rw [Matrix.vecMulVec_eq (Fin 1), Matrix.toLin'_mul]
  refine le_trans (LinearMap.rank_comp_le_left _ _) ?_
  refine (LinearMap.rank_le_domain _).trans_eq ?_
  rw [rank_fun', Fintype.card_ofSubsingleton, Nat.cast_one]


Verifying proof (Commit bad931b7fc9f31f5ff5b8f408dd19bbe20a9f0e1):
:= by
  nontriviality K
  rw [Matrix.vecMulVec_eq, Matrix.toLin'_mul]
  refine le_trans (LinearMap.rank_comp_le_left _ _) ?_
  refine (LinearMap.rank_le_domain _).trans_eq ?_
  rw [rank_fun', Fintype.card_unit, Nat.cast_one]

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean - 2024-09-07 21:58:28.570623.
---49/100---
For theorem Matrix.reverse_charpoly in Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean:
lemma reverse_charpoly (M : Matrix n n R) :
    M.charpoly.reverse = M.charpolyRev 


Original valid proof:
:= by
  nontriviality R
  let t : R[T;Tâ»Â¹] := T 1
  let t_inv : R[T;Tâ»Â¹] := T (-1)
  let p : R[T;Tâ»Â¹] := det (scalar n t - M.map LaurentPolynomial.C)
  let q : R[T;Tâ»Â¹] := det (1 - scalar n t * M.map LaurentPolynomial.C)
  have ht : t_inv * t = 1 := by rw [â† T_add, add_left_neg, T_zero]
  have hp : toLaurentAlg M.charpoly = p := by
    simp [p, charpoly, charmatrix, AlgHom.map_det, map_sub, map_smul']
  have hq : toLaurentAlg M.charpolyRev = q := by
    simp [q, charpolyRev, AlgHom.map_det, map_sub, map_smul', smul_eq_diagonal_mul]
  suffices t_inv ^ Fintype.card n * p = invert q by
    apply toLaurent_injective
    rwa [toLaurent_reverse, â† coe_toLaurentAlg, hp, hq, â† involutive_invert.injective.eq_iff,
      _root_.map_mul, involutive_invert p, charpoly_natDegree_eq_dim,
      â† mul_one (Fintype.card n : â„¤), â† T_pow, map_pow, invert_T, mul_comm]
  rw [â† det_smul, smul_sub, scalar_apply, â† diagonal_smul, Pi.smul_def, smul_eq_mul, ht,
    diagonal_one, invert.map_det]
  simp [t, map_smul', smul_eq_diagonal_mul]


Verifying proof (Commit 8a368c9ce548afdf4c8725618c97ec9e96c48601):
:= by
  nontriviality R
  let t : R[T;Tâ»Â¹] := T 1
  let t_inv : R[T;Tâ»Â¹] := T (-1)
  let p : R[T;Tâ»Â¹] := det (scalar n t - M.map LaurentPolynomial.C)
  let q : R[T;Tâ»Â¹] := det (1 - scalar n t * M.map LaurentPolynomial.C)
  have ht : t_inv * t = 1 := by rw [â† T_add, add_left_neg, T_zero]
  have hp : toLaurentAlg M.charpoly = p := by
    simp [charpoly, charmatrix, AlgHom.map_det, map_sub, map_smul', smul_eq_diagonal_mul]
  suffices t_inv ^ Fintype.card n * p = invert q
  Â· apply toLaurent_injective
    rwa [toLaurent_reverse, â† coe_toLaurentAlg, hp, hq, â† involutive_invert.injective.eq_iff,
      invert.map_mul, involutive_invert p, charpoly_natDegree_eq_dim,
      â† mul_one (Fintype.card n : â„¤), â† T_pow, invert.map_pow, invert_T, mul_comm]
  rw [â† det_smul, smul_sub, scalar_apply, â† diagonal_smul, Pi.smul_def, smul_eq_mul, ht,
    diagonal_one, invert.map_det (R := R)]
  simp [map_smul', smul_eq_diagonal_mul]

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/PosDef.lean - 2024-09-07 21:58:43.596247.
---50/100---
For theorem Matrix.PosDef.eigenvalues_pos in Mathlib/LinearAlgebra/Matrix/PosDef.lean:
lemma eigenvalues_pos [DecidableEq n] {A : Matrix n n ğ•œ}
    (hA : Matrix.PosDef A) (i : n) : 0 < hA.1.eigenvalues i 


Original valid proof:
:= by
  simp only [hA.1.eigenvalues_eq]
  exact hA.re_dotProduct_pos <| hA.1.eigenvectorBasis.orthonormal.ne_zero i


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  rw [hA.1.eigenvalues_eq, hA.1.transpose_eigenvectorMatrix_apply]
  exact hA.re_dotProduct_pos <| hA.1.eigenvectorBasis.orthonormal.ne_zero i

Attempt failure.

---51/100---
For theorem Matrix.IsHermitian.posSemidef_of_eigenvalues_nonneg in Mathlib/LinearAlgebra/Matrix/PosDef.lean:
lemma IsHermitian.posSemidef_of_eigenvalues_nonneg [DecidableEq n] {A : Matrix n n ğ•œ}
    (hA : IsHermitian A) (h : âˆ€ i : n, 0 â‰¤ hA.eigenvalues i) : PosSemidef A 


Original valid proof:
:= by
  rw [hA.spectral_theorem]
  refine (posSemidef_diagonal_iff.mpr ?_).mul_mul_conjTranspose_same _
  simpa using h


Verifying proof (Commit 7800fb94347a7ae960c80963e8c98275d05eecba):
:= by
  simp_rw [hA.conjTranspose_eigenvectorMatrix.symm â–¸ hA.spectral_theorem']
  refine (posSemidef_diagonal_iff.mpr fun i â†¦ ?_).mul_mul_conjTranspose_same _
  rw [IsROrC.le_iff_re_im]
  simpa using h i

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Spectrum.lean - 2024-09-07 21:59:22.070889.
---52/100---
For theorem Matrix.IsHermitian.det_eq_prod_eigenvalues in Mathlib/LinearAlgebra/Matrix/Spectrum.lean:
theorem det_eq_prod_eigenvalues : det A = âˆ i, (hA.eigenvalues i : ğ•œ) 


Original valid proof:
:= by
  convert congr_arg det hA.spectral_theorem
  rw [det_mul_right_comm]
  simp


Verifying proof (Commit aaf4ca2007ab15f02495731d0805034c9199aeea):
:= by
  apply mul_left_cancelâ‚€ <| det_ne_zero_of_left_inverse <|
    unitary.coe_mul_star_self hA.eigenvectorUnitary
  rw [unitary.coe_star, â† det_mul, spectral_theorem, det_mul, mul_comm, det_diagonal]
  simp_rw [Function.comp_apply]

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean - 2024-09-07 21:59:35.478462.
---53/100---
For theorem measurable_of_tendsto_metrizable' in Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean:
theorem measurable_of_tendsto_metrizable' {Î¹} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [NeBot u]
    [IsCountablyGenerated u] (hf : âˆ€ i, Measurable (f i)) (lim : Tendsto f u (ğ“ g)) :
    Measurable g 


Original valid proof:
:= by
  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²
  apply measurable_of_isClosed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices Tendsto (fun i x => infNndist (f i x) s) u (ğ“ fun x => infNndist (g x) s) from
      NNReal.measurable_of_tendsto' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim âŠ¢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g â»Â¹' s = (fun x => infNndist (g x) s) â»Â¹' {0} := by
    ext x
    simp [h1s, â† h1s.mem_iff_infDist_zero h2s, â† NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)


Verifying proof (Commit 5068808d2b4c25cf905cf7fee10ded8e447c2346):
:= by
  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²
  apply measurable_of_is_closed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices Tendsto (fun i x => infNndist (f i x) s) u (ğ“ fun x => infNndist (g x) s)
    exact measurable_of_tendsto_nnreal' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at limâŠ¢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g â»Â¹' s = (fun x => infNndist (g x) s) â»Â¹' {0} := by
    ext x
    simp [h1s, â† h1s.mem_iff_infDist_zero h2s, â† NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/Polish.lean - 2024-09-07 21:59:43.213788.
---54/100---
For theorem MeasurableSet.analyticSet in Mathlib/MeasureTheory/Constructions/Polish.lean:
theorem _root_.MeasurableSet.analyticSet {Î± : Type*} [t : TopologicalSpace Î±] [PolishSpace Î±]
    [MeasurableSpace Î±] [BorelSpace Î±] {s : Set Î±} (hs : MeasurableSet s) : AnalyticSet s 


Original valid proof:
:= by
  obtain âŸ¨t', t't, t'_polish, s_closed, _âŸ© :
      âˆƒ t' : TopologicalSpace Î±, t' â‰¤ t âˆ§ @PolishSpace Î± t' âˆ§ IsClosed[t'] s âˆ§ IsOpen[t'] s :=
    hs.isClopenable
  have A := @IsClosed.analyticSet Î± t' t'_polish s s_closed
  convert @AnalyticSet.image_of_continuous Î± t' Î± t s A id (continuous_id_of_le t't)
  simp only [id, image_id']


Verifying proof (Commit 4968eba95a704a4a58e8b3735dc3733ee6d46c0d):
:= by
  obtain âŸ¨t', t't, t'_polish, s_closed, ?_âŸ© :
      âˆƒ t' : TopologicalSpace Î±, t' â‰¤ t âˆ§ @PolishSpace Î± t' âˆ§ IsClosed[t'] s âˆ§ IsOpen[t'] s :=
    hs.isClopenable
  have A := @IsClosed.analyticSet Î± t' t'_polish s s_closed
  convert @AnalyticSet.image_of_continuous Î± t' Î± t s A id (continuous_id_of_le t't)
  simp only [id, image_id']

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Besicovitch.lean - 2024-09-07 21:59:58.318735.
---55/100---
For theorem Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Î¼ : Measure Î±)
    [IsFiniteMeasure Î¼] (f : Î± â†’ Set â„) (s : Set Î±)
    (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty) :
    âˆƒ t : Set (Î± Ã— â„), t.Countable âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ (âˆ€ p âˆˆ t, p.2 âˆˆ f p.1) âˆ§
      Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) = 0 âˆ§
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 


Original valid proof:
:= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, ?_âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, âŸ¨?_, ?_, ?_âŸ©, ?_âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Î¼ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
:= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, ?_âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, âŸ¨?_, ?_, ?_âŸ©, ?_

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Differentiation.lean - 2024-09-07 22:00:16.345709.
---56/100---
For theorem VitaliFamily.mul_measure_le_of_subset_lt_limRatioMeas in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem mul_measure_le_of_subset_lt_limRatioMeas {q : â„â‰¥0} {s : Set Î±}
    (h : s âŠ† {x | (q : â„â‰¥0âˆ) < v.limRatioMeas hÏ x}) : (q : â„â‰¥0âˆ) * Î¼ s â‰¤ Ï s 


Original valid proof:
:= by
  let t := {x : Î± | Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatioMeas hÏ x))}
  have A : Î¼ tá¶œ = 0 := v.ae_tendsto_limRatioMeas hÏ
  suffices H : (q â€¢ Î¼) (s âˆ© t) â‰¤ Ï (s âˆ© t) by calc
    (q â€¢ Î¼) s = (q â€¢ Î¼) (s âˆ© t âˆª s âˆ© tá¶œ) := by rw [inter_union_compl]
    _ â‰¤ (q â€¢ Î¼) (s âˆ© t) + (q â€¢ Î¼) (s âˆ© tá¶œ) := measure_union_le _ _
    _ â‰¤ Ï (s âˆ© t) + (q â€¢ Î¼) tá¶œ := by gcongr; apply inter_subset_right
    _ = Ï (s âˆ© t) := by simp [A]
    _ â‰¤ Ï s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ ?_
  intro x hx
  have I : âˆ€á¶  a in v.filterAt x, (q : â„â‰¥0âˆ) < Ï a / Î¼ a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le


Verifying proof (Commit 40b64f797572a7615ba4553a28d3d6ee5049aa3b):
:= by
  let t := {x : Î± | Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatioMeas hÏ x))}
  have A : Î¼ tá¶œ = 0 := v.ae_tendsto_limRatioMeas hÏ
  suffices H : (q â€¢ Î¼) (s âˆ© t) â‰¤ Ï (s âˆ© t);
  exact
    calc
      (q â€¢ Î¼) s = (q â€¢ Î¼) (s âˆ© t âˆª s âˆ© tá¶œ) := by rw [inter_union_compl]
      _ â‰¤ (q â€¢ Î¼) (s âˆ© t) + (q â€¢ Î¼) (s âˆ© tá¶œ) := measure_union_le _ _)
      _ â‰¤ Ï (s âˆ© t) + q * Î¼ tá¶œ := by
        apply add_le_add H
        rw [coe_nnreal_smul_apply]
        exact mul_le_mul_left' (measure_mono inter_subset_right) _
      _ â‰¤ Ï s := by
        rw [A, mul_zero, add_zero]; exact measure_mono inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ _
  intro x hx
  have I : âˆ€á¶  a in v.filterAt x, (q : â„â‰¥0âˆ) < Ï a / Î¼ a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le

Attempt failure.

Working on Mathlib/MeasureTheory/Decomposition/Jordan.lean - 2024-09-07 22:00:30.834502.
---57/100---
For theorem MeasureTheory.JordanDecomposition.toSignedMeasure_injective in Mathlib/MeasureTheory/Decomposition/Jordan.lean:
theorem toSignedMeasure_injective : Injective <| @JordanDecomposition.toSignedMeasure Î± _ 


Original valid proof:
:= by
  intro jâ‚ jâ‚‚ hj
  obtain âŸ¨S, hSâ‚, hSâ‚‚, hSâ‚ƒ, hSâ‚„, hSâ‚…âŸ© := jâ‚.exists_compl_positive_negative
  obtain âŸ¨T, hTâ‚, hTâ‚‚, hTâ‚ƒ, hTâ‚„, hTâ‚…âŸ© := jâ‚‚.exists_compl_positive_negative
  rw [â† hj] at hTâ‚‚ hTâ‚ƒ
  obtain âŸ¨hSTâ‚, -âŸ© :=
    of_symmDiff_compl_positive_negative hSâ‚.compl hTâ‚.compl âŸ¨hSâ‚ƒ, (compl_compl S).symm â–¸ hSâ‚‚âŸ©
      âŸ¨hTâ‚ƒ, (compl_compl T).symm â–¸ hTâ‚‚âŸ©
  refine eq_of_posPart_eq_posPart ?_ hj
  ext1 i hi
  have hÎ¼â‚ : (jâ‚.posPart i).toReal = jâ‚.toSignedMeasure (i âˆ© Sá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hSâ‚.compl),
      show jâ‚.negPart (i âˆ© Sá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚… â–¸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i S]
    rw [measure_union,
      show jâ‚.posPart (i âˆ© S) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚„ â–¸ measure_mono Set.inter_subset_right),
      zero_add]
    Â· refine
        Set.disjoint_of_subset_left Set.inter_subset_right
          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    Â· exact hi.inter hSâ‚.compl
  have hÎ¼â‚‚ : (jâ‚‚.posPart i).toReal = jâ‚‚.toSignedMeasure (i âˆ© Tá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hTâ‚.compl),
      show jâ‚‚.negPart (i âˆ© Tá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚… â–¸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i T]
    rw [measure_union,
      show jâ‚‚.posPart (i âˆ© T) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚„ â–¸ measure_mono Set.inter_subset_right),
      zero_add]
    Â· exact
        Set.disjoint_of_subset_left Set.inter_subset_right
          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    Â· exact hi.inter hTâ‚.compl
  rw [â† ENNReal.toReal_eq_toReal (measure_ne_top _ _) (measure_ne_top _ _), hÎ¼â‚, hÎ¼â‚‚, â† hj]
  exact of_inter_eq_of_symmDiff_eq_zero_positive hSâ‚.compl hTâ‚.compl hi hSâ‚ƒ hTâ‚ƒ hSTâ‚


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  intro jâ‚ jâ‚‚ hj
  obtain âŸ¨S, hSâ‚, hSâ‚‚, hSâ‚ƒ, hSâ‚„, hSâ‚…âŸ© := jâ‚.exists_compl_positive_negative
  rw [â† hj] at hTâ‚‚ hTâ‚ƒ
  obtain âŸ¨hSTâ‚, -âŸ© :=
    of_symmDiff_compl_positive_negative hSâ‚.compl hTâ‚.compl âŸ¨hSâ‚ƒ, (compl_compl S).symm â–¸ hSâ‚‚âŸ©
      âŸ¨hTâ‚ƒ, (compl_compl T).symm â–¸ hTâ‚‚âŸ©
  refine eq_of_posPart_eq_posPart ?_ hj
  ext1 i hi
  have hÎ¼â‚ : (jâ‚.posPart i).toReal = jâ‚.toSignedMeasure (i âˆ© Sá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hSâ‚.compl),
      show jâ‚.negPart (i âˆ© Sá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚… â–¸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i S]
    rw [measure_union,
      show jâ‚.posPart (i âˆ© S) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚… â–¸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i S]
    rw [measure_union,
      show jâ‚.posPart (i âˆ© S) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚„ â–¸ measure_mono Set.inter_subset_right),
      zero_add]
    Â· exact
        Set.disjoint_of_subset_left Set.inter_subset_right
           (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    Â· exact hi.inter hSâ‚.compl
  have hÎ¼â‚‚ : (jâ‚‚.posPart i).toReal = jâ‚‚.toSignedMeasure (i âˆ© Tá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hTâ‚.compl),
      show jâ‚‚.negPart (i âˆ© Tá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚… â–¸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i T]
    rw [measure_union,
      show jâ‚‚.posPart (i âˆ© T) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚… â–¸ measure_mono Set.inter_subset_right),
      zero_add]
    Â· exact
        Set.disjoint_of_subset_left Set.inter_subset_right
           (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    Â· exact hi.inter hTâ‚.compl
  rw [â† ENNReal.toReal_eq_toReal (measure_ne_top _ _) (measure_ne_top _ _), hÎ¼â‚, hÎ¼â‚‚, â† hj]
  exact of_inter_eq_of_symmDiff_eq_zero_positive hSâ‚.compl hTâ‚.compl hi hSâ‚ƒ hTâ‚ƒ hSTâ‚

Attempt failure.

Working on Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean - 2024-09-07 22:00:40.865596.
---58/100---
For theorem MeasureTheory.FinStronglyMeasurable.exists_set_sigmaFinite in Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean:
theorem exists_set_sigmaFinite [Zero Î²] [TopologicalSpace Î²] [T2Space Î²]
    (hf : FinStronglyMeasurable f Î¼) :
    âˆƒ t, MeasurableSet t âˆ§ (âˆ€ x âˆˆ tá¶œ, f x = 0) âˆ§ SigmaFinite (Î¼.restrict t) 


Original valid proof:
:= by
  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©
  let T n := support (fs n)
  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := â‹ƒ n, T n
  refine âŸ¨t, MeasurableSet.iUnion hT_meas, ?_, ?_âŸ©
  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  Â· refine âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => ?_, ?_âŸ©âŸ©âŸ©
    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono Set.inter_subset_left).trans_lt (hT_lt_top n)
    Â· rw [â† Set.union_iUnion tá¶œ T]
      exact Set.compl_union_self _


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©
  let T n := support (fs n)
  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := â‹ƒ n, T n
  refine âŸ¨t, MeasurableSet.iUnion hT_meas, ?_, ?_âŸ©
  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  Â· refine âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => ?_, ?_âŸ©âŸ©âŸ©
    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono Set.inter_subset_left).trans_lt (hT_lt_top n)
    Â· rw [â† Set.union_iUnion tá¶œ T]
      exact Set.compl_union_self _

Attempt success.

Working on Mathlib/MeasureTheory/Group/Action.lean - 2024-09-07 22:00:56.300567.
---59/100---
For theorem MeasureTheory.smulInvariantMeasure_tfae in Mathlib/MeasureTheory/Group/Action.lean:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G Î± Î¼,
        âˆ€ (c : G) (s), MeasurableSet s â†’ Î¼ ((c â€¢ Â·) â»Â¹' s) = Î¼ s,
        âˆ€ (c : G) (s), MeasurableSet s â†’ Î¼ (c â€¢ s) = Î¼ s,
        âˆ€ (c : G) (s), Î¼ ((c â€¢ Â·) â»Â¹' s) = Î¼ s,
        âˆ€ (c : G) (s), Î¼ (c â€¢ s) = Î¼ s,
        âˆ€ c : G, Measure.map (c â€¢ Â·) Î¼ = Î¼,
        âˆ€ c : G, MeasurePreserving (c â€¢ Â·) Î¼ Î¼] 


Original valid proof:
:= by
  tfae_have 1 â†” 2
  Â· exact âŸ¨fun h => h.1, fun h => âŸ¨hâŸ©âŸ©
  tfae_have 1 â†’ 6
  Â· intro h c
    exact (measurePreserving_smul c Î¼).map_eq
  tfae_have 6 â†’ 7
  Â· exact fun H c => âŸ¨measurable_const_smul c, H câŸ©
  tfae_have 7 â†’ 4
  Â· exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have 4 â†’ 5
  Â· exact fun H c s => by
      rw [â† preimage_smul_inv]
      apply H
  tfae_have 5 â†’ 3
  Â· exact fun H c s _ => H c s
  tfae_have 3 â†’ 2
  Â· intro H c s hs
    rw [preimage_smul]
    exact H câ»Â¹ s hs
  tfae_finish


Verifying proof (Commit fba28f571f3d12084f060ccc0fd73ca4e275ccce):
:= by
  tfae_have 1 â†” 2
  Â· exact âŸ¨fun h => h.1, fun h => âŸ¨hâŸ©âŸ©
  tfae_have 1 â†’ 6
  Â· intro h c
    exact (measurePreserving_smul c Î¼).map_eq
  tfae_have 6 â†’ 7
  Â· exact fun H c => âŸ¨measurable_const_smul c, H câŸ©
  tfae_have 7 â†’ 4
  Â· exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have 4 â†’ 5
  Â· exact fun H c s => by
      rw [â† preimage_smul_inv]
      apply H
  tfae_have 5 â†’ 3
  Â· exact fun H c s _ => H c s
  tfae_have 3 â†’ 2
  Â· exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have 4 â†’ 5
  Â· exact fun H c s => by
      rw [â† preimage_smul_inv]
      apply H
  tfae_have 5 â†’ 3
  Â· exact fun H c s _ => H c s
  tfae_have 3 â†’ 2
  Â· exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have 4 â†’ 5
  Â· exact fun H c s => by
      rw [â† preimage_smul_inv]
      apply H
  tfae_have 5 â†’ 3
  Â· exact fun H c s _ => H c s
  tfae_have 3 â†’ 2
  Â· exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have 4 â†’ 5
  Â· exact fun H c s => by
      rw [â† preimage_smul_inv]
      apply H
  tfae_have 5 â†’ 3
  Â· exact fun H c s _ => H c s
  tfae_have 3 â†’ 2
  Â· intro H c s hs
    rw [preimage_smul]
    exact H câ»Â¹ s hs
  tfae_finish

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/CircleIntegral.lean - 2024-09-07 22:01:04.646737.
---60/100---
For theorem circleIntegral.norm_integral_lt_of_norm_le_const_of_lt in Mathlib/MeasureTheory/Integral/CircleIntegral.lean:
theorem norm_integral_lt_of_norm_le_const_of_lt {f : â„‚ â†’ E} {c : â„‚} {R C : â„} (hR : 0 < R)
    (hc : ContinuousOn f (sphere c R)) (hf : âˆ€ z âˆˆ sphere c R, â€–f zâ€– â‰¤ C)
    (hlt : âˆƒ z âˆˆ sphere c R, â€–f zâ€– < C) : â€–âˆ® z in C(c, R), f zâ€– < 2 * Ï€ * R * C 


Original valid proof:
:= by
  rw [â† _root_.abs_of_pos hR, â† image_circleMap_Ioc] at hlt
  rcases hlt with âŸ¨_, âŸ¨Î¸â‚€, hmem, rflâŸ©, hltâŸ©
  calc
    â€–âˆ® z in C(c, R), f zâ€– â‰¤ âˆ« Î¸ in (0)..2 * Ï€, â€–deriv (circleMap c R) Î¸ â€¢ f (circleMap c R Î¸)â€– :=
      intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le
    _ < âˆ« _ in (0)..2 * Ï€, R * C := by
      simp only [norm_smul, deriv_circleMap, norm_eq_abs, map_mul, abs_I, mul_one,
        abs_circleMap_zero, abs_of_pos hR]
      refine intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt
          Real.two_pi_pos ?_ continuousOn_const (fun Î¸ _ => ?_) âŸ¨Î¸â‚€, Ioc_subset_Icc_self hmem, ?_âŸ©
      Â· exact continuousOn_const.mul (hc.comp (continuous_circleMap _ _).continuousOn fun Î¸ _ =>
          circleMap_mem_sphere _ hR.le _).norm
      Â· exact mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere _ hR.le _) hR.le
      Â· exact (mul_lt_mul_left hR).2 hlt
    _ = 2 * Ï€ * R * C := by simp [mul_assoc]; ring


Verifying proof (Commit e92ad7acc4d771729f70601a74a3c091f330e507):
:= by
  rw [â† _root_.abs_of_pos hR, â† image_circleMap_Ioc] at hlt
  rcases hlt with âŸ¨_, âŸ¨Î¸â‚€, hmem, rflâŸ©, hltâŸ©
  calc
    â€–âˆ® z in C(c, R), f zâ€– â‰¤ âˆ« Î¸ in [0:2 * Ï€], â€–deriv (circleMap c R) Î¸ â€¢ f (circleMap c R Î¸)â€– :=
      intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le
    _ < âˆ« _ in [0:2 * Ï€], R * C := by
      simp only [norm_smul, deriv_circleMap, norm_eq_abs, map_mul, abs_I, mul_one,
        abs_circleMap_zero, abs_of_pos hR]
      refine intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt
          Real.two_pi_pos _ continuousOn_const (fun Î¸ _ => ?_) âŸ¨Î¸â‚€, Ioc_subset_Icc_self hmem, ?_âŸ©
      Â· exact continuousOn_const.mul (hc.comp (continuous_circleMap _ _).continuousOn fun Î¸ _ =>
          circleMap_mem_sphere _ hR.le _).norm
      Â· exact mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere _ hR.le _) hR.le
      Â· exact (mul_lt_mul_left hR).2 hlt
    _ = 2 * Ï€ * R * C := by simp [mul_assoc]; ring

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Haar/Quotient.lean - 2024-09-07 22:01:38.353203.
---61/100---
For theorem QuotientGroup.integral_mul_eq_integral_automorphize_mul in Mathlib/MeasureTheory/Measure/Haar/Quotient.lean:
lemma QuotientGroup.integral_mul_eq_integral_automorphize_mul {K : Type*} [NormedField K]
    [NormedSpace â„ K] [Î¼.IsMulRightInvariant] {f : G â†’ K}
    (f_â„’_1 : Integrable f Î¼) {g : G â§¸ Î“ â†’ K} (hg : AEStronglyMeasurable g Î¼_ğ“•)
    (g_â„’_infinity : essSup (fun x â†¦ â†‘â€–g xâ€–â‚Š) Î¼_ğ“• â‰  âˆ)
    (F_ae_measurable : AEStronglyMeasurable (QuotientGroup.automorphize f) Î¼_ğ“•) :
    âˆ« x : G, g (x : G â§¸ Î“) * (f x) âˆ‚Î¼
      = âˆ« x : G â§¸ Î“, g x * (QuotientGroup.automorphize f x) âˆ‚Î¼_ğ“• 


Original valid proof:
:= by
  let Ï€ : G â†’ G â§¸ Î“ := QuotientGroup.mk
  have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable
  have Hâ‚€ : QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) = g * (QuotientGroup.automorphize f) := by
    exact QuotientGroup.automorphize_smul_left f g
  calc âˆ« (x : G), g (Ï€ x) * (f x) âˆ‚Î¼ =
        âˆ« (x : G â§¸ Î“), QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) x âˆ‚Î¼_ğ“• := ?_
    _ = âˆ« (x : G â§¸ Î“), g x * (QuotientGroup.automorphize f x) âˆ‚Î¼_ğ“• := by simp [Hâ‚€]
  have Hâ‚ : Integrable ((g âˆ˜ Ï€) * f) Î¼ := by
    have : AEStronglyMeasurable (fun (x : G) â†¦ g (x : (G â§¸ Î“))) Î¼ :=
      (hg.mono_ac hğ“•.absolutelyContinuous_map).comp_measurable meas_Ï€
    refine Integrable.essSup_smul f_â„’_1 this ?_
    have hg' : AEStronglyMeasurable (fun x â†¦ (â€–g xâ€–â‚Š : â„â‰¥0âˆ)) Î¼_ğ“• :=
      (ENNReal.continuous_coe.comp continuous_nnnorm).comp_aestronglyMeasurable hg
    rw [â† essSup_comp_quotientGroup_mk hğ“• hg'.aemeasurable]
    exact g_â„’_infinity
  have Hâ‚‚ : AEStronglyMeasurable (QuotientGroup.automorphize ((g âˆ˜ Ï€) * f)) Î¼_ğ“• := by
    simp_rw [Hâ‚€]
    exact hg.mul F_ae_measurable
  apply QuotientGroup.integral_eq_integral_automorphize hğ“• Hâ‚ Hâ‚‚


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
:= by
  let Ï€ : G â†’ G â§¸ Î“ := QuotientGroup.mk
  have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable
  have Hâ‚€ : QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) = g * (QuotientGroup.automorphize f) := by
    exact QuotientGroup.automorphize_smul_left f g
  calc âˆ« (x : G), g (Ï€ x) * (f x) âˆ‚Î¼ =
        âˆ« (x : G â§¸ Î“), QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) x âˆ‚Î¼_ğ“• := ?_
    _ = âˆ« (x : G â§¸ Î“), g x * (QuotientGroup.automorphize f x) âˆ‚Î¼_ğ“• := by simp [Hâ‚€]
  have Hâ‚ : Integrable ((g âˆ˜ Ï€) * f) Î¼
  Â· have : AEStronglyMeasurable (fun (x : G) â†¦ g (x : (G â§¸ Î“))) Î¼
    Â· refine (AEStronglyMeasurable.mono' hg ?_).comp_measurable meas_Ï€
      exact hğ“•.absolutelyContinuous_map
    refine Integrable.essSup_smul f_â„’_1 this ?_
    have hg' : AEStronglyMeasurable (fun x â†¦ (â€–g xâ€–â‚Š : â„â‰¥0âˆ)) Î¼_ğ“• :=
      (ENNReal.continuous_coe.comp continuous_nnnorm).comp_aestronglyMeasurable hg
    rw [â† essSup_comp_quotientGroup_mk hğ“• hg'.aemeasurable]
    exact g_â„’_infinity
  have Hâ‚‚ : AEStronglyMeasurable (QuotientGroup.automorphize ((g âˆ˜ Ï€) * f)) Î¼_ğ“•
  Â· simp_rw [Hâ‚€]
    exact hg.mul F_ae_measurable
  apply QuotientGroup.integral_eq_integral_automorphize hğ“• Hâ‚ Hâ‚‚

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Hausdorff.lean - 2024-09-07 22:01:53.471406.
---62/100---
For theorem Isometry.hausdorffMeasure_image in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s 


Original valid proof:
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd

Attempt success.

Working on Mathlib/MeasureTheory/Measure/MeasureSpace.lean - 2024-09-07 22:02:09.782241.
---63/100---
For theorem MeasureTheory.measure_limsup_eq_zero in Mathlib/MeasureTheory/Measure/MeasureSpace.lean:
theorem measure_limsup_eq_zero {s : â„• â†’ Set Î±} (hs : (âˆ‘' i, Î¼ (s i)) â‰  âˆ) :
    Î¼ (limsup s atTop) = 0 


Original valid proof:
:= by
  set t : â„• â†’ Set Î± := fun n => toMeasurable Î¼ (s n)
  have ht : (âˆ‘' i, Î¼ (t i)) â‰  âˆ := by simpa only [t, measure_toMeasurable] using hs
  suffices Î¼ (limsup t atTop) = 0 by
    have A : s â‰¤ t := fun n => subset_toMeasurable Î¼ (s n)
    exact measure_mono_null (limsup_le_limsup (eventually_of_forall (Pi.le_def.mp A))) this
  simp only [limsup_eq_iInf_iSup_of_nat', Set.iInf_eq_iInter, Set.iSup_eq_iUnion, â†
    nonpos_iff_eq_zero]
  refine
    le_of_tendsto_of_tendsto'
      (tendsto_measure_iInter
        (fun i => MeasurableSet.iUnion fun b => measurableSet_toMeasurable _ _) ?_
        âŸ¨0, ne_top_of_le_ne_top ht (measure_iUnion_le t)âŸ©)
      (ENNReal.tendsto_sum_nat_add (Î¼ âˆ˜ t) ht) fun n => measure_iUnion_le _
  intro n m hnm x
  simp only [Set.mem_iUnion]
  exact fun âŸ¨i, hiâŸ© => âŸ¨i + (m - n), by simpa only [add_assoc, tsub_add_cancel_of_le hnm] using hiâŸ©


Verifying proof (Commit 464f10c2e8d95b797cf97f9520e276bb51b872af):
:= by
  set t : â„• â†’ Set Î± := fun n => toMeasurable Î¼ (s n)
  have ht : (âˆ‘' i, Î¼ (t i)) â‰  âˆ := by simpa only [measure_toMeasurable] using hs
  suffices Î¼ (limsup t atTop) = 0 by
    have A : s â‰¤ t := fun n => subset_toMeasurable Î¼ (s n)
    exact
      measure_mono_null
        (limsup_le_limsup (eventually_of_forall (Pi.le_def.mp A)) isCobounded_le_of_bot
          isBounded_le_of_top)
        this
  simp only [limsup_eq_iInf_iSup_of_nat', Set.iInf_eq_iInter, Set.iSup_eq_iUnion, â†
    nonpos_iff_eq_zero]
  refine
    le_of_tendsto_of_tendsto'
      (tendsto_measure_iInter
        (fun i => MeasurableSet.iUnion fun b => measurableSet_toMeasurable _ _) ?_
        âŸ¨0, ne_top_of_le_ne_top ht (measure_iUnion_le t)âŸ©)
      (ENNReal.tendsto_sum_nat_add (Î¼ âˆ˜ t) ht) fun n => measure_iUnion_le _
  intro n m hnm x
  simp only [Set.mem_iUnion]
  exact fun âŸ¨i, hiâŸ© => âŸ¨i + (m - n), by simpa only [add_assoc, tsub_add_cancel_of_le hnm] using hiâŸ©

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/VectorMeasure.lean - 2024-09-07 22:02:27.457629.
---64/100---
For theorem MeasureTheory.VectorMeasure.MutuallySingular.add_left in Mathlib/MeasureTheory/Measure/VectorMeasure.lean:
theorem add_left [T2Space N] [ContinuousAdd M] (hâ‚ : vâ‚ âŸ‚áµ¥ w) (hâ‚‚ : vâ‚‚ âŸ‚áµ¥ w) : vâ‚ + vâ‚‚ âŸ‚áµ¥ w 


Original valid proof:
:= by
  obtain âŸ¨u, hmu, huâ‚, huâ‚‚âŸ© := hâ‚
  obtain âŸ¨v, hmv, hvâ‚, hvâ‚‚âŸ© := hâ‚‚
  refine mk (u âˆ© v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_
  Â· rw [add_apply, huâ‚ _ (Set.subset_inter_iff.1 ht).1, hvâ‚ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  Â· rw [Set.compl_inter] at ht
    rw [(_ : t = uá¶œ âˆ© t âˆª vá¶œ \ uá¶œ âˆ© t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), huâ‚‚, hvâ‚‚, add_zero]
    Â· exact Set.Subset.trans Set.inter_subset_left diff_subset
    Â· exact Set.inter_subset_left
    Â· exact disjoint_sdiff_self_right.mono Set.inter_subset_left Set.inter_subset_left
    Â· apply Set.Subset.antisymm <;> intro x hx
      Â· by_cases hxu' : x âˆˆ uá¶œ
        Â· exact Or.inl âŸ¨hxu', hxâŸ©
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr âŸ¨âŸ¨hxv, hxu'âŸ©, hxâŸ©]
      Â· cases' hx with hx hx <;> exact hx.2


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
:= by
  obtain âŸ¨u, hmu, huâ‚, huâ‚‚âŸ© := hâ‚
  obtain âŸ¨v, hmv, hvâ‚, hvâ‚‚âŸ© := hâ‚‚
  refine mk (u âˆ© v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_
  Â· rw [add_apply, huâ‚ _ (Set.subset_inter_iff.1 ht).1, hvâ‚ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  Â· rw [Set.compl_inter] at ht
    rw [(_ : t = uá¶œ âˆ© t âˆª vá¶œ \ uá¶œ âˆ© t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), huâ‚‚, hvâ‚‚, add_zero]
    Â· exact Set.Subset.trans Set.inter_subset_left Set.inter_subset_left
    Â· apply Set.Subset.antisymm <;> intro x hx
      Â· by_cases hxu' : x âˆˆ uá¶œ
        Â· exact Or.inl âŸ¨hxu', hxâŸ©
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr âŸ¨âŸ¨hxv, hxu'âŸ©, hxâŸ©]
      Â· cases' hx with hx hx <;> exact hx.2

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/Finite.lean - 2024-09-07 22:02:41.385699.
---65/100---
For theorem ClassGroup.exists_mem_finsetApprox in Mathlib/NumberTheory/ClassNumber/Finite.lean:
theorem exists_mem_finsetApprox (a : S) {b} (hb : b â‰  (0 : R)) :
    âˆƒ q : S,
      âˆƒ r âˆˆ finsetApprox bS adm, abv (Algebra.norm R (r â€¢ a - b â€¢ q)) <
      abv (Algebra.norm R (algebraMap R S b)) 


Original valid proof:
:= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ (Fintype.card Î¹ : â„)
                â‰¤ abv b ^ (Fintype.card Î¹ : â„) := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancelâ‚€, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; omega
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i / b
  let rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Î¼, qs, rs, Finset.smul_sum, â† Finset.sum_add_distrib]
    refine Finset.sum_congr rfl fun i _ => ?_
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine âŸ¨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [q, r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine Finset.sum_congr rfl fun x _ => ?_
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)
  Â· apply le_of_eq
    congr
    simp_rw [map_sum, map_sub, map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  Â· exact mod_cast Îµ_le


Verifying proof (Commit 6eab74639023015a7887e2f82e153907286e3801):
:= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ Fintype.card Î¹ â‰¤ abv b ^ Fintype.card Î¹ := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancel, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; linarith
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Finset.smul_sum, â† Finset.sum_add_distrib]
    refine
      Finset.sum_congr rfl fun i _ => ?_
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine âŸ¨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine Finset.sum_congr rfl fun x _ => ?_
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)
  Â· apply le_of_eq
    congr
    simp_rw [LinearEquiv.map_sum, LinearEquiv.map_sum, LinearEquiv.map_sum, LinearEq

Attempt failure.

---66/100---
For theorem ClassGroup.exists_mem_finsetApprox in Mathlib/NumberTheory/ClassNumber/Finite.lean:
theorem exists_mem_finsetApprox (a : S) {b} (hb : b â‰  (0 : R)) :
    âˆƒ q : S,
      âˆƒ r âˆˆ finsetApprox bS adm, abv (Algebra.norm R (r â€¢ a - b â€¢ q)) <
      abv (Algebra.norm R (algebraMap R S b)) 


Original valid proof:
:= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ (Fintype.card Î¹ : â„)
                â‰¤ abv b ^ (Fintype.card Î¹ : â„) := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancelâ‚€, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; omega
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i / b
  let rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Î¼, qs, rs, Finset.smul_sum, â† Finset.sum_add_distrib]
    refine Finset.sum_congr rfl fun i _ => ?_
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine âŸ¨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [q, r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine Finset.sum_congr rfl fun x _ => ?_
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)
  Â· apply le_of_eq
    congr
    simp_rw [map_sum, map_sub, map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  Â· exact mod_cast Îµ_le


Verifying proof (Commit 6d1b77e97159c51b0084f053ab93299f39b3a009):
:= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ Fintype.card Î¹ â‰¤ abv b ^ Fintype.card Î¹ := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancel, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; linarith
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Finset.smul_sum, â† Finset.sum_add_distrib]
    refine
      Finset.sum_congr rfl fun i _ => ?_
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine âŸ¨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine Finset.sum_congr rfl fun x _ => ?_
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)
  Â· apply le_of_eq
    congr
    simp_rw [LinearEquiv.map_sum, LinearEquiv.map_sum, LinearEquiv.map_sum, LinearEquiv,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; linarith
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ 

Attempt failure.

Working on Mathlib/NumberTheory/Modular.lean - 2024-09-07 22:03:19.258135.
---67/100---
For theorem ModularGroup.c_eq_zero in Mathlib/NumberTheory/Modular.lean:
theorem c_eq_zero (hz : z âˆˆ ğ’Ÿáµ’) (hg : g â€¢ z âˆˆ ğ’Ÿáµ’) : (â†‘â‚˜g) 1 0 = 0 


Original valid proof:
:= by
  have hp : âˆ€ {g' : SL(2, â„¤)}, g' â€¢ z âˆˆ ğ’Ÿáµ’ â†’ (â†‘â‚˜g') 1 0 â‰  1 := by
    intro g' hg'
    by_contra hc
    let a := (â†‘â‚˜g') 0 0
    let d := (â†‘â‚˜g') 1 1
    have had : T ^ (-a) * g' = S * T ^ d := by rw [g_eq_of_c_eq_one hc]; group
    let w := T ^ (-a) â€¢ g' â€¢ z
    have hâ‚ : w = S â€¢ T ^ d â€¢ z := by simp only [w, â† mul_smul, had]
    replace hâ‚ : normSq w < 1 := hâ‚.symm â–¸ normSq_S_smul_lt_one (one_lt_normSq_T_zpow_smul hz d)
    have hâ‚‚ : 1 < normSq w := one_lt_normSq_T_zpow_smul hg' (-a)
    linarith
  have hn : (â†‘â‚˜g) 1 0 â‰  -1 := by
    intro hc
    replace hc : (â†‘â‚˜(-g)) 1 0 = 1 := by simp [â† neg_eq_iff_eq_neg.mpr hc]
    replace hg : -g â€¢ z âˆˆ ğ’Ÿáµ’ := (SL_neg_smul g z).symm â–¸ hg
    exact hp hg hc
  specialize hp hg
  rcases Int.abs_le_one_iff.mp <| abs_c_le_one hz hg with âŸ¨âŸ© <;> tauto


Verifying proof (Commit f3db3040b24eea7e8cf5c566bd4354149c7dbdc9):
:= by
  have hp : âˆ€ {g' : SL(2, â„¤)}, g' â€¢ z âˆˆ ğ’Ÿáµ’ â†’ (â†‘â‚˜g') 1 0 â‰  1 := by
    intro g' hg'
    by_contra hc
    let a := (â†‘â‚˜g') 0 0
    let d := (â†‘â‚˜g') 1 1
    have had : T ^ (-a) * g' = S * T ^ d := by rw [g_eq_of_c_eq_one hc]; group
    let w := T ^ (-a) â€¢ g' â€¢ z
    have hâ‚ : w = S â€¢ T ^ d â€¢ z := by simp only [â† mul_smul, had]
    replace hâ‚ : normSq w < 1 := hâ‚.symm â–¸ normSq_S_smul_lt_one (one_lt_normSq_T_zpow_smul hz d)
    have hâ‚‚ : 1 < normSq w := one_lt_normSq_T_zpow_smul hg' (-a)
    linarith
  have hn : (â†‘â‚˜g) 1 0 â‰  -1 := by
    intro hc
    replace hc : (â†‘â‚˜(-g)) 1 0 = 1; Â· simp [â† neg_eq_iff_eq_neg.mpr hc]
    replace hg : -g â€¢ z âˆˆ ğ’Ÿáµ’ := (SL_neg_smul g z).symm â–¸ hg
    exact hp hg hc
  specialize hp hg
  rcases Int.abs_le_one_iff.mp <| abs_c_le_one hz hg with âŸ¨âŸ© <;> tauto

Attempt failure.

Working on Mathlib/Order/Height.lean - 2024-09-07 22:03:35.683353.
---68/100---
For theorem Set.chainHeight_eq_iSup_Ici in Mathlib/Order/Height.lean:
theorem chainHeight_eq_iSup_Ici : s.chainHeight = â¨† i âˆˆ s, (s âˆ© Set.Ici i).chainHeight 


Original valid proof:
:= by
  apply le_antisymm
  Â· refine iSupâ‚‚_le ?_
    rintro (_ | âŸ¨x, xsâŸ©) h
    Â· exact zero_le _
    Â· apply le_trans _ (le_iSupâ‚‚ x (cons_mem_subchain_iff.mp h).1)
      apply length_le_chainHeight_of_mem_subchain
      refine âŸ¨h.1, fun i hi â†¦ âŸ¨h.2 i hi, ?_âŸ©âŸ©
      cases hi
      Â· exact left_mem_Ici
      rename_i hi
      cases' chain'_iff_pairwise.mp h.1 with _ _ h'
      exact (h' _ hi).le
  Â· exact iSupâ‚‚_le fun i _ â†¦ chainHeight_mono Set.inter_subset_left


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
:= by
  apply le_antisymm
  Â· refine iSupâ‚‚_le ?_
    rintro (_ | âŸ¨x, xsâŸ©) h
    Â· exact zero_le _
    Â· apply le_trans _ (le_iSupâ‚‚ x (cons_mem_subchain_iff.mp h).1)
      apply length_le_chainHeight_of_mem_subchain
      refine âŸ¨h.1, fun i hi â†¦ âŸ¨h.2 i hi, ?_âŸ©âŸ©
      cases hi
      Â· exact left_mem_Ici
      rename_i hi
      cases' chain'_iff_pairwise.mp h.1 with _ _ h'
      exact (h' _ hi).le
  Â· exact iSupâ‚‚_le fun i _ â†¦ chainHeight_mono <| Set.inter_subset_left

Attempt success.

Working on Mathlib/Order/WellFoundedSet.lean - 2024-09-07 22:03:41.659339.
---69/100---
For theorem Set.partiallyWellOrderedOn_union in Mathlib/Order/WellFoundedSet.lean:
theorem partiallyWellOrderedOn_union :
    (s âˆª t).PartiallyWellOrderedOn r â†” s.PartiallyWellOrderedOn r âˆ§ t.PartiallyWellOrderedOn r 


Original valid proof:
:=
  âŸ¨fun h => âŸ¨h.mono subset_union_left, h.mono subset_union_rightâŸ©, fun h =>
    h.1.union h.2âŸ©


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
:=
  âŸ¨fun h => âŸ¨h.mono subset_union_left, h.mono subset_union_rightâŸ©, fun h =>
    h.1.union h.2âŸ©

Attempt success.

---70/100---
For theorem Set.WellFoundedOn.acc_iff_wellFoundedOn in Mathlib/Order/WellFoundedSet.lean:
theorem acc_iff_wellFoundedOn {Î±} {r : Î± â†’ Î± â†’ Prop} {a : Î±} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r] 


Original valid proof:
:= by
  tfae_have 1 â†’ 2
  Â· refine fun h => âŸ¨fun b => InvImage.accessible _ ?_âŸ©
    rw [â† acc_transGen_iff] at h âŠ¢
    obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2
    Â· rwa [h'] at h
    Â· exact h.inv h'
  tfae_have 2 â†’ 3
  Â· exact fun h => h.subset fun _ => TransGen.to_reflTransGen
  tfae_have 3 â†’ 1
  Â· refine fun h => Acc.intro _ (fun b hb => (h.apply âŸ¨b, .single hbâŸ©).of_fibration Subtype.val ?_)
    exact fun âŸ¨c, hcâŸ© d h => âŸ¨âŸ¨d, .head h hcâŸ©, h, rflâŸ©
  tfae_finish


Verifying proof (Commit 415d6b952a0c6bc1221dd68bc6ae84a0390ea21f):
:= by
  tfae_have 1 â†’ 2
  Â· by
      refine fun h => âŸ¨fun b => InvImage.accessible _ ?_âŸ©
      rw [â† acc_transGen_iff] at h âŠ¢
      obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2
      Â· rwa [h'] at h
      Â· exact h.inv h'
    2 â†’ 3
  Â· exact fun h => h.subset fun _ => TransGen.to_reflTransGen
    3 â†’ 1
  Â· exact fun âŸ¨c, hcâŸ© d h => âŸ¨âŸ¨d, .head h hcâŸ©, h, rflâŸ©

Attempt failure.

Working on Mathlib/Probability/Distributions/Gaussian.lean - 2024-09-07 22:03:55.557016.
---71/100---
For theorem ProbabilityTheory.gaussianReal_map_const_mul in Mathlib/Probability/Distributions/Gaussian.lean:
lemma gaussianReal_map_const_mul (c : â„) :
    (gaussianReal Î¼ v).map (c * Â·) = gaussianReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v) 


Original valid proof:
:= by
  by_cases hv : v = 0
  Â· simp only [hv, mul_zero, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.const_mul c) Î¼
  by_cases hc : c = 0
  Â· simp only [hc, zero_mul, ne_eq, abs_zero, mul_eq_zero]
    rw [Measure.map_const]
    simp only [ne_eq, measure_univ, one_smul, mul_eq_zero]
    convert (gaussianReal_zero_var 0).symm
    simp only [ne_eq, zero_pow, mul_eq_zero, hv, or_false, not_false_eq_true]
    rfl
  let e : â„ â‰ƒáµ â„ := (Homeomorph.mulLeftâ‚€ c hc).symm.toMeasurableEquiv
  have he' : âˆ€ x, HasDerivAt e ((fun _ â†¦ câ»Â¹) x) x := by
    suffices âˆ€ x, HasDerivAt (fun x => câ»Â¹ * x) (câ»Â¹ * 1) x by rwa [mul_one] at this
    exact fun _ â†¦ HasDerivAt.const_mul _ (hasDerivAt_id _)
  change (gaussianReal Î¼ v).map e.symm = gaussianReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v)
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs',
    gaussianReal_apply_eq_integral _ _ s']
  swap
  Â· simp only [ne_eq, mul_eq_zero, hv, or_false]
    rw [â† NNReal.coe_inj]
    simp [hc]
  simp only [e, Homeomorph.mulLeftâ‚€, Equiv.toFun_as_coe, Equiv.mulLeftâ‚€_apply, Equiv.invFun_as_coe,
    Equiv.mulLeftâ‚€_symm_apply, Homeomorph.toMeasurableEquiv_coe, Homeomorph.homeomorph_mk_coe_symm,
    Equiv.coe_fn_symm_mk, gaussianPDFReal_inv_mul hc]
  congr with x
  suffices |câ»Â¹| * |c| = 1 by rw [â† mul_assoc, this, one_mul]
  rw [abs_inv, inv_mul_cancel]
  rwa [ne_eq, abs_eq_zero]


Verifying proof (Commit 62a9ca63fe8a39ea0004bbc5dbf652532269c0b1):
:= by
  by_cases hv : v = 0
  Â· simp only [hv, mul_zero, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.const_mul c) Î¼
  by_cases hc : c = 0
  Â· simp only [hc, zero_mul, ne_eq, abs_zero, mul_eq_zero]
    rw [Measure.map_const]
    simp only [ne_eq, measure_univ, one_smul, mul_eq_zero]
    convert (gaussianReal_zero_var 0).symm
    simp only [ne_eq, zero_pow', mul_eq_zero, hv, or_false, not_false_eq_true]
    rfl
  let e : â„ â‰ƒáµ â„ := (Homeomorph.mulLeftâ‚€ c hc).symm.toMeasurableEquiv
  have he' : âˆ€ x, HasDerivAt e ((fun _ â†¦ câ»Â¹) x) x := by
    suffices âˆ€ x, HasDerivAt (fun x => câ»Â¹ * x) (câ»Â¹ * 1) x by rwa [mul_one] at this
    exact fun _ â†¦ HasDerivAt.const_mul _ (hasDerivAt_id _)
  change (gaussianReal Î¼ v).map e.symm = gaussianReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v)
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, ne_eq, mul_eq_zero]

Attempt failure.

Working on Mathlib/Probability/Kernel/WithDensity.lean - 2024-09-07 22:04:19.829350.
---72/100---
For theorem ProbabilityTheory.kernel.isSFiniteKernel_withDensity_of_isFiniteKernel in Mathlib/Probability/Kernel/WithDensity.lean:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (Îº : kernel Î± Î²) [IsFiniteKernel Îº]
    (hf_ne_top : âˆ€ a b, f a b â‰  âˆ) : IsSFiniteKernel (withDensity Îº f) 


Original valid proof:
:= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; Â· rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ n := by
    intro a b n hn
    have : (f a b).toReal â‰¤ n := Nat.le_of_ceil_le hn
    rw [â† ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    Â· refine this.trans (le_of_eq ?_)
      rw [ENNReal.ofReal_natCast]
    Â· norm_cast
      exact zero_le _
  have h_zero : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b âˆ§ min (f a b) n = f a b by
      simp_rw [fs, this.1, this.2, tsub_self (f a b)]
    exact âŸ¨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)âŸ©
  have hf_eq_tsum : f = âˆ‘' n, fs n := by
    have h_sum_a : âˆ€ a, Summable fun n => fs n a := by
      refine fun a => Pi.summable.mpr fun b => ?_
      suffices âˆ€ n, n âˆ‰ Finset.range âŒˆ(f a b).toRealâŒ‰â‚Š â†’ fs n a b = 0 from
        summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : âˆ€ n, âˆ‘ i âˆˆ Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      Â· simp
      rw [Finset.sum_range_succ, hn]
      simp [fs]
    simp_rw [h_finset_sum]
    refine (Filter.Tendsto.liminf_eq ?_).symm
    refine Filter.Tendsto.congr' ?_ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact âŸ¨âŒˆ(f a b).toRealâŒ‰â‚Š, fun n hn => (min_eq_left (h_le a b n hn)).symmâŸ©
  rw [hf_eq_tsum, withDensity_tsum _ fun n : â„• => _]
  swap; Â· exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine isSFiniteKernel_sum fun n => ?_
  suffices IsFiniteKernel (withDensity Îº (fs n)) by haveI := this; infer_instance
  refine isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : â†‘n + 1 â‰  âˆ) fun a b => ?_
  beta_reduce
  norm_cast
  calc
    fs n a b â‰¤ min (f a b) (n + 1) := tsub_le_self
    _ â‰¤ n + 1 := min_le_right _ _
    _ = â†‘(n + 1) := by norm_cast


Verifying proof (Commit 5ac9cb38fcf9079f6519764442b871fbd4091ab1):
:= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; Â· rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ n := by
    intro a b n hn
    have : (f a b).toReal â‰¤ n := Nat.le_of_ceil_le hn
    rw [â† ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    Â· refine this.trans (le_of_eq ?_)
      rw [ENNReal.ofReal_coe_nat]
    Â· norm_cast
      exact zero_le _
  have h_zero : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b âˆ§ min (f a b) n = f a b by
      simp_rw [this.1, this.2, tsub_self (f a b)]
    exact âŸ¨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)âŸ©
  have hf_eq_tsum : f = âˆ‘' n, fs n := by
    have h_sum_a : âˆ€ a, Summable fun n => fs n a := by
      refine fun a => Pi.summable.mpr fun b => ?_
      suffices âˆ€ n, n âˆ‰ Finset.range âŒˆ(f a b).toRealâŒ‰â‚Š â†’ fs n a b = 0
      exact summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : âˆ€ n, âˆ‘ i âˆˆ Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      Â· simp
      rw [Finset.sum_range_succ, hn]
      simp
    simp_rw [h_finset_sum]
    refine (Filter.Tendsto.liminf_eq ?_).symm
    refine Filter.Tendsto.congr' ?_ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact âŸ¨âŒˆ(f a b).toRealâŒ‰â‚Š, fun n hn => (min_eq_left (h_le a b n hn)).symmâŸ©
  rw [hf_eq_tsum, withDensity_tsum _ fun n : â„• => ?_]
  swap; Â· exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine isSFiniteKernel_sum fun n => ?_
  suffices IsFiniteKernel (withDensity Îº (fs n)) by haveI := this; infer_instance
  refine isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : â†‘n + 1 â‰  âˆ) fun a b => ?_
  norm_cast
  calc
    fs n a b â‰¤ min (f a b) (n + 1) := tsub_le_self
    _ â‰¤ n + 1 := (min_le_right _ _)
    _ = â†‘(n + 1) := by norm_cast

Attempt failure.

Working on Mathlib/RingTheory/Adjoin/PowerBasis.lean - 2024-09-07 22:04:29.407823.
---73/100---
For theorem PowerBasis.repr_mul_isIntegral in Mathlib/RingTheory/Adjoin/PowerBasis.lean:
theorem repr_mul_isIntegral [IsDomain S] {x y : A} (hx : âˆ€ i, IsIntegral R (B.basis.repr x i))
    (hy : âˆ€ i, IsIntegral R (B.basis.repr y i))
    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) :
    âˆ€ i, IsIntegral R (B.basis.repr (x * y) i) 


Original valid proof:
:= by
  intro i
  rw [â† B.basis.sum_repr x, â† B.basis.sum_repr y, Finset.sum_mul_sum, â† Finset.sum_product',
    map_sum, Finset.sum_apply']
  refine IsIntegral.sum _ fun I _ => ?_
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smulâ‚›â‚—,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine (hy _).mul ((hx _).mul ?_)
  simp only [coe_basis, â† pow_add]
  exact repr_gen_pow_isIntegral hB hmin _ _


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  intro i
  rw [â† B.basis.sum_repr x, â† B.basis.sum_repr y, Finset.sum_mul_sum, map_sum, Finset.sum_apply']
  refine IsIntegral.sum ?_ fun I _ => ?_
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smulâ‚›â‚—,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine isIntegral_mul (hy _) (isIntegral_mul (hx _) ?_)
  simp only [coe_basis, â† pow_add]
  refine repr_gen_pow_isIntegral hB hmin _ _

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Different.lean - 2024-09-07 22:04:38.796719.
---74/100---
For theorem FractionalIdeal.dual_eq_mul_inv in Mathlib/RingTheory/DedekindDomain/Different.lean:
lemma dual_eq_mul_inv :
    dual A K I = dual A K 1 * Iâ»Â¹ 


Original valid proof:
:= by
  by_cases hI : I = 0; Â· simp [hI]
  apply le_antisymm
  Â· suffices dual A K I * I â‰¤ dual A K 1 by
      convert mul_right_mono Iâ»Â¹ this using 1; simp only [mul_inv_cancel hI, mul_one, mul_assoc]
    rw [â† le_dual_iff A K hI]
  rw [le_dual_iff A K hI, mul_assoc, inv_mul_cancel hI, mul_one]


Verifying proof (Commit 3465d1aaae242475fad59e688648a2285031d19e):
:= by
  by_cases hI : I = 0; Â· simp [hI]
  apply le_antisymm
  Â· suffices dual A K I * I â‰¤ dual A K 1
    Â· convert mul_right_mono Iâ»Â¹ this using 1; simp only [mul_inv_cancel hI, mul_one, mul_assoc]
    rw [â† le_dual_iff hI]
  rw [le_dual_iff hI, mul_assoc, inv_mul_cancel hI, mul_one]

Attempt failure.

Working on Mathlib/RingTheory/EisensteinCriterion.lean - 2024-09-07 22:05:07.717115.
---75/100---
For theorem Polynomial.irreducible_of_eisenstein_criterion in Mathlib/RingTheory/EisensteinCriterion.lean:
theorem irreducible_of_eisenstein_criterion {f : R[X]} {P : Ideal R} (hP : P.IsPrime)
    (hfl : f.leadingCoeff âˆ‰ P) (hfP : âˆ€ n : â„•, â†‘n < degree f â†’ f.coeff n âˆˆ P) (hfd0 : 0 < degree f)
    (h0 : f.coeff 0 âˆ‰ P ^ 2) (hu : f.IsPrimitive) : Irreducible f 


Original valid proof:
:=
  have hf0 : f â‰  0 := fun _ => by simp_all only [not_true, Submodule.zero_mem, coeff_zero]
  have hf : f.map (mk P) = C (mk P (leadingCoeff f)) * X ^ natDegree f :=
    map_eq_C_mul_X_pow_of_forall_coeff_mem hfP
  have hfd0 : 0 < f.natDegree := WithBot.coe_lt_coe.1 (lt_of_lt_of_le hfd0 degree_le_natDegree)
  âŸ¨mt degree_eq_zero_of_isUnit fun h => by simp_all only [lt_irrefl], by
    rintro p q rfl
    rw [Polynomial.map_mul] at hf
    rcases mul_eq_mul_prime_pow
        (show Prime (X : Polynomial (R â§¸ P)) from monic_X.prime_of_degree_eq_one degree_X) hf with
      âŸ¨m, n, b, c, hmnd, hbc, hp, hqâŸ©
    have hmn : 0 < m â†’ 0 < n â†’ False := by
      intro hm0 hn0
      refine h0 ?_
      rw [coeff_zero_eq_eval_zero, eval_mul, sq]
      exact
        Ideal.mul_mem_mul (eval_zero_mem_ideal_of_eq_mul_X_pow hp hm0.ne')
          (eval_zero_mem_ideal_of_eq_mul_X_pow hq hn0.ne')
    have hpql0 : (mk P) (p * q).leadingCoeff â‰  0 := by rwa [Ne, eq_zero_iff_mem]
    have hp0 : p â‰  0 := fun h => by
      simp_all only [zero_mul, eq_self_iff_true, not_true, Ne]
    have hq0 : q â‰  0 := fun h => by
      simp_all only [eq_self_iff_true, not_true, Ne, mul_zero]
    have hbc0 : degree b = 0 âˆ§ degree c = 0 := by
      apply_fun degree at hbc
      rwa [degree_C hpql0, degree_mul, eq_comm, Nat.WithBot.add_eq_zero_iff] at hbc
    have hmp : m â‰¤ natDegree p := le_natDegree_of_map_eq_mul_X_pow hP hp hbc0.1
    have hnq : n â‰¤ natDegree q := le_natDegree_of_map_eq_mul_X_pow hP hq hbc0.2
    have hpmqn : p.natDegree = m âˆ§ q.natDegree = n := by
      rw [natDegree_mul hp0 hq0] at hmnd
      contrapose hmnd
      apply ne_of_lt
      rw [not_and_or] at hmnd
      cases' hmnd with hmnd hmnd
      Â· exact add_lt_add_of_lt_of_le (lt_of_le_of_ne hmp (Ne.symm hmnd)) hnq
      Â· exact add_lt_add_of_le_of_lt hmp (lt_of_le_of_ne hnq (Ne.symm hmnd))
    obtain rfl | rfl : m = 0 âˆ¨ n = 0 := by
      rwa [pos_iff_ne_zero, pos_iff_ne_zero, imp_false, Classical.not_not, â† or_iff_not_imp_left]
        at hmn
    Â· exact Or.inl (isUnit_of_natDegree_eq_zero_of_isPrimitive hu hpmqn.1)
    Â· exact Or.inr
          (isUnit_of_natDegree_eq_zero_of_isPrimitive
            (show IsPrimitive (q * p) by simpa [mul_comm] using hu)
            hpmqn.2)âŸ©


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
:=
  have hf0 : f â‰  0 := fun _ => by simp_all only [not_true, Submodule.zero_mem, coeff_zero]
  have hf : f.map (mk P) = C (mk P (leadingCoeff f)) * X ^ natDegree f :=
    map_eq_C_mul_X_pow_of_forall_coeff_mem hfP
  have hfd0 : 0 < f.natDegree := WithBot.coe_lt_coe.1 (lt_of_lt_of_le hfd0 degree_le_natDegree)
  âŸ¨mt degree_eq_zero_of_isUnit fun h => by simp_all only [lt_irrefl], by
    rintro p q rfl
    rw [Polynomial.map_mul] at hf
    rcases mul_eq_mul_prime_pow
        (show Prime (X : Polynomial (R â§¸ P)) from monic_X.prime_of_degree_eq_one degree_X) hf with
      âŸ¨m, n, b, c, hmnd, hbc, hp, hqâŸ©
    have hmn : 0 < m â†’ 0 < n â†’ False := by
      intro hm0 hn0
      refine h0 ?_
      rw [coeff_zero_eq_eval_zero, eval_mul, sq]
      exact
        Ideal.mul_mem_mul (eval_zero_mem_ideal_of_eq_mul_X_pow hp hm0)
          (eval_zero_mem_ideal_of_eq_mul_X_pow hq hn0)
    have hpql0 : (mk P) (p * q).leadingCoeff â‰  0 := by rwa [Ne, eq_zero_iff_mem]
    have hp0 : p â‰  0 := fun h => by
      simp_all only [eq_self_iff_true, not_true, Ne, MulZeroClass.mul_zero]
    have hbc0 : degree b = 0 âˆ§ degree c = 0 := by
      apply_fun degree at hbc
      rwa [degree_C hpql0, degree_mul, eq_comm, Nat.WithBot.add_eq_zero_iff] at hbc
    have hmp : m â‰¤ natDegree p := le_natDegree_of_map_eq_mul_X_pow hP hp hbc0.1
    have hnq : n â‰¤ natDegree q := le_natDegree_of_map_eq_mul_X_pow hP hq hbc0.2
    have hpmqn : p.natDegree = m âˆ§ q.natDegree = n := by
      rw [natDegree_mul hp0 hq0] at hmnd
      contrapose hmnd
      apply ne_of_lt
      rw [not_and_or] at hmnd
      cases' hmnd with hmnd hmnd
      Â· exact add_lt_add_of_lt_of_le (lt_of_le_of_ne hmp (Ne.symm hmnd)) hnq
      Â· exact add_lt_add_of_le_of_lt hmp (lt_of_le_of_ne hnq (Ne.symm hmnd))
    obtain rfl | rfl : m = 0 âˆ¨ n = 0 := by
      apply_fun degree at hbc
      rwa [degree_C hpql0, degree_mul, eq_comm, Nat.WithBot.add_eq_zero_iff] at hbc
    have hmp : m â‰¤ natDegree p := le_natDegree_of_map_eq_mul_X_pow hP hp hbc0.1
    have hnq : n â‰¤ natDegree q := le_natDegree_of_map_eq_mul_X_pow hP hq hbc0.2
    have hpmqn : p.natDegree = m âˆ§ q.natDegree = n := by
      rw [natDegree_mul hp0 hq0] at hmnd
      contrapose hmnd
      apply ne_of_lt
      rw [not_and_or] at hmnd
      cases' hmnd with hmnd hmnd
      Â· exact add_lt_add_of_lt_of_le (lt_of_le_of_ne hmp (Ne.symm hmnd)) hnq
      Â· exact add_lt_add_of_le_of_lt hmp (lt_of_le_of_ne hnq (Ne.symm hmnd))
    obtain rfl | rfl : m = 0 âˆ¨ n = 0 := by
      rwa [pos_iff_ne_zero, pos_iff_ne_zero, imp_fal

Attempt failure.

Working on Mathlib/RingTheory/FiniteType.lean - 2024-09-07 22:05:16.139445.
---76/100---
For theorem Module.Finite.injective_of_surjective_endomorphism in Mathlib/RingTheory/FiniteType.lean:
theorem Module.Finite.injective_of_surjective_endomorphism {R : Type*} [CommRing R] {M : Type*}
    [AddCommGroup M] [Module R M] [Finite R M] (f : M â†’â‚—[R] M)
    (f_surj : Function.Surjective f) : Function.Injective f 


Original valid proof:
:=
  OrzechProperty.injective_of_surjective_endomorphism f f_surj


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  have : (âŠ¤ : Submodule R[X] (AEval' f)) â‰¤ Ideal.span {(X : R[X])} â€¢ âŠ¤
  Â· intro a _
    obtain âŸ¨y, rflâŸ© := f_surj.comp (AEval'.of f).symm.surjective a
    rw [Function.comp_apply, â† AEval'.of_symm_X_smul]
    exact Submodule.smul_mem_smul (Ideal.mem_span_singleton.mpr (dvd_refl _)) trivial
  obtain âŸ¨F, hFa, hFbâŸ© :=
    Submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul _ (âŠ¤ : Submodule R[X] (AEval' f))
      (finite_def.mp inferInstance) this
  rw [â† LinearMap.ker_eq_bot, LinearMap.ker_eq_bot']
  intro m hm
  rw [â† map_eq_zero_iff (AEval'.of f) (AEval'.of f).injective]
  set m' := Module.AEval'.of f m
  rw [Ideal.mem_span_singleton'] at hFa
  obtain âŸ¨G, hGâŸ© := hFa
  suffices (F - 1) â€¢ m' = 0 by
    have Fmzero := hFb m' (by simp)
    rwa [â† sub_add_cancel F 1, add_smul, one_smul, this, zero_add] at Fmzero
  rw [â† hG, mul_smul, AEval'.X_smul_of, hm, map_zero, smul_zero]

Attempt failure.

---77/100---
For theorem MonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure in Mathlib/RingTheory/FiniteType.lean:
theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = âŠ¤) :
    Function.Surjective
      (FreeAlgebra.lift R fun s : S => of' R M â†‘s : FreeAlgebra R S â†’ R[M]) 


Original valid proof:
:= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  Â· have : m âˆˆ closure S := hS.symm â–¸ mem_top _
    refine AddSubmonoid.closure_induction this (fun m hm => ?_) ?_ ?_
    Â· exact âŸ¨FreeAlgebra.Î¹ R âŸ¨m, hmâŸ©, FreeAlgebra.lift_Î¹_apply _ _âŸ©
    Â· exact âŸ¨1, AlgHom.map_one _âŸ©
    Â· rintro mâ‚ mâ‚‚ âŸ¨Pâ‚, hPâ‚âŸ© âŸ¨Pâ‚‚, hPâ‚‚âŸ©
      exact
        âŸ¨Pâ‚ * Pâ‚‚, by
          rw [AlgHom.map_mul, hPâ‚, hPâ‚‚, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rflâŸ©
  Â· rcases ihf with âŸ¨P, rflâŸ©
    rcases ihg with âŸ¨Q, rflâŸ©
    exact âŸ¨P + Q, AlgHom.map_add _ _ _âŸ©
  Â· rcases ih with âŸ¨P, rflâŸ©
    exact âŸ¨r â€¢ P, AlgHom.map_smul _ _ _âŸ©


Verifying proof (Commit 5fb9beab28702fb284701d494bc9b7c5f52fef53):
:= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  Â· have : m âˆˆ closure S := hS.symm â–¸ mem_top _
    refine closure_induction this (fun m hm => ?_) ?_ ?_
    Â· exact âŸ¨FreeAlgebra.Î¹ R âŸ¨m, hmâŸ©, FreeAlgebra.lift_Î¹_apply _ _âŸ©
    Â· exact âŸ¨1, AlgHom.map_one _âŸ©
    Â· rintro mâ‚ mâ‚‚ âŸ¨Pâ‚, hPâ‚âŸ© âŸ¨Pâ‚‚, hPâ‚‚âŸ©
      exact
        âŸ¨Pâ‚ * Pâ‚‚, by
          rw [AlgHom.map_mul, hPâ‚, hPâ‚‚, of_apply, of_apply, of_apply, single_mul_single,
           one_mul]; rflâŸ©
  Â· rcases ihf with âŸ¨P, rflâŸ©
    rcases ihg with âŸ¨Q, rflâŸ©
    exact âŸ¨r â€¢ P, AlgHom.map_smul _ _ _âŸ©

Attempt failure.

Working on Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean - 2024-09-07 22:05:47.162996.
---78/100---
For theorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self in Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean:
theorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self (I : HomogeneousIdeal ğ’œ) :
    I.toIdeal.homogeneousCore ğ’œ = I 


Original valid proof:
:= by
  ext1
  convert Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self I.isHomogeneous


Verifying proof (Commit 413e5b872a7c758e0eb91f99cb96d6a61c81f0a2):
:=
  HomogeneousCore.toSubmodule_homogeneousCore_eq_self I

Attempt failure.

Working on Mathlib/RingTheory/IntegralDomain.lean - 2024-09-07 22:05:58.369449.
---79/100---
For theorem sum_hom_units_eq_zero in Mathlib/RingTheory/IntegralDomain.lean:
theorem sum_hom_units_eq_zero (f : G â†’* R) (hf : f â‰  1) : âˆ‘ g : G, f g = 0 


Original valid proof:
:= by
  classical
    obtain âŸ¨x, hxâŸ© : âˆƒ x : MonoidHom.range f.toHomUnits,
        âˆ€ y : MonoidHom.range f.toHomUnits, y âˆˆ Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x â‰  1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx âŸ¨f.toHomUnits g, g, rflâŸ© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 â‰  0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      âˆ‘ g : G, f g = âˆ‘ g : G, (f.toHomUnits g : R) := rfl
      _ = âˆ‘ u âˆˆ univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card â€¢ (u : R) :=
        (sum_comp ((â†‘) : RË£ â†’ R) f.toHomUnits)
      _ = âˆ‘ u âˆˆ univ.image f.toHomUnits, c â€¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_argâ‚‚ _ ?_ rfl)
      _ = âˆ‘ b : MonoidHom.range f.toHomUnits, c â€¢ ((b : RË£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c â€¢ âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R) := smul_sum.symm
      _ = c â€¢ (0 : R) := congr_argâ‚‚ _ rfl ?_
      _ = (0 : R) := smul_zero _
    Â· 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      Â· simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      Â· exact âŸ¨1, f.toHomUnits.map_oneâŸ©
    show (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R)) = 0
    calc
      (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R))
        = âˆ‘ n âˆˆ range (orderOf x), ((x : RË£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ Â·) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let âŸ¨n, hnâŸ© := hx b
              âŸ¨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn âŠ¢; rw [pow_mod_orderOf, hn]âŸ©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [â† mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
:= by
  classical
    obtain âŸ¨x, hxâŸ© :
      âˆƒ x : MonoidHom.range f.toHomUnits,
        âˆ€ y : MonoidHom.range f.toHomUnits, y âˆˆ Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x â‰  1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx âŸ¨f.toHomUnits g, g, rflâŸ© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 â‰  0 := 
    exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      âˆ‘ g : G, f g = âˆ‘ g : G, (f.toHomUnits g : R) := rfl
      _ = âˆ‘ u âˆˆ univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card â€¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_argâ‚‚ _ ?_ rfl)
      _ = âˆ‘ b : MonoidHom.range f.toHomUnits, c â€¢ ((b : RË£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c â€¢ âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R) := smul_sum.symm
      _ = c â€¢ (0 : R) := (congr_argâ‚‚ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    Â· 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      Â· simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      Â· exact âŸ¨1, f.toHomUnits.map_oneâŸ©
    show (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R)) = 0
    calc
      (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R) := smul_sum.symm
      _ = c â€¢ (0 : R) := (congr_argâ‚‚ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    Â· 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      Â· simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      Â· exact âŸ¨1, f.toHomUnits.map_oneâŸ©
    show (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R)) = 0
    calc
      (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R))
        = âˆ‘ n âˆˆ range (orderOf x), ((x : RË£) : R) ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      Â· exact âŸ¨1, f.toHomUnits.map_oneâŸ©
    show (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R)) = 0
    calc
      (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R))
        = âˆ‘ n âˆˆ range (orderOf x), ((x : RË£) : R) ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only

Attempt failure.

Working on Mathlib/RingTheory/IntegralRestrict.lean - 2024-09-07 22:06:10.890196.
---80/100---
For theorem Algebra.intTrace_eq_of_isLocalization in Mathlib/RingTheory/IntegralRestrict.lean:
lemma Algebra.intTrace_eq_of_isLocalization
    (x : B) :
    algebraMap A Aâ‚˜ (Algebra.intTrace A B x) = Algebra.intTrace Aâ‚˜ Bâ‚˜ (algebraMap B Bâ‚˜ x) 


Original valid proof:
:= by
  by_cases hM : 0 âˆˆ M
  Â· have := IsLocalization.uniqueOfZeroMem (S := Aâ‚˜) hM
    exact Subsingleton.elim _ _
  replace hM : M â‰¤ Aâ° := fun x hx â†¦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e â†¦ hM (e â–¸ hx))
  let K := FractionRing A
  let L := FractionRing B
  have : IsIntegralClosure B A L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsLocalization (algebraMapSubmonoid B Aâ°) L :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  let f : Aâ‚˜ â†’+* K := IsLocalization.map _ (T := Aâ°) (RingHom.id A) hM
  letI := f.toAlgebra
  have : IsScalarTower A Aâ‚˜ K := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower B Bâ‚˜ L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := ((algebraMap K L).comp f).toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq' rfl
  have : IsScalarTower Aâ‚˜ Bâ‚˜ L := by
    apply IsScalarTower.of_algebraMap_eq'
    apply IsLocalization.ringHom_ext M
    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Bâ‚˜), RingHom.comp_assoc,
      RingHom.comp_assoc, â† IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq A B Bâ‚˜,
      IsLocalization.map_comp, RingHom.comp_id, â† RingHom.comp_assoc, IsLocalization.map_comp,
      RingHom.comp_id, â† IsScalarTower.algebraMap_eq, â† IsScalarTower.algebraMap_eq]
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization
    (algebraMapSubmonoid B M) Bâ‚˜ L
  have : FiniteDimensional K L := Module.Finite_of_isLocalization A B _ _ Aâ°
  have : IsIntegralClosure Bâ‚˜ Aâ‚˜ L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  apply IsFractionRing.injective Aâ‚˜ K
  rw [â† IsScalarTower.algebraMap_apply, Algebra.algebraMap_intTrace_fractionRing,
    Algebra.algebraMap_intTrace (L := L), â† IsScalarTower.algebraMap_apply]


Verifying proof (Commit 562711c9f3ae24a07facf3809c1631a4ccf2e8f2):
:= by
  by_cases hM : 0 âˆˆ M
  Â· have := IsLocalization.uniqueOfZeroMem (S := Aâ‚˜) hM
    exact Subsingleton.elim _ _
  replace hM : M â‰¤ Aâ° := fun x hx â†¦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e â†¦ hM (e â–¸ hx))
  let K := FractionRing A
  let L := FractionRing B
  have : IsIntegralClosure B A L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (Algebra.IsIntegral.of_finite A B)
  have : IsLocalization (algebraMapSubmonoid B Aâ°) L :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
      (isAlgebraic_of_isFractionRing _ _ (Algebra.IsIntegral.of_finite A B))
  let f : Aâ‚˜ â†’+* K := IsLocalization.map _ (T := Aâ°) (RingHom.id A) hM
  letI := f.toAlgebra
  have : IsScalarTower A Aâ‚˜ K := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, â† RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, â† RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, â† RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, â† RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq' rfl
  have : IsScalarTower Aâ‚˜ Bâ‚˜ L := by
    apply IsScalarTo

Attempt failure.

Working on Mathlib/RingTheory/Jacobson.lean - 2024-09-07 22:06:38.693353.
---81/100---
For theorem Ideal.Polynomial.isMaximal_comap_C_of_isJacobson in Mathlib/RingTheory/Jacobson.lean:
theorem isMaximal_comap_C_of_isJacobson : (P.comap (C : R â†’+* R[X])).IsMaximal 


Original valid proof:
:= by
  rw [â† @mk_ker _ _ P, RingHom.ker_eq_comap_bot, comap_comap]
  have := (bot_quotient_isMaximal_iff _).mpr hP
  exact isMaximal_comap_of_isIntegral_of_isMaximal' _ (quotient_mk_comp_C_isIntegral_of_jacobson P)
    âŠ¥


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  rw [â† @mk_ker _ _ P, RingHom.ker_eq_comap_bot, comap_comap]
  exact isMaximal_comap_of_isIntegral_of_isMaximal' _ (quotient_mk_comp_C_isIntegral_of_jacobson P)
    âŠ¥ ((bot_quotient_isMaximal_iff _).mpr hP)

Attempt failure.

---82/100---
For theorem Ideal.isJacobson_of_isIntegral' in Mathlib/RingTheory/Jacobson.lean:
theorem isJacobson_of_isIntegral' (f : R â†’+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S 


Original valid proof:
:=
  let _ : Algebra R S := f.toAlgebra
  have : Algebra.IsIntegral R S := âŸ¨hfâŸ©
  isJacobson_of_isIntegral hR


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
:=
  let _ : SMul R S := f.toAlgebra
  have : Algebra.IsIntegral R S := âŸ¨hfâŸ©
  isJacobson_of_isIntegral hR

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean - 2024-09-07 22:07:08.122111.
---83/100---
For theorem Polynomial.orderOf_root_cyclotomic_dvd in Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean:
theorem orderOf_root_cyclotomic_dvd {n : â„•} (hpos : 0 < n) {p : â„•} [Fact p.Prime] {a : â„•}
    (hroot : IsRoot (cyclotomic n (ZMod p)) (Nat.castRingHom (ZMod p) a)) :
    orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) âˆ£ n 


Original valid proof:
:= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by
    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [â† prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), â† Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]


Verifying proof (Commit b271affacf1fa368c4e879d75cd5aaf54b75b7ed):
:= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by
    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [â† prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), â† Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]

Attempt success.

Working on Mathlib/RingTheory/Valuation/Basic.lean - 2024-09-07 22:07:19.452136.
---84/100---
For theorem AddValuation.ext_iff in Mathlib/RingTheory/Valuation/Basic.lean:
theorem ext_iff {vâ‚ vâ‚‚ : Valuation R Î“â‚€} : vâ‚ = vâ‚‚ â†” âˆ€ r, vâ‚ r = vâ‚‚ r 


Original valid proof:
:=
  DFunLike.ext_iff


Verifying proof (Commit ae8b24f33174f0b9fcd8f2d87ba6c65a18ae9ceb):
:=
  FunLike.ext_iff

Attempt failure.

Working on Mathlib/Topology/Algebra/Group/Basic.lean - 2024-09-07 22:07:29.329882.
---85/100---
For theorem TopologicalGroup.exists_antitone_basis_nhds_one in Mathlib/Topology/Algebra/Group/Basic.lean:
theorem TopologicalGroup.exists_antitone_basis_nhds_one :
    âˆƒ u : â„• â†’ Set G, (ğ“ 1).HasAntitoneBasis u âˆ§ âˆ€ n, u (n + 1) * u (n + 1) âŠ† u n 


Original valid proof:
:= by
  rcases (ğ“ (1 : G)).exists_antitone_basis with âŸ¨u, hu, u_antiâŸ©
  have :=
    ((hu.prod_nhds hu).tendsto_iff hu).mp
      (by simpa only [mul_one] using continuous_mul.tendsto ((1, 1) : G Ã— G))
  simp only [and_self_iff, mem_prod, and_imp, Prod.forall, exists_true_left, Prod.exists,
    forall_true_left] at this
  have event_mul : âˆ€ n : â„•, âˆ€á¶  m in atTop, u m * u m âŠ† u n := by
    intro n
    rcases this n with âŸ¨j, k, -, hâŸ©
    refine atTop_basis.eventually_iff.mpr âŸ¨max j k, True.intro, fun m hm => ?_âŸ©
    rintro - âŸ¨a, ha, b, hb, rflâŸ©
    exact h a b (u_anti ((le_max_left _ _).trans hm) ha) (u_anti ((le_max_right _ _).trans hm) hb)
  obtain âŸ¨Ï†, -, hÏ†, Ï†_anti_basisâŸ© := HasAntitoneBasis.subbasis_with_rel âŸ¨hu, u_antiâŸ© event_mul
  exact âŸ¨u âˆ˜ Ï†, Ï†_anti_basis, fun n => hÏ† n.lt_succ_selfâŸ©


Verifying proof (Commit 9f9d83a281e21565e06f284c1cf7e46e6c0ad35c):
:= by
  rcases(ğ“ (1 : G)).exists_antitone_basis with âŸ¨u, hu, u_antiâŸ©
  have :=
    ((hu.prod_nhds hu).tendsto_iff hu).mp
      (by simpa only [mul_one] using continuous_mul.tendsto ((1, 1) : G Ã— G))
  simp only [and_self_iff, mem_prod, and_imp, Prod.forall, exists_true_left, Prod.exists,
    forall_true_left] at this
  have event_mul : âˆ€ n : â„•, âˆ€á¶  m in atTop, u m * u m âŠ† u n := by
    intro n
    rcases this n with âŸ¨j, k, -, hâŸ©
    refine atTop_basis.eventually_iff.mpr âŸ¨max j k, True.intro, fun m hm => ?_âŸ©
    rintro - âŸ¨a, b, ha, hb, rflâŸ©
    exact h a b (u_anti ((le_max_left _ _).trans hm) ha) (u_anti ((le_max_right _ _).trans hm) hb)
  obtain âŸ¨Ï†, -, hÏ†, Ï†_anti_basisâŸ© := HasAntitoneBasis.subbasis_with_rel âŸ¨hu, u_antiâŸ© event_mul
  exact âŸ¨u âˆ˜ Ï†, Ï†_anti_basis, fun n => hÏ† n.lt_succ_selfâŸ©

Attempt failure.

Working on Mathlib/Topology/Algebra/Order/LiminfLimsup.lean - 2024-09-07 22:07:44.956519.
---86/100---
For theorem tendsto_of_liminf_eq_limsup in Mathlib/Topology/Algebra/Order/LiminfLimsup.lean:
theorem tendsto_of_liminf_eq_limsup {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} (hinf : liminf u f = a)
    (hsup : limsup u f = a) (h : f.IsBoundedUnder (Â· â‰¤ Â·) u := by isBoundedDefault)
    (h' : f.IsBoundedUnder (Â· â‰¥ Â·) u := by isBoundedDefault) : Tendsto u f (ğ“ a) 


Original valid proof:
:=
  le_nhds_of_limsSup_eq_limsInf h h' hsup hinf


Verifying proof (Commit 8f4f347b47261491fcaffde5530e0b5f8490768e):
:=
  le_nhds_of_limsupâ‚›_eq_liminfâ‚› h h' hsup

Attempt failure.

Working on Mathlib/Topology/Algebra/Valuation.lean - 2024-09-07 22:07:53.597667.
---87/100---
For theorem Valued.loc_const in Mathlib/Topology/Algebra/Valuation.lean:
theorem loc_const {x : R} (h : (v x : Î“â‚€) â‰  0) : { y : R | v y = v x } âˆˆ ğ“ x 


Original valid proof:
:= by
  rw [mem_nhds]
  use Units.mk0 _ h
  rw [Units.val_mk0]
  intro y y_in
  exact Valuation.map_eq_of_sub_lt _ y_in


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  rw [mem_nhds]
  rcases Units.exists_iff_ne_zero.mpr h with âŸ¨Î³, hxâŸ©
  use Î³
  rw [hx]
  intro y y_in
  exact Valuation.map_eq_of_sub_lt _ y_in

Attempt failure.

---88/100---
For theorem Valuation.subgroups_basis in Mathlib/Topology/Algebra/Valuation.lean:
theorem subgroups_basis : RingSubgroupsBasis fun Î³ : Î“â‚€Ë£ => (v.ltAddSubgroup Î³ : AddSubgroup R) 


Original valid proof:
:=
  { inter := by
      rintro Î³â‚€ Î³â‚
      use min Î³â‚€ Î³â‚
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, r_in, s, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := mul_lt_mulâ‚€ r_in s_in
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use (1 : Î“â‚€Ë£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (x * y) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt
    rightMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (y * x) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt }


Verifying proof (Commit 14c729603a56a1a02f31a1b28b852fe56d29c058):
:=
  { inter := by
      rintro Î³â‚€ Î³â‚
      use min Î³â‚€ Î³â‚
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, s, r_in, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := (mul_lt_mulâ‚€ r_in s_in)
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, s, r_in, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := (mul_lt_mulâ‚€ r_in s_in)
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, s, r_in, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := (mul_lt_mulâ‚€ r_in s_in)
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, s, r_in, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := (mul_lt_mulâ‚€ r_in s_in)
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, s, r_in, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := (mul_lt_mulâ‚€ r_in s_in)
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, s, r_in, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := (mul_lt_mulâ‚€ r_in s_in)
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, s, r_in, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := (mul_lt_mulâ‚€ r_in s_in)
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, s, r_in, s_in, rflâŸ©
      c

Attempt failure.

Working on Mathlib/Topology/Algebra/WithZeroTopology.lean - 2024-09-07 22:08:09.613982.
---89/100---
For theorem WithZeroTopology.hasBasis_nhds_zero in Mathlib/Topology/Algebra/WithZeroTopology.lean:
theorem hasBasis_nhds_zero : (ğ“ (0 : Î“â‚€)).HasBasis (fun Î³ : Î“â‚€ => Î³ â‰  0) Iio 


Original valid proof:
:= by
  rw [nhds_zero]
  refine hasBasis_biInf_principal ?_ âŸ¨1, one_ne_zeroâŸ©
  exact directedOn_iff_directed.2 (Monotone.directed_ge fun a b hab => Iio_subset_Iio hab)


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
:= by
  rw [nhds_zero]
  refine hasBasis_biInf_principal _ âŸ¨1, one_ne_zeroâŸ©
  exact directedOn_iff_directed.2 (directed_of_inf fun a b hab => Iio_subset_Iio hab)

Attempt failure.

Working on Mathlib/Topology/Bases.lean - 2024-09-07 22:08:15.776174.
---90/100---
For theorem TopologicalSpace.separableSpace_iff_countable in Mathlib/Topology/Bases.lean:
theorem separableSpace_iff_countable [DiscreteTopology Î±] : SeparableSpace Î± â†” Countable Î± 


Original valid proof:
:= by
  simp [separableSpace_iff, countable_univ_iff]


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
:= by
  simp [SeparableSpace_iff, countable_univ_iff]

Attempt failure.

Working on Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean - 2024-09-07 22:08:24.196900.
---91/100---
For theorem TopCat.pullback_fst_image_snd_preimage in Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean:
theorem pullback_fst_image_snd_preimage (f : X âŸ¶ Z) (g : Y âŸ¶ Z) (U : Set Y) :
    (pullback.fst : pullback f g âŸ¶ _) '' ((pullback.snd : pullback f g âŸ¶ _) â»Â¹' U) =
      f â»Â¹' (g '' U) 


Original valid proof:
:= by
  ext x
  constructor
  Â· rintro âŸ¨(y : (forget TopCat).obj _), hy, rflâŸ©
    exact
      âŸ¨(pullback.snd : pullback f g âŸ¶ _) y, hy,
        (ConcreteCategory.congr_hom pullback.condition y).symmâŸ©
  Â· rintro âŸ¨y, hy, eqâŸ©
    refine âŸ¨(TopCat.pullbackIsoProdSubtype f g).inv âŸ¨âŸ¨_, _âŸ©, eq.symmâŸ©, ?_, ?_âŸ©
    Â· simp only [coe_of, Set.mem_preimage]
      convert hy
      erw [pullbackIsoProdSubtype_inv_snd_apply]
    Â· rw [pullbackIsoProdSubtype_inv_fst_apply]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  ext x
  constructor
  Â· rintro âŸ¨y, hy, rflâŸ©
    exact
      âŸ¨(pullback.snd : pullback f g âŸ¶ _) y, hy,
        (ConcreteCategory.congr_hom pullback.condition y).symmâŸ©
  Â· rintro âŸ¨y, hy, eqâŸ©
    exact âŸ¨(TopCat.pullbackIsoProdSubtype f g).inv âŸ¨âŸ¨_, _âŸ©, eq.symmâŸ©, by simpa, by simpâŸ©

Attempt failure.

Working on Mathlib/Topology/Compactness/Lindelof.lean - 2024-09-07 22:08:34.532293.
---92/100---
For theorem IsLindelof.elim_countable_subcover in Mathlib/Topology/Compactness/Lindelof.lean:
theorem IsLindelof.elim_countable_subcover {Î¹ : Type v} (hs : IsLindelof s) (U : Î¹ â†’ Set X)
    (hUo : âˆ€ i, IsOpen (U i)) (hsU : s âŠ† â‹ƒ i, U i) :
    âˆƒ r : Set Î¹, r.Countable âˆ§ (s âŠ† â‹ƒ i âˆˆ r, U i) 


Original valid proof:
:= by
  have hmono : âˆ€ â¦ƒs t : Set Xâ¦„, s âŠ† t â†’ (âˆƒ r : Set Î¹, r.Countable âˆ§ t âŠ† â‹ƒ i âˆˆ r, U i)
      â†’ (âˆƒ r : Set Î¹, r.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro _ _ hst âŸ¨r, âŸ¨hrcountable, hsubâŸ©âŸ©
    exact âŸ¨r, hrcountable, Subset.trans hst hsubâŸ©
  have hcountable_union : âˆ€ (S : Set (Set X)), S.Countable
      â†’ (âˆ€ s âˆˆ S, âˆƒ r : Set Î¹, r.Countable âˆ§ (s âŠ† â‹ƒ i âˆˆ r, U i))
      â†’ âˆƒ r : Set Î¹, r.Countable âˆ§ (â‹ƒâ‚€ S âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro S hS hsr
    choose! r hr using hsr
    refine âŸ¨â‹ƒ s âˆˆ S, r s, hS.biUnion_iff.mpr (fun s hs â†¦ (hr s hs).1), ?_âŸ©
    refine sUnion_subset ?h.right.h
    simp only [mem_iUnion, exists_prop, iUnion_exists, biUnion_and']
    exact fun i is x hx â†¦ mem_biUnion is ((hr i is).2 hx)
  have h_nhds : âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆƒ r : Set Î¹, r.Countable âˆ§ (t âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro x hx
    let âŸ¨i, hiâŸ© := mem_iUnion.1 (hsU hx)
    refine âŸ¨U i, mem_nhdsWithin_of_mem_nhds ((hUo i).mem_nhds hi), {i}, by simp, ?_âŸ©
    simp only [mem_singleton_iff, iUnion_iUnion_eq_left]
    exact Subset.refl _
  exact hs.induction_on hmono hcountable_union h_nhds


Verifying proof (Commit ad1607ddeaaaa81b831dcb37615796d3fa93c9fe):
:= by
  have he : âˆƒ r : Set Î¹, r.Countable âˆ§ âˆ… âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro S hS hsr
    choose! r hr using hsr
    use â‹ƒ s âˆˆ S, r s
    constructor
    Â· refine (Countable.biUnion_iff hS).mpr ?h.left.a
      intro s hs
      apply (hr s hs).1
    Â· refine iUnionâ‚‚_subset ?h.right.h
      intro i
      simp
      intro is
      have h := (hr i is).2
      intro x hx
      exact mem_biUnion is (h hx)
  have h_nhds : âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆƒ r : Set Î¹, r.Countable âˆ§ (t âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro S hS hsr
    choose! r hr using hsr
    use â‹ƒ s âˆˆ S, r s
    constructor
    Â· refine (Countable.biUnion_iff hS).mpr ?h.left.a
      intro s hs
      apply (hr s hs).1
    Â· refine iUnionâ‚‚_subset ?h.right.h
      intro i
      simp
      intro is
      have h := (hr i is).2
      intro x hx
      exact mem_biUnion is (h hx)
  have h_nhds : âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆƒ r : Set Î¹, r.Countable âˆ§ (t âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro x hx
    let âŸ¨i, hiâŸ© := mem_iUnion.1 (hsU hx)
    refine âŸ¨U i, mem_nhdsWithin_of_mem_nhds (IsOpen.mem_nhds (hUo i) hi),{i}, ?_âŸ©
    constructor <;> simp
    exact Subset.refl _
  exact hs.induction_on he hmono hcountable_union h_nhds

Attempt failure.

Working on Mathlib/Topology/Connected/Basic.lean - 2024-09-07 22:08:41.237880.
---93/100---
For theorem isPreconnected_of_forall_constant in Mathlib/Topology/Connected/Basic.lean:
theorem isPreconnected_of_forall_constant {s : Set Î±}
    (hs : âˆ€ f : Î± â†’ Bool, ContinuousOn f s â†’ âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, f x = f y) : IsPreconnected s 


Original valid proof:
:= by
  unfold IsPreconnected
  by_contra!
  rcases this with âŸ¨u, v, u_op, v_op, hsuv, âŸ¨x, x_in_s, x_in_uâŸ©, âŸ¨y, y_in_s, y_in_vâŸ©, HâŸ©
  have hy : y âˆ‰ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y âŸ¨y_in_s, âŸ¨y_in_u, y_in_vâŸ©âŸ©
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr âŸ¨_, _âŸ©
    Â· rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
    Â· exact u_op.preimage continuous_subtype_val
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s


Verifying proof (Commit 64b674911520c89d4467fb9e8410ab9d79e82064):
:= by
  unfold IsPreconnected
  by_contra!
  rcases this with âŸ¨u, v, u_op, v_op, hsuv, âŸ¨x, x_in_s, x_in_uâŸ©, âŸ¨y, y_in_s, y_in_vâŸ©, HâŸ©
  rw [not_nonempty_iff_eq_empty] at H
  have hy : y âˆ‰ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y âŸ¨y_in_s, âŸ¨y_in_u, y_in_vâŸ©âŸ©
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_clopen _ _).mpr âŸ¨_, _âŸ©
    Â· exact u_op.preimage continuous_subtype_val
    Â· rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s

Attempt failure.

---94/100---
For theorem isPreconnected_of_forall_constant in Mathlib/Topology/Connected/Basic.lean:
theorem isPreconnected_of_forall_constant {s : Set Î±}
    (hs : âˆ€ f : Î± â†’ Bool, ContinuousOn f s â†’ âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, f x = f y) : IsPreconnected s 


Original valid proof:
:= by
  unfold IsPreconnected
  by_contra!
  rcases this with âŸ¨u, v, u_op, v_op, hsuv, âŸ¨x, x_in_s, x_in_uâŸ©, âŸ¨y, y_in_s, y_in_vâŸ©, HâŸ©
  have hy : y âˆ‰ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y âŸ¨y_in_s, âŸ¨y_in_u, y_in_vâŸ©âŸ©
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr âŸ¨_, _âŸ©
    Â· rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
    Â· exact u_op.preimage continuous_subtype_val
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s


Verifying proof (Commit 592e720e2651f6e8a7faf0968b75697c3bcd3b55):
:= by
  unfold IsPreconnected
  by_contra!
  rcases this with âŸ¨u, v, u_op, v_op, hsuv, âŸ¨x, x_in_s, x_in_uâŸ©, âŸ¨y, y_in_s, y_in_vâŸ©, HâŸ©
  have hy : y âˆ‰ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y âŸ¨y_in_s, âŸ¨y_in_u, y_in_vâŸ©âŸ©
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr âŸ¨_, _âŸ©
    Â· exact u_op.preimage continuous_subtype_val
    Â· rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s

Attempt failure.

Working on Mathlib/Topology/PartialHomeomorph.lean - 2024-09-07 22:08:56.536265.
---95/100---
For theorem PartialHomeomorph.subtypeRestr_symm_eqOn_of_le in Mathlib/Topology/PartialHomeomorph.lean:
theorem subtypeRestr_symm_eqOn_of_le {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U â‰¤ V) : EqOn (e.subtypeRestr hV).symm (Set.inclusion hUV âˆ˜ (e.subtypeRestr hU).symm)
      (e.subtypeRestr hU).target 


Original valid proof:
:= by
  set i := Set.inclusion hUV
  intro y hy
  dsimp [PartialHomeomorph.subtypeRestr_def] at hy âŠ¢
  have hyV : e.symm y âˆˆ (V.partialHomeomorphSubtypeCoe hV).target := by
    rw [Opens.partialHomeomorphSubtypeCoe_target] at hy âŠ¢
    exact hUV hy.2
  refine (V.partialHomeomorphSubtypeCoe hV).injOn ?_ trivial ?_
  Â· rw [â† PartialHomeomorph.symm_target]
    apply PartialHomeomorph.map_source
    rw [PartialHomeomorph.symm_source]
    exact hyV
  Â· rw [(V.partialHomeomorphSubtypeCoe hV).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hy.2]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
:= by
  set i := Set.inclusion hUV
  intro y hy
  dsimp [PartialHomeomorph.subtypeRestr_def] at hy âŠ¢
  have hyV : e.symm y âˆˆ (V.partialHomeomorphSubtypeCoe hV).target := by
    rw [Opens.partialHomeomorphSubtypeCoe_target] at hy âŠ¢
    exact hUV hy.2
  refine (V.partialHomeomorphSubtypeCoe hV).injOn ?_ trivial? ?_
  Â· rw [â† PartialHomeomorph.symm_target]
    apply PartialHomeomorph.map_source
    rw [PartialHomeomorph.symm_source]
    exact hyV
  Â· rw [(V.partialHomeomorphSubtypeCoe hV).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hy.2]

Attempt failure.

Working on Mathlib/Topology/Perfect.lean - 2024-09-07 22:09:04.673422.
---96/100---
For theorem exists_perfect_nonempty_of_isClosed_of_not_countable in Mathlib/Topology/Perfect.lean:
theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology Î±]
    (hclosed : IsClosed C) (hunc : Â¬C.Countable) : âˆƒ D : Set Î±, Perfect D âˆ§ D.Nonempty âˆ§ D âŠ† C 


Original valid proof:
:= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with âŸ¨V, D, Vct, Dperf, VDâŸ©
  refine âŸ¨D, âŸ¨Dperf, ?_âŸ©âŸ©
  constructor
  Â· rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with âŸ¨V, D, Vct, Dperf, VDâŸ©
  refine âŸ¨D, âŸ¨Dperf, ?_âŸ©âŸ©
  constructor
  Â· rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right

Attempt success.

Working on Mathlib/Topology/Separation.lean - 2024-09-07 22:09:10.059267.
---97/100---
For theorem compact_t2_tot_disc_iff_tot_sep in Mathlib/Topology/Separation.lean:
theorem compact_t2_tot_disc_iff_tot_sep : TotallyDisconnectedSpace X â†” TotallySeparatedSpace X 


Original valid proof:
:= by
  refine âŸ¨fun h => âŸ¨fun x _ y _ => ?_âŸ©, @TotallySeparatedSpace.totallyDisconnectedSpace _ _âŸ©
  contrapose!
  intro hyp
  suffices x âˆˆ connectedComponent y by
    simpa [totallyDisconnectedSpace_iff_connectedComponent_singleton.1 h y, mem_singleton_iff]
  rw [connectedComponent_eq_iInter_isClopen, mem_iInter]
  rintro âŸ¨w : Set X, hw : IsClopen w, hy : y âˆˆ wâŸ©
  by_contra hx
  exact hyp âŸ¨wá¶œ, w, hw.1.isOpen_compl, hw.2, hx, hy, (@isCompl_compl _ w _).symm.codisjoint.top_le,
    disjoint_compl_leftâŸ©


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  refine âŸ¨fun h => âŸ¨fun x _ y _ => ?_âŸ©, @TotallySeparatedSpace.totallyDisconnectedSpace _ _âŸ©
  contrapose!
  intro hyp
  suffices x âˆˆ connectedComponent y by
    simpa [totallyDisconnectedSpace_iff_connectedComponent_singleton.1 h y, mem_singleton_iff]
  rw [connectedComponent_eq_iInter_isClopen, mem_iInter]
  rintro âŸ¨w : Set X, hw : IsClopen w, hy : y âˆˆ wâŸ©
  by_contra hx
  exact hyp wá¶œ w hw.1.isOpen_compl hw.2 hx hy (@isCompl_compl _ w _).symm.codisjoint.top_le
    disjoint_compl_left

Attempt failure.

Working on Mathlib/Topology/ShrinkingLemma.lean - 2024-09-07 22:09:20.427429.
---98/100---
For theorem ShrinkingLemma.PartialRefinement.exists_gt in Mathlib/Topology/ShrinkingLemma.lean:
theorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : Î¹) (hi : i âˆ‰ v.carrier) :
    âˆƒ v' : PartialRefinement u s, v < v' 


Original valid proof:
:= by
  have I : (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) âŠ† v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with âŸ¨j, hjâŸ©
    exact (em (j = i)).elim (fun h => h â–¸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with âŸ¨vi, ovi, hvi, cviâŸ©
  refine âŸ¨âŸ¨update v i vi, insert i v.carrier, ?_, ?_, ?_, ?_âŸ©, ?_, ?_âŸ©
  Â· intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  Â· refine fun x hx => mem_iUnion.2 ?_
    rcases em (âˆƒ j â‰  i, x âˆˆ v j) with (âŸ¨j, hji, hjâŸ© | h)
    Â· use j
      rwa [update_noteq hji]
    Â· push_neg at h
      use i
      rw [update_same]
      exact hvi âŸ¨hx, mem_biInter hâŸ©
  Â· rintro j (rfl | hj)
    Â· rwa [update_same, â† v.apply_eq hi]
    Â· rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  Â· intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  Â· refine âŸ¨subset_insert _ _, fun j hj => ?_âŸ©
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  Â· exact fun hle => hi (hle.1 <| mem_insert _ _)


Verifying proof (Commit e2b5ca370bbc63149cba7caf35005bf2193dc387):
:= by
  have I : (s âˆ© â‹‚ (j) (_ : j â‰  i), v já¶œ) âŠ† v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with âŸ¨j, hjâŸ©
    exact (em (j = i)).elim (fun h => h â–¸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s âˆ© â‹‚ (j) (_ : j â‰  i), v já¶œ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with âŸ¨vi, ovi, hvi, cviâŸ©
  refine âŸ¨âŸ¨update v i vi, insert i v.carrier, ?_, ?_, ?_, ?_âŸ©, ?_, ?_âŸ©
  Â· intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  Â· refine fun x hx => mem_iUnion.2 ?_
    rcases em (âˆƒ (j : _)(_ : j â‰  i), x âˆˆ v j) with (âŸ¨j, hji, hjâŸ© | h)
    Â· use j
      rwa [update_noteq hji]
    Â· push_neg at h
      use i
      rw [update_same]
      exact hvi âŸ¨hx, mem_biInter hâŸ©
  Â· rintro j (rfl | hj)
    Â· rwa [update_same, â† v.apply_eq hi]
    Â· rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  Â· intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  Â· refine âŸ¨subset_insert _ _, fun j hj => ?_âŸ©
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  Â· exact fun hle => hi (hle.1 <| mem_insert _ _)

Attempt failure.

Working on Mathlib/Topology/TietzeExtension.lean - 2024-09-07 22:09:25.476059.
---99/100---
For theorem BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding' in Mathlib/Topology/TietzeExtension.lean:
theorem exists_extension_norm_eq_of_closedEmbedding' (f : X â†’áµ‡ â„) (e : C(X, Y))
    (he : ClosedEmbedding e) : âˆƒ g : Y â†’áµ‡ â„, â€–gâ€– = â€–fâ€– âˆ§ g.compContinuous e = f 


Original valid proof:
:= by
  choose F hF_norm hF_dist using fun f : X â†’áµ‡ â„ => tietze_extension_step f e he
  set g : â„• â†’ Y â†’áµ‡ â„ := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : âˆ€ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : âˆ€ n, dist ((g n).compContinuous e) f â‰¤ (2 / 3) ^ n * â€–fâ€– := by
    intro n
    induction' n with n ihn
    Â· simp [g0]
    Â· rw [g_succ n, add_compContinuous, â† dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [â† dist_eq_norm']
  have hg_dist : âˆ€ n, dist (g n) (g (n + 1)) â‰¤ 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = â€–F (f - (g n).compContinuous e)â€– := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ â‰¤ â€–f - (g n).compContinuous eâ€– / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ â‰¤ 1 / 3 * ((2 / 3) ^ n * â€–fâ€–) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ğ“ <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine âŸ¨limUnder atTop g, le_antisymm ?_ ?_, hgeâŸ©
  Â· rw [â† dist_zero_left, â† g0]
    refine
      (dist_le_of_le_geometric_of_tendstoâ‚€ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : â„) = 1 by norm_num1]
  Â· rw [â† hge]
    exact norm_compContinuous_le _ _


Verifying proof (Commit 161c69c1dbf66cf3c7ec4f648a61551d044a43e4):
:= by
  choose F hF_norm hF_dist using fun f : X â†’áµ‡ â„ => tietze_extension_step f e he
  set g : â„• â†’ Y â†’áµ‡ â„ := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : âˆ€ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : âˆ€ n, dist ((g n).compContinuous e) f â‰¤ (2 / 3) ^ n * â€–fâ€– := by
    intro n
    induction' n with n ihn
    Â· simp [g0]
    Â· rw [g_succ n, add_compContinuous, â† dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [â† dist_eq_norm']
  have hg_dist : âˆ€ n, dist (g n) (g (n + 1)) â‰¤ 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ğ“ <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul

Attempt failure.

Working on Mathlib/Topology/UniformSpace/Ascoli.lean - 2024-09-07 22:09:36.295204.
---100/100---
For theorem EquicontinuousOn.tendsto_uniformOnFun_iff_pi' in Mathlib/Topology/UniformSpace/Ascoli.lean:
theorem EquicontinuousOn.tendsto_uniformOnFun_iff_pi'
    {ğ”– : Set (Set X)} (ğ”–_compact : âˆ€ K âˆˆ ğ”–, IsCompact K)
    (F_eqcont : âˆ€ K âˆˆ ğ”–, EquicontinuousOn F K) (â„± : Filter Î¹) (f : X â†’ Î±) :
    Tendsto (UniformOnFun.ofFun ğ”– âˆ˜ F) â„± (ğ“ <| UniformOnFun.ofFun ğ”– f) â†”
    Tendsto ((â‹ƒâ‚€ ğ”–).restrict âˆ˜ F) â„± (ğ“ <| (â‹ƒâ‚€ ğ”–).restrict f) 


Original valid proof:
:= by
  rw [â† Filter.tendsto_comap_iff (g := (â‹ƒâ‚€ ğ”–).restrict), â† nhds_induced]
  simp_rw [UniformOnFun.topologicalSpace_eq, Pi.induced_restrict_sUnion ğ”– (Ï€ := fun _ â†¦ Î±),
    _root_.nhds_iInf, nhds_induced, tendsto_iInf, tendsto_comap_iff]
  congrm âˆ€ K (hK : K âˆˆ ğ”–), ?_
  have : CompactSpace K := isCompact_iff_compactSpace.mp (ğ”–_compact K hK)
  rw [â† (equicontinuous_restrict_iff _ |>.mpr <| F_eqcont K hK).tendsto_uniformFun_iff_pi]
  rfl


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  rw [â† Filter.tendsto_comap_iff (g := (â‹ƒâ‚€ ğ”–).restrict), â† nhds_induced]
  simp_rw [UniformOnFun.topologicalSpace_eq, Pi.induced_restrict_sUnion ğ”– (Ï€ := fun _ â†¦ Î±),
    nhds_iInf, nhds_induced, tendsto_iInf, tendsto_comap_iff]
  congrm âˆ€ K (hK : K âˆˆ ğ”–), ?_
  have : CompactSpace K := isCompact_iff_compactSpace.mp (ğ”–_compact K hK)
  rw [â† (equicontinuous_restrict_iff _ |>.mpr <| F_eqcont K hK).tendsto_uniformFun_iff_pi]
  rfl

Attempt failure.

STARTING: Lean repo copy removal
DONE: Lean repo copy removal
Among 100 proof attempts, there were 9 successful and 91 failed attempts at proving their respect theorems.
The rate of successful proof = 0.09.
