STARTING: verification of proofs from predicted_proof column in dataset from models/byt5_small/random/test_random_by_t5_small_tuned_prediction.csv - 2024-09-07 20:37:27.768726
STARTING: Lean repo copy creation
DONE: Lean repo copy creation
STARTING: retrieve cache
installing leantar 0.1.13
Attempting to download 4738 file(s)
Decompressing 4738 file(s)
Unpacked in 497213 ms
Completed successfully!
DONE: retrieved cache
Working on Mathlib/Algebra/DirectSum/Module.lean - 2024-09-07 21:33:46.824670.
---1/100---
For theorem DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top in Mathlib/Algebra/DirectSum/Module.lean:
theorem isInternal_submodule_of_independent_of_iSup_eq_top {A : Œπ ‚Üí Submodule R M}
    (hi : CompleteLattice.Independent A) (hs : iSup A = ‚ä§) : IsInternal A 


Original valid proof:
:=
  ‚ü®hi.dfinsupp_lsum_injective,
    (LinearMap.range_eq_top (f := DFinsupp.lsum _ _)).1 <|
      (Submodule.iSup_eq_range_dfinsupp_lsum _).symm.trans hs‚ü©


Verifying proof (Commit 161c69c1dbf66cf3c7ec4f648a61551d044a43e4):
:=
  ‚ü®hi.dfinsupp_lsum_injective,
    LinearMap.range_eq_top.1 <| (Submodule.iSup_eq_range_dfinsupp_lsum _).symm.trans hs‚ü©

Attempt failure.

Working on Mathlib/Algebra/Homology/Localization.lean - 2024-09-07 21:36:45.084895.
---2/100---
For theorem ComplexShape.QFactorsThroughHomotopy_of_exists_prev in Mathlib/Algebra/Homology/Localization.lean:
lemma ComplexShape.QFactorsThroughHomotopy_of_exists_prev [CategoryWithHomology C] :
    c.QFactorsThroughHomotopy C where



Original valid proof:
  areEqualizedByLocalization {K L f g} h := by
    have : DecidableRel c.Rel := by classical infer_instance
    exact h.map_eq_of_inverts_homotopyEquivalences hc _
      (MorphismProperty.IsInvertedBy.of_le _ _ _
        (Localization.inverts _ (HomologicalComplex.quasiIso C _))
        (homotopyEquivalences_le_quasiIso C _))


Verifying proof (Commit 1cb1056b5a19f416d3fae3469d51eedb4f5b48cb):
:= by classical infer_instance
    exact h.map_eq_of_inverts_homotopyEquivalences hc _
      (MorphismProperty.IsInvertedBy.of_subset _ _ _
        (Localization.inverts _ (HomologicalComplex.quasiIso C _))
        (homotopyEquivalences_subset_quasiIso C _))

Attempt failure.

Working on Mathlib/Algebra/MonoidAlgebra/Basic.lean - 2024-09-07 21:38:24.368990.
---3/100---
For theorem AddMonoidAlgebra.ringHom_ext' in Mathlib/Algebra/MonoidAlgebra/Basic.lean:
theorem ringHom_ext' {R} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G ‚Üí+* R}
    (h‚ÇÅ : f.comp singleOneRingHom = g.comp singleOneRingHom)
    (h_of :
      (f : MonoidAlgebra k G ‚Üí* R).comp (of k G) = (g : MonoidAlgebra k G ‚Üí* R).comp (of k G)) :
    f = g 


Original valid proof:
:=
  ringHom_ext (RingHom.congr_fun h‚ÇÅ) (DFunLike.congr_fun h_of)


Verifying proof (Commit 848a6055965ceeab03ba2c4d2d0e4e0e9b07c6e6):
:=
  ringHom_ext (RingHom.congr_fun h‚ÇÅ) (FunLike.congr_fun h_of)

Attempt failure.

Working on Mathlib/Algebra/Order/CauSeq/BigOperators.lean - 2024-09-07 21:38:52.720697.
---4/100---
For theorem IsCauSeq.geo_series in Mathlib/Algebra/Order/CauSeq/BigOperators.lean:
lemma geo_series [Nontrivial Œ≤] (x : Œ≤) (hx1 : abv x < 1) :
    IsCauSeq abv fun n ‚Ü¶ ‚àë m ‚àà range n, x ^ m 


Original valid proof:
:= by
  have hx1' : abv x ‚â† 1 := fun h ‚Ü¶ by simp [h, lt_irrefl] at hx1
  refine of_abv ?_
  simp only [abv_pow abv, geom_sum_eq hx1']
  conv in _ / _ => rw [‚Üê neg_div_neg_eq, neg_sub, neg_sub]
  have : 0 < 1 - abv x := sub_pos.2 hx1
  refine @of_mono_bounded _ _ _ _ ((1 : Œ±) / (1 - abv x)) 0 ?_ ?_
  ¬∑ intro n _
    rw [abs_of_nonneg]
    ¬∑ gcongr
      exact sub_le_self _ (abv_pow abv x n ‚ñ∏ abv_nonneg _ _)
    refine div_nonneg (sub_nonneg.2 ?_) (sub_nonneg.2 <| le_of_lt hx1)
    exact pow_le_one _ (by positivity) hx1.le
  ¬∑ intro n _
    rw [‚Üê one_mul (abv x ^ n), pow_succ']
    gcongr


Verifying proof (Commit 03690a4c3252f422184189d0b6a6dd8d1c55d551):
:= by
  have hx1' : abv x ‚â† 1 := fun h ‚Ü¶ by simp [h, lt_irrefl] at hx1
  refine of_abv ?_
  simp only [abv_pow abv, geom_sum_eq hx1']
  conv in _ / _ => rw [‚Üê neg_div_neg_eq, neg_sub, neg_sub]
  have : 0 < 1 - abv x := sub_pos.2 hx1
  refine @of_mono_bounded _ _ _ _ _ ((1 : Œ±) / (1 - abv x)) 0 ?_ ?_
  ¬∑ intro n _
    rw [abs_of_nonneg]
    ¬∑ gcongr
      exact sub_le_self _ (abv_pow abv x n ‚ñ∏ abv_nonneg _ _)
    refine div_nonneg (sub_nonneg.2 ?_) (sub_nonneg.2 <| le_of_lt hx1)
    exact pow_le_one _ (by positivity) hx1.le
  ¬∑ intro n _
    rw [‚Üê one_mul (abv x ^ n), pow_succ']
    gcongr

Attempt failure.

Working on Mathlib/Algebra/Order/Ring/Pow.lean - 2024-09-07 21:39:00.899868.
---5/100---
For theorem one_add_mul_le_pow in Mathlib/Algebra/Order/Ring/Pow.lean:
lemma one_add_mul_le_pow' (Hsq : 0 ‚â§ a * a) (Hsq' : 0 ‚â§ (1 + a) * (1 + a)) (H : 0 ‚â§ 2 + a) :
    ‚àÄ n : ‚Ñï, 1 + n * a ‚â§ (1 + a) ^ n



Original valid proof:
  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ‚â§ n * (a * a * (2 + a)) + a * a :=
      add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq
    calc
      _ ‚â§ 1 + ‚Üë(n + 2) * a + (n * (a * a * (2 + a)) + a * a) := le_add_of_nonneg_right this
      _ = (1 + a) * (1 + a) * (1 + n * a) := by
          simp only [Nat.cast_add, add_mul, mul_add, one_mul, mul_one, ‚Üê one_add_one_eq_two,
            Nat.cast_one, add_assoc, add_right_inj]
          simp only [‚Üê add_assoc, add_comm _ (‚Üën * a)]
          simp only [add_assoc, (n.cast_commute (_ : R)).left_comm]
          simp only [add_comm, add_left_comm]
      _ ‚â§ (1 + a) * (1 + a) * (1 + a) ^ n :=
        mul_le_mul_of_nonneg_left (one_add_mul_le_pow' Hsq Hsq' H _) Hsq'
      _ = (1 + a) ^ (n + 2) := by simp only [pow_succ', mul_assoc]


Verifying proof (Commit 61ddcfa78d90f5773ac5739822ee3721851aa662):
:= by
         simp only [Nat.cast_add, add_mul, mul_add, one_mul, mul_one, ‚Üê one_add_one_eq_two,
            Nat.cast_one, add_assoc, add_right_inj]
          simp only [‚Üê add_assoc, add_comm _ (‚Üën * a)]
          simp only [add_assoc, (n.cast_commute (_ : R)).left_comm]
          simp only [add_comm, add_left_comm]
      _ ‚â§ (1 + a) * (1 + a) ^ n :=
        mul_le_mul_of_nonneg_left (one_add_mul_le_pow' Hsq Hsq' H _) Hsq'
      _ = (1 + a) ^ (n + 2) := by simp only [pow_succ', mul_assoc]

Attempt failure.

Working on Mathlib/Algebra/Polynomial/Smeval.lean - 2024-09-07 21:39:05.330737.
---6/100---
For theorem Polynomial.smeval_at_natCast in Mathlib/Algebra/Polynomial/Smeval.lean:
theorem smeval_at_natCast (q : ‚Ñï[X]): ‚àÄ(n : ‚Ñï), q.smeval (n : S) = q.smeval n 


Original valid proof:
:= by
  induction q using Polynomial.induction_on' with
  | h_add p q ph qh =>
    intro n
    simp only [add_mul, smeval_add, ph, qh, Nat.cast_add]
  | h_monomial n a =>
    intro n
    rw [smeval_monomial, smeval_monomial, nsmul_eq_mul, smul_eq_mul, Nat.cast_mul, Nat.cast_npow]


Verifying proof (Commit 25e538f3a737a71314ac143929711e67d0b14d73):
:= by
  induction q with
  | h_add p q ph qh =>
    intro n
    simp only [add_mul, smeval_add, ph, qh, Nat.cast_add]
  | h_monomial n a =>
    intro n
    rw [smeval_monomial, smeval_monomial, nsmul_eq_mul, smul_eq_mul, smul_eq_mul, Nat.cast_mul, Nat.cast_npow]

Attempt failure.

Working on Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean - 2024-09-07 21:39:19.001394.
---7/100---
For theorem AlgebraicGeometry.ŒìSpec.adjunction_homEquiv_apply in Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCat·µí·µñ}
    (f : (op <| Scheme.Œì.obj <| op X) ‚ü∂ R) :
    ŒìSpec.adjunction.homEquiv X R f = locallyRingedSpaceAdjunction.homEquiv X.1 R f 


Original valid proof:
:= rfl


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  dsimp [adjunction, Adjunction.restrictFullyFaithful, equivOfFullyFaithful]
  simp

Attempt failure.

Working on Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean - 2024-09-07 21:44:38.353350.
---8/100---
For theorem PrimeSpectrum.vanishingIdeal_irreducibleComponents in Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean:
lemma vanishingIdeal_irreducibleComponents :
    vanishingIdeal '' (irreducibleComponents <| PrimeSpectrum R) =
    minimalPrimes R 


Original valid proof:
:= by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes_eq_minimals, ‚Üê minimals_swap,
    ‚Üê PrimeSpectrum.vanishingIdeal_isClosed_isIrreducible, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ ‚Ü¶ vanishingIdeal_anti_mono_iff hs.1


Verifying proof (Commit 1833c6e43f5f2d80bf844f5bdf73c2f504fbdf8f):
:= by
  rw [irreducibleComponents_eq_maximals_closed]
  simp_rw [IsIrreducibleClosed, and_comm]
  rw [minimalPrimes_eq_minimals, ‚Üê minimals_swap,
    ‚Üê PrimeSpectrum.vanishingIdeal_isClosed_isIrreducible, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ ‚Ü¶ vanishingIdeal_anti_mono_iff hs.1

Attempt failure.

Working on Mathlib/Analysis/Analytic/Meromorphic.lean - 2024-09-07 21:44:51.245335.
---9/100---
For theorem MeromorphicOn.inv in Mathlib/Analysis/Analytic/Meromorphic.lean:
lemma inv {f : ùïú ‚Üí ùïú} {x : ùïú} (hf : MeromorphicAt f x) : MeromorphicAt f‚Åª¬π x 


Original valid proof:
:= by
  rcases hf with ‚ü®m, hf‚ü©
  by_cases h_eq : (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
  ¬∑ 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  ¬∑ 
    obtain ‚ü®n, g, hg_an, hg_ne, hg_eq‚ü© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ùïú x).sub analyticAt_const).pow _
    refine ‚ü®n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_‚ü©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    ¬∑ simp only [sub_self, pow_succ, mul_zero, zero_smul]
    ¬∑ simp_rw [smul_eq_mul] at hfg ‚ä¢
      have aux1 : f z ‚â† 0 := by
        have : (z - x) ^ n * g z ‚â† 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [‚Üê hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ', mul_assoc, hfg]
      ring


Verifying proof (Commit 0788787e4cbf8892c4d5415e2a91fb7666b8fc59):
:= by
  rcases hf with ‚ü®m, hf‚ü©
  by_cases h_eq : (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) =·∂†[ùìù x] 0
  ¬∑ 
    apply (meromorphicAt_const 0 x).congr
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  ¬∑ 
    obtain ‚ü®n, g, hg_an, hg_ne, hg_eq‚ü© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ùïú x).sub analyticAt_const).pow _
    refine ‚ü®n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_‚ü©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    ¬∑ simp only [sub_self, pow_succ, zero_mul, zero_smul]
    ¬∑ simp_rw [smul_eq_mul] at hfg ‚ä¢
      have aux1 : f z ‚â† 0
      ¬∑ have : (z - x) ^ n * g z ‚â† 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [‚Üê hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ', mul_assoc, hfg]
      ring

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Integrability.lean - 2024-09-07 21:45:29.227269.
---10/100---
For theorem BoxIntegral.hasIntegralIndicatorConst in Mathlib/Analysis/BoxIntegral/Integrability.lean:
theorem hasIntegralIndicatorConst (l : IntegrationParams) (hl : l.bRiemann = false)
    {s : Set (Œπ ‚Üí ‚Ñù)} (hs : MeasurableSet s) (I : Box Œπ) (y : E) (Œº : Measure (Œπ ‚Üí ‚Ñù))
    [IsLocallyFiniteMeasure Œº] :
    HasIntegral.{u, v, v} I l (s.indicator fun _ => y) Œº.toBoxAdditive.toSMul
      ((Œº (s ‚à© I)).toReal ‚Ä¢ y) 


Original valid proof:
:= by
  refine HasIntegral.of_mul ‚Äñy‚Äñ fun Œµ Œµ0 => ?_
  lift Œµ to ‚Ñù‚â•0 using Œµ0.le; rw [NNReal.coe_pos] at Œµ0
  have A : Œº (s ‚à© Box.Icc I) ‚â† ‚àû :=
    ((measure_mono Set.inter_subset_right).trans_lt (I.measure_Icc_lt_top Œº)).ne
  have B : Œº (s ‚à© I) ‚â† ‚àû :=
    ((measure_mono Set.inter_subset_right).trans_lt (I.measure_coe_lt_top Œº)).ne
  obtain ‚ü®F, hFs, hFc, hŒºF‚ü© : ‚àÉ F, F ‚äÜ s ‚à© Box.Icc I ‚àß IsClosed F ‚àß Œº ((s ‚à© Box.Icc I) \ F) < Œµ :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Œµ0).ne'
  obtain ‚ü®U, hsU, hUo, hUt, hŒºU‚ü© :
      ‚àÉ U, s ‚à© Box.Icc I ‚äÜ U ‚àß IsOpen U ‚àß Œº U < ‚àû ‚àß Œº (U \ (s ‚à© Box.Icc I)) < Œµ :=
    (hs.inter I.measurableSet_Icc).exists_isOpen_diff_lt A (ENNReal.coe_pos.2 Œµ0).ne'
  have : ‚àÄ x ‚àà s ‚à© Box.Icc I, ‚àÉ r : Ioi (0 : ‚Ñù), closedBall x r ‚äÜ U := fun x hx => by
    rcases nhds_basis_closedBall.mem_iff.1 (hUo.mem_nhds <| hsU hx) with ‚ü®r, hr‚ÇÄ, hr‚ü©
    exact ‚ü®‚ü®r, hr‚ÇÄ‚ü©, hr‚ü©
  choose! rs hrsU using this
  have : ‚àÄ x ‚àà Box.Icc I \ s, ‚àÉ r : Ioi (0 : ‚Ñù), closedBall x r ‚äÜ F·∂ú := fun x hx => by
    obtain ‚ü®r, hr‚ÇÄ, hr‚ü© :=
      nhds_basis_closedBall.mem_iff.1 (hFc.isOpen_compl.mem_nhds fun hx' => hx.2 (hFs hx').1)
    exact ‚ü®‚ü®r, hr‚ÇÄ‚ü©, hr‚ü©
  choose! rs' hrs'F using this
  set r : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù) := s.piecewise rs rs'
  refine ‚ü®fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c œÄ hœÄ hœÄp => ?_‚ü©; rw [mul_comm]
  dsimp [integralSum]
  simp only [mem_closedBall, dist_eq_norm, ‚Üê indicator_const_smul_apply,
    sum_indicator_eq_sum_filter, ‚Üê sum_smul, ‚Üê sub_smul, norm_smul, Real.norm_eq_abs, ‚Üê
    Prepartition.filter_boxes, ‚Üê Prepartition.measure_iUnion_toReal]
  gcongr
  set t := (œÄ.filter (œÄ.tag ¬∑ ‚àà s)).iUnion
  change abs ((Œº t).toReal - (Œº (s ‚à© I)).toReal) ‚â§ Œµ
  have htU : t ‚äÜ U ‚à© I := by
    simp only [t, TaggedPrepartition.iUnion_def, iUnion_subset_iff, TaggedPrepartition.mem_filter,
      and_imp]
    refine fun J hJ hJs x hx => ‚ü®hrsU _ ‚ü®hJs, œÄ.tag_mem_Icc J‚ü© ?_, œÄ.le_of_mem' J hJ hx‚ü©
    simpa only [r, s.piecewise_eq_of_mem _ _ hJs] using hœÄ.1 J hJ (Box.coe_subset_Icc hx)
  refine abs_sub_le_iff.2 ‚ü®?_, ?_‚ü©
  ¬∑ refine (ENNReal.le_toReal_sub B).trans (ENNReal.toReal_le_coe_of_le_coe ?_)
    refine (tsub_le_tsub (measure_mono htU) le_rfl).trans (le_measure_diff.trans ?_)
    refine (measure_mono fun x hx => ?_).trans hŒºU.le
    exact ‚ü®hx.1.1, fun hx' => hx.2 ‚ü®hx'.1, hx.1.2‚ü©‚ü©
  ¬∑ have hŒºt : Œº t ‚â† ‚àû := ((measure_mono (htU.trans inter_subset_left)).trans_lt hUt).ne
    refine (ENNReal.le_toReal_sub hŒºt).trans (ENNReal.toReal_le_coe_of_le_coe ?_)
    refine le_measure_diff.trans ((measure_mono ?_).trans hŒºF.le)
    rintro x ‚ü®‚ü®hxs, hxI‚ü©, hxt‚ü©
    refine ‚ü®‚ü®hxs, Box.coe_subset_Icc hxI‚ü©, fun hxF => hxt ?_‚ü©
    simp only [t, TaggedPrepartition.iUnion_def, TaggedPrepartition.mem_filter, Set.mem_iUnion]
    rcases hœÄp x hxI with ‚ü®J, hJœÄ, hxJ‚ü©
    refine ‚ü®J, ‚ü®hJœÄ, ?_‚ü©, hxJ‚ü©
    contrapose hxF
    refine hrs'F _ ‚ü®œÄ.tag_mem_Icc J, hxF‚ü© ?_
    simpa only [r, s.piecewise_eq_of_not_mem _ _ hxF] using hœÄ.1 J hJœÄ (Box.coe_subset_Icc hxJ)


Verifying proof (Commit 1b93076c86e6da5d0a25d3465e84d13bd9ccfcc8):
:= by
  refine HasIntegral.of_mul ‚Äñy‚Äñ fun Œµ Œµ0 => ?_
  lift Œµ to ‚Ñù‚â•0 using Œµ0.le; rw [NNReal.coe_pos] at Œµ0
  have A : Œº (s ‚à© Box.Icc I) ‚â† ‚àû :=
    ((measure_mono Set.inter_subset_right).trans_lt (I.measure_Icc_lt_top Œº)).ne
  obtain ‚ü®F, hFs, hFc, hŒºF‚ü© : ‚àÉ F, F ‚äÜ s ‚à© Box.Icc I ‚àß IsClosed F ‚àß Œº ((s ‚à© Box.Icc I) \ F) < Œµ :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Œµ0).ne'
  obtain ‚ü®U, hsU, hUo, hUt, hŒºU‚ü© :
      ‚àÉ U, s ‚à© Box.Icc I ‚äÜ U ‚àß IsOpen U ‚àß Œº U < ‚àû ‚àß Œº (U \ (s ‚à© Box.Icc I)) < Œµ :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Œµ0).ne'
  obtain ‚ü®U, hsU, hUo, hUt, hŒºU‚ü© :
      ‚àÉ U, s ‚à© Box.Icc I ‚äÜ U ‚àß IsOpen U ‚àß Œº U < ‚àû ‚àß Œº (U \ (s ‚à© Box.Icc I)) < Œµ :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Œµ0).ne'
  obtain ‚ü®U, hsU, hUo, hUt, hŒºU‚ü© :
      ‚àÉ U, s ‚à© Box.Icc I ‚äÜ U ‚àß IsOpen U ‚àß Œº U < ‚àû ‚àß Œº (U \ (s ‚à© Box.Icc I)) < Œµ :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Œµ0).ne'
  obtain ‚ü®U, hsU, hUo, hUt, hŒºU‚ü© :
      ‚àÉ U, s ‚à© Box.Icc I ‚äÜ U ‚àß IsOpen U ‚àß Œº U < ‚àû ‚àß Œº (U \ (s ‚à© Box.Icc I)) < Œµ :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Œµ0).ne'
  obtain ‚ü®U, hsU, hUo, hUt, hŒºU‚ü© :
      ‚àÉ U, s ‚à© Box.Icc I ‚äÜ U ‚àß IsOpen U ‚àß Œº U < ‚àû ‚àß Œº (U \ (s ‚à© Box.Icc I)) < Œµ :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Œµ0).ne'
  have : ‚àÄ x ‚àà s ‚à© Box.Icc I, ‚àÉ r : Ioi (0 : ‚Ñù), closedBall x r ‚äÜ U := fun x hx => by
    rcases nhds_basis_closedBall.mem_iff.1 (hUo.mem_nhds <| hsU hx) with ‚ü®r, hr‚ÇÄ, hr‚ü©
    exact ‚ü®‚ü®r, hr‚ÇÄ‚ü©, hr‚ü©
  choose! rs' hrs'F using this
  set r : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù) := s.piecewise rs rs'
  refine ‚ü®fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c œÄ hœÄ hœÄp => ?_‚ü©; rw [mul_comm]
  dsimp [integralSum]
  simp only [mem_closedBall, dist_eq_norm, ‚Üê indicator_const_smul_apply,
    sum_indicator_eq_sum_filter, ‚Üê sum_smul, ‚Üê sub_smul, norm_smul, Real.norm_eq_abs, ‚Üê
    Prepartition.filter_boxes, ‚Üê Prepartition.measure_iUnion_toReal]
  gcongr
  set t := (œÄ.filter (œÄ.tag ¬∑ ‚àà s)).iUnion
  change abs ((Œº t).toReal - (Œº (s ‚à© I)).toReal) ‚â§ Œµ
  have htU : t ‚äÜ U ‚à© I := by
    simp only [TaggedPrepartition.iUnion_def, iUnion_subset_iff, TaggedPrepartition.mem_filter,
      and_imp]
  

Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Equiv.lean - 2024-09-07 21:46:39.572793.
---11/100---
For theorem HasFDerivAt.of_local_left_inverse in Mathlib/Analysis/Calculus/FDeriv/Equiv.lean:
theorem HasFDerivAt.of_local_left_inverse {f : E ‚Üí F} {f' : E ‚âÉL[ùïú] F} {g : F ‚Üí E} {a : F}
    (hg : ContinuousAt g a) (hf : HasFDerivAt f (f' : E ‚ÜíL[ùïú] F) (g a))
    (hfg : ‚àÄ·∂† y in ùìù a, f (g y) = y) : HasFDerivAt g (f'.symm : F ‚ÜíL[ùïú] E) a 


Original valid proof:
:= by
  have : (fun x : F => g x - g a - f'.symm (x - a)) =O[ùìù a]
      fun x : F => f' (g x - g a) - (x - a) := by
    refine ((f'.symm : F ‚ÜíL[ùïú] E).isBigO_comp _ _).congr (fun x => ?_) fun _ => rfl
    simp
  refine HasFDerivAtFilter.of_isLittleO <| this.trans_isLittleO ?_
  clear this
  refine ((hf.isLittleO.comp_tendsto hg).symm.congr' (hfg.mono ?_) .rfl).trans_isBigO ?_
  ¬∑ intro p hp
    simp [hp, hfg.self_of_nhds]
  ¬∑ refine ((hf.isBigO_sub_rev f'.antilipschitz).comp_tendsto hg).congr'
      (eventually_of_forall fun _ => rfl) (hfg.mono ?_)
    rintro p hp
    simp only [(¬∑ ‚àò ¬∑), hp, hfg.self_of_nhds]


Verifying proof (Commit bbc6e56d76341e236fa4e15748bebff612b5cb4f):
:= by
  have : (fun x : F => g x - g a - f'.symm (x - a)) =O[ùìù a]
      fun x : F => f' (g x - g a) - (x - a) := by
    refine ((f'.symm : F ‚ÜíL[ùïú] E).isBigO_comp _ _).congr (fun x => ?_) fun _ => rfl
    simp
  refine this.trans_isLittleO ?_
  clear this
  refine ((hf.comp_tendsto hg).symm.congr' (hfg.mono ?_) .rfl).trans_isBigO ?_
  ¬∑ intro p hp
    simp [hp, hfg.self_of_nhds]
  ¬∑ refine ((hf.isBigO_sub_rev f'.antilipschitz).comp_tendsto hg).congr'
      (eventually_of_forall fun _ => rfl) (hfg.mono ?_)
    rintro p hp
    simp only [(¬∑ ‚àò ¬∑), hp, hfg.self_of_nhds]

Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean - 2024-09-07 21:46:59.205461.
---12/100---
For theorem Convex.taylor_approx_two_segment in Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean:
theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v ‚àà interior s)
    (hw : x + v + w ‚àà interior s) :
    (fun h : ‚Ñù => f (x + h ‚Ä¢ v + h ‚Ä¢ w)
        - f (x + h ‚Ä¢ v) - h ‚Ä¢ f' x w - h ^ 2 ‚Ä¢ f'' v w - (h ^ 2 / 2) ‚Ä¢ f'' w w) =o[ùìù[>] 0]
      fun h => h ^ 2 


Original valid proof:
:= by
  refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun Œµ Œµpos => ?_) (isBigO_const_mul_self ((‚Äñv‚Äñ + ‚Äñw‚Äñ) * ‚Äñw‚Äñ) _ _)
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx Œµpos) with ‚ü®Œ¥, Œ¥pos, sŒ¥‚ü©
  have E1 : ‚àÄ·∂† h in ùìù[>] (0 : ‚Ñù), h * (‚Äñv‚Äñ + ‚Äñw‚Äñ) < Œ¥ := by
    have : Filter.Tendsto (fun h => h * (‚Äñv‚Äñ + ‚Äñw‚Äñ)) (ùìù[>] (0 : ‚Ñù)) (ùìù (0 * (‚Äñv‚Äñ + ‚Äñw‚Äñ))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 Œ¥
    simpa only [zero_mul] using Œ¥pos
  have E2 : ‚àÄ·∂† h in ùìù[>] (0 : ‚Ñù), (h : ‚Ñù) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      ‚ü®(1 : ‚Ñù), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2‚ü©
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hŒ¥ h_lt_1 hpos
  replace hpos : 0 < h := hpos
  have xt_mem : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1, x + h ‚Ä¢ v + (t * h) ‚Ä¢ w ‚àà interior s := by
    intro t ht
    have : x + h ‚Ä¢ v ‚àà interior s := s_conv.add_smul_mem_interior xs hv ‚ü®hpos, h_lt_1.le‚ü©
    rw [‚Üê smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    rw [add_assoc, ‚Üê smul_add]
    exact s_conv.add_smul_mem_interior xs hw ‚ü®hpos, h_lt_1.le‚ü©
  let g t :=
    f (x + h ‚Ä¢ v + (t * h) ‚Ä¢ w) - (t * h) ‚Ä¢ f' x w - (t * h ^ 2) ‚Ä¢ f'' v w -
      ((t * h) ^ 2 / 2) ‚Ä¢ f'' w w
  set g' := fun t =>
    f' (x + h ‚Ä¢ v + (t * h) ‚Ä¢ w) (h ‚Ä¢ w) - h ‚Ä¢ f' x w - h ^ 2 ‚Ä¢ f'' v w - (t * h ^ 2) ‚Ä¢ f'' w w
    with hg'
  have g_deriv : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    ¬∑ refine (hf _ ?_).comp_hasDerivWithinAt _ ?_
      ¬∑ exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,
        hasDerivAt_mul_const]
    ¬∑ apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    ¬∑ apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    ¬∑ suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) ‚Ä¢ f'' w w)
          ((((2 : ‚Ñï) : ‚Ñù) * (t * h) ^ (2 - 1) * (1 * h) / 2) ‚Ä¢ f'' w w) (Icc 0 1) t by
        convert H using 2
        ring
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',
        HasDerivAt.pow, HasDerivAt.mul_const]
  have g'_bound : ‚àÄ t ‚àà Ico (0 : ‚Ñù) 1, ‚Äñg' t‚Äñ ‚â§ Œµ * ((‚Äñv‚Äñ + ‚Äñw‚Äñ) * ‚Äñw‚Äñ) * h ^ 2 := by
    intro t ht
    have I : ‚Äñh ‚Ä¢ v + (t * h) ‚Ä¢ w‚Äñ ‚â§ h * (‚Äñv‚Äñ + ‚Äñw‚Äñ) :=
      calc
        ‚Äñh ‚Ä¢ v + (t * h) ‚Ä¢ w‚Äñ ‚â§ ‚Äñh ‚Ä¢ v‚Äñ + ‚Äñ(t * h) ‚Ä¢ w‚Äñ := norm_add_le _ _
        _ = h * ‚Äñv‚Äñ + t * (h * ‚Äñw‚Äñ) := by
          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,
            mul_assoc]
        _ ‚â§ h * ‚Äñv‚Äñ + 1 * (h * ‚Äñw‚Äñ) := by gcongr; exact ht.2.le
        _ = h * (‚Äñv‚Äñ + ‚Äñw‚Äñ) := by ring
    calc
      ‚Äñg' t‚Äñ = ‚Äñ(f' (x + h ‚Ä¢ v + (t * h) ‚Ä¢ w) - f' x - f'' (h ‚Ä¢ v + (t * h) ‚Ä¢ w)) (h ‚Ä¢ w)‚Äñ := by
        rw [hg']
        have : h * (t * h) = t * (h * h) := by ring
        simp only [ContinuousLinearMap.coe_sub', ContinuousLinearMap.map_add, pow_two,
          ContinuousLinearMap.add_apply, Pi.smul_apply, smul_sub, smul_add, smul_smul, ‚Üê sub_sub,
          ContinuousLinearMap.coe_smul', Pi.sub_apply, ContinuousLinearMap.map_smul, this]
      _ ‚â§ ‚Äñf' (x + h ‚Ä¢ v + (t * h) ‚Ä¢ w) - f' x - f'' (h ‚Ä¢ v + (t * h) ‚Ä¢ w)‚Äñ * ‚Äñh ‚Ä¢ w‚Äñ :=
        (ContinuousLinearMap.le_opNorm _ _)
      _ ‚â§ Œµ * ‚Äñh ‚Ä¢ v + (t * h) ‚Ä¢ w‚Äñ * ‚Äñh ‚Ä¢ w‚Äñ := by
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        have H : x + h ‚Ä¢ v + (t * h) ‚Ä¢ w ‚àà Metric.ball x Œ¥ ‚à© interior s := by
          refine ‚ü®?_, xt_mem t ‚ü®ht.1, ht.2.le‚ü©‚ü©
          rw [add_assoc, add_mem_ball_iff_norm]
          exact I.trans_lt hŒ¥
        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel_left] using sŒ¥ H
      _ ‚â§ Œµ * (‚Äñh ‚Ä¢ v‚Äñ + ‚Äñh ‚Ä¢ w‚Äñ) * ‚Äñh ‚Ä¢ w‚Äñ := by
        gcongr
        apply (norm_add_le _ _).trans
        gcongr
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]
        exact mul_le_of_le_one_left (mul_nonneg hpos.le (norm_nonneg _)) ht.2.le
      _ = Œµ * ((‚Äñv‚Äñ + ‚Äñw‚Äñ) * ‚Äñw‚Äñ) * h ^ 2 := by
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring
  have I : ‚Äñg 1 - g 0‚Äñ ‚â§ Œµ * ((‚Äñv‚Äñ + ‚Äñw‚Äñ) * ‚Äñw‚Äñ) * h ^ 2 := by
    simpa only [mul_one, sub_zero] using
      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)
  convert I using 1
  ¬∑ congr 1
    simp only [g, Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,
      zero_smul, Ne, not_false_iff, bit0_eq_zero, zero_pow]
    abel
  ¬∑ simp only [Real.norm_eq_abs, abs_mul, add_nonneg (norm_nonneg v) (norm_nonneg w), abs_of_nonneg,
      hpos.le, mul_assoc, norm_nonneg, abs_pow]


Verifying proof (Commit 8e31b5ac6bed8ba535a30f3442252684d2f151c1):
:= by
  refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun Œµ Œµpos => ?_) (isBigO_const_mul_self ((‚Äñv‚Äñ + ‚Äñw‚Äñ) * ‚Äñw‚Äñ) _ _)
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx Œµpos) with ‚ü®Œ¥, Œ¥pos, sŒ¥‚ü©
  have E1 : ‚àÄ·∂† h in ùìù[>] (0 : ‚Ñù), h * (‚Äñv‚Äñ + ‚Äñw‚Äñ) < Œ¥ := by
    have : Filter.Tendsto (fun h => h * (‚Äñv‚Äñ + ‚Äñw‚Äñ)) (ùìù[>] (0 : ‚Ñù)) (ùìù (0 * (‚Äñv‚Äñ + ‚Äñw‚Äñ))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 Œ¥
    simpa only [zero_mul] using Œ¥pos
  have E2 : ‚àÄ·∂† h in ùìù[>] (0 : ‚Ñù), (h : ‚Ñù) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      ‚ü®(1 : ‚Ñù), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2‚ü©
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hŒ¥ h_lt_1 hpos
  replace hpos : 0 < h := hpos
  have xt_mem : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1, x + h ‚Ä¢ v + (t * h) ‚Ä¢ w ‚àà interior s := by
    intro t ht
    have : x + h ‚Ä¢ v ‚àà interior s := s_conv.add_smul_mem_interior xs hv ‚ü®hpos, h_lt_1.le‚ü©
    rw [‚Üê smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    rw [add_assoc, ‚Üê smul_add]
    exact s_conv.add_smul_mem_interior xs hw ‚ü®hpos, h_lt_1.le‚ü©
  let g t :=
    f (x + h ‚Ä¢ v + (t * h) ‚Ä¢ w) - (t * h) ‚Ä¢ f' x w - (t * h ^ 2) ‚Ä¢ f'' v w -
      ((t * h) ^ 2 / 2) ‚Ä¢ f'' w w
  set g' := fun t =>
    f' (x + h ‚Ä¢ v + (t * h) ‚Ä¢ w) (h ‚Ä¢ w) - h ‚Ä¢ f' x w - h ^ 2 ‚Ä¢ f'' v w - (t * h ^ 2) ‚Ä¢ f'' w w
    with hg'
  have g_deriv : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    ¬∑ refine (hf _ _).comp_hasDerivWithinAt _ ?_
      ¬∑ exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    ¬∑ apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    ¬∑ suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) ‚Ä¢ f'' w w)
          ((((2 : ‚Ñï) : ‚Ñù) * (t * h) ^ (2 - 1) * (1 * h) ‚Ä¢ f' x w - (t * h ^ 2) ‚Ä¢ f'' w w
    with hg'
  have g_deriv : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    ¬∑ refine (hf _ _).comp_hasDerivWithinAt _ ?_
      ¬∑ exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    ¬∑ apply_rules [Ha

Attempt failure.

Working on Mathlib/Analysis/Complex/CauchyIntegral.lean - 2024-09-07 21:47:16.243634.
---13/100---
For theorem Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable in Mathlib/Analysis/Complex/CauchyIntegral.lean:
theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ‚ÑÇ}
    {r R : ‚Ñù} (h0 : 0 < r) (hle : r ‚â§ R) {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ‚àÄ z ‚àà (ball c R \ closedBall c r) \ s, DifferentiableAt ‚ÑÇ f z) :
    (‚àÆ z in C(c, R), (z - c)‚Åª¬π ‚Ä¢ f z) = ‚àÆ z in C(c, r), (z - c)‚Åª¬π ‚Ä¢ f z 


Original valid proof:
:= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r := ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R := ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp b) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left‚ÇÄ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (c + exp ¬∑)
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z := by
    refine fun z hz => (hd (g z) ‚ü®?_, hz.2‚ü©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  set A := closedBall c R \ ball c r
  obtain ‚ü®a, rfl‚ü© : ‚àÉ a, Real.exp a = r; exact ‚ü®Real.log r, Real.exp_log h0‚ü©
  obtain ‚ü®b, rfl‚ü© : ‚àÉ b, Real.exp b = R; exact ‚ü®Real.log R, Real.exp_log (h0.trans_le hle)‚ü©
  rw [Real.exp_le_exp] at hle
  suffices
    (‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏)) =
      ‚à´ Œ∏ in (0)..2 * œÄ, I ‚Ä¢ f (circleMap c (Real.exp a) Œ∏) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ‚Üê exp_add, smul_smul, ‚Üê
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] √ó‚ÑÇ [[0, 2 * œÄ]]
  set g : ‚ÑÇ ‚Üí ‚ÑÇ := (¬∑ + ¬∑) c ‚àò exp
  have hdg : Differentiable ‚ÑÇ g := differentiable_exp.const_add _
  replace hs : (g ‚Åª¬π' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ‚ü®h, -‚ü©; simpa [dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ‚àò g) R; exact hc.comp hdg.continuous.continuousOn h_maps
  replace hd :
    ‚àÄ z ‚àà Ioo (min a b) (max a b) √ó‚ÑÇ Ioo (min 0 (2 * œÄ)) (max 0 (2 * œÄ)) \ g ‚Åª¬π' s,
      DifferentiableAt ‚ÑÇ (f ‚àò g) z
  ¬∑ refine fun z hz => (hd (g z) ‚ü®?_, hz.2‚ü©).comp z (hdg _)
    simpa [dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [circleMap, exp_periodic _, sub_eq_zero, ‚Üê exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ‚ü®a, 0‚ü© ‚ü®b, 2 * œÄ‚ü© _ hs hc hd

Attempt failure.

Working on Mathlib/Analysis/Complex/RealDeriv.lean - 2024-09-07 21:47:36.229381.
---14/100---
For theorem HasDerivAt.real_of_complex in Mathlib/Analysis/Complex/RealDeriv.lean:
theorem HasDerivAt.real_of_complex (h : HasDerivAt e e' z) :
    HasDerivAt (fun x : ‚Ñù => (e x).re) e'.re z 


Original valid proof:
:= by
  have A : HasFDerivAt ((‚Üë) : ‚Ñù ‚Üí ‚ÑÇ) ofRealCLM z := ofRealCLM.hasFDerivAt
  have B :
    HasFDerivAt e ((ContinuousLinearMap.smulRight 1 e' : ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ).restrictScalars ‚Ñù)
      (ofRealCLM z) :=
    h.hasFDerivAt.restrictScalars ‚Ñù
  have C : HasFDerivAt re reCLM (e (ofRealCLM z)) := reCLM.hasFDerivAt
  convert (C.comp z (B.comp z A)).hasDerivAt
  rw [ContinuousLinearMap.comp_apply, ContinuousLinearMap.comp_apply]
  simp


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
:= by
  have A : HasFDerivAt ((‚Üë) : ‚Ñù ‚Üí ‚ÑÇ) ofRealClm z := ofRealClm.hasFDerivAt
  have B :
    HasFDerivAt e ((ContinuousLinearMap.smulRight 1 e' : ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ).restrictScalars ‚Ñù)
      (ofRealClm z) :=
    h.hasFDerivAt.restrictScalars ‚Ñù
  have C : HasFDerivAt re reClm (e (ofRealClm z)) := reClm.hasFDerivAt
  convert (C.comp z (B.comp z A)).hasDerivAt
  rw [ContinuousLinearMap.comp_apply, ContinuousLinearMap.comp_apply]
  simp

Attempt failure.

Working on Mathlib/Analysis/Convex/Basic.lean - 2024-09-07 21:47:49.377540.
---15/100---
For theorem MonotoneOn.convex_gt in Mathlib/Analysis/Convex/Basic.lean:
theorem MonotoneOn.convex_gt (hf : MonotoneOn f s) (hs : Convex ùïú s) (r : Œ≤) :
    Convex ùïú ({ x ‚àà s | r < f x }) 


Original valid proof:
:=
  @MonotoneOn.convex_lt ùïú E·µí·µà Œ≤·µí·µà _ _ _ _ _ _ _ hf.dual hs r


Verifying proof (Commit 03690a4c3252f422184189d0b6a6dd8d1c55d551):
:=
  @MonotoneOn.convex_lt ùïú E·µí·µà Œ≤·µí·µà _ _ _ _ _ _ hf.dual hs r

Attempt failure.

Working on Mathlib/Analysis/Convex/Gauge.lean - 2024-09-07 21:48:03.387139.
---16/100---
For theorem Absorbent.gauge_set_nonempty in Mathlib/Analysis/Convex/Gauge.lean:
theorem Absorbent.gauge_set_nonempty (absorbs : Absorbent ‚Ñù s) :
    { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s }.Nonempty 


Original valid proof:
:=
  let ‚ü®r, hr‚ÇÅ, hr‚ÇÇ‚ü© := (absorbs x).exists_pos
  ‚ü®r, hr‚ÇÅ, hr‚ÇÇ r (Real.norm_of_nonneg hr‚ÇÅ.le).ge rfl‚ü©


Verifying proof (Commit f41d2e3dd69004ca4172132a94e749b22b59caae):
:=
  let ‚ü®r, hr‚ÇÅ, hr‚ÇÇ‚ü© := absorbs x
  ‚ü®r, hr‚ÇÅ, hr‚ÇÇ r (Real.norm_of_nonneg hr‚ÇÅ.le).ge‚ü©

Attempt failure.

Working on Mathlib/Analysis/Convex/Measure.lean - 2024-09-07 21:48:21.780303.
---17/100---
For theorem Convex.addHaar_frontier in Mathlib/Analysis/Convex/Measure.lean:
theorem addHaar_frontier (hs : Convex ‚Ñù s) : Œº (frontier s) = 0 


Original valid proof:
:= by
  cases' ne_or_eq (affineSpan ‚Ñù s) ‚ä§ with hspan hspan
  ¬∑ refine measure_mono_null ?_ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan ‚Ñù s).closed_of_finiteDimensional)
  rw [‚Üê hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with ‚ü®x, hx‚ü©
  suffices H : ‚àÄ t : Set E, Convex ‚Ñù t ‚Üí x ‚àà interior t ‚Üí IsBounded t ‚Üí Œº (frontier t) = 0 by
    let B : ‚Ñï ‚Üí Set E := fun n => ball x (n + 1)
    have : Œº (‚ãÉ n : ‚Ñï, frontier (s ‚à© B n)) = 0 := by
      refine measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) ?_ (isBounded_ball.subset inter_subset_right)
      rw [interior_inter, isOpen_ball.interior_eq]
      exact ‚ü®hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)‚ü©
    refine measure_mono_null (fun y hy => ?_) this; clear this
    set N : ‚Ñï := ‚åädist y x‚åã‚Çä
    refine mem_iUnion.2 ‚ü®N, ?_‚ü©
    have hN : y ‚àà B N := by simp [B, N, Nat.lt_floor_add_one]
    suffices y ‚àà frontier (s ‚à© B N) ‚à© B N from this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact ‚ü®hy, hN‚ü©
  intro s hs hx hb
  replace hb : Œº (interior s) ‚â† ‚àû := (hb.subset interior_subset).measure_lt_top.ne
  suffices Œº (closure s) ‚â§ Œº (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : ‚Ñï := FiniteDimensional.finrank ‚Ñù E
  have : ‚àÄ r : ‚Ñù‚â•0, 1 < r ‚Üí Œº (closure s) ‚â§ ‚Üë(r ^ d) * Œº (interior s) := fun r hr ‚Ü¶ by
    refine (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq ?_
    rw [addHaar_image_homothety, ‚Üê NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : ‚àÄ·∂† (r : ‚Ñù‚â•0) in ùìù[>] 1, Œº (closure s) ‚â§ ‚Üë(r ^ d) * Œº (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine ge_of_tendsto ?_ this
  refine (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ ?_).mono_left nhdsWithin_le_nhds
  simp


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  cases' ne_or_eq (affineSpan ‚Ñù s) ‚ä§ with hspan hspan
  ¬∑ refine measure_mono_null ?_ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan ‚Ñù s).closed_of_finiteDimensional)
  rw [‚Üê hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with ‚ü®x, hx‚ü©
  suffices H : ‚àÄ t : Set E, Convex ‚Ñù t ‚Üí x ‚àà interior t ‚Üí IsBounded t ‚Üí Œº (frontier t) = 0 by
    let B : ‚Ñï ‚Üí Set E := fun n => ball x (n + 1)
    have : Œº (‚ãÉ n : ‚Ñï, frontier (s ‚à© B n)) = 0 := by
      refine measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) ?_ (isBounded_ball.subset inter_subset_right)
      rw [interior_inter, isOpen_ball.interior_eq]
      exact ‚ü®hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)‚ü©
    refine measure_mono_null (fun y hy => ?_) this; clear this
    set N : ‚Ñï := ‚åädist y x‚åã‚Çä
    refine mem_iUnion.2 ‚ü®N, ?_‚ü©
    have hN : y ‚àà B N := by simp [B, N, Nat.lt_floor_add_one]
    suffices y ‚àà frontier (s ‚à© B N) ‚à© B N from this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact ‚ü®hy, hN‚ü©
  intro s hs hx hb
  replace hb : Œº (interior s) ‚â† ‚àû := (hb.subset interior_subset).measure_lt_top.ne
  suffices Œº (closure s) ‚â§ Œº (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : ‚Ñï := FiniteDimensional.finrank ‚Ñù E
  have : ‚àÄ r : ‚Ñù‚â•0, 1 < r ‚Üí Œº (closure s) ‚â§ ‚Üë(r ^ d) * Œº (interior s) := fun r hr ‚Ü¶ by
    refine (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq ?_
    rw [addHaar_image_homothety, ‚Üê NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : ‚àÄ·∂† (r : ‚Ñù‚â•0) in ùìù[>] 1, Œº (closure s) ‚â§ ‚Üë(r ^ d) * Œº (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine ge_of_tendsto ?_ this
  refine (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ ?_).mono_left nhdsWithin_le_nhds
  simp

Attempt success.

Working on Mathlib/Analysis/InnerProductSpace/Basic.lean - 2024-09-07 21:48:40.071516.
---18/100---
For theorem inner_mul_inner_self_le in Mathlib/Analysis/InnerProductSpace/Basic.lean:
theorem inner_mul_inner_self_le (x y : F) : ‚Äñ‚ü™x, y‚ü´‚Äñ * ‚Äñ‚ü™y, x‚ü´‚Äñ ‚â§ re ‚ü™x, x‚ü´ * re ‚ü™y, y‚ü´ 


Original valid proof:
:= by
  rcases eq_or_ne x 0 with (rfl | hx)
  ¬∑ simpa only [inner_zero_left, map_zero, zero_mul, norm_zero] using le_rfl
  ¬∑ have hx' : 0 < normSqF x := inner_self_nonneg.lt_of_ne' (mt normSq_eq_zero.1 hx)
    rw [‚Üê sub_nonneg, ‚Üê mul_nonneg_iff_right_nonneg_of_pos hx', ‚Üê normSq, ‚Üê normSq,
      norm_inner_symm y, ‚Üê sq, ‚Üê cauchy_schwarz_aux]
    exact inner_self_nonneg


Verifying proof (Commit e46faedbd6353e165e5a0da6768aa2e7bd75f6d4):
:= by
  have hdiscrim : ‚àÄ (t : ‚Ñù), 0 ‚â§ normSqF x * t * t + 2 * ‚Äñ‚ü™x, y‚ü´‚Äñ * t + normSqF y := by
    intro t
    by_cases hzero : ‚ü™x, y‚ü´ = 0
    ¬∑ rw [hzero]
      simp only [norm_zero, mul_zero, zero_mul, add_zero]
      apply add_nonneg
    ¬∑ rw [mul_assoc, ‚Üê sq, normSq]
        exact mul_nonneg inner_self_nonneg (sq_nonneg t)
      ¬∑ rw [normSq]
        exact inner_self_nonneg
    ¬∑ push_neg at hzero
      rw [‚Üê norm_ne_zero_iff] at hzero
      have htxy: 0 ‚â§ normSqF (‚ü™x,y‚ü´ ‚Ä¢ x) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ)
         + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ)
          + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ)
         + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ)
         + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ)
         + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ)
         + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ)
         + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ)
          + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ)
          + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ)
          + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ)
          + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ)
          + 2 * re ‚ü™‚ü™x, ‚ü´ ‚Ä¢ x, y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/PiL2.lean - 2024-09-07 21:49:40.019188.
---19/100---
For theorem Orthonormal.exists_orthonormalBasis_extension in Mathlib/Analysis/InnerProductSpace/PiL2.lean:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal ùïú ((‚Üë) : v ‚Üí E)) :
    ‚àÉ (u : Finset E) (b : OrthonormalBasis u ùïú E), v ‚äÜ u ‚àß ‚áëb = ((‚Üë) : u ‚Üí E) 


Original valid proof:
:= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.setFinite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_‚ü©
  ¬∑ simpa [u] using hu‚ÇÄ_max
  ¬∑ simpa [u] using hu‚ÇÄs
  ¬∑ simp


Verifying proof (Commit 5648120293e005e7ed12dc634bf3094a1835c21b):
:= by
  obtain ‚ü®u‚ÇÄ, hu‚ÇÄs, hu‚ÇÄ, hu‚ÇÄ_max‚ü© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu‚ÇÄ] at hu‚ÇÄ_max
  have hu‚ÇÄ_finite : u‚ÇÄ.Finite := hu‚ÇÄ.linearIndependent.setFinite
  let u : Finset E := hu‚ÇÄ_finite.toFinset
  let fu : ‚Ü•u ‚âÉ ‚Ü•u‚ÇÄ := hu‚ÇÄ_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ùïú ((‚Üë) : u ‚Üí E) := by simpa using hu‚ÇÄ.comp _ fu.injective
  refine ‚ü®u, OrthonormalBasis.mkOfOrthogonalEqBot hu _, ?_, ?_‚ü©
  ¬∑ simpa using hu‚ÇÄ_max

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/RieszLemma.lean - 2024-09-07 21:51:47.228915.
---20/100---
For theorem riesz_lemma in Mathlib/Analysis/NormedSpace/RieszLemma.lean:
theorem riesz_lemma {F : Subspace ùïú E} (hFc : IsClosed (F : Set E)) (hF : ‚àÉ x : E, x ‚àâ F) {r : ‚Ñù}
    (hr : r < 1) : ‚àÉ x‚ÇÄ : E, x‚ÇÄ ‚àâ F ‚àß ‚àÄ y ‚àà F, r * ‚Äñx‚ÇÄ‚Äñ ‚â§ ‚Äñx‚ÇÄ - y‚Äñ 


Original valid proof:
:= by
  classical
    obtain ‚ü®x, hx‚ü© : ‚àÉ x : E, x ‚àâ F := hF
    let d := Metric.infDist x F
    have hFn : (F : Set E).Nonempty := ‚ü®_, F.zero_mem‚ü©
    have hdp : 0 < d :=
      lt_of_le_of_ne Metric.infDist_nonneg fun heq =>
        hx ((hFc.mem_iff_infDist_zero hFn).2 heq.symm)
    let r' := max r 2‚Åª¬π
    have hr' : r' < 1 := by
      simp only [r', ge_iff_le, max_lt_iff, hr, true_and]
      norm_num
    have hlt : 0 < r' := lt_of_lt_of_le (by norm_num) (le_max_right r 2‚Åª¬π)
    have hdlt : d < d / r' := (lt_div_iff hlt).mpr ((mul_lt_iff_lt_one_right hdp).2 hr')
    obtain ‚ü®y‚ÇÄ, hy‚ÇÄF, hxy‚ÇÄ‚ü© : ‚àÉ y ‚àà F, dist x y < d / r' := (Metric.infDist_lt_iff hFn).mp hdlt
    have x_ne_y‚ÇÄ : x - y‚ÇÄ ‚àâ F := by
      by_contra h
      have : x - y‚ÇÄ + y‚ÇÄ ‚àà F := F.add_mem h hy‚ÇÄF
      simp only [neg_add_cancel_right, sub_eq_add_neg] at this
      exact hx this
    refine ‚ü®x - y‚ÇÄ, x_ne_y‚ÇÄ, fun y hy => le_of_lt ?_‚ü©
    have hy‚ÇÄy : y‚ÇÄ + y ‚àà F := F.add_mem hy‚ÇÄF hy
    calc
      r * ‚Äñx - y‚ÇÄ‚Äñ ‚â§ r' * ‚Äñx - y‚ÇÄ‚Äñ := by gcongr; apply le_max_left
      _ < d := by
        rw [‚Üê dist_eq_norm]
        exact (lt_div_iff' hlt).1 hxy‚ÇÄ
      _ ‚â§ dist x (y‚ÇÄ + y) := Metric.infDist_le_dist_of_mem hy‚ÇÄy
      _ = ‚Äñx - y‚ÇÄ - y‚Äñ := by rw [sub_sub, dist_eq_norm]


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
:= by
  classical
    obtain ‚ü®x, hx‚ü© : ‚àÉ x : E, x ‚àâ F := hF
    let d := Metric.infDist x F
    have hFn : (F : Set E).Nonempty := ‚ü®_, F.zero_mem‚ü©
    have hdp : 0 < d :=
      lt_of_le_of_ne Metric.infDist_nonneg fun heq =>
        hx ((hFc.mem_iff_infDist_zero hFn).2 heq.symm)
    let r' := max r 2‚Åª¬π
    have hr' : r' < 1 := by
      simp [hr]
      norm_num
    have hlt : 0 < r' := lt_of_lt_of_le (by norm_num) (le_max_right r 2‚Åª¬π)
    have hdlt : d < d / r' := (lt_div_iff hlt).mpr ((mul_lt_iff_lt_one_right hdp).2 hr')
    obtain ‚ü®y‚ÇÄ, hy‚ÇÄF, hxy‚ÇÄ‚ü© : ‚àÉ y ‚àà F, dist x y < d / r' := (Metric.infDist_lt_iff hFn).mp hdlt
    have x_ne_y‚ÇÄ : x - y‚ÇÄ ‚àâ F := by
      by_contra h
      have : x - y‚ÇÄ + y‚ÇÄ ‚àà F := F.add_mem h hy‚ÇÄF
      simp only [neg_add_cancel_right, sub_eq_add_neg] at this
      exact hx this
    refine ‚ü®x - y‚ÇÄ, x_ne_y‚ÇÄ, fun y hy => le_of_lt ?_‚ü©
    have hy‚ÇÄy : y‚ÇÄ + y ‚àà F := F.add_mem hy‚ÇÄF hy
    calc
      r * ‚Äñx - y‚ÇÄ‚Äñ ‚â§ r' * ‚Äñx - y‚ÇÄ‚Äñ := by gcongr; apply le_max_left
      _ < d := by
        rw [‚Üê dist_eq_norm]
        exact (lt_div_iff' hlt).1 hxy‚ÇÄ
      _ ‚â§ dist x (y‚ÇÄ + y) := (Metric.infDist_le_dist_of_mem hy‚ÇÄy)
      _ = ‚Äñx - y‚ÇÄ - y‚Äñ := by rw [sub_sub, dist_eq_norm]

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean - 2024-09-07 21:51:56.048455.
---21/100---
For theorem nonneg_iff_isSelfAdjoint_and_spectrumRestricts in Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ‚â§ a ‚Üî IsSelfAdjoint a ‚àß SpectrumRestricts a ContinuousMap.realToNNReal 


Original valid proof:
:= by
  refine ‚ü®fun ha ‚Ü¶ ‚ü®.of_nonneg ha, .nnreal_of_nonneg ha‚ü©, ?_‚ü©
  rintro ‚ü®ha‚ÇÅ, ha‚ÇÇ‚ü©
  obtain ‚ü®x, hx, -, rfl‚ü© := CFC.exists_sqrt_of_isSelfAdjoint_of_spectrumRestricts ha‚ÇÅ ha‚ÇÇ
  simpa [sq, hx.star_eq] using star_mul_self_nonneg x


Verifying proof (Commit d16c7a879e758dc3aee434d847d69bfbaf9f30f0):
:= by
  rw [SpectrumRestricts.nnreal_iff]
  refine ‚ü®fun ha ‚Ü¶ ?_, ?_‚ü©
  ¬∑ rw [StarOrderedRing.nonneg_iff] at ha
    induction ha using AddSubmonoid.closure_induction' with
    | mem x hx =>
      obtain ‚ü®b, rfl‚ü© := hx
      exact ‚ü®IsSelfAdjoint.star_mul_self b, spectrum_star_mul_self_nonneg‚ü©
    | one =>
      nontriviality A
      simp
    | mul x _ y _ hx hy =>
      rw [‚Üê SpectrumRestricts.nnreal_iff] at hx hy ‚ä¢
      exact ‚ü®hx.1.add hy.1, hx.2.nnreal_add hx.1 hy.1 hy.2‚ü©
  ¬∑ rintro ‚ü®ha‚ÇÅ, ha‚ÇÇ‚ü©
    let s := cfc a Real.sqrt
    have : a = star s * s := by
      rw [‚Üê cfc_id a (R := ‚Ñù), ‚Üê cfc_mul ..]
      apply cfc_congr a
      peel ha‚ÇÇ with x hx _
      simp [Real.mul_self_sqrt this]
    exact this ‚ñ∏ star_mul_self_nonneg s

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean - 2024-09-07 21:53:20.126498.
---22/100---
For theorem Real.Gamma_mul_Gamma_one_sub in Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean:
theorem Gamma_mul_Gamma_one_sub (z : ‚ÑÇ) : Gamma z * Gamma (1 - z) = œÄ / sin (œÄ * z) 


Original valid proof:
:= by
  have pi_ne : (œÄ : ‚ÑÇ) ‚â† 0 := Complex.ofReal_ne_zero.mpr pi_ne_zero
  by_cases hs : sin (‚ÜëœÄ * z) = 0
  ¬∑ 
    rw [hs, div_zero]
    rw [‚Üê neg_eq_zero, ‚Üê Complex.sin_neg, ‚Üê mul_neg, Complex.sin_eq_zero_iff, mul_comm] at hs
    obtain ‚ü®k, hk‚ü© := hs
    rw [mul_eq_mul_right_iff, eq_false (ofReal_ne_zero.mpr pi_pos.ne'), or_false_iff,
      neg_eq_iff_eq_neg] at hk
    rw [hk]
    cases k
    ¬∑ rw [Int.ofNat_eq_coe, Int.cast_natCast, Complex.Gamma_neg_nat_eq_zero, zero_mul]
    ¬∑ rw [Int.cast_negSucc, neg_neg, Nat.cast_add, Nat.cast_one, add_comm, sub_add_cancel_left,
        Complex.Gamma_neg_nat_eq_zero, mul_zero]
  refine tendsto_nhds_unique ((GammaSeq_tendsto_Gamma z).mul (GammaSeq_tendsto_Gamma <| 1 - z)) ?_
  have : ‚ÜëœÄ / sin (‚ÜëœÄ * z) = 1 * (œÄ / sin (œÄ * z)) := by rw [one_mul]
  convert Tendsto.congr' ((eventually_ne_atTop 0).mp (eventually_of_forall fun n hn =>
    (GammaSeq_mul z hn).symm)) (Tendsto.mul _ _)
  ¬∑ convert tendsto_natCast_div_add_atTop (1 - z) using 1; ext1 n; rw [add_sub_assoc]
  ¬∑ have : ‚ÜëœÄ / sin (‚ÜëœÄ * z) = 1 / (sin (œÄ * z) / œÄ) := by field_simp
    convert tendsto_const_nhds.div _ (div_ne_zero hs pi_ne)
    rw [‚Üê tendsto_mul_iff_of_ne_zero tendsto_const_nhds pi_ne, div_mul_cancel‚ÇÄ _ pi_ne]
    convert tendsto_euler_sin_prod z using 1
    ext1 n; rw [mul_comm, ‚Üê mul_assoc]


Verifying proof (Commit 916c75c1d9f2fcdcd11d5d5b32f69afcc94bb9c4):
:= by
  have pi_ne : (œÄ : ‚ÑÇ) ‚â† 0 := Complex.ofReal_ne_zero.mpr pi_ne_zero
  by_cases hs : sin (‚ÜëœÄ * z) = 0
  ¬∑ 
    rw [hs, div_zero]
    rw [‚Üê neg_eq_zero, ‚Üê Complex.sin_neg, ‚Üê mul_neg, Complex.sin_eq_zero_iff, mul_comm] at hs
    obtain ‚ü®k, hk‚ü© := hs
    rw [mul_eq_mul_right_iff, eq_false (ofReal_ne_zero.mpr pi_pos.ne'), or_false_iff,
      neg_eq_iff_eq_neg] at hk
    rw [hk]
    cases k
    ¬∑ rw [Int.ofNat_eq_coe, Int.cast_ofNat, Complex.Gamma_neg_nat_eq_zero, zero_mul]
    ¬∑ rw [Int.cast_negSucc, neg_neg, Nat.cast_add, Nat.cast_one, add_comm, sub_add_cancel_left,
        Complex.Gamma_neg_nat_eq_zero, MulZeroClass.mul_zero]
  refine tendsto_nhds_unique ((GammaSeq_tendsto_Gamma z).mul (GammaSeq_tendsto_Gamma <| 1 - z)) ?_
  have : ‚ÜëœÄ / sin (‚ÜëœÄ * z) = 1 * (œÄ / sin (œÄ * z)) := by rw [one_mul]
  convert Tendsto.congr' ((eventually_ne_atTop 0).mp (eventually_of_forall fun n hn =>
    (GammaSeq_mul z hn).symm)) (Tendsto.mul _ _)
  ¬∑ convert tendsto_coe_nat_div_add_atTop (1 - z) using 1; ext1 n; rw [add_sub_assoc]
  ¬∑ have : ‚ÜëœÄ / sin (‚ÜëœÄ * z) = 1 / (sin (œÄ * z) / œÄ) := by field_simp
    convert tendsto_const_nhds.div _ (div_ne_zero hs pi_ne)
    rw [‚Üê tendsto_mul_iff_of_ne_zero tendsto_const_nhds pi_ne, div_mul_cancel _ pi_ne]
    convert tendsto_euler_sin_prod z using 1
    ext1 n; rw [mul_comm, ‚Üê mul_assoc]

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Integrals.lean - 2024-09-07 21:54:00.808501.
---23/100---
For theorem intervalIntegral.intervalIntegrable_rpow' in Mathlib/Analysis/SpecialFunctions/Integrals.lean:
theorem intervalIntegrable_rpow' {r : ‚Ñù} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b 


Original valid proof:
:= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]


Verifying proof (Commit 3cb2bdef8481160ee4f3f3a94fca1f5824c2798a):
:= by
  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ‚â† 0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    ¬∑ intro x hx; apply rpow_nonneg hx.1.le
    ¬∑ refine (continuousOn_id.rpow_const _).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  ¬∑ exact this c hc
  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))
    rw [intervalIntegrable_iff] at m ‚ä¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]

Attempt failure.

Working on Mathlib/CategoryTheory/Adjunction/Reflective.lean - 2024-09-07 21:54:19.732400.
---24/100---
For theorem CategoryTheory.equivEssImageOfReflective_map_counitIso_app_hom in Mathlib/CategoryTheory/Adjunction/Reflective.lean:
lemma equivEssImageOfReflective_map_counitIso_app_hom [Reflective i]
    (X : Functor.EssImageSubcategory i) :



Original valid proof:
  (Functor.essImageInclusion i).map (equivEssImageOfReflective_counitIso_app X).hom =
    inv (NatTrans.app (reflectorAdjunction i).unit X.obj) := by
    simp only [Functor.comp_obj, Functor.essImageInclusion_obj, Functor.toEssImage_obj_obj,
      equivEssImageOfReflective_counitIso_app, asIso, Iso.symm_mk, Functor.essImageInclusion_map,
      Functor.id_obj]
    rfl


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  simp only [Functor.comp_obj, Functor.essImageInclusion_obj, Functor.toEssImage_obj_obj,
      equivEssImageOfReflective_counitIso_app, asIso, Iso.symm_mk, Functor.essImageInclusion_map,
      Functor.id_obj]
    rfl

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Constructions/FiniteProductsOfBinaryProducts.lean - 2024-09-07 21:54:25.320353.
---25/100---
For theorem CategoryTheory.hasFiniteCoproducts_of_has_binary_and_initial in Mathlib/CategoryTheory/Limits/Constructions/FiniteProductsOfBinaryProducts.lean:
theorem hasFiniteCoproducts_of_has_binary_and_initial : HasFiniteCoproducts C 


Original valid proof:
:= by
  refine ‚ü®fun n => ‚ü®fun K => ?_‚ü©‚ü©
  letI := hasCoproduct_fin n fun n => K.obj ‚ü®n‚ü©
  let that : K ‚âÖ Discrete.functor fun n => K.obj ‚ü®n‚ü© := Discrete.natIso fun ‚ü®i‚ü© => Iso.refl _
  apply @hasColimitOfIso _ _ _ _ _ _ this that


Verifying proof (Commit 3fcb15f5aa08e5cd66d3eaa95fa51be7f9820348):
:= by
  refine ‚ü®fun n => ‚ü®fun K => ?_‚ü©‚ü©
  letI := has_coproduct_fin n fun n => K.obj ‚ü®n‚ü©
  let that : K ‚âÖ Discrete.functor fun n => K.obj ‚ü®n‚ü© := Discrete.natIso fun ‚ü®i‚ü© => Iso.refl ?_
  apply @hasColimitOfIso _ _ _ _ _ this that

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/HasLimits.lean - 2024-09-07 21:54:31.671609.
---26/100---
For theorem CategoryTheory.Limits.hasColimitOfIso in Mathlib/CategoryTheory/Limits/HasLimits.lean:
theorem hasColimitOfIso {F G : J ‚•§ C} [HasColimit F] (Œ± : G ‚âÖ F) : HasColimit G 


Original valid proof:
:=
  HasColimit.mk
    { cocone := (Cocones.precompose Œ±.hom).obj (colimit.cocone F)
      isColimit := (IsColimit.precomposeHomEquiv _ _).symm (colimit.isColimit F) }


Verifying proof (Commit da3e3a365fffd6c256a62d8990639a4256687a5d):
:=
  HasColimit.mk
    { cocone := (Cocones.precompose Œ±.hom).obj (colimit.cocone F)
      isColimit :=
        { desc := fun s => colimit.desc F ((Cocones.precompose Œ±.inv).obj s)
          fac := fun s j => by
             rw [Cocones.precompose_obj_Œπ, NatTrans.comp_app, colimit.cocone_Œπ]
           rw [Category.assoc, colimit.Œπ_desc, ‚Üê NatIso.app_hom, ‚Üê Iso.eq_inv_comp]; rfl
          uniq := fun s m w => by
             apply colimit.hom_ext; intro j
            rw [colimit.Œπ_desc, Cocones.precompose_obj_Œπ, NatTrans.comp_app, ‚Üê NatIso.app_inv,
             Iso.eq_inv_comp]
            simpa using w j } }

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean - 2024-09-07 21:54:44.394707.
---27/100---
For theorem CategoryTheory.Limits.hasFiniteLimits_of_hasFiniteLimits_of_size in Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean:
theorem hasFiniteLimits_of_hasFiniteLimits_of_size
    (h : ‚àÄ (J : Type w) {ùí• : SmallCategory J} (_ : @FinCategory J ùí•), HasLimitsOfShape J C) :
    HasFiniteLimits C where



Original valid proof:
  out := fun J hJ hhJ => by
    haveI := h (ULiftHom.{w} (ULift.{w} J)) <| @CategoryTheory.finCategoryUlift J hJ hhJ
    have l : @Equivalence J (ULiftHom (ULift J)) hJ
                          (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) :=
      @ULiftHomULiftCategory.equiv J hJ
    apply @hasLimitsOfShape_of_equivalence (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) C _ J hJ
      (@Equivalence.symm J hJ (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) l) _
    


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= fun J hJ hhJ => by
    haveI := h (ULiftHom.{w} (ULift.{w} J)) <| @CategoryTheory.finCategoryUlift J hJ hhJ
    have l : @Equivalence J (ULiftHom (ULift J)) hJ
                      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) :=
      @ULiftHomULiftCategory.equiv J hJ
    apply @hasLimitsOfShape_of_equivalence (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) l) _
    class HasFiniteColimits : Prop where
  out (J : Type) [ùí• : SmallCategory J] [@FinCategory J ùí•] : @HasColimitsOfShape J ùí• C _

Attempt failure.

Working on Mathlib/CategoryTheory/Localization/Triangulated.lean - 2024-09-07 21:54:49.846216.
---28/100---
For theorem CategoryTheory.Triangulated.Localization.distinguished_cocone_triangle in Mathlib/CategoryTheory/Localization/Triangulated.lean:
lemma distinguished_cocone_triangle {X Y : D} (f : X ‚ü∂ Y) :
    ‚àÉ (Z : D) (g : Y ‚ü∂ Z) (h : Z ‚ü∂ X‚ü¶(1 : ‚Ñ§)‚üß),
      Triangle.mk f g h ‚àà L.essImageDistTriang 


Original valid proof:
:= by
  have := essSurj_mapArrow L W
  obtain ‚ü®œÜ, ‚ü®e‚ü©‚ü© : ‚àÉ (œÜ : Arrow C), Nonempty (L.mapArrow.obj œÜ ‚âÖ Arrow.mk f) :=
    ‚ü®_, ‚ü®Functor.objObjPreimageIso _ _‚ü©‚ü©
  obtain ‚ü®Z, g, h, H‚ü© := Pretriangulated.distinguished_cocone_triangle œÜ.hom
  refine ‚ü®L.obj Z, e.inv.right ‚â´ L.map g,
    L.map h ‚â´ (L.commShiftIso (1 : ‚Ñ§)).hom.app _ ‚â´ e.hom.left‚ü¶(1 : ‚Ñ§)‚üß', _, ?_, H‚ü©
  refine Triangle.isoMk _ _ (Arrow.leftFunc.mapIso e.symm) (Arrow.rightFunc.mapIso e.symm)
    (Iso.refl _) e.inv.w.symm (by simp) ?_
  dsimp
  simp only [assoc, id_comp, ‚Üê Functor.map_comp, ‚Üê Arrow.comp_left, e.hom_inv_id, Arrow.id_left,
    Functor.mapArrow_obj_left, Functor.map_id, comp_id]


Verifying proof (Commit bb5ccc412d812c6019a24d2f31b52e65258aa0e4):
:= by
  have := Localization.essSurj L W
  let f' := MorphismProperty.HasLeftCalculusOfFractions.liftMap L W f
  obtain ‚ü®Z, g, h, H‚ü© := Pretriangulated.distinguished_cocone_triangle _ _ f'
  refine ‚ü®L.obj Z, (MorphismProperty.HasLeftCalculusOfFractions.liftMapIso‚ÇÇ L W f).hom ‚â´ L.map g,
    L.map h ‚â´ (L.commShiftIso (1 : ‚Ñ§)).hom.app _ ‚â´
      (MorphismProperty.HasLeftCalculusOfFractions.liftMapIso‚ÇÅ L W f)
    (MorphismProperty.HasLeftCalculusOfFractions.liftMapIso‚ÇÇ L W f)
    (Iso.refl _) (MorphismProperty.HasLeftCalculusOfFractions.liftMap_fac L W f) (by simp) ?_
  dsimp
  simp only [assoc, id_comp, ‚Üê Functor.map_comp, Iso.inv_hom_id, Functor.map_id, comp_id]

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Canonical.lean - 2024-09-07 21:55:07.838379.
---29/100---
For theorem CategoryTheory.Sheaf.isSheafFor_trans in Mathlib/CategoryTheory/Sites/Canonical.lean:
theorem isSheafFor_trans (P : C·µí·µñ ‚•§ Type v) (R S : Sieve X)
    (hR : Presieve.IsSheafFor P (R : Presieve X))
    (hR' : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (_ : S f), Presieve.IsSeparatedFor P (R.pullback f : Presieve Y))
    (hS : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (_ : R f), Presieve.IsSheafFor P (S.pullback f : Presieve Y)) :
    Presieve.IsSheafFor P (S : Presieve X) 


Original valid proof:
:= by
  have : (bind R fun Y f _ => S.pullback f : Presieve X) ‚â§ S := by
    rintro Z f ‚ü®W, f, g, hg, hf : S _, rfl‚ü©
    apply hf
  apply Presieve.isSheafFor_subsieve_aux P this
  ¬∑ apply isSheafFor_bind _ _ _ hR hS
    intro Y f hf Z g
    rw [‚Üê pullback_comp]
    apply (hS (R.downward_closed hf _)).isSeparatedFor
  ¬∑ intro Y f hf
    have : Sieve.pullback f (bind R fun T (k : T ‚ü∂ X) (_ : R k) => pullback k S) =
        R.pullback f := by
      ext Z g
      constructor
      ¬∑ rintro ‚ü®W, k, l, hl, _, comm‚ü©
        rw [pullback_apply, ‚Üê comm]
        simp [hl]
      ¬∑ intro a
        refine ‚ü®Z, ùüô Z, _, a, ?_‚ü©
        simp [hf]
    rw [this]
    apply hR' hf


Verifying proof (Commit a94e348e169a5be4a12ee3126b97e400fc7980e7):
:= by
  have : (bind R fun Y f _ => S.pullback f : Presieve X) ‚â§ S := by
    rintro Z f ‚ü®W, f, g, hg, hf : S _, rfl‚ü©
    apply hf
  apply Presieve.isSheafFor_subsieve_aux P this
  apply isSheafFor_bind _ _ _ hR hS
  ¬∑ intro Y f hf Z g
    dsimp
    rw [‚Üê pullback_comp]
    apply (hS (R.downward_closed hf _)).isSeparatedFor
  ¬∑ intro Y f hf
    have : Sieve.pullback f (bind R fun T (k : T ‚ü∂ X) (_ : R k) => pullback k S) =
        R.pullback f := by
      ext Z
      intro g
      constructor
      ¬∑ rintro ‚ü®W, k, l, hl, _, comm‚ü©
        rw [pullback_apply, ‚Üê comm]
        simp [hl]
      ¬∑ intro a
        refine ‚ü®Z, ùüô Z, ?_, a, ?_‚ü©
        simp [hf]
    rw [this]
    apply hR' hf

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Plus.lean - 2024-09-07 21:55:14.182084.
---30/100---
For theorem CategoryTheory.GrothendieckTopology.plusMap_toPlus in Mathlib/CategoryTheory/Sites/Plus.lean:
theorem plusMap_toPlus : J.plusMap (J.toPlus P) = J.toPlus (J.plusObj P) 


Original valid proof:
:= by
  ext X : 2
  refine colimit.hom_ext (fun S => ?_)
  dsimp only [plusMap, toPlus]
  let e : S.unop ‚ü∂ ‚ä§ := homOfLE (OrderTop.le_top _)
  rw [Œπ_colimMap, ‚Üê colimit.w _ e.op, ‚Üê Category.assoc, ‚Üê Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun I => ?_)
  erw [Multiequalizer.lift_Œπ]
  simp only [unop_op, op_unop, diagram_map, Category.assoc, limit.lift_œÄ,
    Multifork.ofŒπ_œÄ_app]
  let ee : (J.pullback (I.map e).f).obj S.unop ‚ü∂ ‚ä§ := homOfLE (OrderTop.le_top _)
  erw [‚Üê colimit.w _ ee.op, Œπ_colimMap_assoc, colimit.Œπ_pre, diagramPullback_app,
    ‚Üê Category.assoc, ‚Üê Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun II => ?_)
  convert Multiequalizer.condition (S.unop.index P)
    (Cover.Relation.mk I II.base { g‚ÇÅ := II.f, g‚ÇÇ := ùüô _ }) using 1
  all_goals dsimp; simp


Verifying proof (Commit e044580ec850092e8f63fd442e5a9b44c3651b83):
:= by
  ext X : 2
  refine colimit.hom_ext (fun S => ?_)
  dsimp only [plusMap, toPlus]
  let e : S.unop ‚ü∂ ‚ä§ := homOfLE (OrderTop.le_top _)
  rw [Œπ_colimMap, ‚Üê colimit.w _ e.op, ‚Üê Category.assoc, ‚Üê Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext ?_ ?_ ?_ (fun II => ?_)
  convert (Multiequalizer.condition (S.unop.index P)
      ‚ü®_, _, _, II.f, ùüô _, I.f, II.f ‚â´ I.f, I.hf,
        Sieve.downward_closed _ I.hf _, by simp‚ü©) using 1
  ¬∑ dsimp [diagram]
    cases I
    simp only [Category.assoc, limit.lift_œÄ, Multifork.ofŒπ_pt, Multifork.ofŒπ_œÄ_app,
      Cover.Arrow.map_Y, Cover.Arrow.map_f]
    rfl
  ¬∑ erw [Multiequalizer.lift_Œπ]
    dsimp [Cover.index]
    simp only [Functor.map_id, Category.comp_id]
    rfl

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Sheaf.lean - 2024-09-07 21:55:24.512577.
---31/100---
For theorem CategoryTheory.Presheaf.isSheaf_iff_multiequalizer in Mathlib/CategoryTheory/Sites/Sheaf.lean:
theorem isSheaf_iff_multiequalizer [‚àÄ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :
    IsSheaf J P ‚Üî ‚àÄ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) 


Original valid proof:
:= by
  rw [isSheaf_iff_multifork]
  refine forall‚ÇÇ_congr fun X S => ‚ü®?_, ?_‚ü©
  ¬∑ rintro ‚ü®h‚ü©
    let e : P.obj (op X) ‚âÖ multiequalizer (S.index P) :=
      h.conePointUniqueUpToIso (limit.isLimit _)
    exact (inferInstance : IsIso e.hom)
  ¬∑ intro h
    refine ‚ü®IsLimit.ofIsoLimit (limit.isLimit _) (Cones.ext ?_ ?_)‚ü©
    ¬∑ apply (@asIso _ _ _ _ _ h).symm
    ¬∑ intro a
      symm
      erw [IsIso.inv_comp_eq]
      dsimp
      simp


Verifying proof (Commit bfeaa186b46811aacfb5c266a1e6b12a55ab2920):
:= by
  rw [isSheaf_iff_multifork]
  refine forall‚ÇÇ_congr fun X S => ‚ü®?_, ?_‚ü©
  ¬∑ rintro ‚ü®h‚ü©
    let e : P.obj (op X) ‚âÖ multiequalizer (S.index P) :=
      h.conePointUniqueUpToIso (limit.isLimit _)
    exact (inferInstance : IsIso e.hom)
  ¬∑ intro h
    refine ‚ü®IsLimit.ofIsoLimit (limit.isLimit _)
      (Iso.symm (Multifork.ext (asIso (S.toMultiequalizer P)) _))‚ü©
    intro a
    erw [limit.lift_œÄ]
    rfl

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Sheafification.lean - 2024-09-07 21:55:42.939351.
---32/100---
For theorem CategoryTheory.HasSheafify.mk' in Mathlib/CategoryTheory/Sites/Sheafification.lean:
theorem HasSheafify.mk' {F : (C·µí·µñ ‚•§ A) ‚•§ Sheaf J A} (adj : F ‚ä£ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where



Original valid proof:
  isRightAdjoint := ‚ü®F, ‚ü®adj‚ü©‚ü©
  isLeftExact := ‚ü®by
    have : (sheafToPresheaf J A).IsRightAdjoint := ‚ü®_, ‚ü®adj‚ü©‚ü©
    exact ‚ü®fun _ _ _ ‚Ü¶ preservesLimitsOfShapeOfNatIso
      (adj.leftAdjointUniq (Adjunction.ofIsRightAdjoint (sheafToPresheaf J A)))‚ü©‚ü©


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  sheafToPresheaf J A := fun _ ‚Ü¶
      adj.leftAdjointUniq (Adjunction.ofRightAdjoint (sheafToPresheaf J A))
    ‚ü®‚ü®fun _ ‚Ü¶ preservesLimitsOfShapeOfNatIso (i _)‚ü©‚ü©

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean - 2024-09-07 21:55:50.876634.
---33/100---
For theorem SimpleGraph.isAdjMatrix_adjMatrix in Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean:
theorem isAdjMatrix_adjMatrix [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsAdjMatrix 


Original valid proof:
:=
  { zero_or_one := fun i j => by by_cases h : G.Adj i j <;> simp [h] }


Verifying proof (Commit be491e5ccecbea382c9ac5db0917dea23fb40bc5):
:=
  { zero_or_one := fun i j => by by_cases Adj G i j <;> dsimp at h <;> simp [h] }

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Clique.lean - 2024-09-07 21:55:58.690205.
---34/100---
For theorem SimpleGraph.cliqueSet_map in Mathlib/Combinatorics/SimpleGraph/Clique.lean:
theorem cliqueSet_map (hn : n ‚â† 1) (G : SimpleGraph Œ±) (f : Œ± ‚Ü™ Œ≤) :
    (G.map f).cliqueSet n = map f '' G.cliqueSet n 


Original valid proof:
:= by
  ext s
  constructor
  ¬∑ rintro ‚ü®hs, rfl‚ü©
    have hs' : (s.preimage f f.injective.injOn).map f = s := by
      classical
      rw [map_eq_image, image_preimage, filter_true_of_mem]
      rintro a ha
      obtain ‚ü®b, hb, hba‚ü© := exists_mem_ne (hn.lt_of_le' <| Finset.card_pos.2 ‚ü®a, ha‚ü©) a
      obtain ‚ü®c, _, _, hc, _‚ü© := hs ha hb hba.symm
      exact ‚ü®c, hc‚ü©
    refine ‚ü®s.preimage f f.injective.injOn, ‚ü®?_, by rw [‚Üê card_map f, hs']‚ü©, hs'‚ü©
    rw [coe_preimage]
    exact fun a ha b hb hab => map_adj_apply.1 (hs ha hb <| f.injective.ne hab)
  ¬∑ rintro ‚ü®s, hs, rfl‚ü©
    exact hs.map


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  ext s
  constructor
  ¬∑ rintro ‚ü®hs, rfl‚ü©
    have hs' : (s.preimage f <| f.injective.injOn _).map f = s := by
      classical
      rw [map_eq_image, image_preimage, filter_true_of_mem]
      rintro a ha
      obtain ‚ü®b, hb, hba‚ü© := exists_mem_ne (hn.lt_of_le' <| Finset.card_pos.2 ‚ü®a, ha‚ü©) a
      obtain ‚ü®c, _, _, hc, _‚ü© := hs ha hb hba.symm
      exact ‚ü®c, hc‚ü©
    refine ‚ü®s.preimage f <| f.injective.injOn, ‚ü®?_, by rw [‚Üê card_map f, hs']‚ü©, hs'‚ü©
    rw [coe_preimage]
    exact fun a ha b hb hab => map_adj_apply.1 (hs ha hb <| f.injective.ne hab)
  ¬∑ rintro ‚ü®s, hs, rfl‚ü©
    exact hs.map

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean - 2024-09-07 21:56:16.380124.
---35/100---
For theorem Finpartition.equitabilise_aux in Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    ‚àÉ Q : Finpartition s,
      (‚àÄ x : Finset Œ±, x ‚àà Q.parts ‚Üí x.card = m ‚à® x.card = m + 1) ‚àß
        (‚àÄ x, x ‚àà P.parts ‚Üí (x \ (Q.parts.filter fun y => y ‚äÜ x).biUnion id).card ‚â§ m) ‚àß
          (Q.parts.filter fun i => card i = m + 1).card = b 


Original valid proof:
:= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  ¬∑ refine ‚ü®‚ä•, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symm‚ü©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      ‚ü®{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _‚ü©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 ‚àß b = 0
  ¬∑ simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Œ± := Finpartition ‚ä•) P
    exact ‚ü®Finpartition.empty _, by simp, by simp [this], by simp [hab.2]‚ü©
  simp_rw [not_and_or, ‚Üê Ne.eq_def, ‚Üê pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain ‚ü®hn‚ÇÄ, hn‚ÇÅ, hn‚ÇÇ, hn‚ÇÉ‚ü© : 0 < n ‚àß n ‚â§ m + 1 ‚àß n ‚â§ a * m + b * (m + 1) ‚àß
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, ‚Üê hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    ¬∑ refine ‚ü®m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ ‚Äπ0 < a‚Ä∫), ?_‚ü©
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    ¬∑ refine ‚ü®succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‚Äπ¬¨0 < a‚Ä∫), ?_‚ü©
      rw [‚Üê add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‚Äπ¬¨0 < a‚Ä∫)]
  by_cases h : ‚àÄ u ‚àà P.parts, card u < m + 1
  ¬∑ obtain ‚ü®t, hts, htn‚ü© := exists_subset_card_eq (hn‚ÇÇ.trans_eq hs)
    have ht : t.Nonempty := by rwa [‚Üê card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff ‚Äπt ‚äÜ s‚Ä∫, htn, hn‚ÇÉ]
    obtain ‚ü®R, hR‚ÇÅ, _, hR‚ÇÉ‚ü© :=
      @ih (s \ t) (sdiff_ssubset hts ‚Äπt.Nonempty‚Ä∫) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine ‚ü®R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_‚ü©
    ¬∑ simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR‚ÇÅ, htn, hn]
      exact ite_eq_or_eq _ _ _
    ¬∑ exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    ¬∑ rw [hR‚ÇÉ, if_pos ha]
    rw [card_insert_of_not_mem, hR‚ÇÉ, if_neg ha, tsub_add_cancel_of_le]
    ¬∑ exact hab.resolve_left ha
    ¬∑ intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain ‚ü®u, hu‚ÇÅ, hu‚ÇÇ‚ü© := h
  obtain ‚ü®t, htu, htn‚ü© := exists_subset_card_eq (hn‚ÇÅ.trans hu‚ÇÇ)
  have ht : t.Nonempty := by rwa [‚Üê card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le hu‚ÇÅ), htn, hn‚ÇÉ]
  obtain ‚ü®R, hR‚ÇÅ, hR‚ÇÇ, hR‚ÇÉ‚ü© :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le hu‚ÇÅ) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine
    ‚ü®R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le hu‚ÇÅ), ?_, ?_, ?_‚ü©
  ¬∑ simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR‚ÇÅ, htn, hn]
    exact ite_eq_or_eq _ _ _
  ¬∑ conv in _ ‚àà _ => rw [‚Üê insert_erase hu‚ÇÅ]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine ‚ü®?_, fun x hx => (card_le_card ?_).trans <| hR‚ÇÇ x ?_‚ü©
    ¬∑ simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      ¬∑ rw [sdiff_eq_empty_iff_subset.2 subset_union_left]
        exact bot_le
      refine
        (card_le_card fun i => ?_).trans
          (hR‚ÇÇ (u \ t) <| P.mem_avoid.2 ‚ü®u, hu‚ÇÅ, fun i => hut <| i.antisymm htu, rfl‚ü©)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hi‚ÇÅ hi‚ÇÇ hi‚ÇÉ =>
        ‚ü®‚ü®hi‚ÇÅ, hi‚ÇÇ‚ü©, fun x hx hx' => hi‚ÇÉ _ hx <| hx'.trans sdiff_subset‚ü©
    ¬∑ apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      ‚ü®(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) hu‚ÇÅ <| ne_of_mem_erase hx).sdiff_eq_left‚ü©
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  ¬∑ rw [hR‚ÇÉ, if_pos h]
  ¬∑ rw [card_insert_of_not_mem, hR‚ÇÉ, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
:= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  ¬∑ refine ‚ü®‚ä•, by simp, ?_, by simpa using hs.symm‚ü©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      ‚ü®{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _‚ü©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 ‚àß b = 0
  ¬∑ simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Œ± := Finpartition ‚ä•) P
    exact ‚ü®Finpartition.empty _, by simp, by simp [this], by simp [hab.2]‚ü©
  simp_rw [not_and_or, ‚Üê Ne, ‚Üê pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain ‚ü®hn‚ÇÄ, hn‚ÇÅ, hn‚ÇÇ, hn‚ÇÉ‚ü© : 0 < n ‚àß n ‚â§ m + 1 ‚àß n ‚â§ a * m + b * (m + 1) ‚àß
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, ‚Üê hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    ¬∑ refine ‚ü®m_pos, le_succ _, le_add_right (le_mul_of_pos_left ‚Äπ0 < a‚Ä∫), ?_‚ü©
      rw [‚Üê add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left ‚Äπ¬¨0 < a‚Ä∫)]
  by_cases h : ‚àÄ u ‚àà P.parts, card u < m + 1
  ¬∑ obtain ‚ü®t, hts, htn‚ü© := exists_smaller_set s n (hn‚ÇÇ.trans_eq hs)
    have ht : t.Nonempty := by rwa [‚Üê card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff ‚Äπt ‚äÜ s‚Ä∫, htn, hn‚ÇÉ]
    obtain ‚ü®R, hR‚ÇÅ, _, hR‚ÇÉ‚ü© :=
      @ih (s \ t) (sdiff_ssubset hts ‚Äπt.Nonempty‚Ä∫) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine ‚ü®R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_‚ü©
    ¬∑ simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR‚ÇÅ, htn, hn]
      exact ite_eq_or_eq _ _ _
    ¬∑ exact fun x hx => (card_le_card <| sdiff_subset _

Attempt failure.

Working on Mathlib/Computability/Primrec.lean - 2024-09-07 21:56:25.158354.
---36/100---
For theorem Primrec.nat_casesOn' in Mathlib/Computability/Primrec.lean:
theorem nat_casesOn' {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí ‚Ñï ‚Üí Œ≤} (hf : Primrec f) (hg : Primrec‚ÇÇ g) :
    Primrec‚ÇÇ fun a (n : ‚Ñï) => (n.casesOn (f a) (g a) : Œ≤) 


Original valid proof:
:=
  nat_rec hf <| hg.comp‚ÇÇ Primrec‚ÇÇ.left <| comp‚ÇÇ fst Primrec‚ÇÇ.right


Verifying proof (Commit b912476b37f2ea41ee51af7e63439f4a769be095):
:=
  nat_rec hf (hg.comp‚ÇÇ fst <| comp fst snd).to‚ÇÇ

Attempt failure.

Working on Mathlib/Data/Complex/Basic.lean - 2024-09-07 21:56:37.436470.
---37/100---
For theorem Complex.div_ofNat_im in Mathlib/Data/Complex/Basic.lean:
lemma div_ofNat_im (z : ‚ÑÇ) (n : ‚Ñï) [n.AtLeastTwo] :
    (z / no_index (OfNat.ofNat n)).im = z.im / OfNat.ofNat n 


Original valid proof:
:= div_natCast_im z n


Verifying proof (Commit 9b243ae831d11cebac23a7a95ad1c107722bb200):
:= div_nat_cast_im z n

Attempt failure.

Working on Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean - 2024-09-07 21:56:46.896552.
---38/100---
For theorem Multiset.Nat.nodup_antidiagonalTuple in Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean:
theorem nodup_antidiagonalTuple (k n : ‚Ñï) : List.Nodup (antidiagonalTuple k n) 


Original valid proof:
:= by
  induction' k with k ih generalizing n
  ¬∑ cases n
    ¬∑ simp
    ¬∑ simp [eq_comm]
  simp_rw [antidiagonalTuple, List.nodup_bind]
  constructor
  ¬∑ intro i _
    exact (ih i.snd).map (Fin.cons_right_injective (Œ± := fun _ => ‚Ñï) i.fst)
  induction' n with n n_ih
  ¬∑ exact List.pairwise_singleton _ _
  ¬∑ rw [List.Nat.antidiagonal_succ]
    refine List.Pairwise.cons (fun a ha x hx‚ÇÅ hx‚ÇÇ => ?_) (n_ih.map _ fun a b h x hx‚ÇÅ hx‚ÇÇ => ?_)
    ¬∑ rw [List.mem_map] at hx‚ÇÅ hx‚ÇÇ ha
      obtain ‚ü®‚ü®a, -, rfl‚ü©, ‚ü®x‚ÇÅ, -, rfl‚ü©, ‚ü®x‚ÇÇ, -, h‚ü©‚ü© := ha, hx‚ÇÅ, hx‚ÇÇ
      rw [Fin.cons_eq_cons] at h
      injection h.1
    ¬∑ rw [List.mem_map] at hx‚ÇÅ hx‚ÇÇ
      obtain ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ, rfl‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ, h‚ÇÅ‚ÇÇ‚ü©‚ü© := hx‚ÇÅ, hx‚ÇÇ
      dsimp at h‚ÇÅ‚ÇÇ
      rw [Fin.cons_eq_cons, Nat.succ_inj'] at h‚ÇÅ‚ÇÇ
      obtain ‚ü®h‚ÇÅ‚ÇÇ, rfl‚ü© := h‚ÇÅ‚ÇÇ
      rw [h‚ÇÅ‚ÇÇ] at h
      exact h (List.mem_map_of_mem _ hx‚ÇÅ) (List.mem_map_of_mem _ hx‚ÇÇ)


Verifying proof (Commit 388222f05155eadab4ebf5bf655aaca770cf9c53):
:= by
  induction' k with k ih generalizing n
  ¬∑ cases n
    ¬∑ simp
    ¬∑ simp [eq_comm]
  simp_rw [antidiagonalTuple, List.nodup_bind]
  constructor
  ¬∑ intro i _
    exact (ih i.snd).map (Fin.cons_right_injective (Œ± := fun _ => ‚Ñï) i.fst)
  induction' n with n n_ih
  ¬∑ exact List.pairwise_singleton _ _
  ¬∑ rw [List.Nat.antidiagonal_succ]
    refine List.Pairwise.cons (fun a ha x hx‚ÇÅ hx‚ÇÇ => ?_) (n_ih.map _ fun a b h x hx‚ÇÅ hx‚ÇÇ => ?_)
    ¬∑ rw [List.mem_map'] at hx‚ÇÅ hx‚ÇÇ ha
      obtain ‚ü®‚ü®a, -, rfl‚ü©, ‚ü®x‚ÇÇ, -, h‚ü©‚ü© := ha, hx‚ÇÅ, hx‚ÇÇ
      rw [Fin.cons_eq_cons] at h
      injection h.1
    ¬∑ rw [List.mem_map'] at hx‚ÇÅ hx‚ÇÇ
      obtain ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ, rfl‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ, h‚ÇÅ‚ÇÇ‚ü©‚ü© := hx‚ÇÅ, hx‚ÇÇ
      dsimp at h‚ÇÅ‚ÇÇ
      rw [Fin.cons_eq_cons, Nat.succ_inj'] at h‚ÇÅ‚ÇÇ
      obtain ‚ü®h‚ÇÅ‚ÇÇ, rfl‚ü© := h‚ÇÅ‚ÇÇ
      rw [h‚ÇÅ‚ÇÇ] at h
      exact h (List.mem_map_of_mem _ hx‚ÇÅ) (List.mem_map_of_mem _ hx‚ÇÇ)

Attempt failure.

Working on Mathlib/Data/Real/Archimedean.lean - 2024-09-07 21:56:53.529792.
---39/100---
For theorem Real.exists_isLUB in Mathlib/Data/Real/Archimedean.lean:
theorem exists_isLUB {S : Set ‚Ñù} (hne : S.Nonempty) (hbdd : BddAbove S) : ‚àÉ x, IsLUB S x 


Original valid proof:
:= by
  rcases hne, hbdd with ‚ü®‚ü®L, hL‚ü©, ‚ü®U, hU‚ü©‚ü©
  have : ‚àÄ d : ‚Ñï, BddAbove { m : ‚Ñ§ | ‚àÉ y ‚àà S, (m : ‚Ñù) ‚â§ y * d } := by
    cases' exists_int_gt U with k hk
    refine fun d => ‚ü®k * d, fun z h => ?_‚ü©
    rcases h with ‚ü®y, yS, hy‚ü©
    refine Int.cast_le.1 (hy.trans ?_)
    push_cast
    exact mul_le_mul_of_nonneg_right ((hU yS).trans hk.le) d.cast_nonneg
  choose f hf using fun d : ‚Ñï =>
    Int.exists_greatest_of_bdd (this d) ‚ü®‚åäL * d‚åã, L, hL, Int.floor_le _‚ü©
  have hf‚ÇÅ : ‚àÄ n > 0, ‚àÉ y ‚àà S, ((f n / n : ‚Ñö) : ‚Ñù) ‚â§ y := fun n n0 =>
    let ‚ü®y, yS, hy‚ü© := (hf n).1
    ‚ü®y, yS, by simpa using (div_le_iff (Nat.cast_pos.2 n0 : (_ : ‚Ñù) < _)).2 hy‚ü©
  have hf‚ÇÇ : ‚àÄ n > 0, ‚àÄ y ‚àà S, (y - ((n : ‚Ñï) : ‚Ñù)‚Åª¬π) < (f n / n : ‚Ñö) := by
    intro n n0 y yS
    have := (Int.sub_one_lt_floor _).trans_le (Int.cast_le.2 <| (hf n).2 _ ‚ü®y, yS, Int.floor_le _‚ü©)
    simp only [Rat.cast_div, Rat.cast_intCast, Rat.cast_natCast, gt_iff_lt]
    rwa [lt_div_iff (Nat.cast_pos.2 n0 : (_ : ‚Ñù) < _), sub_mul, _root_.inv_mul_cancel]
    exact ne_of_gt (Nat.cast_pos.2 n0)
  have hg : IsCauSeq abs (fun n => f n / n : ‚Ñï ‚Üí ‚Ñö) := by
    intro Œµ Œµ0
    suffices ‚àÄ j ‚â• ‚åàŒµ‚Åª¬π‚åâ‚Çä, ‚àÄ k ‚â• ‚åàŒµ‚Åª¬π‚åâ‚Çä, (f j / j - f k / k : ‚Ñö) < Œµ by
      refine ‚ü®_, fun j ij => abs_lt.2 ‚ü®?_, this _ ij _ le_rfl‚ü©‚ü©
      rw [neg_lt, neg_sub]
      exact this _ le_rfl _ ij
    intro j ij k ik
    replace ij := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ij)
    replace ik := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ik)
    have j0 := Nat.cast_pos.1 ((inv_pos.2 Œµ0).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 Œµ0).trans_le ik)
    rcases hf‚ÇÅ _ j0 with ‚ü®y, yS, hy‚ü©
    refine lt_of_lt_of_le ((Rat.cast_lt (K := ‚Ñù)).1 ?_) ((inv_le Œµ0 (Nat.cast_pos.2 k0)).1 ik)
    simpa using sub_lt_iff_lt_add'.2 (lt_of_le_of_lt hy <| sub_lt_iff_lt_add.1 <| hf‚ÇÇ _ k0 _ yS)
  let g : CauSeq ‚Ñö abs := ‚ü®fun n => f n / n, hg‚ü©
  refine ‚ü®mk g, ‚ü®fun x xS => ?_, fun y h => ?_‚ü©‚ü©
  ¬∑ refine le_of_forall_ge_of_dense fun z xz => ?_
    cases' exists_nat_gt (x - z)‚Åª¬π with K hK
    refine le_mk_of_forall_le ‚ü®K, fun n nK => ?_‚ü©
    replace xz := sub_pos.2 xz
    replace hK := hK.le.trans (Nat.cast_le.2 nK)
    have n0 : 0 < n := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le hK)
    refine le_trans ?_ (hf‚ÇÇ _ n0 _ xS).le
    rwa [le_sub_comm, inv_le (Nat.cast_pos.2 n0 : (_ : ‚Ñù) < _) xz]
  ¬∑ exact
      mk_le_of_forall_le
        ‚ü®1, fun n n1 =>
          let ‚ü®x, xS, hx‚ü© := hf‚ÇÅ _ n1
          le_trans hx (h xS)‚ü©


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  rcases hne, hbdd with ‚ü®‚ü®L, hL‚ü©, ‚ü®U, hU‚ü©‚ü©
  have : ‚àÄ d : ‚Ñï, BddAbove { m : ‚Ñ§ | ‚àÉ y ‚àà S, (m : ‚Ñù) ‚â§ y * d } := by
    cases' exists_int_gt U with k hk
    refine fun d => ‚ü®k * d, fun z h => ?_‚ü©
    rcases h with ‚ü®y, yS, hy‚ü©
    refine Int.cast_le.1 (hy.trans ?_)
    push_cast
    exact mul_le_mul_of_nonneg_right ((hU yS).trans hk.le) d.cast_nonneg
  choose f hf using fun d : ‚Ñï =>
    Int.exists_greatest_of_bdd (this d) ‚ü®‚åäL * d‚åã, L, hL, Int.floor_le _‚ü©
  have hf‚ÇÅ : ‚àÄ n > 0, ‚àÉ y ‚àà S, ((f n / n : ‚Ñö) : ‚Ñù) ‚â§ y := fun n n0 =>
    let ‚ü®y, yS, hy‚ü© := (hf n).1
    ‚ü®y, yS, by simpa using (div_le_iff (Nat.cast_pos.2 n0 : (_ : ‚Ñù) < _)).2 hy‚ü©
  have hf‚ÇÇ : ‚àÄ n > 0, ‚àÄ y ‚àà S, (y - ((n : ‚Ñï) : ‚Ñù)‚Åª¬π) < (f n / n : ‚Ñö) := by
    intro n n0 y yS
    have := (Int.sub_one_lt_floor _).trans_le (Int.cast_le.2 <| (hf n).2 _ ‚ü®y, yS, Int.floor_le _‚ü©)
    simp only [Rat.cast_div, Rat.cast_intCast, Rat.cast_natCast, gt_iff_lt]
    rwa [lt_div_iff (Nat.cast_pos.2 n0 : (_ : ‚Ñù) < _), sub_mul, _root_.inv_mul_cancel]
    exact ne_of_gt (Nat.cast_pos.2 n0)
  have hg : IsCauSeq abs (fun n => f n / n : ‚Ñï ‚Üí ‚Ñö) := by
    intro Œµ Œµ0
    suffices ‚àÄ j ‚â• ‚åàŒµ‚Åª¬π‚åâ‚Çä, ‚àÄ k ‚â• ‚åàŒµ‚Åª¬π‚åâ‚Çä, ‚àÄ k ‚â• ‚åàŒµ‚Åª¬π‚åâ‚Çä, (f j / j - f k / k : ‚Ñö) < Œµ by
      refine ‚ü®_, fun j ij => abs_lt.2 ‚ü®?_, this _ ij _ le_rfl‚ü©‚ü©
      rw [neg_lt, neg_sub]
      exact this _ le_rfl _ ij
    intro j ij k ik
    replace ij := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ij)
    replace ik := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ij)
    have j0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le ij)

Attempt failure.

Working on Mathlib/Data/Seq/WSeq.lean - 2024-09-07 21:57:01.390535.
---40/100---
For theorem Stream'.WSeq.cons_append in Mathlib/Data/Seq/WSeq.lean:
theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) 


Original valid proof:
:=
  Seq.cons_append _ _ _


Verifying proof (Commit 938069ac7c83a4980c46ca108d9947ab788c12ee):
:=
  Seq.cons_append _ _ _

Attempt success.

Working on Mathlib/Data/Set/Finite.lean - 2024-09-07 21:57:14.960250.
---41/100---
For theorem Set.Finite.bddBelow_biUnion in Mathlib/Data/Set/Finite.lean:
theorem Finite.bddBelow_biUnion {I : Set Œ≤} {S : Œ≤ ‚Üí Set Œ±} (H : I.Finite) :
    BddBelow (‚ãÉ i ‚àà I, S i) ‚Üî ‚àÄ i ‚àà I, BddBelow (S i) 


Original valid proof:
:=
  @Finite.bddAbove_biUnion Œ±·µí·µà _ _ _ _ _ _ H


Verifying proof (Commit cda5caa719c6f4cebb505d3bc9250e3bbaf0fc67):
:=
  @Finite.bddAbove_biUnion Œ±·µí·µà _ _ _ _ H

Attempt failure.

Working on Mathlib/Data/ZMod/Basic.lean - 2024-09-07 21:57:24.945840.
---42/100---
For theorem ZMod.cast_one in Mathlib/Data/ZMod/Basic.lean:
theorem cast_one (h : m ‚à£ n) : (cast (1 : ZMod n) : R) = 1 


Original valid proof:
:= by
  cases' n with n
  ¬∑ exact Int.cast_one
  show ((1 % (n + 1) : ‚Ñï) : R) = 1
  cases n;
  ¬∑ rw [Nat.dvd_one] at h
    subst m
    have : Subsingleton R := CharP.CharOne.subsingleton
    apply Subsingleton.elim
  rw [Nat.mod_eq_of_lt]
  ¬∑ exact Nat.cast_one
  exact Nat.lt_of_sub_eq_succ rfl


Verifying proof (Commit 40085f5f4d3ac3fa83073044989c1dde599ea994):
:= by
  cases' n with n
  ¬∑ exact Int.cast_one
  show ((1 % (n + 1) : ‚Ñï) : R) = 1
  cases n
  ¬∑ rw [Nat.dvd_one] at h
    subst m
    subsingleton [CharP.CharOne.subsingleton]
  rw [Nat.mod_eq_of_lt]
  ¬∑ exact Nat.cast_one
  exact Nat.lt_of_sub_eq_succ rfl

Attempt failure.

Working on Mathlib/FieldTheory/Finite/Basic.lean - 2024-09-07 21:57:36.977028.
---43/100---
For theorem FiniteField.card_image_polynomial_eval in Mathlib/FieldTheory/Finite/Basic.lean:
theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R ‚â§ natDegree p * (univ.image fun x => eval x p).card 


Original valid proof:
:=
  Finset.card_le_mul_card_image _ _ (fun a _ =>
    calc
      _ = (p - C a).roots.toFinset.card :=
        congr_arg card (by simp [Finset.ext_iff, ‚Üê mem_roots_sub_C hp])
      _ ‚â§ Multiset.card (p - C a).roots := Multiset.toFinset_card_le _
      _ ‚â§ _ := card_roots_sub_C' hp)


Verifying proof (Commit 89feeaaf464cdb346baab6c7adb1bec331fe789a):
:= sorry

Attempt failure.

---44/100---
For theorem FiniteField.sum_pow_lt_card_sub_one in Mathlib/FieldTheory/Finite/Basic.lean:
theorem sum_pow_lt_card_sub_one (i : ‚Ñï) (h : i < q - 1) : ‚àë x : K, x ^ i = 0 


Original valid proof:
:= by
  by_cases hi : i = 0
  ¬∑ simp only [hi, nsmul_one, sum_const, pow_zero, card_univ, cast_card_eq_zero]
  classical
    have hiq : ¬¨q - 1 ‚à£ i := by contrapose! h; exact Nat.le_of_dvd (Nat.pos_of_ne_zero hi) h
    let œÜ : KÀ£ ‚Ü™ K := ‚ü®fun x ‚Ü¶ x, Units.ext‚ü©
    have : univ.map œÜ = univ \ {0} := by
      ext x
      simpa only [mem_map, mem_univ, Function.Embedding.coeFn_mk, true_and_iff, mem_sdiff,
        mem_singleton, œÜ] using isUnit_iff_ne_zero
    calc
      ‚àë x : K, x ^ i = ‚àë x ‚àà univ \ {(0 : K)}, x ^ i := by
        rw [‚Üê sum_sdiff ({0} : Finset K).subset_univ, sum_singleton, zero_pow hi, add_zero]
      _ = ‚àë x : KÀ£, (x ^ i : K) := by simp [œÜ, ‚Üê this, univ.sum_map œÜ]
      _ = 0 := by rw [sum_pow_units K i, if_neg]; exact hiq


Verifying proof (Commit d618ff4f3388c25c5910e38dd87658b81cb6666f):
:= by
  rcases eq_or_ne i 0 with rfl | hi
  ¬∑ simp only [nsmul_one, sum_const, pow_zero, card_univ, CharP.cast_card_eq_zero]
  classical
  rw [‚Üê Fintype.card_units, ‚Üê Subgroup.card_top] at h
  have key := sum_subgroup_pow_eq_zero (K := K) (G := ‚ä§) hi (by convert h)
  erw [Subgroup.sum_top ((¬∑ : KÀ£ ‚Üí K) ^ i : KÀ£ ‚Üí K)] at key
  rw [‚Üê sum_units_nonunits, ‚Üê key]
  simp [hi]

Attempt failure.

Working on Mathlib/GroupTheory/OrderOfElement.lean - 2024-09-07 21:58:01.247410.
---45/100---
For theorem Fintype.card_zpowers in Mathlib/GroupTheory/OrderOfElement.lean:
theorem Fintype.card_zpowers : Fintype.card (zpowers x) = orderOf x 


Original valid proof:
:=
  (Fintype.card_eq.2 ‚ü®finEquivZPowers x <| isOfFinOrder_of_finite _‚ü©).symm.trans <|
    Fintype.card_fin (orderOf x)


Verifying proof (Commit e8acc5ce2eae55793195ef3a2db2fbbe35cc03aa):
:=
  (Fintype.card_eq.2 ‚ü®finEquivZpowers x $ isOfFinOrder_of_finite _‚ü©).symm.trans $
    Fintype.card_fin (orderOf x)

Attempt failure.

Working on Mathlib/GroupTheory/PGroup.lean - 2024-09-07 21:58:14.197595.
---46/100---
For theorem IsPGroup.index in Mathlib/GroupTheory/PGroup.lean:
theorem index (H : Subgroup G) [H.FiniteIndex] : ‚àÉ n : ‚Ñï, H.index = p ^ n 


Original valid proof:
:= by
  haveI := H.normalCore.fintypeQuotientOfFiniteIndex
  obtain ‚ü®n, hn‚ü© := iff_card.mp (hG.to_quotient H.normalCore)
  obtain ‚ü®k, _, hk2‚ü© :=
    (Nat.dvd_prime_pow hp.out).mp
      ((congr_arg _ (H.normalCore.index_eq_card.trans hn)).mp
        (Subgroup.index_dvd_of_le H.normalCore_le))
  exact ‚ü®k, hk2‚ü©


Verifying proof (Commit 034139f67d1e53664a78cb1986579908d1f2fa67):
:= by
  haveI := H.normalCore.fintypeQuotientOfFiniteIndex
  obtain ‚ü®n, hn‚ü© := iff_card.mp (hG.to_quotient H.normalCore)
  rw [‚Üê Nat.card_eq_fintype_card] at hn
  obtain ‚ü®k, _, hk2‚ü© :=
    (Nat.dvd_prime_pow hp.out).mp
      ((congr_arg _ (H.normalCore.index_eq_card.trans hn)).mp
        (Subgroup.index_dvd_of_le H.normalCore_le))
  exact ‚ü®k, hk2‚ü©

Attempt failure.

Working on Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean - 2024-09-07 21:58:23.661456.
---47/100---
For theorem affineSpan_le_toAffineSubspace_span in Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean:
lemma affineSpan_le_toAffineSubspace_span {s : Set V} :
    affineSpan k s ‚â§ (Submodule.span k s).toAffineSubspace 


Original valid proof:
:= by
  intro x hx
  show x ‚àà Submodule.span k s
  induction hx using affineSpan_induction' with
  | mem x hx => exact Submodule.subset_span hx
  | smul_vsub_vadd c u _ v _ w _ hu hv hw =>
    simp only [vsub_eq_sub, vadd_eq_add]
    apply Submodule.add_mem _ _ hw
    exact Submodule.smul_mem _ _ (Submodule.sub_mem _ hu hv)


Verifying proof (Commit 9bc35020058f4a5a844eb7662d9de673056d4dbe):
:= by
  intro x hx
  show x ‚àà Submodule.span k s
  induction hx using affineSpan_induction' with
  | Hs x hx => exact Submodule.subset_span hx
  | Hc c u _ v _ w _ hu hv hw =>
    simp only [vsub_eq_sub, vadd_eq_add]
    apply Submodule.add_mem _ _ hw
    exact Submodule.smul_mem _ _ (Submodule.sub_mem _ hu hv)

Attempt failure.

Working on Mathlib/LinearAlgebra/Basis.lean - 2024-09-07 21:58:42.409433.
---48/100---
For theorem union_support_maximal_linearIndependent_eq_range_basis in Mathlib/LinearAlgebra/Basis.lean:
theorem union_support_maximal_linearIndependent_eq_range_basis {Œπ : Type w} (b : Basis Œπ R M)
    {Œ∫ : Type w'} (v : Œ∫ ‚Üí M) (i : LinearIndependent R v) (m : i.Maximal) :
    ‚ãÉ k, ((b.repr (v k)).support : Set Œπ) = Set.univ 


Original valid proof:
:= by
  by_contra h
  simp only [‚Üê Ne.eq_def, ne_univ_iff_exists_not_mem, mem_iUnion, not_exists_not,
    Finsupp.mem_support_iff, Finset.mem_coe] at h
  obtain ‚ü®b', w‚ü© := h
  let v' : Option Œ∫ ‚Üí M := fun o => o.elim (b b') v
  have r : range v ‚äÜ range v' := by
    rintro - ‚ü®k, rfl‚ü©
    use some k
    simp only [v', Option.elim_some]
  have r' : b b' ‚àâ range v := by
    rintro ‚ü®k, p‚ü©
    simpa [w] using congr_arg (fun m => (b.repr m) b') p
  have r'' : range v ‚â† range v' := by
    intro e
    have p : b b' ‚àà range v' := by
      use none
      simp only [v', Option.elim_none]
    rw [‚Üê e] at p
    exact r' p
  have i' : LinearIndependent R ((‚Üë) : range v' ‚Üí M) := by
    apply LinearIndependent.to_subtype_range
    rw [linearIndependent_iff]
    intro l z
    rw [Finsupp.total_option] at z
    simp only [v', Option.elim'] at z
    change _ + Finsupp.total Œ∫ M R v l.some = 0 at z
    have l‚ÇÄ : l none = 0 := by
      rw [‚Üê eq_neg_iff_add_eq_zero] at z
      replace z := neg_eq_iff_eq_neg.mpr z
      apply_fun fun x => b.repr x b' at z
      simp only [repr_self, map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply,
        Finsupp.smul_single', map_neg, Finsupp.coe_neg] at z
      erw [DFunLike.congr_fun (Finsupp.apply_total R (b.repr : M ‚Üí‚Çó[R] Œπ ‚Üí‚ÇÄ R) v l.some) b'] at z
      simpa [Finsupp.total_apply, w] using z
    have l‚ÇÅ : l.some = 0 := by
      rw [l‚ÇÄ, zero_smul, zero_add] at z
      exact linearIndependent_iff.mp i _ z
    ext (_ | a)
    ¬∑ simp only [l‚ÇÄ, Finsupp.coe_zero, Pi.zero_apply]
    ¬∑ erw [DFunLike.congr_fun l‚ÇÅ a]
      simp only [Finsupp.coe_zero, Pi.zero_apply]
  rw [LinearIndependent.Maximal] at m
  specialize m (range v') i' r
  exact r'' m


Verifying proof (Commit b09462282225ca03a37b7e6afde435d1ab7552ef):
:= by
  by_contra h
  simp only [‚Üê Ne, ne_univ_iff_exists_not_mem, mem_iUnion, not_exists_not,
    Finsupp.mem_support_iff, Finset.mem_coe] at h
  obtain ‚ü®b', w‚ü© := h
  let v' : Option Œ∫ ‚Üí M := fun o => o.elim (b b') v
  have r : range v ‚äÜ range v' := by
    rintro - ‚ü®k, rfl‚ü©
    use some k
    rfl
  have r' : b b' ‚àâ range v := by
    rintro ‚ü®k, p‚ü©
    simpa [w] using congr_arg (fun m => (b.repr m) b') p
  have r'' : range v ‚â† range v' := by
    intro e
    have p : b b' ‚àà range v' := by
      use none
      rfl
    rw [‚Üê e] at p
    exact r' p
  have i' : LinearIndependent R ((‚Üë) : range v' ‚Üí M) := by
    apply LinearIndependent.to_subtype_range
    rw [linearIndependent_iff]
    intro l z
    rw [Finsupp.total_option] at z
    simp only [Option.elim'] at z
    change _ + Finsupp.total Œ∫ M R v l.some = 0 at z
    have l‚ÇÄ : l none = 0 := by
      rw [‚Üê eq_neg_iff_add_eq_zero] at z
      replace z := neg_eq_iff_eq_neg.mpr z
      apply_fun fun x => b.repr x b' at z
      simp only [repr_self, LinearEquiv.map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply,
        Finsupp.smul_single', LinearEquiv.map_neg, Finsupp.coe_neg] at z
      erw [FunLike.congr_fun (Finsupp.apply_total R (b.repr : M ‚Üí‚Çó[R] Œπ ‚Üí‚ÇÄ R) v l.some) b'] at z
      simpa [Finsupp.total_apply, w] using z
    have l‚ÇÅ : l.some = 0 := by
      rw [l‚ÇÄ, zero_smul, zero_add] at z
      exact linearIndependent_iff.mp i _ z
    ext (_ | a)
    ¬∑ simp only [l‚ÇÄ, Finsupp.coe_zero, Pi.zero_apply]
    ¬∑ erw [FunLike.congr_fun l‚ÇÅ a]
      simp only [Finsupp.coe_zero, Pi.zero_apply]
  rw [LinearIndependent.Maximal] at m
  specialize m (range v') i' r
  exact r'' m

Attempt failure.

Working on Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean - 2024-09-07 21:59:03.475348.
---49/100---
For theorem ExteriorAlgebra.ŒπMulti_span in Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean:
lemma ŒπMulti_span :
    Submodule.span R (Set.range fun x : Œ£ n, (Fin n ‚Üí M) => ŒπMulti R x.1 x.2) = ‚ä§ 


Original valid proof:
:= by
  rw [Submodule.eq_top_iff']
  intro x
  induction x using DirectSum.Decomposition.inductionOn fun i => ‚ãÄ[R]^i M with
  | h_zero => exact Submodule.zero_mem _
  | h_add _ _ hm hm' => exact Submodule.add_mem _ hm hm'
  | h_homogeneous hm =>
    let ‚ü®m, hm‚ü© := hm
    apply Set.mem_of_mem_of_subset hm
    rw [‚Üê ŒπMulti_span_fixedDegree]
    refine Submodule.span_mono fun _ hx ‚Ü¶ ?_
    obtain ‚ü®y, rfl‚ü© := hx
    exact ‚ü®‚ü®_, y‚ü©, rfl‚ü©


Verifying proof (Commit 6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92):
:= by
  rw [Submodule.eq_top_iff']
  intro x
  induction x
    using DirectSum.Decomposition.inductionOn fun i => LinearMap.range (Œπ R (M := M)) ^ i with
  | h_zero => exact Submodule.zero_mem _
  | h_add _ _ hm hm' => exact Submodule.add_mem _ hm hm'
  | h_homogeneous hm =>
    let ‚ü®m, hm‚ü© := hm
    apply Set.mem_of_mem_of_subset hm
    rw [‚Üê ŒπMulti_span_fixedDegree]
    refine Submodule.span_mono fun _ hx ‚Ü¶ ?_
    obtain ‚ü®y, rfl‚ü© := hx
    exact ‚ü®‚ü®_, y‚ü©, rfl‚ü©

Attempt failure.

Working on Mathlib/LinearAlgebra/FiniteDimensional.lean - 2024-09-07 21:59:22.454660.
---50/100---
For theorem FiniteDimensional.of_fintype_basis in Mathlib/LinearAlgebra/FiniteDimensional.lean:
theorem of_fintype_basis {Œπ : Type w} [Finite Œπ] (h : Basis Œπ K V) : FiniteDimensional K V 


Original valid proof:
:=
  Module.Finite.of_basis h


Verifying proof (Commit 44d0abee8c9db1dbf8d88d89f61bae7c34234d96):
:= by
  cases nonempty_fintype Œπ
  exact ‚ü®‚ü®Finset.univ.image h, by
    convert h.span_eq
    simp‚ü©‚ü©

Attempt failure.

Working on Mathlib/LinearAlgebra/Finsupp.lean - 2024-09-07 21:59:43.588133.
---51/100---
For theorem Finsupp.lsum_single in Mathlib/LinearAlgebra/Finsupp.lean:
theorem lsum_single (f : Œ± ‚Üí M ‚Üí‚Çó[R] N) (i : Œ±) (m : M) :
    Finsupp.lsum S f (Finsupp.single i m) = f i m 


Original valid proof:
:=
  Finsupp.sum_single_index (f i).map_zero


Verifying proof (Commit 67e80fd089fe45abea632652c43b78eba72d60e3):
:=
  sumAddHom_single (fun a => (‚Üë(f a) : M ‚Üí+ N)) i m

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Adjugate.lean - 2024-09-07 22:00:04.946450.
---52/100---
For theorem Matrix.cramer_eq_adjugate_mulVec in Mathlib/LinearAlgebra/Matrix/Adjugate.lean:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n Œ±) (b : n ‚Üí Œ±) :
    cramer A b = A.adjugate *·µ• b 


Original valid proof:
:= by
  nth_rw 2 [‚Üê A.transpose_transpose]
  rw [‚Üê adjugate_transpose, adjugate_def]
  have : b = ‚àë i, b i ‚Ä¢ (Pi.single i 1 : n ‚Üí Œ±) := by
    refine (pi_eq_sum_univ b).trans ?_
    congr with j
    simp [Pi.single_apply, eq_comm, Pi.smul_apply (b j)]
  conv_lhs =>
    rw [this]
  ext k
  simp [mulVec, dotProduct, mul_comm]


Verifying proof (Commit 6be2bec13d4dd1fd901f9a619d053d7549cfe177):
:= by
  nth_rw 2 [‚Üê A.transpose_transpose]
  rw [‚Üê adjugate_transpose, adjugate_def]
  have : b = ‚àë i, b i ‚Ä¢ Pi.single i 1 := by
    refine (pi_eq_sum_univ b).trans ?_
    congr with j
    simp [Pi.single_apply, eq_comm, Pi.smul_apply (b j)]
  conv_lhs =>
    rw [this]
  ext k
  simp [mulVec, dotProduct, mul_comm]

Attempt failure.

Working on Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean - 2024-09-07 22:00:18.907875.
---53/100---
For theorem Algebra.TensorProduct.map_ker in Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean:
theorem Algebra.TensorProduct.map_ker (hf : Function.Surjective f) (hg : Function.Surjective g) :
    RingHom.ker (map f g) =
      (RingHom.ker f).map (Algebra.TensorProduct.includeLeft : A ‚Üí‚Çê[R] A ‚äó[R] C) ‚äî
        (RingHom.ker g).map (Algebra.TensorProduct.includeRight : C ‚Üí‚Çê[R] A ‚äó[R] C) 


Original valid proof:
:= by
  have : map f g = (map f (AlgHom.id R D)).comp (map (AlgHom.id R A) g) := ext rfl rfl
  rw [this]
  simp only [AlgHom.coe_ker, AlgHom.comp_toRingHom]
  rw [‚Üê RingHom.comap_ker]
  simp only [‚Üê AlgHom.coe_ker]
  rw [‚Üê Algebra.TensorProduct.lTensor_ker _ hg, RingHom.ker_eq_comap_bot (map (AlgHom.id R A) g)]
  rw [‚Üê Ideal.comap_map_of_surjective (map (AlgHom.id R A) g) (LinearMap.lTensor_surjective A hg)]
  rw [Algebra.TensorProduct.rTensor_ker _ hf]
  apply congr_arg‚ÇÇ _ rfl
  simp only [AlgHom.coe_ideal_map, Ideal.map_map]
  rw [‚Üê AlgHom.comp_toRingHom, Algebra.TensorProduct.map_comp_includeLeft]
  rfl


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
:= by
  have : map f g = (map f (AlgHom.id R D)).comp (map (AlgHom.id R A) g) := ext rfl rfl
  rw [this]
  simp only [AlgHom.coe_ker, AlgHom.comp_toRingHom]
  rw [‚Üê RingHom.comap_ker]
  simp only [‚Üê AlgHom.coe_ker]
  rw [‚Üê AlgHom.comp_toRingHom, Algebra.TensorProduct.map_comp_includeLeft]
  rfl

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/Pi.lean - 2024-09-07 22:00:42.817960.
---54/100---
For theorem generateFrom_pi in Mathlib/MeasureTheory/Constructions/Pi.lean:
theorem generateFrom_pi_eq {C : ‚àÄ i, Set (Set (Œ± i))} (hC : ‚àÄ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) 


Original valid proof:
:= by
  cases nonempty_encodable Œπ
  apply le_antisymm
  ¬∑ refine iSup_le ?_; intro i; rw [comap_generateFrom]
    apply generateFrom_le; rintro _ ‚ü®s, hs, rfl‚ü©
    choose t h1t h2t using hC
    simp_rw [eval_preimage, ‚Üê h2t]
    rw [‚Üê @iUnion_const _ ‚Ñï _ s]
    have : Set.pi univ (update (fun i' : Œπ => iUnion (t i')) i (‚ãÉ _ : ‚Ñï, s)) =
        Set.pi univ fun k => ‚ãÉ j : ‚Ñï,
        @update Œπ (fun i' => Set (Œ± i')) _ (fun i' => t i' j) i s k := by
      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'
      by_cases h : i' = i
      ¬∑ subst h; simp
      ¬∑ rw [‚Üê Ne] at h; simp [h]
    rw [this, ‚Üê iUnion_univ_pi]
    apply MeasurableSet.iUnion
    intro n; apply measurableSet_generateFrom
    apply mem_image_of_mem; intro j _; dsimp only
    by_cases h : j = i
    ¬∑ subst h; rwa [update_same]
    ¬∑ rw [update_noteq h]; apply h1t
  ¬∑ apply generateFrom_le; rintro _ ‚ü®s, hs, rfl‚ü©
    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i
    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))
    exact measurableSet_generateFrom (hs i (mem_univ i))


Verifying proof (Commit 961db629df93e5dbd02440deee4c37efcf2faa85):
:= by
  cases nonempty_encodable Œπ
  apply le_antisymm
  ¬∑ refine iSup_le _; intro i; rw [comap_generateFrom]
    apply generateFrom_le; rintro _ ‚ü®s, hs, rfl‚ü©; dsimp
    choose t h1t h2t using hC
    simp_rw [eval_preimage, ‚Üê h2t]
    rw [‚Üê @iUnion_const _ ‚Ñï _ s]
    have : Set.pi univ (update (fun i' : Œπ => iUnion (t i')) i (‚ãÉ _ : ‚Ñï, s)) =
        Set.pi univ fun k => ‚ãÉ j : ‚Ñï,
        @update Œπ (fun i' => Set (Œ± i')) _ (fun i' => t i' j) i s k := by
      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'
      by_cases h : i' = i
      ¬∑ subst h; simp
      ¬∑ rw [‚Üê Ne.eq_def] at h; simp [h]
    rw [this, ‚Üê iUnion_univ_pi]
    apply MeasurableSet.iUnion
    intro n; apply measurableSet_generateFrom
    apply mem_image_of_mem; intro j _; dsimp only
    by_cases h : j = i; subst h; rwa [update_same]; rw [update_noteq h]; apply h1t
  ¬∑ apply generateFrom_le; rintro _ ‚ü®s, hs, rfl‚ü©
    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i
    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))
    exact measurableSet_generateFrom (hs i (mem_univ i))

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/Polish.lean - 2024-09-07 22:00:54.781707.
---55/100---
For theorem MeasureTheory.AnalyticSet.iUnion in Mathlib/MeasureTheory/Constructions/Polish.lean:
theorem AnalyticSet.iUnion [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hs : ‚àÄ n, AnalyticSet (s n)) :
    AnalyticSet (‚ãÉ n, s n) 


Original valid proof:
:= by
  choose Œ≤ hŒ≤ h'Œ≤ f f_cont f_range using fun n =>
    analyticSet_iff_exists_polishSpace_range.1 (hs n)
  let Œ≥ := Œ£n, Œ≤ n
  let F : Œ≥ ‚Üí Œ± := fun ‚ü®n, x‚ü© ‚Ü¶ f n x
  have F_cont : Continuous F := continuous_sigma f_cont
  have F_range : range F = ‚ãÉ n, s n := by
    simp only [Œ≥, range_sigma_eq_iUnion_range, f_range]
  rw [‚Üê F_range]
  exact analyticSet_range_of_polishSpace F_cont


Verifying proof (Commit 62d1e98c9775031911b945f049f84047fafbe5e1):
:= by
  choose Œ≤ hŒ≤ h'Œ≤ f f_cont f_range using fun n =>
    analyticSet_iff_exists_polishSpace_range.1 (hs n)
  let Œ≥ := Œ£n, Œ≤ n
  let F : Œ≥ ‚Üí Œ± := fun ‚ü®n, x‚ü© ‚Ü¶ f n x
  have F_cont : Continuous F := continuous_sigma f_cont
  have F_range : range F = ‚ãÉ n, s n := by
    simp only [range_sigma_eq_iUnion_range, f_range]
  rw [‚Üê F_range]
  exact analyticSet_range_of_polishSpace F_cont

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/Prod/Basic.lean - 2024-09-07 22:01:04.116215.
---56/100---
For theorem measurable_measure_prod_mk_left_finite in Mathlib/MeasureTheory/Constructions/Prod/Basic.lean:
theorem measurable_measure_prod_mk_left_finite [IsFiniteMeasure ŒΩ] {s : Set (Œ± √ó Œ≤)}
    (hs : MeasurableSet s) : Measurable fun x => ŒΩ (Prod.mk x ‚Åª¬π' s) 


Original valid proof:
:= by
  refine induction_on_inter (C := fun s => Measurable fun x => ŒΩ (Prod.mk x ‚Åª¬π' s))
    generateFrom_prod.symm isPiSystem_prod ?_ ?_ ?_ ?_ hs
  ¬∑ simp
  ¬∑ rintro _ ‚ü®s, hs, t, _, rfl‚ü©
    simp only [mk_preimage_prod_right_eq_if, measure_if]
    exact measurable_const.indicator hs
  ¬∑ intro t ht h2t
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top ŒΩ _)]
    exact h2t.const_sub _
  ¬∑ intro f h1f h2f h3f
    simp_rw [preimage_iUnion]
    have : ‚àÄ b, ŒΩ (‚ãÉ i, Prod.mk b ‚Åª¬π' f i) = ‚àë' i, ŒΩ (Prod.mk b ‚Åª¬π' f i) := fun b =>
      measure_iUnion (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i =>
        measurable_prod_mk_left (h2f i)
    simp_rw [this]
    apply Measurable.ennreal_tsum h3f


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  refine induction_on_inter (C := fun s => Measurable fun x => ŒΩ (Prod.mk x ‚Åª¬π' s))
    generateFrom_prod.symm isPiSystem_prod ?_ ?_ ?_ ?_ hs
  ¬∑ simp [measurable_zero, const_def]
  ¬∑ rintro _ ‚ü®s, hs, t, _, rfl‚ü©
    simp only [mk_preimage_prod_right_eq_if, measure_if]
    exact measurable_const.indicator hs
  ¬∑ intro t ht h2t
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top ŒΩ _)]
    exact h2t.const_sub _
  ¬∑ intro f h1f h2f h3f
    simp_rw [preimage_iUnion]
    have : ‚àÄ b, ŒΩ (‚ãÉ i, Prod.mk b ‚Åª¬π' f i) = ‚àë' i, ŒΩ (Prod.mk b ‚Åª¬π' f i) := fun b =>
      measure_iUnion (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i =>
        measurable_prod_mk_left (h2f i)
    simp_rw [this]
    apply Measurable.ennreal_tsum h3f

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Besicovitch.lean - 2024-09-07 22:01:17.348469.
---57/100---
For theorem Besicovitch.TauPackage.color_lt in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ‚Ñï}
    (hN : IsEmpty (SatelliteConfig Œ± N p.œÑ)) : p.color i < N 


Original valid proof:
:= by
  induction' i using Ordinal.induction with i IH
  let A : Set ‚Ñï :=
    ‚ãÉ (j : { j // j < i })
      (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) ‚à©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),
      {p.color j}
  have color_i : p.color i = sInf (univ \ A) := by rw [color]
  rw [color_i]
  have N_mem : N ‚àà univ \ A := by
    simp only [A, not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff,
      mem_closedBall, not_and, mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
    intro j ji _
    exact (IH j ji (ji.trans hi)).ne'
  suffices sInf (univ \ A) ‚â† N by
    rcases (csInf_le (OrderBot.bddBelow (univ \ A)) N_mem).lt_or_eq with (H | H)
    ¬∑ exact H
    ¬∑ exact (this H).elim
  intro Inf_eq_N
  have :
    ‚àÄ k, k < N ‚Üí ‚àÉ j, j < i ‚àß
      (closedBall (p.c (p.index j)) (p.r (p.index j)) ‚à©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty ‚àß k = p.color j := by
    intro k hk
    rw [‚Üê Inf_eq_N] at hk
    have : k ‚àà A := by
      simpa only [true_and_iff, mem_univ, Classical.not_not, mem_diff] using
        Nat.not_mem_of_lt_sInf hk
    simp only [mem_iUnion, mem_singleton_iff, exists_prop, Subtype.exists, exists_and_right,
      and_assoc] at this
    simpa only [A, exists_prop, mem_iUnion, mem_singleton_iff, mem_closedBall, Subtype.exists,
      Subtype.coe_mk]
  choose! g hg using this
  let G : ‚Ñï ‚Üí Ordinal := fun n => if n = N then i else g n
  have color_G : ‚àÄ n, n ‚â§ N ‚Üí p.color (G n) = n := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    ¬∑ simp only [G]; simp only [color_i, Inf_eq_N, if_true, eq_self_iff_true]
    ¬∑ simp only [G]; simp only [H.ne, (hg n H).right.right.symm, if_false]
  have G_lt_last : ‚àÄ n, n ‚â§ N ‚Üí G n < p.lastStep := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    ¬∑ simp only [G]; simp only [hi, if_true, eq_self_iff_true]
    ¬∑ simp only [G]; simp only [H.ne, (hg n H).left.trans hi, if_false]
  have fGn :
      ‚àÄ n, n ‚â§ N ‚Üí
        p.c (p.index (G n)) ‚àâ p.iUnionUpTo (G n) ‚àß p.R (G n) ‚â§ p.œÑ * p.r (p.index (G n)) := by
    intro n hn
    have :
      p.index (G n) =
        Classical.epsilon fun t => p.c t ‚àâ p.iUnionUpTo (G n) ‚àß p.R (G n) ‚â§ p.œÑ * p.r t := by
      rw [index]; rfl
    rw [this]
    have : ‚àÉ t, p.c t ‚àâ p.iUnionUpTo (G n) ‚àß p.R (G n) ‚â§ p.œÑ * p.r t := by
      simpa only [not_exists, exists_prop, not_and, not_lt, not_le, mem_setOf_eq, not_forall] using
        not_mem_of_lt_csInf (G_lt_last n hn) (OrderBot.bddBelow _)
    exact Classical.epsilon_spec this
  have Gab :
    ‚àÄ a b : Fin (Nat.succ N),
      G a < G b ‚Üí
        p.r (p.index (G a)) ‚â§ dist (p.c (p.index (G a))) (p.c (p.index (G b))) ‚àß
          p.r (p.index (G b)) ‚â§ p.œÑ * p.r (p.index (G a)) := by
    intro a b G_lt
    have ha : (a : ‚Ñï) ‚â§ N := Nat.lt_succ_iff.1 a.2
    have hb : (b : ‚Ñï) ‚â§ N := Nat.lt_succ_iff.1 b.2
    constructor
    ¬∑ have := (fGn b hb).1
      simp only [iUnionUpTo, not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
        Subtype.exists, Subtype.coe_mk] at this
      simpa only [dist_comm, mem_ball, not_lt] using this (G a) G_lt
    ¬∑ apply le_trans _ (fGn a ha).2
      have B : p.c (p.index (G b)) ‚àâ p.iUnionUpTo (G a) := by
        intro H; exact (fGn b hb).1 (p.monotone_iUnionUpTo G_lt.le H)
      let b' : { t // p.c t ‚àâ p.iUnionUpTo (G a) } := ‚ü®p.index (G b), B‚ü©
      apply @le_ciSup _ _ _ (fun t : { t // p.c t ‚àâ p.iUnionUpTo (G a) } => p.r t) _ b'
      refine ‚ü®p.r_bound, fun t ht => ?_‚ü©
      simp only [exists_prop, mem_range, Subtype.exists, Subtype.coe_mk] at ht
      rcases ht with ‚ü®u, hu‚ü©
      rw [‚Üê hu.2]
      exact p.r_le _
  let sc : SatelliteConfig Œ± N p.œÑ :=
    { c := fun k => p.c (p.index (G k))
      r := fun k => p.r (p.index (G k))
      rpos := fun k => p.rpos (p.index (G k))
      h := by
        intro a b a_ne_b
        wlog G_le : G a ‚â§ G b generalizing a b
        ¬∑ exact (this a_ne_b.symm (le_of_not_le G_le)).symm
        have G_lt : G a < G b := by
          rcases G_le.lt_or_eq with (H | H); ¬∑ exact H
          have A : (a : ‚Ñï) ‚â† b := Fin.val_injective.ne a_ne_b
          rw [‚Üê color_G a (Nat.lt_succ_iff.1 a.2), ‚Üê color_G b (Nat.lt_succ_iff.1 b.2), H] at A
          exact (A rfl).elim
        exact Or.inl (Gab a b G_lt)
      hlast := by
        intro a ha
        have I : (a : ‚Ñï) < N := ha
        have : G a < G (Fin.last N) := by dsimp; simp [G, I.ne, (hg a I).1]
        exact Gab _ _ this
      inter := by
        intro a ha
        have I : (a : ‚Ñï) < N := ha
        have J : G (Fin.last N) = i := by dsimp; simp only [G, if_true, eq_self_iff_true]
        have K : G a = g a := by dsimp [G]; simp [I.ne, (hg a I).1]
        convert dist_le_add_of_nonempty_closedBall_inter_closedBall (hg _ I).2.1 }
  exact hN.false sc


Verifying proof (Commit 151feca7cd329a83c958aa6af46cb01fabc83bf1):
:= by
  induction' i using Ordinal.induction with i IH
  let A : Set ‚Ñï :=
    ‚ãÉ (j : { j // j < i })
      (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) ‚à©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),
      {p.color j}
  have color_i : p.color i = sInf (univ \ A) := by rw [color]
  rw [color_i]
  have N_mem : N ‚àà univ \ A := by
    simp only [not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff, mem_closedBall,
      not_and, mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
    intro j ji _
    exact (IH j ji (ji.trans hi)).ne'
  suffices sInf (univ \ A) ‚â† N by
    rcases (csInf_le (OrderBot.bddBelow (univ \ A)) N_mem).lt_or_eq with (H | H)
    ¬∑ exact H
    ¬∑ exact (this H).elim
  intro Inf_eq_N
  have :
    ‚àÄ k, k < N ‚Üí ‚àÉ j, j < i ‚àß
      (closedBall (p.c (p.index j)) (p.r (p.index j)) ‚à©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty ‚àß k = p.color j := by
    intro k hk
    rw [‚Üê Inf_eq_N] at hk
    have : k ‚àà A := by
      simpa only [true_and_iff, mem_univ, Classical.not_not, mem_diff] using
        Nat.not_mem_of_lt_sInf hk
    simp only [mem_iUnion, mem_singleton_iff, mem_closedBall, Subtype.exists,
      Subtype.coe_mk]
  choose! g hg using this
  let G : ‚Ñï ‚Üí Ordinal := fun n => if n = N then i else g n
  have color_G : ‚àÄ n, n ‚â§ N ‚Üí p.color (G n) = n := by
    intro k hk
    rw [‚Üê Inf_eq_N] at hk
    have : k ‚àà A := by
      simpa only [true_and_iff, mem_univ, Classical.not_not, mem_diff] using
        Nat.not_mem_of_lt_sInf hk
    simp only [mem_iUnion, mem_singleton_iff, mem_closedBall, Subtype.exists,
      Subtype.coe_mk]
  choose! g hg using this
  let G : ‚Ñï ‚Üí Ordinal := fun n => if n = N then i else g n
  have color_G : ‚àÄ n, n ‚â§ N ‚Üí p.color (G n) = n := by
    intro k hk
    rw [‚Üê Inf_eq_N] at hk
    have : k ‚àà A := by
      simpa only [true_and_iff, mem_univ, Classical.not_not, mem_diff] using
        Nat.not_mem_of_lt_sInf hk
    simp only [mem_iUnion, mem_singleton_iff, mem_closedBall, Subtype.exists,
      Subtype.coe_mk]
  choose! g hg using this
  let G : ‚Ñï ‚Üí Ordinal := fun n => if n = N then i else g n
  have color_G : ‚àÄ n, n ‚â§ N ‚Üí p.color (G n) = n := by
    intro k hk
    rw [‚Üê Inf_eq_N] at hk
    have : k ‚àà A := by
      simpa only [true_and_iff, mem_univ, Classical.not_not, mem_diff] using
        Nat.not_mem_of_lt_sInf hk
    simp only [mem_iUnion, mem_singleton_iff, mem_closedBall, Subtype.exists,
      Subtype.coe_mk]
  choose! g hg using this
  let G : 

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Differentiation.lean - 2024-09-07 22:01:31.718527.
---58/100---
For theorem VitaliFamily.null_of_frequently_le_of_frequently_ge in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem null_of_frequently_le_of_frequently_ge {c d : ‚Ñù‚â•0} (hcd : c < d) (s : Set Œ±)
    (hc : ‚àÄ x ‚àà s, ‚àÉ·∂† a in v.filterAt x, œÅ a ‚â§ c * Œº a)
    (hd : ‚àÄ x ‚àà s, ‚àÉ·∂† a in v.filterAt x, (d : ‚Ñù‚â•0‚àû) * Œº a ‚â§ œÅ a) : Œº s = 0 


Original valid proof:
:= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ‚ü®o, xo, o_open, Œºo‚ü© : ‚àÉ o : Set Œ±, x ‚àà o ‚àß IsOpen o ‚àß Œº o < ‚àû :=
    Measure.exists_isOpen_measure_lt_top Œº x
  refine ‚ü®s ‚à© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_‚ü©
  let s' := s ‚à© o
  by_contra h
  apply lt_irrefl (œÅ s')
  calc
    œÅ s' ‚â§ c * Œº s' := v.measure_le_of_frequently_le (c ‚Ä¢ Œº) hœÅ s' fun x hx => hc x hx.1
    _ < d * Œº s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono inter_subset_right) Œºo).ne
    _ ‚â§ œÅ s' :=
      v.measure_le_of_frequently_le œÅ ((Measure.AbsolutelyContinuous.refl Œº).smul d) s' fun x hx =>
        hd x hx.1


Verifying proof (Commit 9d3887769246754772c178dd6c594378dce58448):
:= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ‚ü®o, xo, o_open, Œºo‚ü© : ‚àÉ o : Set Œ±, x ‚àà o ‚àß IsOpen o ‚àß Œº o < ‚àû :=
    Measure.exists_isOpen_measure_lt_top Œº x
  refine ‚ü®s ‚à© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_‚ü©
  let s' := s ‚à© o
  by_contra h
  apply lt_irrefl (œÅ s')
  calc
    œÅ s' ‚â§ c * Œº s' := v.measure_le_of_frequently_le (c ‚Ä¢ Œº) hœÅ s' fun x hx => hc x hx.1
    _ < d * Œº s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono inter_subset_right) Œºo).ne
    _ ‚â§ œÅ s' :=
      v.measure_le_of_frequently_le œÅ ((Measure.AbsolutelyContinuous.refl Œº).smul d) s' fun x hx =>
        hd x hx.1

Attempt success.

Working on Mathlib/MeasureTheory/Group/Prod.lean - 2024-09-07 22:01:46.977778.
---59/100---
For theorem MeasureTheory.measure_lintegral_div_measure in Mathlib/MeasureTheory/Group/Prod.lean:
theorem measure_lintegral_div_measure [IsMulLeftInvariant ŒΩ] (sm : MeasurableSet s) (h2s : ŒΩ s ‚â† 0)
    (h3s : ŒΩ s ‚â† ‚àû) (f : G ‚Üí ‚Ñù‚â•0‚àû) (hf : Measurable f) :
    (Œº s * ‚à´‚Åª y, f y‚Åª¬π / ŒΩ ((fun x => x * y‚Åª¬π) ‚Åª¬π' s) ‚àÇŒΩ) = ‚à´‚Åª x, f x ‚àÇŒº 


Original valid proof:
:= by
  set g := fun y => f y‚Åª¬π / ŒΩ ((fun x => x * y‚Åª¬π) ‚Åª¬π' s)
  have hg : Measurable g :=
    (hf.comp measurable_inv).div ((measurable_measure_mul_right ŒΩ sm).comp measurable_inv)
  simp_rw [measure_mul_lintegral_eq Œº ŒΩ sm g hg, g, inv_inv]
  refine lintegral_congr_ae ?_
  refine (ae_measure_preimage_mul_right_lt_top_of_ne_zero Œº ŒΩ sm h2s h3s).mono fun x hx => ?_
  simp_rw [ENNReal.mul_div_cancel' (measure_mul_right_ne_zero ŒΩ h2s _) hx.ne]


Verifying proof (Commit 71880da883b383ac13b9beb76b1bd41a0f023582):
:= by
  set g := fun y => f y‚Åª¬π / ŒΩ ((fun x => x * y‚Åª¬π) ‚Åª¬π' s)
  have hg : Measurable g :=
    (hf.comp measurable_inv).div ((measurable_measure_mul_right ŒΩ sm).comp measurable_inv)
  simp_rw [measure_mul_lintegral_eq Œº ŒΩ sm g hg, inv_inv]
  refine lintegral_congr_ae ?_
  refine (ae_measure_preimage_mul_right_lt_top_of_ne_zero Œº ŒΩ sm h2s h3s).mono fun x hx => ?_
  simp_rw [ENNReal.mul_div_cancel' (measure_mul_right_ne_zero ŒΩ h2s _) hx.ne]

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/CircleIntegral.lean - 2024-09-07 22:01:56.932453.
---60/100---
For theorem circleIntegrable_sub_zpow_iff in Mathlib/MeasureTheory/Integral/CircleIntegral.lean:
theorem circleIntegrable_sub_zpow_iff {c w : ‚ÑÇ} {R : ‚Ñù} {n : ‚Ñ§} :
    CircleIntegrable (fun z => (z - w) ^ n) c R ‚Üî R = 0 ‚à® 0 ‚â§ n ‚à® w ‚àâ sphere c |R| 


Original valid proof:
:= by
  constructor
  ¬∑ intro h; contrapose! h; rcases h with ‚ü®hR, hn, hw‚ü©
    simp only [circleIntegrable_iff R, deriv_circleMap]
    rw [‚Üê image_circleMap_Ioc] at hw; rcases hw with ‚ü®Œ∏, hŒ∏, rfl‚ü©
    replace hŒ∏ : Œ∏ ‚àà [[0, 2 * œÄ]] := Icc_subset_uIcc (Ioc_subset_Icc_self hŒ∏)
    refine not_intervalIntegrable_of_sub_inv_isBigO_punctured ?_ Real.two_pi_pos.ne hŒ∏
    set f : ‚Ñù ‚Üí ‚ÑÇ := fun Œ∏' => circleMap c R Œ∏' - circleMap c R Œ∏
    have : ‚àÄ·∂† Œ∏' in ùìù[‚â†] Œ∏, f Œ∏' ‚àà ball (0 : ‚ÑÇ) 1 \ {0} := by
      suffices ‚àÄ·∂† z in ùìù[‚â†] circleMap c R Œ∏, z - circleMap c R Œ∏ ‚àà ball (0 : ‚ÑÇ) 1 \ {0} from
        ((differentiable_circleMap c R Œ∏).hasDerivAt.tendsto_punctured_nhds
          (deriv_circleMap_ne_zero hR)).eventually this
      filter_upwards [self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds (ball_mem_nhds _ zero_lt_one)]
      simp_all [dist_eq, sub_eq_zero]
    refine (((hasDerivAt_circleMap c R Œ∏).isBigO_sub.mono inf_le_left).inv_rev
      (this.mono fun Œ∏' h‚ÇÅ h‚ÇÇ => absurd h‚ÇÇ h‚ÇÅ.2)).trans ?_
    refine IsBigO.of_bound |R|‚Åª¬π (this.mono fun Œ∏' hŒ∏' => ?_)
    set x := abs (f Œ∏')
    suffices x‚Åª¬π ‚â§ x ^ n by
      simpa only [inv_mul_cancel_left‚ÇÄ, abs_eq_zero.not.2 hR, norm_eq_abs, map_inv‚ÇÄ,
        Algebra.id.smul_eq_mul, map_mul, abs_circleMap_zero, abs_I, mul_one, abs_zpow, Ne,
        not_false_iff] using this
    have : x ‚àà Ioo (0 : ‚Ñù) 1 := by simpa [x, and_comm] using hŒ∏'
    rw [‚Üê zpow_neg_one]
    refine (zpow_strictAnti this.1 this.2).le_iff_le.2 (Int.lt_add_one_iff.1 ?_); exact hn
  ¬∑ rintro (rfl | H)
    exacts [circleIntegrable_zero_radius,
      ((continuousOn_id.sub continuousOn_const).zpow‚ÇÄ _ fun z hz =>
        H.symm.imp_left fun (hw : w ‚àâ sphere c |R|) =>
          sub_ne_zero.2 <| ne_of_mem_of_not_mem hz hw).circleIntegrable']


Verifying proof (Commit d16c7a879e758dc3aee434d847d69bfbaf9f30f0):
:= by
  constructor
  ¬∑ intro h; contrapose! h; rcases h with ‚ü®hR, hn, hw‚ü©
    simp only [circleIntegrable_iff R, deriv_circleMap]
    rw [‚Üê image_circleMap_Ioc] at hw; rcases hw with ‚ü®Œ∏, hŒ∏, rfl‚ü©
    replace hŒ∏ : Œ∏ ‚àà [[0, 2 * œÄ]] := Icc_subset_uIcc (Ioc_subset_Icc_self hŒ∏)
    refine not_intervalIntegrable_of_sub_inv_isBigO_punctured ?_ Real.two_pi_pos.ne hŒ∏
    set f : ‚Ñù ‚Üí ‚ÑÇ := fun Œ∏' => circleMap c R Œ∏' - circleMap c R Œ∏
    have : ‚àÄ·∂† Œ∏' in ùìù[‚â†] Œ∏, f Œ∏' ‚àà ball (0 : ‚ÑÇ) 1 \ {0} := by
      suffices ‚àÄ·∂† z in ùìù[‚â†] circleMap c R Œ∏, z - circleMap c R Œ∏ ‚àà ball (0 : ‚ÑÇ) 1 \ {0} from
        ((differentiable_circleMap c R Œ∏).hasDerivAt.tendsto_punctured_nhds
          (deriv_circleMap_ne_zero hR)).eventually this
      filter_upwards [self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds (ball_mem_nhds _ zero_lt_one)]
      simp_all [dist_eq, sub_eq_zero]
    refine (((hasDerivAt_circleMap c R Œ∏).isBigO_sub.mono inf_le_left).inv_rev
      (this.mono fun Œ∏' h‚ÇÅ h‚ÇÇ => absurd h‚ÇÇ h‚ÇÅ.2)).trans ?_
    refine IsBigO.of_bound |R|‚Åª¬π (this.mono fun Œ∏' hŒ∏' => ?_)
    set x := abs (f Œ∏')
    suffices x‚Åª¬π ‚â§ x ^ n by
      simpa only [inv_mul_cancel_left‚ÇÄ, abs_eq_zero.not.2 hR, norm_eq_abs, map_inv‚ÇÄ,
        Algebra.id.smul_eq_mul, map_mul, abs_circleMap_zero, abs_I, mul_one, abs_zpow, Ne,
        not_false_iff] using this
    have : x ‚àà Ioo (0 : ‚Ñù) 1 := by simpa [x, and_comm] using hŒ∏'
    rw [‚Üê zpow_neg_one]
    refine (zpow_strictAnti this.1 this.2).le_iff_le.2 (Int.lt_add_one_iff.1 ?_); exact hn
  ¬∑ rintro (rfl | H)
    exacts [circleIntegrable_zero_radius,
      ((continuousOn_id.sub continuousOn_const).zpow‚ÇÄ _ fun z hz =>
        H.symm.imp_left fun (hw : w ‚àâ sphere c |R|) =>
          sub_ne_zero.2 <| ne_of_mem_of_not_mem hz hw).circleIntegrable']

Attempt success.

Working on Mathlib/MeasureTheory/Measure/Haar/Basic.lean - 2024-09-07 22:02:14.878821.
---61/100---
For theorem MeasureTheory.Measure.div_mem_nhds_one_of_haar_pos in Mathlib/MeasureTheory/Measure/Haar/Basic.lean:
theorem div_mem_nhds_one_of_haar_pos (Œº : Measure G) [IsHaarMeasure Œº] [LocallyCompactSpace G]
    [InnerRegular Œº] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < Œº E) :
    E / E ‚àà ùìù (1 : G) 


Original valid proof:
:= by
  obtain ‚ü®K, hKE, hK, K_closed, hKpos‚ü© :
      ‚àÉ (K : Set G), K ‚äÜ E ‚àß IsCompact K ‚àß IsClosed K ‚àß 0 < Œº K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with ‚ü®K, KE, K_comp, K_meas‚ü©
    refine ‚ü®closure K, ?_, K_comp.closure, isClosed_closure, ?_‚ü©
    ¬∑ exact K_comp.closure_subset_measurableSet hE KE
    ¬∑ rwa [K_comp.measure_closure]
  filter_upwards [eventually_nhds_one_measure_smul_diff_lt hK K_closed hKpos.ne' (Œº := Œº)] with g hg
  have : ¬¨Disjoint (g ‚Ä¢ K) K := fun hd ‚Ü¶ by
    rw [hd.symm.sdiff_eq_right, measure_smul] at hg
    exact hg.false
  rcases Set.not_disjoint_iff.1 this with ‚ü®_, ‚ü®x, hxK, rfl‚ü©, hgxK‚ü©
  simpa using div_mem_div (hKE hgxK) (hKE hxK)


Verifying proof (Commit 488012d0f5ac537bb8055c310b3f223de3f6802e):
:= by
  obtain ‚ü®K, hKE, hK, K_closed, hKpos‚ü© :
      ‚àÉ (K : Set G), K ‚äÜ E ‚àß IsCompact K ‚àß IsClosed K ‚àß 0 < Œº K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with ‚ü®K, KE, K_comp, K_meas‚ü©
    refine ‚ü®closure K, ?_, K_comp.closure, isClosed_closure, ?_‚ü©
    ¬∑ exact IsCompact.closure_subset_of_measurableSet_of_group K_comp hE KE
    ¬∑ rwa [K_comp.measure_closure_eq_of_group]
  obtain ‚ü®V, hV1, hV‚ü© : ‚àÉ V ‚àà ùìù (1 : G), ‚àÄ g ‚àà V, Œº (g ‚Ä¢ K \ K) < Œº K :=
    exists_nhds_measure_smul_diff_lt hK K_closed hKpos.ne'
  have hv : ‚àÄ v : G, v ‚àà V ‚Üí ¬¨Disjoint (v ‚Ä¢ K) K := by
    intro v hv hKv
    have Z := hV v hv
    rw [hKv.symm.sdiff_eq_right, measure_smul] at Z
    exact lt_irrefl _ Z
  suffices V ‚äÜ E / E from Filter.mem_of_superset hV1 this
  intro v hvV
  obtain ‚ü®x, hxK, hxvK‚ü© : ‚àÉ x : G, x ‚àà v ‚Ä¢ K ‚àß x ‚àà K := Set.not_disjoint_iff.1 (hv v hvV)
  refine ‚ü®x, hKE hxvK, v‚Åª¬π * x, hKE ?_, ?_‚ü©
  ¬∑ simpa [mem_smul_set_iff_inv_smul_mem] using hxK
  ¬∑ simp only [div_eq_iff_eq_mul, ‚Üê mul_assoc, mul_right_inv, one_mul]

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Haar/OfBasis.lean - 2024-09-07 22:02:25.143570.
---62/100---
For theorem parallelepiped_single in Mathlib/MeasureTheory/Measure/Haar/OfBasis.lean:
theorem parallelepiped_single [DecidableEq Œπ] (a : Œπ ‚Üí ‚Ñù) :
    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a 


Original valid proof:
:= by
  ext x
  simp_rw [Set.uIcc, mem_parallelepiped_iff, Set.mem_Icc, Pi.le_def, ‚Üê forall_and, Pi.inf_apply,
    Pi.sup_apply, ‚Üê Pi.single_smul', Pi.one_apply, Pi.zero_apply, ‚Üê Pi.smul_apply',
    Finset.univ_sum_single (_ : Œπ ‚Üí ‚Ñù)]
  constructor
  ¬∑ rintro ‚ü®t, ht, rfl‚ü© i
    specialize ht i
    simp_rw [smul_eq_mul, Pi.mul_apply]
    rcases le_total (a i) 0 with hai | hai
    ¬∑ rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai]
      exact ‚ü®le_mul_of_le_one_left hai ht.2, mul_nonpos_of_nonneg_of_nonpos ht.1 hai‚ü©
    ¬∑ rw [sup_eq_right.mpr hai, inf_eq_left.mpr hai]
      exact ‚ü®mul_nonneg ht.1 hai, mul_le_of_le_one_left hai ht.2‚ü©
  ¬∑ intro h
    refine ‚ü®fun i => x i / a i, fun i => ?_, funext fun i => ?_‚ü©
    ¬∑ specialize h i
      rcases le_total (a i) 0 with hai | hai
      ¬∑ rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai] at h
        exact ‚ü®div_nonneg_of_nonpos h.2 hai, div_le_one_of_ge h.1 hai‚ü©
      ¬∑ rw [sup_eq_right.mpr hai, inf_eq_left.mpr hai] at h
        exact ‚ü®div_nonneg h.1 hai, div_le_one_of_le h.2 hai‚ü©
    ¬∑ specialize h i
      simp only [smul_eq_mul, Pi.mul_apply]
      rcases eq_or_ne (a i) 0 with hai | hai
      ¬∑ rw [hai, inf_idem, sup_idem, ‚Üê le_antisymm_iff] at h
        rw [hai, ‚Üê h, zero_div, zero_mul]
      ¬∑ rw [div_mul_cancel‚ÇÄ _ hai]


Verifying proof (Commit df634f2a3b3d3eef3936f220d4bcc9b21e88770c):
:= by
  ext x
  simp_rw [Set.uIcc, mem_parallelepiped_iff, Set.mem_Icc, Pi.le_def, ‚Üê forall_and, Pi.inf_apply,
    Pi.sup_apply, ‚Üê Pi.single_smul', Pi.one_apply, Pi.zero_apply, ‚Üê Pi.smul_apply',
    Finset.univ_sum_single (_ : Œπ ‚Üí ‚Ñù)]
  constructor
  ¬∑ rintro ‚ü®t, ht, rfl‚ü© i
    specialize ht i
    simp_rw [smul_eq_mul, Pi.mul_apply]
    cases' le_total (a i) 0 with hai hai
    ¬∑ rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai]
      exact ‚ü®mul_nonneg ht.1 hai, mul_le_of_le_one_left hai ht.2‚ü©
  ¬∑ intro h
    refine ‚ü®fun i => x i / a i, fun i => ?_, funext fun i => ?_‚ü©
    ¬∑ specialize h i
      cases' le_total (a i) 0 with hai hai
      ¬∑ rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai] at h
        exact ‚ü®div_nonneg h.1 hai, div_le_one_of_le h.2 hai‚ü©
    ¬∑ specialize h i
      simp only [smul_eq_mul, Pi.mul_apply]
      cases' eq_or_ne (a i) 0 with hai hai
    ¬∑ rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai] at h
        exact ‚ü®div_nonneg h.1 hai, div_le_one_of_le h.2 hai‚ü©
    ¬∑ specialize h i
      simp only [smul_eq_mul, Pi.mul_apply]
      cases' eq_or_ne (a i) 0 with hai hai
      ¬∑ rw [hai, inf_idem, sup_idem, ‚Üê le_antisymm_iff] at h
        rw [hai, ‚Üê h, zero_div, zero_mul]
      ¬∑ rw [div_mul_cancel‚ÇÄ _ hai]

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Hausdorff.lean - 2024-09-07 22:02:39.347146.
---63/100---
For theorem IsometryEquiv.hausdorffMeasure_image in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ‚Ñù} (hd : 0 ‚â§ d) :
    ŒºH[d] (f '' s) ‚â§ (C : ‚Ñù‚â•0‚àû) ^ d * ŒºH[r * d] s 


Original valid proof:
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  ¬∑ rcases eq_empty_or_nonempty s with (rfl | ‚ü®x, hx‚ü©)
    ¬∑ simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    ¬∑ simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ‚ü®x, hx‚ü©
    ¬∑ haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  ¬∑ have hCd0 : (C : ‚Ñù‚â•0‚àû) ^ d ‚â† 0 := by simp [hC0.ne']
    have hCd : (C : ‚Ñù‚â•0‚àû) ^ d ‚â† ‚àû := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      ‚Üê ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : ‚Ñù‚â•0‚àû => (C : ‚Ñù‚â•0‚àû) * d ^ (r : ‚Ñù)) (ùìù 0) (ùìù 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      ‚ü®Œ¥, Œ¥0, H‚ü©
    refine le_iSup‚ÇÇ_of_le Œ¥ Œ¥0 <| iInf‚ÇÇ_mono' fun t hst ‚Ü¶
      ‚ü®fun n => f '' (t n ‚à© s), ?_, iInf_mono' fun htŒ¥ ‚Ü¶
        ‚ü®fun n => (h.ediam_image_inter_le (t n)).trans (H (htŒ¥ n)).le, ?_‚ü©‚ü©
    ¬∑ rw [‚Üê image_iUnion, ‚Üê iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    ¬∑ refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, ‚Üê ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  ¬∑ rcases eq_empty_or_nonempty s with (rfl | ‚ü®x, hx‚ü©)
    ¬∑ simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    ¬∑ simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ‚ü®x, hx‚ü©
    ¬∑ haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  ¬∑ have hCd0 : (C : ‚Ñù‚â•0‚àû) ^ d ‚â† 0 := by simp [hC0.ne']
    have hCd : (C : ‚Ñù‚â•0‚àû) ^ d ‚â† ‚àû := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      ‚Üê ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : ‚Ñù‚â•0‚àû => (C : ‚Ñù‚â•0‚àû) * d ^ (r : ‚Ñù)) (ùìù 0) (ùìù 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      ‚ü®Œ¥, Œ¥0, H‚ü©
    refine le_iSup‚ÇÇ_of_le Œ¥ Œ¥0 <| iInf‚ÇÇ_mono' fun t hst ‚Ü¶
      ‚ü®fun n => f '' (t n ‚à© s), ?_, iInf_mono' fun htŒ¥ ‚Ü¶
        ‚ü®fun n => (h.ediam_image_inter_le (t n)).trans (H (htŒ¥ n)).le, ?_‚ü©‚ü©
    ¬∑ rw [‚Üê image_iUnion, ‚Üê iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    ¬∑ refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, nonempty_image_iff]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, ‚Üê ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd

Attempt success.

---64/100---
For theorem MeasureTheory.Measure.noAtoms_hausdorff in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem noAtoms_hausdorff {d : ‚Ñù} (hd : 0 < d) : NoAtoms (hausdorffMeasure d : Measure X) 


Original valid proof:
:= by
  refine ‚ü®fun x => ?_‚ü©
  rw [‚Üê nonpos_iff_eq_zero, hausdorffMeasure_apply]
  refine iSup‚ÇÇ_le fun Œµ _ => iInf‚ÇÇ_le_of_le (fun _ => {x}) ?_ <| iInf_le_of_le (fun _ => ?_) ?_
  ¬∑ exact subset_iUnion (fun _ => {x} : ‚Ñï ‚Üí Set X) 0
  ¬∑ simp only [EMetric.diam_singleton, zero_le]
  ¬∑ simp [hd]


Verifying proof (Commit ced4d3c0af763b9fd00166e49cf999cf46c891cc):
:= by
  refine ‚ü®fun x => ?_‚ü©
  rw [‚Üê nonpos_iff_eq_zero, hausdorffMeasure_apply]
  refine iSup‚ÇÇ_le fun Œµ _ => iInf‚ÇÇ_le_of_le (fun _ => {x}) _ <| iInf_le_of_le (fun _ => ?_) ?_
  ¬∑ exact subset_iUnion (fun _ => {x} : ‚Ñï ‚Üí Set X) 0
  ¬∑ simp only [EMetric.diam_singleton, zero_le]
  ¬∑ simp [hd]

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean - 2024-09-07 22:03:11.423641.
---65/100---
For theorem MeasureTheory.measure_inter_null_of_null_left in Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean:
theorem measure_inter_null_of_null_left {S : Set Œ±} (T : Set Œ±) (h : Œº S = 0) : Œº (S ‚à© T) = 0 


Original valid proof:
:=
  measure_mono_null inter_subset_left h


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:=
  measure_mono_null S T) h

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Portmanteau.lean - 2024-09-07 22:03:19.840638.
---66/100---
For theorem MeasureTheory.exists_null_frontier_thickening in Mathlib/MeasureTheory/Measure/Portmanteau.lean:
theorem exists_null_frontier_thickening (Œº : Measure Œ©) [SigmaFinite Œº] (s : Set Œ©) {a b : ‚Ñù}
    (hab : a < b) : ‚àÉ r ‚àà Ioo a b, Œº (frontier (Metric.thickening r s)) = 0 


Original valid proof:
:= by
  have mbles : ‚àÄ r : ‚Ñù, MeasurableSet (frontier (Metric.thickening r s)) :=
    fun r => isClosed_frontier.measurableSet
  have disjs := Metric.frontier_thickening_disjoint s
  have key := Measure.countable_meas_pos_of_disjoint_iUnion (Œº := Œº) mbles disjs
  have aux := measure_diff_null (s := Ioo a b) (Set.Countable.measure_zero key volume)
  have len_pos : 0 < ENNReal.ofReal (b - a) := by simp only [hab, ENNReal.ofReal_pos, sub_pos]
  rw [‚Üê Real.volume_Ioo, ‚Üê aux] at len_pos
  rcases nonempty_of_measure_ne_zero len_pos.ne.symm with ‚ü®r, ‚ü®r_in_Ioo, hr‚ü©‚ü©
  refine ‚ü®r, r_in_Ioo, ?_‚ü©
  simpa only [mem_setOf_eq, not_lt, le_zero_iff] using hr


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  have mbles : ‚àÄ r : ‚Ñù, MeasurableSet (frontier (Metric.thickening r s)) :=
    fun r => isClosed_frontier.measurableSet
  have disjs := Metric.frontier_thickening_disjoint s
  have key := Measure.countable_meas_pos_of_disjoint_iUnion (Œº := Œº) mbles disjs
  have aux := measure_diff_null (s‚ÇÅ := Ioo a b) (Set.Countable.measure_zero key volume)
  have len_pos : 0 < ENNReal.ofReal (b - a) := by simp only [hab, ENNReal.ofReal_pos, sub_pos]
  rw [‚Üê Real.volume_Ioo, ‚Üê aux] at len_pos
  rcases nonempty_of_measure_ne_zero len_pos.ne.symm with ‚ü®r, ‚ü®r_in_Ioo, hr‚ü©‚ü©
  refine ‚ü®r, r_in_Ioo, ?_‚ü©
  simpa only [mem_setOf_eq, not_lt, le_zero_iff] using hr

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Typeclasses.lean - 2024-09-07 22:03:29.566776.
---67/100---
For theorem MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ in Mathlib/MeasureTheory/Measure/Typeclasses.lean:
theorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top‚ÇÄ {Œπ : Type*} {_ : MeasurableSpace Œ±}
    (Œº : Measure Œ±) {As : Œπ ‚Üí Set Œ±} (As_mble : ‚àÄ i : Œπ, NullMeasurableSet (As i) Œº)
    (As_disj : Pairwise (AEDisjoint Œº on As)) (Union_As_finite : Œº (‚ãÉ i, As i) ‚â† ‚àû) :
    Set.Countable { i : Œπ | 0 < Œº (As i) } 


Original valid proof:
:= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only [fairmeas]
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable ?_
  exact finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite


Verifying proof (Commit 7dbc4ee943ff99bb5a359e820806969fa45b18b0):
:= by
  set posmeas := { i : Œπ | 0 < Œº (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ‚Ñù‚â•0‚àû) < 1) with
    ‚ü®as, _, as_mem, as_lim‚ü©
  set fairmeas := fun n : ‚Ñï => { i : Œπ | as n ‚â§ Œº (As i) }
  have countable_union : posmeas = ‚ãÉ n, fairmeas n := by
    have fairmeas_eq : ‚àÄ n, fairmeas n = (fun i => Œº (As i)) ‚Åª¬π' Ici (as n) := fun n => by
      simp only []
      rfl
    simpa only [fairmeas_eq, posmeas_def, ‚Üê preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ‚Ñù‚â•0‚àû) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable ?_
  refine finite_const_le_meas_of_disjoint_iUnion‚ÇÄ Œº (as_mem n).1 As_mble As_disj Union_As_finite

Attempt failure.

Working on Mathlib/ModelTheory/Satisfiability.lean - 2024-09-07 22:03:41.268956.
---68/100---
For theorem FirstOrder.Language.Theory.models_iff_not_satisfiable in Mathlib/ModelTheory/Satisfiability.lean:
theorem models_iff_not_satisfiable (œÜ : L.Sentence) : T ‚ä®·µá œÜ ‚Üî ¬¨IsSatisfiable (T ‚à™ {œÜ.not}) 


Original valid proof:
:= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    ‚ü®fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T ‚à™ {Formula.not œÜ})
          (Set.subset_union_right (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel Set.subset_union_left)),
      fun h M => ?_‚ü©
  contrapose! h
  rw [‚Üê Sentence.realize_not] at h
  refine
    ‚ü®{  Carrier := M
        is_model := ‚ü®fun œà hœà => hœà.elim (realize_sentence_of_mem _) fun h' => ?_‚ü© }‚ü©
  rw [Set.mem_singleton_iff.1 h']
  exact h


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    ‚ü®fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T ‚à™ {Formula.not œÜ})
          (Set.subset_union_right Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel Set.subset_union_left)),
      fun h M => ?_‚ü©
  contrapose! h
  rw [‚Üê Sentence.realize_not] at h
  refine
    ‚ü®{  Carrier := M
        is_model := ‚ü®fun œà hœà => hœà.elim (realize_sentence_of_mem _) fun h' => ?_‚ü© }‚ü©
  rw [Set.mem_singleton_iff.1 h']
  exact h

Attempt failure.

Working on Mathlib/NumberTheory/Bertrand.lean - 2024-09-07 22:03:52.259948.
---69/100---
For theorem Nat.exists_prime_lt_and_le_two_mul_succ in Mathlib/NumberTheory/Bertrand.lean:
theorem exists_prime_lt_and_le_two_mul_succ {n} (q) {p : ‚Ñï} (prime_p : Nat.Prime p)
    (covering : p ‚â§ 2 * q) (H : n < q ‚Üí ‚àÉ p : ‚Ñï, p.Prime ‚àß n < p ‚àß p ‚â§ 2 * n) (hn : n < p) :
    ‚àÉ p : ‚Ñï, p.Prime ‚àß n < p ‚àß p ‚â§ 2 * n 


Original valid proof:
:= by
  by_cases h : p ‚â§ 2 * n; ¬∑ exact ‚ü®p, prime_p, hn, h‚ü©
  exact H (lt_of_mul_lt_mul_left' (lt_of_lt_of_le (not_le.1 h) covering))


Verifying proof (Commit 693fd79515903b10b1d31f10dccfc49e633cf7ee):
:= by
  by_cases p ‚â§ 2 * n; ¬∑ exact ‚ü®p, prime_p, hn, h‚ü©
  exact H (lt_of_mul_lt_mul_left' (lt_of_lt_of_le (not_le.1 h) covering))

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean - 2024-09-07 22:04:01.895670.
---70/100---
For theorem Polynomial.exists_partition_polynomial_aux in Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean:
theorem exists_partition_polynomial_aux (n : ‚Ñï) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {b : Fq[X]} (hb : b ‚â† 0)
    (A : Fin n ‚Üí Fq[X]) : ‚àÉ t : Fin n ‚Üí Fin (Fintype.card Fq ^ ‚åà-log Œµ / log (Fintype.card Fq)‚åâ‚Çä),
      ‚àÄ i‚ÇÄ i‚ÇÅ : Fin n, t i‚ÇÄ = t i‚ÇÅ ‚Üî
        (cardPowDegree (A i‚ÇÅ % b - A i‚ÇÄ % b) : ‚Ñù) < cardPowDegree b ‚Ä¢ Œµ 


Original valid proof:
:= by
  have hbŒµ : 0 < cardPowDegree b ‚Ä¢ Œµ := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hŒµ
  induction' n with n ih
  ¬∑ refine ‚ü®finZeroElim, finZeroElim‚ü©
  have anti_archim' : ‚àÄ {i j k} {Œµ : ‚Ñù},
    (cardPowDegree (A i % b - A j % b) : ‚Ñù) < Œµ ‚Üí
      (cardPowDegree (A j % b - A k % b) : ‚Ñù) < Œµ ‚Üí
        (cardPowDegree (A i % b - A k % b) : ‚Ñù) < Œµ := by
    intro i j k Œµ
    simp_rw [‚Üê Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain ‚ü®t', ht'‚ü© := ih (Fin.tail A)
  rsuffices ‚ü®j, hj‚ü© :
    ‚àÉ j, ‚àÄ i, t' i = j ‚Üî (cardPowDegree (A 0 % b - A i.succ % b) : ‚Ñù) < cardPowDegree b ‚Ä¢ Œµ
  ¬∑ refine ‚ü®Fin.cons j t', fun i‚ÇÄ i‚ÇÅ => ?_‚ü©
    refine Fin.cases ?_ (fun i‚ÇÄ => ?_) i‚ÇÄ <;> refine Fin.cases ?_ (fun i‚ÇÅ => ?_) i‚ÇÅ
    ¬∑ simpa using hbŒµ
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj i‚ÇÅ
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero]
      exact hj i‚ÇÄ
    ¬∑ rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' i‚ÇÄ i‚ÇÅ
  obtain ‚ü®j, hj‚ü© : ‚àÉ j, ‚àÄ i : Fin n,
      t' i = j ‚Üí (cardPowDegree (A 0 % b - A i.succ % b) : ‚Ñù) < cardPowDegree b ‚Ä¢ Œµ := by
    by_contra! hg
    obtain ‚ü®j‚ÇÄ, j‚ÇÅ, j_ne, approx‚ü© := exists_approx_polynomial hb hŒµ
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine Fin.cases ?_ (fun j‚ÇÄ => ?_) j‚ÇÄ <;>
      refine Fin.cases (fun j_ne approx => ?_) (fun j‚ÇÅ j_ne approx => ?_) j‚ÇÅ
    ¬∑ exact absurd rfl j_ne
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, ‚Üê not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg j‚ÇÅ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, ‚Üê not_le] at approx
      have := (Classical.choose_spec (hg j‚ÇÄ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : j‚ÇÄ = j‚ÇÅ := (Classical.choose_spec (hg j‚ÇÄ)).1.symm.trans
        (((ht' (Classical.choose (hg j‚ÇÄ)) (Classical.choose (hg j‚ÇÅ))).mpr approx).trans
          (Classical.choose_spec (hg j‚ÇÅ)).1)
      contradiction
  by_cases exists_nonempty_j : ‚àÉ j, (‚àÉ i, t' i = j) ‚àß
      ‚àÄ i, t' i = j ‚Üí (cardPowDegree (A 0 % b - A i.succ % b) : ‚Ñù) < cardPowDegree b ‚Ä¢ Œµ
  ¬∑ obtain ‚ü®j, ‚ü®i, hi‚ü©, hj‚ü© := exists_nonempty_j
    refine ‚ü®j, fun i' => ‚ü®hj i', fun hi' => _root_.trans ((ht' _ _).mpr ?_) hi‚ü©‚ü©
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine ‚ü®j, fun i => ‚ü®hj i, fun hi => ?_‚ü©‚ü©
  have := exists_nonempty_j ‚ü®t' i, ‚ü®i, rfl‚ü©, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')‚ü©
  contradiction


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
:= by
  have hbŒµ : 0 < cardPowDegree b ‚Ä¢ Œµ := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hŒµ
  induction' n with n ih
  ¬∑ refine ‚ü®finZeroElim, finZeroElim‚ü©
  have anti_archim' : ‚àÄ {i j k} {Œµ : ‚Ñù},
    (cardPowDegree (A i % b - A j % b) : ‚Ñù) < Œµ ‚Üí
        (cardPowDegree (A i % b - A k % b) : ‚Ñù) < Œµ ‚Üí
        (cardPowDegree (A i % b - A k % b) : ‚Ñù) < Œµ := by
    intro i j k Œµ
    simp_rw [‚Üê Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain ‚ü®t', ht'‚ü© := ih (Fin.tail A)
  rsuffices ‚ü®j, hj‚ü© :
    ‚àÉ j, ‚àÄ i, t' i = j ‚Üî (cardPowDegree (A 0 % b - A i.succ % b) : ‚Ñù) < cardPowDegree b ‚Ä¢ Œµ
  ¬∑ refine ‚ü®Fin.cons j t', fun i‚ÇÄ i‚ÇÅ => ?_‚ü©
    refine Fin.cases ?_ (fun i‚ÇÅ => ?_) i‚ÇÅ
    ¬∑ simpa using hbŒµ
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj i‚ÇÅ
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero]
      exact hj i‚ÇÄ
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj i‚ÇÅ
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero]
      exact hj i‚ÇÄ
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj i‚ÇÅ
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero]
      exact hj i‚ÇÄ
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, ‚Üê not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg j‚ÇÄ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, ‚Üê not_le] at approx
      have := (Classical.choose_spec (hg j‚ÇÄ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, ‚Üê not_le] at approx
      have := (Classical.choose_spec (hg j‚ÇÄ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, ‚Üê not_le] at approx
      have := (Classical.choose_spec (hg j‚ÇÄ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, ‚Üê not_le] at approx
      have := (Classical.choose_spec (hg j‚ÇÄ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, ‚Üê not_le] at approx
      have := (Classical.choose_spec (hg j‚ÇÄ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_zero, ‚Üê not_le] at approx
      have := (Classical.choose_spec (hg j‚ÇÄ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : j‚ÇÄ = j‚ÇÅ := (Classical.choose_spec (hg j‚ÇÄ)).2
      contradiction
    ¬∑ rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : j‚ÇÄ = j‚ÇÅ := (Classical.choose_spec (hg j

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/Discriminant.lean - 2024-09-07 22:04:13.064632.
---71/100---
For theorem IsCyclotomicExtension.discr_prime_pow in Mathlib/NumberTheory/Cyclotomic/Discriminant.lean:
theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) 


Original valid proof:
:= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this


Verifying proof (Commit 8802cc5585f54b80097a016895ed9e54bf69d452):
:= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
         ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2
      ¬∑ rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, deriv

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/Rat.lean - 2024-09-07 22:04:50.342122.
---72/100---
For theorem IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime in Mathlib/NumberTheory/Cyclotomic/Rat.lean:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ‚Ñ§ ‚Ñö) ‚Ñ§ (CyclotomicField (p ^ k) ‚Ñö) 


Original valid proof:
:= by
  have hŒ∂ := zeta_spec (p ^ k) ‚Ñö (CyclotomicField (p ^ k) ‚Ñö)
  refine ‚ü®IsFractionRing.injective _ _, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  ¬∑ have := isIntegralClosure_adjoin_singleton_of_prime_pow hŒ∂
    obtain ‚ü®y, rfl‚ü© := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hŒ∂.pow_eq_one
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} ‚Ñ§ _).isIntegral _)


Verifying proof (Commit 954582f0c09c6f4ec138a9365f445da0d3a83bfd):
:= by
  haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
  have hŒ∂ := zeta_spec (p ^ k) ‚Ñö (CyclotomicField (p ^ k) ‚Ñö)
  refine ‚ü®IsFractionRing.injective _ _, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  ¬∑ have := (isIntegralClosure_adjoin_singleton_of_prime_pow hŒ∂)
    obtain ‚ü®y, rfl‚ü© := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hŒ∂.pow_eq_one
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} ‚Ñ§ _) _)

Attempt failure.

---73/100---
For theorem IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime in Mathlib/NumberTheory/Cyclotomic/Rat.lean:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ‚Ñ§ ‚Ñö) ‚Ñ§ (CyclotomicField (p ^ k) ‚Ñö) 


Original valid proof:
:= by
  have hŒ∂ := zeta_spec (p ^ k) ‚Ñö (CyclotomicField (p ^ k) ‚Ñö)
  refine ‚ü®IsFractionRing.injective _ _, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  ¬∑ have := isIntegralClosure_adjoin_singleton_of_prime_pow hŒ∂
    obtain ‚ü®y, rfl‚ü© := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hŒ∂.pow_eq_one
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} ‚Ñ§ _).isIntegral _)


Verifying proof (Commit 6be2bec13d4dd1fd901f9a619d053d7549cfe177):
:= by
  haveI : CharZero ‚Ñö := StrictOrderedSemiring.to_charZero
  have hŒ∂ := zeta_spec (p ^ k) ‚Ñö (CyclotomicField (p ^ k) ‚Ñö)
  refine ‚ü®IsFractionRing.injective _ _, @fun x => ‚ü®fun h => ‚ü®‚ü®x, ?_‚ü©, rfl‚ü©, ?_‚ü©‚ü©
  ¬∑ have := isIntegralClosure_adjoin_singleton_of_prime_pow hŒ∂
    obtain ‚ü®y, rfl‚ü© := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hŒ∂.pow_eq_one
  ¬∑ rintro ‚ü®y, rfl‚ü©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} ‚Ñ§ _) _)

Attempt failure.

Working on Mathlib/NumberTheory/Padics/PadicVal.lean - 2024-09-07 22:05:41.532450.
---74/100---
For theorem padicValNat.padicValNat_eq_maxPowDiv in Mathlib/NumberTheory/Padics/PadicVal.lean:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 


Original valid proof:
:= by
  ext p n
  by_cases h : 1 < p ‚àß 0 < n
  ¬∑ dsimp [padicValNat]
    rw [dif_pos ‚ü®Nat.ne_of_gt h.1,h.2‚ü©, maxPowDiv_eq_multiplicity_get h.1 h.2]
  ¬∑ simp only [not_and_or,not_gt_eq,Nat.le_zero] at h
    apply h.elim
    ¬∑ intro h
      interval_cases p
      ¬∑ simp [Classical.em]
      ¬∑ dsimp [padicValNat, maxPowDiv]
        rw [go, if_neg]; simp
    ¬∑ intro h
      simp [h]


Verifying proof (Commit d16c7a879e758dc3aee434d847d69bfbaf9f30f0):
:= by
  ext p n
  by_cases h : 1 < p ‚àß 0 < n
  ¬∑ dsimp [padicValNat]
    rw [dif_pos ‚ü®Nat.ne_of_gt h.1,h.2‚ü©, maxPowDiv_eq_multiplicity_get h.1 h.2]
  ¬∑ simp only [not_and_or,not_gt_eq, le_zero_iff] at h
    apply h.elim
    ¬∑ intro h
      interval_cases p
      ¬∑ simp [Classical.em]
      ¬∑ dsimp [padicValNat, maxPowDiv]
        rw [go_eq, if_neg, dif_neg] <;> simp
    ¬∑ intro h
      simp [h]

Attempt failure.

Working on Mathlib/NumberTheory/Pell.lean - 2024-09-07 22:05:48.578695.
---75/100---
For theorem Pell.exists_of_not_isSquare in Mathlib/NumberTheory/Pell.lean:
theorem exists_of_not_isSquare (h‚ÇÄ : 0 < d) (hd : ¬¨IsSquare d) :
    ‚àÉ x y : ‚Ñ§, x ^ 2 - d * y ^ 2 = 1 ‚àß y ‚â† 0 


Original valid proof:
:= by
  let Œæ : ‚Ñù := ‚àöd
  have hŒæ : Irrational Œæ := by
    refine irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr h‚ÇÄ.le) ?_ two_pos
    rintro ‚ü®x, hx‚ü©
    refine hd ‚ü®x, @Int.cast_injective ‚Ñù _ _ d (x * x) ?_‚ü©
    rw [‚Üê sq_sqrt <| Int.cast_nonneg.mpr h‚ÇÄ.le, Int.cast_mul, ‚Üê hx, sq]
  obtain ‚ü®M, hM‚ÇÅ‚ü© := exists_int_gt (2 * |Œæ| + 1)
  have hM : {q : ‚Ñö | |q.1 ^ 2 - d * (q.2 : ‚Ñ§) ^ 2| < M}.Infinite := by
    refine Infinite.mono (fun q h => ?_) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hŒæ)
    have h0 : 0 < (q.2 : ‚Ñù) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2
    have h1 : (q.num : ‚Ñù) / (q.den : ‚Ñù) = q := mod_cast q.num_div_den
    rw [mem_setOf, abs_sub_comm, ‚Üê @Int.cast_lt ‚Ñù, ‚Üê div_lt_div_right (abs_pos_of_pos h0)]
    push_cast
    rw [‚Üê abs_div, abs_sq, sub_div, mul_div_cancel_right‚ÇÄ _ h0.ne', ‚Üê div_pow, h1, ‚Üê
      sq_sqrt (Int.cast_pos.mpr h‚ÇÄ).le, sq_sub_sq, abs_mul, ‚Üê mul_one_div]
    refine mul_lt_mul'' (((abs_add Œæ q).trans ?_).trans_lt hM‚ÇÅ) h (abs_nonneg _) (abs_nonneg _)
    rw [two_mul, add_assoc, add_le_add_iff_left, ‚Üê sub_le_iff_le_add']
    rw [mem_setOf, abs_sub_comm] at h
    refine (abs_sub_abs_le_abs_sub (q : ‚Ñù) Œæ).trans (h.le.trans ?_)
    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]
    exact q.pos
  obtain ‚ü®m, hm‚ü© : ‚àÉ m : ‚Ñ§, {q : ‚Ñö | q.1 ^ 2 - d * (q.den : ‚Ñ§) ^ 2 = m}.Infinite := by
    contrapose! hM
    simp only [not_infinite] at hM ‚ä¢
    refine (congr_arg _ (ext fun x => ?_)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)
    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']
  have hm‚ÇÄ : m ‚â† 0 := by
    rintro rfl
    obtain ‚ü®q, hq‚ü© := hm.nonempty
    rw [mem_setOf, sub_eq_zero, mul_comm] at hq
    obtain ‚ü®a, ha‚ü© := (Int.pow_dvd_pow_iff two_ne_zero).mp ‚ü®d, hq‚ü©
    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.natCast_pos.mpr q.pos) 2).ne'] at hq
    exact hd ‚ü®a, sq a ‚ñ∏ hq.symm‚ü©
  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hm‚ÇÄ)
  let f : ‚Ñö ‚Üí ZMod m.natAbs √ó ZMod m.natAbs := fun q => (q.num, q.den)
  obtain ‚ü®q‚ÇÅ, h‚ÇÅ : q‚ÇÅ.num ^ 2 - d * (q‚ÇÅ.den : ‚Ñ§) ^ 2 = m,
      q‚ÇÇ, h‚ÇÇ : q‚ÇÇ.num ^ 2 - d * (q‚ÇÇ.den : ‚Ñ§) ^ 2 = m, hne, hqf‚ü© :=
    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ
  obtain ‚ü®hq1 : (q‚ÇÅ.num : ZMod m.natAbs) = q‚ÇÇ.num, hq2 : (q‚ÇÅ.den : ZMod m.natAbs) = q‚ÇÇ.den‚ü© :=
    Prod.ext_iff.mp hqf
  have hd‚ÇÅ : m ‚à£ q‚ÇÅ.num * q‚ÇÇ.num - d * (q‚ÇÅ.den * q‚ÇÇ.den) := by
    rw [‚Üê Int.natAbs_dvd, ‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd]
    push_cast
    rw [hq1, hq2, ‚Üê sq, ‚Üê sq]
    norm_cast
    rw [ZMod.intCast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, ‚Üê h‚ÇÇ]
  have hd‚ÇÇ : m ‚à£ q‚ÇÅ.num * q‚ÇÇ.den - q‚ÇÇ.num * q‚ÇÅ.den := by
    rw [‚Üê Int.natAbs_dvd, ‚Üê ZMod.intCast_eq_intCast_iff_dvd_sub]
    push_cast
    rw [hq1, hq2]
  replace hm‚ÇÄ : (m : ‚Ñö) ‚â† 0 := Int.cast_ne_zero.mpr hm‚ÇÄ
  refine ‚ü®(q‚ÇÅ.num * q‚ÇÇ.num - d * (q‚ÇÅ.den * q‚ÇÇ.den)) / m, (q‚ÇÅ.num * q‚ÇÇ.den - q‚ÇÇ.num * q‚ÇÅ.den) / m,
      ?_, ?_‚ü©
  ¬∑ qify [hd‚ÇÅ, hd‚ÇÇ]
    field_simp [hm‚ÇÄ]
    norm_cast
    conv_rhs =>
      rw [sq]
      congr
      ¬∑ rw [‚Üê h‚ÇÅ]
      ¬∑ rw [‚Üê h‚ÇÇ]
    push_cast
    ring
  ¬∑ qify [hd‚ÇÇ]
    refine div_ne_zero_iff.mpr ‚ü®?_, hm‚ÇÄ‚ü©
    exact mod_cast mt sub_eq_zero.mp (mt Rat.eq_iff_mul_eq_mul.mpr hne)


Verifying proof (Commit 0f24aee7da46f85fee5cacc716172444ce31e582):
:= by
  let Œæ : ‚Ñù := sqrt d
  have hŒæ : Irrational Œæ := by
    refine irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr h‚ÇÄ.le) ?_ two_pos
    rintro ‚ü®x, hx‚ü©
    refine hd ‚ü®x, @Int.cast_injective ‚Ñù _ _ d (x * x) ?_‚ü©
    rw [‚Üê sq_sqrt <| Int.cast_nonneg.mpr h‚ÇÄ.le, Int.cast_mul, ‚Üê hx, sq]
  obtain ‚ü®M, hM‚ÇÅ‚ü© := exists_int_gt (2 * |Œæ| + 1)
  have hM : {q : ‚Ñö | |q.1 ^ 2 - d * (q.2 : ‚Ñ§) ^ 2| < M}.Infinite := by
    refine Infinite.mono (fun q h => ?_) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hŒæ)
    have h0 : 0 < (q.2 : ‚Ñù) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2
    have h1 : (q.num : ‚Ñù) / (q.den : ‚Ñù) = q := mod_cast q.num_div_den
    rw [mem_setOf, abs_sub_comm, ‚Üê @Int.cast_lt ‚Ñù, ‚Üê div_lt_div_right (abs_pos_of_pos h0)]
    push_cast
    rw [‚Üê abs_div, abs_sq, sub_div, mul_div_cancel _ h0.ne', ‚Üê div_pow, h1, ‚Üê
      sq_sqrt (Int.cast_pos.mpr h‚ÇÄ).le, sq_sub_sq, abs_mul, ‚Üê mul_one_div]
    refine mul_lt_mul'' (((abs_add Œæ q).trans ?_).trans_lt hM‚ÇÅ) h (abs_nonneg _) (abs_nonneg _)
    rw [two_mul, add_assoc, add_le_add_iff_left, ‚Üê sub_le_iff_le_add']
    rw [mem_setOf, abs_sub_comm] at h
    refine (abs_sub_abs_le_abs_sub (q : ‚Ñù) Œæ).trans (h.le.trans ?_)
    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]
    exact q.pos
  obtain ‚ü®m, hm‚ü© : ‚àÉ m : ‚Ñ§, {q : ‚Ñö | q.1 ^ 2 - d * (q.den : ‚Ñ§) ^ 2 = m}.Infinite := by
    contrapose! hM
    simp only [not_infinite] at hM ‚ä¢
    refine (congr_arg _ (ext fun x => ?_)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)
    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']
  have hm‚ÇÄ : m ‚â† 0 := by
    rintro rfl
    obtain ‚ü®q, hq‚ü© := hm.nonempty
    rw [mem_setOf, sub_eq_zero, mul_comm] at hq
    obtain ‚ü®a, ha‚ü© := (Int.pow_dvd_pow_iff two_pos).mp ‚ü®d, hq‚ü©
    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.coe_natCast q.pos) 2).ne'] at hq
    exact hd ‚ü®a, sq a ‚ñ∏ hq.symm‚ü©
  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hm‚ÇÄ)
  let f : ‚Ñö ‚Üí ZMod m.natAbs √ó ZMod m.natAbs := fun q => (q.num, q.den)
  obtain ‚ü®q‚ÇÅ, h‚ÇÅ : q‚ÇÅ.num ^ 2 - d * (q‚ÇÅ.den : ‚Ñ§) ^ 2 = m,
      q‚ÇÇ, h‚ÇÇ : q‚ÇÇ.num ^ 2 - d * (q‚ÇÇ.den : ‚Ñ§) ^ 2 = m, hne, hqf‚ü© :=
    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ
  obtain ‚ü®hq1 : (q‚ÇÅ.num : ZMod m.natAbs) = q‚ÇÇ.num, hq2 : (q‚ÇÅ.den : ZMod m.natAbs) = q‚ÇÇ.num, hq2 : (q‚ÇÅ.den : ZMod m.natAbs) = q‚ÇÇ.num, hq2 : (q‚ÇÅ.den : ZMod m.natAbs) = q‚ÇÇ.num, hq2 

Attempt failure.

Working on Mathlib/Order/Bounds/Basic.lean - 2024-09-07 22:06:05.808518.
---76/100---
For theorem union_upperBounds_subset_upperBounds_inter in Mathlib/Order/Bounds/Basic.lean:
theorem union_upperBounds_subset_upperBounds_inter :
    upperBounds s ‚à™ upperBounds t ‚äÜ upperBounds (s ‚à© t) 


Original valid proof:
:=
  union_subset (upperBounds_mono_set inter_subset_left)
    (upperBounds_mono_set inter_subset_right)


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
:=
  union_subset inter_subset_left
    (upperBounds_mono_set inter_subset_right

Attempt failure.

Working on Mathlib/Order/Interval/Finset/Fin.lean - 2024-09-07 22:06:11.589349.
---77/100---
For theorem Fin.map_valEmbedding_Ici in Mathlib/Order/Interval/Finset/Fin.lean:
theorem map_valEmbedding_Ici : (Ici a).map Fin.valEmbedding = Icc ‚Üëa (n - 1) 


Original valid proof:
:= by
  clear b
  ext x
  simp only [exists_prop, Embedding.coe_subtype, mem_Ici, mem_map, mem_Icc]
  constructor
  ¬∑ rintro ‚ü®x, hx, rfl‚ü©
    exact ‚ü®hx, Nat.le_sub_of_add_le <| x.2‚ü©
  cases n
  ¬∑ exact Fin.elim0 a
  ¬∑ exact fun hx => ‚ü®‚ü®x, Nat.lt_succ_iff.2 hx.2‚ü©, hx.1, rfl‚ü©


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  clear b
  ext x
  simp only [exists_prop, Embedding.coe_subtype, mem_Ici, mem_map, mem_Icc]
  constructor
  ¬∑ rintro ‚ü®x, hx, rfl‚ü©
    exact ‚ü®hx, le_tsub_of_add_le_right <| x.2‚ü©
  cases n
  ¬∑ exact Fin.elim0 a
  ¬∑ exact fun hx => ‚ü®‚ü®x, Nat.lt_succ_iff.2 hx.2‚ü©, hx.1, rfl‚ü©

Attempt failure.

Working on Mathlib/Order/WellFoundedSet.lean - 2024-09-07 22:06:16.532726.
---78/100---
For theorem Set.PartiallyWellOrderedOn.partiallyWellOrderedOn_sublistForall‚ÇÇ in Mathlib/Order/WellFoundedSet.lean:
theorem partiallyWellOrderedOn_sublistForall‚ÇÇ (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsRefl Œ± r] [IsTrans Œ± r]
    {s : Set Œ±} (h : s.PartiallyWellOrderedOn r) :
    { l : List Œ± | ‚àÄ x, x ‚àà l ‚Üí x ‚àà s }.PartiallyWellOrderedOn (List.SublistForall‚ÇÇ r) 


Original valid proof:
:= by
  rcases isEmpty_or_nonempty Œ±
  ¬∑ exact subsingleton_of_subsingleton.partiallyWellOrderedOn
  inhabit Œ±
  rw [iff_not_exists_isMinBadSeq List.length]
  rintro ‚ü®f, hf1, hf2‚ü©
  have hnil : ‚àÄ n, f n ‚â† List.nil := fun n con =>
    hf1.2 n n.succ n.lt_succ_self (con.symm ‚ñ∏ List.SublistForall‚ÇÇ.nil)
  have : ‚àÄ n, (f n).headI ‚àà s :=
    fun n => hf1.1 n _ (List.head!_mem_self (hnil n))
  obtain ‚ü®g, hg‚ü© := h.exists_monotone_subseq (fun n => (f n).headI) this
  have hf' :=
    hf2 (g 0) (fun n => if n < g 0 then f n else List.tail (f (g (n - g 0))))
      (fun m hm => (if_pos hm).symm) ?_
  swap;
  ¬∑ simp only [if_neg (lt_irrefl (g 0)), Nat.sub_self]
    rw [List.length_tail, ‚Üê Nat.pred_eq_sub_one]
    exact Nat.pred_lt fun con => hnil _ (List.length_eq_zero.1 con)
  rw [IsBadSeq] at hf'
  push_neg at hf'
  obtain ‚ü®m, n, mn, hmn‚ü© := hf' fun n x hx => by
    split_ifs at hx with hn
    exacts [hf1.1 _ _ hx, hf1.1 _ _ (List.tail_subset _ hx)]
  by_cases hn : n < g 0
  ¬∑ apply hf1.2 m n mn
    rwa [if_pos hn, if_pos (mn.trans hn)] at hmn
  ¬∑ obtain ‚ü®n', rfl‚ü© := Nat.exists_eq_add_of_le (not_lt.1 hn)
    rw [if_neg hn, add_comm (g 0) n', Nat.add_sub_cancel_right] at hmn
    split_ifs at hmn with hm
    ¬∑ apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))
      exact _root_.trans hmn (List.tail_sublistForall‚ÇÇ_self _)
    ¬∑ rw [‚Üê Nat.sub_lt_iff_lt_add (le_of_not_lt hm)] at mn
      apply hf1.2 _ _ (g.lt_iff_lt.2 mn)
      rw [‚Üê List.cons_head!_tail (hnil (g (m - g 0))), ‚Üê List.cons_head!_tail (hnil (g n'))]
      exact List.SublistForall‚ÇÇ.cons (hg _ _ (le_of_lt mn)) hmn


Verifying proof (Commit b502dbb455f708f5af5e6017e88f53565165ab0a):
:= by
  rcases isEmpty_or_nonempty Œ±
  ¬∑ exact subsingleton_of_subsingleton.partiallyWellOrderedOn
  inhabit Œ±
  rw [iff_not_exists_isMinBadSeq List.length]
  rintro ‚ü®f, hf1, hf2‚ü©
  have hnil : ‚àÄ n, f n ‚â† List.nil := fun n con =>
    hf1.2 n n.succ n.lt_succ_self (con.symm ‚ñ∏ List.SublistForall‚ÇÇ.nil)
  have : ‚àÄ n, (f n).headI ‚àà s :=
    fun n => hf1.1 n _ (List.head!_mem_self (hnil n))
  obtain ‚ü®g, hg‚ü© := h.exists_monotone_subseq (fun n => (f n).headI) this
  have hf' :=
    hf2 (g 0) (fun n => if n < g 0 then f n else List.tail (f (g (n - g 0))))
      (fun m hm => (if_pos hm).symm) ?_
  swap;
  ¬∑ simp only [if_neg (lt_irrefl (g 0)), tsub_self]
    rw [List.length_tail, ‚Üê Nat.pred_eq_sub_one]
    exact Nat.pred_lt fun con => hnil _ (List.length_eq_zero.1 con)
  rw [IsBadSeq] at hf'
  push_neg at hf'
  obtain ‚ü®m, n, mn, hmn‚ü© := hf' fun n x hx => by
    split_ifs at hx with hn
    exacts [hf1.1 _ _ hx, hf1.1 _ _ (List.tail_subset _ hx)]
  by_cases hn : n < g 0
  ¬∑ apply hf1.2 m n mn
    rwa [if_pos hn, if_pos (mn.trans hn)] at hmn
  ¬∑ obtain ‚ü®n', rfl‚ü© := exists_add_of_le (not_lt.1 hn)
    rw [if_neg hn, add_comm (g 0) n', add_tsub_cancel_right] at hmn
    split_ifs at hmn with hm
    ¬∑ apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))
      exact _root_.trans hmn (List.tail_sublistForall‚ÇÇ_self _)
    ¬∑ rw [‚Üê tsub_lt_iff_left (le_of_not_lt hm)] at mn
      apply hf1.2 _ _ (g.lt_iff_lt.2 mn)
      rw [‚Üê List.cons_head!_tail (hnil (g (m - g 0))), ‚Üê List.cons_head!_tail (hnil (g n'))]
      exact List.SublistForall‚ÇÇ.cons (hg _ _ (le_of_lt mn)) hmn

Attempt failure.

Working on Mathlib/Probability/Martingale/Convergence.lean - 2024-09-07 22:06:23.259521.
---79/100---
For theorem MeasureTheory.Submartingale.upcrossings_ae_lt_top in Mathlib/Probability/Martingale/Convergence.lean:
theorem Submartingale.upcrossings_ae_lt_top' [IsFiniteMeasure Œº] (hf : Submartingale f ‚Ñ± Œº)
    (hbdd : ‚àÄ n, snorm (f n) 1 Œº ‚â§ R) (hab : a < b) : ‚àÄ·µê œâ ‚àÇŒº, upcrossings a b f œâ < ‚àû 


Original valid proof:
:= by
  refine ae_lt_top (hf.adapted.measurable_upcrossings hab) ?_
  have := hf.mul_lintegral_upcrossings_le_lintegral_pos_part a b
  rw [mul_comm, ‚Üê ENNReal.le_div_iff_mul_le] at this
  ¬∑ refine (lt_of_le_of_lt this (ENNReal.div_lt_top ?_ ?_)).ne
    ¬∑ have hR' : ‚àÄ n, ‚à´‚Åª œâ, ‚Äñf n œâ - a‚Äñ‚Çä ‚àÇŒº ‚â§ R + ‚Äña‚Äñ‚Çä * Œº Set.univ := by
        simp_rw [snorm_one_eq_lintegral_nnnorm] at hbdd
        intro n
        refine (lintegral_mono ?_ : ‚à´‚Åª œâ, ‚Äñf n œâ - a‚Äñ‚Çä ‚àÇŒº ‚â§ ‚à´‚Åª œâ, ‚Äñf n œâ‚Äñ‚Çä + ‚Äña‚Äñ‚Çä ‚àÇŒº).trans ?_
        ¬∑ intro œâ
          simp_rw [sub_eq_add_neg, ‚Üê nnnorm_neg a, ‚Üê ENNReal.coe_add, ENNReal.coe_le_coe]
          exact nnnorm_add_le _ _
        ¬∑ simp_rw [lintegral_add_right _ measurable_const, lintegral_const]
          exact add_le_add (hbdd _) le_rfl
      refine ne_of_lt (iSup_lt_iff.2 ‚ü®R + ‚Äña‚Äñ‚Çä * Œº Set.univ, ENNReal.add_lt_top.2
        ‚ü®ENNReal.coe_lt_top, ENNReal.mul_lt_top ENNReal.coe_lt_top.ne (measure_ne_top _ _)‚ü©,
        fun n => le_trans ?_ (hR' n)‚ü©)
      refine lintegral_mono fun œâ => ?_
      rw [ENNReal.ofReal_le_iff_le_toReal, ENNReal.coe_toReal, coe_nnnorm]
      ¬∑ by_cases hnonneg : 0 ‚â§ f n œâ - a
        ¬∑ rw [posPart_eq_self.2 hnonneg, Real.norm_eq_abs, abs_of_nonneg hnonneg]
        ¬∑ rw [posPart_eq_zero.2 (not_le.1 hnonneg).le]
          exact norm_nonneg _
      ¬∑ simp only [Ne, ENNReal.coe_ne_top, not_false_iff]
    ¬∑ simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le]
  ¬∑ simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le, true_or_iff]
  ¬∑ simp only [Ne, ENNReal.ofReal_ne_top, not_false_iff, true_or_iff]


Verifying proof (Commit 8b24b7412473ebe3dfb3396b9609b7817f5d3868):
:= by
  refine ae_lt_top (hf.adapted.measurable_upcrossings hab) ?_
  have := hf.mul_lintegral_upcrossings_le_lintegral_pos_part a b
  rw [mul_comm, ‚Üê ENNReal.le_div_iff_mul_le] at this
  ¬∑ refine (lt_of_le_of_lt this (ENNReal.div_lt_top ?_ ?_)).ne
    ¬∑ have hR' : ‚àÄ n, ‚à´‚Åª œâ, ‚Äñf n œâ - a‚Äñ‚Çä ‚àÇŒº ‚â§ R + ‚Äña‚Äñ‚Çä * Œº Set.univ := by
        simp_rw [snorm_one_eq_lintegral_nnnorm] at hbdd
        intro n
        refine (lintegral_mono ?_ : ‚à´‚Åª œâ, ‚Äñf n œâ - a‚Äñ‚Çä ‚àÇŒº ‚â§ ‚à´‚Åª œâ, ‚Äñf n œâ‚Äñ‚Çä + ‚Äña‚Äñ‚Çä ‚àÇŒº).trans ?_
        ¬∑ intro œâ
          simp_rw [sub_eq_add_neg, ‚Üê nnnorm_neg a, ‚Üê ENNReal.coe_add, ENNReal.coe_le_coe]
          exact nnnorm_add_le _ _
        ¬∑ simp_rw [lintegral_add_right _ measurable_const, lintegral_const]
          exact add_le_add (hbdd _) le_rfl
      refine ne_of_lt (iSup_lt_iff.2 ‚ü®R + ‚Äña‚Äñ‚Çä * Œº Set.univ, ENNReal.add_lt_top.2
        ‚ü®ENNReal.coe_lt_top, ENNReal.mul_lt_top ENNReal.coe_lt_top.ne (measure_ne_top _ _)‚ü©,
        fun n => le_trans ?_ (hR' n)‚ü©)
      refine lintegral_mono fun œâ => ?_
      rw [ENNReal.ofReal_le_iff_le_toReal, ENNReal.coe_toReal, coe_nnnorm]
      by_cases hnonneg : 0 ‚â§ f n œâ - a
      ¬∑ rw [LatticeOrderedCommGroup.pos_of_nonneg _ hnonneg, Real.norm_eq_abs,
          abs_of_nonneg hnonneg]
      ¬∑ rw [LatticeOrderedCommGroup.pos_of_nonpos _ (not_le.1 hnonneg).le]
        exact norm_nonneg _
      ¬∑ simp only [Ne, ENNReal.coe_ne_top, not_false_iff, true_or_iff]

Attempt failure.

---80/100---
For theorem MeasureTheory.Submartingale.ae_tendsto_limitProcess in Mathlib/Probability/Martingale/Convergence.lean:
theorem Submartingale.ae_tendsto_limitProcess [IsFiniteMeasure Œº] (hf : Submartingale f ‚Ñ± Œº)
    (hbdd : ‚àÄ n, snorm (f n) 1 Œº ‚â§ R) :
    ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ) atTop (ùìù (‚Ñ±.limitProcess f Œº œâ)) 


Original valid proof:
:= by
  classical
  suffices
      ‚àÉ g, StronglyMeasurable[‚®Ü n, ‚Ñ± n] g ‚àß ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù c) then h.choose else 0
  have hle : ‚®Ü n, ‚Ñ± n ‚â§ m0 := sSup_le fun m ‚ü®n, hn‚ü© => hn ‚ñ∏ ‚Ñ±.le _
  have hg' : ‚àÄ·µê œâ ‚àÇŒº.trim hle, Tendsto (fun n => f n œâ) atTop (ùìù (g' œâ)) := by
    filter_upwards [hf.exists_ae_trim_tendsto_of_bdd hbdd] with œâ hœâ
    simp_rw [g', dif_pos hœâ]
    exact hœâ.choose_spec
  have hg'm : @AEStronglyMeasurable _ _ _ (‚®Ü n, ‚Ñ± n) g' (Œº.trim hle) :=
    (@aemeasurable_of_tendsto_metrizable_ae' _ _ (‚®Ü n, ‚Ñ± n) _ _ _ _ _ _ _
      (fun n => ((hf.stronglyMeasurable n).measurable.mono (le_sSup ‚ü®n, rfl‚ü© : ‚Ñ± n ‚â§ ‚®Ü n, ‚Ñ± n)
        le_rfl).aemeasurable) hg').aestronglyMeasurable
  obtain ‚ü®g, hgm, hae‚ü© := hg'm
  have hg : ‚àÄ·µê œâ ‚àÇŒº.trim hle, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) := by
    filter_upwards [hae, hg'] with œâ hœâ hg'œâ
    exact hœâ ‚ñ∏ hg'œâ
  exact ‚ü®g, hgm, measure_eq_zero_of_trim_eq_zero hle hg‚ü©


Verifying proof (Commit be55166c883a8ce6c537d5f0d2dd43baed489981):
:= by
  classical
  suffices
      ‚àÉ g, StronglyMeasurable[‚®Ü n, ‚Ñ± n] g ‚àß ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Ideal.lean - 2024-09-07 22:06:44.687694.
---81/100---
For theorem FractionalIdeal.coe_ideal_mul_inv in Mathlib/RingTheory/DedekindDomain/Ideal.lean:
theorem coe_ideal_mul_inv [h : IsDedekindDomain A] (I : Ideal A) (hI0 : I ‚â† ‚ä•) :
    I * (I : FractionalIdeal A‚Å∞ K)‚Åª¬π = 1 


Original valid proof:
:= by
  apply mul_inv_cancel_of_le_one hI0
  by_cases hJ0 : I * (I : FractionalIdeal A‚Å∞ K)‚Åª¬π = 0
  ¬∑ rw [hJ0, inv_zero']; exact zero_le _
  intro x hx
  suffices x ‚àà integralClosure A K by
    rwa [IsIntegrallyClosed.integralClosure_eq_bot, Algebra.mem_bot, Set.mem_range,
      ‚Üê mem_one_iff] at this
  rw [mem_integralClosure_iff_mem_fg]
  have x_mul_mem : ‚àÄ b ‚àà (I‚Åª¬π : FractionalIdeal A‚Å∞ K), x * b ‚àà (I‚Åª¬π : FractionalIdeal A‚Å∞ K) := by
    intro b hb
    rw [mem_inv_iff (coeIdeal_ne_zero.mpr hI0)]
    dsimp only at hx
    rw [val_eq_coe, mem_coe, mem_inv_iff hJ0] at hx
    simp only [mul_assoc, mul_comm b] at hx ‚ä¢
    intro y hy
    exact hx _ (mul_mem_mul hy hb)
  refine ‚ü®AlgHom.range (Polynomial.aeval x : A[X] ‚Üí‚Çê[A] K),
    isNoetherian_submodule.mp (isNoetherian (I : FractionalIdeal A‚Å∞ K)‚Åª¬π) _ fun y hy => ?_,
    ‚ü®Polynomial.X, Polynomial.aeval_X x‚ü©‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp hy
  rw [Polynomial.aeval_eq_sum_range]
  refine Submodule.sum_mem _ fun i hi => Submodule.smul_mem _ _ ?_
  clear hi
  induction' i with i ih
  ¬∑ rw [pow_zero]; exact one_mem_inv_coe_ideal hI0
  ¬∑ show x ^ i.succ ‚àà (I‚Åª¬π : FractionalIdeal A‚Å∞ K)
    rw [pow_succ']; exact x_mul_mem _ ih


Verifying proof (Commit db4b2acc70490f6bcea6872fdf1d716949f8c1e7):
:= by
  apply mul_inv_cancel_of_le_one hI0
  by_cases hJ0 : I * (I : FractionalIdeal A‚Å∞ K)‚Åª¬π = 0
  ¬∑ rw [hJ0, inv_zero']; exact zero_le _
  intro x hx
  have := IsDedekindDomain.isIntegrallyClosed A K
  suffices x ‚àà integralClosure A K by
    rwa [IsIntegrallyClosed.integralClosure_eq_bot, Algebra.mem_bot, Set.mem_range,
      ‚Üê mem_one_iff] at this
  rw [mem_integralClosure_iff_mem_FG]
  have x_mul_mem : ‚àÄ b ‚àà (I‚Åª¬π : FractionalIdeal A‚Å∞ K), x * b ‚àà (I‚Åª¬π : FractionalIdeal A‚Å∞ K) := by
    intro b hb
    rw [mem_inv_iff (coeIdeal_ne_zero.mpr hI0)]
    dsimp only at hx
    rw [val_eq_coe, mem_coe, mem_inv_iff hJ0] at hx
    simp only [mul_assoc, mul_comm b] at hx ‚ä¢
    intro y hy
    exact hx _ (mul_mem_mul hy hb)
  refine ‚ü®AlgHom.range (Polynomial.aeval x : A[X] ‚Üí‚Çê[A] K),
    isNoetherian_submodule.mp (isNoetherian (I : FractionalIdeal A‚Å∞ K)‚Åª¬π) _ fun y hy => ?_,
    ‚ü®Polynomial.X, Polynomial.aeval_X x‚ü©‚ü©
  obtain ‚ü®p, rfl‚ü© := (AlgHom.mem_range _).mp hy
  rw [Polynomial.aeval_eq_sum_range]
  refine Submodule.sum_mem _ fun i hi => Submodule.smul_mem _ _ ?_
  clear hi
  induction' i with i ih
  ¬∑ rw [pow_zero]; exact one_mem_inv_coe_ideal hI0
  ¬∑ show x ^ i.succ ‚àà (I‚Åª¬π : FractionalIdeal A‚Å∞ K)
    rw [pow_succ]; exact x_mul_mem _ ih

Attempt failure.

Working on Mathlib/RingTheory/Discriminant.lean - 2024-09-07 22:07:06.422714.
---82/100---
For theorem Algebra.discr_zero_of_not_linearIndependent in Mathlib/RingTheory/Discriminant.lean:
theorem discr_zero_of_not_linearIndependent [IsDomain A] {b : Œπ ‚Üí B}
    (hli : ¬¨LinearIndependent A b) : discr A b = 0 


Original valid proof:
:= by
  classical
  obtain ‚ü®g, hg, i, hi‚ü© := Fintype.not_linearIndependent_iff.1 hli
  have : (traceMatrix A b) *·µ• g = 0 := by
    ext i
    have : ‚àÄ j, (trace A B) (b i * b j) * g j = (trace A B) (g j ‚Ä¢ b j * b i) := by
      intro j;
      simp [mul_comm]
    simp only [mulVec, dotProduct, traceMatrix_apply, Pi.zero_apply, traceForm_apply, fun j =>
      this j, ‚Üê map_sum, ‚Üê sum_mul, hg, zero_mul, LinearMap.map_zero]
  by_contra h
  rw [discr_def] at h
  simp [Matrix.eq_zero_of_mulVec_eq_zero h this] at hi


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
:= by
  classical
  obtain ‚ü®g, hg, i, hi‚ü© := Fintype.not_linearIndependent_iff.1 hli
  have : (traceMatrix A b).mulVec g = 0 := by
    ext i
    have : ‚àÄ j, (trace A B) (b i * b j) * g j = (trace A B) (g j ‚Ä¢ b j * b i) := by
      intro j;
      simp [mul_comm]
    simp only [mulVec, dotProduct, traceMatrix_apply, Pi.zero_apply, traceForm_apply, fun j =>
      this j, ‚Üê LinearMap.map_sum, ‚Üê sum_mul, hg, MulZeroClass.zero_mul, LinearMap.map_zero]
  by_contra h
  rw [discr_def] at h
  simp [Matrix.eq_zero_of_mulVec_eq_zero h this] at hi

Attempt failure.

Working on Mathlib/RingTheory/IntegralClosure.lean - 2024-09-07 22:07:17.877554.
---83/100---
For theorem isIntegral_of_smul_mem_submodule in Mathlib/RingTheory/IntegralClosure.lean:
theorem isIntegral_of_smul_mem_submodule {M : Type*} [AddCommGroup M] [Module R M] [Module A M]
    [IsScalarTower R A M] [NoZeroSMulDivisors A M] (N : Submodule R M) (hN : N ‚â† ‚ä•) (hN' : N.FG)
    (x : A) (hx : ‚àÄ n ‚àà N, x ‚Ä¢ n ‚àà N) : IsIntegral R x 


Original valid proof:
:= by
  let A' : Subalgebra R A :=
    { carrier := { x | ‚àÄ n ‚àà N, x ‚Ä¢ n ‚àà N }
      mul_mem' := fun {a b} ha hb n hn => smul_smul a b n ‚ñ∏ ha _ (hb _ hn)
      one_mem' := fun n hn => (one_smul A n).symm ‚ñ∏ hn
      add_mem' := fun {a b} ha hb n hn => (add_smul a b n).symm ‚ñ∏ N.add_mem (ha _ hn) (hb _ hn)
      zero_mem' := fun n _hn => (zero_smul A n).symm ‚ñ∏ N.zero_mem
      algebraMap_mem' := fun r n hn => (algebraMap_smul A r n).symm ‚ñ∏ N.smul_mem r hn }
  let f : A' ‚Üí‚Çê[R] Module.End R N :=
    AlgHom.ofLinearMap
      { toFun := fun x => (DistribMulAction.toLinearMap R M x).restrict x.prop
        map_add' := by intros x y; ext; exact add_smul _ _ _
        map_smul' := by intros r s; ext; apply smul_assoc }
      (by ext; apply one_smul)
      (by intros x y; ext; apply mul_smul)
  obtain ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© : ‚àÉ a ‚àà N, a ‚â† (0 : M) := by
    by_contra! h'
    apply hN
    rwa [eq_bot_iff]
  have : Function.Injective f := by
    show Function.Injective f.toLinearMap
    rw [‚Üê LinearMap.ker_eq_bot, eq_bot_iff]
    intro s hs
    have : s.1 ‚Ä¢ a = 0 := congr_arg Subtype.val (LinearMap.congr_fun hs ‚ü®a, ha‚ÇÅ‚ü©)
    exact Subtype.ext ((eq_zero_or_eq_zero_of_smul_eq_zero this).resolve_right ha‚ÇÇ)
  show IsIntegral R (A'.val ‚ü®x, hx‚ü©)
  rw [isIntegral_algHom_iff A'.val Subtype.val_injective, ‚Üê isIntegral_algHom_iff f this]
  haveI : Module.Finite R N := by rwa [Module.finite_def, Submodule.fg_top]
  apply Algebra.IsIntegral.isIntegral


Verifying proof (Commit b1cd52acffa53bca04a33ddc14a40b2a62ed4308):
:= by
  let A' : Subalgebra R A :=
    { carrier := { x | ‚àÄ n ‚àà N, x ‚Ä¢ n ‚àà N }
      mul_mem' := fun {a b} ha hb n hn => smul_smul a b n ‚ñ∏ ha _ (hb _ hn)
      one_mem' := fun n hn => (one_smul A n).symm ‚ñ∏ hn
      add_mem' := fun {a b} ha hb n hn => (add_smul a b n).symm ‚ñ∏ N.add_mem (ha _ hn) (hb _ hn)
      zero_mem' := fun n _hn => (zero_smul A n).symm ‚ñ∏ N.zero_mem
      algebraMap_mem' := fun r n hn => (algebraMap_smul A r n).symm ‚ñ∏ N.smul_mem r hn }
  let f : A' ‚Üí‚Çê[R] Module.End R N :=
    AlgHom.ofLinearMap
      { toFun := fun x => (DistribMulAction.toLinearMap R M x).restrict x.prop
        map_add' := by intros x y; ext; exact add_smul _ _ _
        map_smul' := by intros r s; ext; apply smul_assoc }
      (by ext; apply one_smul)
      (by intros x y; ext; apply mul_smul)
  obtain ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© : ‚àÉ a ‚àà N, a ‚â† (0 : M) := by
    by_contra! h'
    apply hN
    rwa [eq_bot_iff]
  have : Function.Injective f := by
    show Function.Injective f.toLinearMap
    rw [‚Üê LinearMap.ker_eq_bot, eq_bot_iff]
    intro s hs
    have : s.1 ‚Ä¢ a = 0 := congr_arg Subtype.val (LinearMap.congr_fun hs ‚ü®a, ha‚ÇÅ‚ü©)
    exact Subtype.ext ((eq_zero_or_eq_zero_of_smul_eq_zero this).resolve_right ha‚ÇÇ)
  show IsIntegral R (A'.val ‚ü®x, hx‚ü©)
  rw [isIntegral_algHom_iff A'.val Subtype.val_injective, ‚Üê isIntegral_algHom_iff f this]
  haveI : Module.Finite R N := by rwa [Module.finite_def, Submodule.fg_top]
  apply Module.End.isIntegral

Attempt failure.

---84/100---
For theorem RingHom.isIntegralElem_leadingCoeff_mul in Mathlib/RingTheory/IntegralClosure.lean:
theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval‚ÇÇ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) 


Original valid proof:
:= by
  by_cases h' : 1 ‚â§ p.natDegree
  ¬∑ use normalizeScaleRoots p
    have : p ‚â† 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_eval‚ÇÇ_leadingCoeff_mul p h' f x, h, mul_zero]
  ¬∑ by_cases hp : p.map f = 0
    ¬∑ apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, zero_mul]
      exact f.isIntegralElem_zero
    ¬∑ rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', eval‚ÇÇ_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
:= by
  by_cases h' : 1 ‚â§ p.natDegree
  ¬∑ use normalizeScaleRoots p
    have : p ‚â† 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_eval‚ÇÇ_leadingCoeff_mul p h' f x, h, MulZeroClass.mul_zero]
  ¬∑ by_cases hp : p.map f = 0
    ¬∑ apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, MulZeroClass.zero_mul]
      exact f.isIntegral_zero
    ¬∑ rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/GaussLemma.lean - 2024-09-07 22:07:56.611733.
---85/100---
For theorem IsIntegrallyClosed.eq_map_mul_C_of_dvd in Mathlib/RingTheory/Polynomial/GaussLemma.lean:
theorem IsIntegrallyClosed.eq_map_mul_C_of_dvd [IsIntegrallyClosed R] {f : R[X]} (hf : f.Monic)
    {g : K[X]} (hg : g ‚à£ f.map (algebraMap R K)) :
    ‚àÉ g' : R[X], g'.map (algebraMap R K) * (C <| leadingCoeff g) = g 


Original valid proof:
:= by
  have g_ne_0 : g ‚â† 0 := ne_zero_of_dvd_ne_zero (Monic.ne_zero <| hf.map (algebraMap R K)) hg
  suffices lem : ‚àÉ g' : R[X], g'.map (algebraMap R K) = g * C g.leadingCoeff‚Åª¬π by
    obtain ‚ü®g', hg'‚ü© := lem
    use g'
    rw [hg', mul_assoc, ‚Üê C_mul, inv_mul_cancel (leadingCoeff_ne_zero.mpr g_ne_0), C_1, mul_one]
  have g_mul_dvd : g * C g.leadingCoeff‚Åª¬π ‚à£ f.map (algebraMap R K) := by
    rwa [Associated.dvd_iff_dvd_left (show Associated (g * C g.leadingCoeff‚Åª¬π) g from _)]
    rw [associated_mul_isUnit_left_iff]
    exact isUnit_C.mpr (inv_ne_zero <| leadingCoeff_ne_zero.mpr g_ne_0).isUnit
  let algeq :=
    (Subalgebra.equivOfEq _ _ <| integralClosure_eq_bot R _).trans
      (Algebra.botEquivOfInjective <| IsFractionRing.injective R <| K)
  have :
    (algebraMap R _).comp algeq.toAlgHom.toRingHom = (integralClosure R _).toSubring.subtype := by
    ext x; (conv_rhs => rw [‚Üê algeq.symm_apply_apply x]); rfl
  have H :=
    (mem_lifts _).1
      (integralClosure.mem_lifts_of_monic_of_dvd_map K hf (monic_mul_leadingCoeff_inv g_ne_0)
        g_mul_dvd)
  refine ‚ü®map algeq.toAlgHom.toRingHom ?_, ?_‚ü©
  ¬∑ use! Classical.choose H
  ¬∑ rw [map_map, this]
    exact Classical.choose_spec H


Verifying proof (Commit 9f6d33884de569540c527b667d1573e1b97e1347):
:= by
  have g_ne_0 : g ‚â† 0 := ne_zero_of_dvd_ne_zero (Monic.ne_zero <| hf.map (algebraMap R K)) hg
  suffices lem : ‚àÉ g' : R[X], g'.map (algebraMap R K) = g * C g.leadingCoeff‚Åª¬π
  ¬∑ obtain ‚ü®g', hg'‚ü© := lem
    use g'
    rw [hg', mul_assoc, ‚Üê C_mul, inv_mul_cancel (leadingCoeff_ne_zero.mpr g_ne_0), C_1, mul_one]
  have g_mul_dvd : g * C g.leadingCoeff‚Åª¬π ‚à£ f.map (algebraMap R K) := by
    rwa [Associated.dvd_iff_dvd_left (show Associated (g * C g.leadingCoeff‚Åª¬π) g from _)]
    rw [associated_mul_isUnit_left_iff]
    exact isUnit_C.mpr (inv_ne_zero <| leadingCoeff_ne_zero.mpr g_ne_0).isUnit
  let algeq :=
    (Subalgebra.equivOfEq _ _ <| integralClosure_eq_bot R _).trans
      (Algebra.botEquivOfInjective <| IsFractionRing.injective R <| K)
  have :
    (algebraMap R _).comp algeq.toAlgHom.toRingHom = (integralClosure R _).toSubring.subtype :=
    by ext x; conv_rhs => rw [‚Üê algeq.symm_apply_apply x]; rfl
  have H :=
    (mem_lifts _).1
      (integralClosure.mem_lifts_of_monic_of_dvd_map K hf (monic_mul_leadingCoeff_inv g_ne_0)
        g_mul_dvd)
  refine ‚ü®map algeq.toAlgHom.toRingHom ?_, ?_‚ü©
  ¬∑ use! Classical.choose H
  ¬∑ rw [map_map, this]
    exact Classical.choose_spec H

Attempt failure.

Working on Mathlib/RingTheory/UniqueFactorizationDomain.lean - 2024-09-07 22:08:05.594815.
---86/100---
For theorem Associates.count_pow in Mathlib/RingTheory/UniqueFactorizationDomain.lean:
theorem count_pow [Nontrivial Œ±] [DecidableEq (Associates Œ±)] {a : Associates Œ±} (ha : a ‚â† 0)
    {p : Associates Œ±} (hp : Irreducible p) (k : ‚Ñï) :
    count p (a ^ k).factors = k * count p a.factors 


Original valid proof:
:= by
  induction' k with n h
  ¬∑ rw [pow_zero, factors_one, zero_mul, count_zero hp]
  ¬∑ rw [pow_succ', count_mul ha (pow_ne_zero _ ha) hp, h]
    ring


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  induction' k with n h
  ¬∑ rw [pow_zero, factors_one, Nat.zero_eq, zero_mul, count_zero hp]
  ¬∑ rw [pow_succ', count_mul ha (pow_ne_zero _ ha) hp, h, Nat.succ_eq_add_one]
    ring

Attempt failure.

Working on Mathlib/SetTheory/Ordinal/Notation.lean - 2024-09-07 22:08:22.745229.
---87/100---
For theorem ONote.fundamentalSequence_has_prop in Mathlib/SetTheory/Ordinal/Notation.lean:
theorem fundamentalSequence_has_prop (o) : FundamentalSequenceProp o (fundamentalSequence o) 


Original valid proof:
:= by
  induction' o with a m b iha ihb; ¬∑ exact rfl
  rw [fundamentalSequence]
  rcases e : b.fundamentalSequence with (‚ü®_ | b'‚ü© | f) <;>
    simp only [FundamentalSequenceProp] <;>
    rw [e, FundamentalSequenceProp] at ihb
  ¬∑ rcases e : a.fundamentalSequence with (‚ü®_ | a'‚ü© | f) <;> cases' e' : m.natPred with m' <;>
      simp only [FundamentalSequenceProp] <;>
      rw [e, FundamentalSequenceProp] at iha <;>
      (try rw [show m = 1 by
            have := PNat.natPred_add_one m; rw [e'] at this; exact PNat.coe_inj.1 this.symm]) <;>
      (try rw [show m = (m' + 1).succPNat by
              rw [‚Üê e', ‚Üê PNat.coe_inj, Nat.succPNat_coe, ‚Üê Nat.add_one, PNat.natPred_add_one]]) <;>
      simp only [repr, iha, ihb, opow_lt_opow_iff_right one_lt_omega, add_lt_add_iff_left, add_zero,
        eq_self_iff_true, lt_add_iff_pos_right, lt_def, mul_one, Nat.cast_zero, Nat.cast_succ,
        Nat.succPNat_coe, opow_succ, opow_zero, mul_add_one, PNat.one_coe, succ_zero,
        true_and_iff, _root_.zero_add, zero_def]
    ¬∑ decide
    ¬∑ exact ‚ü®rfl, inferInstance‚ü©
    ¬∑ have := opow_pos (repr a') omega_pos
      refine
        ‚ü®mul_isLimit this omega_isLimit, fun i =>
          ‚ü®this, ?_, fun H => @NF.oadd_zero _ _ (iha.2 H.fst)‚ü©, exists_lt_mul_omega'‚ü©
      rw [‚Üê mul_succ, ‚Üê natCast_succ, Ordinal.mul_lt_mul_iff_left this]
      apply nat_lt_omega
    ¬∑ have := opow_pos (repr a') omega_pos
      refine
        ‚ü®add_isLimit _ (mul_isLimit this omega_isLimit), fun i => ‚ü®this, ?_, ?_‚ü©,
          exists_lt_add exists_lt_mul_omega'‚ü©
      ¬∑ rw [‚Üê mul_succ, ‚Üê natCast_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
      ¬∑ refine fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (@NF.oadd_zero _ _ (iha.2 H.fst)))
        rw [repr, ‚Üê zero_def, repr, add_zero, iha.1, opow_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
    ¬∑ rcases iha with ‚ü®h1, h2, h3‚ü©
      refine ‚ü®opow_isLimit one_lt_omega h1, fun i => ?_, exists_lt_omega_opow' one_lt_omega h1 h3‚ü©
      obtain ‚ü®h4, h5, h6‚ü© := h2 i
      exact ‚ü®h4, h5, fun H => @NF.oadd_zero _ _ (h6 H.fst)‚ü©
    ¬∑ rcases iha with ‚ü®h1, h2, h3‚ü©
      refine
        ‚ü®add_isLimit _ (opow_isLimit one_lt_omega h1), fun i => ?_,
          exists_lt_add (exists_lt_omega_opow' one_lt_omega h1 h3)‚ü©
      obtain ‚ü®h4, h5, h6‚ü© := h2 i
      refine ‚ü®h4, h5, fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (@NF.oadd_zero _ _ (h6 H.fst)))‚ü©
      rwa [repr, ‚Üê zero_def, repr, add_zero, PNat.one_coe, Nat.cast_one, mul_one,
        opow_lt_opow_iff_right one_lt_omega]
  ¬∑ refine ‚ü®by
      rw [repr, ihb.1, add_succ, repr], fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (ihb.2 H.snd))‚ü©
    have := H.snd'.repr_lt
    rw [ihb.1] at this
    exact (lt_succ _).trans this
  ¬∑ rcases ihb with ‚ü®h1, h2, h3‚ü©
    simp only [repr]
    exact
      ‚ü®Ordinal.add_isLimit _ h1, fun i =>
        ‚ü®oadd_lt_oadd_3 (h2 i).1, oadd_lt_oadd_3 (h2 i).2.1, fun H =>
          H.fst.oadd _ (NF.below_of_lt' (lt_trans (h2 i).2.1 H.snd'.repr_lt) ((h2 i).2.2 H.snd))‚ü©,
        exists_lt_add h3‚ü©


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
:= by
  induction' o with a m b iha ihb; ¬∑ exact rfl
  rw [fundamentalSequence]
  rcases e : b.fundamentalSequence with (‚ü®_ | a'‚ü© | f) <;>
    simp only [FundamentalSequenceProp] <;>
    rw [e, FundamentalSequenceProp] at iha <;>
      (try rw [show m = 1 by
            have := PNat.natPred_add_one m; rw [e'] at this; exact PNat.coe_inj.1 this.symm]) <;>
      (try rw [show m = m'.succ.succPNat by
              rw [‚Üê e', ‚Üê PNat.coe_inj, Nat.succPNat_coe, ‚Üê Nat.add_one, PNat.natPred_add_one]]) <;>
      simp only [repr, iha, ihb, opow_lt_opow_iff_right one_lt_omega, add_lt_add_iff_left, add_zero,
        eq_self_iff_true, lt_add_iff_pos_right, lt_def, mul_one, Nat.cast_zero, Nat.cast_succ,
        Nat.succPNat_coe, opow_succ', opow_zero, mul_add_one, PNat.one_coe, succ_zero,
        true_and_iff, _root_.zero_add, zero_def]
    ¬∑ decide
    ¬∑ exact ‚ü®rfl, inferInstance‚ü©
    ¬∑ have := opow_pos (repr a') omega_pos
      refine
        ‚ü®mul_isLimit this omega_isLimit, fun i =>
          ‚ü®this, _, fun H => @NF.oadd_zero _ _ (iha.2 H.fst)‚ü©, exists_lt_mul_omega'‚ü©
      rw [‚Üê mul_succ, ‚Üê natCast_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
    ¬∑ have := opow_pos (repr a') omega_pos
      refine
        ‚ü®add_isLimit _ (mul_isLimit this omega_isLimit), fun i => ‚ü®this, ?_, ?_‚ü©,
          exists_lt_add exists_lt_mul_omega'‚ü©
      ¬∑ rw [‚Üê mul_succ, ‚Üê natCast_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
    ¬∑ have := opow_pos (repr a') omega_pos
      refine
        ‚ü®add_isLimit _ (mul_isLimit this omega_isLimit), fun i => ‚ü®this, ?_, ?_‚ü©,
          exists_lt_add exists_lt_mul_omega'‚ü©
      ¬∑ rw [‚Üê mul_succ, ‚Üê natCast_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
    ¬∑ have := opow_pos (repr a') omega_pos
      refine
        ‚ü®add_isLimit _ (mul_isLimit this omega_isLimit), fun i => ‚ü®this, ?_, ?_‚ü©,
          exists_lt_add exists_lt_mul_omega'‚ü©
      ¬∑ rw [‚Üê mul_succ, ‚Üê natCast_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
    ¬∑ rcases iha with ‚ü®h1, h2, h3‚ü©
      refine ‚ü®opow_isLimit one_lt_omega h1, fun i => ?_, exists_lt_omega_opow' one_lt_omega h1 h3‚ü©
      obtain ‚ü®h4, h5, h6‚ü© := h2 i
      exact ‚ü®h4, h5, fun H => @NF.oadd_zero _ _ (h6 H.fst)‚ü©
    ¬∑ rcases iha with ‚ü®h1, h2, h3‚ü©
      refine ‚ü®opow_isLimit one_lt_omega h1, fun i => ?_, exists_lt_omega_opow' one_lt_omega h1 h3‚ü©
      obtain ‚ü®h4, h5, h6‚ü© := h2 i
      exact ‚ü®h4, h5, fun H => @NF.o

Attempt failure.

Working on Mathlib/Topology/AlexandrovDiscrete.lean - 2024-09-07 22:08:33.308184.
---88/100---
For theorem isClopen_iUnion in Mathlib/Topology/AlexandrovDiscrete.lean:
lemma isClopen_iUnion (hf : ‚àÄ i, IsClopen (f i)) : IsClopen (‚ãÉ i, f i) 


Original valid proof:
:=
  ‚ü®isClosed_iUnion fun i ‚Ü¶ (hf i).1, isOpen_iUnion fun i ‚Ü¶ (hf i).2‚ü©


Verifying proof (Commit 13444d800e71a22689e60023576255503756cd93):
:=
  isClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsClopen_iUnion (hf : ‚àÄ i, IsC

Attempt failure.

Working on Mathlib/Topology/Algebra/Module/LinearPMap.lean - 2024-09-07 22:08:39.185729.
---89/100---
For theorem LinearPMap.inverse_isClosable_iff in Mathlib/Topology/Algebra/Module/LinearPMap.lean:
theorem inverse_isClosable_iff (hf : LinearMap.ker f.toFun = ‚ä•) (hf' : f.IsClosable) :
    f.inverse.IsClosable ‚Üî LinearMap.ker f.closure.toFun = ‚ä• 


Original valid proof:
:= by
  constructor
  ¬∑ intro ‚ü®f', h‚ü©
    rw [LinearMap.ker_eq_bot']
    intro ‚ü®x, hx‚ü© hx'
    simp only [Submodule.mk_eq_zero]
    rw [toFun_eq_coe, eq_comm, image_iff] at hx'
    have : (0, x) ‚àà graph f' := by
      rw [‚Üê h, inverse_graph hf]
      rw [‚Üê hf'.graph_closure_eq_closure_graph, ‚Üê SetLike.mem_coe,
        Submodule.topologicalClosure_coe] at hx'
      apply image_closure_subset_closure_image continuous_swap
      simp only [Set.mem_image, Prod.exists, Prod.swap_prod_mk, Prod.mk.injEq]
      exact ‚ü®x, 0, hx', rfl, rfl‚ü©
    exact graph_fst_eq_zero_snd f' this rfl
  ¬∑ intro h
    use f.closure.inverse
    exact (closure_inverse_graph hf hf' h).symm


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
:= by
  constructor
  ¬∑ intro ‚ü®f', h‚ü©
    rw [LinearMap.ker_eq_bot']
    intro ‚ü®x, hx‚ü© hx'
    simp only [Submodule.mk_eq_zero]
    rw [toFun_eq_coe, eq_comm, image_iff] at hx'
    have : (0, x) ‚àà graph f'
    ¬∑ rw [‚Üê h, inverse_graph hf]
      rw [‚Üê hf'.graph_closure_eq_closure_graph, ‚Üê SetLike.mem_coe,
        Submodule.topologicalClosure_coe] at hx'
      apply image_closure_subset_closure_image continuous_swap
      simp only [Set.mem_image, Prod.exists, Prod.swap_prod_mk, Prod.mk.injEq]
      exact ‚ü®x, 0, hx', rfl, rfl‚ü©
    exact graph_fst_eq_zero_snd f' this rfl
  ¬∑ intro h
    use f.closure.inverse
    exact (closure_inverse_graph hf hf' h).symm

Attempt failure.

Working on Mathlib/Topology/Algebra/StarSubalgebra.lean - 2024-09-07 22:08:48.262995.
---90/100---
For theorem StarSubalgebra.closedEmbedding_inclusion in Mathlib/Topology/Algebra/StarSubalgebra.lean:
theorem closedEmbedding_inclusion {S‚ÇÅ S‚ÇÇ : StarSubalgebra R A} (h : S‚ÇÅ ‚â§ S‚ÇÇ)
    (hS‚ÇÅ : IsClosed (S‚ÇÅ : Set A)) : ClosedEmbedding (inclusion h) 


Original valid proof:
:=
  { embedding_inclusion h with
    isClosed_range := isClosed_induced_iff.2
      ‚ü®S‚ÇÅ, hS‚ÇÅ, by
          convert (Set.range_subtype_map id _).symm
          ¬∑ rw [Set.image_id]; rfl
          ¬∑ intro _ h'
            apply h h' ‚ü© }


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
:=
  { embedding_inclusion h with
    closed_range := isClosed_induced_iff.2
      ‚ü®S‚ÇÅ, hS‚ÇÅ, by
          convert(Set.range_subtype_map id _).symm
         ¬∑ rw [Set.image_id]; rfl
          ¬∑ intro _ h'
           apply h h' ‚ü© }

Attempt failure.

Working on Mathlib/Topology/Category/Stonean/Basic.lean - 2024-09-07 22:08:57.839307.
---91/100---
For theorem Profinite.projective_of_extrDisc in Mathlib/Topology/Category/Stonean/Basic.lean:
lemma projective_of_extrDisc {X : Profinite.{u}} (hX : ExtremallyDisconnected X) :
    Projective X 


Original valid proof:
:= by
  show Projective (Stonean.toProfinite.obj ‚ü®X.toCompHaus‚ü©)
  exact inferInstance


Verifying proof (Commit 7d5d6eb658906f2c7b67de823bc202579000fb2e):
:= by
  show Projective (Stonean.toProfinite.obj ‚ü®X.toTop, inferInstance‚ü©)
  exact inferInstance

Attempt failure.

Working on Mathlib/Topology/Compactness/Lindelof.lean - 2024-09-07 22:09:06.066651.
---92/100---
For theorem hasBasis_coclosedLindelof in Mathlib/Topology/Compactness/Lindelof.lean:
theorem hasBasis_coclosedLindelof :
    (Filter.coclosedLindelof X).HasBasis (fun s => IsClosed s ‚àß IsLindelof s) compl 


Original valid proof:
:= by
  simp only [Filter.coclosedLindelof, iInf_and']
  refine hasBasis_biInf_principal' ?_ ‚ü®‚àÖ, isClosed_empty, isLindelof_empty‚ü©
  rintro s ‚ü®hs‚ÇÅ, hs‚ÇÇ‚ü© t ‚ü®ht‚ÇÅ, ht‚ÇÇ‚ü©
  exact ‚ü®s ‚à™ t, ‚ü®‚ü®hs‚ÇÅ.union ht‚ÇÅ, hs‚ÇÇ.union ht‚ÇÇ‚ü©, compl_subset_compl.2 subset_union_left,
    compl_subset_compl.2 subset_union_right‚ü©‚ü©


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  simp only [Filter.coclosedLindelof, iInf_and']
  refine hasBasis_biInf_principal' ?_ ‚ü®‚àÖ, isClosed_empty, isLindelof_empty‚ü©
  rintro s ‚ü®hs‚ÇÅ, hs‚ÇÇ‚ü© t ‚ü®ht‚ÇÅ, ht‚ÇÇ‚ü©
  exact ‚ü®s ‚à™ t, ‚ü®‚ü®hs‚ÇÅ.union ht‚ÇÅ, hs‚ÇÇ.union ht‚ÇÇ‚ü©, compl_subset_compl.2 (subset_union_left‚ü©‚ü©

Attempt failure.

Working on Mathlib/Topology/Connected/TotallyDisconnected.lean - 2024-09-07 22:09:12.464524.
---93/100---
For theorem isTotallyDisconnected_of_isClopen_set in Mathlib/Topology/Connected/TotallyDisconnected.lean:
theorem isTotallyDisconnected_of_isClopen_set {X : Type*} [TopologicalSpace X]
    (hX : Pairwise fun x y => ‚àÉ (U : Set X), IsClopen U ‚àß x ‚àà U ‚àß y ‚àâ U) :
    IsTotallyDisconnected (Set.univ : Set X) 


Original valid proof:
:= by
  rintro S - hS
  unfold Set.Subsingleton
  by_contra! h_contra
  rcases h_contra with ‚ü®x, hx, y, hy, hxy‚ü©
  obtain ‚ü®U, hU, hxU, hyU‚ü© := hX hxy
  specialize
    hS U U·∂ú hU.2 hU.compl.2 (fun a _ => em (a ‚àà U)) ‚ü®x, hx, hxU‚ü© ‚ü®y, hy, hyU‚ü©
  rw [inter_compl_self, Set.inter_empty] at hS
  exact Set.not_nonempty_empty hS


Verifying proof (Commit 5192777c94aec06289e492ce206d68fbbe72572c):
:= by
  rintro S - hS
  unfold Set.Subsingleton by_contra! h_contra
  rcases h_contra with ‚ü®x, hx, y, hy, hxy‚ü©
  obtain ‚ü®U, hU, hxU, hyU‚ü© := hX hxy
  specialize
    hS U U·∂ú hU.1 hU.compl.1 (fun a _ => em (a ‚àà U)) ‚ü®x, hx, hxU‚ü© ‚ü®y, hy, hyU‚ü©
  rw [inter_compl_self, Set.inter_empty] at hS
  exact Set.not_nonempty_empty hS

Attempt failure.

Working on Mathlib/Topology/ContinuousOn.lean - 2024-09-07 22:09:17.554000.
---94/100---
For theorem nhdsWithin_restrict'' in Mathlib/Topology/ContinuousOn.lean:
theorem nhdsWithin_restrict'' {a : Œ±} (s : Set Œ±) {t : Set Œ±} (h : t ‚àà ùìù[s] a) :
    ùìù[s] a = ùìù[s ‚à© t] a 


Original valid proof:
:=
  le_antisymm (le_inf inf_le_left (le_principal_iff.mpr (inter_mem self_mem_nhdsWithin h)))
    (inf_le_inf_left _ (principal_mono.mpr Set.inter_subset_left))


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:=
  le_antisymm (le_inf inf_le_left (le_principal_iff.mpr (inter_mem self_mem_nhdsWithin h)))
    (inf_le_inf_left _ (principal_mono.mpr Set.inter_subset_left))

Attempt success.

Working on Mathlib/Topology/MetricSpace/GromovHausdorff.lean - 2024-09-07 22:09:25.756747.
---95/100---
For theorem GromovHausdorff.ghDist_le_of_approx_subsets in Mathlib/Topology/MetricSpace/GromovHausdorff.lean:
theorem ghDist_le_of_approx_subsets {s : Set X} (Œ¶ : s ‚Üí Y) {Œµ‚ÇÅ Œµ‚ÇÇ Œµ‚ÇÉ : ‚Ñù}
    (hs : ‚àÄ x : X, ‚àÉ y ‚àà s, dist x y ‚â§ Œµ‚ÇÅ) (hs' : ‚àÄ x : Y, ‚àÉ y : s, dist x (Œ¶ y) ‚â§ Œµ‚ÇÉ)
    (H : ‚àÄ x y : s, |dist x y - dist (Œ¶ x) (Œ¶ y)| ‚â§ Œµ‚ÇÇ) : ghDist X Y ‚â§ Œµ‚ÇÅ + Œµ‚ÇÇ / 2 + Œµ‚ÇÉ 


Original valid proof:
:= by
  refine le_of_forall_pos_le_add fun Œ¥ Œ¥0 => ?_
  rcases exists_mem_of_nonempty X with ‚ü®xX, _‚ü©
  rcases hs xX with ‚ü®xs, hxs, Dxs‚ü©
  have sne : s.Nonempty := ‚ü®xs, hxs‚ü©
  letI : Nonempty s := sne.to_subtype
  have : 0 ‚â§ Œµ‚ÇÇ := le_trans (abs_nonneg _) (H ‚ü®xs, hxs‚ü© ‚ü®xs, hxs‚ü©)
  have : ‚àÄ p q : s, |dist p q - dist (Œ¶ p) (Œ¶ q)| ‚â§ 2 * (Œµ‚ÇÇ / 2 + Œ¥) := fun p q =>
    calc
      |dist p q - dist (Œ¶ p) (Œ¶ q)| ‚â§ Œµ‚ÇÇ := H p q
      _ ‚â§ 2 * (Œµ‚ÇÇ / 2 + Œ¥) := by linarith
  letI : MetricSpace (Sum X Y) :=
    glueMetricApprox (fun x : s => (x : X)) (fun x => Œ¶ x) (Œµ‚ÇÇ / 2 + Œ¥) (by linarith) this
  let Fl := @Sum.inl X Y
  let Fr := @Sum.inr X Y
  have Il : Isometry Fl := Isometry.of_dist_eq fun x y => rfl
  have Ir : Isometry Fr := Isometry.of_dist_eq fun x y => rfl
  have : ghDist X Y ‚â§ hausdorffDist (range Fl) (range Fr) := ghDist_le_hausdorffDist Il Ir
  have :
    hausdorffDist (range Fl) (range Fr) ‚â§
      hausdorffDist (range Fl) (Fl '' s) + hausdorffDist (Fl '' s) (range Fr) :=
    have B : IsBounded (range Fl) := (isCompact_range Il.continuous).isBounded
    hausdorffDist_triangle
      (hausdorffEdist_ne_top_of_nonempty_of_bounded (range_nonempty _) (sne.image _) B
        (B.subset (image_subset_range _ _)))
  have :
    hausdorffDist (Fl '' s) (range Fr) ‚â§
      hausdorffDist (Fl '' s) (Fr '' range Œ¶) + hausdorffDist (Fr '' range Œ¶) (range Fr) :=
    have B : IsBounded (range Fr) := (isCompact_range Ir.continuous).isBounded
    hausdorffDist_triangle'
      (hausdorffEdist_ne_top_of_nonempty_of_bounded ((range_nonempty _).image _) (range_nonempty _)
        (B.subset (image_subset_range _ _)) B)
  have : hausdorffDist (range Fl) (Fl '' s) ‚â§ Œµ‚ÇÅ := by
    rw [‚Üê image_univ, hausdorffDist_image Il]
    have : 0 ‚â§ Œµ‚ÇÅ := le_trans dist_nonneg Dxs
    refine hausdorffDist_le_of_mem_dist this (fun x _ => hs x) fun x _ =>
      ‚ü®x, mem_univ _, by simpa only [dist_self]‚ü©
  have : hausdorffDist (Fl '' s) (Fr '' range Œ¶) ‚â§ Œµ‚ÇÇ / 2 + Œ¥ := by
    refine hausdorffDist_le_of_mem_dist (by linarith) ?_ ?_
    ¬∑ intro x' hx'
      rcases (Set.mem_image _ _ _).1 hx' with ‚ü®x, ‚ü®x_in_s, xx'‚ü©‚ü©
      rw [‚Üê xx']
      use Fr (Œ¶ ‚ü®x, x_in_s‚ü©), mem_image_of_mem Fr (mem_range_self _)
      exact le_of_eq (glueDist_glued_points (fun x : s => (x : X)) Œ¶ (Œµ‚ÇÇ / 2 + Œ¥) ‚ü®x, x_in_s‚ü©)
    ¬∑ intro x' hx'
      rcases (Set.mem_image _ _ _).1 hx' with ‚ü®y, ‚ü®y_in_s', yx'‚ü©‚ü©
      rcases mem_range.1 y_in_s' with ‚ü®x, xy‚ü©
      use Fl x, mem_image_of_mem _ x.2
      rw [‚Üê yx', ‚Üê xy, dist_comm]
      exact le_of_eq (glueDist_glued_points (Z := s) (@Subtype.val X s) Œ¶ (Œµ‚ÇÇ / 2 + Œ¥) x)
  have : hausdorffDist (Fr '' range Œ¶) (range Fr) ‚â§ Œµ‚ÇÉ := by
    rw [‚Üê @image_univ _ _ Fr, hausdorffDist_image Ir]
    rcases exists_mem_of_nonempty Y with ‚ü®xY, _‚ü©
    rcases hs' xY with ‚ü®xs', Dxs'‚ü©
    have : 0 ‚â§ Œµ‚ÇÉ := le_trans dist_nonneg Dxs'
    refine hausdorffDist_le_of_mem_dist this
      (fun x _ => ‚ü®x, mem_univ _, by simpa only [dist_self]‚ü©)
      fun x _ => ?_
    rcases hs' x with ‚ü®y, Dy‚ü©
    exact ‚ü®Œ¶ y, mem_range_self _, Dy‚ü©
  linarith


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):
:= by
  refine le_of_forall_pos_le_add fun Œ¥ Œ¥0 => ?_
  rcases exists_mem_of_nonempty X with ‚ü®xX, _‚ü©
  rcases hs xX with ‚ü®xs, hxs, Dxs‚ü©
  have sne : s.Nonempty := ‚ü®xs, hxs‚ü©
  letI : Nonempty s := sne.to_subtype
  have : 0 ‚â§ Œµ‚ÇÇ := le_trans (abs_nonneg _) (H ‚ü®xs, hxs‚ü© ‚ü®xs, hxs‚ü©)
  have : ‚àÄ p q : s, |dist p q - dist (Œ¶ p) (Œ¶ q)| ‚â§ 2 * (Œµ‚ÇÇ / 2 + Œ¥) := fun p q =>
    calc
      |dist p q - dist (Œ¶ p) (Œ¶ q)| ‚â§ Œµ‚ÇÇ := H p q
      _ ‚â§ 2 * (Œµ‚ÇÇ / 2 + Œ¥) := by linarith
  letI : MetricSpace (Sum X Y) :=
    glueMetricApprox (fun x : s => (x : X)) (fun x => Œ¶ x) (Œµ‚ÇÇ / 2 + Œ¥) (by linarith) this
  let Fl := @Sum.inl X Y
  let Fr := @Sum.inr X Y
  have Il : Isometry Fl := Isometry.of_dist_eq fun x y => rfl
  have : ghDist X Y ‚â§ hausdorffDist (range Fl) (range Fr) ‚â§
      hausdorffDist (range Fl) := (isCompact_range Ir.continuous).isBounded
    hausdorffDist_triangle'
      (hausdorffEdist_ne_top_of_nonempty_of_bounded (range_nonempty _) (sne.image _) B
        (B.subset (image_subset_range _ _)))
  have :
    hausdorffDist (Fl '' s) (range Fr) ‚â§
      hausdorffDist (Fl '' s) (Fr '' range Œ¶) + hausdorffDist (Fr '' range Œ¶) (range Fr) :=
    have B : IsBounded (range Fr) := (isCompact_range Ir.continuous).isBounded
    hausdorffDist_triangle'
      (hausdorffEdist_ne_top_of_nonempty_of_bounded (range_nonempty _) (sne.image _) B
        (B.subset (image_subset_range _ _)))
  have :
    hausdorffDist (Fl '' s) (range Fr) ‚â§
      hausdorffDist (Fl '' s) (Fr '' range Œ¶) + hausdorffDist (Fr '' range Œ¶) (range Fr) :=
    have B : IsBounded (range Fr) := (isCompact_range Ir.continuous).isBounded
    hausdorffDist_triangle'
      (hausdorffEdist_ne_top_of_nonempty_of_bounded ((range_nonempty _).image _) (range_nonempty _)
        (B.subset (image_subset_range _ _)) B)
  have : hausdorffDist (range Fl) (Fl '' s) ‚â§ Œµ‚ÇÅ := by
    rw [‚Üê image_univ, hausdorffDist_image Il]
    have : 0 ‚â§ Œµ‚ÇÅ := le_trans dist_nonneg Dxs
    refine hausdorffDist_le_of_mem_dist this (fun x _ => hs x) fun x _ =>
      ‚ü®x, mem_univ _, by simpa only [dist_self]‚ü©
  have : hausdorffDist (Fl '' s) (Fr '' range Œ¶) ‚â§ Œµ‚ÇÇ / 2 + Œ¥ := by
    refine hausdorffDist_le_of_mem_dist (by linarith) ?_ ?_
    ¬∑ intro x' hx'
      rcases (Set.mem_image _ _ _).1 hx' with ‚ü®x, ‚ü®x_in_s, xx'‚ü©‚ü©
      rw [‚Üê xx']
      use Fr (Œ¶ ‚ü®x, x_in_s‚ü©), mem_

Attempt failure.

Working on Mathlib/Topology/PartitionOfUnity.lean - 2024-09-07 22:09:49.855400.
---96/100---
For theorem PartitionOfUnity.exists_isSubordinate in Mathlib/Topology/PartitionOfUnity.lean:
theorem exists_isSubordinate_of_locallyFinite_of_prop [NormalSpace X] (p : (X ‚Üí ‚Ñù) ‚Üí Prop)
    (h01 : ‚àÄ s t, IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí
      ‚àÉ f : C(X, ‚Ñù), p f ‚àß EqOn f 0 s ‚àß EqOn f 1 t ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1)
    (hs : IsClosed s) (U : Œπ ‚Üí Set X) (ho : ‚àÄ i, IsOpen (U i)) (hf : LocallyFinite U)
    (hU : s ‚äÜ ‚ãÉ i, U i) : ‚àÉ f : BumpCovering Œπ X s, (‚àÄ i, p (f i)) ‚àß f.IsSubordinate U 


Original valid proof:
:= by
  rcases exists_subset_iUnion_closure_subset hs ho (fun x _ => hf.point_finite x) hU with
    ‚ü®V, hsV, hVo, hVU‚ü©
  have hVU' : ‚àÄ i, V i ‚äÜ U i := fun i => Subset.trans subset_closure (hVU i)
  rcases exists_subset_iUnion_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)
      hsV with
    ‚ü®W, hsW, hWo, hWV‚ü©
  choose f hfp hf0 hf1 hf01 using fun i =>
    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure
      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))
  have hsupp : ‚àÄ i, support (f i) ‚äÜ V i := fun i => support_subset_iff'.2 (hf0 i)
  refine ‚ü®‚ü®f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,
      fun i x => (hf01 i x).2, fun x hx => ?_‚ü©,
    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)‚ü©
  rcases mem_iUnion.1 (hsW hx) with ‚ü®i, hi‚ü©
  exact ‚ü®i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)‚ü©


Verifying proof (Commit 47189ba3b5745e8b76312e34fe4a6c87e0d76e90):
:= by
  rcases exists_subset_union_closure_subset hs ho (fun x _ => hf.point_finite x) hU with
    ‚ü®V, hsV, hVo, hVU‚ü©
  have hVU' : ‚àÄ i, V i ‚äÜ U i := fun i => Subset.trans subset_closure (hVU i)
  rcases exists_subset_union_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)
      hsV with
    ‚ü®W, hsW, hWo, hWV‚ü©
  choose f hfp hf0 hf1 hf01 using fun i =>
    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure
      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))
  have hsupp : ‚àÄ i, support (f i) ‚äÜ V i := fun i => support_subset_iff'.2 (hf0 i)
  refine ‚ü®‚ü®f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,
      fun i x => (hf01 i x).2, fun x hx => ?_‚ü©,
    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)‚ü©
  rcases mem_union·µ¢.1 (hsW hx) with ‚ü®i, hi‚ü©
  exact ‚ü®i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)‚ü©

Attempt failure.

Working on Mathlib/Topology/QuasiSeparated.lean - 2024-09-07 22:09:58.739472.
---97/100---
For theorem IsQuasiSeparated.image_of_embedding in Mathlib/Topology/QuasiSeparated.lean:
theorem IsQuasiSeparated.image_of_embedding {s : Set Œ±} (H : IsQuasiSeparated s) (h : Embedding f) :
    IsQuasiSeparated (f '' s) 


Original valid proof:
:= by
  intro U V hU hU' hU'' hV hV' hV''
  convert
    (H (f ‚Åª¬π' U) (f ‚Åª¬π' V)
      ?_ (h.continuous.1 _ hU') ?_ ?_ (h.continuous.1 _ hV') ?_).image h.continuous
  ¬∑ symm
    rw [‚Üê Set.preimage_inter, Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact Set.inter_subset_left.trans (hU.trans (Set.image_subset_range _ _))
  ¬∑ intro x hx
    rw [‚Üê h.inj.injOn.mem_image_iff (Set.subset_univ _) trivial]
    exact hU hx
  ¬∑ rw [h.isCompact_iff]
    convert hU''
    rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact hU.trans (Set.image_subset_range _ _)
  ¬∑ intro x hx
    rw [‚Üê h.inj.injOn.mem_image_iff (Set.subset_univ _) trivial]
    exact hV hx
  ¬∑ rw [h.isCompact_iff]
    convert hV''
    rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact hV.trans (Set.image_subset_range _ _)


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
:= by
  intro U V hU hU' hU'' hV hV' hV''
  convert
    (H (f ‚Åª¬π' U) (f ‚Åª¬π' V)
      ?_ (h.continuous.1 _ hU') ?_ ?_ (h.continuous.1 _ hU') ?_ ?_ (h.continuous.1 _ hV') ?_).image h.continuous
  ¬∑ symm
    rw [‚Üê Set.preimage_inter, Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact hU.trans Set.image_subset_range _ _)
  ¬∑ intro x hx
    rw [‚Üê (h.inj.injOn _).mem_image_iff (Set.subset_univ _) trivial]
    exact hV hx
  ¬∑ rw [h.isCompact_iff]
    convert hV''
    rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact hV.trans Set.image_subset_range _ _)

Attempt failure.

Working on Mathlib/Topology/Separation/NotNormal.lean - 2024-09-07 22:10:03.669193.
---98/100---
For theorem IsClosed.mk_lt_continuum in Mathlib/Topology/Separation/NotNormal.lean:
theorem IsClosed.mk_lt_continuum [NormalSpace X] {s : Set X} (hs : IsClosed s)
    [DiscreteTopology s] : #s < ùî† 


Original valid proof:
:= by
  by_contra! h
  rcases exists_countable_dense X with ‚ü®t, htc, htd‚ü©
  haveI := htc.to_subtype
  refine (Cardinal.cantor ùî†).not_le ?_
  calc
    2 ^ ùî† ‚â§ #C(s, ‚Ñù) := by
      rw [(ContinuousMap.equivFnOfDiscrete _ _).cardinal_eq, mk_arrow, mk_real, lift_continuum,
        lift_uzero]
      exact (power_le_power_left two_ne_zero h).trans (power_le_power_right (nat_lt_continuum 2).le)
    _ ‚â§ #C(X, ‚Ñù) := by
      choose f hf using ContinuousMap.exists_restrict_eq (Y := ‚Ñù) hs
      have hfi : Injective f := LeftInverse.injective hf
      exact mk_le_of_injective hfi
    _ ‚â§ #C(t, ‚Ñù) := mk_le_of_injective <| ContinuousMap.injective_restrict htd
    _ ‚â§ #(t ‚Üí ‚Ñù) := mk_le_of_injective DFunLike.coe_injective
    _ ‚â§ ùî† := by
      rw [mk_arrow, mk_real, lift_uzero, lift_continuum, continuum, ‚Üê power_mul]
      exact power_le_power_left two_ne_zero mk_le_aleph0


Verifying proof (Commit 161c69c1dbf66cf3c7ec4f648a61551d044a43e4):
:= by
  by_contra! h
  rcases exists_countable_dense X with ‚ü®t, htc, htd‚ü©
  haveI := htc.to_subtype
  refine (Cardinal.cantor ùî†).not_le ?_
  calc
    2 ^ ùî† ‚â§ #C(s, ‚Ñù) := by
      rw [(ContinuousMap.equivFnOfDiscrete _ _).cardinal_eq, mk_arrow, mk_real, lift_continuum,
        lift_uzero]
      exact (power_le_power_left two_ne_zero h).trans (power_le_power_right (nat_lt_continuum 2).le)
    _ ‚â§ #C(X, ‚Ñù) := by
      choose f hf using (ContinuousMap.exists_restrict_eq_of_closed ¬∑ hs)
      have hfi : Injective f := LeftInverse.injective hf
      exact mk_le_of_injective hfi
    _ ‚â§ #C(t, ‚Ñù) := mk_le_of_injective <| ContinuousMap.injective_restrict htd
    _ ‚â§ #(t ‚Üí ‚Ñù) := mk_le_of_injective DFunLike.coe_injective
    _ ‚â§ ùî† := by
      rw [mk_arrow, mk_real, lift_uzero, lift_continuum, continuum, ‚Üê power_mul]
      exact power_le_power_left two_ne_zero mk_le_aleph0

Attempt failure.

Working on Mathlib/Topology/UniformSpace/Basic.lean - 2024-09-07 22:10:10.545843.
---99/100---
For theorem ball_inter_left in Mathlib/Topology/UniformSpace/Basic.lean:
theorem ball_inter_left (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x V 


Original valid proof:
:=
  ball_mono inter_subset_left x


Verifying proof (Commit f33a8c19a1c116af0ea9bb6af0c85b1ef25cb15f):
:=
  ball_mono inter_subset_left x

Attempt success.

Working on Mathlib/Topology/UniformSpace/UniformEmbedding.lean - 2024-09-07 22:10:21.013604.
---100/100---
For theorem uniformEmbedding_inl in Mathlib/Topology/UniformSpace/UniformEmbedding.lean:
theorem uniformEmbedding_inl : UniformEmbedding (Sum.inl : Œ± ‚Üí Œ± ‚äï Œ≤) 


Original valid proof:
:=
  uniformEmbedding_iff'.2 ‚ü®Sum.inl_injective, uniformContinuous_inl, fun s hs =>
    ‚ü®Prod.map Sum.inl Sum.inl '' s ‚à™ range (Prod.map Sum.inr Sum.inr),
      union_mem_sup (image_mem_map hs) range_mem_map,
      fun x h => by simpa [Prod.map_apply'] using h‚ü©‚ü©


Verifying proof (Commit 2ba547a6481ef513d87a606a16c441262be9e648):
:=
  uniformEmbedding_iff'.2 ‚ü®Sum.inl_injective, uniformContinuous_inl, fun s hs =>
    ‚ü®Prod.map Sum.inl Sum.inl '' s ‚à™ range (Prod.map Sum.inr Sum.inr),
      union_mem_sup (image_mem_map hs) range_mem_map, fun x h => by simpa using h‚ü©‚ü©

Attempt failure.

STARTING: Lean repo copy removal
DONE: Lean repo copy removal
Among 100 proof attempts, there were 7 successful and 93 failed attempts at proving their respect theorems.
The rate of successful proof = 0.07.
