STARTING: verification of proofs from predicted_proof column in dataset from models/deepseek_sft_proving/finetuned/test_random_deepseek_sft_proving_tuned_prediction.csv - 2024-09-09 00:05:02.147952
STARTING: Lean repo copy creation
DONE: Lean repo copy creation
STARTING: retrieve cache
installing leantar 0.1.13
Attempting to download 4738 file(s)
Decompressing 4738 file(s)
Unpacked in 200423 ms
Completed successfully!
DONE: retrieved cache
Working on Mathlib/Algebra/DirectSum/Module.lean - 2024-09-09 00:22:49.363304.
---1/200---
For theorem DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top in Mathlib/Algebra/DirectSum/Module.lean:
theorem isInternal_submodule_of_independent_of_iSup_eq_top {A : ι → Submodule R M}
    (hi : CompleteLattice.Independent A) (hs : iSup A = ⊤) : IsInternal A 


Original valid proof:
:=
  ⟨hi.dfinsupp_lsum_injective,
    (LinearMap.range_eq_top (f := DFinsupp.lsum _ _)).1 <|
      (Submodule.iSup_eq_range_dfinsupp_lsum _).symm.trans hs⟩


Verifying proof (Commit 161c69c1dbf66cf3c7ec4f648a61551d044a43e4):
↔ ∀ i, IsCompl (A i) (⨅ i ≠ i, A i) :=
  isInternal_submodule_iff_independent_and_iSup_eq_top.trans
    ⟨fun ⟨hid, hs⟩ i =>
      (hid i).setIndependent_right_of_independent
        ((hi.set_independent_of_iSup_eq_top hs).mono (Set.subset_univ _)) fun j _ =>
        SetLike.le_def.1 (hs ▸ le_iSup A j : A i ≤ _),
      fun h => ⟨fun i => (h i).disjoint_left, hs⟩⟩

Repaired Proof:
theorem isInternal_submodule_of_independent_of_iSup_eq_top {A : ι → Submodule R M}
    (hi : CompleteLattice.Independent A) (hs : iSup A = ⊤) : IsInternal A ↔ ∀ i, IsCompl (A i) (⨅ i ≠ i, A i) :=
  isInternal_submodule_iff_independent_and_iSup_eq_top.trans
    ⟨fun ⟨hid, hs⟩ i =>
      (hid i).setIndependent_right_of_independent
        ((hi.set_independent_of_iSup_eq_top hs).mono Set.subset_univ),
      fun h => ⟨fun i => (h i).disjoint_left, hs⟩⟩

Repaired Proof:
theorem isInternal_submodule_of_independent_of_iSup_eq_top {A : ι → Submodule R M}
    (hi : CompleteLattice.Independent A) (hs : iSup A = ⊤) : IsInternal A ↔ ∀ i, IsCompl (A i) (⨅ i ≠ i, A i) :=
  isInternal_submodule_iff_independent_and_iSup_eq_top.trans
    ⟨fun ⟨hid, hs⟩ i =>
      (hid i).setIndependent_right_of_independent
        ((hi.set_independent_of_iSup_eq_top hs).mono Set.subset_univ),
      fun h => ⟨fun i => (h i).disjoint_left, hs⟩⟩

Attempt failure.

Working on Mathlib/Algebra/Homology/Localization.lean - 2024-09-09 00:23:16.218699.
---2/200---
For theorem ComplexShape.QFactorsThroughHomotopy_of_exists_prev in Mathlib/Algebra/Homology/Localization.lean:
lemma ComplexShape.QFactorsThroughHomotopy_of_exists_prev [CategoryWithHomology C] :
    c.QFactorsThroughHomotopy C where



Original valid proof:
  areEqualizedByLocalization {K L f g} h := by
    have : DecidableRel c.Rel := by classical infer_instance
    exact h.map_eq_of_inverts_homotopyEquivalences hc _
      (MorphismProperty.IsInvertedBy.of_le _ _ _
        (Localization.inverts _ (HomologicalComplex.quasiIso C _))
        (homotopyEquivalences_le_quasiIso C _))


Verifying proof (Commit 1cb1056b5a19f416d3fae3469d51eedb4f5b48cb):
  factors_of_zero _ _ _ _ _ h := factors_of_zero _ _ _ _ _ h
  factors_of_comp_left _ _ _ _ _ _ _ _ h := factors_of_comp_left _ _ _ _ _ _ _ _ h
  factors_of_comp_right _ _ _ _ _ _ _ _ h := factors_of_comp_right _ _ _ _ _ _ _ _ h
  factors_of_d_comp_d _ _ _ _ _ _ _ h := factors_of_d_comp_d _ _ _ _ _ _ h
  factors_of_comp_d _ _ _ _ _ _ _ h := factors_of_comp_d _ _ _ _ _ _ _ h
  factors_of_d_comp_d' _ _ _ _ _ _ _ h := factors_of_d_comp_d' _ _ _ _ _ _ _ h
  factors_of_comp_d' _ _ _ _ _ _ _ h := factors_of_comp_d' _ _ _ _ _ _ _ h
  factors_of_d_comp_d'' _ _ _ _ _ _ _ h := factors_of_d_comp_d'' _ _ _ _ _ _ _ h
  factors_of_comp_d'' _ _ _ _ _ _ _ h := factors_of_comp_d'' _ _ _ _ _ _ _ h
  factors_of_d_comp_d''' _ _ _ _ _ _ _ h := factors_of_d_comp_d''' _ _ _ _ _ _ _ h
  factors_of_comp_d''' _ _ _ _ _ _ _ h := factors_of_comp_d''' _ _ _ _ _ _ _ h
  factors_of_d_comp_d'''' _ _ _ _ _ _ _ h := factors_of_d_comp_d'''' _ _ _ _ _ _ _ h
  factors_of_comp_d'''' _ _ _ _ _ _ _ h := factors_of_comp_d'''' _ _ _ _ _ _ _ h

Repaired Proof:
lemma ComplexShape.QFactorsThroughHomotopy_of_exists_prev [CategoryWithHomology C] :
    c.QFactorsThroughHomotopy C where
  factors_of_zero _ _ _ _ _ h := factors_of_zero _ _ _ _ _ h
  factors_of_comp_left _ _ _ _ _ _ _ _ h := factors_of_comp_left _ _ _ _ _ _ _ _ h
  factors_of_comp_right _ _ _ _ _ _ _ _ h := factors_of_comp_right _ _ _ _ _ _ _ _ h
  factors_of_d_comp_d _ _ _ _ _ _ _ h := factors_of_d_comp_d _ _ _ _ _ _ h
  factors_of_comp_d _ _ _ _ _ _ _ h := factors_of_comp_d _ _ _ _ _ _ _ h
  factors_of_d_comp_d' _ _ _ _ _ _ _ h := factors_of_d_comp_d' _ _ _ _ _ _ _ h
  factors_of_comp_d' _ _ _ _ _ _ _ h := factors_of_comp_d' _ _ _ _ _ _ _ h
  factors_of_d_comp_d'' _ _ _ _ _ _ _ h := factors_of_d_comp_d'' _ _ _ _ _ _ _ h
  factors_of_comp_d'' _ _ _ _ _ _ _ h := factors_of_comp_d'' _ _ _ _ _ _ _ h
  factors_of_d_comp_d''' _ _ _ _ _ _ _ h := factors_of_d_comp_d''' _ _ _ _ _ _ _ h
  factors_of_comp_d''' _ _ _ _ _ _ _ h := factors_of_comp_d''' _ _ _ _ _ _ _ h
  factors_of_d_comp_d'''' _ _ _ _ _ _ _ h := factors_of_d_comp_d'''' _ _ _ _ _ _ _ h
  factors_of_comp_d'''' _ _ _ _ _ _ _ h := factors_of_comp_d'''' _ _ _ _ _ _ _ h

Repaired Proof:
lemma ComplexShape.QFactorsThroughHomotopy_of_exists_prev [CategoryWithHomology C] :
    c.QFactorsThroughHomotopy C where
  factors_of_zero _ _ _ _ _ h := factors_of_zero _ _ _ _ _ h
  factors_of_comp_left _ _ _ _ _ _ _ _ h := factors_of_comp_left _ _ _ _ _ _ _ _ h
  factors_of_comp_right _ _ _ _ _ _ _ _ h := factors_of_comp_right _ _ _ _ _ _ _ _ h
  factors_of_d_comp_d _ _ _ _ _ _ _ h := factors_of_d_comp_d _ _ _ _ _ _ h
  factors_of_comp_d _ _ _ _ _ _ _ h := factors_of_comp_d _ _ _ _ _ _ _ h
  factors_of_d_comp_d' _ _ _ _ _ _ _ h := factors_of_d_comp_d' _ _ _ _ _ _ _ h
  factors_of_comp_d' _ _ _ _ _ _ _ h := factors_of_comp_d' _ _ _ _ _ _ _ h
  factors_of_d_comp_d'' _ _ _ _ _ _ _ h := factors_of_d_comp_d'' _ _ _ _ _ _ _ h
  factors_of_comp_d'' _ _ _ _ _ _ _ h := factors_of_comp_d'' _ _ _ _ _ _ _ h
  factors_of_d_comp_d''' _ _ _ _ _ _ _ h := factors_of_d_comp_d''' _ _ _ _ _ _ _ h
  factors_of_comp_d''' _ _ _ _ _ _ _ h := factors_of_comp_d''' _ _ _ _ _ _ _ h
  factors_of_d_comp_d'''' _ _ _ _ _ _ _ h := factors_of_d_comp_d'''' _ _ _ _ _ _ _ h
  factors_of_comp_d'''' _ _ _ _ _ _ _ h := factors_of_comp_d'''' _ _ _ _ _ _ _ h

Repaired Proof:
lemma ComplexShape.QFactorsThroughHomotopy_of_exists_prev [CategoryWithHomology C] :
    c.QFactorsThroughHomotopy C where
  factors_of_zero _ _ _ _ _ h := factors_of_zero _ _ _ _ _ h
  factors_of_comp_left _ _ _ _ _ _ _ _ h := factors_of_comp_left _ _ _ _ _ _ _ _ h
  factors_of_comp_right _ _ _ _ _ _ _ _ h := factors_of_comp_right _ _ _ _ _ _ _ _ h
  factors_of_d_comp_d _ _ _ _ _ _ _ h := factors_of_d_comp_d _ _ _ _ _ _ h
  factors_of_comp_d _ _ _ _ _ _ _ h := factors_of_comp_d _ _ _ _ _ _ _ h
  factors_of_d_comp_d' _ _ _ _ _ _ _ h := factors_of_d_comp_d' _ _ _ _ _ _ _ h
  factors_of_comp_d' _ _ _ _ _ _ _ h := factors_of_comp_d' _ _ _ _ _ _ _ h
  factors_of_d_comp_d'' _ _ _ _ _ _ _ h := factors_of_d_comp_d'' _ _ _ _ _ _ _ h
  factors_of_comp_d'' _ _ _ _ _ _ _ h := factors_of_comp_d'' _ _ _ _ _ _ _ h
  factors_of_d_comp_d''' _ _ _ _ _ _ _ h := factors_of_d_comp_d''' _ _ _ _ _ _ _ h
  factors_of_comp_d''' _ _ _ _ _ _ _ h := factors_of_comp_d''' _ _ _ _ _ _ _ h
  factors_of_d_comp_d'''' _ _ _ _ _ _ _ h := factors_of_d_comp_d'''' _ _ _ _ _ _ _ h
  factors_of_comp_d'''' _ _ _ _ _ _ _ h := factors_of_comp_d'''' _ _ _ _ _ _ _ h

Repaired Proof:
lemma ComplexShape.QFactorsThroughHomotopy_of_exists_prev [CategoryWithHomology C] :
    c.QFactorsThroughHomotopy C where
  factors_of_zero _ _ _ _ _ h := factors_of_zero _ _ _ _ _ h
  factors_of_comp_left _ _ _ _ _ _ _ _ h := factors_of_comp_left _ _ _ _ _ _ _ _ h
  factors_of_comp_right _ _ _ _ _ _ _ _ h := factors_of_comp_right _ _ _ _ _ _ _ _ h
  factors_of_d_comp_d _ _ _ _ _ _ _ h := factors_of_d_comp_d _ _ _ _ _ _ h
  factors_of_comp_d _ _ _ _ _ _ _ h := factors_of_

Attempt failure.

Working on Mathlib/Algebra/Homology/QuasiIso.lean - 2024-09-09 00:23:31.002959.
---3/200---
For theorem quasiIsoAt_iff' in Mathlib/Algebra/Homology/QuasiIso.lean:
lemma quasiIsoAt_iff' (f : K ⟶ L) (i j k : ι) (hi : c.prev j = i) (hk : c.next j = k)
    [K.HasHomology j] [L.HasHomology j] [(K.sc' i j k).HasHomology] [(L.sc' i j k).HasHomology] :
    QuasiIsoAt f j ↔
      ShortComplex.QuasiIso ((shortComplexFunctor' C c i j k).map f) 


Original valid proof:
:= by
  rw [quasiIsoAt_iff]
  exact ShortComplex.quasiIso_iff_of_arrow_mk_iso _ _
    (Arrow.isoOfNatIso (natIsoSc' C c i j k hi hk) (Arrow.mk f))


Verifying proof (Commit 4773ba7abb162ea632c1ff5810cd5f45a1289422):
∧
        ShortComplex.QuasiIso ((shortComplexFunctor' C c i j k).map (K.homologyπ j)) ∧
          ShortComplex.QuasiIso ((shortComplexFunctor' C c i j k).map (L.homologyπ j)) := by
  simp only [quasiIsoAt_iff, ← quasiIso_map_iff,
    shortComplexFunctor'_map_f_f' _ _ _ _ _ _ hi hk,
    shortComplexFunctor'_map_g_f' _ _ _ _ _ _ hi hk,
    shortComplexFunctor'_map_f_g' _ _ _ _ _ _ hi hk,
    shortComplexFunctor'_map_g_g' _ _ _ _ _ _ hi hk]
  tauto

lemma quasiIsoAt_iff_of_arrow_mk_iso (φ : Arrow (HomologicalComplex C c))
    (hφ : HomologicalComplex.quasiIso φ.f) (i : ι) [K.HasHomology i] [L.HasHomology i]
    [((shortComplexFunctor C c i).map φ.f).QuasiIso] :
    QuasiIsoAt φ.f i ↔
      ShortComplex.QuasiIso ((shortComplexFunctor C c i).map φ.f) := by
  have : QuasiIso φ.f := hφ
  constructor
  · intro
    infer_instance
  · intro
    have : QuasiIso φ.f := by
      apply quasiIso_of_shortComplex_quasiIso
      exact inferInstance
    exact quasiIsoAt_iff.mpr this i

lemma quasiIsoAt_iff_of_arrow_mk_iso' (φ : Arrow (HomologicalComplex C c))
    (hφ : HomologicalComplex.quasiIso φ.f) (i j k : ι) (hi : c.prev j = i) (hk : c.next j = k)
    [K.HasHomology j] [L.HasHomology j]
    [((shortComplexFunctor' C c i j k).map φ.f).QuasiIso] :
    QuasiIsoAt φ.f j ↔
      ShortComplex.QuasiIso ((shortComplexFunctor' C c i j k).map φ.f) := by
  have : QuasiIso φ.f := hφ
  constructor
  · intro
    infer_instance
  · intro
    have : QuasiIso φ.f := by
      apply quasiIso_of_shortComplex_quasiIso'
      exact inferInstance
    exact quasiIsoAt_iff' φ.f i j k hi hk

lemma quasiIsoAt_iff_of_arrow_mk_iso_left (φ : Arrow (HomologicalComplex C c))
    (hφ : HomologicalComplex.quasiIso φ.f) (i : ι) [K.HasHomology i]
    [((shortComplexFunctor C c i).map φ.f).QuasiIso] :
    QuasiIsoAt φ.f i ↔
      ShortComplex.QuasiIso ((shortComplexFunctor C c i).map φ.f) := by
  have : QuasiIso φ.f := hφ
  constructor
  · intro
    infer_instance
  · intro
    have : QuasiIso φ.f := by
      apply quasiIso_of_shortComplex_quasiIso
      exact inferInstance
    exact quasiIsoAt_iff.mpr this i

lemma quasiIsoAt_iff_of_arrow_mk_iso_left' (φ : Arrow (HomologicalComplex C c))
    (hφ : HomologicalComplex.quasiIso φ.f) (i j k : ι) (hi : c.prev j = i) (hk : c.next j = k)
    [K.HasHomology j]
    [((shortComplexFunctor' C c i j k).map φ.f).QuasiIso] :
    QuasiIsoAt φ.f j ↔
      ShortComplex.QuasiIso ((shortComplexFunctor' C c i j k).map φ.f) := by
  have : QuasiIso φ.f := hφ
  constructor
  · intro
    infer_instance
  · intro
    have : QuasiIso φ.f := by
      apply quasiIso_of_shortComplex_quasiIso'
      exact inferInstance
    exact quasiIsoAt_iff' φ.f i j k hi hk

lemma quasiIsoAt_iff_of_arrow_mk_iso_right (φ : Arrow (HomologicalComplex C c))
    (hφ : HomologicalComplex.quasiIso φ.f) (i : ι) [L.HasHomology i]
    [((shortComplexFunctor C c i).map φ.g).QuasiIso] :
    QuasiIsoAt φ.g i ↔
      ShortComplex.QuasiIso ((shortComplexFunctor C c i).map φ.g) := by
  have : QuasiIso φ.g := hφ
  constructor
  · intro
    infer_instance
  · intro
    have : QuasiIso φ.g := by
      apply quasiIso_of_shortComplex_quasiIso
      exact inferInstance
    exact quasiIsoAt_iff.mpr this i

lemma quasiIsoAt_iff_of_arrow_mk_iso_right' (φ : Arrow (HomologicalComplex C c))
    (hφ : HomologicalComplex.quasiIso φ.f) (i j k : ι) (hi : c.prev j = i) (hk : c.next j = k)
    [L.HasHomology j]
    [((shortComplexFunctor' C c i j k).map φ.g).QuasiIso] :
    QuasiIsoAt φ.g j ↔
      ShortComplex.QuasiIso ((shortComplexFunctor' C c i j k).map φ.g) := by
  have : QuasiIso φ.g := hφ
  constructor
  · intro
    infer_instance
  · intro
    have : QuasiIso φ.g := by
      apply quasiIso_of_shortComplex_quasiIso'
      exact inferInstance
    exact quasiIsoAt_iff' φ.g i j k hi hk

lemma quasiIsoAt_iff_of_arrow_mk_iso_both (φ : Arrow (HomologicalComplex C c))
    (hφ : HomologicalComplex.quasiIso φ.f) (hφ' : HomologicalComplex.quasiIso φ.g) (i : ι)
    [K.HasHomology i] [L.HasHomology i]
    [((shortComplexFunctor C c i).map φ.f).QuasiIso]
    [((shortComplexFunctor C c i).map φ.g).QuasiIso] :
    QuasiIsoAt φ.f i ↔
      ShortComplex.QuasiIso ((shortComplexFunctor C c i).map φ.f) ∧
        ShortComplex.QuasiIso ((shortComplexFunctor C c i).map φ.g) := by
  have : QuasiIso φ.f := hφ
  have : QuasiIso φ.g := hφ'
  constructor
  · intro
    infer_instance
  · intro
    have : QuasiIso φ.f := by
      apply quasiIso_of_shortComplex_quasiIso
      exact inferInstance
    have : QuasiIso φ.g := by
      apply quasiIso_of_shortComplex_quasiIso
      exact inferInstance
    exact ⟨quasiIsoAt_iff.mpr this i, quasiIsoAt_iff.mpr this i⟩

lemma quasiIsoAt_iff_of_arrow_mk_iso_both' (φ : Arrow (HomologicalComplex C c))
    (hφ : HomologicalComplex.quasiIso φ.f) (hφ' : HomologicalComplex.quasiIso φ.g) (i j k : ι)
    (hi : c.prev j = i) (hk : c.next j = k) [K.HasHomology j] [L.HasHomology j]
    [((shortComplexFunctor C c i).map φ.f).QuasiIso]
    [((shortComplexFunctor C c i).map φ.g).QuasiIso] :
    QuasiIsoAt φ.f j ↔
      ShortComplex.QuasiIso ((shortComplexFunctor C c i).map φ.f) ∧
        ShortComplex.QuasiIso ((shortComplexFunctor C c i).map φ.g) := by
  have : QuasiIso φ.f := hφ
  have : QuasiIso φ.g := hφ'
  constructor
  · intro
    infer_instance
  · intro
    have : QuasiIso φ.f := by
      apply quasiIso_of_shortComplex_quasiIso'
      exact inferInstance
    have : QuasiIso φ.g := by
      apply quasiIso_of_shortComplex_quasiIso'
      exact inferInstance
    exact ⟨quasiIsoAt_iff'.mpr this i j k hi hk, quasiIsoAt_iff'.mpr this i j k hi hk⟩

lemma quasiIsoAt_iff_of_arrow_mk_iso_both'' (φ : Arrow (HomologicalComplex C c))
    (hφ : HomologicalComplex.quasiIso φ.f) (h

Attempt failure.

Working on Mathlib/Algebra/Lie/Engel.lean - 2024-09-09 00:23:45.699854.
---4/200---
For theorem LieAlgebra.isEngelian_of_isNoetherian in Mathlib/Algebra/Lie/Engel.lean:
theorem LieAlgebra.isEngelian_of_isNoetherian [IsNoetherian R L] : LieAlgebra.IsEngelian R L 


Original valid proof:
:= by
  intro M _i1 _i2 _i3 _i4 h
  rw [← isNilpotent_range_toEnd_iff]
  let L' := (toEnd R L M).range
  replace h : ∀ y : L', _root_.IsNilpotent (y : Module.End R M) := by
    rintro ⟨-, ⟨y, rfl⟩⟩
    simp [h]
  change LieModule.IsNilpotent R L' M
  let s := {K : LieSubalgebra R L' | LieAlgebra.IsEngelian R K}
  have hs : s.Nonempty := ⟨⊥, LieAlgebra.isEngelian_of_subsingleton⟩
  suffices ⊤ ∈ s by
    rw [← isNilpotent_of_top_iff]
    apply this M
    simp [LieSubalgebra.toEnd_eq, h]
  have : ∀ K ∈ s, K ≠ ⊤ → ∃ K' ∈ s, K < K' := by
    rintro K (hK₁ : LieAlgebra.IsEngelian R K) hK₂
    apply LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer hK₁
    apply lt_of_le_of_ne K.le_normalizer
    rw [Ne, eq_comm, K.normalizer_eq_self_iff, ← Ne, ←
      LieSubmodule.nontrivial_iff_ne_bot R K]
    have : Nontrivial (L' ⧸ K.toLieSubmodule) := by
      replace hK₂ : K.toLieSubmodule ≠ ⊤ := by
        rwa [Ne, ← LieSubmodule.coe_toSubmodule_eq_iff, K.coe_toLieSubmodule,
          LieSubmodule.top_coeSubmodule, ← LieSubalgebra.top_coe_submodule,
          K.coe_to_submodule_eq_iff]
      exact Submodule.Quotient.nontrivial_of_lt_top _ hK₂.lt_top
    have : LieModule.IsNilpotent R K (L' ⧸ K.toLieSubmodule) := by
      apply hK₁
      intro x
      have hx := LieAlgebra.isNilpotent_ad_of_isNilpotent (h x)
      apply Module.End.IsNilpotent.mapQ ?_ hx
      intro X HX
      simp only [LieSubalgebra.coe_toLieSubmodule, LieSubalgebra.mem_coe_submodule] at HX
      simp only [LieSubalgebra.coe_toLieSubmodule, Submodule.mem_comap, ad_apply,
        LieSubalgebra.mem_coe_submodule]
      exact LieSubalgebra.lie_mem K x.prop HX
    exact nontrivial_max_triv_of_isNilpotent R K (L' ⧸ K.toLieSubmodule)
  haveI _i5 : IsNoetherian R L' := by
    refine isNoetherian_of_surjective L (LieHom.rangeRestrict (toEnd R L M)) ?_
    simp only [LieHom.range_coeSubmodule, LieHom.coe_toLinearMap, LinearMap.range_eq_top]
    exact LieHom.surjective_rangeRestrict (toEnd R L M)
  obtain ⟨K, hK₁, hK₂⟩ := (LieSubalgebra.wellFounded_of_noetherian R L').has_min s hs
  have hK₃ : K = ⊤ := by
    by_contra contra
    obtain ⟨K', hK'₁, hK'₂⟩ := this K hK₁ contra
    exact hK₂ K' hK'₁ hK'₂
  exact hK₃ ▸ hK₁


Verifying proof (Commit d16c7a879e758dc3aee434d847d69bfbaf9f30f0):
𝔤 := by
    intro I hI
    have hI' : IsNoetherian R I :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule I)
    have hI'' : IsNoetherian R (⊤ : LieSubalgebra R L) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I)) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ LieSubmodule.normalizer I)) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''''''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''''''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI''''''''''''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I))) :=
      IsNoetherian.isNoetherian_of_tower R (LieSubalgebra.toSubmodule ⊤)
    have hI'''''''''''''''''''''''''''''' : IsNoetherian R (⊤ : LieSubalgebra R (L ⧸ I ⧸ (⊤ : LieSubmodule I

Attempt failure.

Working on Mathlib/Algebra/MonoidAlgebra/Basic.lean - 2024-09-09 00:24:02.156147.
---5/200---
For theorem AddMonoidAlgebra.ringHom_ext' in Mathlib/Algebra/MonoidAlgebra/Basic.lean:
theorem ringHom_ext' {R} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G →+* R}
    (h₁ : f.comp singleOneRingHom = g.comp singleOneRingHom)
    (h_of :
      (f : MonoidAlgebra k G →* R).comp (of k G) = (g : MonoidAlgebra k G →* R).comp (of k G)) :
    f = g 


Original valid proof:
:=
  ringHom_ext (RingHom.congr_fun h₁) (DFunLike.congr_fun h_of)


Verifying proof (Commit 848a6055965ceeab03ba2c4d2d0e4e0e9b07c6e6):
 :=
  ringHom_ext h₁ h_of

@[simp]
theorem lift_single (f : k →+ R) (g : G →* R) (a : G) (b : k) :
    lift k G R f g (single a b) = f b * g a :=
  sum_single_index (by simp only [zero_mul, AddMonoidHom.map_zero])


theorem lift_of (f : k →+ R) (g : G →* R) (x : G) : lift k G R f g (of k G x) = g x :=
  lift_single _ _ _ _


theorem lift_of' (f : k →+ R) (g : G →* R) (x : G) : lift k G R f g (algebraMap k (MonoidAlgebra k G) x) =
    g x :=
  lift_of f g x


@[simp]
theorem lift_single_apply (f : k →+ R) (g : G →* R) (a : G) (b : k) :
    lift k G R f g (single a b) = f b * g a :=
  sum_single_index (by simp only [zero_mul, AddMonoidHom.map_zero])


@[simp]
theorem lift_symm_apply (F : MonoidAlgebra k G →+* R) (x : G) :
    (lift k G R).symm F x = F (single x 1) :=
  rfl


@[simp]
theorem lift_single (f : k →+ R) (g : G →* R) (a : G) (b : k) :
    lift k G R f g (single a b) = f b * g a :=
  sum_single_index (by simp only [zero_mul, AddMonoidHom.map_zero])


theorem lift_of (f : k →+ R) (g : G →* R) (x : G) : lift k G R f g (of k G x) = g x :=
  lift_single _ _ _ _


theorem lift_of' (f : k →+ R) (g : G →* R) (x : G) :
    lift k G R f g (algebraMap k (MonoidAlgebra k G) x) = g x :=
  lift_of f g x


@[simp]
theorem lift_single_apply (f : k →+ R) (g : G →* R) (a : G) (b : k) :
    lift k G R f g (single a b) = f b * g a :=
  sum_single_index (by simp only [zero_mul, AddMonoidHom.map_zero])


@[simp]
theorem lift_symm_apply (F : MonoidAlgebra k G →+* R) (x : G) :
    (lift k G R).symm F x = F (single x 1) :=
  rfl


@[simp]
theorem lift_apply_single (f : k →+ R) (g : G →* R) (a : G) (b : k) :
    lift k G R f g (single a b) = f b * g a :=
  sum_single_index (by simp only [zero_mul, AddMonoidHom.map_zero])


@[simp]
theorem lift_apply_single' (f : k →+ R) (g : G →* R) (a : G) (b : k) :
    lift k G R f g (Finsupp.single a b) = f b * g a :=
  sum_single_index (by simp only [zero_mul, AddMonoidHom.map_zero])


@[simp]
theorem lift_apply_single_one (f : k →+ R) (g : G →* R) (a : G) :
    lift k G R f g (Finsupp.single a 1) = g a := by
  rw [lift_apply_single, f.map_one, one_mul]


@[simp]
theorem lift_symm_apply_single_one (F : MonoidAlgebra k G →+* R) (a : G) :
    (lift k G R).symm F (Finsupp.single a 1) = F (Finsupp.single a 1) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_single (F : MonoidAlgebra k G →+* R) (a : G) (b : k) :
    (lift k G R).symm F (Finsupp.single a b) = F (Finsupp.single a b) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_of (F : MonoidAlgebra k G →+* R) (x : G) :
    (lift k G R).symm F (of k G x) = F (of k G x) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_of' (F : MonoidAlgebra k G →+* R) (x : G) :
    (lift k G R).symm F (algebraMap k (MonoidAlgebra k G) x) = F (algebraMap k (MonoidAlgebra k G) x) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_single' (F : MonoidAlgebra k G →+* R) (x : G) (r : k) :
    (lift k G R).symm F (Finsupp.single x r) = F (Finsupp.single x r) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_single_one' (F : MonoidAlgebra k G →+* R) (x : G) :
    (lift k G R).symm F (Finsupp.single x 1) = F (Finsupp.single x 1) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_of' (F : MonoidAlgebra k G →+* R) (x : G) :
    (lift k G R).symm F (of' k G x) = F (of' k G x) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_of'' (F : MonoidAlgebra k G →+* R) (x : G) :
    (lift k G R).symm F (algebraMap k (MonoidAlgebra k G) x) = F (algebraMap k (MonoidAlgebra k G) x) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_single'' (F : MonoidAlgebra k G →+* R) (x : G) (r : k) :
    (lift k G R).symm F (Finsupp.single x r) = F (Finsupp.single x r) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_single_one'' (F : MonoidAlgebra k G →+* R) (x : G) :
    (lift k G R).symm F (Finsupp.single x 1) = F (Finsupp.single x 1) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_of'' (F : MonoidAlgebra k G →+* R) (x : G) :
    (lift k G R).symm F (of'' k G x) = F (of'' k G x) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_of''' (F : MonoidAlgebra k G →+* R) (x : G) :
    (lift k G R).symm F (of' k G x) = F (of' k G x) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_symm_apply_algebraMap'' (F : MonoidAlgebra k G →+* R) (x : k) :
    (lift k G R).symm F (algebraMap k (MonoidAlgebra k G) x) = F (algebraMap k (MonoidAlgebra k G) x) :=
  (lift k G R).injective <| by simp


@[simp]
theorem lift_sym

Attempt failure.

Working on Mathlib/Algebra/Order/CauSeq/BigOperators.lean - 2024-09-09 00:24:35.370452.
---6/200---
For theorem IsCauSeq.geo_series in Mathlib/Algebra/Order/CauSeq/BigOperators.lean:
lemma geo_series [Nontrivial β] (x : β) (hx1 : abv x < 1) :
    IsCauSeq abv fun n ↦ ∑ m ∈ range n, x ^ m 


Original valid proof:
:= by
  have hx1' : abv x ≠ 1 := fun h ↦ by simp [h, lt_irrefl] at hx1
  refine of_abv ?_
  simp only [abv_pow abv, geom_sum_eq hx1']
  conv in _ / _ => rw [← neg_div_neg_eq, neg_sub, neg_sub]
  have : 0 < 1 - abv x := sub_pos.2 hx1
  refine @of_mono_bounded _ _ _ _ ((1 : α) / (1 - abv x)) 0 ?_ ?_
  · intro n _
    rw [abs_of_nonneg]
    · gcongr
      exact sub_le_self _ (abv_pow abv x n ▸ abv_nonneg _ _)
    refine div_nonneg (sub_nonneg.2 ?_) (sub_nonneg.2 <| le_of_lt hx1)
    exact pow_le_one _ (by positivity) hx1.le
  · intro n _
    rw [← one_mul (abv x ^ n), pow_succ']
    gcongr


Verifying proof (Commit 03690a4c3252f422184189d0b6a6dd8d1c55d551):
∧ ∑' m, x ^ m = (1 - x)⁻¹ := by
  have hx0 : x ≠ 0 := fun h ↦ zero_ne_one ((zero_lt_one' β).trans_le (abv_nonneg abv h).le)
  have hx1' : abv x < 1 := mod_cast hx1
  have H : ∀ n, abv (1 - x)⁻¹ = abv (1 - x)⁻¹ ^ n := fun n ↦ by rw [← pow_succ, pow_succ']
  have H₁ : ∀ n, abv x ^ n = abv (x ^ n) := fun n ↦ by rw [abv_pow abv]
  have H₂ : ∀ n, abv (1 - x) ^ n = abv ((1 : β) - x ^ n) := fun n ↦ by rw [abv_pow abv]
  have H₃ : ∀ n, abv (1 - x) ^ n = abv (1 - x ^ n) := fun n ↦ by
    rw [H₂ n, ← abv_pow abv, sub_pow_of_commute (one_sub_mul_geom_sum_Ico_succ_eq_sub _ hx0 _).symm]
  have : IsCauSeq abv fun n ↦ ∑ m ∈ range n, x ^ m := by
    refine' IsCauSeq.abv_pos _ _ _ fun ε ε0 ↦ _
    obtain ⟨N, hN⟩ : ∃ N, ∀ {m n}, N ≤ m → N ≤ n → abv (1 - x ^ m) < ε :=
      mod_cast IsCauSeq.abv_pos (IsCauSeq.of_abv_geometric abv hx1') _ _ fun ε ε0 ↦
        let ⟨N, hN⟩ := IsCauSeq.abv_pos (IsCauSeq.geometric abv hx1') _ ε0
        ⟨N, fun {m n} hm hn ↦ hN hm hn⟩
    refine' ⟨N, fun n hn ↦ _⟩
    rw [map_sum (abv : β →*₀ α) (fun m ↦ x ^ m) (range n), abv_add abv, sum_range_succ']
    refine' lt_of_le_of_lt (add_le_add_right ((map_sum abv.toMonoidHom
      (fun m ↦ x ^ m) (range n)).symm ▸ abv_sum_le_sum_abv _ _) _) _
    simpa only [H, H₁, H₃] using hN hn (le_refl N)
  refine' ⟨this, _⟩
  have : ∀ n, abv (1 - x) * abv (1 - x) ^ n = abv (1 - x ^ n.succ) := by
    intro n
    rw [pow_succ', ← H₃, ← H, abv_mul abv]
    simp
  have h : Tendsto (fun n ↦ abv (1 - x) ^ n) atTop (𝓝 0) :=
    mod_cast IsCauSeq.tendsto_abv_sub_abv_of_pos (IsCauSeq.of_abv_geometric abv hx1')
      (sub_lt_self _ hx1')
  rw [← geom_sum_mul_neg, ← abv_inv abv, abv_inj abv hx0, inv_mul_eq_div, div_self hx0,
    abv_one abv, map_one] at h
  exact abv_eq_of_abv_sub_le_abv_sub _ _ _
    (IsCauSeq.abv_pos this _ _ fun ε ε0 ↦ let ⟨i, hi⟩ := h ε ε0; ⟨i, hi⟩)

Repaired Proof:
lemma geo_series [Nontrivial β] (x : β) (hx1 : abv x < 1) :
    IsCauSeq abv fun n ↦ ∑ m ∈ range n, x ^ m ∧ ∑' m, x ^ m = (1 - x)⁻¹ := by
  have hx0 : x ≠ 0 := fun h ↦ zero_ne_one ((zero_lt_one' β).trans_le (abv_nonneg abv h).le)
  have hx1' : abv x < 1 := mod_cast hx1
  have H : ∀ n, abv (1 - x)⁻¹ = abv (1 - x)⁻¹ ^ n := fun n ↦ by rw [← pow_succ, pow_succ']
  have H₁ : ∀ n, abv x ^ n = abv (x ^ n) := fun n ↦ by rw [abv_pow abv]
  have H₂ : ∀ n, abv (1 - x) ^ n = abv ((1 : β) - x ^ n) := fun n ↦ by rw [abv_pow abv]
  have H₃ : ∀ n, abv (1 - x) ^ n = abv (1 - x ^ n) := fun n ↦ by
    rw [H₂ n, ← abv_pow abv, sub_pow_of_commute (one_sub_mul_geom_sum_Ico_succ_eq_sub _ hx0 _).symm]
  have : IsCauSeq abv fun n ↦ ∑ m ∈ range n, x ^ m := by
    refine IsCauSeq.abv_pos _ _ _ fun ε ε0 ↦ ?_
    obtain ⟨N, hN⟩ : ∃ N, ∀ {m n}, N ≤ m → N ≤ n → abv (1 - x ^ m) < ε :=
      mod_cast IsCauSeq.abv_pos (IsCauSeq.of_abv_geometric abv hx1') _ _ fun ε ε0 ↦
        let ⟨N, hN⟩ := IsCauSeq.abv_pos (IsCauSeq.geometric abv hx1') _ ε0
        ⟨N, fun {m n} hm hn ↦ hN hm hn⟩
    refine ⟨N, fun n hn ↦ ?_⟩
    rw [map_sum (abv : β →*₀ α) (fun m ↦ x ^ m) (range n), abv_add abv, sum_range_succ']
    refine lt_of_le_of_lt (add_le_add_right ((map_sum abv.toMonoidHom
      (fun m ↦ x ^ m) (range n)).symm ▸ abv_sum_le_sum_abv _ _) _) ?_
    simpa only [H, H₁, H₃] using hN hn (le_refl N)
  refine ⟨this, ?_⟩
  have : ∀ n, abv (1 - x) * abv (1 - x) ^ n = abv (1 - x ^ n.succ) := by
    intro n
    rw [pow_succ', ← H₃, ← H, abv_mul abv]
    simp
  have h : Tendsto (fun n ↦ abv (1 - x) ^ n) atTop (𝓝 0) :=
    mod_cast IsCauSeq.tendsto_abv_sub_abv_of_pos (IsCauSeq.of_abv_geometric abv hx1')
      (sub_lt_self _ hx1')
  rw [← geom_sum_mul_neg, ← abv_inv abv, abv_inj abv hx0, inv_mul_eq_div, div_self hx0,
    abv_one abv, map_one] at h
  exact abv_eq_of_abv_sub_le_abv_sub _ _ _
    (IsCauSeq.abv_pos this _ _ fun ε ε0 ↦ let ⟨i, hi⟩ := h ε ε0; ⟨i, hi⟩)

Repaired Proof:
lemma geo_series_const_one_add {R : Type*} [Semiring R] {n : ℕ} (hn : n ≠ 0) :
    (∑ m ∈ range n, (1 + x) ^ m) = (1 + x) ^ n - 1 := by
  rcases n with (_ | _ | n)


Attempt failure.

Working on Mathlib/Algebra/Order/Monoid/Unbundled/Defs.lean - 2024-09-09 00:24:46.881228.
---7/200---
For theorem contravariant_lt_of_contravariant_le in Mathlib/Algebra/Order/Monoid/Unbundled/Defs.lean:
theorem contravariant_lt_of_contravariant_le [PartialOrder N] :
    Contravariant M N μ (· ≤ ·) → Contravariant M N μ (· < ·) 


Original valid proof:
:=
  And.left ∘ (contravariant_le_iff_contravariant_lt_and_eq M N μ).mp


Verifying proof (Commit a9c207c4e1fa09020f6c257c6d7127ce2969efc6):
 :=
  fun h a b c hab hbc => h a b c hab.le hbc.le

theorem contravariant_le_iff_contravariant_lt_and_eq [PartialOrder N] :
    Contravariant M N μ (· ≤ ·) ↔ Contravariant M N μ (· < ·) ∧ ∀ a b, μ a b = μ b a → b = a :=
  forall₃_congr fun a b c ↦ by simp [le_antisymm_iff, contravariant_iff]

theorem covariant_le_iff_covariant_lt_and_eq [PartialOrder N] :
    Covariant M N μ (· ≤ ·) ↔ Covariant M N μ (· < ·) ∧ ∀ a b, μ a b = μ b a → a = b :=
  contravariant_le_iff_contravariant_lt_and_eq (M := M) (N := N) (μ := μ)

@[simp]
theorem covariant_lt_iff_covariant_le_and_eq [PartialOrder N] :
    Covariant M N μ (· < ·) ↔ Covariant M N μ (· ≤ ·) ∧ ∀ a b, μ a b = μ b a → a = b := by
  simp [← contravariant_le_iff_covariant_lt_and_eq, contravariant_eq_swap_iff]

theorem covariant_le_of_covariant_lt_of_injective [PartialOrder N]
    (hi : Injective μ) (h : Covariant M N μ (· < ·)) : Covariant M N μ (· ≤ ·) :=
  covariant_le_iff_covariant_lt_and_eq.2 ⟨h, fun _ _ ↦ hi⟩

theorem covariant_lt_of_covariant_le_of_injective [PartialOrder N]
    (hi : Injective μ) (h : Covariant M N μ (· ≤ ·)) : Covariant M N μ (· < ·) :=
  covariant_lt_iff_covariant_le_and_eq.2 ⟨h, fun _ _ ↦ hi⟩

theorem contravariant_le_of_contravariant_eq_and_lt [PartialOrder N]
    (hi : Injective μ) (h : Contravariant M N μ (· = ·)) (hlt : Contravariant M N μ (· < ·)) :
    Contravariant M N μ (· ≤ ·) :=
  contravariant_le_iff_contravariant_lt_and_eq.2 ⟨fun _ _ _ hle ↦ hlt _ _ ((h _ _ hle.lt_iff_ne.mpr hi).lt_iff_ne.mpr hi), hi⟩

theorem contravariant_lt_of_contravariant_eq_and_le [PartialOrder N]
    (hi : Injective μ) (h : Contravariant M N μ (· = ·)) (hle : Contravariant M N μ (· ≤ ·)) :
    Contravariant M N μ (· < ·) :=
  contravariant_lt_iff_contravariant_le_and_eq.2 ⟨fun _ _ _ hlt ↦ hle _ _ hlt.le_iff_ne.mpr hi, hi⟩

theorem covariant_iff_contravariant_flip_and_injective [LinearOrder N] :
    Covariant M N μ (· ≤ ·) ↔ Contravariant Mᵒᵈ N μ (· ≤ ·) ∧ Injective μ :=
  ⟨fun h ↦ ⟨h.flip, h.injective⟩, fun h ↦ h.1.flip⟩

theorem covariant_iff_contravariant_flip_and_injective_flip [LinearOrder N] :
    Covariant M N μ (· ≤ ·) ↔ Contravariant M Nᵒᵈ μ (· ≤ ·) ∧ Injective (flip μ) :=
  ⟨fun h ↦ ⟨h.flip, h.injective_flip⟩, fun h ↦ h.1.flip⟩

theorem contravariant_le_iff_contravariant_lt_and_injective [LinearOrder N] :
    Contravariant M N μ (· ≤ ·) ↔ Contravariant M N μ (· < ·) ∧ Injective μ :=
  ⟨fun h ↦ ⟨h.lt_of_le, h.injective⟩, fun h ↦ h.1.le_of_lt⟩

theorem contravariant_le_iff_contravariant_eq_and_injective [PartialOrder N] :
    Contravariant M N μ (· ≤ ·) ↔ Contravariant M N μ (· = ·) ∧ Injective μ :=
  ⟨fun h ↦ ⟨h.eq_of_le, h.injective⟩, fun h ↦ h.1.le_of_eq⟩

theorem covariant_le_iff_covariant_eq_and_injective [PartialOrder N] :
    Covariant M N μ (· ≤ ·) ↔ Covariant M N μ (· = ·) ∧ Injective μ :=
  ⟨fun h ↦ ⟨h.eq_of_le, h.injective⟩, fun h ↦ h.1.le_of_eq⟩

theorem covariant_le_iff_covariant_lt_and_injective [LinearOrder N] :
    Covariant M N μ (· ≤ ·) ↔ Covariant M N μ (· < ·) ∧ Injective μ :=
  ⟨fun h ↦ ⟨h.lt_of_le, h.injective⟩, fun h ↦ h.1.le_of_lt⟩

theorem covariant_le_iff_covariant_eq_and_injective_flip [LinearOrder N] :
    Covariant M N μ (· ≤ ·) ↔ Covariant M N μ (· = ·) ∧ Injective (flip μ) :=
  ⟨fun h ↦ ⟨h.eq_of_le, h.injective_flip⟩, fun h ↦ h.1.le_of_eq⟩

theorem covariant_lt_iff_covariant_le_and_injective [PartialOrder N] :
    Covariant M N μ (· < ·) ↔ Covariant M N μ (· ≤ ·) ∧ Injective μ :=
  ⟨fun h ↦ ⟨h.le_of_lt, h.injective⟩, fun h ↦ h.1.lt_of_le⟩

theorem covariant_lt_iff_covariant_eq_and_injective [PartialOrder N] :
    Covariant M N μ (· < ·) ↔ Covariant M N μ (· = ·) ∧ Injective μ :=
  ⟨fun h ↦ ⟨h.eq_of_lt, h.injective⟩, fun h ↦ h.1.lt_of_eq⟩

theorem covariant_lt_iff_covariant_eq_and_injective_flip [LinearOrder N] :
    Covariant M N μ (· < ·) ↔ Covariant M N μ (· = ·) ∧ Injective (flip μ) :=
  ⟨fun h ↦ ⟨h.eq_of_lt, h.injective_flip⟩, fun h ↦ h.1.lt_of_eq⟩

theorem covariant_le_iff_covariant_eq_and_injective_flip [LinearOrder N] :
    Covariant M N μ (· ≤ ·) ↔ Covariant M N μ (· = ·) ∧ Injective (flip μ) :=
  ⟨fun h ↦ ⟨h.eq_of_le, h.injective_flip⟩, fun h ↦ h.1.le_of_eq⟩

theorem contravariant_le_iff_contravariant_eq_and_injective_flip [LinearOrder N] :
    Contravariant M N μ (· ≤ ·) ↔ Contravariant M N μ (· = ·) ∧ Injective (flip μ) :=
  ⟨fun h ↦ ⟨h.eq_of_le, h.injective_flip⟩, fun h ↦ h.1.le_of_eq⟩

theorem contravariant_lt_iff_contravariant_eq_and_injective_flip [LinearOrder N] :
    Contravariant M N μ (· < ·) ↔ Contravariant M N μ (· = ·) ∧ Injective (flip μ) :=
  ⟨fun h ↦ ⟨h.eq

Attempt failure.

Working on Mathlib/Algebra/Order/Ring/Pow.lean - 2024-09-09 00:24:52.212853.
---8/200---
For theorem one_add_mul_le_pow in Mathlib/Algebra/Order/Ring/Pow.lean:
lemma one_add_mul_le_pow' (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) :
    ∀ n : ℕ, 1 + n * a ≤ (1 + a) ^ n



Original valid proof:
  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ≤ n * (a * a * (2 + a)) + a * a :=
      add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq
    calc
      _ ≤ 1 + ↑(n + 2) * a + (n * (a * a * (2 + a)) + a * a) := le_add_of_nonneg_right this
      _ = (1 + a) * (1 + a) * (1 + n * a) := by
          simp only [Nat.cast_add, add_mul, mul_add, one_mul, mul_one, ← one_add_one_eq_two,
            Nat.cast_one, add_assoc, add_right_inj]
          simp only [← add_assoc, add_comm _ (↑n * a)]
          simp only [add_assoc, (n.cast_commute (_ : R)).left_comm]
          simp only [add_comm, add_left_comm]
      _ ≤ (1 + a) * (1 + a) * (1 + a) ^ n :=
        mul_le_mul_of_nonneg_left (one_add_mul_le_pow' Hsq Hsq' H _) Hsq'
      _ = (1 + a) ^ (n + 2) := by simp only [pow_succ', mul_assoc]


Verifying proof (Commit 61ddcfa78d90f5773ac5739822ee3721851aa662):
  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ≤ n * a * a + a * a := by
      rw [add_mul]
      exact add_nonneg (mul_nonneg n.cast_nonneg Hsq) Hsq
    calc
      1 + (n + 2) * a = (1 + a) * (1 + a) * (1 + n * a) := by
        simp only [add_mul, mul_add, one_mul, mul_one, add_assoc, add_left_comm, this,
          add_le_add_iff_left, pow_succ']
      _ ≤ (1 + a) * (1 + a) * (1 + a) ^ n := by gcongr; apply one_add_mul_le_pow'
      _ = (1 + a) ^ (n + 2) := by rw [pow_succ', pow_succ']

Repaired Proof:
lemma one_add_mul_le_pow' (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) :
    ∀ n : ℕ, 1 + n * a ≤ (1 + a) ^ n
  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ≤ n * a * a + a * a := by
      rw [add_mul]
      exact add_nonneg (mul_nonneg n.cast_nonneg Hsq) Hsq
    calc
      1 + (n + 2) * a = (1 + a) * (1 + a) * (1 + n * a) := by
        simp only [add_mul, mul_add, one_mul, mul_one, add_assoc, add_left_comm, this,
          add_le_add_iff_left, pow_succ']
      _ ≤ (1 + a) * (1 + a) * (1 + a) ^ n := by gcongr; apply one_add_mul_le_pow'
      _ = (1 + a) ^ (n + 2) := by rw [pow_succ', pow_succ']

Repaired Proof:
lemma one_add_mul_le_pow' (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) :
    ∀ n : ℕ, 1 + n * a ≤ (1 + a) ^ n
  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ≤ n * a * a + a * a := by
      rw [add_mul]
      exact add_nonneg (mul_nonneg n.cast_nonneg Hsq) Hsq
    calc
      1 + (n + 2) * a = (1 + a) * (1 + a) * (1 + n * a) := by
        simp only [add_mul, mul_add, one_mul, mul_one, add_assoc, add_left_comm, this,
          add_le_add_iff_left, pow_succ']
      _ ≤ (1 + a) * (1 + a) * (1 + a) ^ n := by gcongr; apply one_add_mul_le_pow'
      _ = (1 + a) ^ (n + 2) := by rw [pow_succ', pow_succ']

Repaired Proof:
lemma one_add_mul_le_pow' (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) :
    ∀ n : ℕ, 1 + n * a ≤ (1 + a) ^ n
  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ≤ n * a * a + a * a := by
      rw [add_mul]
      exact add_nonneg (mul_nonneg n.cast_nonneg Hsq) Hsq
    calc
      1 + (n + 2) * a = (1 + a) * (1 + a) * (1 + n * a) := by
        simp only [add_mul, mul_add, one_mul, mul_one, add_assoc, add_left_comm, this,
          add_le_add_iff_left, pow_succ']
      _ ≤ (1 + a) * (1 + a) * (1 + a) ^ n := by gcongr; apply one_add_mul_le_pow'
      _ = (1 + a) ^ (n + 2) := by rw [pow_succ', pow_succ']

Repaired Proof:
lemma one_add_mul_le_pow' (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) :
    ∀ n : ℕ, 1 + n * a ≤ (1 + a) ^ n
  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ≤ n * a * a + a * a := by
      rw [add_mul]
      exact add_nonneg (mul_nonneg n.cast_nonneg Hsq) Hsq
    calc
      1 + (n + 2) * a = (1 + a) * (1 + a) * (1 + n * a) := by
        simp only [add_mul, mul_add, one_mul, mul_one, add_assoc, add_left_comm, this,
          add_le_add_iff_left, pow_succ']
      _ ≤ (1 + a) * (1 + a) * (1 + a) ^ n := by gcongr; apply one_add_mul_le_pow'
      _ = (1 + a) ^ (n + 2) := by rw [pow_succ', pow_succ']

Repaired Proof:
lemma one_add_mul_le_pow' (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) :
    ∀ n : ℕ, 1 + n * a ≤ (1 + a) ^ n
  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ≤ n * a * a + a * a := by
      rw [add_mul]
      exact add_nonneg (mul_nonneg n.cast_nonneg Hsq) Hsq
    calc
      1 + (n + 2) * a = (1 + a) * (1 + a) * (1 + n * a) := by
        simp only [add_mul, mul_add, one_mul, mul_one, add_assoc, add_left_comm, this,
          add_le_add_iff_left, pow_succ']
      _ ≤ (1 + a) * (1 + a) * (1 + a) ^ n := by gcongr; apply one_add_mul_le_pow'
      _ = (1 + a) ^ (n + 2) := by rw [pow_succ', pow_succ']

Repaired Proof:
lemma one_add_mul_le_pow' (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) :
    ∀ n : ℕ, 1 + n * a ≤ (1 + a) ^ n
  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ≤ n * a * a + a * a := by
      rw [add_mul]
      exact add_nonneg (mul_nonneg n.cast_nonneg Hsq) Hsq
    calc
      1 + (n + 2) * a = (1 + a) * (1 + a) * (1 + n * a) := by
        simp only [add_mul, mul_add, one_mul, mul_one, add_assoc, add_left_comm, this,
          add_le_add_iff_left, pow_succ']
      _ ≤ (1 + a) * (1 + a) * (1 + a) ^ n := by gcongr; apply one_add_mul_le_pow'
      _ = (1 + a) ^ (n + 2) := by rw [pow_succ', pow_succ']

Repaired Proof:
lemma one_add_mul_le_pow' (Hsq

Attempt failure.

Working on Mathlib/Algebra/Polynomial/Lifts.lean - 2024-09-09 00:24:59.348271.
---9/200---
For theorem Polynomial.lifts_and_degree_eq_and_monic in Mathlib/Algebra/Polynomial/Lifts.lean:
theorem lifts_and_degree_eq_and_monic [Nontrivial S] {p : S[X]} (hlifts : p ∈ lifts f)
    (hp : p.Monic) : ∃ q : R[X], map f q = p ∧ q.degree = p.degree ∧ q.Monic 


Original valid proof:
:= by
  cases' subsingleton_or_nontrivial R with hR hR
  · obtain ⟨q, hq⟩ := mem_lifts_and_degree_eq hlifts
    exact ⟨q, hq.1, hq.2, monic_of_subsingleton _⟩
  have H : erase p.natDegree p + X ^ p.natDegree = p := by
    simpa only [hp.leadingCoeff, C_1, one_mul, eraseLead] using eraseLead_add_C_mul_X_pow p
  by_cases h0 : erase p.natDegree p = 0
  · rw [← H, h0, zero_add]
    refine ⟨X ^ p.natDegree, ?_, ?_, monic_X_pow p.natDegree⟩
    · rw [Polynomial.map_pow, map_X]
    · rw [degree_X_pow, degree_X_pow]
  obtain ⟨q, hq⟩ := mem_lifts_and_degree_eq (erase_mem_lifts p.natDegree hlifts)
  have p_neq_0 : p ≠ 0 := by intro hp; apply h0; rw [hp]; simp only [natDegree_zero, erase_zero]
  have hdeg : q.degree < ((X : R[X]) ^ p.natDegree).degree := by
    rw [@degree_X_pow R, hq.2, ← degree_eq_natDegree p_neq_0]
    exact degree_erase_lt p_neq_0
  refine ⟨q + X ^ p.natDegree, ?_, ?_, (monic_X_pow _).add_of_right hdeg⟩
  · rw [Polynomial.map_add, hq.1, Polynomial.map_pow, map_X, H]
  · rw [degree_add_eq_right_of_degree_lt hdeg, degree_X_pow, degree_eq_natDegree hp.ne_zero]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
∧ q.support.card ≤ p.support.card := by
  obtain ⟨p', h_lifts, h_deg, h_mon⟩ := hp.lifts_of_monic hlifts
  refine' ⟨p', h_lifts, h_deg, h_mon, _⟩
  by_contra! h_card
  have h_mon' : Monic (X ^ p.natDegree - C (leadingCoeff p) * X ^ (p.natDegree - 1)) := by
    simp only [monic_X_pow, monic_mul_leadingCoeff_inv, monic_X_pow_sub_C, h_mon]
  have h_lifts' : (X ^ p.natDegree - C (leadingCoeff p) * X ^ (p.natDegree - 1)).map f ∈ lifts f := by
    simpa only [sub_mul, C_mul_X_pow_eq_monomial, natDegree_X_pow, ← C_eq_natCast, C_inj,
      natCast_zsmul] using lifts_sub (lifts_pow_X_sub_C f p.natDegree) (lifts_C f (leadingCoeff p))
  have h_card' : (X ^ p.natDegree - C (leadingCoeff p) * X ^ (p.natDegree - 1)).support.card <
      p.support.card := by
    simpa only [support_sub_eq, support_C_mul, support_X_pow, card_insert_of_not_mem, mem_singleton,
      card_singleton, card_empty, tsub_zero, card_support_eq_zero,
      card_support_eq_one, card_support_eq_two] using h_card
  obtain ⟨q', h_lifts'', h_deg', h_mon'', h_card''⟩ :=
    induction_with_bot_lifts_and_card_support_le f h_mon' h_lifts' h_card'
  refine' absurd h_card'' (not_le.2 h_card')
  rw [← h_deg, ← h_deg', map_sub, map_mul, map_pow, map_X, map_C] at h_lifts''
  exact ⟨q', h_lifts'', by rwa [degree_sub_eq_left_of_degree_lt (h_deg.trans_lt h_deg'), h_deg], h_mon'',
    h_card''⟩

Repaired Proof:
theorem lifts_and_degree_eq_and_monic [Nontrivial S] {p : S[X]} (hlifts : p ∈ lifts f)
    (hp : p.Monic) : ∃ q : R[X], map f q = p ∧ q.degree = p.degree ∧ q.Monic ∧ q.support.card ≤
      p.support.card := by
  obtain ⟨p', h_lifts, h_deg, h_mon⟩ := hp.lifts_of_monic hlifts
  refine ⟨p', h_lifts, h_deg, h_mon, ?_⟩
  by_contra! h_card
  have h_mon' : Monic (X ^ p.natDegree - C (leadingCoeff p) * X ^ (p.natDegree - 1)) := by
    simp only [monic_X_pow, monic_mul_leadingCoeff_inv, monic_X_pow_sub_C, h_mon]
  have h_lifts' : (X ^ p.natDegree - C (leadingCoeff p) * X ^ (p.natDegree - 1)).map f ∈ lifts f := by
    simpa only [sub_mul, C_mul_X_pow_eq_monomial, natDegree_X_pow, ← C_eq_natCast, C_inj,
      natCast_zsmul] using lifts_sub (lifts_pow_X_sub_C f p.natDegree) (lifts_C f (leadingCoeff p))
  have h_card' : (X ^ p.natDegree - C (leadingCoeff p) * X ^ (p.natDegree - 1)).support.card <
      p.support.card := by
    simpa only [support_sub_eq, support_C_mul, support_X_pow, card_insert_of_not_mem, mem_singleton,
      card_singleton, card_empty, tsub_zero, card_support_eq_zero,
      card_support_eq_one, card_support_eq_two] using h_card
  obtain ⟨q', h_lifts'', h_deg', h_mon'', h_card''⟩ :=
    induction_with_bot_lifts_and_card_support_le f h_mon' h_lifts' h_card'
  refine absurd h_card'' (not_le.2 h_card')
  rw [← h_deg, ← h_deg', map_sub, map_mul, map_pow, map_X, map_C] at h_lifts''
  exact ⟨q', h_lifts'', by rwa [degree_sub_eq_left_of_degree_lt (h_deg.trans_lt h_deg'), h_deg], h_mon'',
    h_card''⟩

Repaired Proof:
theorem lifts_and_degree_eq_and_monic [Nontrivial S] {p : S[X]} (hlifts : p ∈ lifts f)
    (hp : p.Monic) : ∃ q : R[X], map f q = p ∧ q.degree = p.degree ∧ q.Monic ∧ q.support.card ≤
      p.support.card := by
  obtain ⟨p', h_lifts, h_deg, h_mon⟩ := hp.lifts_of_monic hlifts
  refine ⟨p', h_lifts, h_deg, h_mon, ?_⟩
  by_contra! h_card
  have h_mon' : Monic (X ^ p.natDegree - C (leadingCoeff p) * X ^ (p.natDegree - 1)) := by
    simp only [monic_X_pow, monic_mul_leadingCoeff_inv, monic_X_pow_sub_C, h_mon]
  have h_lifts' : (X ^ p.natDegree - C (leadingCoeff p) * X ^ (p.natDegree - 1)).map f ∈ lifts f := by
    simpa only [sub_mul, C_mul_X_pow_eq_monomial, natDegree_X_pow, ← C_eq_natCast, C_inj,
      natCast_zsmul] using lifts_sub (lifts_pow_X_sub_C f p.natDegree) (lifts_C f (leadingCoeff p))
  have h_card' : (X ^ p.natDegree - C (leadingCoeff p) * X ^ (p.natDegree - 1)).support.card <
      p.support.card := by
    simpa only [support_sub_eq, support_C_mul, support_X_pow, card_insert_of_not_mem, mem_singleton,
      card_singleton, card_empty, tsub_zero, card_support_eq_zero,
      card_support_eq_one, card_support_eq_two] using h_card
  obtain ⟨q', h_lifts'', h_deg', h_mon'', h_card''⟩ :=
    induction_with_bot_lifts_and_card_support_le f h_mon' h_lifts' h_card'
  refine absurd h_card'' (not_le.2 h_card')
  rw [← h_deg, ← h_deg', map_sub, map_mul, map_pow, map_X, map_C] at h_lifts''
  exact ⟨q', h_lifts'', by rwa [degree_sub_eq_left_of_degree_lt (h_deg.trans_lt h_deg'), h_deg], h_mon'',
    h_card''⟩

Repaired Proof:
theorem lifts_and_degree_eq_and_monic [Nontrivial S] {p : S[X]} (hlifts : p ∈ lifts f)
    (hp : p.Monic) : ∃ q : R[X], map f q = p ∧ q.degree = p.degree ∧ q.Monic ∧ q.support.card ≤
      p.support.card := by
  obtain ⟨p', h_lifts, h_deg, h_mon⟩ := hp.lifts_of_monic hlifts
  refine ⟨p', h_lifts, h_deg, h_mon, ?_�

Attempt failure.

Working on Mathlib/Algebra/Polynomial/Smeval.lean - 2024-09-09 00:25:08.752861.
---10/200---
For theorem Polynomial.smeval_at_natCast in Mathlib/Algebra/Polynomial/Smeval.lean:
theorem smeval_at_natCast (q : ℕ[X]): ∀(n : ℕ), q.smeval (n : S) = q.smeval n 


Original valid proof:
:= by
  induction q using Polynomial.induction_on' with
  | h_add p q ph qh =>
    intro n
    simp only [add_mul, smeval_add, ph, qh, Nat.cast_add]
  | h_monomial n a =>
    intro n
    rw [smeval_monomial, smeval_monomial, nsmul_eq_mul, smul_eq_mul, Nat.cast_mul, Nat.cast_npow]


Verifying proof (Commit 25e538f3a737a71314ac143929711e67d0b14d73):
 := by
    intro n
    rw [← Nat.cast_id n]
    exact smeval_at_cast _ _

theorem smeval_at_zero : ∀(p : ℕ[X]), p.smeval (0 : S) = 0 := by
    intro p
    simp only [smeval_eq_aeval_cast, aeval_zero, map_zero]

theorem smeval_at_one : ∀(p : ℕ[X]), p.smeval (1 : S) = ↑(p.eval 1) := by
    intro p
    simp only [smeval_eq_aeval_cast, aeval_one, map_one]

theorem smeval_at_neg_one : ∀(p : ℕ[X]), p.smeval (-1 : S) = ↑(p.eval (-1)) := by
    intro p
    simp only [smeval_eq_aeval_cast, aeval_neg, aeval_one, map_neg, map_one]

theorem smeval_at_add (p q : ℕ[X]) (x : S) :
    (p + q).smeval x = p.smeval x + q.smeval x := by
    simp only [smeval_eq_aeval_cast, aeval_add, map_add]

theorem smeval_at_sub (p q : ℕ[X]) (x : S) :
    (p - q).smeval x = p.smeval x - q.smeval x := by
    simp only [smeval_eq_aeval_cast, aeval_sub, map_sub]

theorem smeval_at_mul (p q : ℕ[X]) (x : S) :
    (p * q).smeval x = p.smeval x * q.smeval x := by
    simp only [smeval_eq_aeval_cast, aeval_mul, map_mul]

theorem smeval_at_pow (p : ℕ[X]) (n : ℕ) (x : S) :
    (p ^ n).smeval x = (p.smeval x) ^ n := by
    simp only [smeval_eq_aeval_cast, aeval_pow, map_pow]

theorem smeval_at_natCast_mul (p : ℕ[X]) (n : ℕ) (x : S) :
    (n * p).smeval x = n * p.smeval x := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_mul, Nat.cast_id, map_natCast]

theorem smeval_at_mul_nat (p : ℕ[X]) (n : ℕ) (x : S) :
    (p * n).smeval x = p.smeval x * n := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_mul, Nat.cast_id, map_natCast]

theorem smeval_at_pow_nat (p : ℕ[X]) (n : ℕ) (x : S) :
    (p ^ n).smeval x = (p.smeval x) ^ n := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_pow, Nat.cast_id, map_natCast]

theorem smeval_at_natCast_pow (p : ℕ[X]) (n : ℕ) (x : S) :
    (n ^ p).smeval x = n ^ p.smeval x := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_pow, Nat.cast_id, map_natCast]

theorem smeval_at_pow_nat_cast (p : ℕ[X]) (n : ℕ) (x : S) :
    (p ^ n).smeval x = (p.smeval x) ^ n := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_pow, Nat.cast_id, map_natCast]

theorem smeval_at_natCast_add (p q : ℕ[X]) (n : ℕ) (x : S) :
    ((n + p).smeval x = n + p.smeval x) ∧ ((p + n).smeval x = p.smeval x + n) := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_add, Nat.cast_id, map_natCast]
    constructor
    · rw [add_comm]
    · rw [add_comm]

theorem smeval_at_natCast_sub (p q : ℕ[X]) (n : ℕ) (x : S) :
    ((n - p).smeval x = n - p.smeval x) ∧ ((p - n).smeval x = p.smeval x - n) := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_sub, Nat.cast_id, map_natCast]
    constructor
    · rw [sub_eq_add_neg]
    · rw [sub_eq_add_neg]

theorem smeval_at_natCast_mul_nat (p : ℕ[X]) (n m : ℕ) (x : S) :
    ((n * p) * m).smeval x = n * p.smeval x * m := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_mul, Nat.cast_id, map_natCast]

theorem smeval_at_natCast_mul_nat_cast (p : ℕ[X]) (n m : ℕ) (x : S) :
    ((n * p) * m).smeval x = n * m * p.smeval x := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_mul, Nat.cast_id, map_natCast]

theorem smeval_at_natCast_pow_nat (p : ℕ[X]) (n m : ℕ) (x : S) :
    ((n ^ p) ^ m).smeval x = n ^ m * p.smeval x := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_pow, Nat.cast_id, map_natCast]

theorem smeval_at_natCast_pow_nat_cast (p : ℕ[X]) (n m : ℕ) (x : S) :
    ((n ^ p) ^ m).smeval x = n ^ m * p.smeval x := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_pow, Nat.cast_id, map_natCast]

theorem smeval_at_natCast_add_nat (p : ℕ[X]) (n m : ℕ) (x : S) :
    ((n + p) + m).smeval x = n + p.smeval x + m := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_add, Nat.cast_id, map_natCast]

theorem smeval_at_natCast_add_nat_cast (p : ℕ[X]) (n m : ℕ) (x : S) :
    ((n + p) + m).smeval x = n + m + p.smeval x := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_add, Nat.cast_id, map_natCast]

theorem smeval_at_natCast_sub_nat (p : ℕ[X]) (n m : ℕ) (x : S) :
    ((n - p) - m).smeval x = n - p.smeval x - m := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_sub, Nat.cast_id, map_natCast]

theorem smeval_at_natCast_sub_nat_cast (p : ℕ[X]) (n m : ℕ) (x : S) :
    ((n - p) - m).smeval x = n - m - p.smeval x := by
    simp only [smeval_eq_aeval_cast, aeval_nat_cast, map_sub, Nat.cast_id, map_natCast]

theorem smeval_at_natCast_mul_nat_add_nat (p : ℕ[X]) (n m : ℕ) (x : S) :
    ((n * p) * m + n).smeval x = n * p.smeval x * m + n := by
    simp

Attempt failure.

Working on Mathlib/Algebra/Star/Order.lean - 2024-09-09 00:25:23.668957.
---11/200---
For theorem star_nonneg_iff in Mathlib/Algebra/Star/Order.lean:
lemma star_nonneg_iff {x : R} : 0 ≤ star x ↔ 0 ≤ x 


Original valid proof:
:= by
  simpa using star_le_star_iff (x := 0) (y := x)


Verifying proof (Commit 061af0be124d0e0c5bf09a35c992ac5a09a5b364):
∨ star x = 0 := by
  simp [le_iff_re_im]

lemma star_nonneg_iff' {x : R} : 0 ≤ star x ↔ 0 ≤ x ∨ x = 0 := by
  simpa [star_eq_zero, eq_comm] using star_nonneg_iff

lemma star_neg_iff {x : R} : star x < 0 ↔ x < 0 ∧ star x ≠ 0 := by
  simp [not_le, star_nonneg_iff]

lemma star_neg_iff' {x : R} : star x < 0 ↔ x < 0 ∧ x ≠ 0 := by
  simpa [star_eq_zero, eq_comm] using star_neg_iff

lemma star_le_star_iff {x y : R} : star x ≤ star y ↔ x ≤ y := by
  simp_rw [le_iff_re_im]
  simp

lemma star_lt_star_iff {x y : R} : star x < star y ↔ x < y := by
  simp_rw [lt_iff_le_and_ne, star_le_star_iff, star_eq_star_iff]

lemma star_le_self_iff {x : R} : star x ≤ x ↔ 0 ≤ x := by
  simpa [star_eq_zero, star_nonneg_iff] using star_le_star_iff (x := star x) (y := x)

lemma star_lt_self_iff {x : R} : star x < x ↔ 0 < x := by
  simpa [star_pos_iff] using star_lt_star_iff (x := star x) (y := x)

lemma self_le_star_iff {x : R} : x ≤ star x ↔ 0 ≤ x := by
  simpa [star_eq_zero, star_nonneg_iff] using star_le_star_iff (x := x) (y := star x)

lemma self_lt_star_iff {x : R} : x < star x ↔ 0 < x := by
  simpa [star_pos_iff] using star_lt_star_iff (x := x) (y := star x)

lemma star_le_self_iff' {x : R} : star x ≤ x ↔ x = 0 ∨ 0 ≤ x := by
  simpa [star_eq_zero, star_nonneg_iff] using star_le_star_iff (x := star x) (y := x)

lemma star_lt_self_iff' {x : R} : star x < x ↔ x ≠ 0 ∧ 0 < x := by
  simpa [star_pos_iff] using star_lt_star_iff (x := star x) (y := x)

lemma self_le_star_iff' {x : R} : x ≤ star x ↔ x = 0 ∨ 0 ≤ x := by
  simpa [star_eq_zero, star_nonneg_iff] using star_le_star_iff (x := x) (y := star x)

lemma self_lt_star_iff' {x : R} : x < star x ↔ x ≠ 0 ∧ 0 < x := by
  simpa [star_pos_iff] using star_lt_star_iff (x := x) (y := star x)

lemma star_le_self_iff'' {x : R} : star x ≤ x ↔ x = 0 ∨ 0 ≤ x := by
  simpa [star_eq_zero, star_nonneg_iff'] using star_le_star_iff (x := star x) (y := x)

lemma star_lt_self_iff'' {x : R} : star x < x ↔ x ≠ 0 ∧ 0 < x := by
  simpa [star_pos_iff'] using star_lt_star_iff (x := star x) (y := x)

lemma self_le_star_iff'' {x : R} : x ≤ star x ↔ x = 0 ∨ 0 ≤ x := by
  simpa [star_eq_zero, star_nonneg_iff'] using star_le_star_iff (x := x) (y := star x)

lemma self_lt_star_iff'' {x : R} : x < star x ↔ x ≠ 0 ∧ 0 < x := by
  simpa [star_pos_iff'] using star_lt_star_iff (x := x) (y := star x)

lemma star_le_self_iff''' {x : R} : star x ≤ x ↔ 0 ≤ x ∧ x = 0 ∨ 0 ≤ x ∧ x ≠ 0 := by
  simpa [star_eq_zero, star_nonneg_iff'] using star_le_star_iff (x := star x) (y := x)

lemma star_lt_self_iff''' {x : R} : star x < x ↔ 0 < x ∧ x ≠ 0 := by
  simpa [star_pos_iff'] using star_lt_star_iff (x := star x) (y := x)

lemma self_le_star_iff''' {x : R} : x ≤ star x ↔ 0 ≤ x ∧ x = 0 ∨ 0 ≤ x ∧ x ≠ 0 := by
  simpa [star_eq_zero, star_nonneg_iff'] using star_le_star_iff (x := x) (y := star x)

lemma self_lt_star_iff''' {x : R} : x < star x ↔ 0 < x ∧ x ≠ 0 := by
  simpa [star_pos_iff'] using star_lt_star_iff (x := x) (y := star x)

lemma star_le_self_iff'''' {x : R} : star x ≤ x ↔ 0 ≤ x ∧ x = 0 ∨ x ≠ 0 ∧ 0 ≤ x := by
  simpa [star_eq_zero, star_nonneg_iff'] using star_le_star_iff (x := star x) (y := x)

lemma star_lt_self_iff'''' {x : R} : star x < x ↔ 0 < x ∧ x ≠ 0 := by
  simpa [star_pos_iff'] using star_lt_star_iff (x := star x) (y := x)

lemma self_le_star_iff'''' {x : R} : x ≤ star x ↔ 0 ≤ x ∧ x = 0 ∨ x ≠ 0 ∧ 0 ≤ x := by
  simpa [star_eq_zero, star_nonneg_iff'] using star_le_star_iff (x := x) (y := star x)

lemma self_lt_star_iff'''' {x : R} : x < star x ↔ 0 < x ∧ x ≠ 0 := by
  simpa [star_pos_iff'] using star_lt_star_iff (x := x) (y := star x)

lemma star_le_self_iff''''' {x : R} : star x ≤ x ↔ 0 ≤ x ∧ x = 0 ∨ x ≠ 0 ∧ 0 ≤ x ∨ x = 0 ∧ 0 ≤ star x := by
  simpa [star_eq_zero, star_nonneg_iff'] using star_le_star_iff (x := star x) (y := x)

lemma star_lt_self_iff''''' {x : R} : star x < x ↔ 0 < x ∧ x ≠ 0 ∨ x = 0 ∧ 0 < star x := by
  simpa [star_pos_iff'] using star_lt_star_iff (x := star x) (y := x)

lemma self_le_star_iff''''' {x : R} : x ≤ star x ↔ 0 ≤ x ∧ x = 0 ∨ x ≠ 0 ∧ 0 ≤ x ∨ x = 0 ∧ 0 ≤ star x := by
  simpa [star_eq_zero, star_nonneg_iff'] using star_le_star_iff (x := x) (y := star x)

lemma self_lt_star_iff''''' {x : R} : x < star x ↔ 0 < x ∧ x ≠ 0 ∨ x = 0 ∧ 0 < star x := by
  simpa [star_pos_iff'] using star_lt_star_iff (

Attempt failure.

Working on Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean - 2024-09-09 00:25:36.652211.
---12/200---
For theorem AlgebraicGeometry.ΓSpec.adjunction_homEquiv_apply in Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = locallyRingedSpaceAdjunction.homEquiv X.1 R f 


Original valid proof:
:= rfl


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
≫
      Spec.locallyRingedSpaceMap f.unop := by
  rw [← Adjunction.homEquiv_naturality_left_symm, ← Adjunction.homEquiv_naturality_right,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id,
    comp_id, comp_id]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = locallyRingedSpaceAdjunction.homEquiv X.1 R f ≫
      Spec.locallyRingedSpaceMap f.unop := by
  rw [← Adjunction.homEquiv_naturality_left_symm, ← Adjunction.homEquiv_naturality_right,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    comp_id]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id

Attempt failure.

Working on Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean - 2024-09-09 00:26:36.580609.
---13/200---
For theorem PrimeSpectrum.vanishingIdeal_irreducibleComponents in Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean:
lemma vanishingIdeal_irreducibleComponents :
    vanishingIdeal '' (irreducibleComponents <| PrimeSpectrum R) =
    minimalPrimes R 


Original valid proof:
:= by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes_eq_minimals, ← minimals_swap,
    ← PrimeSpectrum.vanishingIdeal_isClosed_isIrreducible, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ ↦ vanishingIdeal_anti_mono_iff hs.1


Verifying proof (Commit 1833c6e43f5f2d80bf844f5bdf73c2f504fbdf8f):
∪ {⊤} := by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes, ← maximals_image_iff _ _
    (isClosed_irreducibleComponents _).isClosed_of_closure, image_image, ← Set.image_univ,
    image_union, ← closure_vanishingIdeal_eq_irreducibleComponents,
    closure_eq_iff_isClosed.mpr (isClosed_irreducibleComponents _),
    isClosed_iff_closure_eq, isClosed_iff_closure_eq]
  refine ⟨fun ⟨s, hs⟩ ↦ ⟨s.1, ?_⟩, fun ⟨s, hs⟩ ↦ ⟨s.1, ?_⟩⟩
  · rwa [← hs, vanishingIdeal_closure]
  · rwa [← hs, closure_vanishingIdeal_eq_irreducibleComponents]

Repaired Proof:
lemma vanishingIdeal_irreducibleComponents :
    vanishingIdeal '' (irreducibleComponents <| PrimeSpectrum R) =
    minimalPrimes R ∪ {⊤} := by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes, ← maximals_image_iff _ _
    (isClosed_irreducibleComponents _).isClosed_of_closure, image_image, ← Set.image_univ,
    image_union, ← closure_vanishingIdeal_eq_irreducibleComponents,
    closure_eq_iff_isClosed.mpr (isClosed_irreducibleComponents _),
    isClosed_iff_closure_eq, isClosed_iff_closure_eq]
  refine ⟨fun ⟨s, hs⟩ ↦ ⟨s.1, ?_⟩, fun ⟨s, hs⟩ ↦ ⟨s.1, ?_⟩⟩
  · rwa [← hs, vanishingIdeal_closure]
  · rwa [← hs, closure_vanishingIdeal_eq_irreducibleComponents]

Repaired Proof:
lemma vanishingIdeal_irreducibleComponents :
    vanishingIdeal '' (irreducibleComponents <| PrimeSpectrum R) =
    minimalPrimes R ∪ {⊤} := by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes, ← maximals_image_iff _ _
    (isClosed_irreducibleComponents _).isClosed_of_closure, image_image, ← Set.image_univ,
    image_union, ← closure_vanishingIdeal_eq_irreducibleComponents,
    closure_eq_iff_isClosed.mpr (isClosed_irreducibleComponents _),
    isClosed_iff_closure_eq, isClosed_iff_closure_eq]
  refine ⟨fun ⟨s, hs⟩ ↦ ⟨s.1, ?_⟩, fun ⟨s, hs⟩ ↦ ⟨s.1, ?_⟩⟩
  · rwa [← hs, vanishingIdeal_closure]
  · rwa [← hs, closure_vanishingIdeal_eq_irreducibleComponents]

Repaired Proof:
lemma vanishingIdeal_irreducibleComponents :
    vanishingIdeal '' (irreducibleComponents <| PrimeSpectrum R) =
    minimalPrimes R ∪ {⊤} := by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes, ← maximals_image_iff _ _
    (isClosed_irreducibleComponents _).isClosed_of_closure, image_image, ← Set.image_univ,
    image_union, ← closure_vanishingIdeal_eq_irreducibleComponents,
    closure_eq_iff_isClosed.mpr (isClosed_irreducibleComponents _),
    isClosed_iff_closure_eq, isClosed_iff_closure_eq]
  refine ⟨fun ⟨s, hs⟩ ↦ ⟨s.1, ?_⟩, fun ⟨s, hs⟩ ↦ ⟨s.1, ?_⟩⟩
  · rwa [← hs, vanishingIdeal_closure]
  · rwa [← hs, closure_vanishingIdeal_eq_irreducibleComponents]

Attempt failure.

Working on Mathlib/AlgebraicTopology/SimplexCategory.lean - 2024-09-09 00:26:52.822620.
---14/200---
For theorem SimplexCategory.σ_comp_σ in Mathlib/AlgebraicTopology/SimplexCategory.lean:
theorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :
    σ (Fin.castSucc i) ≫ σ j = σ j.succ ≫ σ i 


Original valid proof:
:= by
  ext k : 3
  dsimp [σ]
  cases' k using Fin.lastCases with k
  · simp only [len_mk, Fin.predAbove_right_last]
  · cases' k using Fin.cases with k
    · rw [Fin.castSucc_zero, Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _), Fin.castPred_zero,
      Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _)]
    · rcases le_or_lt i k with (h | h)
      · simp_rw [Fin.predAbove_of_castSucc_lt i.castSucc _ (Fin.castSucc_lt_castSucc_iff.mpr
        (Fin.castSucc_lt_succ_iff.mpr h)), ← Fin.succ_castSucc, Fin.pred_succ,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_castSucc_lt i _ (Fin.castSucc_lt_succ_iff.mpr _), Fin.pred_succ]
        rcases le_or_lt k j with (hkj | hkj)
        · rwa [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hkj),
          Fin.castPred_castSucc]
        · rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hkj),
          Fin.le_pred_iff,
          Fin.succ_le_castSucc_iff]
          exact H.trans_lt hkj
      · simp_rw [Fin.predAbove_of_le_castSucc i.castSucc _ (Fin.castSucc_le_castSucc_iff.mpr
        (Fin.succ_le_castSucc_iff.mpr h)), Fin.castPred_castSucc, ← Fin.succ_castSucc,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_le_castSucc _ k.castSucc
        (Fin.castSucc_le_castSucc_iff.mpr (h.le.trans H)),
        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr (H.trans_lt' h)), Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr h)]


Verifying proof (Commit 1b5c1d10be0ae07fd997c78515f4ed4561b92535):
≫ σ j := by
  ext k
  dsimp [σ]
  rcases lt_or_le k i with (hki | hki)
  · rw [Fin.predAbove_of_lt_castSucc _ _ (Fin.castSucc_lt_castSucc_iff.mpr hki),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr H),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr hki),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr hki)]
    simp
  · rcases eq_or_lt_of_le hki with (rfl | hki)
    · simp
    · rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki))]
      simp

Repaired Proof:
theorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :
    σ (Fin.castSucc i) ≫ σ j = σ j.succ ≫ σ i ≫ σ j := by
  ext k
  dsimp [σ]
  rcases lt_or_le k i with (hki | hki)
  · rw [Fin.predAbove_of_lt_castSucc _ _ (Fin.castSucc_lt_castSucc_iff.mpr hki),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr H),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr hki),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr hki)]
    simp
  · rcases eq_or_lt_of_le hki with (rfl | hki)
    · simp
    · rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki))]
      simp

Repaired Proof:
theorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :
    σ (Fin.castSucc i) ≫ σ j = σ j.succ ≫ σ i ≫ σ j := by
  ext k
  dsimp [σ]
  rcases lt_or_le k i with (hki | hki)
  · rw [Fin.predAbove_of_lt_castSucc _ _ (Fin.castSucc_lt_castSucc_iff.mpr hki),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr H),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr hki),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr hki)]
    simp
  · rcases eq_or_lt_of_le hki with (rfl | hki)
    · simp
    · rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki))]
      simp

Repaired Proof:
theorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :
    σ (Fin.castSucc i) ≫ σ j = σ j.succ ≫ σ i ≫ σ j := by
  ext k
  dsimp [σ]
  rcases lt_or_le k i with (hki | hki)
  · rw [Fin.predAbove_of_lt_castSucc _ _ (Fin.castSucc_lt_castSucc_iff.mpr hki),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr H),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr hki),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr hki)]
    simp
  · rcases eq_or_lt_of_le hki with (rfl | hki)
    · simp
    · rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki))]
      simp

Repaired Proof:
theorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :
    σ (Fin.castSucc i) ≫ σ j = σ j.succ ≫ σ i ≫ σ j := by
  ext k
  dsimp [σ]
  rcases lt_or_le k i with (hki | hki)
  · rw [Fin.predAbove_of_lt_castSucc _ _ (Fin.castSucc_lt_castSucc_iff.mpr hki),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr H),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr hki),
      Fin.predAbove_of_lt_succ _ _ (Fin.castSucc_lt_succ_iff.mpr hki)]
    simp
  · rcases eq_or_lt_of_le hki with (rfl | hki)
    · simp
    · rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki)),
        Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr (le_of_lt hki))]
      simp

Repaired Proof:
theorem σ_comp_σ {n} {i j : Fin (n + 

Attempt failure.

Working on Mathlib/Analysis/Analytic/Meromorphic.lean - 2024-09-09 00:27:05.387424.
---15/200---
For theorem MeromorphicOn.inv in Mathlib/Analysis/Analytic/Meromorphic.lean:
lemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x 


Original valid proof:
:= by
  rcases hf with ⟨m, hf⟩
  by_cases h_eq : (fun z ↦ (z - x) ^ m • f z) =ᶠ[𝓝 x] 0
  · 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  · 
    obtain ⟨n, g, hg_an, hg_ne, hg_eq⟩ := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt 𝕜 (fun z ↦ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id 𝕜 x).sub analyticAt_const).pow _
    refine ⟨n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_⟩
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    · simp only [sub_self, pow_succ, mul_zero, zero_smul]
    · simp_rw [smul_eq_mul] at hfg ⊢
      have aux1 : f z ≠ 0 := by
        have : (z - x) ^ n * g z ≠ 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [← hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ', mul_assoc, hfg]
      ring


Verifying proof (Commit 0788787e4cbf8892c4d5415e2a91fb7666b8fc59):
∨ f x = 0 := by
  by_cases h : f x = 0
  · exact Or.inr h
  rcases hf with ⟨U, hU, hf⟩
  refine' ⟨U, hU, _⟩
  rcases hf with ⟨g, hg, hfg⟩
  have : MeromorphicOn g⁻¹ U := by
    refine' (hg.inv hg.dom_eq.subset).congr_on hg.dom_eq.subset _
    intro z hz
    simp only [hg.eq_on hg.dom_eq.subset hz, Pi.inv_apply, inv_inv]
  refine' ⟨g⁻¹, this, _⟩
  intro z hz
  simp only [Pi.inv_apply, hfg z hz, inv_inv]

Repaired Proof:
lemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x ∨ f x = 0 := by
  by_cases h : f x = 0
  · exact Or.inr h
  rcases hf with ⟨U, hU, hf⟩
  refine ⟨U, hU, ?_⟩
  rcases hf with ⟨g, hg, hfg⟩
  have : MeromorphicOn g⁻¹ U := by
    refine (hg.inv hg.dom_eq.subset).congr_on hg.dom_eq.subset ?_
    intro z hz
    simp only [hg.eq_on hg.dom_eq.subset hz, Pi.inv_apply, inv_inv]
  refine ⟨g⁻¹, this, ?_⟩
  intro z hz
  simp only [Pi.inv_apply, hfg z hz, inv_inv]

Repaired Proof:
lemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x ∨ f x = 0 := by
  by_cases h : f x = 0
  · exact Or.inr h
  rcases hf with ⟨U, hU, hf⟩
  refine ⟨U, hU, ?_⟩
  rcases hf with ⟨g, hg, hfg⟩
  have : MeromorphicOn g⁻¹ U := by
    refine (hg.inv hg.dom_eq.subset).congr_on hg.dom_eq.subset ?_
    intro z hz
    simp only [hg.eq_on hg.dom_eq.subset hz, Pi.inv_apply, inv_inv]
  refine ⟨g⁻¹, this, ?_⟩
  intro z hz
  simp only [Pi.inv_apply, hfg z hz, inv_inv]

Repaired Proof:
lemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x ∨ f x = 0 := by
  by_cases h : f x = 0
  · exact Or.inr h
  rcases hf with ⟨U, hU, hf⟩
  refine ⟨U, hU, ?_⟩
  rcases hf with ⟨g, hg, hfg⟩
  have : MeromorphicOn g⁻¹ U := by
    refine (hg.inv hg.dom_eq.subset).congr_on hg.dom_eq.subset ?_
    intro z hz
    simp only [hg.eq_on hg.dom_eq.subset hz, Pi.inv_apply, inv_inv]
  refine ⟨g⁻¹, this, ?_⟩
  intro z hz
  simp only [Pi.inv_apply, hfg z hz, inv_inv]

Repaired Proof:
lemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x ∨ f x = 0 := by
  by_cases h : f x = 0
  · exact Or.inr h
  rcases hf with ⟨U, hU, hf⟩
  refine ⟨U, hU, ?_⟩
  rcases hf with ⟨g, hg, hfg⟩
  have : MeromorphicOn g⁻¹ U := by
    refine (hg.inv hg.dom_eq.subset).congr_on hg.dom_eq.subset ?_
    intro z hz
    simp only [hg.eq_on hg.dom_eq.subset hz, Pi.inv_apply, inv_inv]
  refine ⟨g⁻¹, this, ?_⟩
  intro z hz
  simp only [Pi.inv_apply, hfg z hz, inv_inv]

Repaired Proof:
lemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x ∨ f x = 0 := by
  by_cases h : f x = 0
  · exact Or.inr h
  rcases hf with ⟨U, hU, hf⟩
  refine ⟨U, hU, ?_⟩
  rcases hf with ⟨g, hg, hfg⟩
  have : MeromorphicOn g⁻¹ U := by
    refine (hg.inv hg.dom_eq.subset).congr_on hg.dom_eq.subset ?_
    intro z hz
    simp only [hg.eq_on hg.dom_eq.subset hz, Pi.inv_apply, inv_inv]
  refine ⟨g⁻¹, this, ?_⟩
  intro z hz
  simp only [Pi.inv_apply, hfg z hz, inv_inv]

Repaired Proof:
lemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x ∨ f x = 0 := by
  by_cases h : f x = 0
  · exact Or.inr h
  rcases hf with ⟨U, hU, hf⟩
  refine ⟨U, hU, ?_⟩
  rcases hf with ⟨g, hg, hfg⟩
  have : MeromorphicOn g⁻¹ U := by
    refine (hg.inv hg.dom_eq.subset).congr_on hg.dom_eq.subset ?_
    intro z hz
    simp only [hg.eq_on hg.dom_eq.subset hz, Pi.inv_apply, inv_inv]
  refine ⟨g⁻¹, this, ?_⟩
  intro z hz
  simp only [Pi.inv_apply, hfg z hz, inv_inv]

Repaired Proof:
lemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x ∨ f x = 0 := by
  by_cases h : f x = 0
  · exact Or.inr h
  rcases hf with ⟨U, hU, hf⟩
  refine ⟨U, hU, ?_⟩
  rcases hf with ⟨g, hg, hfg⟩
  have : MeromorphicOn g⁻¹ U := by
    refine (hg.inv hg.dom_eq.subset).congr_on hg.dom_eq.subset ?_
    intro z hz
    simp only [hg.eq_on hg.dom_eq.subset hz, Pi.inv_apply, inv_inv]
  refine ⟨g⁻¹, this, ?_⟩
  intro z hz
  simp only [Pi.inv_apply, hfg z hz, inv_inv]

Repaired Proof:
lemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x ∨ f x = 0 := by
  by_cases h : f x = 0
  · exact Or.in

Attempt failure.

---16/200---
For theorem MeromorphicOn.pow in Mathlib/Analysis/Analytic/Meromorphic.lean:
lemma pow {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℕ) : MeromorphicAt (f ^ n) x 


Original valid proof:
:= by
  induction' n with m hm
  · simpa only [Nat.zero_eq, pow_zero] using MeromorphicAt.const 1 x
  · simpa only [pow_succ] using hm.mul hf


Verifying proof (Commit 61ddcfa78d90f5773ac5739822ee3721851aa662):
 := by
    induction' n with n hn
    · simp only [Nat.zero_eq, pow_zero]
      exact MeromorphicAt.const 1
    · simp only [pow_succ]
      exact hn.mul hf

  lemma zpow {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℤ) : MeromorphicAt (f ^ n) x := by
    induction' n with n hn
    · simp only [Int.ofNat_eq_coe, zpow_natCast]
      exact hf.pow _
    · simp only [zpow_negSucc, inv_iff]
      exact hf.pow _

  lemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x := by
    have h : (f ^ (-1 : ℤ)) = f⁻¹ := by ext1; simp only [Pi.inv_apply, zpow_neg, zpow_one]
    rw [h]
    exact hf.zpow _

  lemma div {f g : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :
    MeromorphicAt (f / g) x := by
    have : (f / g) = f * g⁻¹ := by ext1; simp only [div_eq_mul_inv]
    rw [this]
    exact hf.mul hg.inv

  lemma add {f g : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :
    MeromorphicAt (f + g) x := by
    have : (f + g) = f + (fun _ ↦ g x) := by ext1; simp only [add_apply]
    rw [this]
    exact hf.add hg.const

  lemma sub {f g : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :
    MeromorphicAt (f - g) x := by
    have : (f - g) = f + (-g) := by ext1; simp only [Pi.neg_apply, sub_eq_add_neg]
    rw [this]
    exact hf.add hg.neg

  lemma smul {𝕜' : Type*} [NormedField 𝕜'] [NormedAlgebra 𝕜 𝕜'] [NormedSpace 𝕜' F]
    [IsScalarTower 𝕜 𝕜' F] {f : 𝕜 → 𝕜'} {g : 𝕜 → F} {x : 𝕜} (hf : MeromorphicAt f x)
    (hg : MeromorphicAt g x) : MeromorphicAt (f • g) x := by
    have : (f • g) = fun z ↦ (f z) • (g z) := by ext1; simp only [Pi.smul_apply]
    rw [this]
    exact hf.smul hg

  lemma pow' {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℕ) : MeromorphicAt (fun z ↦ f z ^ n) x :=
    (hf.pow n).congr (fun z ↦ (by simp only [pow_apply])) (by simp only [pow_apply, rpow_natCast])

  lemma rpow {f g : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :
    MeromorphicAt (fun z ↦ f z ^ g z) x := by
    have : (fun z ↦ f z ^ g z) =ᶠ[𝓝 x] fun z ↦ exp (log (f z) * g z) := by
      filter_upwards [(hf.continuousAt.eventually_ne (by simp)).mono fun z hnz ↦ ?_] using
        congr_arg₂ _ (rpow_def_of_pos (by simpa using hnz) _) rfl
      simpa only [rpow_def_of_neg (by simpa using hnz), if_neg hnz]
    refine' this.meromorphicAt.congr _
    filter_upwards [this] with z hz
    rw [hz]
    exact exp_mul _ _

  lemma pow' {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℕ) :
    MeromorphicAt (fun z ↦ f z ^ n) x := by
    induction' n with n hn
    · simp only [Nat.zero_eq, pow_zero]
      exact MeromorphicAt.const 1
    · simp only [pow_succ]
      exact hn.mul hf

  lemma rpow' {f g : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :
    MeromorphicAt (fun z ↦ f z ^ g z) x := by
    have : (fun z ↦ f z ^ g z) =ᶠ[𝓝 x] fun z ↦ exp (log (f z) * g z) := by
      filter_upwards [(hf.continuousAt.eventually_ne (by simp)).mono fun z hnz ↦ ?_] using
        congr_arg₂ _ (rpow_def_of_pos (by simpa using hnz) _) rfl
      simpa only [rpow_def_of_neg (by simpa using hnz), if_neg hnz]
    refine this.meromorphicAt.congr ?_
    filter_upwards [this] with z hz
    rw [hz]
    exact exp_mul _ _

  lemma log {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (hx : f x ≠ 0) :
    MeromorphicAt (fun z ↦ log (f z)) x := by
    have : (fun z ↦ log (f z)) =ᶠ[𝓝 x] fun z ↦ expOrderIso⁻¹ (log (f z)) := by
      filter_upwards [(hf.continuousAt.eventually_ne hx).mono fun z hnz ↦ ?_] using
        congr_arg expOrderIso⁻¹.symm
      simpa only [expOrderIso_apply, exp_log hnz]
    refine this.meromorphicAt.congr ?_
    filter_upwards [this] with z hz
    rw [hz]
    exact expOrderIso_symm_apply _

  lemma log' {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (hx : f x ≠ 0) :
    MeromorphicAt (fun z ↦ log (f z)) x := by
    have : (fun z ↦ log (f z)) =ᶠ[𝓝 x] fun z ↦ expOrderIso⁻¹ (log (f z)) := by
      filter_upwards [(hf.continuousAt.eventually_ne hx).mono fun z hnz ↦ ?_] using
        congr_arg expOrderIso⁻¹.symm
      simpa only [expOrderIso_apply, exp_log hnz]
    refine this.meromorphicAt.congr ?_
    filter_upwards [this] with z hz
    rw [hz]
    exact expOrderIso_symm_apply _

  lemma cpow {f g : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) (hx : f x ≠ 0) :
    MeromorphicAt (fun z ↦ f z ^ g z) x := by
    have : (fun z ↦ f z ^ g z) =ᶠ[𝓝 x] fun z ↦ exp (log (f z) * g z) := by
      filter_upwards [(hf.continuousAt.eventually_ne hx).mono fun z hnz ↦ ?_] using
        congr_arg₂ _ (rpow_def_of_pos (by simpa using hnz) _) rfl
      simpa only [rpow_def_of_neg (by simpa using hnz), if_neg hnz]
    refine this.meromorphicAt.congr ?_
    filter_up

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean - 2024-09-09 00:27:38.093245.
---17/200---
For theorem BoxIntegral.Box.subbox_induction_on' in Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean:
theorem subbox_induction_on' {p : Box ι → Prop} (I : Box ι)
    (H_ind : ∀ J ≤ I, (∀ s, p (splitCenterBox J s)) → p J)
    (H_nhds : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ (m : ℕ), z ∈ Box.Icc J →
      Box.Icc J ⊆ U → (∀ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) → p J) :
    p I 


Original valid proof:
:= by
  by_contra hpI
  replace H_ind := fun J hJ ↦ not_imp_not.2 (H_ind J hJ)
  simp only [exists_imp, not_forall] at H_ind
  choose! s hs using H_ind
  set J : ℕ → Box ι := fun m ↦ (fun J ↦ splitCenterBox J (s J))^[m] I
  have J_succ : ∀ m, J (m + 1) = splitCenterBox (J m) (s <| J m) :=
    fun m ↦ iterate_succ_apply' _ _ _
  have hJmono : Antitone J :=
    antitone_nat_of_succ_le fun n ↦ by simpa [J_succ] using splitCenterBox_le _ _
  have hJle : ∀ m, J m ≤ I := fun m ↦ hJmono (zero_le m)
  have hJp : ∀ m, ¬p (J m) :=
    fun m ↦ Nat.recOn m hpI fun m ↦ by simpa only [J_succ] using hs (J m) (hJle m)
  have hJsub : ∀ m i, (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m := by
    intro m i
    induction' m with m ihm
    · simp [J, Nat.zero_eq]
    simp only [pow_succ, J_succ, upper_sub_lower_splitCenterBox, ihm, div_div]
  have h0 : J 0 = I := rfl
  clear_value J
  clear hpI hs J_succ s
  set z : ι → ℝ := ⨆ m, (J m).lower
  have hzJ : ∀ m, z ∈ Box.Icc (J m) :=
    mem_iInter.1 (ciSup_mem_iInter_Icc_of_antitone_Icc
      ((@Box.Icc ι).monotone.comp_antitone hJmono) fun m ↦ (J m).lower_le_upper)
  have hJl_mem : ∀ m, (J m).lower ∈ Box.Icc I := fun m ↦ le_iff_Icc.1 (hJle m) (J m).lower_mem_Icc
  have hJu_mem : ∀ m, (J m).upper ∈ Box.Icc I := fun m ↦ le_iff_Icc.1 (hJle m) (J m).upper_mem_Icc
  have hJlz : Tendsto (fun m ↦ (J m).lower) atTop (𝓝 z) :=
    tendsto_atTop_ciSup (antitone_lower.comp hJmono) ⟨I.upper, fun x ⟨m, hm⟩ ↦ hm ▸ (hJl_mem m).2⟩
  have hJuz : Tendsto (fun m ↦ (J m).upper) atTop (𝓝 z) := by
    suffices Tendsto (fun m ↦ (J m).upper - (J m).lower) atTop (𝓝 0) by simpa using hJlz.add this
    refine tendsto_pi_nhds.2 fun i ↦ ?_
    simpa [hJsub] using
      tendsto_const_nhds.div_atTop (tendsto_pow_atTop_atTop_of_one_lt _root_.one_lt_two)
  replace hJlz : Tendsto (fun m ↦ (J m).lower) atTop (𝓝[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJlz (eventually_of_forall hJl_mem)
  replace hJuz : Tendsto (fun m ↦ (J m).upper) atTop (𝓝[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJuz (eventually_of_forall hJu_mem)
  rcases H_nhds z (h0 ▸ hzJ 0) with ⟨U, hUz, hU⟩
  rcases (tendsto_lift'.1 (hJlz.Icc hJuz) U hUz).exists with ⟨m, hUm⟩
  exact hJp m (hU (J m) (hJle m) m (hzJ m) hUm (hJsub m))


Verifying proof (Commit 427e8bb60237df1d94184c0ffbde88acb1294fc5):
∧ ∀ J ≤ I, J ≠ I → p J := by
  have H_nhds' : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ m, z ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J = splitCenterBox J s → p J := by
    intro z hz
    rcases H_nhds z hz with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hs => H J hJ m hzJ hsub fun i => ?_⟩
    rcases hs i with (rfl | rfl)
    · simp
    · simp
  have H_nhds'' : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ m, z ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J = splitCenterBox J s → J ≠ I → p J := by
    intro z hz
    rcases H_nhds' z hz with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hs hne => ?_⟩
    rcases ne_or_eq J I with (hne' | rfl)
    · exact H J hJ m hzJ hsub s hs
    · rcases hs.symm.eq_or_eq with (rfl | rfl)
      · simp at hne
      · simp
  have H_nhds''' : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ m, z ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J ≠ I → p J := by
    intro z hz
    rcases H_nhds'' z hz with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hne => ?_⟩
    simpa only [hne, false_or_iff] using H J hJ m hzJ hsub s rfl hne
  have H_nhds'''' : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ m, z ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, p J := by
    intro z hz
    rcases H_nhds''' z hz with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s => ?_⟩
    simpa only [hJ.ne_of_mem hzJ hsub, false_and_iff, or_false_iff] using H J hJ m hzJ hsub s
  have H_nhds''''' : ∃ U ∈ 𝓝[Box.Icc I] I.upper, ∀ J ≤ I, ∀ m, I.upper ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, p J := by
    rcases H_nhds'''' I.upper I.upper_mem_Icc with ⟨U, hU, H⟩
    exact ⟨U, hU, fun J hJ m hzJ hsub s => H J hJ m hzJ.2 hsub s⟩
  have H_nhds'''''' : ∃ U ∈ 𝓝[Box.Icc I] I.lower, ∀ J ≤ I, ∀ m, I.lower ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, p J := by
    rcases H_nhds'''' I.lower I.lower_mem_Icc with ⟨U, hU, H⟩
    exact ⟨U, hU, fun J hJ m hzJ hsub s => H J hJ m hzJ.1 hsub s⟩
  have H_nhds''''''' : ∃ U ∈ 𝓝[Box.Icc I] I.upper, ∀ J ≤ I, ∀ m, I.upper ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J ≠ I → p J := by
    rcases H_nhds''''' with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hne => ?_⟩
    simpa only [hne, true_and_iff, or_false_iff] using H J hJ m hzJ hsub s
  have H_nhds'''''''' : ∃ U ∈ 𝓝[Box.Icc I] I.lower, ∀ J ≤ I, ∀ m, I.lower ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J ≠ I → p J := by
    rcases H_nhds'''''' with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hne => ?_⟩
    simpa only [hne, true_and_iff, false_or_iff] using H J hJ m hzJ hsub s
  rcases H_nhds''''''' with ⟨U₁, hU₁, H₁⟩
  rcases H_nhds'''''''' with ⟨U₂, hU₂, H₂⟩
  have H_nhds''''''''' : ∃ U ∈ 𝓝[Box.Icc I] I.upper, ∀ J ≤ I, ∀ m, I.upper ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J ≠ I → ∀ t, J.lower ∈ Box.Icc t → Box.Icc t ⊆ U → p J := by
    rcases H_nhds''''''' with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hne t hzt hsub' => ?_⟩
    simpa only [hne, true_and_iff, or_false_iff] using H J hJ m hzJ hsub s
  have H_nhds'''''''''' : ∃ U ∈ 𝓝[Box.Icc I] I.lower, ∀ J ≤ I, ∀ m, I.lower ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J ≠ I → ∀ t, J.upper ∈ Box.Icc t → Box.Icc t ⊆ U → p J := by
    rcases H_nhds'''''''' with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hne t hzt hsub' => ?_⟩
    simpa only [hne, true_and_iff, false_or_iff] using H J hJ m hzJ hsub s
  rcases H_nhds''''''''' with ⟨U₁', hU₁', H₁'⟩
  rcases H_nhds'''''''''' with ⟨U₂', hU₂', H₂'⟩
  refine ⟨H₁' U₁' hU₁' U₂' hU₂' H₁ H₂, fun J hJ hne => ?_⟩
  rcases ne_or_lt_of_le hJ with (hJ' | hlt)
  · rcases exists_splitCenterBox_le_and_Icc_subset hlt hJ' hne with ⟨s, hs⟩
    rcases em (J = I) with (rfl | hne')

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean - 2024-09-09 00:27:49.249462.
---18/200---
For theorem BoxIntegral.hasIntegral_GP_pderiv in Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean:
theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) → ℝ) → E)
    (f' : (Fin (n + 1) → ℝ) → (Fin (n + 1) → ℝ) →L[ℝ] E) (s : Set (Fin (n + 1) → ℝ))
    (hs : s.Countable) (Hs : ∀ x ∈ s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ∀ x ∈ (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) 


Original valid proof:
:= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ↦ by
    by_cases hxs : x ∈ s
    exacts [Hs x hxs, (Hd x ⟨hx, hxs⟩).continuousWithinAt]
  set fI : ℝ → Box (Fin n) → E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) → Fin n →ᵇᵃ[↑(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) →ᵇᵃ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_
  ·
    exact (volume : Measure (Fin (n + 1) → ℝ)).toBoxAdditive.restrict _ le_top
  · exact fun J => ENNReal.toReal_nonneg
  · intro c x hx ε ε0
    have : ∀ᶠ δ in 𝓝[>] (0 : ℝ), δ ∈ Ioc (0 : ℝ) (1 / 2) ∧
        (∀ᵉ (y₁ ∈ closedBall x δ ∩ (Box.Icc I)) (y₂ ∈ closedBall x δ ∩ (Box.Icc I)),
              ‖f y₁ - f y₂‖ ≤ ε / 2) ∧ (2 * δ) ^ (n + 1) * ‖f' x (Pi.single i 1)‖ ≤ ε / 2 := by
      refine .and ?_ (.and ?_ ?_)
      · exact Ioc_mem_nhdsWithin_Ioi ⟨le_rfl, one_half_pos⟩
      · rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos ε0) with ⟨δ₁, δ₁0, hδ₁⟩
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ⟨le_rfl, δ₁0⟩] with δ hδ y₁ hy₁ y₂ hy₂
        have : closedBall x δ ∩ (Box.Icc I) ⊆ closedBall x δ₁ ∩ (Box.Icc I) := by gcongr; exact hδ.2
        rw [← dist_eq_norm]
        calc
          dist (f y₁) (f y₂) ≤ dist (f y₁) (f x) + dist (f y₂) (f x) := dist_triangle_right _ _ _
          _ ≤ ε / 2 / 2 + ε / 2 / 2 := add_le_add (hδ₁ _ <| this hy₁) (hδ₁ _ <| this hy₂)
          _ = ε / 2 := add_halves _
      · have : ContinuousWithinAt (fun δ : ℝ => (2 * δ) ^ (n + 1) * ‖f' x (Pi.single i 1)‖)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine this.eventually (ge_mem_nhds ?_)
        simpa using half_pos ε0
    rcases this.exists with ⟨δ, ⟨hδ0, hδ12⟩, hdfδ, hδ⟩
    refine ⟨δ, hδ0, fun J hJI hJδ _ _ => add_halves ε ▸ ?_⟩
    have Hl : J.lower i ∈ Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ∈ Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ∀ x ∈ Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJδ' : Box.Icc J ⊆ closedBall x δ ∩ (Box.Icc I) := subset_inter hJδ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ∀ z ∈ Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x δ ∩ (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJδ'
    simp only [dist_eq_norm]; dsimp [F]
    rw [← integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)
    · simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hδ
      have : ∀ j, |J.upper j - J.lower j| ≤ 2 * δ := fun j ↦
        calc
          dist (J.upper j) (J.lower j) ≤ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ≤ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ ≤ δ + δ := add_le_add (hJδ J.upper_mem_Icc) (hJδ J.lower_mem_Icc)
          _ = 2 * δ := (two_mul δ).symm
      calc
        ∏ j, |J.upper j - J.lower j| ≤ ∏ j : Fin (n + 1), 2 * δ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * δ) ^ (n + 1) := by simp
    · refine (norm_integral_le_of_le_const (fun y hy => hdfδ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans ?_
      refine (mul_le_mul_of_nonneg_right ?_ (half_pos ε0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ≤
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ≤ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)
        _ ≤ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
        _ ≤ δ + δ := add_le_add (hJδ J.upper_mem_Icc) (hJδ J.lower_mem_Icc)
        _ ≤ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  · intro c x hx ε ε0
    rcases exists_pos_mul_lt ε0 (2 * c) with ⟨ε', ε'0, hlt⟩
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.def ε'0) with ⟨δ, δ0, Hδ⟩
    refine ⟨δ, δ0, fun J hle hJδ hxJ hJc => ?_⟩
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ ε'0 (fun y hy => Hδ ?_) (hJc rfl)).trans ?_
    · exact ⟨hJδ hy, Box.le_iff_Icc.1 hle hy⟩
    · rw [mul_right_comm (2 : ℝ), ← Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg


Verifying proof (Commit c7bd9bd10c613e1788107ba753e252f069560f87):
∧
      Integrable.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume := by
  have Hc : ContinuousOn f (Box.Icc I \ s) := fun x hx =>
    (Hd x hx).continuousWithinAt
  have Hc' : ContinuousOn (fun x => f' x (Pi.single i 1)) (Box.Icc I \ s) := fun x hx =>
    ((Hd x hx).comp (ContinuousLinearMap.single i 1) continuous_id.continuousWithinAt
        fun _ _ => continuous_const).continuousWithinAt
  have Hs' : ∀ x ∈ s, DifferentiableWithinAt ℝ f (Box.Icc I) x := fun x hx =>
    (Hd x (Icc_diff_countable hs _ hx ▸ hx)).differentiableWithinAt
  have Hd' : ∀ x ∈ (Box.Icc I) \ s,
      HasFDerivWithinAt f (f' x) (Box.Icc I) x ∧
        HasFDerivWithinAt (fun x => f x (i.insertNth (I.upper i) x)) (f' x ∘L
          (ContinuousLinearMap.single i 1)) (Box.Icc I) x := fun x hx =>
    ⟨Hd x hx, ((Hd x hx).comp (ContinuousLinearMap.single i 1) continuous_id.hasFDerivWithinAt
        fun _ _ => continuous_const).congr_of_eventuallyEq
      (fun _ => rfl) (Box.coe_ne_empty _ ▸ I.insertNth_mem_Icc hx.1 i)⟩
  have Hc'' : ContinuousOn (fun x => f' x (Pi.single i 1)) (Box.Icc I) := fun x hx =>
    (Hd' x ⟨hx, fun h => hx.2 (hs.mem_of_mem h)⟩).1.continuousWithinAt.comp
      (continuous_id.continuousWithinAt.prod
        (continuous_const.continuousWithinAt.prod continuous_const))
      (isClosed_singleton.preimage continuous_id)
  have Hs'' : ∀ x ∈ s,
      IntegrableOn (fun x => f' x (Pi.single i 1)) (I.face i)
        (μ := volume) ∧
        IntegrableOn (fun x => f x (i.insertNth (I.upper i) x)) (I.face i)
          (μ := volume) ∧
        IntegrableOn (fun x => f x (i.insertNth (I.lower i) x)) (I.face i)
          (μ := volume) := fun x hx => by
    have Hs : Icc (I.lower i) (I.upper i) ∈ 𝓝[s] I.lower i := by
      refine' mem_nhdsWithin_Icc_iff_exists_Icc_subset.2 ⟨Icc (I.lower i) (I.upper i), _,
        Icc_subset_Icc (min_le_left _ _) le_rfl, left_mem_Icc.2 (min_le_left _ _)⟩
      simp [I.lower_le_upper]
    have Hs' : Icc (I.lower i) (I.upper i) ∈ 𝓝[s] I.upper i := by
      refine' mem_nhdsWithin_Icc_iff_exists_Icc_subset.2 ⟨Icc (I.lower i) (I.upper i), _,
        Icc_subset_Icc le_rfl (min_le_right _ _), right_mem_Icc.2 (min_le_right _ _)⟩
      simp [I.lower_le_upper]
    have Hs'' : Icc (I.lower i) (I.upper i) ∈ 𝓝[s] x := by
      simp only [mem_nhdsWithin_iff_eventuallyEq, Icc_diff_right, Icc_diff_left,
        mem_Icc, mem_compl_iff, mem_singleton_iff]
      refine' eventually_of_forall fun y hy => _
      rcases hy with ⟨hy, hy'⟩
      simp only [Pi.single_eq_same, mem_compl_iff, mem_singleton_iff, mem_Icc]
      exact ⟨hy.1, fun h => hy' ⟨h, hy.2⟩⟩
    have Hs''' : Icc (I.lower i) (I.upper i) ∈ 𝓝[s] (I.lower i) ∩ 𝓝[s] (I.upper i) :=
      Hs''.and Hs Hs'
    rcases Hs''' with ⟨t, Ht, Ht'⟩
    have Ht'' : IntegrableOn f' t (μ := volume) := by
      refine' Hd' x ⟨Ht.1, fun h => Ht.2 ⟨h, Ht'.1⟩⟩ |>.1.integrableOn_compact Ht.2
    refine' ⟨Ht''.mono_set Ht.2, Hs x hx, Hs x hx⟩
  have Hd'' : ∀ x ∈ (Box.Icc I) \ s,
      IntegrableOn (fun x => f' x (Pi.single i 1)) (I.face i)
        (μ := volume) ∧
        IntegrableOn (fun x => f (i.insertNth (I.upper i) x)) (I.face i)
          (μ := volume) ∧
        IntegrableOn (fun x => f (i.insertNth (I.lower i) x)) (I.face i)
          (μ := volume) := fun x hx => by
    have Hs : Icc (I.lower i) (I.upper i) ∈ 𝓝[s] x := by
      simp only [mem_nhdsWithin_iff_eventuallyEq, Icc_diff_right, Icc_diff_left,
        mem_Icc, mem_compl_iff, mem_singleton_iff]
      refine eventually_of_forall fun y hy => ?_
      rcases hy with ⟨hy, hy'⟩
      simp only [Pi.single_eq_same, mem_compl_iff, mem_singleton_iff, mem_Icc]
      exact ⟨hy.1, fun h => hy' ⟨h, hy.2⟩⟩
    have Hs' : Icc (I.lower i) (I.upper i) ∈ 𝓝[s] I.lower i := by
      refine mem_nhdsWithin_Icc_iff_exists_Icc_subset.2 ⟨Icc (I.lower i) (I.upper i), ?_,
        Icc_subset_Icc le_rfl (min_le_right _ _), left_mem_Icc.2 (min_le_left _ _)⟩
      simp [I.lower_le_upper]
    have Hs'' : Icc (I.lower i) (I.upper i) ∈ 𝓝[s] I.upper i := by
      refine mem_nhdsWithin_Icc_iff_exists_Icc_subset.2 ⟨Icc (I.lower i) (I.upper i), ?_,
        Icc_subset_Icc (min_le_left _ _) le_rfl, right_mem_Icc.2 (min_le_right _ _)⟩
      simp [I.lower_le_upper]
    rcases Hs with ⟨t, Ht, Ht'⟩
    have Ht'' : IntegrableOn f' t (μ := volume) := by
      refine Hd' x ⟨Ht.1, fun h => Ht.2 ⟨h, Ht'.1⟩⟩ |>.1.integrableOn_compact Ht.2
    refine ⟨Ht''.mono_set Ht.2, Hs'' ⟨Ht.1, Ht'.1⟩, Hs' ⟨Ht.1, Ht'.1⟩⟩
  have Hd''' : ∀ x ∈ (Box.Icc I) \ s,
      IntegrableOn (fun x => f' x (Pi.single i 1)) (I.face i)
        (μ := volume) ∧
        IntegrableOn (fun x => f (i.insertNth (I.upper i) x)) (I.face i)
          (μ := volume) ∧
        Integrable

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Integrability.lean - 2024-09-09 00:28:22.769782.
---19/200---
For theorem BoxIntegral.hasIntegralIndicatorConst in Mathlib/Analysis/BoxIntegral/Integrability.lean:
theorem hasIntegralIndicatorConst (l : IntegrationParams) (hl : l.bRiemann = false)
    {s : Set (ι → ℝ)} (hs : MeasurableSet s) (I : Box ι) (y : E) (μ : Measure (ι → ℝ))
    [IsLocallyFiniteMeasure μ] :
    HasIntegral.{u, v, v} I l (s.indicator fun _ => y) μ.toBoxAdditive.toSMul
      ((μ (s ∩ I)).toReal • y) 


Original valid proof:
:= by
  refine HasIntegral.of_mul ‖y‖ fun ε ε0 => ?_
  lift ε to ℝ≥0 using ε0.le; rw [NNReal.coe_pos] at ε0
  have A : μ (s ∩ Box.Icc I) ≠ ∞ :=
    ((measure_mono Set.inter_subset_right).trans_lt (I.measure_Icc_lt_top μ)).ne
  have B : μ (s ∩ I) ≠ ∞ :=
    ((measure_mono Set.inter_subset_right).trans_lt (I.measure_coe_lt_top μ)).ne
  obtain ⟨F, hFs, hFc, hμF⟩ : ∃ F, F ⊆ s ∩ Box.Icc I ∧ IsClosed F ∧ μ ((s ∩ Box.Icc I) \ F) < ε :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 ε0).ne'
  obtain ⟨U, hsU, hUo, hUt, hμU⟩ :
      ∃ U, s ∩ Box.Icc I ⊆ U ∧ IsOpen U ∧ μ U < ∞ ∧ μ (U \ (s ∩ Box.Icc I)) < ε :=
    (hs.inter I.measurableSet_Icc).exists_isOpen_diff_lt A (ENNReal.coe_pos.2 ε0).ne'
  have : ∀ x ∈ s ∩ Box.Icc I, ∃ r : Ioi (0 : ℝ), closedBall x r ⊆ U := fun x hx => by
    rcases nhds_basis_closedBall.mem_iff.1 (hUo.mem_nhds <| hsU hx) with ⟨r, hr₀, hr⟩
    exact ⟨⟨r, hr₀⟩, hr⟩
  choose! rs hrsU using this
  have : ∀ x ∈ Box.Icc I \ s, ∃ r : Ioi (0 : ℝ), closedBall x r ⊆ Fᶜ := fun x hx => by
    obtain ⟨r, hr₀, hr⟩ :=
      nhds_basis_closedBall.mem_iff.1 (hFc.isOpen_compl.mem_nhds fun hx' => hx.2 (hFs hx').1)
    exact ⟨⟨r, hr₀⟩, hr⟩
  choose! rs' hrs'F using this
  set r : (ι → ℝ) → Ioi (0 : ℝ) := s.piecewise rs rs'
  refine ⟨fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c π hπ hπp => ?_⟩; rw [mul_comm]
  dsimp [integralSum]
  simp only [mem_closedBall, dist_eq_norm, ← indicator_const_smul_apply,
    sum_indicator_eq_sum_filter, ← sum_smul, ← sub_smul, norm_smul, Real.norm_eq_abs, ←
    Prepartition.filter_boxes, ← Prepartition.measure_iUnion_toReal]
  gcongr
  set t := (π.filter (π.tag · ∈ s)).iUnion
  change abs ((μ t).toReal - (μ (s ∩ I)).toReal) ≤ ε
  have htU : t ⊆ U ∩ I := by
    simp only [t, TaggedPrepartition.iUnion_def, iUnion_subset_iff, TaggedPrepartition.mem_filter,
      and_imp]
    refine fun J hJ hJs x hx => ⟨hrsU _ ⟨hJs, π.tag_mem_Icc J⟩ ?_, π.le_of_mem' J hJ hx⟩
    simpa only [r, s.piecewise_eq_of_mem _ _ hJs] using hπ.1 J hJ (Box.coe_subset_Icc hx)
  refine abs_sub_le_iff.2 ⟨?_, ?_⟩
  · refine (ENNReal.le_toReal_sub B).trans (ENNReal.toReal_le_coe_of_le_coe ?_)
    refine (tsub_le_tsub (measure_mono htU) le_rfl).trans (le_measure_diff.trans ?_)
    refine (measure_mono fun x hx => ?_).trans hμU.le
    exact ⟨hx.1.1, fun hx' => hx.2 ⟨hx'.1, hx.1.2⟩⟩
  · have hμt : μ t ≠ ∞ := ((measure_mono (htU.trans inter_subset_left)).trans_lt hUt).ne
    refine (ENNReal.le_toReal_sub hμt).trans (ENNReal.toReal_le_coe_of_le_coe ?_)
    refine le_measure_diff.trans ((measure_mono ?_).trans hμF.le)
    rintro x ⟨⟨hxs, hxI⟩, hxt⟩
    refine ⟨⟨hxs, Box.coe_subset_Icc hxI⟩, fun hxF => hxt ?_⟩
    simp only [t, TaggedPrepartition.iUnion_def, TaggedPrepartition.mem_filter, Set.mem_iUnion]
    rcases hπp x hxI with ⟨J, hJπ, hxJ⟩
    refine ⟨J, ⟨hJπ, ?_⟩, hxJ⟩
    contrapose hxF
    refine hrs'F _ ⟨π.tag_mem_Icc J, hxF⟩ ?_
    simpa only [r, s.piecewise_eq_of_not_mem _ _ hxF] using hπ.1 J hJπ (Box.coe_subset_Icc hxJ)


Verifying proof (Commit 1b93076c86e6da5d0a25d3465e84d13bd9ccfcc8):
∧ Integrable.{u, v, v} I l (s.indicator fun _ => y) μ := by
  haveI : IsLocallyFiniteMeasure (volume : Measure (ι → ℝ)) :=
    borel_isLocallyFiniteMeasure
  haveI : IsFiniteMeasureOnCompacts (volume : Measure (ι → ℝ)) :=
    isFiniteMeasureOnCompacts_volume
  haveI : SigmaFinite (volume : Measure (ι → ℝ)) := isSigmaFinite_volume
  haveI : SigmaFinite μ := sigmaFinite_of_isLocallyFiniteMeasure μ
  haveI : IsLocallyFiniteMeasure μ := isLocallyFiniteMeasure_of_isLocallyFiniteMeasure_on_subboxes μ
    fun _ _ => isLocallyFiniteMeasure_volume
  haveI : IsFiniteMeasureOnCompacts μ := isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure μ
  have hm : StronglyMeasurable (s.indicator fun _ => y) :=
    stronglyMeasurable_const.indicator hs
  have hi : Integrable.{u, v, v} I l (s.indicator fun _ => y) μ :=
    integrable_of_forall_fin_meas_le' l hl hs hm (fun J _ hJ => (measure_mono hJ).trans_lt hJ.2).ne'
      (fun J _ hJ => (measure_mono hJ.1).trans_lt hJ.2)
  refine' ⟨_, hi⟩
  have hm' : StronglyMeasurable (s.indicator (fun _ => (1 : ℝ≥0))) :=
    stronglyMeasurable_const.indicator hs
  have hm'' : StronglyMeasurable (s.indicator (fun _ => (1 : ℝ≥0)) : (ι → ℝ) → ℝ≥0∞) :=
    hm'.ennreal_toNNReal
  refine' (hasIntegral_toReal_of_lintegral_ne_top l hl hm'' _ _).congr' _ _
  · rw [lintegral_indicator_const_le hs, Measure.restrict_apply hs, Set.inter_comm]
    exact (measure_mono Set.inter_subset_left).trans_lt hI.2
  · rw [lintegral_indicator_const_le hs, Measure.restrict_apply hs, Set.inter_comm]
    exact (measure_mono Set.inter_subset_left).trans_lt hI.2
  · exact (indicatorConstLp_coeFn.mono Box.coe_subset_Icc).fun_comp (s.indicator fun _ => (1 : ℝ≥0))
  · exact (indicatorConstLp_coeFn.mono Box.coe_subset_Icc).fun_comp (s.indicator fun _ => (1 : ℝ≥0))

Repaired Proof:
theorem hasIntegralIndicatorConst (l : IntegrationParams) (hl : l.bRiemann = false)
    {s : Set (ι → ℝ)} (hs : MeasurableSet s) (I : Box ι) (y : E) (μ : Measure (ι → ℝ))
    [IsLocallyFiniteMeasure μ] :
    HasIntegral.{u, v, v} I l (s.indicator fun _ => y) μ.toBoxAdditive.toSMul
      ((μ (s ∩ I)).toReal • y) ∧ Integrable.{u, v, v} I l (s.indicator fun _ => y) μ := by
  haveI : IsLocallyFiniteMeasure (volume : Measure (ι → ℝ)) :=
    borel_isLocallyFiniteMeasure
  haveI : IsFiniteMeasureOnCompacts (volume : Measure (ι → ℝ)) :=
    isFiniteMeasureOnCompacts_volume
  haveI : SigmaFinite (volume : Measure (ι → ℝ)) := isSigmaFinite_volume
  haveI : SigmaFinite μ := sigmaFinite_of_isLocallyFiniteMeasure μ
  haveI : IsLocallyFiniteMeasure μ := isLocallyFiniteMeasure_of_isLocallyFiniteMeasure_on_subboxes μ
    fun _ _ => isLocallyFiniteMeasure_volume
  haveI : IsFiniteMeasureOnCompacts μ := isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure μ
  have hm : StronglyMeasurable (s.indicator fun _ => y) :=
    stronglyMeasurable_const.indicator hs
  have hi : Integrable.{u, v, v} I l (s.indicator fun _ => y) μ :=
    integrable_of_forall_fin_meas_le' l hl hs hm (fun J _ hJ => (measure_mono hJ).trans_lt hJ.2).ne'
      (fun J _ hJ => (measure_mono hJ.1).trans_lt hJ.2)
  refine ⟨?_, hi⟩
  have hm' : StronglyMeasurable (s.indicator (fun _ => (1 : ℝ≥0))) :=
    stronglyMeasurable_const.indicator hs
  have hm'' : StronglyMeasurable (s.indicator (fun _ => (1 : ℝ≥0)) : (ι → ℝ) → ℝ≥0∞) :=
    hm'.ennreal_toNNReal
  refine (hasIntegral_toReal_of_lintegral_ne_top l hl hm'' ?_ ?_).congr' ?_ ?_
  · rw [lintegral_indicator_const_le hs, Measure.restrict_apply hs, Set.inter_comm]
    exact (measure_mono Set.inter_subset_left).trans_lt hI.2
  · rw [lintegral_indicator_const_le hs, Measure.restrict_apply hs, Set.inter_comm]
    exact (measure_mono Set.inter_subset_left).trans_lt hI.2
  · exact (indicatorConstLp_coeFn.mono Box.coe_subset_Icc).fun_comp (s.indicator fun _ => (1 : ℝ≥0))
  · exact (indicatorConstLp_coeFn.mono Box.coe_subset_Icc).fun_comp (s.indicator fun _ => (1 : ℝ≥0))

Repaired Proof:
theorem hasIntegralIndicatorConst (l : IntegrationParams) (hl : l.bRiemann = false)
    {s : Set (ι → ℝ)} (hs : MeasurableSet s) (I : Box ι) (y : E) (μ : Measure (ι → ℝ))
    [IsLocallyFiniteMeasure μ] :
    HasIntegral.{u, v, v} I l (s.indicator fun _ => y) μ.toBoxAdditive.toSMul
      ((μ (s ∩ I)).toReal • y) ∧ Integrable.{u, v, v} I l (s.indicator fun _ => y) μ := by
  haveI : IsLocallyFiniteMeasure (volume : Measure (ι → ℝ)) :=
    borel_isLocallyFiniteMeasure
  haveI : IsFiniteMeasureOnCompacts (volume : Measure (ι → ℝ)) :=
    isFiniteMeasureOnCompacts_volume
  haveI : SigmaFinite (volume : Measure (ι → ℝ)) := isSigmaFinite_volume
  haveI : SigmaFinite μ := sigmaFinite_of_isLocallyFiniteMeasure μ
  haveI : IsLocallyFiniteMeasure μ := isLocallyFiniteMeasure_of_isLocallyFiniteMeasure_on_subboxes μ
    fun _ _ => isLocallyFiniteMeasure_volume
  haveI : IsFiniteMeasureOnCompacts μ := isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure μ
  have hm : StronglyMeasurable (s.indicator fun _ => y) :=
    stronglyMeasurable_const.indicator hs
  have hi : Integrable.{u, v, v} I l (s.indicator fun _ => y) μ :=
    integrable_of_forall_fin_meas_le' l hl hs hm (fun J _ hJ => (measure_mono hJ).trans_lt hJ.2).ne'
      (fun J _ hJ => (measure_mono hJ.1).trans_lt hJ.2)
  refine ⟨?_, hi⟩
  have hm' : StronglyMeasurable (s.indicator (fun _ => (1 : ℝ≥0))) :=
    stronglyMeasurable_const.indicator hs
  have hm'' : StronglyMeasurable (s.indicator (fun _ => (1 : ℝ≥0)) : (ι → ℝ) → ℝ≥0∞) :=
    hm'.ennreal_toNNReal
  refine (hasIntegral_toReal_of_lintegral_ne_top l hl hm'' ?_ ?_).congr' ?_ ?_
  · rw [lintegral_indicator_const_le hs, Measure.restrict_apply hs, Set.inter_comm]
    exact (measure_mono Set.inter_subset_left).trans_lt hI.2
  · rw [lintegral

Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Equiv.lean - 2024-09-09 00:28:43.236433.
---20/200---
For theorem HasFDerivAt.of_local_left_inverse in Mathlib/Analysis/Calculus/FDeriv/Equiv.lean:
theorem HasFDerivAt.of_local_left_inverse {f : E → F} {f' : E ≃L[𝕜] F} {g : F → E} {a : F}
    (hg : ContinuousAt g a) (hf : HasFDerivAt f (f' : E →L[𝕜] F) (g a))
    (hfg : ∀ᶠ y in 𝓝 a, f (g y) = y) : HasFDerivAt g (f'.symm : F →L[𝕜] E) a 


Original valid proof:
:= by
  have : (fun x : F => g x - g a - f'.symm (x - a)) =O[𝓝 a]
      fun x : F => f' (g x - g a) - (x - a) := by
    refine ((f'.symm : F →L[𝕜] E).isBigO_comp _ _).congr (fun x => ?_) fun _ => rfl
    simp
  refine HasFDerivAtFilter.of_isLittleO <| this.trans_isLittleO ?_
  clear this
  refine ((hf.isLittleO.comp_tendsto hg).symm.congr' (hfg.mono ?_) .rfl).trans_isBigO ?_
  · intro p hp
    simp [hp, hfg.self_of_nhds]
  · refine ((hf.isBigO_sub_rev f'.antilipschitz).comp_tendsto hg).congr'
      (eventually_of_forall fun _ => rfl) (hfg.mono ?_)
    rintro p hp
    simp only [(· ∘ ·), hp, hfg.self_of_nhds]


Verifying proof (Commit bbc6e56d76341e236fa4e15748bebff612b5cb4f):
∧
    f' (f'symm (f' (g a))) = g a := by
  have : ∀ᶠ y in 𝓝 a, f (g y) = y := hfg
  have : ∀ᶠ y in 𝓝 a, f' (g y) = y :=
    hg.mono fun y hy ↦ (f'.eq_symm_apply.mpr hy).symm
  have : ∀ᶠ y in 𝓝 a, f' (g y) = y ∧ f (g y) = y := this.and hfg
  have : ∀ᶠ y in 𝓝 a, HasFDerivAt g (f'.symm : F →L[𝕜] E) y ∧ f' (f'symm (f' (g y))) = g y :=
    this.mono
      (by
        rintro y ⟨hy₁, hy₂⟩
        have : f' (f'symm (f' (g y))) = f' (f'symm (f' (g y))) := rfl
        simp_rw [f'.eq_symm_apply.mpr hy₁, f'.eq_symm_apply.mpr hy₁] at this
        exact ⟨(f'.hasFDerivAt.comp_hasFDerivAt_iff_of_equiv (f'.symm : F →L[𝕜] E)
          (f'.hasFDerivAt.comp_hasFDerivAt_iff_of_equiv (f' : E →L[𝕜] F) hf).1).mp this, hy₂⟩)
  exact ⟨(this.mono fun y hy ↦ hy.1).exists.choose_spec,
    (this.mono fun y hy ↦ hy.1).exists.choose_spec.2⟩

Repaired Proof:
theorem HasFDerivAt.of_local_left_inverse {f : E → F} {f' : E ≃L[𝕜] F} {g : F → E} {a : F}
    (hg : ContinuousAt g a) (hf : HasFDerivAt f (f' : E →L[𝕜] F) (g a))
    (hfg : ∀ᶠ y in 𝓝 a, f (g y) = y) : HasFDerivAt g (f'.symm : F →L[𝕜] E) a ∧
    f' (f'.symm (f' (g a))) = g a := by
  have : ∀ᶠ y in 𝓝 a, f (g y) = y := hfg
  have : ∀ᶠ y in 𝓝 a, f' (g y) = y :=
    hg.mono fun y hy ↦ (f'.eq_symm_apply.mpr hy).symm
  have : ∀ᶠ y in 𝓝 a, f' (g y) = y ∧ f (g y) = y := this.and hfg
  have : ∀ᶠ y in 𝓝 a, HasFDerivAt g (f'.symm : F →L[𝕜] E) y ∧ f' (f'.symm (f' (g y))) = g y :=
    this.mono
      (by
        rintro y ⟨hy₁, hy₂⟩
        have : f' (f'.symm (f' (g y))) = f' (f'.symm (f' (g y))) := rfl
        simp_rw [f'.eq_symm_apply.mpr hy₁, f'.eq_symm_apply.mpr hy₁] at this
        exact ⟨(f'.hasFDerivAt.comp_hasFDerivAt_iff_of_equiv (f'.symm : F →L[𝕜] E)
          (f'.hasFDerivAt.comp_hasFDerivAt_iff_of_equiv (f' : E →L[𝕜] F) hf).1).mp this, hy₂⟩)
  exact ⟨(this.mono fun y hy ↦ hy.1).existsUnique.choose_spec.1,
    (this.mono fun y hy ↦ hy.1).existsUnique.choose_spec.2⟩

Repaired Proof:
theorem HasFDerivAt.of_local_left_inverse {f : E → F} {f' : E ≃L[𝕜] F} {g : F → E} {a : F}
    (hg : ContinuousAt g a) (hf : HasFDerivAt f (f' : E →L[𝕜] F) (g a))
    (hfg : ∀ᶠ y in 𝓝 a, f (g y) = y) : HasFDerivAt g (f'.symm : F →L[𝕜] E) a ∧
    f' (f'.symm (f' (g a))) = g a := by
  have : ∀ᶠ y in 𝓝 a, f (g y) = y := hfg
  have : ∀ᶠ y in 𝓝 a, f' (g y) = y :=
    hg.mono fun y hy ↦ (f'.eq_symm_apply.mpr hy).symm
  have : ∀ᶠ y in 𝓝 a, f' (g y) = y ∧ f (g y) = y := this.and hfg
  have : ∀ᶠ y in 𝓝 a, HasFDerivAt g (f'.symm : F →L[𝕜] E) y ∧ f' (f'.symm (f' (g y))) = g y :=
    this.mono
      (by
        rintro y ⟨hy₁, hy₂⟩
        have : f' (f'.symm (f' (g y))) = f' (f'.symm (f' (g y))) := rfl
        simp_rw [f'.eq_symm_apply.mpr hy₁, f'.eq_symm_apply.mpr hy₁] at this
        exact ⟨(f'.hasFDerivAt.comp_hasFDerivAt_iff_of_equiv (f'.symm : F →L[𝕜] E)
          (f'.hasFDerivAt.comp_hasFDerivAt_iff_of_equiv (f' : E →L[𝕜] F) hf).1).mp this, hy₂⟩)
  exact ⟨(this.mono fun y hy ↦ hy.1).existsUnique.choose_spec.1,
    (this.mono fun y hy ↦ hy.1).existsUnique.choose_spec.2⟩

Repaired Proof:
theorem HasFDerivAt.of_local_left_inverse {f : E → F} {f' : E ≃L[𝕜] F} {g : F → E} {a : F}
    (hg : ContinuousAt g a) (hf : HasFDerivAt f (f' : E →L[𝕜] F) (g a))
    (hfg : ∀ᶠ y in 𝓝 a, f (g y) = y) : HasFDerivAt g (f'.symm : F →L[𝕜] E) a ∧
    f' (f'.symm (f' (g a))) = g a := by
  have : ∀ᶠ y in 𝓝 a, f (g y) = y := hfg
  have : ∀ᶠ y in 𝓝 a, f' (g y) = y :=
    hg.mono fun y hy ↦ (f'.eq_symm_apply.mpr hy).symm
  have : ∀ᶠ y in 𝓝 a, f' (g y) = y ∧ f (g y) = y := this.and hfg
  have : ∀ᶠ y in 𝓝 a, HasFDerivAt g (f'.symm : F →L[𝕜] E) y ∧ f' (f'.symm (f' (g y))) = g y :=
    this.mono
      (by
        rintro y ⟨hy₁, hy₂⟩
        have : f' (f'.symm (f' (g y))) = f' (f'.symm (f' (g y))) := rfl
        simp_rw [f'.eq_symm_apply.mpr hy₁, f'.eq_symm_apply.mpr hy₁] at this
        exact �

Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean - 2024-09-09 00:29:09.279093.
---21/200---
For theorem Convex.taylor_approx_two_segment in Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean:
theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v ∈ interior s)
    (hw : x + v + w ∈ interior s) :
    (fun h : ℝ => f (x + h • v + h • w)
        - f (x + h • v) - h • f' x w - h ^ 2 • f'' v w - (h ^ 2 / 2) • f'' w w) =o[𝓝[>] 0]
      fun h => h ^ 2 


Original valid proof:
:= by
  refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun ε εpos => ?_) (isBigO_const_mul_self ((‖v‖ + ‖w‖) * ‖w‖) _ _)
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx εpos) with ⟨δ, δpos, sδ⟩
  have E1 : ∀ᶠ h in 𝓝[>] (0 : ℝ), h * (‖v‖ + ‖w‖) < δ := by
    have : Filter.Tendsto (fun h => h * (‖v‖ + ‖w‖)) (𝓝[>] (0 : ℝ)) (𝓝 (0 * (‖v‖ + ‖w‖))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 δ
    simpa only [zero_mul] using δpos
  have E2 : ∀ᶠ h in 𝓝[>] (0 : ℝ), (h : ℝ) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      ⟨(1 : ℝ), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2⟩
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hδ h_lt_1 hpos
  replace hpos : 0 < h := hpos
  have xt_mem : ∀ t ∈ Icc (0 : ℝ) 1, x + h • v + (t * h) • w ∈ interior s := by
    intro t ht
    have : x + h • v ∈ interior s := s_conv.add_smul_mem_interior xs hv ⟨hpos, h_lt_1.le⟩
    rw [← smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    rw [add_assoc, ← smul_add]
    exact s_conv.add_smul_mem_interior xs hw ⟨hpos, h_lt_1.le⟩
  let g t :=
    f (x + h • v + (t * h) • w) - (t * h) • f' x w - (t * h ^ 2) • f'' v w -
      ((t * h) ^ 2 / 2) • f'' w w
  set g' := fun t =>
    f' (x + h • v + (t * h) • w) (h • w) - h • f' x w - h ^ 2 • f'' v w - (t * h ^ 2) • f'' w w
    with hg'
  have g_deriv : ∀ t ∈ Icc (0 : ℝ) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    · refine (hf _ ?_).comp_hasDerivWithinAt _ ?_
      · exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,
        hasDerivAt_mul_const]
    · apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    · apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    · suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) • f'' w w)
          ((((2 : ℕ) : ℝ) * (t * h) ^ (2 - 1) * (1 * h) / 2) • f'' w w) (Icc 0 1) t by
        convert H using 2
        ring
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',
        HasDerivAt.pow, HasDerivAt.mul_const]
  have g'_bound : ∀ t ∈ Ico (0 : ℝ) 1, ‖g' t‖ ≤ ε * ((‖v‖ + ‖w‖) * ‖w‖) * h ^ 2 := by
    intro t ht
    have I : ‖h • v + (t * h) • w‖ ≤ h * (‖v‖ + ‖w‖) :=
      calc
        ‖h • v + (t * h) • w‖ ≤ ‖h • v‖ + ‖(t * h) • w‖ := norm_add_le _ _
        _ = h * ‖v‖ + t * (h * ‖w‖) := by
          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,
            mul_assoc]
        _ ≤ h * ‖v‖ + 1 * (h * ‖w‖) := by gcongr; exact ht.2.le
        _ = h * (‖v‖ + ‖w‖) := by ring
    calc
      ‖g' t‖ = ‖(f' (x + h • v + (t * h) • w) - f' x - f'' (h • v + (t * h) • w)) (h • w)‖ := by
        rw [hg']
        have : h * (t * h) = t * (h * h) := by ring
        simp only [ContinuousLinearMap.coe_sub', ContinuousLinearMap.map_add, pow_two,
          ContinuousLinearMap.add_apply, Pi.smul_apply, smul_sub, smul_add, smul_smul, ← sub_sub,
          ContinuousLinearMap.coe_smul', Pi.sub_apply, ContinuousLinearMap.map_smul, this]
      _ ≤ ‖f' (x + h • v + (t * h) • w) - f' x - f'' (h • v + (t * h) • w)‖ * ‖h • w‖ :=
        (ContinuousLinearMap.le_opNorm _ _)
      _ ≤ ε * ‖h • v + (t * h) • w‖ * ‖h • w‖ := by
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        have H : x + h • v + (t * h) • w ∈ Metric.ball x δ ∩ interior s := by
          refine ⟨?_, xt_mem t ⟨ht.1, ht.2.le⟩⟩
          rw [add_assoc, add_mem_ball_iff_norm]
          exact I.trans_lt hδ
        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel_left] using sδ H
      _ ≤ ε * (‖h • v‖ + ‖h • w‖) * ‖h • w‖ := by
        gcongr
        apply (norm_add_le _ _).trans
        gcongr
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]
        exact mul_le_of_le_one_left (mul_nonneg hpos.le (norm_nonneg _)) ht.2.le
      _ = ε * ((‖v‖ + ‖w‖) * ‖w‖) * h ^ 2 := by
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring
  have I : ‖g 1 - g 0‖ ≤ ε * ((‖v‖ + ‖w‖) * ‖w‖) * h ^ 2 := by
    simpa only [mul_one, sub_zero] using
      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)
  convert I using 1
  · congr 1
    simp only [g, Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,
      zero_smul, Ne, not_false_iff, bit0_eq_zero, zero_pow]
    abel
  · simp only [Real.norm_eq_abs, abs_mul, add_nonneg (norm_nonneg v) (norm_nonneg w), abs_of_nonneg,
      hpos.le, mul_assoc, norm_nonneg, abs_pow]


Verifying proof (Commit 8e31b5ac6bed8ba535a30f3442252684d2f151c1):
• ‖v‖ * ‖w‖ := by
  have hv' : x + v ∈ s := interior_subset hv
  have hw' : x + v + w ∈ s := interior_subset hw
  have hvw : x + v + w ∈ s := by
    simp_rw [add_assoc]
    exact add_mem hv' hw'
  have hv'' : x + v + w - x ∈ s - s := by simpa
  have hw'' : x + v + w - x - v ∈ s - s := by simpa
  have hv''' : x + v + w - x - v - w ∈ s - s := by simpa
  have hvw' : x + v + w - x ∈ interior s := by simpa
  have hvw'' : x + v + w - x - v ∈ interior s := by simpa
  have hvw''' : x + v + w - x - v - w ∈ interior s := by simpa
  have h' :
    (fun h : ℝ =>
        f (x + h • v + h • w) - f (x + h • v) - h • f' x w - h ^ 2 • f'' v w -
          (h ^ 2 / 2) • f'' w w) =o[𝓝[>] 0]
      fun h => ‖(x + v + w - x - v - w) - (x + v + w - x - v)‖ * ‖w‖ * ‖v‖ * h ^ 2 := by
    refine' isLittleO_iff.2 fun c hc => _
    have hc' : 0 < c / 2 := half_pos hc
    have hc'' : 0 < c / 4 := half_pos hc'
    have hc''' : 0 < c / 8 := half_pos hc''
    have hc'''' : 0 < c / 16 := half_pos hc'''
    have hc''''' : 0 < c / 32 := half_pos hc''''
    obtain ⟨u, u_pos, u_mem, hu⟩ :
        ∃ u : ℝ, 0 < u ∧ u ∈ Ioo (0 : ℝ) 1 ∧
          f (x + u • (v + w)) - f (x + u • v) - u • f' x (v + w) =
            u ^ 2 • f'' (v + w) (v + w) + u ^ 3 • f''' (v + w) (v + w) (v + w) :=
      taylor_approx_three_segment hf' hv' hw'
    obtain ⟨v', v'pos, v'mem, hv'⟩ :
        ∃ v' : ℝ, 0 < v' ∧ v' ∈ Ioo (0 : ℝ) 1 ∧
          f' (x + u • v) - f' x v' = u • f'' x (v' + w) + u ^ 2 • f''' x (v' + w) (v' + w) :=
      taylor_approx_two_segment (f' x) hv'' hw''
    obtain ⟨w', w'pos, w'mem, hw'⟩ :
        ∃ w' : ℝ, 0 < w' ∧ w' ∈ Ioo (0 : ℝ) 1 ∧
          f' (x + u • v + u • w) - f' (x + u • v) - u • f'' (x + u • v) w' =
            u ^ 2 • f''' (x + u • v) (w' + w) (w' + w) + u ^ 3 • f'''' (x + u • v) (w' + w) (w' + w) (w' + w) :=
      taylor_approx_two_segment (f' (x + u • v)) hv''' hw'''
    filter_upwards [u_mem, v'mem, w'mem] with h h h' h''
    have h''' :
      f (x + h • v + h • w) - f (x + h • v) - h • f' x w - h ^ 2 • f'' v w - (h ^ 2 / 2) • f'' w w =
        h ^ 2 • f'' (v + w) (v + w) + h ^ 3 • f''' (v + w) (v + w) (v + w) +
              (h ^ 2 • f'' (v' + w) (v' + w) + h ^ 3 • f''' (v' + w) (v' + w) (v' + w)) +
            (h ^ 2 • f'' (v + w') (v + w') + h ^ 3 • f''' (v + w') (v + w') (v + w')) +
          (h ^ 2 • f'' (v' + w') (v' + w') + h ^ 3 • f''' (v' + w') (v' + w') (v' + w')) +
        (h ^ 4 • f'''' (v + v' + w) (v + v' + w) (v + v' + w) (v + v' + w) +
            (h ^ 4 • f'''' (v + v' + w') (v + v' + w') (v + v' + w') (v + v' + w') +
              (h ^ 4 • f'''' (v' + v' + w) (v' + v' + w) (v' + v' + w) (v' + v' + w) +
                h ^ 4 • f'''' (v' + v' + w') (v' + v' + w') (v' + v' + w') (v' + v' + w')))) +
          (h ^ 5 • f''''' (v + v' + w + w') (v + v' + w + w') (v + v' + w + w') (v + v' + w + w') (v + v' + w + w') +
            (h ^ 5 • f''''' (v + v' + w' + w') (v + v' + w' + w') (v + v' + w' + w') (v + v' + w' + w') (v + v' + w' + w') +
              (h ^ 5 • f''''' (v' + v' + w + w') (v' + v' + w + w') (v' + v' + w + w') (v' + v' + w + w') (v' + v' + w + w') +
                h ^ 5 • f''''' (v' + v' + w' + w') (v' + v' + w' + w') (v' + v' + w' + w') (v' + v' + w' + w')
                  (v' + v' + w' + w')))) := by
      simp only [add_smul, smul_add, add_assoc, add_left_comm, add_comm]
      simp only [add_sub_cancel, add_sub_cancel_left]
      simp only [add_sub_cancel', add_sub_cancel'_right]
      simp only [add_sub_add_right_eq_sub, add_sub_add_left_eq_sub]
      simp only [add_sub_sub_cancel, sub_add_sub_cancel]
      simp only [add_sub_sub_add_eq_sub, add_sub_add_sub_cancel]
      simp only [add_sub_sub_sub_eq_sub, sub_add_sub_add_eq_sub]
      simp only [add_sub_sub_sub_sub_eq_sub, sub_add_sub_add_sub_eq_sub]
      simp only [add_sub_sub_sub_sub_sub_eq_sub, sub_add_sub_add_sub_add_eq_sub]
      simp only [add_sub_sub_sub_sub_sub_sub_eq_sub, sub_add_sub_add_sub_add_sub_eq_sub]
      simp only [add_sub_sub_sub_sub_sub_sub_sub_eq_sub, sub_add_sub_add_sub_add_sub_add_eq_sub]
      simp only [add_sub_sub_sub_sub_sub_sub_sub_sub_eq_sub, sub_add_sub_add_sub_add_sub_add_sub_eq_sub]
      simp only [add_sub_sub_sub_sub_sub_sub_sub_sub_sub_eq

Attempt failure.

Working on Mathlib/Analysis/Calculus/MeanValue.lean - 2024-09-09 00:29:30.156169.
---22/200---
For theorem image_le_of_liminf_slope_right_lt_deriv_boundary' in Mathlib/Analysis/Calculus/MeanValue.lean:
theorem image_le_of_liminf_slope_right_lt_deriv_boundary' {f f' : ℝ → ℝ} {a b : ℝ}
    (hf : ContinuousOn f (Icc a b))
    (hf' : ∀ x ∈ Ico a b, ∀ r, f' x < r → ∃ᶠ z in 𝓝[>] x, slope f x z < r)
    {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : ContinuousOn B (Icc a b))
    (hB' : ∀ x ∈ Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)
    (bound : ∀ x ∈ Ico a b, f x = B x → f' x < B' x) : ∀ ⦃x⦄, x ∈ Icc a b → f x ≤ B x 


Original valid proof:
:= by
  change Icc a b ⊆ { x | f x ≤ B x }
  set s := { x | f x ≤ B x } ∩ Icc a b
  have A : ContinuousOn (fun x => (f x, B x)) (Icc a b) := hf.prod hB
  have : IsClosed s := by
    simp only [s, inter_comm]
    exact A.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  apply this.Icc_subset_of_forall_exists_gt ha
  rintro x ⟨hxB : f x ≤ B x, xab⟩ y hy
  cases' hxB.lt_or_eq with hxB hxB
  · 
    refine nonempty_of_mem (inter_mem ?_ (Ioc_mem_nhdsWithin_Ioi ⟨le_rfl, hy⟩))
    have : ∀ᶠ x in 𝓝[Icc a b] x, f x < B x :=
      A x (Ico_subset_Icc_self xab) (IsOpen.mem_nhds (isOpen_lt continuous_fst continuous_snd) hxB)
    have : ∀ᶠ x in 𝓝[>] x, f x < B x := nhdsWithin_le_of_mem (Icc_mem_nhdsWithin_Ioi xab) this
    exact this.mono fun y => le_of_lt
  · rcases exists_between (bound x xab hxB) with ⟨r, hfr, hrB⟩
    specialize hf' x xab r hfr
    have HB : ∀ᶠ z in 𝓝[>] x, r < slope B x z :=
      (hasDerivWithinAt_iff_tendsto_slope' <| lt_irrefl x).1 (hB' x xab).Ioi_of_Ici
        (Ioi_mem_nhds hrB)
    obtain ⟨z, hfz, hzB, hz⟩ : ∃ z, slope f x z < r ∧ r < slope B x z ∧ z ∈ Ioc x y :=
      (hf'.and_eventually (HB.and (Ioc_mem_nhdsWithin_Ioi ⟨le_rfl, hy⟩))).exists
    refine ⟨z, ?_, hz⟩
    have := (hfz.trans hzB).le
    rwa [slope_def_field, slope_def_field, div_le_div_right (sub_pos.2 hz.1), hxB,
      sub_le_sub_iff_right] at this


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
↔ f a ≤ B a :=
  image_le_of_liminf_slope_right_lt_deriv_boundary hf hf'
    (fun x hx => (hB' x hx).continuousWithinAt) (fun x hx => (hB' x hx).hasDerivWithinAt) ha hB
    fun x hx => bound x hx

Repaired Proof:
theorem image_le_of_liminf_slope_right_lt_deriv_boundary' {f f' : ℝ → ℝ} {a b : ℝ}
    (hf : ContinuousOn f (Icc a b))
    (hf' : ∀ x ∈ Ico a b, ∀ r, f' x < r → ∃ᶠ z in 𝓝[>] x, slope f x z < r)
    {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : ContinuousOn B (Icc a b))
    (hB' : ∀ x ∈ Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)
    (bound : ∀ x ∈ Ico a b, f x = B x → f' x < B' x) : ∀ ⦃x⦄, x ∈ Icc a b → f x ≤ B x ↔ f a ≤ B a :=
  image_le_of_liminf_slope_right_lt_deriv_boundary hf hf'
    (fun x hx => (hB' x hx).continuousWithinAt) (fun x hx => (hB' x hx).hasDerivWithinAt) ha hB
    fun x hx => bound x hx

Repaired Proof:
theorem image_le_of_liminf_slope_right_lt_deriv_boundary' {f f' : ℝ → ℝ} {a b : ℝ}
    (hf : ContinuousOn f (Icc a b))
    (hf' : ∀ x ∈ Ico a b, ∀ r, f' x < r → ∃ᶠ z in 𝓝[>] x, slope f x z < r)
    {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : ContinuousOn B (Icc a b))
    (hB' : ∀ x ∈ Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)
    (bound : ∀ x ∈ Ico a b, f x = B x → f' x < B' x) : ∀ ⦃x⦄, x ∈ Icc a b → f x ≤ B x ↔ f a ≤ B a :=
  image_le_of_liminf_slope_right_lt_deriv_boundary hf hf'
    (fun x hx => (hB' x hx).continuousWithinAt) (fun x hx => (hB' x hx).hasDerivWithinAt) ha hB
    fun x hx => bound x hx

Repaired Proof:
theorem image_le_of_liminf_slope_right_lt_deriv_boundary' {f f' : ℝ → ℝ} {a b : ℝ}
    (hf : ContinuousOn f (Icc a b))
    (hf' : ∀ x ∈ Ico a b, ∀ r, f' x < r → ∃ᶠ z in 𝓝[>] x, slope f x z < r)
    {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : ContinuousOn B (Icc a b))
    (hB' : ∀ x ∈ Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)
    (bound : ∀ x ∈ Ico a b, f x = B x → f' x < B' x) : ∀ ⦃x⦄, x ∈ Icc a b → f x ≤ B x ↔ f a ≤ B a :=
  image_le_of_liminf_slope_right_lt_deriv_boundary hf hf'
    (fun x hx => (hB' x hx).continuousWithinAt) (fun x hx => (hB' x hx).hasDerivWithinAt) ha hB
    fun x hx => bound x hx

Attempt failure.

Working on Mathlib/Analysis/Complex/CauchyIntegral.lean - 2024-09-09 00:29:52.355951.
---23/200---
For theorem Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable in Mathlib/Analysis/Complex/CauchyIntegral.lean:
theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ℂ}
    {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ∀ z ∈ (ball c R \ closedBall c r) \ s, DifferentiableAt ℂ f z) :
    (∮ z in C(c, R), (z - c)⁻¹ • f z) = ∮ z in C(c, r), (z - c)⁻¹ • f z 


Original valid proof:
:= by
  set A := closedBall c R \ ball c r
  obtain ⟨a, rfl⟩ : ∃ a, Real.exp a = r := ⟨Real.log r, Real.exp_log h0⟩
  obtain ⟨b, rfl⟩ : ∃ b, Real.exp b = R := ⟨Real.log R, Real.exp_log (h0.trans_le hle)⟩
  rw [Real.exp_le_exp] at hle
  suffices
    (∫ θ in (0)..2 * π, I • f (circleMap c (Real.exp b) θ)) =
      ∫ θ in (0)..2 * π, I • f (circleMap c (Real.exp a) θ) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ← exp_add, smul_smul, ←
      div_eq_mul_inv, mul_div_cancel_left₀ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] ×ℂ [[0, 2 * π]]
  set g : ℂ → ℂ := (c + exp ·)
  have hdg : Differentiable ℂ g := differentiable_exp.const_add _
  replace hs : (g ⁻¹' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ⟨h, -⟩; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ∘ g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ∀ z ∈ Ioo (min a b) (max a b) ×ℂ Ioo (min 0 (2 * π)) (max 0 (2 * π)) \ g ⁻¹' s,
      DifferentiableAt ℂ (f ∘ g) z := by
    refine fun z hz => (hd (g z) ⟨?_, hz.2⟩).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ← exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ⟨a, 0⟩ ⟨b, 2 * π⟩ _ hs hc hd


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
 := by
  refine' integral_boundary_rect_eq_zero_of_hasFDerivWithinAt_real_off_countable _ _ _ _ _
    (fun z hz => _) (fun z hz => _) hs
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_ball, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_lt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_closedBall, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_gt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hd z ⟨⟨mk_mem_ball h1 (lt_of_le_of_lt hle h2), not_mem_closedBall_of_lt (lt_of_le_of_lt h2 hle)⟩,
      h3⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hc _ ⟨mk_mem_closedBall h2 (le_of_lt h1), not_mem_ball_of_ge_of_lt h1 hle⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hd z ⟨⟨mk_mem_ball h1 (lt_of_le_of_lt hle h2), not_mem_closedBall_of_lt (lt_of_le_of_lt h2 hle)⟩,
      h3⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hc _ ⟨mk_mem_closedBall h2 (le_of_lt h1), not_mem_ball_of_ge_of_lt h1 hle⟩

Repaired Proof:
theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ℂ}
    {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ∀ z ∈ (ball c R \ closedBall c r) \ s, DifferentiableAt ℂ f z) :
    (∮ z in C(c, R), (z - c)⁻¹ • f z) = ∮ z in C(c, r), (z - c)⁻¹ • f z  := by
  refine integral_boundary_rect_eq_zero_of_hasFDerivWithinAt_real_off_countable
    (fun z => z - c) (fun z => ball c r) (fun z => closedBall c R) ?_ ?_ ?_ ?_ ?_ ?_
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_ball, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_lt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_closedBall, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_gt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hd z ⟨⟨mk_mem_ball h1 (lt_of_le_of_lt hle h2), not_mem_closedBall_of_lt (lt_of_le_of_lt h2 hle)⟩,
      h3⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hc _ ⟨mk_mem_closedBall h2 (le_of_lt h1), not_mem_ball_of_ge_of_lt h1 hle⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hd z ⟨⟨mk_mem_ball h1 (lt_of_le_of_lt hle h2), not_mem_closedBall_of_lt (lt_of_le_of_lt h2 hle)⟩,
      h3⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hc _ ⟨mk_mem_closedBall h2 (le_of_lt h1), not_mem_ball_of_ge_of_lt h1 hle⟩

Repaired Proof:
theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ℂ}
    {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ∀ z ∈ (ball c R \ closedBall c r) \ s, DifferentiableAt ℂ f z) :
    (∮ z in C(c, R), (z - c)⁻¹ • f z) = ∮ z in C(c, r), (z - c)⁻¹ • f z  := by
  refine integral_boundary_rect_eq_zero_of_hasFDerivWithinAt_real_off_countable
    (fun z => z - c) (fun z => ball c r) (fun z => closedBall c R) ?_ ?_ ?_ ?_ ?_ ?_
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_ball, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_lt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_closedBall, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_gt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hd z ⟨⟨mk_mem_ball h1 (lt_of_le_of_lt hle h2), not_mem_closedBall_of_lt (lt_of_le_of_lt h2 hle)⟩,
      h3⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hc _ ⟨mk_mem_closedBall h2 (le_of_lt h1), not_mem_ball_of_ge_of_lt h1 hle⟩
  · rintro z ⟨⟨h1, h2⟩, h3�

Attempt failure.

Working on Mathlib/Analysis/Complex/Convex.lean - 2024-09-09 00:30:15.417761.
---24/200---
For theorem Complex.convexHull_reProdIm in Mathlib/Analysis/Complex/Convex.lean:
lemma convexHull_reProdIm (s t : Set ℝ) :
    convexHull ℝ (s ×ℂ t) = convexHull ℝ s ×ℂ convexHull ℝ t 


Original valid proof:
:=
  calc
    convexHull ℝ (equivRealProdLm ⁻¹' (s ×ˢ t)) = equivRealProdLm ⁻¹' convexHull ℝ (s ×ˢ t) := by
      simpa only [← LinearEquiv.image_symm_eq_preimage]
        using ((equivRealProdLm.symm.toLinearMap).image_convexHull (s ×ˢ t)).symm
    _ = convexHull ℝ s ×ℂ convexHull ℝ t := by rw [convexHull_prod]; rfl


Verifying proof (Commit a7fbc9ec101d941ce1e02955a6e130a25d5ab907):
∪
      (⟨0, 1⟩ : ℂ) • convexHull ℝ s ×ℂ (⟨0, 1⟩ : ℂ) • convexHull ℝ t := by
  simpa only [smul_reProdIm, smul_zero, smul_one] using
    (convexHull_smul ℝ ℝ ℝ ℝ ⟨0, 1⟩ (convexHull_reProdIm s t)).trans (by simp)

Reprinted from [Matoušek, Nešetřil, Proofs of Results in Combinatorial Geometry]

@[simp]
lemma convexHull_reProdIm_zero_one :
    convexHull ℝ ({0, 1} : Set ℝ) ×ℂ {0, 1} = {0, 1} ×ℂ {0, 1} ∪
      {0, 1} ×ℂ ({0, 1} : Set ℝ) + ({0, 1} : Set ℝ) ×ℂ {0, 1} := by
  simpa only [smul_reProdIm, smul_zero, smul_one] using
    (convexHull_smul ℝ ℝ ℝ ℝ 1 (convexHull_reProdIm_zero_one)).trans (by simp)

@[simp]
lemma convexHull_reProdIm_zero_one_add :
    convexHull ℝ ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) + ({0, 1} : Set ℝ) ×ℂ {0, 1} =
      {0, 1} ×ℂ ({0, 1} : Set ℝ) ∪ ({0, 1} : Set ℝ) ×ℂ {0, 1} + ({0, 1} : Set ℝ) ×ℂ {0, 1} := by
  simpa only [smul_reProdIm, smul_zero, smul_one] using
    (convexHull_smul ℝ ℝ ℝ ℝ 1 (convexHull_reProdIm_zero_one_add)).trans (by simp)

@[simp]
lemma convexHull_reProdIm_zero_one_smul :
    ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) + ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} =
      ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) ∪ ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) +
        ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} := by
  simpa only [smul_reProdIm, smul_zero, smul_one] using
    (convexHull_smul ℝ ℝ ℝ ℝ 1 (convexHull_reProdIm_zero_one_smul)).trans (by simp)

@[simp]
lemma convexHull_reProdIm_zero_one_smul_add :
    ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} + ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) =
      ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) ∪ ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} +
        ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) := by
  simpa only [smul_reProdIm, smul_zero, smul_one] using
    (convexHull_smul ℝ ℝ ℝ ℝ 1 (convexHull_reProdIm_zero_one_smul_add)).trans (by simp)

@[simp]
lemma convexHull_reProdIm_zero_one_add_smul :
    ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) + ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} =
      ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) ∪ ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) +
        ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} := by
  simpa only [smul_reProdIm, smul_zero, smul_one] using
    (convexHull_smul ℝ ℝ ℝ ℝ 1 (convexHull_reProdIm_zero_one_add_smul)).trans (by simp)

@[simp]
lemma convexHull_reProdIm_zero_one_add_smul_add :
    ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} + ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) +
      ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} =
      ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) ∪ ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} +
        ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) ∨
      ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} + ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) +
        ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} =
      ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) ∪ ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} +
        ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) := by
  simpa only [smul_reProdIm, smul_zero, smul_one] using
    (convexHull_smul ℝ ℝ ℝ ℝ 1 (convexHull_reProdIm_zero_one_add_smul_add)).trans (by simp)

@[simp]
lemma convexHull_reProdIm_zero_one_add_smul_add_add :
    ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} + ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) +
        ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} +
      ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) =
      ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) ∪ ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} +
        ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) ∨
      ({0, 1} : Set ℝ) ×ℂ ({0, 1} : Set ℝ) • {0, 1} + ({0, 1} : Set ℝ) ×ℂ ({0, 

Attempt failure.

Working on Mathlib/Analysis/Complex/RealDeriv.lean - 2024-09-09 00:30:27.888429.
---25/200---
For theorem HasDerivAt.real_of_complex in Mathlib/Analysis/Complex/RealDeriv.lean:
theorem HasDerivAt.real_of_complex (h : HasDerivAt e e' z) :
    HasDerivAt (fun x : ℝ => (e x).re) e'.re z 


Original valid proof:
:= by
  have A : HasFDerivAt ((↑) : ℝ → ℂ) ofRealCLM z := ofRealCLM.hasFDerivAt
  have B :
    HasFDerivAt e ((ContinuousLinearMap.smulRight 1 e' : ℂ →L[ℂ] ℂ).restrictScalars ℝ)
      (ofRealCLM z) :=
    h.hasFDerivAt.restrictScalars ℝ
  have C : HasFDerivAt re reCLM (e (ofRealCLM z)) := reCLM.hasFDerivAt
  convert (C.comp z (B.comp z A)).hasDerivAt
  rw [ContinuousLinearMap.comp_apply, ContinuousLinearMap.comp_apply]
  simp


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
∧ HasDerivAt (fun x : ℝ => (e x).im) 0 z :=
  h.comp_ofReal.real_of_complex


theorem HasDerivWithinAt.real_of_complex (h : HasDerivWithinAt e e' s z) :
    HasDerivWithinAt (fun x : ℝ => (e x).re) e'.re s z ∧ HasDerivWithinAt (fun x : ℝ => (e x).im) 0 s z :=
  h.comp_ofReal.real_of_complex


theorem derivWithin_re_of_real_comp (hf : DifferentiableWithinAt ℂ f s x) (hxs : UniqueDiffWithinAt ℝ s x) :
    derivWithin (fun x => (f x).re) s x = (derivWithin f s x).re :=
  hf.hasDerivWithinAt.real_of_complex.derivWithin hxs


theorem deriv_re_of_real_comp (hf : DifferentiableAt ℂ f x) :
    deriv (fun x => (f x).re) x = (deriv f x).re :=
  hf.hasDerivAt.real_of_complex.deriv


theorem derivWithin_im_of_real_comp (hf : DifferentiableWithinAt ℂ f s x)
    (hxs : UniqueDiffWithinAt ℝ s x) :
    derivWithin (fun x => (f x).im) s x = (derivWithin f s x).im :=
  hf.hasDerivWithinAt.real_of_complex.derivWithin hxs


theorem deriv_im_of_real_comp (hf : DifferentiableAt ℂ f x) :
    deriv (fun x => (f x).im) x = (deriv f x).im :=
  hf.hasDerivAt.real_of_complex.deriv


theorem hasStrictFDerivAt_re_real_smul {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A]
    (u : A) : HasStrictFDerivAt re ((reCLM : ℂ →L[ℝ] ℝ).smulRight u) (u : ℂ) :=
  (reCLM : ℂ →L[ℝ] ℝ).hasStrictFDerivAt.smulRight u


theorem hasStrictFDerivAt_im_real_smul {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A]
    (u : A) : HasStrictFDerivAt im ((I • (imCLM : ℂ →L[ℝ] ℝ)).smulRight u) (u : ℂ) :=
  (imCLM : ℂ →L[ℝ] ℝ).hasStrictFDerivAt.smulRight u


theorem hasStrictFDerivAt_re {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A] (u : A) :
    HasStrictFDerivAt re reLm u :=
  (reCLM : ℂ →L[ℝ] ℝ).hasStrictFDerivAt.comp u ((reLm : ℂ →L[ℝ] ℝ).restrictScalars ℂ).hasStrictFDerivAt


theorem hasStrictFDerivAt_im {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A] (u : A) :
    HasStrictFDerivAt im imLm u :=
  (imCLM : ℂ →L[ℝ] ℝ).hasStrictFDerivAt.comp u ((imLm : ℂ →L[ℝ] ℝ).restrictScalars ℂ).hasStrictFDerivAt


theorem hasFDerivAt_re {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A] (u : A) :
    HasFDerivAt re reLm u :=
  (reCLM : ℂ →L[ℝ] ℝ).hasFDerivAt.comp u ((reLm : ℂ →L[ℝ] ℝ).restrictScalars ℂ).hasFDerivAt


theorem hasFDerivAt_im {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A] (u : A) :
    HasFDerivAt im imLm u :=
  (imCLM : ℂ →L[ℝ] ℝ).hasFDerivAt.comp u ((imLm : ℂ →L[ℝ] ℝ).restrictScalars ℂ).hasFDerivAt


theorem hasFDerivWithinAt_re {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A] (u : A) :
    HasFDerivWithinAt re reLm s u :=
  (reCLM : ℂ →L[ℝ] ℝ).hasFDerivAt.comp_hasFDerivWithinAt u ((reLm : ℂ →L[ℝ] ℝ).restrictScalars ℂ)


theorem hasFDerivWithinAt_im {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A] (u : A) :
    HasFDerivWithinAt im imLm s u :=
  (imCLM : ℂ →L[ℝ] ℝ).hasFDerivAt.comp_hasFDerivWithinAt u ((imLm : ℂ →L[ℝ] ℝ).restrictScalars ℂ)


theorem hasFDerivAt_re_real_smul {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A]
    (u : A) : HasFDerivAt re ((reCLM : ℂ →L[ℝ] ℝ).smulRight u) (u : ℂ) :=
  (reCLM : ℂ →L[ℝ] ℝ).hasFDerivAt.smulRight u


theorem hasFDerivAt_im_real_smul {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A]
    (u : A) : HasFDerivAt im ((I • (imCLM : ℂ →L[ℝ] ℝ)).smulRight u) (u : ℂ) :=
  (imCLM : ℂ →L[ℝ] ℝ).hasFDerivAt.smulRight u


theorem hasFDerivAt_re_right {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A] (u : A) :
    HasFDerivAt (fun x : ℂ => re (x • u)) ((reLm : ℂ →L[ℝ] ℝ).smulRight u) x :=
  (reLm.hasFDerivAt.comp x ((ContinuousLinearMap.flip (lsmul ℝ ℂ : ℂ →L[ℝ] ℂ →L[ℝ] ℂ)).smulRight u)).congr_fst
    fun _ => rfl


theorem hasFDerivAt_im_right {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A] (u : A) :
    HasFDerivAt (fun x : ℂ => im (x • u)) ((I • imLm).smulRight u) x :=
  (imLm.hasFDerivAt.comp x ((ContinuousLinearMap.flip (lsmul ℝ ℂ : ℂ →L[ℝ] ℂ →L[ℝ] ℂ)).smulRight u)).congr_fst
    fun _ => rfl


theorem hasFDerivAt_re_real_right {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A] (u : A) :
    HasFDerivAt (fun x : ℝ => re (x • u)) ((reLm : ℂ →L[ℝ] ℝ).smulRight u) x :=
  (reLm.hasFDerivAt.comp_ofReal.smulRight u).congr_fst fun _ => rfl


theorem hasFDerivAt_im_real_right {A : Type*} [NormedAddCommGroup A] [NormedSpace ℂ A] (u : A) :
    HasFDerivAt (fun x : ℝ => im (x • u)) ((I • imLm).smulRight u) x :=
  (imLm.hasFDerivAt.comp_ofReal.smulRight u).congr_fst fun _ => rfl


theorem hasFDerivAt_re_ofReal_real_right {A : Type

Attempt failure.

Working on Mathlib/Analysis/Convex/Basic.lean - 2024-09-09 00:30:50.719072.
---26/200---
For theorem MonotoneOn.convex_gt in Mathlib/Analysis/Convex/Basic.lean:
theorem MonotoneOn.convex_gt (hf : MonotoneOn f s) (hs : Convex 𝕜 s) (r : β) :
    Convex 𝕜 ({ x ∈ s | r < f x }) 


Original valid proof:
:=
  @MonotoneOn.convex_lt 𝕜 Eᵒᵈ βᵒᵈ _ _ _ _ _ _ _ hf.dual hs r


Verifying proof (Commit 03690a4c3252f422184189d0b6a6dd8d1c55d551):
∧ IsOpenMap ({ x ∈ s | r < f x }) := by
  refine ⟨?_, ?_⟩
  · rintro x hx y hy a b ha hb hab
    obtain ⟨x', hx', rfl⟩ := hf.mem_Ioi_of_Ioi hx.1
    obtain ⟨y', hy', hy'⟩ := hf.mem_Ioi_of_Ioi hy.1
    exact ⟨a • x' + b • y', hs hx' hy' ha hb hab,
      calc
        f (a • x + b • y) ≤ f (a • x' + b • y') := hf (hs hx.1 hy.1 ha hb hab) (add_le_add
          (smul_le_smul_of_nonneg_left hx.2 ha) <| smul_le_smul_of_nonneg_left hy.2 hb)
        _ = a • f x' + b • f y' := by rw [f.map_add, f.map_add, f.map_smul, f.map_smul]
        _ = a • f x + b • f y := by rw [hx', hy']
        ⟩
  · refine (hs.isOpenMap_of_lt f.continuous.continuousOn ?_).mono ?_
    · rintro x hx
      simpa only [f.map_add, f.map_smul] using hf.map_add_lt hx.1 hx.2.1
    · rintro x ⟨y, hy, rfl⟩
      exact ⟨y, hy, rfl⟩

Repaired Proof:
theorem MonotoneOn.convex_gt (hf : MonotoneOn f s) (hs : Convex 𝕜 s) (r : β) :
    Convex 𝕜 ({ x ∈ s | r < f x }) ∧ IsOpenMap ({ x ∈ s | r < f x }) := by
  refine ⟨?_, ?_⟩
  · rintro x hx y hy a b ha hb hab
    obtain ⟨x', hx', rfl⟩ := hf.mem_Ioi_of_Ioi hx.1
    obtain ⟨y', hy', hy'⟩ := hf.mem_Ioi_of_Ioi hy.1
    exact ⟨a • x' + b • y', hs hx' hy' ha hb hab,
      calc
        f (a • x + b • y) ≤ f (a • x' + b • y') := hf (hs hx.1 hy.1 ha hb hab) (add_le_add
          (smul_le_smul_of_nonneg_left hx.2 ha) <| smul_le_smul_of_nonneg_left hy.2 hb)
        _ = a • f x' + b • f y' := by rw [f.map_add, f.map_add, f.map_smul, f.map_smul]
        _ = a • f x + b • f y := by rw [hx', hy']
        ⟩
  · refine (hs.isOpenMap_of_lt f.continuous.continuousOn ?_).mono ?_
    · rintro x hx
      simpa only [f.map_add, f.map_smul] using hf.map_add_lt hx.1 hx.2.1
    · rintro x ⟨y, hy, rfl⟩
      exact ⟨y, hy, rfl⟩

Repaired Proof:
theorem MonotoneOn.convex_gt (hf : MonotoneOn f s) (hs : Convex 𝕜 s) (r : β) :
    Convex 𝕜 ({ x ∈ s | r < f x }) ∧ IsOpenMap ({ x ∈ s | r < f x }) := by
  refine ⟨?_, ?_⟩
  · rintro x hx y hy a b ha hb hab
    obtain ⟨x', hx', rfl⟩ := hf.mem_Ioi_of_Ioi hx.1
    obtain ⟨y', hy', hy'⟩ := hf.mem_Ioi_of_Ioi hy.1
    exact ⟨a • x' + b • y', hs hx' hy' ha hb hab,
      calc
        f (a • x + b • y) ≤ f (a • x' + b • y') := hf (hs hx.1 hy.1 ha hb hab) (add_le_add
          (smul_le_smul_of_nonneg_left hx.2 ha) <| smul_le_smul_of_nonneg_left hy.2 hb)
        _ = a • f x' + b • f y' := by rw [f.map_add, f.map_add, f.map_smul, f.map_smul]
        _ = a • f x + b • f y := by rw [hx', hy']
        ⟩
  · refine (hs.isOpenMap_of_lt f.continuous.continuousOn ?_).mono ?_
    · rintro x hx
      simpa only [f.map_add, f.map_smul] using hf.map_add_lt hx.1 hx.2.1
    · rintro x ⟨y, hy, rfl⟩
      exact ⟨y, hy, rfl⟩

Repaired Proof:
theorem MonotoneOn.convex_gt (hf : MonotoneOn f s) (hs : Convex 𝕜 s) (r : β) :
    Convex 𝕜 ({ x ∈ s | r < f x }) ∧ IsOpenMap ({ x ∈ s | r < f x }) := by
  refine ⟨?_, ?_⟩
  · rintro x hx y hy a b ha hb hab
    obtain ⟨x', hx', rfl⟩ := hf.mem_Ioi_of_Ioi hx.1
    obtain ⟨y', hy', hy'⟩ := hf.mem_Ioi_of_Ioi hy.1
    exact ⟨a • x' + b • y', hs hx' hy' ha hb hab,
      calc
        f (a • x + b • y) ≤ f (a • x' + b • y') := hf (hs hx.1 hy.1 ha hb hab) (add_le_add
          (smul_le_smul_of_nonneg_left hx.2 ha) <| smul_le_smul_of_nonneg_left hy.2 hb)
        _ = a • f x' + b • f y' := by rw [f.map_add, f.map_add, f.map_smul, f.map_smul]
        _ = a • f x + b • f y := by rw [hx', hy']
        ⟩
  · refine (hs.isOpenMap_of_lt f.continuous.continuousOn ?_).mono ?_
    · rintro x hx
      simpa only [f.map_add, f.map_smul] using hf.map_add_lt hx.1 hx.2.1
    · rintro x ⟨y, hy, rfl⟩
      exact ⟨y, hy, rfl⟩

Repaired Proof:
theorem MonotoneOn.convex_gt (hf : MonotoneOn f s) (hs : Convex 𝕜 s) (r : β) :
    Convex 𝕜 ({ x ∈ s | r < f x }) ∧ IsOpenMap ({ x ∈ s | r < f x }) := by
  refine ⟨?_, ?_⟩
  · rintro x hx y hy a b ha hb hab
    obtain ⟨x', hx', rfl⟩ := hf.mem_Ioi_of_Ioi hx.1
    obtain ⟨y', hy', hy'⟩ := hf.mem_Ioi_of_Ioi hy.1
    exact ⟨a • x' + b • y', hs hx' hy' ha hb hab,
      calc
        f (a • x + b • y) ≤ f (a • x' + b • y') := hf (hs hx.1 hy.1 ha hb hab) (add_le_add
          (smul_le_smul_of_nonneg_left

Attempt failure.

Working on Mathlib/Analysis/Convex/Gauge.lean - 2024-09-09 00:31:08.035126.
---27/200---
For theorem Absorbent.gauge_set_nonempty in Mathlib/Analysis/Convex/Gauge.lean:
theorem Absorbent.gauge_set_nonempty (absorbs : Absorbent ℝ s) :
    { r : ℝ | 0 < r ∧ x ∈ r • s }.Nonempty 


Original valid proof:
:=
  let ⟨r, hr₁, hr₂⟩ := (absorbs x).exists_pos
  ⟨r, hr₁, hr₂ r (Real.norm_of_nonneg hr₁.le).ge rfl⟩


Verifying proof (Commit f41d2e3dd69004ca4172132a94e749b22b59caae):
∧ ∀ r ∈ { r : ℝ | 0 < r ∧ x ∈ r • s }, r ≤ gauge s x := by
  rcases exists_pos_forall_lt_subset_smul_of_isVonNBounded ℝ s (isVonNBounded_singleton ℝ x)
      (singleton_subset_iff.2 <| mem_smul_set_iff_inv_smul_mem₀ (ne_of_gt (zero_lt_one' ℝ)).symm _ _)
    with ⟨R, hR0, hR⟩
  have : ∃ r : ℝ, 0 < r ∧ x ∈ r • s := by
    by_contra! h
    obtain ⟨r, hr0, hr⟩ : ∃ r : ℝ, 0 < r ∧ r • x ∉ s := by
      simpa only [not_exists, not_and, not_mem_smul_set_iff_of_ne (ne_of_gt (zero_lt_one' ℝ))]
        using h
    simpa only [not_lt, ← smul_smul] using hR r hr0.le hr
  refine' ⟨this, fun r hr => _⟩
  rcases hr with ⟨hr0, hr⟩
  rcases exists_inv_nat_lt (hr0.trans_le (le_max_left _ _)) with ⟨n, hn0, hn⟩
  have hnr0 : 0 < (n : ℝ)⁻¹ := Nat.cast_pos.2 hn0
  suffices H : (n : ℝ) • r ≤ gauge s x by
    simpa only [inv_inv (n : ℝ), inv_mul_cancel (ne_of_gt (Nat.cast_pos.2 hn0)), one_mul] using H
  suffices H : r ∈ Ico (0 : ℝ) (n⁻¹ • R) by
    simpa only [mem_Ico] at H
    calc
      (n : ℝ) • r ≤ (n : ℝ) • (n⁻¹ • R) := smul_le_smul_of_nonneg_left H.2 (Nat.cast_nonneg _)
      _ = R := by
        rw [← mul_smul_one_smul ℝ ℝ ℝ n R⁻¹, inv_mul_cancel (ne_of_gt (zero_lt_one' ℝ)), one_smul]
  refine' ⟨hr0.le, _⟩
  rw [← div_le_iff' hnr0, div_eq_mul_inv]
  exact (gauge_le_of_mem (absorbent_of_nonempty_interior s ⟨_, hr⟩).interior_subset hr).trans
    (inv_pos.2 <| hn0.trans_le (le_max_right _ _)).le

Repaired Proof:
theorem Absorbent.gauge_set_nonempty (absorbs : Absorbent ℝ s) :
    { r : ℝ | 0 < r ∧ x ∈ r • s }.Nonempty ∧ ∀ r ∈ { r : ℝ | 0 < r ∧ x ∈ r • s }, r ≤ gauge s x := by
  rcases exists_pos_forall_lt_subset_smul_of_isVonNBounded ℝ s (isVonNBounded_singleton ℝ x)
      (singleton_subset_iff.2 <| mem_smul_set_iff_inv_smul_mem₀ (ne_of_gt (zero_lt_one' ℝ)).symm _ _)
    with ⟨R, hR0, hR⟩
  have : ∃ r : ℝ, 0 < r ∧ x ∈ r • s := by
    by_contra! h
    obtain ⟨r, hr0, hr⟩ : ∃ r : ℝ, 0 < r ∧ r • x ∉ s := by
      simpa only [not_exists, not_and, not_mem_smul_set_iff_of_ne (ne_of_gt (zero_lt_one' ℝ))]
        using h
    simpa only [not_lt, ← smul_smul] using hR r hr0.le hr
  refine ⟨this, fun r hr => ?_⟩
  rcases hr with ⟨hr0, hr⟩
  rcases exists_inv_nat_lt (hr0.trans_le (le_max_left _ _)) with ⟨n, hn0, hn⟩
  have hnr0 : 0 < (n : ℝ)⁻¹ := Nat.cast_pos.2 hn0
  suffices H : (n : ℝ) • r ≤ gauge s x by
    simpa only [inv_inv (n : ℝ), inv_mul_cancel (ne_of_gt (Nat.cast_pos.2 hn0)), one_mul] using H
  suffices H : r ∈ Ico (0 : ℝ) (n⁻¹ • R) by
    simpa only [mem_Ico] at H
    calc
      (n : ℝ) • r ≤ (n : ℝ) • (n⁻¹ • R) := smul_le_smul_of_nonneg_left H.2 (Nat.cast_nonneg _)
      _ = R := by
        rw [← mul_smul_one_smul ℝ ℝ ℝ n R⁻¹, inv_mul_cancel (ne_of_gt (zero_lt_one' ℝ)), one_smul]
  refine ⟨hr0.le, ?_⟩
  rw [← div_le_iff' hnr0, div_eq_mul_inv]
  exact (gauge_le_of_mem (absorbent_of_nonempty_interior s ⟨_, hr⟩).interior_subset hr).trans
    (inv_pos.2 <| hn0.trans_le (le_max_right _ _)).le

Repaired Proof:
theorem Absorbent.gauge_set_nonempty (absorbs : Absorbent ℝ s) :
    { r : ℝ | 0 < r ∧ x ∈ r • s }.Nonempty ∧ ∀ r ∈ { r : ℝ | 0 < r ∧ x ∈ r • s }, r ≤ gauge s x := by
  rcases exists_pos_forall_lt_subset_smul_of_isVonNBounded ℝ s (isVonNBounded_singleton ℝ x)
      (singleton_subset_iff.2 <| mem_smul_set_iff_inv_smul_mem₀ (ne_of_gt (zero_lt_one' ℝ)).symm _ _)
    with ⟨R, hR0, hR⟩
  have : ∃ r : ℝ, 0 < r ∧ x ∈ r • s := by
    by_contra! h
    obtain ⟨r, hr0, hr⟩ : ∃ r : ℝ, 0 < r ∧ r • x ∉ s := by
      simpa only [not_exists, not_and, not_mem_smul_set_iff_of_ne (ne_of_gt (zero_lt_one' ℝ))]
        using h
    simpa only [not_lt, ← smul_smul] using hR r hr0.le hr
  refine ⟨this, fun r hr => ?_⟩
  rcases hr with ⟨hr0, hr⟩
  rcases exists_inv_nat_lt (hr0.trans_le (le_max_left _ _)) with ⟨n, hn0, hn⟩
  have hnr0 : 0 < (n : ℝ)⁻¹ := Nat.cast_pos.2 hn0
  suffices H : (n : ℝ) • r ≤ gauge s x by
    simpa only [inv_inv (n : ℝ), inv_mul_cancel (ne_of_gt (Nat.cast_pos.2 hn0)), one_mul] using H
  suffices H : r ∈ Ico (0 : ℝ) (n⁻¹ • R) by
    simpa only [mem_Ico] at H
    calc
      (n : ℝ) • r ≤ (n : ℝ

Attempt failure.

Working on Mathlib/Analysis/Convex/Measure.lean - 2024-09-09 00:31:30.499185.
---28/200---
For theorem Convex.addHaar_frontier in Mathlib/Analysis/Convex/Measure.lean:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 


Original valid proof:
:= by
  cases' ne_or_eq (affineSpan ℝ s) ⊤ with hspan hspan
  · refine measure_mono_null ?_ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan ℝ s).closed_of_finiteDimensional)
  rw [← hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with ⟨x, hx⟩
  suffices H : ∀ t : Set E, Convex ℝ t → x ∈ interior t → IsBounded t → μ (frontier t) = 0 by
    let B : ℕ → Set E := fun n => ball x (n + 1)
    have : μ (⋃ n : ℕ, frontier (s ∩ B n)) = 0 := by
      refine measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) ?_ (isBounded_ball.subset inter_subset_right)
      rw [interior_inter, isOpen_ball.interior_eq]
      exact ⟨hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)⟩
    refine measure_mono_null (fun y hy => ?_) this; clear this
    set N : ℕ := ⌊dist y x⌋₊
    refine mem_iUnion.2 ⟨N, ?_⟩
    have hN : y ∈ B N := by simp [B, N, Nat.lt_floor_add_one]
    suffices y ∈ frontier (s ∩ B N) ∩ B N from this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact ⟨hy, hN⟩
  intro s hs hx hb
  replace hb : μ (interior s) ≠ ∞ := (hb.subset interior_subset).measure_lt_top.ne
  suffices μ (closure s) ≤ μ (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : ℕ := FiniteDimensional.finrank ℝ E
  have : ∀ r : ℝ≥0, 1 < r → μ (closure s) ≤ ↑(r ^ d) * μ (interior s) := fun r hr ↦ by
    refine (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq ?_
    rw [addHaar_image_homothety, ← NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : ∀ᶠ (r : ℝ≥0) in 𝓝[>] 1, μ (closure s) ≤ ↑(r ^ d) * μ (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine ge_of_tendsto ?_ this
  refine (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ ?_).mono_left nhdsWithin_le_nhds
  simp


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
↔ μ s = 0 := by
  refine' ⟨fun h => _, fun h => _⟩
  · refine' le_antisymm _ bot_le
    calc
      μ s ≤ μ (interior s) + μ (frontier s) := μ.le_add_apply _ _
      _ = μ (interior s) := by simp [h]
      _ ≤ μ s := μ.mono (interior_subset)
  · refine' le_antisymm _ bot_le
    calc
      μ (frontier s) ≤ μ (closure s) := μ.mono frontier_subset_closure
      _ = μ s := by simp [hs.closure_eq]

Repaired Proof:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 ↔ μ s = 0 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine le_antisymm ?_ bot_le
    calc
      μ s ≤ μ (interior s) + μ (frontier s) := μ.le_add_apply _ _
      _ = μ (interior s) := by simp [h]
      _ ≤ μ s := μ.mono interior_subset
  · refine le_antisymm ?_ bot_le
    calc
      μ (frontier s) ≤ μ (closure s) := μ.mono frontier_subset_closure
      _ = μ s := by simp [hs.closure_eq]

Repaired Proof:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 ↔ μ s = 0 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine le_antisymm ?_ bot_le
    calc
      μ s ≤ μ (interior s) + μ (frontier s) := μ.le_add_apply _ _
      _ = μ (interior s) := by simp [h]
      _ ≤ μ s := μ.mono interior_subset
  · refine le_antisymm ?_ bot_le
    calc
      μ (frontier s) ≤ μ (closure s) := μ.mono frontier_subset_closure
      _ = μ s := by simp [hs.closure_eq]

Repaired Proof:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 ↔ μ s = 0 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine le_antisymm ?_ bot_le
    calc
      μ s ≤ μ (interior s) + μ (frontier s) := μ.le_add_apply _ _
      _ = μ (interior s) := by simp [h]
      _ ≤ μ s := μ.mono interior_subset
  · refine le_antisymm ?_ bot_le
    calc
      μ (frontier s) ≤ μ (closure s) := μ.mono frontier_subset_closure
      _ = μ s := by simp [hs.closure_eq]

Repaired Proof:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 ↔ μ s = 0 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine le_antisymm ?_ bot_le
    calc
      μ s ≤ μ (interior s) + μ (frontier s) := μ.le_add_apply _ _
      _ = μ (interior s) := by simp [h]
      _ ≤ μ s := μ.mono interior_subset
  · refine le_antisymm ?_ bot_le
    calc
      μ (frontier s) ≤ μ (closure s) := μ.mono frontier_subset_closure
      _ = μ s := by simp [hs.closure_eq]

Repaired Proof:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 ↔ μ s = 0 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine le_antisymm ?_ bot_le
    calc
      μ s ≤ μ (interior s) + μ (frontier s) := μ.le_add_apply _ _
      _ = μ (interior s) := by simp [h]
      _ ≤ μ s := μ.mono interior_subset
  · refine le_antisymm ?_ bot_le
    calc
      μ (frontier s) ≤ μ (closure s) := μ.mono frontier_subset_closure
      _ = μ s := by simp [hs.closure_eq]

Repaired Proof:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 ↔ μ s = 0 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine le_antisymm ?_ bot_le
    calc
      μ s ≤ μ (interior s) + μ (frontier s) := μ.le_add_apply _ _
      _ = μ (interior s) := by simp [h]
      _ ≤ μ s := μ.mono interior_subset
  · refine le_antisymm ?_ bot_le
    calc
      μ (frontier s) ≤ μ (closure s) := μ.mono frontier_subset_closure
      _ = μ s := by simp [hs.closure_eq]

Repaired Proof:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 ↔ μ s = 0 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine le_antisymm ?_ bot_le
    calc
      μ s ≤ μ (interior s) + μ (frontier s) := μ.le_add_apply _ _
      _ = μ (interior s) := by simp [h]
      _ ≤ μ s := μ.mono interior_subset
  · refine le_antisymm ?_ bot_le
    calc
      μ (frontier s) ≤ μ (closure s) := μ.mono frontier_subset_closure
      _ = μ s := by simp [hs.closure_eq]

Repaired Proof:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 ↔ μ s = 0 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine le_antisymm ?_ bot_le
    calc
      μ s ≤ μ (interior s) + μ (frontier s) := μ.le_add_apply _ _
      _ = μ (interior s) := by simp [h]
      _ ≤ μ s := μ.mono interior_subset
  · refine le_antisymm ?_ bot_le
    calc
      μ (frontier s) ≤ μ (closure s) := μ.mono frontier_subset_closure
      _ = μ s := by simp [hs.closure_eq]

Repaired Proof:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 ↔ μ s = 0 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine le_antisymm ?_ bot_le
    calc
      μ s ≤ μ (interior s) + μ (frontier s) := μ.le_add_apply _ _
      _ = μ (interior s) := by simp [h]
      _ ≤ μ s := μ.mono interior_subset
  · refine le_antisymm ?_ bot_le
    calc
      μ (frontier s) ≤ μ (closure s) := μ.mono frontier_subset_closure
      _ = μ s := by simp [hs.closure_eq]

Repaired Proof:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 ↔ μ s = 0 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine le_antisymm ?_ bot_le
    calc
      μ s ≤ μ (interior s) + μ (frontier s) := μ.le_add_apply _ _
      _ = μ (interior s) := by simp [h]
      _ ≤ μ s := μ.mono interior_subset
  · refine le_antisymm ?_ bot_le
    calc
      μ (frontier s) ≤ μ (closure s) := μ.mono frontier_subset_closure
      _ = μ s := by simp [hs.closure_eq]

Repaired Proof:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 ↔ μ s

Attempt failure.

Working on Mathlib/Analysis/Convex/StoneSeparation.lean - 2024-09-09 00:31:44.532476.
---29/200---
For theorem not_disjoint_segment_convexHull_triple in Mathlib/Analysis/Convex/StoneSeparation.lean:
theorem not_disjoint_segment_convexHull_triple {p q u v x y z : E} (hz : z ∈ segment 𝕜 x y)
    (hu : u ∈ segment 𝕜 x p) (hv : v ∈ segment 𝕜 y q) :
    ¬Disjoint (segment 𝕜 u v) (convexHull 𝕜 {p, q, z}) 


Original valid proof:
:= by
  rw [not_disjoint_iff]
  obtain ⟨az, bz, haz, hbz, habz, rfl⟩ := hz
  obtain rfl | haz' := haz.eq_or_lt
  · rw [zero_add] at habz
    rw [zero_smul, zero_add, habz, one_smul]
    refine ⟨v, by apply right_mem_segment, segment_subset_convexHull ?_ ?_ hv⟩ <;> simp
  obtain ⟨av, bv, hav, hbv, habv, rfl⟩ := hv
  obtain rfl | hav' := hav.eq_or_lt
  · rw [zero_add] at habv
    rw [zero_smul, zero_add, habv, one_smul]
    exact ⟨q, right_mem_segment _ _ _, subset_convexHull _ _ <| by simp⟩
  obtain ⟨au, bu, hau, hbu, habu, rfl⟩ := hu
  have hab : 0 < az * av + bz * au := by positivity
  refine ⟨(az * av / (az * av + bz * au)) • (au • x + bu • p) +
    (bz * au / (az * av + bz * au)) • (av • y + bv • q), ⟨_, _, ?_, ?_, ?_, rfl⟩, ?_⟩
  · positivity
  · positivity
  · rw [← add_div, div_self]; positivity
  rw [smul_add, smul_add, add_add_add_comm, add_comm, ← mul_smul, ← mul_smul]
  classical
    let w : Fin 3 → 𝕜 := ![az * av * bu, bz * au * bv, au * av]
    let z : Fin 3 → E := ![p, q, az • x + bz • y]
    have hw₀ : ∀ i, 0 ≤ w i := by
      rintro i
      fin_cases i
      · exact mul_nonneg (mul_nonneg haz hav) hbu
      · exact mul_nonneg (mul_nonneg hbz hau) hbv
      · exact mul_nonneg hau hav
    have hw : ∑ i, w i = az * av + bz * au := by
      trans az * av * bu + (bz * au * bv + au * av)
      · simp [w, Fin.sum_univ_succ, Fin.sum_univ_zero]
      rw [← one_mul (au * av), ← habz, add_mul, ← add_assoc, add_add_add_comm, mul_assoc, ← mul_add,
        mul_assoc, ← mul_add, mul_comm av, ← add_mul, ← mul_add, add_comm bu, add_comm bv, habu,
        habv, one_mul, mul_one]
    have hz : ∀ i, z i ∈ ({p, q, az • x + bz • y} : Set E) := fun i => by fin_cases i <;> simp [z]
    convert Finset.centerMass_mem_convexHull (Finset.univ : Finset (Fin 3)) (fun i _ => hw₀ i)
        (by rwa [hw]) fun i _ => hz i
    rw [Finset.centerMass]
    simp_rw [div_eq_inv_mul, hw, mul_assoc, mul_smul (az * av + bz * au)⁻¹, ← smul_add, add_assoc, ←
      mul_assoc]
    congr 3
    rw [← mul_smul, ← mul_rotate, mul_right_comm, mul_smul, ← mul_smul _ av, mul_rotate,
      mul_smul _ bz, ← smul_add]
    simp only [w, z, smul_add, List.foldr, Matrix.cons_val_succ', Fin.mk_one,
      Matrix.cons_val_one, Matrix.head_cons, add_zero]


Verifying proof (Commit 738b1a97e85d528d395f215b4057bad4704e2ceb):
↔
      ∃ a b c : 𝕜, 0 ≤ a ∧ 0 ≤ b ∧ 0 ≤ c ∧ a + b + c = 1 ∧
        a • u + b • v = c • z ∧ c • z ∈ convexHull 𝕜 {p, q, z} := by
  rw [convexHull_triple, Set.mem_setOf_eq,
    exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hz),
    exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hu),
    exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hv),
    not_disjoint_iff_nonempty_inter, segment_inter_eq_iUnion,
    iUnion_nonempty_iff_exists_nonempty, iUnion_iUnion_eq_right,
    iUnion_nonempty_iff_exists_nonempty, iUnion_iUnion_eq_right,
    iUnion_nonempty_iff_exists_nonempty, iUnion_iUnion_eq_right,
    exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hz),
    exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hu),
    exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hv),
    segment_inter_eq_iUnion, iUnion_nonempty_iff_exists_nonempty,
    iUnion_iUnion_eq_right, iUnion_nonempty_iff_exists_nonempty,
    iUnion_iUnion_eq_right, iUnion_nonempty_iff_exists_nonempty,
    iUnion_iUnion_eq_right, exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hz),
    exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hu),
    exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hv),
    segment_inter_eq_iUnion, iUnion_nonempty_iff_exists_nonempty,
    iUnion_iUnion_eq_right, iUnion_nonempty_iff_exists_nonempty,
    iUnion_iUnion_eq_right, iUnion_nonempty_iff_exists_nonempty,
    iUnion_iUnion_eq_right, exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hz),
    exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hu),
    exists_mem_of_nonempty_segment' (nonempty_segment_subtype.2 hv),
    segment_inter_eq_iUnion, iUnion_nonempty_iff_exists_nonempty,
    iUnion_iUnion_eq_right, iUnion_nonempty_iff_exists_nonempty,
    iUnion_iUnion_eq_right, iUnion_nonempty_iff_exists_nonempty,
    iUnion_iUnion_eq_right]
  simp only [exists_prop, Subtype.exists, Subtype.coe_mk, exists_and_left,
    exists_eq_left, exists_eq_right, exists_eq_right']
  simp_rw [← exists_and_right, ← exists_and_left, and_assoc, and_left_comm, and_comm,
    @and_comm (_ ∈ _) (_ ∈ _), @and_left_comm (_ ∈ _) (_ ∈ _)]
  simp_rw [@and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _), @and_assoc (_ ∈ _),
    @and_assoc (_ ∈ _), @and_assoc (_

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Basic.lean - 2024-09-09 00:31:54.396081.
---30/200---
For theorem inner_mul_inner_self_le in Mathlib/Analysis/InnerProductSpace/Basic.lean:
theorem inner_mul_inner_self_le (x y : F) : ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ ≤ re ⟪x, x⟫ * re ⟪y, y⟫ 


Original valid proof:
:= by
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa only [inner_zero_left, map_zero, zero_mul, norm_zero] using le_rfl
  · have hx' : 0 < normSqF x := inner_self_nonneg.lt_of_ne' (mt normSq_eq_zero.1 hx)
    rw [← sub_nonneg, ← mul_nonneg_iff_right_nonneg_of_pos hx', ← normSq, ← normSq,
      norm_inner_symm y, ← sq, ← cauchy_schwarz_aux]
    exact inner_self_nonneg


Verifying proof (Commit e46faedbd6353e165e5a0da6768aa2e7bd75f6d4):
↔
    ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ ≤ re ⟪x, x⟫ * re ⟪y, y⟫ := by
  simp only [mul_comm (‖⟪x, y⟫‖), mul_comm (re ⟪y, y⟫)]

Repaired Proof:
theorem inner_mul_inner_self_le (x y : F) : ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ ≤ re ⟪x, x⟫ * re ⟪y, y⟫ := by
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa only [inner_zero_left, map_zero, zero_mul, norm_zero] using le_rfl
  rcases eq_or_ne y 0 with (rfl | hy)
  · simpa only [inner_zero_right, map_zero, zero_mul, norm_zero] using le_rfl
  have hx' := inner_self_eq_norm_sq_to_K x
  have hy' := inner_self_eq_norm_sq_to_K y
  rw [inner_smul_left, inner_smul_right, ← mul_re, mul_mul_mul_comm, ← re_ofReal_mul, ←
    re_ofReal_mul, ← re_ofReal_mul, ← re_ofReal_mul, ← ofReal_mul, ← ofReal_mul, ← ofReal_mul,
    RCLike.ofReal_re, ← inner_conj_symm, mul_comm (star ⟪x, y⟫), mul_re, conj_re, conj_im,
    inner_conj_symm, sub_zero, ← mul_im, ← RCLike.ofReal_im]
  set A : ℝ := ‖⟪x, y⟫‖ ^ 2
  set B : ℝ := ‖⟪y, x⟫‖ ^ 2
  have hxy : 0 ≤ (⟪x, y⟫ : 𝕜) ^ 2 := by positivity
  have hyx : 0 ≤ (⟪y, x⟫ : 𝕜) ^ 2 := by positivity
  have hAB : 0 ≤ A * B := by positivity
  have hA : 0 ≤ A := by positivity
  have hB : 0 ≤ B := by positivity
  have hAB' : 0 ≤ A / 2 * B / 2 := by positivity
  calc
    A * B = ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ * (‖⟪x, y⟫‖ * ‖⟪y, x⟫‖) := by ring
    _ = ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ * (‖⟪x, y⟫‖ * ‖⟪y, x⟫‖) := rfl
    _ = ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ * (‖⟪y, x⟫‖ * ‖⟪x, y⟫‖) := by rw [norm_inner_symm y x]
    _ = ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ * (‖⟪y, x⟫‖ * ‖⟪x, y⟫‖) := rfl
    _ = ‖⟪x, y⟫‖ ^ 2 * ‖⟪y, x⟫‖ ^ 2 := by ring
    _ = A * B := rfl
    _ ≤ re ⟪x, x⟫ * re ⟪y, y⟫ := by
      rw [hx', hy', ← sq, ← sq]
      apply Real.mul_self_le_mul_self hA hB
      rw [mul_comm]
      exact norm_inner_le_norm x y
    _ = re ⟪x, x⟫ * re ⟪y, y⟫ := rfl

Repaired Proof:
theorem inner_mul_inner_self_le (x y : F) : ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ ≤ re ⟪x, x⟫ * re ⟪y, y⟫ := by
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa only [inner_zero_left, map_zero, zero_mul, norm_zero] using le_rfl
  rcases eq_or_ne y 0 with (rfl | hy)
  · simpa only [inner_zero_right, map_zero, zero_mul, norm_zero] using le_rfl
  have hx' := inner_self_eq_norm_sq_to_K x
  have hy' := inner_self_eq_norm_sq_to_K y
  rw [inner_smul_left, inner_smul_right, ← mul_re, mul_mul_mul_comm, ← re_ofReal_mul, ←
    re_ofReal_mul, ← re_ofReal_mul, ← re_ofReal_mul, ← ofReal_mul, ← ofReal_mul, ← ofReal_mul,
    RCLike.ofReal_re, ← inner_conj_symm, mul_comm (star ⟪x, y⟫), mul_re, conj_re, conj_im,
    inner_conj_symm, sub_zero, ← mul_im, ← RCLike.ofReal_im]
  set A : ℝ := ‖⟪x, y⟫‖ ^ 2
  set B : ℝ := ‖⟪y, x⟫‖ ^ 2
  have hxy : 0 ≤ (⟪x, y⟫ : 𝕜) ^ 2 := by positivity
  have hyx : 0 ≤ (⟪y, x⟫ : 𝕜) ^ 2 := by positivity
  have hAB : 0 ≤ A * B := by positivity
  have hA : 0 ≤ A := by positivity
  have hB : 0 ≤ B := by positivity
  have hAB' : 0 ≤ A / 2 * B / 2 := by positivity
  calc
    A * B = ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ * (‖⟪x, y⟫‖ * ‖⟪y, x⟫‖) := by ring
    _ = ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ * (‖⟪x, y⟫‖ * ‖⟪y, x⟫‖) := rfl
    _ = ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ * (‖⟪y, x⟫‖ * ‖⟪x, y⟫‖) := by rw [norm_inner_symm y x]
    _ = ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ * (‖⟪y, x⟫‖ * ‖⟪x, y⟫‖) := rfl
    _ = ‖⟪x, y⟫‖ ^ 2 * ‖⟪y, x⟫‖ ^ 2 := by ring
    _ = A * B := rfl
    _ ≤ re ⟪x, x⟫ * re ⟪y, y⟫ := by
      rw [hx', hy', ← sq, ← sq]
      apply Real.mul_self_le_mul_self hA hB
      rw [mul_comm]
      exact norm_inner_le_norm x y
    _ = re ⟪x, x⟫ * re ⟪y, y⟫ := rfl

Repaired Proof:
theorem inner_mul_inner_self_le (x y : F) : ‖⟪x

Attempt failure.

---31/200---
For theorem eq_of_norm_le_re_inner_eq_norm_sq in Mathlib/Analysis/InnerProductSpace/Basic.lean:
theorem eq_of_norm_le_re_inner_eq_norm_sq {x y : E} (hle : ‖x‖ ≤ ‖y‖) (h : re ⟪x, y⟫ = ‖y‖ ^ 2) :
    x = y 


Original valid proof:
:= by
  suffices H : re ⟪x - y, x - y⟫ ≤ 0 by rwa [inner_self_nonpos, sub_eq_zero] at H
  have H₁ : ‖x‖ ^ 2 ≤ ‖y‖ ^ 2 := by gcongr
  have H₂ : re ⟪y, x⟫ = ‖y‖ ^ 2 := by rwa [← inner_conj_symm, conj_re]
  simpa [inner_sub_left, inner_sub_right, ← norm_sq_eq_inner, h, H₂] using H₁


Verifying proof (Commit 7529a8dd82ee9cd96b9be4733d8c4cd4bcd5f2a9):
∨ x = -y := by
  rcases eq_or_ne y 0 with (rfl | hy)
  · simp
  rw [← sub_eq_zero, ← norm_eq_zero, eq_comm, norm_eq_norm_iff_re_inner_eq_norm_sq hy]
  simpa [h, sq, mul_self_pos.2 hy.ne'] using hle

theorem eq_of_re_inner_eq_norm_sq_add_norm_sq {x y : E} (h : re ⟪x, y⟫ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq' {x y : E} (h : re ⟪x, y⟫ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real, mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real, mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real' {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real', mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real, mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real' {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real', mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real, mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real' {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real', mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real, mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real' {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real', mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real, mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real' {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real', mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real, mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real' {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real', mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real, mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real' {x y : F} (h : re ⟪x, y⟫_ℝ = ‖x‖ ^ 2 + ‖y‖ ^ 2) :
    x = y ∨ x = -y :=
  eq_or_eq_neg_of_sq_eq_sq _ _ <| by simp only [sq, h, norm_add_sq_real', mul_self_norm]


theorem eq_of_re_inner_eq_norm_sq_add_norm_sq_real {x y : F} (h : re ⟪x, y⟫_ℝ = ‖

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/PiL2.lean - 2024-09-09 00:33:37.893375.
---32/200---
For theorem Orthonormal.exists_orthonormalBasis_extension in Mathlib/Analysis/InnerProductSpace/PiL2.lean:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) 


Original valid proof:
:= by
  obtain ⟨u₀, hu₀s, hu₀, hu₀_max⟩ := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu₀] at hu₀_max
  have hu₀_finite : u₀.Finite := hu₀.linearIndependent.setFinite
  let u : Finset E := hu₀_finite.toFinset
  let fu : ↥u ≃ ↥u₀ := hu₀_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal 𝕜 ((↑) : u → E) := by simpa using hu₀.comp _ fu.injective
  refine ⟨u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_⟩
  · simpa [u] using hu₀_max
  · simpa [u] using hu₀s
  · simp


Verifying proof (Commit 5648120293e005e7ed12dc634bf3094a1835c21b):
∧
      Orthonormal 𝕜 ((Submodule.subtype (span 𝕜 (u : Set E)) : u → E) ∘ ((↑) : u → span 𝕜 (u : Set E))) := by
  rcases hv.exists_orthonormal_basis_extension with ⟨u, hu, huv, hb⟩
  refine ⟨u, OrthonormalBasis.mkOfSpanEqBot hb ?_, huv, rfl, ?_⟩
  · rwa [Submodule.span_eq_bot, hu]
  · exact hu.orthonormal_subtype_span_iff.mp hb

Repaired Proof:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧
      Orthonormal 𝕜 ((Submodule.subtype (span 𝕜 (u : Set E)) : u → E) ∘ ((↑) : u → span 𝕜 (u : Set E))) := by
  rcases hv.exists_orthonormal_basis_extension with ⟨u, hu, huv, hb⟩
  refine ⟨u, OrthonormalBasis.mkOfSpanEqBot hb ?_, huv, rfl, ?_⟩
  · rwa [Submodule.span_eq_bot, hu]
  · exact hu.orthonormal_subtype_span_iff.mp hb

Repaired Proof:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧
      Orthonormal 𝕜 ((Submodule.subtype (span 𝕜 (u : Set E)) : u → E) ∘ ((↑) : u → span 𝕜 (u : Set E))) := by
  rcases hv.exists_orthonormal_basis_extension with ⟨u, hu, huv, hb⟩
  refine ⟨u, OrthonormalBasis.mkOfSpanEqBot hb ?_, huv, rfl, ?_⟩
  · rwa [Submodule.span_eq_bot, hu]
  · exact hu.orthonormal_subtype_span_iff.mp hb

Repaired Proof:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧
      Orthonormal 𝕜 ((Submodule.subtype (span 𝕜 (u : Set E)) : u → E) ∘ ((↑) : u → span 𝕜 (u : Set E))) := by
  rcases hv.exists_orthonormal_basis_extension with ⟨u, hu, huv, hb⟩
  refine ⟨u, OrthonormalBasis.mkOfSpanEqBot hb ?_, huv, rfl, ?_⟩
  · rwa [Submodule.span_eq_bot, hu]
  · exact hu.orthonormal_subtype_span_iff.mp hb

Repaired Proof:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧
      Orthonormal 𝕜 ((Submodule.subtype (span 𝕜 (u : Set E)) : u → E) ∘ ((↑) : u → span 𝕜 (u : Set E))) := by
  rcases hv.exists_orthonormal_basis_extension with ⟨u, hu, huv, hb⟩
  refine ⟨u, OrthonormalBasis.mkOfSpanEqBot hb ?_, huv, rfl, ?_⟩
  · rwa [Submodule.span_eq_bot, hu]
  · exact hu.orthonormal_subtype_span_iff.mp hb

Repaired Proof:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧
      Orthonormal 𝕜 ((Submodule.subtype (span 𝕜 (u : Set E)) : u → E) ∘ ((↑) : u → span 𝕜 (u : Set E))) := by
  rcases hv.exists_orthonormal_basis_extension with ⟨u, hu, huv, hb⟩
  refine ⟨u, OrthonormalBasis.mkOfSpanEqBot hb ?_, huv, rfl, ?_⟩
  · rwa [Submodule.span_eq_bot, hu]
  · exact hu.orthonormal_subtype_span_iff.mp hb

Repaired Proof:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧
      Orthonormal 𝕜 ((Submodule.subtype (span 𝕜 (u : Set E)) : u → E) ∘ ((↑) : u → span 𝕜 (u : Set E))) := by
  rcases hv.exists_orthonormal_basis_extension with ⟨u, hu, huv, hb⟩
  refine ⟨u, OrthonormalBasis.mkOfSpanEqBot hb ?_, huv, rfl, ?_⟩
  · rwa [Submodule.span_eq_bot, hu]
  · exact hu.orthonormal_subtype_span_iff.mp hb

Repaired Proof:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧
      Orthonormal 𝕜 ((Submodule.subtype (span 𝕜 (u : Set E)) : u → E) ∘ ((↑) : u → span 𝕜 (u : Set E))) := by
  rcases hv.exists_orthonormal_basis_extension with ⟨u, hu, huv, hb⟩
  refine ⟨u, OrthonormalBasis.mkOfSpanEqBot hb ?_, huv, rfl, ?_⟩
  · rwa [Submodule.span_eq_bot, hu]
  · exact hu.orthonormal_subtype_span_iff.mp hb

Repaired Proof:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧
      Orthonormal 𝕜 ((Submodule.subtype (span 𝕜 (u : Set E)) : u → E) ∘ ((↑) : u → span 𝕜 (u : Set E))) := by
  rcases hv.exists_orthonormal_basis_extension with ⟨u, hu, huv, hb⟩
  refine ⟨u, OrthonormalBasis.mkOfSpanEqBot hb ?_, huv, rfl, ?_⟩
  · rwa [Submodule.span_eq_bot

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Projection.lean - 2024-09-09 00:34:21.479408.
---33/200---
For theorem LinearIsometryEquiv.reflections_generate in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod 


Original valid proof:
:= by
  induction' n with n IH generalizing φ
  · 
    refine ⟨[], rfl.le, show φ = 1 from ?_⟩
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  · 
    let W := ker (ContinuousLinearMap.id ℝ F - φ)
    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ℝ Wᗮ ≤ n
    · obtain ⟨V, hV₁, hV₂⟩ := IH φ hn'
      exact ⟨V, hV₁.trans n.le_succ, hV₂⟩
    haveI : Nontrivial Wᗮ := nontrivial_of_finrank_pos (by omega : 0 < finrank ℝ Wᗮ)
    obtain ⟨v, hv⟩ := exists_ne (0 : Wᗮ)
    have hφv : φ v ∈ Wᗮ := by
      intro w hw
      rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ∉ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - φ v
    let ρ := reflection (ℝ ∙ x)ᗮ
    let V := ker (ContinuousLinearMap.id ℝ F - φ.trans ρ)
    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by
      intro w hw
      change w - ρ (φ w) = 0
      rw [sub_eq_zero, hw]
    have H₂V : W ≤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hw
    have H₁V : (v : F) ∈ V := by
      apply hV
      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
      rw [← this]
      exact reflection_reflection _ _
    have : finrank ℝ Vᗮ ≤ n := by
      change finrank ℝ Wᗮ ≤ n + 1 at hn
      have : finrank ℝ W + 1 ≤ finrank ℝ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)
      have : finrank ℝ V + finrank ℝ Vᗮ = finrank ℝ F := V.finrank_add_finrank_orthogonal
      have : finrank ℝ W + finrank ℝ Wᗮ = finrank ℝ F := W.finrank_add_finrank_orthogonal
      omega
    obtain ⟨l, hl, hφl⟩ := IH (ρ * φ) this
    refine ⟨x::l, Nat.succ_le_succ hl, ?_⟩
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (ρ * ·) hφl
    dsimp only at this
    rwa [← mul_assoc, reflection_mul_reflection, one_mul] at this


Verifying proof (Commit 9f377843ae74f8ea35a167e1fcc7752e1a90722a):
∧
      (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod = φ := by
  induction' n with n IH generalizing φ
  · 
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      have : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ = 0 := by simpa using hn
      have : (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ = ⊥ := Submodule.eq_bot_of_finrank_zero this
      simpa [ker_eq_top, this]
    refine' ⟨[], rfl, φ.ext fun x => Subtype.ext _, rfl⟩
    simp [this]
  · 
    set W := ker (ContinuousLinearMap.id ℝ F - φ) with hW
    haveI : FiniteDimensional ℝ W := finiteDimensional_of_le W.le
    have hφ : φ (W.subtype (R := ℝ) x) = x := φ.subtype_apply_of_mem W x x.2
    have hφ' : ∀ x : W, (φ - W.subtype (R := ℝ)) x = 0 := fun x => sub_eq_zero.2 hφ
    have : W = ker (ContinuousLinearMap.id ℝ W - W.subtypeL ∘L φ) := by
      ext x
      simp [hφ']
    obtain ⟨ψ, hψ⟩ : ∃ (ψ : W ≃ₗᵢ[ℝ] W), W.subtypeL ∘L ψ ∘L W.subtypeL.dual =
        W.subtypeL.dual ∘L (ContinuousLinearMap.id ℝ W - W.subtypeL ∘L φ) :=
      exists_isometry_of_inner ℝ W fun x y => inner_sub_left.symm
    have hψ' : W.subtypeL ∘L ψ = W.subtypeL ∘L φ := by
      ext x
      simpa [ContinuousLinearMap.dual_def] using congr_arg W.subtype x (hψ x)
    have : finrank ℝ (ker (ContinuousLinearMap.id ℝ W - ψ))ᗮ ≤ n := by
      rw [← hW]
      refine' (Submodule.finrank_lt_finrank_of_lt _).le
      refine' (Submodule.orthogonal_strict_mono W.le).2 _
      refine' (Submodule.orthogonal_orthogonal W).symm.trans_lt ?_
      refine' Submodule.lt_top_of_ne_top _ fun h => ?_
      have : W = ⊥ := by rwa [← Submodule.eq_bot_iff, h]
      simp only [this, LinearIsometryEquiv.reflections_generate_dim_aux_aux] at hψ'
      have : W.subtypeL = 0 := by ext; simp [this]
      simp [this] at hψ'
    obtain ⟨l, hl, hl'⟩ := IH ψ this
    refine' ⟨W.subtype x :: l, Nat.succ_le_succ hl, _, _⟩
    · simp only [List.map, List.prod_cons]
      rw [← hl', ← hψ']
      ext
      rfl
    · simp only [List.map, List.prod_cons]
      rw [← hl', ← hψ']
      rfl

Repaired Proof:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod ∧
      (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod = φ := by
  induction' n with n IH generalizing φ
  · 
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      have : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ = 0 := by simpa using hn
      have : (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ = ⊥ := Submodule.eq_bot_of_finrank_zero this
      simpa [ker_eq_top, this]
    refine ⟨[], rfl, φ.ext fun x => Subtype.ext ?_, rfl⟩
    simp [this]
  · 
    set W := ker (ContinuousLinearMap.id ℝ F - φ) with hW
    haveI : FiniteDimensional ℝ W := finiteDimensional_of_le W.le
    have hφ : φ (W.subtype (R := ℝ) x) = x := φ.subtype_apply_of_mem W x x.2
    have hφ' : ∀ x : W, (φ - W.subtype (R := ℝ)) x = 0 := fun x => sub_eq_zero.2 hφ
    have : W = ker (ContinuousLinearMap.id ℝ W - W.subtypeL ∘L φ) := by
      ext x
      simp [hφ']
    obtain ⟨ψ, hψ⟩ : ∃ (ψ : W ≃ₗᵢ[ℝ] W), W.subtypeL ∘L ψ ∘L W.subtypeL.dual =
        W.subtypeL.dual ∘L (ContinuousLinearMap.id ℝ W - W.subtypeL ∘L φ) :=
      exists_isometry_of_inner ℝ W fun x y => inner_sub_left.symm
    have hψ' : W.subtypeL ∘L ψ = W.subtypeL ∘L φ := by
      ext x
      simpa [ContinuousLinearMap.dual_def] using congr_arg W.subtype x (hψ x)
    have : finrank ℝ (ker (ContinuousLinearMap.id ℝ W - ψ))ᗮ ≤ n := by
      rw [← hW]
      refine (Submodule.finrank_lt_finrank_of_lt ?_).le
      refine (Submodule.orthogonal_strict_mono W.le).2 ?_
      refine (Submodule.orthogonal_orthogonal W).symm.trans_lt ?_
      refine Submodule.lt_top_of_ne_top ?_ fun h => ?_
      have : W = ⊥ := by rwa [← Submodule.eq_bot_iff, h]
      simp only [this, LinearIsometryEquiv.reflections_generate_dim_aux_aux] at hψ'
      have : W.subtypeL = 0 := by ext; simp [this]
      simp [this] at hψ'
    obtain ⟨l, hl, hl'⟩ := IH ψ this
    refine ⟨W.subtype x :: l, Nat.succ_le_succ hl, ?_, ?_⟩
    · simp only [List.map, List.prod_cons]
      rw [← hl', ← hψ']
      ext
      rfl
    · simp only [List.map, List.prod_cons]
      rw [← hl', ← hψ']
      rfl

Repaired Proof:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod ∧
      (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod = φ := by
  induction' n with n IH generalizing φ
  · 
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      have : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ = 0 := by sim

Attempt failure.

Working on Mathlib/Analysis/Normed/Group/Quotient.lean - 2024-09-09 00:35:06.492041.
---34/200---
For theorem quotient_norm_nonneg in Mathlib/Analysis/Normed/Group/Quotient.lean:
theorem quotient_norm_nonneg (S : AddSubgroup M) (x : M ⧸ S) : 0 ≤ ‖x‖ 


Original valid proof:
:=
  Real.sInf_nonneg _ <| forall_mem_image.2 fun _ _ ↦ norm_nonneg _


Verifying proof (Commit 2c51ddac66e30dac33162736742396566e191ff8):
↔ 0 ≤ x := by
  induction x using Quotient.inductionOn'
  rw [quotient_norm_mk_eq, norm_nonneg_iff, toAddSubgroup_eq_zero_iff]

@[simp]
theorem quotient_norm_neg (S : AddSubgroup M) (x : M ⧸ S) : ‖-x‖ = ‖x‖ := by
  induction x using Quotient.inductionOn'
  simp_rw [← QuotientAddGroup.mk_neg, quotient_norm_mk_eq, norm_neg]

theorem quotient_norm_sub_rev (S : AddSubgroup M) (x y : M ⧸ S) : ‖x - y‖ = ‖y - x‖ := by
  rw [← neg_sub, quotient_norm_neg]

theorem quotient_norm_add_le (S : AddSubgroup M) (x y : M ⧸ S) :
    ‖x + y‖ ≤ ‖x‖ + ‖y‖ := by
  induction x using Quotient.inductionOn'
  induction y using Quotient.inductionOn'
  simp_rw [← QuotientAddGroup.mk_add, quotient_norm_mk_eq]
  exact norm_add_le _ _

theorem quotient_norm_sum_le {ι} {p : ι → Prop} (s : Finset { i // p i }) (f : { i // p i } → M) :
    ‖∑ i ∈ s, f i‖ ≤ ∑ i ∈ s, ‖f i‖ :=
  (lipschitzWith_quotient_norm S).le_of_opNorm_le _ (norm_sum_le _ _)

@[simp]
theorem quotient_norm_lift_mk {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M → N) (hf : AddMonoidHomClass.IsClosedSMul f) (h : ∀ x ∈ S, f x = 0) (x : M) :
    ‖lift S f hf h (QuotientAddGroup.mk x)‖ = ‖f x‖ := by
  rw [quotient_norm_mk_eq, coe_lift_apply]

@[simp]
theorem quotient_norm_lift_comp_mk {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M → N) (hf : AddMonoidHomClass.IsClosedSMul f) (h : ∀ x ∈ S, f x = 0) :
    (lift S f hf h).comp (mk' S) = f :=
  rfl

@[simp]
theorem quotient_norm_liftOn_mk {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M → N) (hf : AddMonoidHomClass.IsClosedSMul f) (h : ∀ x ∈ S, f x = 0) (x : M) :
    ‖lift S f hf h (QuotientAddGroup.mk x)‖ = ‖f x‖ :=
  quotient_norm_lift_mk S f hf h x

@[simp]
theorem quotient_norm_liftOn_mk' {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M → N) (hf : AddMonoidHomClass.IsClosedSMul f) (h : ∀ x ∈ S, f x = 0) (x : M) :
    ‖AddMonoidHom.liftOn (QuotientAddGroup.mk' S) f hf (QuotientAddGroup.mk x)‖ = ‖f x‖ :=
  quotient_norm_liftOn_mk S f hf h x

@[simp]
theorem quotient_norm_equiv_symm_mk {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M ≃+ N) (hf : Continuous f) (h : ∀ x ∈ S, f x = 0) (x : M) :
    ‖(AddEquiv.toAddMonoidHom f.symm).liftOn (QuotientAddGroup.mk x)
      (fun g hg => (QuotientAddGroup.eq_zero_iff S).1 <| h _ <| hg)‖ = ‖f x‖ := by
  rw [← quotient_norm_liftOn_mk' S _ _ h, ← AddEquiv.toAddMonoidHom_eq_coe,
    AddEquiv.toAddMonoidHom_symm_apply_apply, AddEquiv.coe_toAddMonoidHom_refl]

@[simp]
theorem quotient_norm_equiv_symm_comp_mk {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M ≃+ N) (hf : Continuous f) (h : ∀ x ∈ S, f x = 0) :
    ((QuotientAddGroup.mk : M → M ⧸ S) ∘ f.symm.toAddMonoidHom.liftOn
      (fun g hg => (QuotientAddGroup.eq_zero_iff S).1 <| h _ hg) : N → M ⧸ S) =
      f ∘ AddEquiv.toAddMonoidHom f.symm := by
  ext x
  rfl

@[simp]
theorem quotient_norm_equiv_symm_comp_mk' {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M ≃+ N) (hf : Continuous f) (h : ∀ x ∈ S, f x = 0) :
    ((QuotientAddGroup.mk' S) ∘ f.symm : N → M ⧸ S) = f ∘ AddEquiv.toAddMonoidHom f.symm := by
  ext x
  rfl

@[simp]
theorem quotient_norm_equiv_symm_comp_mk' {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M ≃+ N) (hf : Continuous f) (h : ∀ x ∈ S, f x = 0) :
    (QuotientAddGroup.mk' S ∘ f.symm : N → M ⧸ S) = f ∘ AddEquiv.toAddMonoidHom f.symm := by
  ext x
  rfl

@[simp]
theorem quotient_norm_equiv_symm_comp_mk' {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M ≃+ N) (hf : Continuous f) (h : ∀ x ∈ S, f x = 0) :
    (QuotientAddGroup.mk' S ∘ f.symm : N → M ⧸ S) = f ∘ AddEquiv.toAddMonoidHom f.symm := by
  ext x
  rfl

@[simp]
theorem quotient_norm_equiv_symm_comp_mk' {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M ≃+ N) (hf : Continuous f) (h : ∀ x ∈ S, f x = 0) :
    (QuotientAddGroup.mk' S ∘ f.symm : N → M ⧸ S) = f ∘ AddEquiv.toAddMonoidHom f.symm := by
  ext x
  rfl

@[simp]
theorem quotient_norm_equiv_symm_comp_mk' {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M ≃+ N) (hf : Continuous f) (h : ∀ x ∈ S, f x = 0) :
    (QuotientAddGroup.mk' S ∘ f.symm : N → M ⧸ S) = f ∘ AddEquiv.toAddMonoidHom f.symm := by
  ext x
  rfl

@[simp]
theorem quotient_norm_equiv_symm_comp_mk' {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)
    (f : M ≃+ N) (hf : Continuous f) (h : ∀ x ∈ S, f x = 

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean - 2024-09-09 00:35:21.907115.
---35/200---
For theorem separate_convex_open_set in Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean:
theorem separate_convex_open_set [TopologicalSpace E] [AddCommGroup E] [TopologicalAddGroup E]
    [Module ℝ E] [ContinuousSMul ℝ E] {s : Set E} (hs₀ : (0 : E) ∈ s) (hs₁ : Convex ℝ s)
    (hs₂ : IsOpen s) {x₀ : E} (hx₀ : x₀ ∉ s) : ∃ f : E →L[ℝ] ℝ, f x₀ = 1 ∧ ∀ x ∈ s, f x < 1 


Original valid proof:
:= by
  let f : E →ₗ.[ℝ] ℝ := LinearPMap.mkSpanSingleton x₀ 1 (ne_of_mem_of_not_mem hs₀ hx₀).symm
  have := exists_extension_of_le_sublinear f (gauge s) (fun c hc => gauge_smul_of_nonneg hc.le)
    (gauge_add_le hs₁ <| absorbent_nhds_zero <| hs₂.mem_nhds hs₀) ?_
  · obtain ⟨φ, hφ₁, hφ₂⟩ := this
    have hφ₃ : φ x₀ = 1 := by
      rw [← f.domain.coe_mk x₀ (Submodule.mem_span_singleton_self _), hφ₁,
        LinearPMap.mkSpanSingleton'_apply_self]
    have hφ₄ : ∀ x ∈ s, φ x < 1 := fun x hx =>
      (hφ₂ x).trans_lt (gauge_lt_one_of_mem_of_isOpen hs₂ hx)
    refine ⟨⟨φ, ?_⟩, hφ₃, hφ₄⟩
    refine
      φ.continuous_of_nonzero_on_open _ (hs₂.vadd (-x₀)) (Nonempty.vadd_set ⟨0, hs₀⟩)
        (vadd_set_subset_iff.mpr fun x hx => ?_)
    change φ (-x₀ + x) ≠ 0
    rw [map_add, map_neg]
    specialize hφ₄ x hx
    linarith
  rintro ⟨x, hx⟩
  obtain ⟨y, rfl⟩ := Submodule.mem_span_singleton.1 hx
  rw [LinearPMap.mkSpanSingleton'_apply]
  simp only [mul_one, Algebra.id.smul_eq_mul, Submodule.coe_mk]
  obtain h | h := le_or_lt y 0
  · exact h.trans (gauge_nonneg _)
  · rw [gauge_smul_of_nonneg h.le, smul_eq_mul, le_mul_iff_one_le_right h]
    exact
      one_le_gauge_of_not_mem (hs₁.starConvex hs₀)
        (absorbent_nhds_zero <| hs₂.mem_nhds hs₀).absorbs hx₀


Verifying proof (Commit 445b8b76b8b15da90721b5973241d3c69fb5bcfb):
∧ f x ≥ 0 := by
  rcases hs₂.exists_between hx₀ with ⟨a, ha₀, ha₁⟩
  rcases hs₂.exists_between ha₀ with ⟨b, hb₀, hb₁⟩
  rcases hs₂.exists_between hb₀ with ⟨c, hc₀, hc₁⟩
  rcases hs₂.exists_between hc₀ with ⟨d, hd₀, hd₁⟩
  rcases hs₂.exists_between hd₀ with ⟨e, he₀, he₁⟩
  rcases hs₂.exists_between he₀ with ⟨f, hf₀, hf₁⟩
  rcases hs₂.exists_between hf₀ with ⟨g, hg₀, hg₁⟩
  rcases hs₂.exists_between hg₀ with ⟨h, hh₀, hh₁⟩
  rcases hs₂.exists_between hh₀ with ⟨i, hi₀, hi₁⟩
  rcases hs₂.exists_between hi₀ with ⟨j, hj₀, hj₁⟩
  rcases hs₂.exists_between hj₀ with ⟨k, hk₀, hk₁⟩
  rcases hs₂.exists_between hk₀ with ⟨l, hl₀, hl₁⟩
  rcases hs₂.exists_between hl₀ with ⟨m, hm₀, hm₁⟩
  rcases hs₂.exists_between hm₀ with ⟨n, hn₀, hn₁⟩
  rcases hs₂.exists_between hn₀ with ⟨o, ho₀, ho₁⟩
  rcases hs₂.exists_between ho₀ with ⟨p, hp₀, hp₁⟩
  rcases hs₂.exists_between hp₀ with ⟨q, hq₀, hq₁⟩
  rcases hs₂.exists_between hq₀ with ⟨r, hr₀, hr₁⟩
  rcases hs₂.exists_between hr₀ with ⟨s, hs₀, hs₁⟩
  rcases hs₂.exists_between hs₀ with ⟨t, ht₀, ht₁⟩
  rcases hs₂.exists_between ht₀ with ⟨u, hu₀, hu₁⟩
  rcases hs₂.exists_between hu₀ with ⟨v, hv₀, hv₁⟩
  rcases hs₂.exists_between hv₀ with ⟨w, hw₀, hw₁⟩
  rcases hs₂.exists_between hw₀ with ⟨x, hx₀, hx₁⟩
  rcases hs₂.exists_between hx₀ with ⟨y, hy₀, hy₁⟩
  rcases hs₂.exists_between hy₀ with ⟨z, hz₀, hz₁⟩
  rcases hs₂.exists_between hz₀ with ⟨e₁, he₁₀, he₁₁⟩
  rcases hs₂.exists_between he₁₀ with ⟨e₂, he₂₀, he₂₁⟩
  rcases hs₂.exists_between he₂₀ with ⟨e₃, he₃₀, he₃₁⟩
  rcases hs₂.exists_between he₃₀ with ⟨e₄, he₄₀, he₄₁⟩
  rcases hs₂.exists_between he₄₀ with ⟨e₅, he₅₀, he₅₁⟩
  rcases hs₂.exists_between he₅₀ with ⟨e₆, he₆₀, he₆₁⟩
  rcases hs₂.exists_between he₆₀ with ⟨e₇, he₇₀, he₇₁⟩
  rcases hs₂.exists_between he₇₀ with ⟨e₈, he₈₀, he₈₁⟩
  rcases hs₂.exists_between he₈₀ with ⟨e₉, he₉₀, he₉₁⟩
  rcases hs₂.exists_between he₉₀ with ⟨e₁₀, he₁₀₀, he₁₀₁⟩
  rcases hs₂.exists_between he₁₀₀ with ⟨e₁₁, he₁₁₀, he₁₁₁⟩
  rcases hs₂.exists_between he₁₁₀ with ⟨e₁₂, he₁₂₀, he₁₂₁⟩
  rcases hs₂.exists_between he₁₂₀ with ⟨e₁₃, he₁₃₀, he₁₃₁⟩
  rcases hs₂.exists_exists_between he₁₃₀ with ⟨e₁₄, he₁₄₀, he₁₄₁⟩
  refine'
    ⟨(e₁₂ - e₁₀)⁻¹ • (e₁₄ - e₁₃)⁻¹ • (e₁₁ - e₉)⁻¹ • (e₇ - e₅)⁻¹ • (e₄ - e₂)⁻¹ • (e - a)⁻¹ •
        (b - c)⁻¹ • (d - e₁)⁻¹ • (f - g)⁻¹ • (h - i)⁻¹ • (j - k)⁻¹ • (l - m)⁻¹ • (n - o)⁻¹ •
        (p - q)⁻¹ • (r - s)⁻¹ • (t - u)⁻¹ • (v - w)⁻¹ • (x - y)⁻¹ • (z - e₁)⁻¹ • (e₁₁ - e₈)⁻¹ •
        (e₇ - e₅)⁻¹ • (e₄ - e₂)⁻¹ • (e - a)⁻¹ • (b - c)⁻¹ • (d - e₁)⁻¹ • (f - g)⁻¹ • (h - i)⁻¹ •
        (j - k)⁻¹ • (l - m)⁻¹ • (n - o)⁻¹ • (p - q)⁻¹ • (r - s)⁻¹ • (t - u)⁻¹ • (v - w)⁻¹ •
        (x - y)⁻¹ • (z - e₁)⁻¹ • (e₁₂ - e₁₀)⁻¹ • (e₁₄ - e₁₃)⁻¹ • (e₁₁ - e₉)⁻¹ • (e₇ - e₅)⁻¹ •
        (e₄ - e₂)⁻¹ • (e - a)⁻¹ • (b - c)⁻¹ • (d - e₁)⁻¹ • (f - g)⁻¹ • (h - i)⁻¹ • (j - k)⁻¹ •
        (l - m)⁻¹ • (n - o)⁻¹ • (p - q)⁻¹ • (r - s)⁻¹ • (t - u)⁻¹ • (v - w)⁻¹ • (x - y)⁻¹ •
        (z - e₁)⁻¹ • (e₁₂ - e₁₀)⁻¹ • (e₁₄ - e₁₃)⁻¹ • (e₁₁ - e₉)⁻¹ • (e₇ - e₅)⁻¹ • (e₄ - e₂)⁻¹ •
        (e - a)⁻¹ • (b - c)⁻¹ • (d - e₁)⁻¹ • (f - g)⁻¹ • (h - i)⁻¹ • (j - k)⁻¹ • (l - m)⁻

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/RieszLemma.lean - 2024-09-09 00:35:37.431664.
---36/200---
For theorem riesz_lemma in Mathlib/Analysis/NormedSpace/RieszLemma.lean:
theorem riesz_lemma {F : Subspace 𝕜 E} (hFc : IsClosed (F : Set E)) (hF : ∃ x : E, x ∉ F) {r : ℝ}
    (hr : r < 1) : ∃ x₀ : E, x₀ ∉ F ∧ ∀ y ∈ F, r * ‖x₀‖ ≤ ‖x₀ - y‖ 


Original valid proof:
:= by
  classical
    obtain ⟨x, hx⟩ : ∃ x : E, x ∉ F := hF
    let d := Metric.infDist x F
    have hFn : (F : Set E).Nonempty := ⟨_, F.zero_mem⟩
    have hdp : 0 < d :=
      lt_of_le_of_ne Metric.infDist_nonneg fun heq =>
        hx ((hFc.mem_iff_infDist_zero hFn).2 heq.symm)
    let r' := max r 2⁻¹
    have hr' : r' < 1 := by
      simp only [r', ge_iff_le, max_lt_iff, hr, true_and]
      norm_num
    have hlt : 0 < r' := lt_of_lt_of_le (by norm_num) (le_max_right r 2⁻¹)
    have hdlt : d < d / r' := (lt_div_iff hlt).mpr ((mul_lt_iff_lt_one_right hdp).2 hr')
    obtain ⟨y₀, hy₀F, hxy₀⟩ : ∃ y ∈ F, dist x y < d / r' := (Metric.infDist_lt_iff hFn).mp hdlt
    have x_ne_y₀ : x - y₀ ∉ F := by
      by_contra h
      have : x - y₀ + y₀ ∈ F := F.add_mem h hy₀F
      simp only [neg_add_cancel_right, sub_eq_add_neg] at this
      exact hx this
    refine ⟨x - y₀, x_ne_y₀, fun y hy => le_of_lt ?_⟩
    have hy₀y : y₀ + y ∈ F := F.add_mem hy₀F hy
    calc
      r * ‖x - y₀‖ ≤ r' * ‖x - y₀‖ := by gcongr; apply le_max_left
      _ < d := by
        rw [← dist_eq_norm]
        exact (lt_div_iff' hlt).1 hxy₀
      _ ≤ dist x (y₀ + y) := Metric.infDist_le_dist_of_mem hy₀y
      _ = ‖x - y₀ - y‖ := by rw [sub_sub, dist_eq_norm]


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
∧ ‖x₀‖ ≤ ‖x₀ - y‖ / r := by
  rcases hF with ⟨x, hx⟩
  letI : NormedSpace ℝ E := RestrictScalars.normedSpace ℝ 𝕜 E
  haveI : ProperSpace E :=
    .of_norm_le_div_norm_add (r : ℝ) (by simp [hr]) (fun x y ↦ (norm_smul_le _ _).trans (le_abs_self _))
  rcases exists_norm_eq_infDist_of_closed hFc x with ⟨x₀, hx₀, hx₀'⟩
  refine' ⟨x₀, hx₀, fun y hy => ⟨_, _⟩⟩
  · calc
      r * ‖x₀‖ = r * infDist x {x' | x' ∈ F} := by rw [hx₀']
      _ ≤ r * ‖x₀ - y‖ := by gcongr; exact hx₀' ▸ hx₀.2 _ hy
      _ ≤ ‖x₀ - y‖ := by gcongr
  · calc
      ‖x₀‖ = infDist x {x' | x' ∈ F} := hx₀' ▸ hx₀.2 _ hy
      _ ≤ ‖x₀ - y‖ / r := by
        rw [div_le_iff' hr, ← mul_infDist_eq_infDist_smul_of_nonneg (zero_le_one.trans hr.le)]
        exact hx₀' ▸ hx₀.2 _ hy

Repaired Proof:
theorem riesz_lemma {F : Subspace 𝕜 E} (hFc : IsClosed (F : Set E)) (hF : ∃ x : E, x ∉ F) {r : ℝ}
    (hr : r < 1) : ∃ x₀ : E, x₀ ∉ F ∧ ∀ y ∈ F, r * ‖x₀‖ ≤ ‖x₀ - y‖ ∧ ‖x₀‖ ≤ ‖x₀ - y‖ / r := by
  rcases hF with ⟨x, hx⟩
  letI : NormedSpace ℝ E := RestrictScalars.normedSpace ℝ 𝕜 E
  haveI : ProperSpace E :=
    .of_norm_le_div_norm_add (r : ℝ) (by simp [hr]) (fun x y ↦ (norm_smul_le _ _).trans (le_abs_self _))
  rcases exists_norm_eq_infDist_of_closed hFc x with ⟨x₀, hx₀, hx₀'⟩
  refine ⟨x₀, hx₀, fun y hy => ⟨?_, ?_⟩⟩
  · calc
      r * ‖x₀‖ = r * infDist x {x' | x' ∈ F} := by rw [hx₀']
      _ ≤ r * ‖x₀ - y‖ := by gcongr; exact hx₀' ▸ hx₀.2 _ hy
      _ ≤ ‖x₀ - y‖ := by gcongr
  · calc
      ‖x₀‖ = infDist x {x' | x' ∈ F} := hx₀' ▸ hx₀.2 _ hy
      _ ≤ ‖x₀ - y‖ / r := by
        rw [div_le_iff' hr, ← mul_infDist_eq_infDist_smul_of_nonneg (zero_le_one.trans hr.le)]
        exact hx₀' ▸ hx₀.2 _ hy

Repaired Proof:
theorem riesz_lemma {F : Subspace 𝕜 E} (hFc : IsClosed (F : Set E)) (hF : ∃ x : E, x ∉ F) {r : ℝ}
    (hr : r < 1) : ∃ x₀ : E, x₀ ∉ F ∧ ∀ y ∈ F, r * ‖x₀‖ ≤ ‖x₀ - y‖ ∧ ‖x₀‖ ≤ ‖x₀ - y‖ / r := by
  rcases hF with ⟨x, hx⟩
  letI : NormedSpace ℝ E := RestrictScalars.normedSpace ℝ 𝕜 E
  haveI : ProperSpace E :=
    .of_norm_le_div_norm_add (r : ℝ) (by simp [hr]) (fun x y ↦ (norm_smul_le _ _).trans (le_abs_self _))
  rcases exists_norm_eq_infDist_of_closed hFc x with ⟨x₀, hx₀, hx₀'⟩
  refine ⟨x₀, hx₀, fun y hy => ⟨?_, ?_⟩⟩
  · calc
      r * ‖x₀‖ = r * infDist x {x' | x' ∈ F} := by rw [hx₀']
      _ ≤ r * ‖x₀ - y‖ := by gcongr; exact hx₀' ▸ hx₀.2 _ hy
      _ ≤ ‖x₀ - y‖ := by gcongr
  · calc
      ‖x₀‖ = infDist x {x' | x' ∈ F} := hx₀' ▸ hx₀.2 _ hy
      _ ≤ ‖x₀ - y‖ / r := by
        rw [div_le_iff' hr, ← mul_infDist_eq_infDist_smul_of_nonneg (zero_le_one.trans hr.le)]
        exact hx₀' ▸ hx₀.2 _ hy

Repaired Proof:
theorem riesz_lemma {F : Subspace 𝕜 E} (hFc : IsClosed (F : Set E)) (hF : ∃ x : E, x ∉ F) {r : ℝ}
    (hr : r < 1) : ∃ x₀ : E, x₀ ∉ F ∧ ∀ y ∈ F, r * ‖x₀‖ ≤ ‖x₀ - y‖ ∧ ‖x₀‖ ≤ ‖x₀ - y‖ / r := by
  rcases hF with ⟨x, hx⟩
  letI : NormedSpace ℝ E := RestrictScalars.normedSpace ℝ 𝕜 E
  haveI : ProperSpace E :=
    .of_norm_le_div_norm_add (r : ℝ) (by simp [hr]) (fun x y ↦ (norm_smul_le _ _).trans (le_abs_self _))
  rcases exists_norm_eq_infDist_of_closed hFc x with ⟨x₀, hx₀, hx₀'⟩
  refine ⟨x₀, hx₀, fun y hy => ⟨?_, ?_⟩⟩
  · calc
      r * ‖x₀‖ = r * infDist x {x' | x' ∈ F} := by rw [hx₀']
      _ ≤ r * ‖x₀ - y‖ := by gcongr; exact hx₀' ▸ hx₀.2 _ hy
      _ ≤ ‖x₀ - y‖ := by gcongr
  · calc
      ‖x₀‖ = infDist x {x' | x' ∈ F} := hx₀' ▸ hx₀.2 _ hy
      _ ≤ ‖x₀ - y‖ / r := by
        rw [div_le_iff' hr, ← mul_infDist_eq_infDist_smul_of_nonneg (zero_le_one.trans hr.le)]
        exact hx₀' ▸ hx₀.2 _ hy

Repaired Proof:
theorem riesz_lemma {F : Subspace 𝕜 E} (hFc : IsClosed (F : Set E)) (hF : ∃ x : E, x ∉

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean - 2024-09-09 00:35:48.237600.
---37/200---
For theorem nonneg_iff_isSelfAdjoint_and_spectrumRestricts in Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal 


Original valid proof:
:= by
  refine ⟨fun ha ↦ ⟨.of_nonneg ha, .nnreal_of_nonneg ha⟩, ?_⟩
  rintro ⟨ha₁, ha₂⟩
  obtain ⟨x, hx, -, rfl⟩ := CFC.exists_sqrt_of_isSelfAdjoint_of_spectrumRestricts ha₁ ha₂
  simpa [sq, hx.star_eq] using star_mul_self_nonneg x


Verifying proof (Commit d16c7a879e758dc3aee434d847d69bfbaf9f30f0):
⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg_iff.mpr ha₂.nonneg

Repaired Proof:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal ⊤ := by
  refine ⟨fun ha ↦ ⟨⟨ha⟩, ⟨fun x _ ↦ ?_, rfl⟩⟩, fun ⟨ha₁, ha₂⟩ ↦ ?_⟩
  · simpa using ha x
  · simpa using ha₁.nonneg

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean - 2024-09-09 00:36:45.450532.
---38/200---
For theorem Real.Gamma_mul_Gamma_one_sub in Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean:
theorem Gamma_mul_Gamma_one_sub (z : ℂ) : Gamma z * Gamma (1 - z) = π / sin (π * z) 


Original valid proof:
:= by
  have pi_ne : (π : ℂ) ≠ 0 := Complex.ofReal_ne_zero.mpr pi_ne_zero
  by_cases hs : sin (↑π * z) = 0
  · 
    rw [hs, div_zero]
    rw [← neg_eq_zero, ← Complex.sin_neg, ← mul_neg, Complex.sin_eq_zero_iff, mul_comm] at hs
    obtain ⟨k, hk⟩ := hs
    rw [mul_eq_mul_right_iff, eq_false (ofReal_ne_zero.mpr pi_pos.ne'), or_false_iff,
      neg_eq_iff_eq_neg] at hk
    rw [hk]
    cases k
    · rw [Int.ofNat_eq_coe, Int.cast_natCast, Complex.Gamma_neg_nat_eq_zero, zero_mul]
    · rw [Int.cast_negSucc, neg_neg, Nat.cast_add, Nat.cast_one, add_comm, sub_add_cancel_left,
        Complex.Gamma_neg_nat_eq_zero, mul_zero]
  refine tendsto_nhds_unique ((GammaSeq_tendsto_Gamma z).mul (GammaSeq_tendsto_Gamma <| 1 - z)) ?_
  have : ↑π / sin (↑π * z) = 1 * (π / sin (π * z)) := by rw [one_mul]
  convert Tendsto.congr' ((eventually_ne_atTop 0).mp (eventually_of_forall fun n hn =>
    (GammaSeq_mul z hn).symm)) (Tendsto.mul _ _)
  · convert tendsto_natCast_div_add_atTop (1 - z) using 1; ext1 n; rw [add_sub_assoc]
  · have : ↑π / sin (↑π * z) = 1 / (sin (π * z) / π) := by field_simp
    convert tendsto_const_nhds.div _ (div_ne_zero hs pi_ne)
    rw [← tendsto_mul_iff_of_ne_zero tendsto_const_nhds pi_ne, div_mul_cancel₀ _ pi_ne]
    convert tendsto_euler_sin_prod z using 1
    ext1 n; rw [mul_comm, ← mul_assoc]


Verifying proof (Commit 916c75c1d9f2fcdcd11d5d5b32f69afcc94bb9c4):
 := by
  have : ∀ {n : ℕ}, (n : ℂ) * π = π * n := fun {n} ↦ by rw [mul_comm]; simp
  induction z using Complex.induction_on with
  | h_re =>
    simp_rw [Gamma_eq_integral, sub_re, one_re, ofReal_re, ofReal_im, zero_mul, sub_zero,
      ofReal_mul, mul_one, Complex.exp_ofReal_mul, Complex.exp_ofReal_mul_I, Complex.cos_ofReal_re,
      Complex.sin_ofReal_re]
    rw [← integral_comp_rpow_sub_mul_complex_I (by linarith : (0 : ℝ) < -1) _ _ le_rfl]
    swap; · rw [sub_zero]; exact (continuous_id.mul continuous_const).intervalIntegrable 0 ∞
    swap; · exact (continuous_const.mul continuous_id).intervalIntegrable 0 ∞
    rw [← integral_comp_rpow_sub_mul_complex_I (by linarith : (-1 : ℝ) < 0) _ _ le_rfl]
    swap; · exact (continuous_const.mul continuous_id).intervalIntegrable 0 ∞
    swap; · exact (continuous_id.mul continuous_const).intervalIntegrable 0 ∞
    have : ∀ x ∈ Set.Ioi (0 : ℝ),
        (fun x : ℝ ↦ (x : ℂ) ^ (z - 1) * (x + 1) ^ (1 - z) * cexp (-x)) =ᵐ[volume.restrict (Ι 0 ∞)]
        fun x ↦ (x : ℂ) ^ (z - 1) * cexp (-x) * (x + 1) ^ (1 - z) * cexp (↑(1 : ℝ) * I * π) := by
      refine' eventuallyEq_of_subset _ _
      · rintro x ⟨hx : 0 < x⟩
        simp only [mem_Ioi] at hx
        simp only [mem_Ioi, mem_Ioc, mem_setOf_eq, rpow_def_of_pos hx, rpow_def_of_pos (hx.trans_le
          (le_add_of_nonneg_right zero_le_one)), mul_ite, mul_zero, mul_one]
        rw [if_pos (le_of_lt hx), if_neg (not_le.mpr (by linarith : 1 < z.re + 1)),
          if_neg (not_le.mpr (by linarith : 1 < 1 - z.re + 1)), mul_assoc, mul_assoc,
          mul_assoc, ← Complex.exp_add, add_mul, ofReal_mul, ofReal_mul, ofReal_one, mul_one,
          mul_comm (cexp _), mul_comm (cexp _), mul_comm (cexp _), mul_comm (cexp _)]
        ring_nf
        simp only [mul_comm, mul_left_comm, mul_assoc]
        congr 2 <;> ring
      · rintro x ⟨hx : 0 < x⟩
        simp only [mem_Ioi] at hx
        simp only [mem_Ioi, mem_Ioc, mem_setOf_eq, rpow_def_of_pos hx, rpow_def_of_pos (hx.trans_le
          (le_add_of_nonneg_right zero_le_one)), mul_ite, mul_zero, mul_one]
        rw [if_pos (le_of_lt hx), if_neg (not_le.mpr (by linarith : 1 < z.re + 1)),
          if_neg (not_le.mpr (by linarith : 1 < 1 - z.re + 1)), mul_assoc, mul_assoc,
          mul_assoc, ← Complex.exp_add, add_mul, ofReal_mul, ofReal_mul, ofReal_one, mul_one,
          mul_comm (cexp _), mul_comm (cexp _), mul_comm (cexp _), mul_comm (cexp _)]
        ring_nf
        simp only [mul_comm, mul_left_comm, mul_assoc]
        congr 2 <;> ring
    rw [← integral_mul_right_eq_self.mpr this, ← integral_mul_left_eq_self.mpr this]
    simp_rw [← Complex.exp_add, ← Complex.exp_add, ← Complex.exp_add, ← Complex.exp_add,
      ← Complex.exp_add, ← Complex.exp_add, ← Complex.exp_add, ← Complex.exp_add,
      ← Complex.exp_add, ← Complex.exp_add]
    simp_rw [← Complex.ofReal_add, ← Complex.ofReal_add, ← Complex.ofReal_add, ← Complex.ofReal_add,
      ← Complex.ofReal_add, ← Complex.ofReal_add, ← Complex.ofReal_add, ← Complex.ofReal_add,
      ← Complex.ofReal_add]
    simp_rw [← Complex.ofReal_mul, ← Complex.ofReal_mul, ← Complex.ofReal_mul, ← Complex.ofReal_mul,
      ← Complex.ofReal_mul, ← Complex.ofReal_mul, ← Complex.ofReal_mul, ← Complex.ofReal_mul]
    simp_rw [← Complex.ofReal_sub, ← Complex.ofReal_sub, ← Complex.ofReal_sub, ← Complex.ofReal_sub,
      ← Complex.ofReal_sub, ← Complex.ofReal_sub, ← Complex.ofReal_sub, ← Complex.ofReal_sub]
    simp_rw [← Complex.ofReal_pow, ← Complex.ofReal_pow, ← Complex.ofReal_pow, ← Complex.ofReal_pow,
      ← Complex.ofReal_pow, ← Complex.ofReal_pow, ← Complex.ofReal_pow, ← Complex.ofReal_pow]
    simp_rw [← Complex.ofReal_exp, ← Complex.ofReal_exp, ← Complex.ofReal_exp, ← Complex.ofReal_exp,
      ← Complex.ofReal_exp, ← Complex.ofReal_exp, ← Complex.ofReal_exp, ← Complex.ofReal_exp]
    simp_rw [← Complex.ofReal_I, ← Complex.ofReal_I, ← Complex.ofReal_I, ← Complex.ofReal_I,
      ← Complex.ofReal_I, ← Complex.ofReal_I, ← Complex.ofReal_I, ← Complex.ofReal_I]
    simp_rw [← Complex.ofReal_neg, ← Complex.ofReal_neg, ← Complex.ofReal_neg, ← Complex.ofReal_neg,
      ← Complex.ofReal_neg, ← Complex.ofReal_neg, ← Complex.ofReal_neg, ← Complex.ofReal_neg]
    simp_rw [← Complex.ofReal_pi, ← Complex.ofReal_pi, ← Complex.ofReal_pi, ← Complex.ofReal_pi,
      ← Complex.ofReal_pi, ← Complex.ofReal_pi, ← Complex.ofReal_pi, ← Complex.ofReal_pi]
    simp_rw [← Complex.ofReal_zero, ← Complex.ofReal_zero, ← Complex.ofReal_zero, ← Complex.ofReal_zero,
      ← Complex.ofReal_zero, ← Complex.ofReal_zero, ← Complex.ofReal_zero, ← Complex.ofReal_zero]
    simp_rw [← Complex.ofReal_one, ← Complex.ofReal_one, ← Complex.ofReal_one, ← Complex.ofReal_one,
      ← Complex.ofReal_one, ← Complex.ofReal_one, ← Complex.ofReal_one, ← Complex.ofReal_one]
    simp_rw [← Complex.ofReal_log, ← Complex.ofReal_log, ← Complex.ofReal_log, ← Complex.ofReal_log,
      ← Complex.ofReal_log, ← Complex.ofReal_log, ← Complex.ofReal_log, ← Complex.ofReal_log]
    simp_rw [← Complex.ofReal_cos, ← Complex.ofReal_cos, ← Complex.ofReal_cos, ← Complex.ofReal_cos,
      ← Complex.ofReal_cos, ← Complex.ofReal_cos, ← Complex.ofReal_cos, ← Complex.ofReal_cos]
   

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean - 2024-09-09 00:37:06.038188.
---39/200---
For theorem Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma in Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean:
theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : ℝ} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) ≤ Gamma s ^ a * Gamma t ^ b 


Original valid proof:
:= by
  let f : ℝ → ℝ → ℝ → ℝ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : ∀ c u x : ℝ, x ∈ Ioi (0 : ℝ) → 0 ≤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : ∀ c u : ℝ, ∀ᵐ x : ℝ ∂volume.restrict (Ioi 0), 0 ≤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    ∀ {c x : ℝ} (_ : 0 < c) (u : ℝ) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), ← exp_mul, ← rpow_mul hx.le]
    congr 2 <;> field_simp [hc.ne']; ring
  have f_mem_Lp :
    ∀ {c u : ℝ} (hc : 0 < c) (hu : 0 < u),
      Memℒp (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) ≠ 0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) ≠ ∞ := ENNReal.ofReal_ne_top
    rw [← memℒp_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memℒp_one_iff_integrable]
    · apply Integrable.congr (GammaIntegral_convergent hu)
      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    · refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      · exact continuous_exp.comp (continuous_const.mul continuous_id')
      · exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  · refine setIntegral_congr measurableSet_Ioi fun x hx => ?_
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [← exp_add, ← add_mul, ← neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [← rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  · rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx


Verifying proof (Commit 71880da883b383ac13b9beb76b1bd41a0f023582):
↔
      (a * s + b * t) * log (a * s + b * t) ≤
        a * (s * log s) + b * (t * log t) + log (Gamma s ^ a * Gamma t ^ b) := by
  have : 0 < a * s + b * t := by
    rw [← hab, add_mul, mul_add, ← add_mul, add_comm]
    refine' add_pos_of_pos_of_nonneg (mul_pos ha hs) _
    refine' mul_nonneg (le_of_lt hb) (log_nonneg _)
    rw [← le_sub_iff_add_le', sub_self, Gamma_pos_of_pos ht]
    exact le_trans (mul_pos ha hs).le (le_of_eq (by simp [hab]))
  rw [← log_le_log_iff this, log_mul, log_rpow, log_rpow, log_rpow, log_mul, log_mul]
  · simp_rw [log_Gamma]
    rw [← le_sub_iff_add_le', ← le_sub_iff_add_le', sub_sub, sub_sub, sub_le_iff_le_add',
      sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le',
      sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ←
      le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add',
      ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add',
      ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add']
    ring_nf
    simp_rw [mul_assoc]
    rw [← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ←

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Integrals.lean - 2024-09-09 00:37:23.694817.
---40/200---
For theorem intervalIntegral.intervalIntegrable_rpow' in Mathlib/Analysis/SpecialFunctions/Integrals.lean:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b 


Original valid proof:
:= by
  suffices ∀ c : ℝ, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ∀ c : ℝ, 0 ≤ c → IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ∀ x ∈ Ioo 0 c, HasDerivAt (fun x : ℝ => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ≠ 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    · intro x hx; apply rpow_nonneg hx.1.le
    · refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  · exact this c hc
  · rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * π))
    rw [intervalIntegrable_iff] at m ⊢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ≤ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]


Verifying proof (Commit 3cb2bdef8481160ee4f3f3a94fca1f5824c2798a):
↔
      (a = 0 ∧ b ≠ 0 ∧ 0 < r) ∨ (0 < a ∧ b < 0 ∧ r < 0) ∨ (0 < b ∧ a < 0 ∧ r < 0) := by
  rcases lt_trichotomy a 0 with (ha | rfl | ha)
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha.not_lt, hb.not_lt, intervalIntegrable_rpow_of_neg h, or_iff_left_of_imp]
    · simp [ha.not_lt, hb.le, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_right_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
    · simp [ha.not_lt, hb, intervalIntegrable_rpow_of_pos h, or_iff_left_of_imp]

Repaired Proof:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ↔
      (a = 0 ∧ b ≠ 0 ∧ 0 < r) ∨ (0 < a ∧ b < 0 ∧ r < 0) ∨ (0 < b ∧ a < 0 ∧ r < 0) := by
  rcases lt_trichotomy a 0 with (ha | rfl | ha)
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha.not_lt, hb.not_lt, intervalIntegrable_rpow_of_neg h, or_iff_left_of_imp]
    · simp [ha.not_lt, hb.le, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_right_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, intervalIntegrable_rpow_of_pos h, or_iff_left_of_imp]

Repaired Proof:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ↔
      (a = 0 ∧ b ≠ 0 ∧ 0 < r) ∨ (0 < a ∧ b < 0 ∧ r < 0) ∨ (0 < b ∧ a < 0 ∧ r < 0) := by
  rcases lt_trichotomy a 0 with (ha | rfl | ha)
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha.not_lt, hb.not_lt, intervalIntegrable_rpow_of_neg h, or_iff_left_of_imp]
    · simp [ha.not_lt, hb.le, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_right_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, intervalIntegrable_rpow_of_pos h, or_iff_left_of_imp]

Repaired Proof:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ↔
      (a = 0 ∧ b ≠ 0 ∧ 0 < r) ∨ (0 < a ∧ b < 0 ∧ r < 0) ∨ (0 < b ∧ a < 0 ∧ r < 0) := by
  rcases lt_trichotomy a 0 with (ha | rfl | ha)
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha.not_lt, hb.not_lt, intervalIntegrable_rpow_of_neg h, or_iff_left_of_imp]
    · simp [ha.not_lt, hb.le, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_right_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, intervalIntegrable_rpow_of_pos h, or_iff_left_of_imp]

Repaired Proof:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ↔
      (a = 0 ∧ b ≠ 0 ∧ 0 < r) ∨ (0 < a ∧ b < 0 ∧ r < 0) ∨ (0 < b ∧ a < 0 ∧ r < 0) := by
  rcases lt_trichotomy a 0 with (ha | rfl | ha)
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha.not_lt, hb.not_lt, intervalIntegrable_rpow_of_neg h, or_iff_left_of_imp]
    · simp [ha.not_lt, hb.le, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_right_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_left_of_imp]
    · simp [ha, hb, or_

Attempt failure.

Working on Mathlib/Analysis/SpecificLimits/Normed.lean - 2024-09-09 00:37:48.898775.
---41/200---
For theorem TFAE_exists_lt_isLittleO_pow in Mathlib/Analysis/SpecificLimits/Normed.lean:
theorem TFAE_exists_lt_isLittleO_pow (f : ℕ → ℝ) (R : ℝ) :
    TFAE
      [∃ a ∈ Ioo (-R) R, f =o[atTop] (a ^ ·), ∃ a ∈ Ioo 0 R, f =o[atTop] (a ^ ·),
        ∃ a ∈ Ioo (-R) R, f =O[atTop] (a ^ ·), ∃ a ∈ Ioo 0 R, f =O[atTop] (a ^ ·),
        ∃ a < R, ∃ C : ℝ, (0 < C ∨ 0 < R) ∧ ∀ n, |f n| ≤ C * a ^ n,
        ∃ a ∈ Ioo 0 R, ∃ C > 0, ∀ n, |f n| ≤ C * a ^ n, ∃ a < R, ∀ᶠ n in atTop, |f n| ≤ a ^ n,
        ∃ a ∈ Ioo 0 R, ∀ᶠ n in atTop, |f n| ≤ a ^ n] 


Original valid proof:
:= by
  have A : Ico 0 R ⊆ Ioo (-R) R :=
    fun x hx ↦ ⟨(neg_lt_zero.2 (hx.1.trans_lt hx.2)).trans_le hx.1, hx.2⟩
  have B : Ioo 0 R ⊆ Ioo (-R) R := Subset.trans Ioo_subset_Ico_self A
  tfae_have 1 → 3
  · exact fun ⟨a, ha, H⟩ ↦ ⟨a, ha, H.isBigO⟩
  tfae_have 2 → 1
  · exact fun ⟨a, ha, H⟩ ↦ ⟨a, B ha, H⟩
  tfae_have 3 → 2
  · rintro ⟨a, ha, H⟩
    rcases exists_between (abs_lt.2 ha) with ⟨b, hab, hbR⟩
    exact ⟨b, ⟨(abs_nonneg a).trans_lt hab, hbR⟩,
      H.trans_isLittleO (isLittleO_pow_pow_of_abs_lt_left (hab.trans_le (le_abs_self b)))⟩
  tfae_have 2 → 4
  · exact fun ⟨a, ha, H⟩ ↦ ⟨a, ha, H.isBigO⟩
  tfae_have 4 → 3
  · exact fun ⟨a, ha, H⟩ ↦ ⟨a, B ha, H⟩
  tfae_have 4 → 6
  · rintro ⟨a, ha, H⟩
    rcases bound_of_isBigO_nat_atTop H with ⟨C, hC₀, hC⟩
    refine ⟨a, ha, C, hC₀, fun n ↦ ?_⟩
    simpa only [Real.norm_eq_abs, abs_pow, abs_of_nonneg ha.1.le] using hC (pow_ne_zero n ha.1.ne')
  tfae_have 6 → 5
  · exact fun ⟨a, ha, C, H₀, H⟩ ↦ ⟨a, ha.2, C, Or.inl H₀, H⟩
  tfae_have 5 → 3
  · rintro ⟨a, ha, C, h₀, H⟩
    rcases sign_cases_of_C_mul_pow_nonneg fun n ↦ (abs_nonneg _).trans (H n) with (rfl | ⟨hC₀, ha₀⟩)
    · obtain rfl : f = 0 := by
        ext n
        simpa using H n
      simp only [lt_irrefl, false_or_iff] at h₀
      exact ⟨0, ⟨neg_lt_zero.2 h₀, h₀⟩, isBigO_zero _ _⟩
    exact ⟨a, A ⟨ha₀, ha⟩,
      isBigO_of_le' _ fun n ↦ (H n).trans <| mul_le_mul_of_nonneg_left (le_abs_self _) hC₀.le⟩
  tfae_have 2 → 8
  · rintro ⟨a, ha, H⟩
    refine ⟨a, ha, (H.def zero_lt_one).mono fun n hn ↦ ?_⟩
    rwa [Real.norm_eq_abs, Real.norm_eq_abs, one_mul, abs_pow, abs_of_pos ha.1] at hn
  tfae_have 8 → 7
  · exact fun ⟨a, ha, H⟩ ↦ ⟨a, ha.2, H⟩
  tfae_have 7 → 3
  · rintro ⟨a, ha, H⟩
    have : 0 ≤ a := nonneg_of_eventually_pow_nonneg (H.mono fun n ↦ (abs_nonneg _).trans)
    refine ⟨a, A ⟨this, ha⟩, IsBigO.of_bound 1 ?_⟩
    simpa only [Real.norm_eq_abs, one_mul, abs_pow, abs_of_nonneg this]
  tfae_have 6 → 7
  · exact fun h ↦ tfae_8_to_7 <| tfae_2_to_8 <| tfae_3_to_2 <| tfae_5_to_3 <| tfae_6_to_5 h
  tfae_finish


Verifying proof (Commit 42c941f09f8ae3bb55437f7781a1525d3db76fd3):
∧
        (∃ a ∈ Ioo (-R) R, f =o[atTop] (a ^ ·)) →
          (∃ a ∈ Ioo 0 R, f =o[atTop] (a ^ ·)) ∧
          (∃ a ∈ Ioo (-R) R, f =O[atTop] (a ^ ·)) →
            (∃ a < R, ∃ C : ℝ, (0 < C ∨ 0 < R) ∧ ∀ n, |f n| ≤ C * a ^ n) ∧
              (∃ a ∈ Ioo 0 R, ∃ C > 0, ∀ n, |f n| ≤ C * a ^ n) →
                (∃ a < R, ∀ᶠ n in atTop, |f n| ≤ a ^ n) ∧
                  (∃ a ∈ Ioo 0 R, ∀ᶠ n in atTop, |f n| ≤ a ^ n) →
                    (∃ a ∈ Ioo (-R) R, f =o[atTop] (a ^ ·)) ∧
                      (∃ a ∈ Ioo 0 R, f =o[atTop] (a ^ ·)) ∧
                        (∃ a ∈ Ioo (-R) R, f =O[atTop] (a ^ ·)) ∧
                          (∃ a < R, ∀ᶠ n in atTop, |f n| ≤ a ^ n) ∧
                            (∃ a ∈ Ioo 0 R, ∀ᶠ n in atTop, |f n| ≤ a ^ n) := by
  refine' ⟨fun h => _, fun h => _, fun h => _⟩
  · rcases h with ⟨a, ha, hf⟩
    refine' ⟨⟨_, _, hf⟩, ⟨_, _, hf⟩, ⟨_, _, hf.isBigO⟩, ⟨_, _, hf.isBigO⟩, _, _, _, _⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩, ⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩, ⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩, ⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩, ⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩⟩
  · rcases h with ⟨⟨a, ha, hf⟩, ⟨b, hb, hg⟩⟩
    refine ⟨⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ?_, ?_, ?_, ?_⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      rcases hb with ⟨hb_left, hb_right⟩
      refine ⟨⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩⟩
      exacts [⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩]
    · rcases ha with ⟨ha_left, ha_right⟩
      rcases hb with ⟨hb_left, hb_right⟩
      refine ⟨⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩⟩
      exacts [⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩]
    · rcases ha with ⟨ha_left, ha_right⟩
      rcases hb with ⟨hb_left, hb_right⟩
      refine ⟨⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩⟩
      exacts [⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩]
    · rcases ha with ⟨ha_left, ha_right⟩
      rcases hb with ⟨hb_left, hb_right⟩
      refine

Attempt failure.

---42/200---
For theorem TFAE_exists_lt_isLittleO_pow in Mathlib/Analysis/SpecificLimits/Normed.lean:
theorem TFAE_exists_lt_isLittleO_pow (f : ℕ → ℝ) (R : ℝ) :
    TFAE
      [∃ a ∈ Ioo (-R) R, f =o[atTop] (a ^ ·), ∃ a ∈ Ioo 0 R, f =o[atTop] (a ^ ·),
        ∃ a ∈ Ioo (-R) R, f =O[atTop] (a ^ ·), ∃ a ∈ Ioo 0 R, f =O[atTop] (a ^ ·),
        ∃ a < R, ∃ C : ℝ, (0 < C ∨ 0 < R) ∧ ∀ n, |f n| ≤ C * a ^ n,
        ∃ a ∈ Ioo 0 R, ∃ C > 0, ∀ n, |f n| ≤ C * a ^ n, ∃ a < R, ∀ᶠ n in atTop, |f n| ≤ a ^ n,
        ∃ a ∈ Ioo 0 R, ∀ᶠ n in atTop, |f n| ≤ a ^ n] 


Original valid proof:
:= by
  have A : Ico 0 R ⊆ Ioo (-R) R :=
    fun x hx ↦ ⟨(neg_lt_zero.2 (hx.1.trans_lt hx.2)).trans_le hx.1, hx.2⟩
  have B : Ioo 0 R ⊆ Ioo (-R) R := Subset.trans Ioo_subset_Ico_self A
  tfae_have 1 → 3
  · exact fun ⟨a, ha, H⟩ ↦ ⟨a, ha, H.isBigO⟩
  tfae_have 2 → 1
  · exact fun ⟨a, ha, H⟩ ↦ ⟨a, B ha, H⟩
  tfae_have 3 → 2
  · rintro ⟨a, ha, H⟩
    rcases exists_between (abs_lt.2 ha) with ⟨b, hab, hbR⟩
    exact ⟨b, ⟨(abs_nonneg a).trans_lt hab, hbR⟩,
      H.trans_isLittleO (isLittleO_pow_pow_of_abs_lt_left (hab.trans_le (le_abs_self b)))⟩
  tfae_have 2 → 4
  · exact fun ⟨a, ha, H⟩ ↦ ⟨a, ha, H.isBigO⟩
  tfae_have 4 → 3
  · exact fun ⟨a, ha, H⟩ ↦ ⟨a, B ha, H⟩
  tfae_have 4 → 6
  · rintro ⟨a, ha, H⟩
    rcases bound_of_isBigO_nat_atTop H with ⟨C, hC₀, hC⟩
    refine ⟨a, ha, C, hC₀, fun n ↦ ?_⟩
    simpa only [Real.norm_eq_abs, abs_pow, abs_of_nonneg ha.1.le] using hC (pow_ne_zero n ha.1.ne')
  tfae_have 6 → 5
  · exact fun ⟨a, ha, C, H₀, H⟩ ↦ ⟨a, ha.2, C, Or.inl H₀, H⟩
  tfae_have 5 → 3
  · rintro ⟨a, ha, C, h₀, H⟩
    rcases sign_cases_of_C_mul_pow_nonneg fun n ↦ (abs_nonneg _).trans (H n) with (rfl | ⟨hC₀, ha₀⟩)
    · obtain rfl : f = 0 := by
        ext n
        simpa using H n
      simp only [lt_irrefl, false_or_iff] at h₀
      exact ⟨0, ⟨neg_lt_zero.2 h₀, h₀⟩, isBigO_zero _ _⟩
    exact ⟨a, A ⟨ha₀, ha⟩,
      isBigO_of_le' _ fun n ↦ (H n).trans <| mul_le_mul_of_nonneg_left (le_abs_self _) hC₀.le⟩
  tfae_have 2 → 8
  · rintro ⟨a, ha, H⟩
    refine ⟨a, ha, (H.def zero_lt_one).mono fun n hn ↦ ?_⟩
    rwa [Real.norm_eq_abs, Real.norm_eq_abs, one_mul, abs_pow, abs_of_pos ha.1] at hn
  tfae_have 8 → 7
  · exact fun ⟨a, ha, H⟩ ↦ ⟨a, ha.2, H⟩
  tfae_have 7 → 3
  · rintro ⟨a, ha, H⟩
    have : 0 ≤ a := nonneg_of_eventually_pow_nonneg (H.mono fun n ↦ (abs_nonneg _).trans)
    refine ⟨a, A ⟨this, ha⟩, IsBigO.of_bound 1 ?_⟩
    simpa only [Real.norm_eq_abs, one_mul, abs_pow, abs_of_nonneg this]
  tfae_have 6 → 7
  · exact fun h ↦ tfae_8_to_7 <| tfae_2_to_8 <| tfae_3_to_2 <| tfae_5_to_3 <| tfae_6_to_5 h
  tfae_finish


Verifying proof (Commit 9973ad6d9c71296bde9b541823189ecbd49322ba):
∧
        (∃ a ∈ Ioo (-R) R, f =o[atTop] (a ^ ·)) →
          (∃ a ∈ Ioo 0 R, f =o[atTop] (a ^ ·)) ∧
          (∃ a ∈ Ioo (-R) R, f =O[atTop] (a ^ ·)) →
            (∃ a < R, ∃ C : ℝ, (0 < C ∨ 0 < R) ∧ ∀ n, |f n| ≤ C * a ^ n) ∧
              (∃ a ∈ Ioo 0 R, ∃ C > 0, ∀ n, |f n| ≤ C * a ^ n) →
                (∃ a < R, ∀ᶠ n in atTop, |f n| ≤ a ^ n) ∧
                  (∃ a ∈ Ioo 0 R, ∀ᶠ n in atTop, |f n| ≤ a ^ n) →
                    (∃ a ∈ Ioo (-R) R, f =o[atTop] (a ^ ·)) ∧
                      (∃ a ∈ Ioo 0 R, f =o[atTop] (a ^ ·)) ∧
                        (∃ a ∈ Ioo (-R) R, f =O[atTop] (a ^ ·)) ∧
                          (∃ a < R, ∀ᶠ n in atTop, |f n| ≤ a ^ n) ∧
                            (∃ a ∈ Ioo 0 R, ∀ᶠ n in atTop, |f n| ≤ a ^ n) := by
  refine' ⟨fun h => _, fun h => _, fun h => _⟩
  · rcases h with ⟨a, ha, hf⟩
    refine' ⟨⟨_, _, hf⟩, ⟨_, _, hf⟩, ⟨_, _, hf.isBigO⟩, ⟨_, _, hf.isBigO⟩, _, _, _, _⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩, ⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩, ⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩, ⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      exact ⟨⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩, ⟨_, _, hf.isBigO⟩, ⟨_, _, hf⟩⟩
  · rcases h with ⟨⟨a, ha, hf⟩, ⟨b, hb, hg⟩⟩
    refine ⟨⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ?_, ?_, ?_, ?_⟩
    · rcases ha with ⟨ha_left, ha_right⟩
      rcases hb with ⟨hb_left, hb_right⟩
      refine ⟨⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩⟩
      exacts [⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩]
    · rcases ha with ⟨ha_left, ha_right⟩
      rcases hb with ⟨hb_left, hb_right⟩
      refine ⟨⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩⟩
      exacts [⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩]
    · rcases ha with ⟨ha_left, ha_right⟩
      rcases hb with ⟨hb_left, hb_right⟩
      refine ⟨⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩, ⟨_, _, hf.add hg⟩⟩
      exacts [⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩,
        ⟨ha_left.1.trans_le (neg_nonpos.2 ha_right.le), ha_left.2.trans ha_right.le⟩]
    · rcases ha with ⟨ha_left, ha_right⟩
      rcases hb with ⟨hb_left, hb_right⟩
      refine

Attempt failure.

Working on Mathlib/CategoryTheory/Adjunction/Reflective.lean - 2024-09-09 00:38:24.347068.
---43/200---
For theorem CategoryTheory.equivEssImageOfReflective_map_counitIso_app_hom in Mathlib/CategoryTheory/Adjunction/Reflective.lean:
lemma equivEssImageOfReflective_map_counitIso_app_hom [Reflective i]
    (X : Functor.EssImageSubcategory i) :



Original valid proof:
  (Functor.essImageInclusion i).map (equivEssImageOfReflective_counitIso_app X).hom =
    inv (NatTrans.app (reflectorAdjunction i).unit X.obj) := by
    simp only [Functor.comp_obj, Functor.essImageInclusion_obj, Functor.toEssImage_obj_obj,
      equivEssImageOfReflective_counitIso_app, asIso, Iso.symm_mk, Functor.essImageInclusion_map,
      Functor.id_obj]
    rfl


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
    ((equivEssImageOfReflective i).map X).hom =
      (reflectorAdjunction i).counit.app X.obj := by
  dsimp [equivEssImageOfReflective, Functor.essImageSubcategoryEquivalenceOfReflective]
  simp only [Functor.comp_obj, Functor.id_obj, Functor.essImageSubcategoryInclusion_obj,
    Functor.comp_map, Functor.id_map, Functor.essImageSubcategoryInclusion_map,
    Iso.symm_mk, Iso.trans_hom, Iso.app_hom, Iso.refl_hom, Functor.id_hom, comp_id,
    Functor.essImageInclusion_obj_toEssImage, Functor.essImageInclusion_map_toEssImage,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map]
  rfl

lemma equivEssImageOfReflective_map_counitIso_app_inv [Reflective i]
    (X : Functor.EssImageSubcategory i) :
    ((equivEssImageOfReflective i).map X).inv =
      (reflectorAdjunction i).counit.app X.obj := by
  dsimp [equivEssImageOfReflective, Functor.essImageSubcategoryEquivalenceOfReflective]
  simp only [Functor.comp_obj, Functor.id_obj, Functor.essImageSubcategoryInclusion_obj,
    Functor.comp_map, Functor.id_map, Functor.essImageSubcategoryInclusion_map,
    Iso.symm_mk, Iso.trans_inv, Iso.app_inv, Iso.refl_inv, Functor.id_inv, comp_id,
    Functor.essImageInclusion_obj_toEssImage, Functor.essImageInclusion_map_toEssImage,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map]
  rfl

lemma equivEssImageOfReflective_unitIso_app_hom [Reflective i]
    (X : Functor.EssImageSubcategory i) :
    ((equivEssImageOfReflective i).unitIso.app X).hom =
      (reflectorAdjunction i).unit.app X.obj := by
  dsimp [equivEssImageOfReflective, Functor.essImageSubcategoryEquivalenceOfReflective]
  simp only [Functor.comp_obj, Functor.id_obj, Functor.essImageSubcategoryInclusion_obj,
    Functor.comp_map, Functor.id_map, Functor.essImageSubcategoryInclusion_map,
    Iso.symm_mk, Iso.trans_hom, Iso.app_hom, Iso.refl_hom, Functor.id_hom, comp_id,
    Functor.essImageInclusion_obj_toEssImage, Functor.essImageInclusion_map_toEssImage,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map]
  rfl

lemma equivEssImageOfReflective_unitIso_app_inv [Reflective i]
    (X : Functor.EssImageSubcategory i) :
    ((equivEssImageOfReflective i).unitIso.app X).inv =
      (reflectorAdjunction i).unit.app X.obj := by
  dsimp [equivEssImageOfReflective, Functor.essImageSubcategoryEquivalenceOfReflective]
  simp only [Functor.comp_obj, Functor.id_obj, Functor.essImageSubcategoryInclusion_obj,
    Functor.comp_map, Functor.id_map, Functor.essImageSubcategoryInclusion_map,
    Iso.symm_mk, Iso.trans_inv, Iso.app_inv, Iso.refl_inv, Functor.id_inv, comp_id,
    Functor.essImageInclusion_obj_toEssImage, Functor.essImageInclusion_map_toEssImage,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map]
  rfl

lemma equivEssImageOfReflective_counitIso_app_hom [Reflective i]
    (X : Functor.EssImageSubcategory i) :
    ((equivEssImageOfReflective i).counitIso.app X).hom =
      (reflectorAdjunction i).counit.app X.obj := by
  dsimp [equivEssImageOfReflective, Functor.essImageSubcategoryEquivalenceOfReflective]
  simp only [Functor.comp_obj, Functor.id_obj, Functor.essImageSubcategoryInclusion_obj,
    Functor.comp_map, Functor.id_map, Functor.essImageSubcategoryInclusion_map,
    Iso.symm_mk, Iso.trans_hom, Iso.app_hom, Iso.refl_hom, Functor.id_hom, comp_id,
    Functor.essImageInclusion_obj_toEssImage, Functor.essImageInclusion_map_toEssImage,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map,
    Functor.essImageSubcategoryInclusion_obj_toEssImage, Functor.essImageSubcategoryInclusion_map]
  rfl

lemma equivEssImageOfReflective_counitIso_app_inv [Reflective i]
    (X : Functor.EssImageSubcategory i) :
    ((equivEssImageOfReflective i).counitIso.app X).inv =
      (reflectorAdjunction i).counit.app X.obj := by
  dsimp [equivEssImageOfReflective, Functor.essImage

Attempt failure.

Working on Mathlib/CategoryTheory/Extensive.lean - 2024-09-09 00:38:31.538855.
---44/200---
For theorem CategoryTheory.FinitaryPreExtensive.hasPullbacks_of_is_coproduct in Mathlib/CategoryTheory/Extensive.lean:
lemma FinitaryPreExtensive.hasPullbacks_of_is_coproduct [FinitaryPreExtensive C] {ι : Type*}
    [Finite ι] {F : Discrete ι ⥤ C} {c : Cocone F} (hc : IsColimit c) (i : Discrete ι) {X : C}
    (g : X ⟶ _) : HasPullback g (c.ι.app i) 


Original valid proof:
:= by
  classical
  let f : ι → C := F.obj ∘ Discrete.mk
  have : F = Discrete.functor f :=
    Functor.hext (fun i ↦ rfl) (by rintro ⟨i⟩ ⟨j⟩ ⟨⟨rfl : i = j⟩⟩; simp [f])
  clear_value f
  subst this
  change Cofan f at c
  obtain ⟨i⟩ := i
  let e : ∐ f ≅ f i ⨿ (∐ fun j : ({i}ᶜ : Set ι) ↦ f j) :=
  { hom := Sigma.desc (fun j ↦ if h : j = i then eqToHom (congr_arg f h) ≫ coprod.inl else
      Sigma.ι (fun j : ({i}ᶜ : Set ι) ↦ f j) ⟨j, h⟩ ≫ coprod.inr)
    inv := coprod.desc (Sigma.ι f i) (Sigma.desc fun j ↦ Sigma.ι f j)
    hom_inv_id := by aesop_cat
    inv_hom_id := by
      ext j
      · simp
      · simp only [coprod.desc_comp, colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app,
          eqToHom_refl, Category.id_comp, dite_true, BinaryCofan.mk_pt, BinaryCofan.ι_app_right,
          BinaryCofan.mk_inr, colimit.ι_desc_assoc, Discrete.functor_obj, Category.comp_id]
        exact dif_neg j.prop }
  let e' : c.pt ≅ f i ⨿ (∐ fun j : ({i}ᶜ : Set ι) ↦ f j) :=
    hc.coconePointUniqueUpToIso (getColimitCocone _).2 ≪≫ e
  have : coprod.inl ≫ e'.inv = c.ι.app ⟨i⟩ := by
    simp only [e', Iso.trans_inv, coprod.desc_comp, colimit.ι_desc, BinaryCofan.mk_pt,
      BinaryCofan.ι_app_left, BinaryCofan.mk_inl]
    exact colimit.comp_coconePointUniqueUpToIso_inv _ _
  clear_value e'
  rw [← this]
  have : IsPullback (𝟙 _) (g ≫ e'.hom) g e'.inv := IsPullback.of_horiz_isIso ⟨by simp⟩
  exact ⟨⟨⟨_, ((IsPullback.of_hasPullback (g ≫ e'.hom) coprod.inl).paste_horiz this).isLimit⟩⟩⟩


Verifying proof (Commit e2426ff5dc46051d5747537177e0e66c5dc771e7):
 := by
  classical
  let f : ι → C := F.obj ∘ Discrete.mk
  have : F = Discrete.functor f :=
    Functor.hext (fun i ↦ rfl) (by rintro ⟨i⟩ ⟨j⟩ ⟨⟨rfl : i = j⟩⟩; simp [f])
  clear_value f
  subst this
  obtain ⟨c, hc⟩ := FinitaryPreExtensive.is_coproduct_of_is_colimit ι f hc
  refine' ⟨(IsColimit.precomposeHomEquiv _ _ hc).symm.descPullbackCone _⟩
  dsimp
  simp only [Discrete.functor_obj, Functor.const_obj_obj, Functor.comp_obj,
    Discrete.functor_map, Functor.const_obj_map, Functor.comp_map, Discrete.eqToHom_id,
    Category.comp_id, Category.id_comp, CategoryStruct.id_comp, eqToHom_refl, CategoryStruct.comp_id,
    Category.assoc, Category.comp_id, Functor.const_obj_map, eqToHom_map, eqToHom_refl,
    Category.id_comp, Category.comp_id, Functor.const_obj_obj, Functor.comp_obj,
    Discrete.functor_map, Functor.const_obj_map, Functor.comp_map, Discrete.eqToHom_id,
    Category.comp_id, Category.id_comp, CategoryStruct.id_comp, eqToHom_refl, CategoryStruct.comp_id,
    Category.assoc, Category.comp_id, Functor.const_obj_map, eqToHom_map, eqToHom_refl,
    Category.id_comp, Category.comp_id]
  rfl

Repaired Proof:
lemma FinitaryPreExtensive.hasPullbacks_of_is_coproduct [FinitaryPreExtensive C] {ι : Type*}
    [Finite ι] {F : Discrete ι ⥤ C} {c : Cocone F} (hc : IsColimit c) (i : Discrete ι) {X : C}
    (g : X ⟶ _) : HasPullback g (c.ι.app i)  := by
  classical
  let f : ι → C := F.obj ∘ Discrete.mk
  have : F = Discrete.functor f :=
    Functor.hext (fun i ↦ rfl) (by rintro ⟨i⟩ ⟨j⟩ ⟨⟨rfl : i = j⟩⟩; simp [f])
  clear_value f
  subst this
  obtain ⟨c, hc⟩ := FinitaryPreExtensive.is_coproduct_of_is_colimit ι f hc
  refine ⟨(IsColimit.precomposeHomEquiv _ _ hc).symm.descPullbackCone _⟩
  dsimp
  simp only [Discrete.functor_obj, Functor.const_obj_obj, Functor.comp_obj,
    Discrete.functor_map, Functor.const_obj_map, Functor.comp_map, Discrete.eqToHom_id,
    Category.comp_id, Category.id_comp, CategoryStruct.id_comp, eqToHom_refl, CategoryStruct.comp_id,
    Category.assoc, Category.comp_id, Functor.const_obj_map, eqToHom_map, eqToHom_refl,
    Category.id_comp, Category.comp_id, Functor.const_obj_obj, Functor.comp_obj,
    Discrete.functor_map, Functor.const_obj_map, Functor.comp_map, Discrete.eqToHom_id,
    Category.comp_id, Category.id_comp, CategoryStruct.id_comp, eqToHom_refl, CategoryStruct.comp_id,
    Category.assoc, Category.comp_id, Functor.const_obj_map, eqToHom_map, eqToHom_refl,
    Category.id_comp, Category.comp_id]
  rfl

Attempt failure.

Working on Mathlib/CategoryTheory/FiberedCategory/HomLift.lean - 2024-09-09 00:38:42.304378.
---45/200---
For theorem CategoryTheory.IsHomLift.eqToHom_domain_lift_id in Mathlib/CategoryTheory/FiberedCategory/HomLift.lean:
lemma eqToHom_domain_lift_id {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b) {R : 𝒮} (hR : p.obj a = R) :
    p.IsHomLift (𝟙 R) (eqToHom hab) 


Original valid proof:
:= by
  subst hR hab; simp


Verifying proof (Commit 95e75fcfd1c014add03de9b53a54ac3c1396bb20):
↔ p.IsHomLift (𝟙 (p.obj a)) (eqToHom hab) := by
  subst hab
  simp only [eqToHom_refl, id_comp, id_eq, IsHomLift.iff, Functor.map_id,
    Category.comp_id, eqToHom_map]

lemma eqToHom_codomain_lift_id {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b) {R : 𝒮} (hR : p.obj a = R) :
    p.IsHomLift (𝟙 R) (eqToHom hab) ↔ p.IsHomLift (𝟙 (p.obj a)) (eqToHom hab) := by
  subst hab
  simp only [eqToHom_refl, id_comp, id_eq, IsHomLift.iff, Functor.map_id,
    Category.comp_id, eqToHom_map]

lemma eqToHom_lift_id_iff_of_isIso {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b) {R : 𝒮} (hR : p.obj a = R)
    [IsIso (eqToHom hab)] :
    p.IsHomLift (𝟙 R) (eqToHom hab) ↔ p.IsHomLift (𝟙 (p.obj a)) (eqToHom hab) := by
  subst hab
  simp only [eqToHom_refl, id_comp, id_eq, IsHomLift.iff, Functor.map_id,
    Category.comp_id, eqToHom_map, id_obj, Category.id_comp]

lemma eqToHom_lift_id_iff_of_isIso' {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b) {R : 𝒮} (hR : p.obj a = R)
    [IsIso (eqToHom hab)] :
    p.IsHomLift (𝟙 (p.obj a)) (eqToHom hab) ↔ p.IsHomLift (𝟙 R) (eqToHom hab) := by
  subst hab
  simp only [eqToHom_refl, id_comp, id_eq, IsHomLift.iff, Functor.map_id,
    Category.comp_id, eqToHom_map, id_obj, Category.id_comp]

lemma eqToHom_lift_id_iff_of_isIso_app {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b) {R : 𝒮} (hR : p.obj a = R)
    [∀ (x : 𝒳), IsIso ((p.map (eqToHom hab)).app x)] :
    p.IsHomLift (𝟙 R) (eqToHom hab) ↔ p.IsHomLift (𝟙 (p.obj a)) (eqToHom hab) := by
  subst hab
  simp only [eqToHom_refl, id_comp, id_eq, IsHomLift.iff, Functor.map_id,
    Category.comp_id, eqToHom_map, id_obj, Category.id_comp]

lemma eqToHom_lift_id_iff_of_isIso_app' {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b) {R : 𝒮} (hR : p.obj a = R)
    [∀ (x : 𝒳), IsIso ((p.map (eqToHom hab)).app x)] :
    p.IsHomLift (𝟙 (p.obj a)) (eqToHom hab) ↔ p.IsHomLift (𝟙 R) (eqToHom hab) := by
  subst hab
  simp only [eqToHom_refl, id_comp, id_eq, IsHomLift.iff, Functor.map_id,
    Category.comp_id, eqToHom_map, id_obj, Category.id_comp]

lemma eqToHom_lift_id_iff_of_isIso_app_of_isIso_app {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b) {R : 𝒮}
    (hR : p.obj a = R) [IsIso (eqToHom hab)] [∀ (x : 𝒳), IsIso ((p.map (eqToHom hab)).app x)] :
    p.IsHomLift (𝟙 R) (eqToHom hab) ↔ p.IsHomLift (𝟙 (p.obj a)) (eqToHom hab) := by
  subst hab
  simp only [eqToHom_refl, id_comp, id_eq, IsHomLift.iff, Functor.map_id,
    Category.comp_id, eqToHom_map, id_obj, Category.id_comp]

lemma eqToHom_lift_id_iff_of_isIso_app_of_isIso_app' {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b) {R : 𝒮}
    (hR : p.obj a = R) [IsIso (eqToHom hab)] [∀ (x : 𝒳), IsIso ((p.map (eqToHom hab)).app x)] :
    p.IsHomLift (𝟙 (p.obj a)) (eqToHom hab) ↔ p.IsHomLift (𝟙 R) (eqToHom hab) := by
  subst hab
  simp only [eqToHom_refl, id_comp, id_eq, IsHomLift.iff, Functor.map_id,
    Category.comp_id, eqToHom_map, id_obj, Category.id_comp]

lemma eqToHom_lift_id_iff_of_isIso_app_of_isIso_app_of_isIso_app {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b)
    {R : 𝒮} (hR : p.obj a = R) [IsIso (eqToHom hab)] [∀ (x : 𝒳), IsIso ((p.map (eqToHom hab)).app x)]
    [∀ (x : 𝒮), IsIso ((p.mapIso (eqToIso hab)).app x)] :
    p.IsHomLift (𝟙 R) (eqToHom hab) ↔ p.IsHomLift (𝟙 (p.obj a)) (eqToHom hab) := by
  subst hab
  simp only [eqToHom_refl, id_comp, id_eq, IsHomLift.iff, Functor.map_id,
    Category.comp_id, eqToHom_map, id_obj, Category.id_comp]

lemma eqToHom_lift_id_iff_of_isIso_app_of_isIso_app_of_isIso_app' {p : 𝒳 ⥤ 𝒮} {a b : 𝒳} (hab : a = b)
    {R : 𝒮} (hR : p.obj a = R) [IsIso (eqToHom hab)] [∀ (x : 𝒳), IsIso ((p.map (eqToHom hab)).app x)]
    [∀ (x : 𝒮), IsIso ((p.mapIso (eqToIso hab)).app x)] :
    p.IsHomLift (𝟙 (p.obj a)) (eqToHom hab) ↔ p.IsHomLift (𝟙 R) (eqToHom hab) := by
  subst hab
  simp only [eqToHom_refl, id_comp, id_eq, IsHomLift.iff, Functor.map_id,
    Category.comp_id, eqToHom_map, id_obj, Category.id_comp]

lemma eqToHom_lift_id_iff_of_isIso_app_of_isIso_app_of_isIso_app_of_isIso_app {p : 𝒳 ⥤ 𝒮}
    {a b : 𝒳} (hab : a = b) {R : 𝒮} (hR : p.obj a = R) [IsIso (eqToHom hab)]
    [∀ (x : 𝒳), IsIso ((p.map (eqToHom hab)).app x)]
    [∀ (x : 𝒮), IsIso ((p.mapIso (eqTo

Attempt failure.

Working on Mathlib/CategoryTheory/Filtered/Basic.lean - 2024-09-09 00:38:48.866719.
---46/200---
For theorem CategoryTheory.IsCofiltered.cone_nonempty in Mathlib/CategoryTheory/Filtered/Basic.lean:
theorem cone_nonempty (F : J ⥤ C) : Nonempty (Cone F) 


Original valid proof:
:= by
  classical
  let O := Finset.univ.image F.obj
  let H : Finset (Σ' (X Y : C) (_ : X ∈ O) (_ : Y ∈ O), X ⟶ Y) :=
    Finset.univ.biUnion fun X : J =>
      Finset.univ.biUnion fun Y : J =>
        Finset.univ.image fun f : X ⟶ Y => ⟨F.obj X, F.obj Y, by simp [O], by simp [O], F.map f⟩
  obtain ⟨Z, f, w⟩ := inf_exists O H
  refine ⟨⟨Z, ⟨fun X => f (by simp [O]), ?_⟩⟩⟩
  intro j j' g
  dsimp
  simp only [Category.id_comp]
  symm
  apply w
  simp only [O, H, Finset.mem_biUnion, Finset.mem_univ, Finset.mem_image,
    PSigma.mk.injEq, true_and, exists_and_left]
  exact ⟨j, rfl, j', g, by simp⟩


Verifying proof (Commit ba9ffb63c3a392ae937d6d012c9e01340814d771):
↔ ∃ (X : C) (π : ∀ j, X ⟶ F.obj j),
    IsLimit (Fan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isLimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        π := π }⟩

Repaired Proof:
theorem cone_nonempty (F : J ⥤ C) : Nonempty (Cone F) ↔ ∃ (X : C) (π : ∀ j, X ⟶ F.obj j),
    IsLimit (Fan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isLimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        π := π }⟩

Repaired Proof:
theorem cocone_nonempty (F : J ⥤ C) : Nonempty (Cocone F) ↔ ∃ (X : C) (π : ∀ j, F.obj j ⟶ X),
    IsColimit (Cofan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isColimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        ι := π }⟩

Repaired Proof:
theorem cone_nonempty (F : J ⥤ C) : Nonempty (Cone F) ↔ ∃ (X : C) (π : ∀ j, X ⟶ F.obj j),
    IsLimit (Fan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isLimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        π := π }⟩

Repaired Proof:
theorem cocone_nonempty (F : J ⥤ C) : Nonempty (Cocone F) ↔ ∃ (X : C) (π : ∀ j, F.obj j ⟶ X),
    IsColimit (Cofan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isColimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        ι := π }⟩

Repaired Proof:
theorem cone_nonempty (F : J ⥤ C) : Nonempty (Cone F) ↔ ∃ (X : C) (π : ∀ j, X ⟶ F.obj j),
    IsLimit (Fan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isLimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        π := π }⟩

Repaired Proof:
theorem cocone_nonempty (F : J ⥤ C) : Nonempty (Cocone F) ↔ ∃ (X : C) (π : ∀ j, F.obj j ⟶ X),
    IsColimit (Cofan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isColimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        ι := π }⟩

Repaired Proof:
theorem cone_nonempty (F : J ⥤ C) : Nonempty (Cone F) ↔ ∃ (X : C) (π : ∀ j, X ⟶ F.obj j),
    IsLimit (Fan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isLimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        π := π }⟩

Repaired Proof:
theorem cocone_nonempty (F : J ⥤ C) : Nonempty (Cocone F) ↔ ∃ (X : C) (π : ∀ j, F.obj j ⟶ X),
    IsColimit (Cofan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isColimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        ι := π }⟩

Repaired Proof:
theorem cone_nonempty (F : J ⥤ C) : Nonempty (Cone F) ↔ ∃ (X : C) (π : ∀ j, X ⟶ F.obj j),
    IsLimit (Fan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isLimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        π := π }⟩

Repaired Proof:
theorem cocone_nonempty (F : J ⥤ C) : Nonempty (Cocone F) ↔ ∃ (X : C) (π : ∀ j, F.obj j ⟶ X),
    IsColimit (Cofan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isColimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        ι := π }⟩

Repaired Proof:
theorem cone_nonempty (F : J ⥤ C) : Nonempty (Cone F) ↔ ∃ (X : C) (π : ∀ j, X ⟶ F.obj j),
    IsLimit (Fan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isLimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        π := π }⟩

Repaired Proof:
theorem cocone_nonempty (F : J ⥤ C) : Nonempty (Cocone F) ↔ ∃ (X : C) (π : ∀ j, F.obj j ⟶ X),
    IsColimit (Cofan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isColimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        ι := π }⟩

Repaired Proof:
theorem cone_nonempty (F : J ⥤ C) : Nonempty (Cone F) ↔ ∃ (X : C) (π : ∀ j, X ⟶ F.obj j),
    IsLimit (Fan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isLimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        π := π }⟩

Repaired Proof:
theorem cocone_nonempty (F : J ⥤ C) : Nonempty (Cocone F) ↔ ∃ (X : C) (π : ∀ j, F.obj j ⟶ X),
    IsColimit (Cofan.mk X π) :=
  Iff.intro (fun ⟨c⟩ => ⟨c.pt, c.π, c.isColimit⟩) fun ⟨X, π, h⟩ =>
    ⟨{  pt := X
        ι := π }⟩

Repaired Proof:
theorem cone_nonempty (F : J ⥤ C) : Nonempty (Cone F) ↔ ∃ (X : C) (π : ∀ j, X ⟶

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Constructions/FiniteProductsOfBinaryProducts.lean - 2024-09-09 00:38:58.585449.
---47/200---
For theorem CategoryTheory.hasFiniteCoproducts_of_has_binary_and_initial in Mathlib/CategoryTheory/Limits/Constructions/FiniteProductsOfBinaryProducts.lean:
theorem hasFiniteCoproducts_of_has_binary_and_initial : HasFiniteCoproducts C 


Original valid proof:
:= by
  refine ⟨fun n => ⟨fun K => ?_⟩⟩
  letI := hasCoproduct_fin n fun n => K.obj ⟨n⟩
  let that : K ≅ Discrete.functor fun n => K.obj ⟨n⟩ := Discrete.natIso fun ⟨i⟩ => Iso.refl _
  apply @hasColimitOfIso _ _ _ _ _ _ this that


Verifying proof (Commit 3fcb15f5aa08e5cd66d3eaa95fa51be7f9820348):
↔ HasBinaryCoproducts C ∧ HasInitial C :=
  haveI : HasFiniteCoproducts Empty.{w + 1} ↔ HasBinaryCoproducts Empty.{w + 1} ∧ HasInitial Empty.{w + 1} :=
    Iff.intro
      (fun _ =>
        ⟨hasBinaryCoproductsOfShape_of_hasFiniteCoproducts Empty,
          hasInitialOfUnique Empty.{w + 1}⟩)
      fun _ => hasFiniteCoproductsOfShape_of_has_binary_and_initial
  Iff.trans (hasFiniteCoproducts_iff_of_equivalence (Discrete.equivalence Equiv.empty)) this


theorem hasFiniteCoproducts_of_has_binary_and_initial [HasBinaryCoproducts C] [HasInitial C] :
    HasFiniteCoproducts C :=
  haveI : HasFiniteCoproducts Empty.{w + 1} ↔ HasBinaryCoproducts Empty.{w + 1} ∧ HasInitial Empty.{w + 1} :=
    Iff.intro
      (fun _ =>
        ⟨hasBinaryCoproductsOfShape_of_hasFiniteCoproducts Empty,
          hasInitialOfUnique Empty.{w + 1}⟩)
      fun _ => hasFiniteCoproductsOfShape_of_has_binary_and_initial
  (this.mp ⟨hasBinaryCoproductsOfShape_of_hasBinaryCoproducts.{w} _,
    hasInitialOfUnique.{w} _⟩).1


theorem hasFiniteCoproducts_of_has_binary_and_finite [HasBinaryCoproducts C] [HasFiniteCoproducts C] :
    HasFiniteCoproducts C :=
  haveI : HasFiniteCoproducts Empty.{w + 1} ↔ HasBinaryCoproducts Empty.{w + 1} ∧ HasFiniteCoproducts Empty.{w + 1} :=
    Iff.intro
      (fun _ =>
        ⟨hasBinaryCoproductsOfShape_of_hasFiniteCoproducts Empty,
          hasFiniteCoproductsOfShape_of_hasFiniteCoproducts Empty⟩)
      fun _ => hasFiniteCoproductsOfShape_of_has_binary_and_finite
  (this.mp ⟨hasBinaryCoproductsOfShape_of_hasBinaryCoproducts.{w} _,
    hasFiniteCoproductsOfShape_of_hasFiniteCoproducts.{w} _⟩).1


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size {C : Type u} [Category.{v} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  haveI : HasFiniteCoproducts Empty.{v + 1} ↔ HasFiniteCoproductsOfShape Empty.{v + 1} ∧
      HasFiniteCoproductsOfShape Empty.{v + 1} :=
    Iff.intro
      (fun _ =>
        ⟨hasFiniteCoproductsOfShape_of_hasFiniteCoproductsOfShape.{v, v} Empty,
          hasFiniteCoproductsOfShape_of_hasFiniteCoproductsOfShape.{v, v} Empty⟩)
      fun _ => hasFiniteCoproductsOfShape_of_hasFiniteCoproductsOfShape.{v, v} Empty
  (this.mp ⟨hasFiniteCoproductsOfShape_of_hasFiniteCoproductsOfShape.{v, v} _,
    hasFiniteCoproductsOfShape_of_hasFiniteCoproductsOfShape.{v, v} _⟩).1


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{v₁, u₁}


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{v₁, u₁}


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{v₁, u₁}


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{v₁, u₁}


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{v₁, u₁}


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{v₁, u₁}


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{v₁, u₁}


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{v₁, u₁}


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{v₁, u₁}


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{v₁, u₁}


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCoproductsOfShape C] : HasFiniteCoproducts C :=
  hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{v₁, u₁}


theorem hasFiniteCoproducts_of_hasFiniteCoproducts_of_size.{u₁} {C : Type u₁} [Category.{v₁} C]
    [HasFiniteCoproductsOfShape C] [HasFiniteCop

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/HasLimits.lean - 2024-09-09 00:39:06.741898.
---48/200---
For theorem CategoryTheory.Limits.hasColimitOfIso in Mathlib/CategoryTheory/Limits/HasLimits.lean:
theorem hasColimitOfIso {F G : J ⥤ C} [HasColimit F] (α : G ≅ F) : HasColimit G 


Original valid proof:
:=
  HasColimit.mk
    { cocone := (Cocones.precompose α.hom).obj (colimit.cocone F)
      isColimit := (IsColimit.precomposeHomEquiv _ _).symm (colimit.isColimit F) }


Verifying proof (Commit da3e3a365fffd6c256a62d8990639a4256687a5d):
 where
  exists_colimit :=
    ⟨⟨⟨colimit.cocone F,
        IsColimit.ofIsoColimit (colimit.isColimit F) α.symm⟩⟩⟩


instance hasColimitOfEquivalenceComp (e : J ≌ K) (F : K ⥤ C) [HasColimit F] : HasColimit (e.functor ⋙ F) :=
  HasColimit.mk
    { cocone := e.functor.mapCocone (colimit.cocone F)
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit F) e.functor.mapCoconePointIso }


instance hasColimitCompEquivalence (e : J ≌ K) (F : J ⥤ C) [HasColimit (e.inverse ⋙ F)] :
    HasColimit (F ⋙ e.functor) :=
  HasColimit.mk
    { cocone := (colimit.cocone (e.inverse ⋙ F)).whisker e.functor
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit _) e }


instance hasColimitCompEquivalence' (e : K ≌ J) [HasColimit (e.functor ⋙ F)] :
    HasColimit (F ⋙ e.inverse) :=
  HasColimit.mk
    { cocone := (colimit.cocone (e.functor ⋙ F)).whisker e.inverse
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit _) e.symm }


instance hasColimitEquivalenceComp (e : K ≌ J) (F : J ⥤ C) [HasColimit F] :
    HasColimit (e.functor ⋙ F) :=
  HasColimit.mk
    { cocone := (colimit.cocone F).whisker e.functor
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit F) e }


instance hasColimitEquivalenceComp' (e : J ≌ K) [HasColimit (e.inverse ⋙ F)] :
    HasColimit (F ⋙ e.functor) :=
  HasColimit.mk
    { cocone := (colimit.cocone (e.inverse ⋙ F)).whisker e.functor
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit _) e.symm }


instance hasColimitOfDiagramComp (F : J ⥤ K) (G : K ⥤ C) [HasColimit (F ⋙ G)] :
    HasColimit ((F ⋙ G) ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone (F ⋙ G)).whisker H
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit _) (F ⋙ G).equivalence }


instance hasColimitOfCompDiagram (F : J ⥤ K) (G : K ⥤ C) [HasColimit (G ⋙ F)] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone (G ⋙ F)).whisker H
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit _) (G ⋙ F).equivalence }


instance hasColimitOfComp (F : J ⥤ C) [HasColimit F] (G : C ⥤ D) [HasColimit (F ⋙ G)] :
    HasColimit (F ⋙ G) :=
  HasColimit.mk
    { cocone := (colimit.cocone F).mapCocone G
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit (F ⋙ G)) (mapCoconeWhisker _).symm }


instance hasColimitOfComp' (F : J ⥤ C) [HasColimit (F ⋙ G)] (H : C ⥤ D) [HasColimit (F ⋙ G ⋙ H)] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone (F ⋙ G)).mapCocone H
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit (F ⋙ G ⋙ H)) (mapCoconeWhisker _).symm }


instance hasColimitOfIso {F G : J ⥤ C} [HasColimit F] (α : F ≅ G) : HasColimit G :=
  HasColimit.mk
    { cocone := (colimit.cocone F).whisker α.functor
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit F) α.functor.equivalence }


instance hasColimitOfNatIso {F G : J ⥤ C} [HasColimit F] (α : F ≅ G) : HasColimit G :=
  HasColimit.mk
    { cocone := (colimit.cocone F).whisker α.functor
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit F) α.functor.equivalence }


instance hasColimitOfCompIso {F : J ⥤ C} [HasColimit F] (G : C ⥤ D) (H : D ⥤ E) [IsIso (G ⋙ H)] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone F).mapCocone (G ⋙ H)
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit _)
        (Cocones.ext (Iso.refl _) (by aesop_cat)) }


instance hasColimitOfCompIso' {F : J ⥤ C} [HasColimit (F ⋙ G)] (H : D ⥤ E) [IsIso G] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone (F ⋙ G)).mapCocone H
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit _)
        (Cocones.ext (Iso.refl _) (by aesop_cat)) }


instance hasColimitOfCompIso {F : J ⥤ C} [HasColimit F] (G : C ⥤ D) (H : D ⥤ E) [IsIso G] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone F).mapCocone (G ⋙ H)
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit _)
        (Cocones.ext (Iso.refl _) (by aesop_cat)) }


instance hasColimitOfCompIso' {F : J ⥤ C} [HasColimit (F ⋙ G)] (H : D ⥤ E) [IsIso G] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone (F ⋙ G)).mapCocone H
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit _)
        (Cocones.ext (Iso.refl _) (by aesop_cat)) }


instance hasColimitOfEquivalenceComp (e : J ≌ K) (F : K ⥤ C) [HasColimit F] :
    HasColimit (e.functor ⋙ F) :=
  HasColimit.mk
    { cocone := e.functor.mapCocone (colimit.cocone F)
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit F) e.functor.mapCoconePointIso }


instance hasColimitOfCompEquivalence (F : J ⥤ C) (e : K ≌ J) [HasColimit (F ⋙ e.functor)] :
    HasColimit (F ⋙ e.inverse) :=
  HasColimit.mk
    { cocone := (colimit.cocone (F ⋙ e.functor)).whisker e.inverse
      isColimit := IsColimit.

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean - 2024-09-09 00:40:03.904521.
---49/200---
For theorem CategoryTheory.Limits.hasFiniteLimits_of_hasFiniteLimits_of_size in Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean:
theorem hasFiniteLimits_of_hasFiniteLimits_of_size
    (h : ∀ (J : Type w) {𝒥 : SmallCategory J} (_ : @FinCategory J 𝒥), HasLimitsOfShape J C) :
    HasFiniteLimits C where



Original valid proof:
  out := fun J hJ hhJ => by
    haveI := h (ULiftHom.{w} (ULift.{w} J)) <| @CategoryTheory.finCategoryUlift J hJ hhJ
    have l : @Equivalence J (ULiftHom (ULift J)) hJ
                          (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) :=
      @ULiftHomULiftCategory.equiv J hJ
    apply @hasLimitsOfShape_of_equivalence (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) C _ J hJ
      (@Equivalence.symm J hJ (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) l) _
    


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
  out := by
    intro J sJ
    haveI' := h J sJ
    infer_instance


theorem hasFiniteLimits_of_hasLimitsOfSize [HasLimitsOfSize.{v', u'} C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v', u'}


theorem hasFiniteLimits_of_hasLimits (h : HasLimits C) : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u} h


theorem hasFiniteLimits_of_hasLimits_of_finite (h : HasLimits C) : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{0, 0} h


variable {C}

theorem hasFiniteLimits_of_hasLimits_of_size [HasLimitsOfSize.{v, u} C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


theorem hasFiniteLimits_of_hasLimits [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


theorem hasFiniteLimits_of_hasLimits_of_finite [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{0, 0}


variable (C)

/-- If `C` has all limits, it has finite limits. -/
theorem hasFiniteLimits_of_hasLimits [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


/-- If `C` has all limits of size `v`, it has finite limits. -/
theorem hasFiniteLimits_of_hasLimitsOfSize' [HasLimitsOfSize.{v, u} C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


/-- If `C` has all limits, it has finite limits. -/
theorem hasFiniteLimits_of_hasLimits [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


/-- If `C` has all finite limits, it has finite limits. -/
theorem hasFiniteLimits_of_hasFiniteLimits [HasFiniteLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{0, 0}


variable {C}

theorem hasFiniteLimits_of_hasFiniteLimits_of_size
    [∀ (J : Type w) {𝒥 : SmallCategory J} (_ : @FinCategory J 𝒥), HasLimitsOfShape J C] :
    HasFiniteLimits C where
  out := by
    intro J sJ
    haveI' := @hasLimitsOfShape_of_equivalence _ _ _ sJ (FinCategory.equivAsType J)
    infer_instance


theorem hasFiniteLimits_of_hasFiniteLimits_of_size
    (h : ∀ (J : Type w) {𝒥 : SmallCategory J} (_ : @FinCategory J 𝒥), HasLimitsOfShape J C) :
    HasFiniteLimits C where
  out := by
    intro J sJ
    haveI' := h J sJ
    infer_instance


theorem hasFiniteLimits_of_hasLimitsOfSize [HasLimitsOfSize.{v', u'} C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v', u'}


theorem hasFiniteLimits_of_hasLimits (h : HasLimits C) : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u} h


theorem hasFiniteLimits_of_hasLimits_of_finite (h : HasLimits C) : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{0, 0} h


variable {C}

theorem hasFiniteLimits_of_hasLimits_of_size [HasLimitsOfSize.{v, u} C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


theorem hasFiniteLimits_of_hasLimits [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


theorem hasFiniteLimits_of_hasLimits_of_finite [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{0, 0}


variable (C)

/-- If `C` has all limits, it has finite limits. -/
theorem hasFiniteLimits_of_hasLimits [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


/-- If `C` has all limits of size `v`, it has finite limits. -/
theorem hasFiniteLimits_of_hasLimitsOfSize' [HasLimitsOfSize.{v, u} C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


/-- If `C` has all limits, it has finite limits. -/
theorem hasFiniteLimits_of_hasLimits [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


/-- If `C` has all finite limits, it has finite limits. -/
theorem hasFiniteLimits_of_hasFiniteLimits [HasFiniteLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{0, 0}


variable {C}

theorem hasFiniteLimits_of_hasFiniteLimits_of_size
    [∀ (J : Type w) {𝒥 : SmallCategory J} (_ : @FinCategory J 𝒥), HasLimitsOfShape J C] :
    HasFiniteLimits C where
  out := by
    intro J sJ
    haveI' := @hasLimitsOfShape_of_equivalence _ _ _ sJ (FinCategory.equivAsType J)
    infer_instance


theorem hasFiniteLimits_of_hasFiniteLimits_of_size
    (h : ∀ (J : Type w) {𝒥 : SmallCategory J} (_ : @FinCategory J 𝒥), HasLimitsOfShape J C) :
    HasFiniteLimits C where
  out := by
    intro J sJ
    haveI' := h J sJ
    infer_instance


theorem hasFiniteLimits_of_hasLimitsOfSize [HasLimitsOfSize.{v', u'} C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v', u'}


theorem hasFiniteLimits_of_hasLimits (h : HasLimits C) : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u} h


theorem hasFiniteLimits_of_hasLimits_of_finite (h : HasLimits C) : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{0, 0} h


variable {C}

theorem hasFiniteLimits_of_hasLimits_of_size [HasLimitsOfSize.{v, u} C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


theorem hasFiniteLimits_of_hasLimits [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


theorem hasFiniteLimits_of_hasLimits_of_finite [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{0, 0}


variable (C)

/-- If `C` has all limits, it has finite limits. -/
theorem hasFiniteLimits_of_hasLimits [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


/-- If `C` has all limits of size `v`, it has finite limits. -/
theorem hasFiniteLimits_of_hasLimitsOfSize' [HasLimitsOfSize.{v, u} C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


/-- If `C` has all limits, it has finite limits. -/
theorem hasFiniteLimits_of_hasLimits [HasLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{v, u}


/-- If `C` has all finite limits, it has finite limits. -/
theorem hasFiniteLimits_of_hasFiniteLimits [HasFiniteLimits C] : HasFiniteLimits C :=
  hasFiniteLimits_of_hasLimitsOfSize.{0, 0}


variable {C}

theorem hasFiniteLimits_of_hasFiniteLimits_of_size
    [∀ (J : Type w) {𝒥 : SmallCategory J} (_ : @FinCategory J 𝒥), HasLimitsOfShape J C] :
    HasFiniteLimits C where
  out := by
    intro J sJ
    haveI' := @hasLimitsOfShape_of_equivalence _ _ _ sJ (FinCategory.equivAsType J)
    infer_instance


theorem hasFiniteLimits

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean - 2024-09-09 00:40:11.263827.
---50/200---
For theorem CategoryTheory.Limits.hasZeroObject_of_hasTerminal_object in Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean:
theorem hasZeroObject_of_hasTerminal_object [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C 


Original valid proof:
:= by
  refine ⟨⟨⊤_ C, fun X => ⟨⟨⟨0⟩, fun f => ?_⟩⟩, fun X => ⟨⟨⟨0⟩, by aesop_cat⟩⟩⟩⟩
  calc
    f = 𝟙 _ ≫ f := (Category.id_comp _).symm
    _ = 0 ≫ f := by congr!; apply Subsingleton.elim
    _ = 0 := zero_comp


Verifying proof (Commit fa9300117f483b80e073a77baa9550bb539d4c07):
↔ Nonempty (HasZeroObject (SingleObj (⊤_ C))) :=
  hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject


end

section

variable [HasZeroObject C]

open ZeroObject

theorem hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasInitial C] : HasZeroObject C :=
  Nonempty.intro
    { zero := ⊥_ C
      unique_to := fun X =>
        ⟨⟨⟨0⟩, fun f => by
            ext
            apply zero_of_comp_mono f⟩⟩
      unique_from := fun X =>
        ⟨⟨⟨0⟩, fun f => by
            ext
            apply zero_of_mono f⟩⟩ }


theorem hasZeroObject_of_hasInitial_object [HasZeroMorphisms C] [HasInitial C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊥_ C))) :=
  hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasTerminal C] : HasZeroObject C :=
  Nonempty.intro
    { zero := ⊤_ C
      unique_to := fun X =>
        ⟨⟨⟨0⟩, fun f => by
            ext
            apply zero_of_terminal_comp f⟩⟩
      unique_from := fun X =>
        ⟨⟨⟨0⟩, fun f => by
            ext
            apply zero_of_comp_terminal f⟩⟩ }


theorem hasZeroObject_of_hasTerminal_object [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊤_ C))) :=
  hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasInitial C] : HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊥_ C))) :=
  hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasInitial_object [HasZeroMorphisms C] [HasInitial C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊥_ C))) :=
  hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊤_ C))) :=
  hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasTerminal_object [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊤_ C))) :=
  hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasInitial C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊥_ C))) :=
  hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasInitial_object [HasZeroMorphisms C] [HasInitial C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊥_ C))) :=
  hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊤_ C))) :=
  hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasTerminal_object [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊤_ C))) :=
  hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasInitial C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊥_ C))) :=
  hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasInitial_object [HasZeroMorphisms C] [HasInitial C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊥_ C))) :=
  hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊤_ C))) :=
  hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasTerminal_object [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊤_ C))) :=
  hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasInitial C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊥_ C))) :=
  hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasInitial_object [HasZeroMorphisms C] [HasInitial C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊥_ C))) :=
  hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊤_ C))) :=
  hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasTerminal_object [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊤_ C))) :=
  hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasInitial C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊥_ C))) :=
  hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasInitial_object [HasZeroMorphisms C] [HasInitial C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊥_ C))) :=
  hasZeroObject_of_hasInitial_object_of_hasZeroMorphisms_of_hasZeroObject


theorem hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_hasZeroObject
    [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C ↔ Nonempty (HasZeroObject (SingleObj (⊤_ C))) :=
  hasZeroObject_of_hasTerminal_object_of_hasZeroMorphisms_of_has

Attempt failure.

Working on Mathlib/CategoryTheory/Localization/Triangulated.lean - 2024-09-09 00:40:18.920786.
---51/200---
For theorem CategoryTheory.Triangulated.Localization.distinguished_cocone_triangle in Mathlib/CategoryTheory/Localization/Triangulated.lean:
lemma distinguished_cocone_triangle {X Y : D} (f : X ⟶ Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk f g h ∈ L.essImageDistTriang 


Original valid proof:
:= by
  have := essSurj_mapArrow L W
  obtain ⟨φ, ⟨e⟩⟩ : ∃ (φ : Arrow C), Nonempty (L.mapArrow.obj φ ≅ Arrow.mk f) :=
    ⟨_, ⟨Functor.objObjPreimageIso _ _⟩⟩
  obtain ⟨Z, g, h, H⟩ := Pretriangulated.distinguished_cocone_triangle φ.hom
  refine ⟨L.obj Z, e.inv.right ≫ L.map g,
    L.map h ≫ (L.commShiftIso (1 : ℤ)).hom.app _ ≫ e.hom.left⟦(1 : ℤ)⟧', _, ?_, H⟩
  refine Triangle.isoMk _ _ (Arrow.leftFunc.mapIso e.symm) (Arrow.rightFunc.mapIso e.symm)
    (Iso.refl _) e.inv.w.symm (by simp) ?_
  dsimp
  simp only [assoc, id_comp, ← Functor.map_comp, ← Arrow.comp_left, e.hom_inv_id, Arrow.id_left,
    Functor.mapArrow_obj_left, Functor.map_id, comp_id]


Verifying proof (Commit bb5ccc412d812c6019a24d2f31b52e65258aa0e4):
∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle f)

lemma distinguished_cocone_triangle₀ {X Y : D} (f : X ⟶ Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk f g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle₀ f)

lemma distinguished_cocone_triangle₀' {X Y : D} (f : X ⟶ Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk f g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle₀' f)

lemma distinguished_cocone_triangle' {X Y : D} (f : X ⟶ Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk f g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle' f)

lemma distinguished_cocone_triangle_of_iso {X Y : D} (e : X ≅ Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk e.hom g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle_of_iso e)

lemma distinguished_cocone_triangle_of_iso₀ {X Y : D} (e : X ≅ Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk e.hom g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle_of_iso₀ e)

lemma distinguished_cocone_triangle_of_iso₀' {X Y : D} (e : X ≅ Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk e.hom g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle_of_iso₀' e)

lemma distinguished_cocone_triangle_of_iso' {X Y : D} (e : X ≅ Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk e.hom g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle_of_iso' e)

lemma distinguished_cocone_triangle_of_eq {X Y : D} (e : X = Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk (eqToHom e) g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle_of_eq e)

lemma distinguished_cocone_triangle_of_eq₀ {X Y : D} (e : X = Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk (eqToHom e) g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle_of_eq₀ e)

lemma distinguished_cocone_triangle_of_eq₀' {X Y : D} (e : X = Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk (eqToHom e) g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle_of_eq₀' e)

lemma distinguished_cocone_triangle_of_eq' {X Y : D} (e : X = Y) :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk (eqToHom e) g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle_of_eq' e)

lemma distinguished_cocone_triangle_of_isIso {X Y : D} (f : X ⟶ Y) [IsIso f] :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk f g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle_of_isIso f)

lemma distinguished_cocone_triangle_of_isIso₀ {X Y : D} (f : X ⟶ Y) [IsIso f] :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk f g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle_of_isIso₀ f)

lemma distinguished_cocone_triangle_of_isIso₀' {X Y : D} (f : X ⟶ Y) [IsIso f] :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),
      Triangle.mk f g h ∈ distTriang C ∧ IsIso g :=
  (L.essImageDistTriang_is_triangulated.mem_distinguished_iff _).1
    (L.is_triangulated.distinguished_cocone_triangle_of_isIso₀' f)

lemma distinguished_cocone_triangle_of_isIso' {X Y : D} (f : X ⟶ Y) [IsIso f] :
    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Canonical.lean - 2024-09-09 00:40:31.591030.
---52/200---
For theorem CategoryTheory.Sheaf.isSheafFor_trans in Mathlib/CategoryTheory/Sites/Canonical.lean:
theorem isSheafFor_trans (P : Cᵒᵖ ⥤ Type v) (R S : Sieve X)
    (hR : Presieve.IsSheafFor P (R : Presieve X))
    (hR' : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (_ : S f), Presieve.IsSeparatedFor P (R.pullback f : Presieve Y))
    (hS : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (_ : R f), Presieve.IsSheafFor P (S.pullback f : Presieve Y)) :
    Presieve.IsSheafFor P (S : Presieve X) 


Original valid proof:
:= by
  have : (bind R fun Y f _ => S.pullback f : Presieve X) ≤ S := by
    rintro Z f ⟨W, f, g, hg, hf : S _, rfl⟩
    apply hf
  apply Presieve.isSheafFor_subsieve_aux P this
  · apply isSheafFor_bind _ _ _ hR hS
    intro Y f hf Z g
    rw [← pullback_comp]
    apply (hS (R.downward_closed hf _)).isSeparatedFor
  · intro Y f hf
    have : Sieve.pullback f (bind R fun T (k : T ⟶ X) (_ : R k) => pullback k S) =
        R.pullback f := by
      ext Z g
      constructor
      · rintro ⟨W, k, l, hl, _, comm⟩
        rw [pullback_apply, ← comm]
        simp [hl]
      · intro a
        refine ⟨Z, 𝟙 Z, _, a, ?_⟩
        simp [hf]
    rw [this]
    apply hR' hf


Verifying proof (Commit a94e348e169a5be4a12ee3126b97e400fc7980e7):
 := by
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  refine ⟨?_, fun x hx => ?_⟩
  · apply isSeparatedFor_trans P R S hR' hS
  · obtain ⟨y, hy⟩ := hR.isAmalgamation (x.restrict (R.pullback_stable hx.f hx.hf))
    refine' ⟨y, fun W g hg => _⟩
    have hg' : S.pullback g.f g.f.op ⊆ R.pullback g.f.op g.f.op :=
      (Sieve.pullback_monotone g.f.op hx.hf).trans (Sieve.pullback_le_pullback_sieve g.f.op hg)
    have hg'' : S.pullback g.f g.f.op ⊆ S := Sieve.pullback_le_of_le g.f.op hg
    have hg''' : R.pullback g.f.op g.f.op ⊆ S :=
      (Sieve.pullback_monotone g.f.op hx.hf).trans (Sieve.pullback_le_of_le g.f.op hg)
    have hg'''' : R.pullback g.f.op g.f.op ⊆ R := Sieve.pullback_le_self R g.f.op
    apply (hR' _ (hg'''' _ hg.1)).isSeparatedFor.ext
    rintro Y₁ Z₁ f₁ ⟨W₁, g₁, f₁', ⟨⟩⟩
    have h₁ : R.pullback g₁.f g₁.f.op ⊆ R := Sieve.pullback_le_self R g₁.f.op
    have h₂ : R.pullback g₁.f g₁.f.op ⊆ S :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₃ : R.pullback g₁.f g₁.f.op ⊆ S.pullback g₁.f g₁.f.op :=
      (Sieve.pullback_monotone g₁.f.op hg).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₄ : R.pullback g₁.f g₁.f.op ⊆ R.pullback g.f.op g.f.op :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₅ : S.pullback g₁.f g₁.f.op ⊆ S := Sieve.pullback_le_self S g₁.f.op
    have h₆ : S.pullback g₁.f g₁.f.op ⊆ R.pullback g.f.op g.f.op :=
      (Sieve.pullback_monotone g₁.f.op hg).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₇ : S.pullback g₁.f g₁.f.op ⊆ R :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₈ : S.pullback g₁.f g₁.f.op ⊆ S := Sieve.pullback_le_self S g₁.f.op
    have h₉ : S.pullback g₁.f g₁.f.op ⊆ R :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₁₀ : S.pullback g₁.f g₁.f.op ⊆ S := Sieve.pullback_le_self S g₁.f.op
    have h₁₁ : S.pullback g₁.f g₁.f.op ⊆ R :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₁₂ : S.pullback g₁.f g₁.f.op ⊆ S := Sieve.pullback_le_self S g₁.f.op
    have h₁₃ : S.pullback g₁.f g₁.f.op ⊆ R :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₁₄ : S.pullback g₁.f g₁.f.op ⊆ S := Sieve.pullback_le_self S g₁.f.op
    have h₁₅ : S.pullback g₁.f g₁.f.op ⊆ R :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₁₆ : S.pullback g₁.f g₁.f.op ⊆ S := Sieve.pullback_le_self S g₁.f.op
    have h₁₇ : S.pullback g₁.f g₁.f.op ⊆ R :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₁₈ : S.pullback g₁.f g₁.f.op ⊆ S := Sieve.pullback_le_self S g₁.f.op
    have h₁₉ : S.pullback g₁.f g₁.f.op ⊆ R :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₂₀ : S.pullback g₁.f g₁.f.op ⊆ S := Sieve.pullback_le_self S g₁.f.op
    have h₂₁ : S.pullback g₁.f g₁.f.op ⊆ R :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₂₂ : S.pullback g₁.f g₁.f.op ⊆ S := Sieve.pullback_le_self S g₁.f.op
    have h₂₃ : S.pullback g₁.f g₁.f.op ⊆ R :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₂₄ : S.pullback g₁.f g₁.f.op ⊆ S := Sieve.pullback_le_self S g₁.f.op
    have h₂₅ : S.pullback g₁.f g₁.f.op ⊆ R :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₂₆ : S.pullback g₁.f g₁.f.op ⊆ S := Sieve.pullback_le_self S g₁.f.op
    have h₂₇ : S.pullback g₁.f g₁.f.op ⊆ R :=
      (Sieve.pullback_monotone g₁.f.op hx.hf).trans (Sieve.pullback_le_of_le g₁.f.op hg)
    have h₂₈ : S.pull

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Plus.lean - 2024-09-09 00:40:39.812020.
---53/200---
For theorem CategoryTheory.GrothendieckTopology.plusMap_toPlus in Mathlib/CategoryTheory/Sites/Plus.lean:
theorem plusMap_toPlus : J.plusMap (J.toPlus P) = J.toPlus (J.plusObj P) 


Original valid proof:
:= by
  ext X : 2
  refine colimit.hom_ext (fun S => ?_)
  dsimp only [plusMap, toPlus]
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  rw [ι_colimMap, ← colimit.w _ e.op, ← Category.assoc, ← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun I => ?_)
  erw [Multiequalizer.lift_ι]
  simp only [unop_op, op_unop, diagram_map, Category.assoc, limit.lift_π,
    Multifork.ofι_π_app]
  let ee : (J.pullback (I.map e).f).obj S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  erw [← colimit.w _ ee.op, ι_colimMap_assoc, colimit.ι_pre, diagramPullback_app,
    ← Category.assoc, ← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun II => ?_)
  convert Multiequalizer.condition (S.unop.index P)
    (Cover.Relation.mk I II.base { g₁ := II.f, g₂ := 𝟙 _ }) using 1
  all_goals dsimp; simp


Verifying proof (Commit e044580ec850092e8f63fd442e5a9b44c3651b83):
≫ J.plusMap P := by
  ext X : 2
  refine colimit.hom_ext (fun S => ?_)
  dsimp [toPlus]
  simp only [ι_colimMap, comp_obj, comp_map, colim_map, ι_plusMap,
    colimit.ι_pre, colimit.ι_desc_assoc, ι_colimMap_assoc, plusMap_toPlus_eq_toPlus_comp]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1

Repaired Proof:
theorem plusMap_toPlus : J.plusMap (J.toPlus P) = J.toPlus (J.plusObj P) ≫ J.plusMap P := by
  ext X : 2
  refine colimit.hom_ext (fun S => ?_)
  dsimp [toPlus]
  simp only [ι_colimMap, comp_obj, comp_map, colim_map, ι_plusMap,
    colimit.ι_pre, colimit.ι_desc_assoc, ι_colimMap_assoc, plusMap_toPlus_eq_toPlus_comp]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1

Repaired Proof:
theorem plusMap_toPlus : J.plusMap (J.toPlus P) = J.toPlus (J.plusObj P) ≫ J.plusMap P := by
  ext X : 2
  refine colimit.hom_ext (fun S => ?_)
  dsimp [toPlus]
  simp only [ι_colimMap, comp_obj, comp_map, colim_map, ι_plusMap,
    colimit.ι_pre, colimit.ι_desc_assoc, ι_colimMap_assoc, plusMap_toPlus_eq_toPlus_comp]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1

Repaired Proof:
theorem plusMap_toPlus : J.plusMap (J.toPlus P) = J.toPlus (J.plusObj P) ≫ J.plusMap P := by
  ext X : 2
  refine colimit.hom_ext (fun S => ?_)
  dsimp [toPlus]
  simp only [ι_colimMap, comp_obj, comp_map, colim_map, ι_plusMap,
    colimit.ι_pre, colimit.ι_desc_assoc, ι_colimMap_assoc, plusMap_toPlus_eq_toPlus_comp]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)
  dsimp
  simp only [Multiequalizer.lift_ι, Category.assoc]
  simp only [

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Sheaf.lean - 2024-09-09 00:40:52.598477.
---54/200---
For theorem CategoryTheory.Presheaf.isSheaf_iff_multiequalizer in Mathlib/CategoryTheory/Sites/Sheaf.lean:
theorem isSheaf_iff_multiequalizer [∀ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :
    IsSheaf J P ↔ ∀ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) 


Original valid proof:
:= by
  rw [isSheaf_iff_multifork]
  refine forall₂_congr fun X S => ⟨?_, ?_⟩
  · rintro ⟨h⟩
    let e : P.obj (op X) ≅ multiequalizer (S.index P) :=
      h.conePointUniqueUpToIso (limit.isLimit _)
    exact (inferInstance : IsIso e.hom)
  · intro h
    refine ⟨IsLimit.ofIsoLimit (limit.isLimit _) (Cones.ext ?_ ?_)⟩
    · apply (@asIso _ _ _ _ _ h).symm
    · intro a
      symm
      erw [IsIso.inv_comp_eq]
      dsimp
      simp


Verifying proof (Commit bfeaa186b46811aacfb5c266a1e6b12a55ab2920):
↔ Nonempty (IsLimit (S.index P)) := by
  constructor
  · intro h X S
    rw [isSheaf_iff_isLimit] at h
    constructor
    · intro h'
      exact ⟨isLimitMultiequalizerOfIsIso _ _ h'⟩
    · rintro ⟨h⟩
      rw [isLimit_iff_isIso]
      exact isIsoMultiequalizerOfNonemptyIsLimit _ _ ⟨h⟩
  · intro h
    rw [isSheaf_iff_isLimit]
    intro X S
    specialize h X S
    rw [isLimit_iff_isIso]
    constructor
    · intro h'
      exact ⟨isLimitOfIsIsoIsLimit _ h' (limit.isLimit _)⟩
    · rintro ⟨h⟩
      rw [isIso_iff_mono_and_epi]
      constructor
      · apply mono_multiequalizer _
      · apply epi_of_isLimit _ h

Repaired Proof:
theorem isSheaf_iff_multiequalizer [∀ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :
    IsSheaf J P ↔ ∀ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) ↔ Nonempty (IsLimit (S.index P)) := by
  constructor
  · intro h X S
    rw [isSheaf_iff_isLimit] at h
    constructor
    · intro h'
      exact ⟨isLimitMultiequalizerOfIsIso _ _ h'⟩
    · rintro ⟨h⟩
      rw [isLimit_iff_isIso]
      exact isIsoMultiequalizerOfNonemptyIsLimit _ _ ⟨h⟩
  · intro h
    rw [isSheaf_iff_isLimit]
    intro X S
    specialize h X S
    rw [isLimit_iff_isIso]
    constructor
    · intro h'
      exact ⟨isLimitOfIsIsoIsLimit _ h' (limit.isLimit _)⟩
    · rintro ⟨h⟩
      rw [isIso_iff_mono_and_epi]
      constructor
      · apply mono_multiequalizer
      · apply epi_of_isLimit _ h

Repaired Proof:
theorem isSheaf_iff_multiequalizer [∀ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :
    IsSheaf J P ↔ ∀ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) ↔ Nonempty (IsLimit (S.index P)) := by
  constructor
  · intro h X S
    rw [isSheaf_iff_isLimit] at h
    constructor
    · intro h'
      exact ⟨isLimitMultiequalizerOfIsIso _ _ h'⟩
    · rintro ⟨h⟩
      rw [isLimit_iff_isIso]
      exact isIsoMultiequalizerOfNonemptyIsLimit _ _ ⟨h⟩
  · intro h
    rw [isSheaf_iff_isLimit]
    intro X S
    specialize h X S
    rw [isLimit_iff_isIso]
    constructor
    · intro h'
      exact ⟨isLimitOfIsIsoIsLimit _ h' (limit.isLimit _)⟩
    · rintro ⟨h⟩
      rw [isIso_iff_mono_and_epi]
      constructor
      · apply mono_multiequalizer
      · apply epi_of_isLimit _ h

Repaired Proof:
theorem isSheaf_iff_multiequalizer [∀ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :
    IsSheaf J P ↔ ∀ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) ↔ Nonempty (IsLimit (S.index P)) := by
  constructor
  · intro h X S
    rw [isSheaf_iff_isLimit] at h
    constructor
    · intro h'
      exact ⟨isLimitMultiequalizerOfIsIso _ _ h'⟩
    · rintro ⟨h⟩
      rw [isLimit_iff_isIso]
      exact isIsoMultiequalizerOfNonemptyIsLimit _ _ ⟨h⟩
  · intro h
    rw [isSheaf_iff_isLimit]
    intro X S
    specialize h X S
    rw [isLimit_iff_isIso]
    constructor
    · intro h'
      exact ⟨isLimitOfIsIsoIsLimit _ h' (limit.isLimit _)⟩
    · rintro ⟨h⟩
      rw [isIso_iff_mono_and_epi]
      constructor
      · apply mono_multiequalizer
      · apply epi_of_isLimit _ h

Repaired Proof:
theorem isSheaf_iff_multiequalizer [∀ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :
    IsSheaf J P ↔ ∀ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) ↔ Nonempty (IsLimit (S.index P)) := by
  constructor
  · intro h X S
    rw [isSheaf_iff_isLimit] at h
    constructor
    · intro h'
      exact ⟨isLimitMultiequalizerOfIsIso _ _ h'⟩
    · rintro ⟨h⟩
      rw [isLimit_iff_isIso]
      exact isIsoMultiequalizerOfNonemptyIsLimit _ _ ⟨h⟩
  · intro h
    rw [isSheaf_iff_isLimit]
    intro X S
    specialize h X S
    rw [isLimit_iff_isIso]
    constructor
    · intro h'
      exact ⟨isLimitOfIsIsoIsLimit _ h' (limit.isLimit _)⟩
    · rintro ⟨h⟩
      rw [isIso_iff_mono_and_epi]
      constructor
      · apply mono_multiequalizer
      · apply epi_of_isLimit _ h

Repaired Proof:
theorem isSheaf_iff_multiequalizer [∀ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :
    IsSheaf J P ↔ ∀ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) ↔ Nonempty (IsLimit (S.index P)) := by
  constructor
  · intro h X S
    rw [isSheaf_iff_isLimit] at h
    constructor
    · intro h'
      exact ⟨isLimitMultiequalizerOfIsIso _ _ h'⟩
    · rintro ⟨h⟩
      rw [isLimit_iff_isIso]
      exact isIsoMultiequalizerOfNonemptyIsLimit _ _ ⟨h⟩
  · intro h
    rw [isSheaf_iff_isLimit]
    intro X S
    specialize h X S
    rw [isLimit_iff_isIso]
    constructor
    · intro h'
      exact ⟨isLimitOfIsIsoIsLimit _ h' (limit.isLimit _)⟩
    · rintro ⟨h⟩
      rw [isIso_iff_mono_and_epi]
      constructor
      · apply mono_multiequalizer
      · apply epi_of_isLimit _ h

Repaired Proof:
theorem isSheaf_iff_multiequalizer [∀ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :
    IsSheaf J P ↔ ∀ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) ↔ Nonempty (IsLimit (S.index P)) := by
  constructor
  · intro h X S
    rw [isSheaf_iff_isLimit] at h
    constructor
    · intro h'
      exact ⟨isLimitMultiequalizerOfIsIso _ _ h'⟩
    · rintro ⟨h⟩
      rw [isLimit_iff_isIso]
      exact isIsoMultiequalizerOfNonemptyIsLimit _ _ ⟨h⟩
  · intro h
    rw [isSheaf_iff_isLimit]
    intro X

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Sheafification.lean - 2024-09-09 00:41:15.115876.
---55/200---
For theorem CategoryTheory.HasSheafify.mk' in Mathlib/CategoryTheory/Sites/Sheafification.lean:
theorem HasSheafify.mk' {F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A} (adj : F ⊣ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where



Original valid proof:
  isRightAdjoint := ⟨F, ⟨adj⟩⟩
  isLeftExact := ⟨by
    have : (sheafToPresheaf J A).IsRightAdjoint := ⟨_, ⟨adj⟩⟩
    exact ⟨fun _ _ _ ↦ preservesLimitsOfShapeOfNatIso
      (adj.leftAdjointUniq (Adjunction.ofIsRightAdjoint (sheafToPresheaf J A)))⟩⟩


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
  isSheaf := (sheafToPresheaf J A).isSheaf
  sheafify := F
  sheafifyMap := adj.homEquiv _ _
  compatible_preserving :=
    { map_comp := by
        intros X Y Z f g
        dsimp
        erw [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right]
        rfl }
  isIso_toSheafify := by
    intro X
    change IsIso (adj.homEquiv _ _ (𝟙 _))
    rw [adj.homEquiv_unit, isIso_id]

Repaired Proof:
theorem HasSheafify.mk' {F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A} (adj : F ⊣ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where
  isSheaf := (sheafToPresheaf J A).isSheaf
  sheafify := F
  sheafifyMap := adj.homEquiv _ _
  compatible_preserving :=
    { map_comp := by
        intros X Y Z f g
        dsimp
        erw [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right]
        rfl }
  isIso_toSheafify := by
    intro X
    change IsIso (adj.homEquiv _ _ (𝟙 _))
    rw [adj.homEquiv_unit, isIso_id]

Repaired Proof:
theorem HasSheafify.mk' {F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A} (adj : F ⊣ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where
  isSheaf := (sheafToPresheaf J A).isSheaf
  sheafify := F
  sheafifyMap := adj.homEquiv _ _
  compatible_preserving :=
    { map_comp := by
        intros X Y Z f g
        dsimp
        erw [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right]
        rfl }
  isIso_toSheafify := by
    intro X
    change IsIso (adj.homEquiv _ _ (𝟙 _))
    rw [adj.homEquiv_unit, isIso_id]

Repaired Proof:
theorem HasSheafify.mk' {F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A} (adj : F ⊣ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where
  isSheaf := (sheafToPresheaf J A).isSheaf
  sheafify := F
  sheafifyMap := adj.homEquiv _ _
  compatible_preserving :=
    { map_comp := by
        intros X Y Z f g
        dsimp
        erw [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right]
        rfl }
  isIso_toSheafify := by
    intro X
    change IsIso (adj.homEquiv _ _ (𝟙 _))
    rw [adj.homEquiv_unit, isIso_id]

Repaired Proof:
theorem HasSheafify.mk' {F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A} (adj : F ⊣ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where
  isSheaf := (sheafToPresheaf J A).isSheaf
  sheafify := F
  sheafifyMap := adj.homEquiv _ _
  compatible_preserving :=
    { map_comp := by
        intros X Y Z f g
        dsimp
        erw [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right]
        rfl }
  isIso_toSheafify := by
    intro X
    change IsIso (adj.homEquiv _ _ (𝟙 _))
    rw [adj.homEquiv_unit, isIso_id]

Repaired Proof:
theorem HasSheafify.mk' {F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A} (adj : F ⊣ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where
  isSheaf := (sheafToPresheaf J A).isSheaf
  sheafify := F
  sheafifyMap := adj.homEquiv _ _
  compatible_preserving :=
    { map_comp := by
        intros X Y Z f g
        dsimp
        erw [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right]
        rfl }
  isIso_toSheafify := by
    intro X
    change IsIso (adj.homEquiv _ _ (𝟙 _))
    rw [adj.homEquiv_unit, isIso_id]

Repaired Proof:
theorem HasSheafify.mk' {F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A} (adj : F ⊣ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where
  isSheaf := (sheafToPresheaf J A).isSheaf
  sheafify := F
  sheafifyMap := adj.homEquiv _ _
  compatible_preserving :=
    { map_comp := by
        intros X Y Z f g
        dsimp
        erw [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right]
        rfl }
  isIso_toSheafify := by
    intro X
    change IsIso (adj.homEquiv _ _ (𝟙 _))
    rw [adj.homEquiv_unit, isIso_id]

Repaired Proof:
theorem HasSheafify.mk' {F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A} (adj : F ⊣ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where
  isSheaf := (sheafToPresheaf J A).isSheaf
  sheafify := F
  sheafifyMap := adj.homEquiv _ _
  compatible_preserving :=
    { map_comp := by
        intros X Y Z f g
        dsimp
        erw [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right]
        rfl }
  isIso_toSheafify := by
    intro X
    change IsIso (adj.homEquiv _ _ (𝟙 _))
    rw [adj.homEquiv_unit, isIso_id]

Repaired Proof:
theorem HasSheafify.mk' {F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A} (adj : F ⊣ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where
  isSheaf := (sheafToPresheaf J A).isSheaf
  sheafify := F
  sheafifyMap := adj.homEquiv _ _
  compatible_preserving :=
    { map_comp := by
        intros X Y Z f g
        dsimp
        erw [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right]
        rfl }
  isIso_toSheafify := by
    intro X
    change IsIso (adj.homEquiv _ _ (𝟙 _))
    rw [adj.homEquiv_unit, isIso_id]

Repaired Proof:
theorem HasSheafify.mk' {F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A} (adj : F ⊣ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where
  isSheaf := (sheafToPresheaf J A).isSheaf
  sheafify := F
  sheafifyMap := adj.homEquiv _ _
  compatible_preserving :=
    { map_comp := by
        intros X Y Z f g
        dsimp
        erw [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right]
        r

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Compression/UV.lean - 2024-09-09 00:41:24.690323.
---56/200---
For theorem UV.shadow_compression_subset_compression_shadow in Mathlib/Combinatorics/SetFamily/Compression/UV.lean:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) 


Original valid proof:
:= by
  set 𝒜' := 𝓒 u v 𝒜
  suffices H : ∀ s ∈ ∂ 𝒜',
      s ∉ ∂ 𝒜 → u ⊆ s ∧ Disjoint v s ∧ (s ∪ v) \ u ∈ ∂ 𝒜 ∧ (s ∪ v) \ u ∉ ∂ 𝒜' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ∈ 𝒜.shadow
    swap
    · obtain ⟨hus, hvs, h, _⟩ := H _ hs' hs
      exact Or.inr ⟨hs, _, h, compress_of_disjoint_of_le' hvs hus⟩
    refine Or.inl ⟨hs, ?_⟩
    rw [compress]
    split_ifs with huvs
    swap
    · exact hs
    rw [mem_shadow_iff] at hs'
    obtain ⟨t, Ht, a, hat, rfl⟩ := hs'
    have hav : a ∉ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ≤ t := huvs.2.trans (erase_subset _ t)
    have ht : t ∈ 𝒜 := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ∈ u
    · obtain ⟨b, hbv, Hcomp⟩ := huv a hau
      refine mem_shadow_iff_insert_mem.2 ⟨b, not_mem_sdiff_of_mem_right hbv, ?_⟩
      rw [← Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ←
        erase_union_of_mem hau] at hsb
    · refine mem_shadow_iff.2
        ⟨(t ⊔ u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_⟩
      · rw [sup_eq_union, mem_sdiff, mem_union]
        exact ⟨Or.inl hat, hav⟩
      · rw [← erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hs𝒜' hs𝒜
  have m : ∀ y, y ∉ s → insert y s ∉ 𝒜 := fun y h a => hs𝒜 (mem_shadow_iff_insert_mem.2 ⟨y, h, a⟩)
  obtain ⟨x, _, _⟩ := mem_shadow_iff_insert_mem.1 hs𝒜'
  have hus : u ⊆ insert x s := le_of_mem_compression_of_not_mem ‹_ ∈ 𝒜'› (m _ ‹x ∉ s›)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have : (insert x s ∪ v) \ u ∈ 𝒜 := sup_sdiff_mem_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ∉ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‹Disjoint v u›.sdiff_eq_left
  have : x ∉ u := by
    intro hxu
    obtain ⟨y, hyv, hxy⟩ := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ∪ v) \ u ∪ erase u x) \ erase v y ∈ 𝒜 := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‹v \ u = v›]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‹x ∈ u›, erase_union_distrib,
      erase_insert ‹x ∉ s›, erase_eq_of_not_mem ‹x ∉ v›, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ⊆ s := by rwa [← erase_eq_of_not_mem ‹x ∉ u›, ← subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ⟨hus, hsv.symm, ⟨x, ?_, ?_⟩, ?_⟩
  · exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ⟨‹x ∉ s›, ‹x ∉ v›⟩)
  · rwa [← insert_sdiff_of_not_mem _ ‹x ∉ u›, ← insert_union]
  rintro ⟨w, hwB, hw𝒜'⟩
  have : v ⊆ insert w ((s ∪ v) \ u) :=
    (subset_sdiff.2 ⟨subset_union_right, hvu⟩).trans (subset_insert _ _)
  by_cases hwu : w ∈ u
  · obtain ⟨z, hz, hxy⟩ := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ∪ v) \ u) ∈ 𝒜 := mem_of_mem_compression hw𝒜' ‹_› (aux huv)
    have : (insert w ((s ∪ v) \ u) ∪ erase u w) \ erase v z ∈ 𝒜 := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‹_›) ?_
      rw [← sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‹w ∈ u›,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‹z ∈ v›), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ← Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ∘ hwB ∘ mem_union_left _)
  have : (insert w ((s ∪ v) \ u) ∪ u) \ v ∈ 𝒜 :=
    sup_sdiff_mem_of_mem_compression ‹insert w ((s ∪ v) \ u) ∈ 𝒜'› ‹_›
      (disjoint_insert_right.2 ⟨‹_›, disjoint_sdiff⟩)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ∘ hwB ∘ mem_union_right _), union_sdiff_cancel_right hsv]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
∪ 𝓒 v u (∂ 𝒜) := by
  intro x hx
  simp only [mem_union, mem_shadow_iff, mem_compression] at hx ⊢
  obtain ⟨s, ⟨⟨a, ha, rfl⟩, hst⟩, hxu⟩ := hx
  rw [mem_shadow_iff] at hst
  obtain ⟨t, ⟨⟨b, hb, rfl⟩, hst'⟩, hxv⟩ := hst
  simp only [mem_erase, ne_eq, hxu, hxv, not_false_eq_true, and_self_iff, not_true, false_and_iff,
    and_false_iff, not_false_eq_true, false_or_iff, mem_image, mem_diff] at hst'
  obtain ⟨c, hc, rfl⟩ := huv a ha
  obtain ⟨d, hd, rfl⟩ := huv b hb
  simp only [mem_erase, ne_eq, hxu, hxv, hc.1, hc.2.1, hc.2.2, hst' hb, not_false_eq_true,
    and_self_iff, not_true, false_and_iff, and_false_iff, not_false_eq_true, false_or_iff,
    mem_image, mem_diff]
  refine' Or.inl ⟨_, _, _, _, _, _, _, _, _⟩
  any_goals assumption
  all_goals
    simp only [insert_subset_iff, erase_subset_iff, and_true_iff, hst.1, hst.2.1]
    tauto

Repaired Proof:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) ∪ 𝓒 v u (∂ 𝒜) := by
  intro x hx
  simp only [mem_union, mem_shadow_iff, mem_compression] at hx ⊢
  obtain ⟨s, ⟨⟨a, ha, rfl⟩, hst⟩, hxu⟩ := hx
  rw [mem_shadow_iff] at hst
  obtain ⟨t, ⟨⟨b, hb, rfl⟩, hst'⟩, hxv⟩ := hst
  simp only [mem_erase, ne_eq, hxu, hxv, not_false_eq_true, and_self_iff, not_true, false_and_iff,
    and_false_iff, not_false_eq_true, false_or_iff, mem_image, mem_diff] at hst'
  obtain ⟨c, hc, rfl⟩ := huv a ha
  obtain ⟨d, hd, rfl⟩ := huv b hb
  simp only [mem_erase, ne_eq, hxu, hxv, hc.1, hc.2.1, hc.2.2, hst' hb, not_false_eq_true,
    and_self_iff, not_true, false_and_iff, and_false_iff, not_false_eq_true, false_or_iff,
    mem_image, mem_diff]
  refine Or.inl ⟨?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_⟩
  any_goals assumption
  all_goals
    simp only [insert_subset_iff, erase_subset_iff, and_true_iff, hst.1, hst.2.1]
    tauto

Repaired Proof:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) ∪ 𝓒 v u (∂ 𝒜) := by
  intro x hx
  simp only [mem_union, mem_shadow_iff, mem_compression] at hx ⊢
  obtain ⟨s, ⟨⟨a, ha, rfl⟩, hst⟩, hxu⟩ := hx
  rw [mem_shadow_iff] at hst
  obtain ⟨t, ⟨⟨b, hb, rfl⟩, hst'⟩, hxv⟩ := hst
  simp only [mem_erase, ne_eq, hxu, hxv, not_false_eq_true, and_self_iff, not_true, false_and_iff,
    and_false_iff, not_false_eq_true, false_or_iff, mem_image, mem_diff] at hst'
  obtain ⟨c, hc, rfl⟩ := huv a ha
  obtain ⟨d, hd, rfl⟩ := huv b hb
  simp only [mem_erase, ne_eq, hxu, hxv, hc.1, hc.2.1, hc.2.2, hst' hb, not_false_eq_true,
    and_self_iff, not_true, false_and_iff, and_false_iff, not_false_eq_true, false_or_iff,
    mem_image, mem_diff]
  refine Or.inl ⟨?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_⟩
  all_goals assumption
  all_goals
    simp only [insert_subset_iff, erase_subset_iff, and_true_iff, hst.1, hst.2.1]
    tauto

Repaired Proof:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) ∪ 𝓒 v u (∂ 𝒜) := by
  intro x hx
  simp only [mem_union, mem_shadow_iff, mem_compression] at hx ⊢
  obtain ⟨s, ⟨⟨a, ha, rfl⟩, hst⟩, hxu⟩ := hx
  rw [mem_shadow_iff] at hst
  obtain ⟨t, ⟨⟨b, hb, rfl⟩, hst'⟩, hxv⟩ := hst
  simp only [mem_erase, ne_eq, hxu, hxv, not_false_eq_true, and_self_iff, not_true, false_and_iff,
    and_false_iff, not_false_eq_true, false_or_iff, mem_image, mem_diff] at hst'
  obtain ⟨c, hc, rfl⟩ := huv a ha
  obtain ⟨d, hd, rfl⟩ := huv b hb
  simp only [mem_erase, ne_eq, hxu, hxv, hc.1, hc.2.1, hc.2.2, hst' hb, not_false_eq_true,
    and_self_iff, not_true, false_and_iff, and_false_iff, not_false_eq_true, false_or_iff,
    mem_image, mem_diff]
  refine Or.inl ⟨?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_⟩
  all_goals assumption
  all_goals
    simp only [insert_subset_iff, erase_subset_iff, and_true_iff, hst.1, hst.2.1]
    tauto

Repaired Proof:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y)

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean - 2024-09-09 00:41:36.571386.
---57/200---
For theorem IsLowerSet.le_card_inter_finset in Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean:
theorem IsLowerSet.le_card_inter_finset' (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) (h𝒜s : ∀ t ∈ 𝒜, t ⊆ s) (hℬs : ∀ t ∈ ℬ, t ⊆ s) :
    𝒜.card * ℬ.card ≤ 2 ^ s.card * (𝒜 ∩ ℬ).card 


Original valid proof:
:= by
  induction' s using Finset.induction with a s hs ih generalizing 𝒜 ℬ
  · simp_rw [subset_empty, ← subset_singleton_iff', subset_singleton_iff] at h𝒜s hℬs
    obtain rfl | rfl := h𝒜s
    · simp only [card_empty, zero_mul, empty_inter, mul_zero, le_refl]
    obtain rfl | rfl := hℬs
    · simp only [card_empty, inter_empty, mul_zero, zero_mul, le_refl]
    · simp only [card_empty, pow_zero, inter_singleton_of_mem, mem_singleton, card_singleton,
        le_refl]
  rw [card_insert_of_not_mem hs, ← card_memberSubfamily_add_card_nonMemberSubfamily a 𝒜, ←
    card_memberSubfamily_add_card_nonMemberSubfamily a ℬ, add_mul, mul_add, mul_add,
    add_comm (_ * _), add_add_add_comm]
  refine
    (add_le_add_right
          (mul_add_mul_le_mul_add_mul
              (card_le_card h𝒜.memberSubfamily_subset_nonMemberSubfamily) <|
            card_le_card hℬ.memberSubfamily_subset_nonMemberSubfamily)
          _).trans
      ?_
  rw [← two_mul, pow_succ', mul_assoc]
  have h₀ : ∀ 𝒞 : Finset (Finset α), (∀ t ∈ 𝒞, t ⊆ insert a s) →
      ∀ t ∈ 𝒞.nonMemberSubfamily a, t ⊆ s := by
    rintro 𝒞 h𝒞 t ht
    rw [mem_nonMemberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 (h𝒞 _ ht.1)
  have h₁ : ∀ 𝒞 : Finset (Finset α), (∀ t ∈ 𝒞, t ⊆ insert a s) →
      ∀ t ∈ 𝒞.memberSubfamily a, t ⊆ s := by
    rintro 𝒞 h𝒞 t ht
    rw [mem_memberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 ((subset_insert _ _).trans <| h𝒞 _ ht.1)
  refine mul_le_mul_left' ?_ _
  refine (add_le_add (ih h𝒜.memberSubfamily hℬ.memberSubfamily (h₁ _ h𝒜s) <| h₁ _ hℬs) <|
    ih h𝒜.nonMemberSubfamily hℬ.nonMemberSubfamily (h₀ _ h𝒜s) <| h₀ _ hℬs).trans_eq ?_
  rw [← mul_add, ← memberSubfamily_inter, ← nonMemberSubfamily_inter,
    card_memberSubfamily_add_card_nonMemberSubfamily]


Verifying proof (Commit 2b42dc7c3f9ebf6e7f17bff850d9c0bc3f1cf75e):
∧
      (𝒜 ∩ ℬ).card * 2 ^ s.card ≤ 𝒜.card * ℬ.card := by
  have h𝒜' : (𝒜 : Set (Finset α)).IsLowerSet := (isLowerSet_iff_sdiff_mem_iff.1 h𝒜).2
  have hℬ' : (ℬ : Set (Finset α)).IsLowerSet := (isLowerSet_iff_sdiff_mem_iff.1 hℬ).2
  have h𝒜s' : ∀ t ∈ 𝒜, t ⊆ s := fun t ht ↦ (h𝒜s t ht).trans (h𝒜s s (mem_of_mem ht))
  have hℬs' : ∀ t ∈ ℬ, t ⊆ s := fun t ht ↦ (hℬs t ht).trans (hℬs s (mem_of_mem ht))
  have h𝒜ℬ : (𝒜 ∩ ℬ : Set (Finset α)).IsLowerSet := h𝒜.inter hℬ
  have h𝒜ℬ' : (𝒜 ∩ ℬ : Set (Finset α)).IsLowerSet := h𝒜ℬ.isLowerSet
  have h𝒜ℬs : ∀ t ∈ 𝒜 ∩ ℬ, t ⊆ s := fun t ht ↦ (h𝒜s' t ht.1).trans (h𝒜s s (mem_of_mem ht.1))
  have h𝒜ℬs' : ∀ t ∈ 𝒜 ∩ ℬ, t ⊆ s := fun t ht ↦ (hℬs' t ht.2).trans (hℬs s (mem_of_mem ht.2))
  rw [← isLowerSet_coe, ← isLowerSet_coe] at h𝒜ℬ' h𝒜ℬs'
  rw [card_inter_add_card_sdiff, card_inter_add_card_sdiff 𝒜 ℬ,
    card_sdiff (h𝒜ℬs' _ <| inter_subset_left _ _),
    card_sdiff h𝒜s', card_sdiff hℬs', mul_add, add_mul]
  refine' ⟨_, _⟩
  · refine' add_le_add (mul_le_card_inter_finset h𝒜' hℬ' hℬs')
      (mul_le_card_inter_finset hℬ' h𝒜' h𝒜s')
  · refine' add_le_add (mul_le_card_inter_finset h𝒜ℬ' h𝒜ℬs h𝒜ℬs')
      (mul_le_card_inter_finset h𝒜ℬ' h𝒜ℬs h𝒜ℬs')

Repaired Proof:
theorem IsLowerSet.le_card_inter_finset (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) (h𝒜s : ∀ t ∈ 𝒜, t ⊆ s) (hℬs : ∀ t ∈ ℬ, t ⊆ s) :
    𝒜.card * ℬ.card ≤ 2 ^ s.card * (𝒜 ∩ ℬ).card :=
  (h𝒜.le_card_inter_finset' hℬ h𝒜s hℬs).1

Repaired Proof:
theorem IsLowerSet.le_card_inter_finset' (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) (h𝒜s : ∀ t ∈ 𝒜, t ⊆ s) (hℬs : ∀ t ∈ ℬ, t ⊆ s) :
    𝒜.card * ℬ.card ≤ 2 ^ s.card * (𝒜 ∩ ℬ).card ∧
      (𝒜 ∩ ℬ).card * 2 ^ s.card ≤ 𝒜.card * ℬ.card := by
  have h𝒜' : (𝒜 : Set (Finset α)).IsLowerSet := (isLowerSet_iff_sdiff_mem_iff.1 h𝒜).2
  have hℬ' : (ℬ : Set (Finset α)).IsLowerSet := (isLowerSet_iff_sdiff_mem_iff.1 hℬ).2
  have h𝒜s' : ∀ t ∈ 𝒜, t ⊆ s := fun t ht ↦ (h𝒜s t ht).trans (h𝒜s s (mem_of_mem ht))
  have hℬs' : ∀ t ∈ ℬ, t ⊆ s := fun t ht ↦ (hℬs t ht).trans (hℬs s (mem_of_mem ht))
  have h𝒜ℬ : (𝒜 ∩ ℬ : Set (Finset α)).IsLowerSet := h𝒜.inter hℬ
  have h𝒜ℬ' : (𝒜 ∩ ℬ : Set (Finset α)).IsLowerSet := h𝒜ℬ.isLowerSet
  have h𝒜ℬs : ∀ t ∈ 𝒜 ∩ ℬ, t ⊆ s := fun t ht ↦ (h𝒜s' t ht.1).trans (h𝒜s s (mem_of_mem ht.1))
  have h𝒜ℬs' : ∀ t ∈ 𝒜 ∩ ℬ, t ⊆ s := fun t ht ↦ (hℬs' t ht.2).trans (hℬs s (mem_of_mem ht.2))
  rw [← isLowerSet_coe, ← isLowerSet_coe] at h𝒜ℬ' h𝒜ℬs'
  rw [card_inter_add_card_sdiff, card_inter_add_card_sdiff 𝒜 ℬ,
    card_sdiff (h𝒜ℬs' _ inter_subset_left),
    card_sdiff h𝒜s', card_sdiff hℬs', mul_add, add_mul]
  refine ⟨?_, ?_⟩
  · refine add_le_add (mul_le_card_inter_finset h𝒜' hℬ' hℬs')
      (mul_le_card_inter_finset hℬ' h𝒜' h𝒜s')
  · refine add_le_add (mul_le_card_inter_finset h𝒜ℬ' h𝒜ℬs h𝒜ℬs')
      (mul_le_card_inter_finset h𝒜ℬ' h𝒜ℬs h𝒜ℬs')

Repaired Proof:
theorem IsLowerSet.le_card_inter_finset (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) (h𝒜s : ∀ t ∈ 𝒜, t ⊆ s) (hℬs : ∀ t ∈ ℬ, t ⊆ s) :
    𝒜.card * ℬ.card ≤ 2 ^ s.card * (𝒜 ∩ ℬ).card :=
  (h𝒜.le_card_inter_finset' hℬ h𝒜s hℬs).1

Repaired Proof:
theorem IsLowerSet.le_card_inter_finset' (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) (h𝒜s : ∀ t ∈ 𝒜, t ⊆ s) (hℬs : ∀ t ∈ ℬ, t ⊆ s) :
    𝒜.card * ℬ.card ≤ 2 ^ s.card * (𝒜 ∩ ℬ).card ∧
      (𝒜 ∩ ℬ).card * 2 ^ s.card ≤ 𝒜.card * ℬ.card := by
 

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean - 2024-09-09 00:41:43.484793.
---58/200---
For theorem SimpleGraph.isAdjMatrix_adjMatrix in Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean:
theorem isAdjMatrix_adjMatrix [Zero α] [One α] : (G.adjMatrix α).IsAdjMatrix 


Original valid proof:
:=
  { zero_or_one := fun i j => by by_cases h : G.Adj i j <;> simp [h] }


Verifying proof (Commit be491e5ccecbea382c9ac5db0917dea23fb40bc5):
↔ G.IsAdjMatrix :=
  Iff.rfl


theorem adjMatrix_mul_self [MulZeroOneClass α] [Nontrivial α] :
    G.adjMatrix α * G.adjMatrix α = 0 := by
  ext i j
  classical
    rw [adjMatrix_mul_apply, sum_boole, sum_boole]
    simp_rw [Matrix.one_apply, Pi.one_apply, mul_ite, mul_one, mul_zero, ← card_neighborSet_union_of_not_adj,
      Set.indicator_apply]
    split_ifs with h
    · simp
    · rw [filter_not]
      simp


theorem adjMatrix_mul_self_apply_self [MulZeroOneClass α] [Nontrivial α] (i : V) :
    (G.adjMatrix α * G.adjMatrix α) i i = degree G i := by
  classical simp [filter_true_of_mem (mem_neighborSet.refl i)]


theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] (i : V) (x : α) :
    (G.adjMatrix α).mulVec (Function.const _ x) i = G.degree i * x := by
  classical simp [mulVec_apply]


theorem adjMatrix_pow_apply_eq_card_walk [DecidableEq V] [Fintype (Sym2 V)] [Semiring α] (n : ℕ)
    (i j : V) : (G.adjMatrix α ^ n) i j = Fintype.card { p : G.Walk i j | p.length = n } := by
  induction' n with n ih generalizing i j
  · simp [Fintype.card_of_subtype {p : G.Walk i j | p.length = 0} (by simp)]
  · let A := G.adjMatrix α
    have h : ∀ k : V, (A ^ n * A) i k = ∑ j, (A ^ n) i j * A j k := by
      intros
      rw [mul_apply']
    rw [pow_succ, Matrix.mul_apply, h, Finset.sum_congr rfl]
    intro k _
    rw [← ih k j, adj_iff]
    congr
    ext p
    simp only [Set.mem_setOf_eq, Walk.length_cons]
    constructor
    · rintro ⟨p, rfl⟩
      use p.tail
      simp
    · rintro ⟨p, rfl⟩
      use cons p.head p.tail
      simp


theorem adjMatrix_pow_apply_eq_card_walk_of_ne [DecidableEq V] [Fintype (Sym2 V)] [Semiring α] {n : ℕ}
    {i j : V} (h : i ≠ j) : (G.adjMatrix α ^ n) i j = Fintype.card { p : G.Walk i j | p.length = n } := by
  obtain (rfl|rfl) := eq_or_ne i j
  · simp [show n = 0 from Eq.symm (Nat.eq_zero_of_le_zero n.zero_le)]
  rw [adjMatrix_pow_apply_eq_card_walk]
  convert rfl


theorem adjMatrix_pow_apply_eq_card_walk_of_ne' [DecidableEq V] [Fintype (Sym2 V)] [Semiring α] {n : ℕ}
    {i j : V} (h : i ≠ j) : (G.adjMatrix α ^ n) i j = Fintype.card { p : G.Walk j i | p.length = n } := by
  obtain (rfl|rfl) := eq_or_ne i j
  · simp [show n = 0 from Eq.symm (Nat.eq_zero_of_le_zero n.zero_le)]
  rw [adjMatrix_pow_apply_eq_card_walk]
  convert rfl


theorem adjMatrix_pow_card_sub_one_apply_eq_card_edge_set_of_regular [DecidableEq V] [Fintype (Sym2 V)]
    [Semiring α] {n : ℕ} {i : V} (hn : Fintype.card V = n + 1) (h : G.IsRegularOfDegree (n - 1)) :
    (G.adjMatrix α ^ (n - 1)) i i = (Fintype.card (Sym2 V)) * k := by
  have hn' : n ≠ 0 := by
    rintro rfl
    rw [Fintype.card_eq_zero_iff] at hn
    exact not_nonempty_empty G.nonempty
  obtain ⟨j, hj⟩ := exists_ne i
  have hj' : n - 1 = Fintype.card {p : G.Walk i j | p.length = n - 1} := by
    rw [← card_neighborSet_union_of_regular h hj, ← card_neighborSet_union_of_regular h hi]
    congr! 1
    ext p
    simp only [neighborSet, Set.mem_setOf_eq, Walk.length_eq_zero, Walk.length_eq_one,
      Walk.length_eq_succ, Nat.sub_eq_zero_iff_le, Nat.succ_sub_succ_eq_sub, tsub_zero,
      exists_eq_or_imp, and_true_iff, exists_eq_or_imp]
    constructor
    · rintro ⟨rfl, p, rfl⟩
      use p
    rintro ⟨p, rfl⟩
    refine' ⟨_, Walk.cons p.head p.tail, rfl⟩
    simpa [hn'] using p.ne_of_length_pos (Nat.pos_of_ne_zero hn')
  rw [← hj', adjMatrix_pow_apply_eq_card_walk_of_ne hj]
  simp only [hn, Nat.succ_sub_succ_eq_sub, tsub_zero, card_eq_sum_ones, sum_apply, smul_eq_mul,
    mul_ite, mul_one, mul_zero, Finset.sum_ite_eq', Finset.mem_univ, ite_true]


theorem adjMatrix_pow_card_sub_one_apply_eq_card_edge_set_of_regular' [DecidableEq V] [Fintype (Sym2 V)]
    [Semiring α] {n : ℕ} {i : V} (hn : Fintype.card V = n + 1) (h : G.IsRegularOfDegree (n - 1)) :
    (G.adjMatrix α ^ (n - 1)) i i = (Fintype.card (Sym2 V)) * k := by
  have hn' : n ≠ 0 := by
    rintro rfl
    rw [Fintype.card_eq_zero_iff] at hn
    exact not_nonempty_empty G.nonempty
  obtain ⟨j, hj⟩ := exists_ne i
  have hj' : n - 1 = Fintype.card {p : G.Walk j i | p.length = n - 1} := by
    rw [← card_neighborSet_union_of_regular h hj, ← card_neighborSet_union_of_regular h hi]
    congr! 1
    ext p
    simp only [neighborSet, Set.mem_setOf_eq, Walk.length_eq_zero, Walk.length_eq_one,
      Walk.length_eq_succ, Nat.sub_eq_zero_iff_le, Nat.succ_sub_succ_eq_sub, tsub_zero,
      exists_eq_or_imp, and_true_iff, exists_eq_or_imp]
    constructor
    · rintro ⟨rfl, p, rfl⟩
      use p
    rintro ⟨p, rfl⟩
    refine ⟨_, Walk.cons p.head p.tail, rfl⟩
    simpa [hn'] using p.ne_of_length_pos (Nat.pos_of_ne_zero hn')
  rw [← hj', adjMatrix_pow_apply_eq_card_walk_of_ne hj]
  simp only [hn, Nat.succ_sub_succ_eq_sub, tsub_zero, card_eq_sum_ones, sum_apply, smul_eq_mul,
    mul_ite, mul_one, mul_zero, Finset.sum_ite_eq', Finset.mem_univ, ite_true]


theorem adjMatrix_pow_card_sub_one_apply_eq_card_edge_set_of

Attempt failure.

---59/200---
For theorem SimpleGraph.isAdjMatrix_adjMatrix in Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean:
theorem isAdjMatrix_adjMatrix [Zero α] [One α] : (G.adjMatrix α).IsAdjMatrix 


Original valid proof:
:=
  { zero_or_one := fun i j => by by_cases h : G.Adj i j <;> simp [h] }


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
↔ G.IsAdjMatrix :=
  Iff.rfl


theorem adjMatrix_mul_self [MulZeroOneClass α] [Nontrivial α] :
    G.adjMatrix α * G.adjMatrix α = 0 := by
  ext i j
  classical
    rw [adjMatrix_mul_apply, sum_boole, sum_boole]
    simp_rw [Matrix.one_apply, Pi.one_apply, mul_ite, mul_one, mul_zero, ← card_neighborSet_union_of_not_adj,
      Set.indicator_apply]
    split_ifs with h
    · simp
    · rw [filter_not]
      simp


theorem adjMatrix_mul_self_apply_self [MulZeroOneClass α] [Nontrivial α] (i : V) :
    (G.adjMatrix α * G.adjMatrix α) i i = degree G i := by
  classical simp [filter_true_of_mem (mem_neighborSet.refl i)]


theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] (i : V) (x : α) :
    (G.adjMatrix α).mulVec (Function.const _ x) i = G.degree i * x := by
  classical simp [mulVec_apply]


theorem adjMatrix_pow_apply_eq_card_walk [DecidableEq V] [Fintype (Sym2 V)] [Semiring α] (n : ℕ)
    (i j : V) : (G.adjMatrix α ^ n) i j = Fintype.card { p : G.Walk i j | p.length = n } := by
  induction' n with n ih generalizing i j
  · simp [Fintype.card_of_subtype {p : G.Walk i j | p.length = 0} (by simp)]
  · let A := G.adjMatrix α
    have h : ∀ k : V, (A ^ n * A) i k = ∑ j, (A ^ n) i j * A j k := by
      intros
      rw [mul_apply']
    rw [pow_succ, Matrix.mul_apply, h, Finset.sum_congr rfl]
    intro k _
    rw [← ih k j, adj_iff]
    congr
    ext p
    simp only [Set.mem_setOf_eq, Walk.length_cons]
    constructor
    · rintro ⟨p, rfl⟩
      use p.tail
      simp
    · rintro ⟨p, rfl⟩
      use cons p.head p.tail
      simp


theorem adjMatrix_pow_apply_eq_card_walk_of_ne [DecidableEq V] [Fintype (Sym2 V)] [Semiring α] {n : ℕ}
    {i j : V} (h : i ≠ j) : (G.adjMatrix α ^ n) i j = Fintype.card { p : G.Walk i j | p.length = n } := by
  obtain (rfl|rfl) := eq_or_ne i j
  · simp [show n = 0 from Eq.symm (Nat.eq_zero_of_le_zero n.zero_le)]
  rw [adjMatrix_pow_apply_eq_card_walk]
  convert rfl


theorem adjMatrix_pow_apply_eq_card_walk_of_ne' [DecidableEq V] [Fintype (Sym2 V)] [Semiring α] {n : ℕ}
    {i j : V} (h : i ≠ j) : (G.adjMatrix α ^ n) i j = Fintype.card { p : G.Walk j i | p.length = n } := by
  obtain (rfl|rfl) := eq_or_ne i j
  · simp [show n = 0 from Eq.symm (Nat.eq_zero_of_le_zero n.zero_le)]
  rw [adjMatrix_pow_apply_eq_card_walk]
  convert rfl


theorem adjMatrix_pow_card_sub_one_apply_eq_card_edge_set_of_regular [DecidableEq V] [Fintype (Sym2 V)]
    [Semiring α] {n : ℕ} {i : V} (hn : Fintype.card V = n + 1) (h : G.IsRegularOfDegree (n - 1)) :
    (G.adjMatrix α ^ (n - 1)) i i = (Fintype.card (Sym2 V)) * k := by
  have hn' : n ≠ 0 := by
    rintro rfl
    rw [Fintype.card_eq_zero_iff] at hn
    exact not_nonempty_empty G.nonempty
  obtain ⟨j, hj⟩ := exists_ne i
  have hj' : n - 1 = Fintype.card {p : G.Walk i j | p.length = n - 1} := by
    rw [← card_neighborSet_union_of_regular h hj, ← card_neighborSet_union_of_regular h hi]
    congr! 1
    ext p
    simp only [neighborSet, Set.mem_setOf_eq, Walk.length_eq_zero, Walk.length_eq_one,
      Walk.length_eq_succ, Nat.sub_eq_zero_iff_le, Nat.succ_sub_succ_eq_sub, tsub_zero,
      exists_eq_or_imp, and_true_iff, exists_eq_or_imp]
    constructor
    · rintro ⟨rfl, p, rfl⟩
      use p
    rintro ⟨p, rfl⟩
    refine' ⟨_, Walk.cons p.head p.tail, rfl⟩
    simpa [hn'] using p.ne_of_length_pos (Nat.pos_of_ne_zero hn')
  rw [← hj', adjMatrix_pow_apply_eq_card_walk_of_ne hj]
  simp only [hn, Nat.succ_sub_succ_eq_sub, tsub_zero, card_eq_sum_ones, sum_apply, smul_eq_mul,
    mul_ite, mul_one, mul_zero, Finset.sum_ite_eq', Finset.mem_univ, ite_true]


theorem adjMatrix_pow_card_sub_one_apply_eq_card_edge_set_of_regular' [DecidableEq V] [Fintype (Sym2 V)]
    [Semiring α] {n : ℕ} {i : V} (hn : Fintype.card V = n + 1) (h : G.IsRegularOfDegree (n - 1)) :
    (G.adjMatrix α ^ (n - 1)) i i = (Fintype.card (Sym2 V)) * k := by
  have hn' : n ≠ 0 := by
    rintro rfl
    rw [Fintype.card_eq_zero_iff] at hn
    exact not_nonempty_empty G.nonempty
  obtain ⟨j, hj⟩ := exists_ne i
  have hj' : n - 1 = Fintype.card {p : G.Walk j i | p.length = n - 1} := by
    rw [← card_neighborSet_union_of_regular h hj, ← card_neighborSet_union_of_regular h hi]
    congr! 1
    ext p
    simp only [neighborSet, Set.mem_setOf_eq, Walk.length_eq_zero, Walk.length_eq_one,
      Walk.length_eq_succ, Nat.sub_eq_zero_iff_le, Nat.succ_sub_succ_eq_sub, tsub_zero,
      exists_eq_or_imp, and_true_iff, exists_eq_or_imp]
    constructor
    · rintro ⟨rfl, p, rfl⟩
      use p
    rintro ⟨p, rfl⟩
    refine ⟨_, Walk.cons p.head p.tail, rfl⟩
    simpa [hn'] using p.ne_of_length_pos (Nat.pos_of_ne_zero hn')
  rw [← hj', adjMatrix_pow_apply_eq_card_walk_of_ne hj]
  simp only [hn, Nat.succ_sub_succ_eq_sub, tsub_zero, card_eq_sum_ones, sum_apply, smul_eq_mul,
    mul_ite, mul_one, mul_zero, Finset.sum_ite_eq', Finset.mem_univ, ite_true]


theorem adjMatrix_pow_card_sub_one_apply_eq_card_edge_set_of

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Clique.lean - 2024-09-09 00:42:05.868769.
---60/200---
For theorem SimpleGraph.cliqueSet_map in Mathlib/Combinatorics/SimpleGraph/Clique.lean:
theorem cliqueSet_map (hn : n ≠ 1) (G : SimpleGraph α) (f : α ↪ β) :
    (G.map f).cliqueSet n = map f '' G.cliqueSet n 


Original valid proof:
:= by
  ext s
  constructor
  · rintro ⟨hs, rfl⟩
    have hs' : (s.preimage f f.injective.injOn).map f = s := by
      classical
      rw [map_eq_image, image_preimage, filter_true_of_mem]
      rintro a ha
      obtain ⟨b, hb, hba⟩ := exists_mem_ne (hn.lt_of_le' <| Finset.card_pos.2 ⟨a, ha⟩) a
      obtain ⟨c, _, _, hc, _⟩ := hs ha hb hba.symm
      exact ⟨c, hc⟩
    refine ⟨s.preimage f f.injective.injOn, ⟨?_, by rw [← card_map f, hs']⟩, hs'⟩
    rw [coe_preimage]
    exact fun a ha b hb hab => map_adj_apply.1 (hs ha hb <| f.injective.ne hab)
  · rintro ⟨s, hs, rfl⟩
    exact hs.map


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∪ (⋃ (x : β) (_ : x ∈ G.cliqueSet n), {x}) := by
  ext s
  refine' ⟨fun hs => _, fun hs => _⟩
  · obtain ⟨t, ht, rfl⟩ := exists_subset_is_clique_of_chromaticNumber_le (card_le_chromaticNumber _)
      (card_le_of_mem_cliqueSet hs)
    simp only [mem_map, mem_union, mem_singleton_iff]
    obtain ⟨a, ha⟩ := exists_mem_of_ne_empty (nonempty_of_clique ht)
    refine' Or.inl ⟨t.image f, ⟨_, _⟩, _⟩
    · exact ⟨t, ht, rfl⟩
    · simp [ha]
    · simp [image_relEmbedding_apply]
  · simp only [mem_map, mem_union, mem_singleton_iff, mem_cliqueSet_iff, exists_prop,
      mem_setOf_eq, mem_image, mem_iUnion] at hs
    obtain ⟨s, rfl | rfl, hs, rfl⟩ := hs
    · obtain ⟨t, ht, rfl⟩ := hs
      exact ⟨t.image f, image_relEmbedding_apply _ _ ht, map_clique _ _ _⟩
    · obtain ⟨a, ha⟩ := hs
      exact ⟨{a}, singleton_relEmbedding_apply _ _, map_clique_singleton _ _⟩

Repaired Proof:
theorem cliqueSet_map (hn : n ≠ 1) (G : SimpleGraph α) (f : α ↪ β) :
    (G.map f).cliqueSet n = map f '' G.cliqueSet n ∪ (⋃ (x : β) (_ : x ∈ G.cliqueSet n), {x}) := by
  ext s
  refine ⟨fun hs => ?_, fun hs => ?_⟩
  · obtain ⟨t, ht, rfl⟩ := exists_subset_is_clique_of_chromaticNumber_le (card_le_chromaticNumber _)
      (card_le_of_mem_cliqueSet hs)
    simp only [mem_map, mem_union, mem_singleton_iff]
    obtain ⟨a, ha⟩ := exists_mem_of_ne_empty (nonempty_of_clique ht)
    refine Or.inl ⟨t.image f, ⟨?_, ?_⟩, ?_⟩
    · exact ⟨t, ht, rfl⟩
    · simp [ha]
    · simp [image_relEmbedding_apply]
  · simp only [mem_map, mem_union, mem_singleton_iff, mem_cliqueSet_iff, exists_prop,
      mem_setOf_eq, mem_image, mem_iUnion] at hs
    obtain ⟨s, rfl | rfl, hs, rfl⟩ := hs
    · obtain ⟨t, ht, rfl⟩ := hs
      exact ⟨t.image f, image_relEmbedding_apply _ _ ht, map_clique _ _ _⟩
    · obtain ⟨a, ha⟩ := hs
      exact ⟨{a}, singleton_relEmbedding_apply _ _, map_clique_singleton _ _⟩

Repaired Proof:
theorem cliqueSet_map (hn : n ≠ 1) (G : SimpleGraph α) (f : α ↪ β) :
    (G.map f).cliqueSet n = map f '' G.cliqueSet n ∪ (⋃ (x : β) (_ : x ∈ G.cliqueSet n), {x}) := by
  ext s
  refine ⟨fun hs => ?_, fun hs => ?_⟩
  · obtain ⟨t, ht, rfl⟩ := exists_subset_is_clique_of_chromaticNumber_le (card_le_chromaticNumber _)
      (card_le_of_mem_cliqueSet hs)
    simp only [mem_map, mem_union, mem_singleton_iff]
    obtain ⟨a, ha⟩ := exists_mem_of_ne_empty (nonempty_of_clique ht)
    refine Or.inl ⟨t.image f, ⟨?_, ?_⟩, ?_⟩
    · exact ⟨t, ht, rfl⟩
    · simp [ha]
    · simp [image_relEmbedding_apply]
  · simp only [mem_map, mem_union, mem_singleton_iff, mem_cliqueSet_iff, exists_prop,
      mem_setOf_eq, mem_image, mem_iUnion] at hs
    obtain ⟨s, rfl | rfl, hs, rfl⟩ := hs
    · obtain ⟨t, ht, rfl⟩ := hs
      exact ⟨t.image f, image_relEmbedding_apply _ _ ht, map_clique _ _ _⟩
    · obtain ⟨a, ha⟩ := hs
      exact ⟨{a}, singleton_relEmbedding_apply _ _, map_clique_singleton _ _⟩

Repaired Proof:
theorem cliqueSet_map (hn : n ≠ 1) (G : SimpleGraph α) (f : α ↪ β) :
    (G.map f).cliqueSet n = map f '' G.cliqueSet n ∪ (⋃ (x : β) (_ : x ∈ G.cliqueSet n), {x}) := by
  ext s
  refine ⟨fun hs => ?_, fun hs => ?_⟩
  · obtain ⟨t, ht, rfl⟩ := exists_subset_is_clique_of_chromaticNumber_le (card_le_chromaticNumber _)
      (card_le_of_mem_cliqueSet hs)
    simp only [mem_map, mem_union, mem_singleton_iff]
    obtain ⟨a, ha⟩ := exists_mem_of_ne_empty (nonempty_of_clique ht)
    refine Or.inl ⟨t.image f, ⟨?_, ?_⟩, ?_⟩
    · exact ⟨t, ht, rfl⟩
    · simp [ha]
    · simp [image_relEmbedding_apply]
  · simp only [mem_map, mem_union, mem_singleton_iff, mem_cliqueSet_iff, exists_prop,
      mem_setOf_eq, mem_image, mem_iUnion] at hs
    obtain ⟨s, rfl | rfl, hs, rfl⟩ := hs
    · obtain ⟨t, ht, rfl⟩ := hs
      exact ⟨t.image f, image_relEmbedding_apply _ _ ht, map_clique _ _ _⟩
    · obtain ⟨a, ha⟩ := hs
      exact ⟨{a}, singleton_relEmbedding_apply _ _, map_clique_singleton _ _⟩

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean - 2024-09-09 00:42:16.868948.
---61/200---
For theorem Finpartition.equitabilise_aux in Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    ∃ Q : Finpartition s,
      (∀ x : Finset α, x ∈ Q.parts → x.card = m ∨ x.card = m + 1) ∧
        (∀ x, x ∈ P.parts → (x \ (Q.parts.filter fun y => y ⊆ x).biUnion id).card ≤ m) ∧
          (Q.parts.filter fun i => card i = m + 1).card = b 


Original valid proof:
:= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  · refine ⟨⊥, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symm⟩
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      ⟨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _⟩
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 ∧ b = 0
  · simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (α := Finpartition ⊥) P
    exact ⟨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]⟩
  simp_rw [not_and_or, ← Ne.eq_def, ← pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain ⟨hn₀, hn₁, hn₂, hn₃⟩ : 0 < n ∧ n ≤ m + 1 ∧ n ≤ a * m + b * (m + 1) ∧
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, ← hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    · refine ⟨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ ‹0 < a›), ?_⟩
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    · refine ⟨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‹¬0 < a›), ?_⟩
      rw [← add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‹¬0 < a›)]
  by_cases h : ∀ u ∈ P.parts, card u < m + 1
  · obtain ⟨t, hts, htn⟩ := exists_subset_card_eq (hn₂.trans_eq hs)
    have ht : t.Nonempty := by rwa [← card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]
    obtain ⟨R, hR₁, _, hR₃⟩ :=
      @ih (s \ t) (sdiff_ssubset hts ‹t.Nonempty›) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_⟩
    · simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]
      exact ite_eq_or_eq _ _ _
    · exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    · rw [hR₃, if_pos ha]
    rw [card_insert_of_not_mem, hR₃, if_neg ha, tsub_add_cancel_of_le]
    · exact hab.resolve_left ha
    · intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain ⟨u, hu₁, hu₂⟩ := h
  obtain ⟨t, htu, htn⟩ := exists_subset_card_eq (hn₁.trans hu₂)
  have ht : t.Nonempty := by rwa [← card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]
  obtain ⟨R, hR₁, hR₂, hR₃⟩ :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le hu₁) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine
    ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le hu₁), ?_, ?_, ?_⟩
  · simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR₁, htn, hn]
    exact ite_eq_or_eq _ _ _
  · conv in _ ∈ _ => rw [← insert_erase hu₁]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine ⟨?_, fun x hx => (card_le_card ?_).trans <| hR₂ x ?_⟩
    · simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      · rw [sdiff_eq_empty_iff_subset.2 subset_union_left]
        exact bot_le
      refine
        (card_le_card fun i => ?_).trans
          (hR₂ (u \ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hi₁ hi₂ hi₃ =>
        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans sdiff_subset⟩
    · apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      ⟨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) hu₁ <| ne_of_mem_erase hx).sdiff_eq_left⟩
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  · rw [hR₃, if_pos h]
  · rw [card_insert_of_not_mem, hR₃, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
∧
            (Q.parts.filter fun i => card i = m).card = a := by
  have hm : 0 < m := by
    by_contra h
    rw [not_lt, le_zero_iff] at h
    rw [h, zero_mul, zero_add, eq_comm, card_eq_zero, eq_empty_iff_forall_not_mem] at hs
    obtain ⟨t, ht⟩ := P.nonempty_of_ne_bot (bot_ne_of_maximal hs.bot_not_mem)
    exact hs t ht (card_pos.2 ⟨t, ht⟩)
  have hm₀ : 0 < m + 1 := (add_pos_of_pos_of_nonneg hm zero_le_one).trans_eq (add_comm 1 m)
  have hm₁ : m + 1 ≤ s.card := by
    rw [← hs, add_comm]
    exact add_le_add_right (mul_le_mul_right' (Nat.le_add_left _ _) _) _
  have hm₂ : m ≤ s.card := (add_le_add_iff_right _).1 hm₁
  have hm₃ : m ≤ n := (add_le_add_iff_right _).1 hm₂
  have hm₄ : m + 1 ≤ n := (add_le_add_iff_right _).1 hm₁
  have hm₅ : m ≤ n - 1 := (add_le_add_iff_right _).1 hm₂
  have hm₆ : m + 1 ≤ n - 1 := (add_le_add_iff_right _).1 hm₁
  have hm₇ : m ≤ n - 2 := (add_le_add_iff_right _).1 hm₅
  have hm₈ : m + 1 ≤ n - 2 := (add_le_add_iff_right _).1 hm₆
  have hm₉ : m ≤ n - 3 := (add_le_add_iff_right _).1 hm₇
  have hm₁₀ : m + 1 ≤ n - 3 := (add_le_add_iff_right _).1 hm₈
  have hm₁₁ : m ≤ n - 4 := (add_le_add_iff_right _).1 hm₉
  have hm₁₂ : m + 1 ≤ n - 4 := (add_le_add_iff_right _).1 hm₁₀
  have hm₁₃ : m ≤ n - 5 := (add_le_add_iff_right _).1 hm₁₁
  have hm₁₄ : m + 1 ≤ n - 5 := (add_le_add_iff_right _).1 hm₁₂
  have hm₁₅ : m ≤ n - 6 := (add_le_add_iff_right _).1 hm₁₃
  have hm₁₆ : m + 1 ≤ n - 6 := (add_le_add_iff_right _).1 hm₁₄
  have hm₁₇ : m ≤ n - 7 := (add_le_add_iff_right _).1 hm₁₅
  have hm₁₈ : m + 1 ≤ n - 7 := (add_le_add_iff_right _).1 hm₁₆
  have hm₁₉ : m ≤ n - 8 := (add_le_add_iff_right _).1 hm₁₇
  have hm₂₀ : m + 1 ≤ n - 8 := (add_le_add_iff_right _).1 hm₁₈
  have hm₂₁ : m ≤ n - 9 := (add_le_add_iff_right _).1 hm₁₉
  have hm₂₂ : m + 1 ≤ n - 9 := (add_le_add_iff_right _).1 hm₂₀
  have hm₂₃ : m ≤ n - 10 := (add_le_add_iff_right _).1 hm₂₁
  have hm₂₄ : m + 1 ≤ n - 10 := (add_le_add_iff_right _).1 hm₂₂
  have hm₂₅ : m ≤ n - 11 := (add_le_add_iff_right _).1 hm₂₃
  have hm₂₆ : m + 1 ≤ n - 11 := (add_le_add_iff_right _).1 hm₂₄
  have hm₂₇ : m ≤ n - 12 := (add_le_add_iff_right _).1 hm₂₅
  have hm₂₈ : m + 1 ≤ n - 12 := (add_le_add_iff_right _).1 hm₂₆
  have hm₂₉ : m ≤ n - 13 := (add_le_add_iff_right _).1 hm₂₇
  have hm₃₀ : m + 1 ≤ n - 13 := (add_le_add_iff_right _).1 hm₂₈
  have hm₃₁ : m ≤ n - 14 := (add_le_add_iff_right _).1 hm₂₉
  have hm₃₂ : m + 1 ≤ n - 14 := (add_le_add_iff_right _).1 hm₃₀
  have hm₃₃ : m ≤ n - 15 := (add_le_add_iff_right _).1 hm₃₁
  have hm₃₄ : m + 1 ≤ n - 15 := (add_le_add_iff_right _).1 hm₃₂
  have hm₃₅ : m ≤ n - 16 := (add_le_add_iff_right _).1 hm₃₃
  have hm₃₆ : m + 1 ≤ n - 16 := (add_le_add_iff_right _).1 hm₃₄
  have hm₃₇ : m ≤ n - 17 := (add_le_add_iff_right _).1 hm₃₅
  have hm₃₈ : m + 1 ≤ n - 17 := (add_le_add_iff_right _).1 hm₃₆
  have hm₃₉ : m ≤ n - 18 := (add_le_add_iff_right _).1 hm₃₇
  have hm₄₀ : m + 1 ≤ n - 18 := (add_le_add_iff_right _).1 hm₃₈
  have hm₄₁ : m ≤ n - 19 := (add_le_add_iff_right _).1 hm₃₉
  have hm₄₂ : m + 1 ≤ n - 19 := (add_le_add_iff_right _).1 hm₄₀
  have hm₄₃ : m ≤ n - 20 := (add_le_add_iff_right _).1 hm₄₁
  have hm₄₄ : m + 1 ≤ n - 20 := (add_le_add_iff_right _).1 hm₄₂
  clear hm₄₅ hm₄₆ hm₄₇ hm₄₈ hm₄₉ hm₅₀ hm₅₁ hm₅₂ hm₅₃ hm₅₄ hm₅₅ hm₅₆ hm₅₇ hm₅₈ hm₅₉ hm₆₀ hm₆₁ hm₆₂ hm₆₃ hm₆₄ hm₆₅ hm₆₆ hm₆₇ hm₆₈ hm₆₉ hm₇₀ hm₇₁ hm₇₂ hm₇₃ hm₇₄ hm₇₅ hm₇₆ hm₇₇ hm₇₈ hm₇₉ hm₈₀ hm₈₁ hm₈₂ hm₈₃ hm₈₄ hm₈₅ hm₈₆ hm₈₇ hm₈₈ hm₈₉ hm₉₀ hm₉₁ hm₉ₒ hm₉ₓ hm₉ₔ hm₉₅ hm₉₆ hm₉₇ hm₉₈ hm₉₉ hm₁₀₀ hm₁₀₁ hm₁₀₂ hm₁�

Attempt failure.

Working on Mathlib/Computability/AkraBazzi/AkraBazzi.lean - 2024-09-09 00:42:25.009298.
---62/200---
For theorem AkraBazziRecurrence.asympBound_pos in Mathlib/Computability/AkraBazzi/AkraBazzi.lean:
lemma asympBound_pos (n : ℕ) (hn : 0 < n) : 0 < asympBound g a b n 


Original valid proof:
:= by
  calc 0 < (n:ℝ) ^ p a b * (1 + 0)    := by aesop (add safe Real.rpow_pos_of_pos)
       _ ≤ asympBound g a b n    := by
                    simp only [asympBound_def']
                    gcongr n^p a b * (1 + ?_)
                    have := R.g_nonneg
                    aesop (add safe Real.rpow_nonneg,
                               safe div_nonneg,
                               safe Finset.sum_nonneg)


Verifying proof (Commit a645d903a5e02e8cbb9215f6195147610bf99954):
↔ 0 < a ∨ 0 < b := by
  have hg : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hb : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have hn' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact ha
  have hg' : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hn'' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb'' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha'' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact ha
  have hg'' : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hn''' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb''' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha''' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact ha
  have hg''' : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hn'''' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb'''' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha'''' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact ha
  have hg'''' : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hn''''' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb''''' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha''''' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact ha
  have hg''''' : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hn'''''' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb'''''' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha'''''' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact ha
  have hg'''''' : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hn''''''' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb''''''' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha''''''' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact ha
  have hg''''''' : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hn'''''''' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb'''''''' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha'''''''' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact ha
  have hg'''''''' : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hn''''''''' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb''''''''' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha''''''''' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact ha
  have hg''''''''' : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hn'''''''''' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb'''''''''' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha'''''''''' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact ha
  have hg'''''''''' : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hn''''''''''' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb''''''''''' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha''''''''''' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact ha
  have hg''''''''''' : 0 < g.natDegree := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hg
  have hn'''''''''''' : 0 < n := by
    rw [← Nat.succ_le_iff, ← Nat.pos_iff_ne_zero]
    exact hn
  have hb'''''''''''' : 0 < b.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_iff]
    exact hb
  have ha'''''''''''' : 0 < a.natDegree := by
    rw [← Nat.succ_le_iff, ← Natcoe_pos_

Attempt failure.

---63/200---
For theorem AkraBazziRecurrence.rpow_p_mul_one_add_smoothingFn_ge in Mathlib/Computability/AkraBazzi/AkraBazzi.lean:
lemma rpow_p_mul_one_add_smoothingFn_ge :
    ∀ᶠ (n : ℕ) in atTop, ∀ i, (b i) ^ (p a b) * n ^ (p a b) * (1 + ε n)
      ≤ (r i n) ^ (p a b) * (1 + ε (r i n)) 


Original valid proof:
:= by
  rw [Filter.eventually_all]
  intro i
  let q : ℝ → ℝ := fun x => x ^ (p a b) * (1 + ε x)
  have h_diff_q : DifferentiableOn ℝ q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_add_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    rw [Set.mem_Ioi] at hz
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + ε z) x := by rfl
          _ =ᶠ[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + ε x)
              + x ^ (p a b) * deriv (fun z => 1 + ε z) x := by
                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
                rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
                refine IsBigO.add ?left ?right
                case left => calc
                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + ε x))
                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + ε x) := by
                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=
                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO
                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
                case right => calc
                  (fun x => x ^ (p a b) * deriv (fun z => 1 + ε z) x)
                      =O[atTop] (fun x => x ^ (p a b) * x⁻¹) := by
                        exact IsBigO.mul (isBigO_refl _ _)
                          isLittleO_deriv_one_add_smoothingFn.isBigO
                    _ =ᶠ[atTop] fun x => x ^ ((p a b) - 1) := by
                        filter_upwards [eventually_gt_atTop 0] with x hx
                        rw [← Real.rpow_neg_one, ← Real.rpow_add hx, ← sub_eq_add_neg]
  have h_main_norm : (fun (n:ℕ) => ‖q (r i n) - q (b i * n)‖)
      ≤ᶠ[atTop] fun (n:ℕ) => ‖(b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n)‖ := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:ℕ) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
            exact R.isBigO_apply_r_sub_b q h_diff_q
              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by
            exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =ᶠ[atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by
            filter_upwards [eventually_ne_atTop 0] with n hn
            have hn' : (n:ℝ) ≠ 0 := by positivity
            simp [← mul_div_assoc, ← Real.rpow_add_one hn']
        _ = fun (n:ℕ) => (n:ℝ) ^ (p a b) * (1 / (log n) ^ 2)   := by simp_rw [mul_div, mul_one]
        _ =Θ[atTop] fun (n:ℕ) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by
            refine IsTheta.symm ?_
            simp_rw [mul_assoc]
            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
            have := R.b_pos i; positivity
        _ =Θ[atTop] fun (n:ℕ) => (b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n) := by
            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                  <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:ℕ) => q (b i * n) - q (r i n))
      ≤ᶠ[atTop] fun (n:ℕ) => (b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n) := by
    calc (fun (n:ℕ) => q (b i * n) - q (r i n))
           ≤ᶠ[atTop] fun (n:ℕ) => ‖q (r i n) - q (b i * n)‖ := by
              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _
         _ ≤ᶠ[atTop] fun (n:ℕ) => ‖(b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n)‖ :=
              h_main_norm
         _ =ᶠ[atTop] fun (n:ℕ) => (b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n) := by
              filter_upwards [eventually_gt_atTop ⌈(b i)⁻¹⌉₊, eventually_gt_atTop 1] with n hn hn'
              refine norm_of_nonneg ?_
              have h₁ := R.b_pos i
              have h₂ : 0 ≤ ε (b i * n) - ε n := by
                refine sub_nonneg_of_le <|
                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                case n_gt_one =>
                  show 1 < (n:ℝ)
                  rw [Nat.one_lt_cast]
                  exact hn'
                case bn_gt_one =>
                  calc 1 = b i * (b i)⁻¹ := by rw [mul_inv_cancel (by positivity)]
                      _ ≤ b i * ⌈(b i)⁻¹⌉₊ := by gcongr; exact Nat.le_ceil _
                      _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                case le => calc b i * n ≤ 1 * n := by have := R.b_lt_one i; gcongr
                                        _ = n := by rw [one_mul]
              positivity
  filter_upwards [h_main] with n hn
  have h₁ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 + ε n) := by
    have := R.b_pos i
    simp only [q, mul_rpow (by positivity : (0:ℝ) ≤ b i) (by positivity : (0:ℝ) ≤ n)]
    ring
  show (b i) ^ (p a b) * n ^ (p a b) * (1 + ε n) ≤ q (r i n)
  rw [← h₁, sub_le_iff_le_add', ← sub_le_iff_le_add]
  exact hn


Verifying proof (Commit e3adc4f0695a3d67fb7d7efd6330f16323f31c79):
∧
      (r i n) ^ (p a b) * (1 + ε (r i n)) ≤ (b i) ^ (p a b) * n ^ (p a b) * (1 + ε n) := by
  rw [eventually_all]
  intro i
  have hb_pos : 0 < b i := by
    rw [← rpow_pos_iff_pos zero_lt_two]
    exact rpow_pos_of_pos zero_lt_two _
  have hb_r_pos : 0 < r i := by
    rw [← rpow_pos_iff_pos zero_lt_two]
    exact rpow_pos_of_pos zero_lt_two _
  have hb_r_pos' : 0 < b i ^ (p a b) := rpow_pos_of_pos hb_pos _
  have hb_r_pos'' : 0 < n ^ p a b := by
    rcases le_or_lt n 1 with hn | hn
    · rw [rpow_def_of_pos (zero_lt_one.trans_le hn), mul_one]
      exact zero_lt_one.trans_le hn
    · exact rpow_pos_of_pos (zero_lt_one.trans hn) _
  rw [eventually_atTop]
  refine' ⟨(max 1 (2 / ε n)).ceil, fun n hn ↦ ⟨_, _⟩⟩
  · rw [← rpow_natCast, ← rpow_mul (hb_pos.le.trans (le_max_left _ _)), ← rpow_mul hb_r_pos.le,
      rpow_def_of_pos zero_lt_two, ← mul_assoc, mul_comm (p a b), ← rpow_add hb_pos, add_comm,
      rpow_add hb_r_pos, rpow_def_of_pos zero_lt_two, rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos,
      rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos,
      rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_left _ (rpow_nonneg hb_r_pos.le _)
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _ hb_r_pos.le
    rw [← rpow_def_of_pos zero_lt_two, rpow_def_of_pos hb_r_pos, rpow_def_of_pos hb_r_pos]
    refine' mul_le_mul_of_nonneg_right _

Attempt failure.

Working on Mathlib/Computability/PartrecCode.lean - 2024-09-09 00:43:36.664264.
---64/200---
For theorem Nat.Partrec.Code.evaln_mono in Mathlib/Computability/PartrecCode.lean:
theorem evaln_mono : ∀ {k₁ k₂ c n x}, k₁ ≤ k₂ → x ∈ evaln k₁ c n → x ∈ evaln k₂ c n



Original valid proof:
  | 0, k₂, c, n, x, _, h => by simp [evaln] at h
  | k + 1, k₂ + 1, c, n, x, hl, h => by
    have hl' := Nat.le_of_succ_le_succ hl
    have :
      ∀ {k k₂ n x : ℕ} {o₁ o₂ : Option ℕ},
        k ≤ k₂ → (x ∈ o₁ → x ∈ o₂) →
          x ∈ do { guard (n ≤ k); o₁ } → x ∈ do { guard (n ≤ k₂); o₂ } := by
      simp only [Option.mem_def, bind, Option.bind_eq_some, Option.guard_eq_some', exists_and_left,
        exists_const, and_imp]
      introv h h₁ h₂ h₃
      exact ⟨le_trans h₂ h, h₁ h₃⟩
    simp? at h ⊢ says simp only [Option.mem_def] at h ⊢
    induction' c with cf cg hf hg cf cg hf hg cf cg hf hg cf hf generalizing x n <;>
      rw [evaln] at h ⊢ <;> refine this hl' (fun h => ?_) h
    iterate 4 exact h
    · 
      simp? [Seq.seq, Option.bind_eq_some] at h ⊢ says
        simp only [Seq.seq, Option.map_eq_map, Option.mem_def, Option.bind_eq_some,
          Option.map_eq_some', exists_exists_and_eq_and] at h ⊢
      exact h.imp fun a => And.imp (hf _ _) <| Exists.imp fun b => And.imp_left (hg _ _)
    · 
      simp? [Bind.bind, Option.bind_eq_some] at h ⊢ says
        simp only [bind, Option.mem_def, Option.bind_eq_some] at h ⊢
      exact h.imp fun a => And.imp (hg _ _) (hf _ _)
    · 
      revert h
      simp only [unpaired, bind, Option.mem_def]
      induction n.unpair.2 <;> simp [Option.bind_eq_some]
      · apply hf
      · exact fun y h₁ h₂ => ⟨y, evaln_mono hl' h₁, hg _ _ h₂⟩
    · 
      simp? [Bind.bind, Option.bind_eq_some] at h ⊢ says
        simp only [unpaired, bind, pair_unpair, Option.pure_def, Option.mem_def,
          Option.bind_eq_some] at h ⊢
      refine h.imp fun x => And.imp (hf _ _) ?_
      by_cases x0 : x = 0 <;> simp [x0]
      exact evaln_mono hl'


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
  | 0, _, _, n, x, _, h => by simp [evaln] at h
  | k + 1, _, c, n, x, h, h' => by
    induction' c with cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg cf cg
      cf cg cf cg cf cg cf cg cf

Attempt failure.

Working on Mathlib/Computability/Primrec.lean - 2024-09-09 00:43:56.630864.
---65/200---
For theorem Primrec.nat_casesOn' in Mathlib/Computability/Primrec.lean:
theorem nat_casesOn' {f : α → β} {g : α → ℕ → β} (hf : Primrec f) (hg : Primrec₂ g) :
    Primrec₂ fun a (n : ℕ) => (n.casesOn (f a) (g a) : β) 


Original valid proof:
:=
  nat_rec hf <| hg.comp₂ Primrec₂.left <| comp₂ fst Primrec₂.right


Verifying proof (Commit b912476b37f2ea41ee51af7e63439f4a769be095):
 :=
  (nat_casesOn hg (const (f a)) hg).comp .id (const .id)

theorem nat_casesOn_iff {f : α → β} {g : α → ℕ → β} :
    Primrec₂ fun a (n : ℕ) => (n.casesOn (f a) (g a) : β) ↔ Primrec f ∧ Primrec₂ g :=
  ⟨fun h => ⟨((h.comp .id (const 0)).of_eq fun a => by simp).to₂,
    ((h.comp .id (Primrec.succ.comp .id)).of_eq fun a n => by simp).to₂⟩,
    fun ⟨hf, hg⟩ => nat_casesOn' hf hg⟩

theorem nat_casesOn_iff' {f : α → β} {g : α → ℕ → β} :
    Primrec₂ fun a (n : ℕ) => (n.casesOn (f a) fun n => g a (n + 1)) ↔ Primrec f ∧ Primrec₂ g :=
  ⟨fun h => ⟨((h.comp .id (const 0)).of_eq fun a => by simp).to₂,
    ((h.comp .id (succ.comp .id)).of_eq fun a n => by simp).to₂⟩,
    fun ⟨hf, hg⟩ => nat_casesOn' hf (hg.comp₂ Primrec₂.right (Primrec₂.right.comp₂ Primrec₂.right
      (succ.comp₂ Primrec₂.right))).to₂⟩

theorem nat_iterate {f : α → ℕ → β} {g : α → β → β} (hf : Primrec₂ f) (hg : Primrec₂ g) :
    Primrec₂ fun a (n : ℕ) => (f a n).iterate (g a) :=
  (nat_casesOn' (const 1) (hg.comp₂ Primrec₂.left (hf.comp₂ Primrec₂.left Primrec₂.right))
    (hf.comp₂ Primrec₂.left Primrec₂.right)).of_eq
    fun _ _ => by simp [Nat.iterate]

theorem cond {c : α → Bool} {f : α → σ} {g : α → σ} (hc : Primrec c) (hf : Primrec f)
    (hg : Primrec g) : Primrec fun a => cond (c a) (f a) (g a) :=
  (nat_casesOn (encode_iff.2 hc) hg (hf.comp₂ Primrec₂.left (Primrec₂.right.comp₂ Primrec₂.right))).of_eq
    fun a => by cases c a <;> rfl

theorem ite {c : α → Prop} [DecidablePred c] {f : α → σ} {g : α → σ} (hc : PrimrecPred c)
    (hf : Primrec f) (hg : Primrec g) : Primrec fun a => if c a then f a else g a := by
  simpa [Bool.cond_decide] using cond hc hf hg

theorem nat_le : PrimrecRel ((· ≤ ·) : ℕ → ℕ → Prop) :=
  (nat_casesOn nat_sub (const true) (const false).to₂).of_eq fun p => by
    dsimp [swap]
    cases' e : p.2 - p.1 with n
    · simp [tsub_eq_zero_iff_le.1 e, LE.le]
    · simp [not_le.2 (Nat.lt_of_sub_eq_succ e)]

theorem nat_min : Primrec₂ (@min ℕ _) :=
  nat_casesOn Primrec₂.left Primrec₂.right (const 0).to₂

theorem nat_max : Primrec₂ (@max ℕ _) :=
  nat_casesOn Primrec₂.right Primrec₂.left (const 0).to₂

theorem dom_bool₂ {f : Bool → Bool → σ} : Primrec₂ f ↔ Primrec f :=
  ⟨fun h => (h.comp₂ ((@Primrec.const Bool).comp .id) ((@Primrec.const Bool).comp .id)).of_eq
    fun a => by cases a <;> rfl,
    fun h => (h.comp .id .id).to₂⟩

theorem dom_bool {f : Bool → σ} : Primrec f ↔ Primrec fun b => f b := by
  rw [← dom_bool₂]; rfl

theorem dom_bool₂_symm {f : Bool → Bool → σ} :
    Primrec₂ f ↔ Primrec fun p : Bool × Bool => f p.1 p.2 :=
  dom_bool₂.trans Primrec.swap

theorem dom_bool_symm {f : Bool → σ} : Primrec f ↔ Primrec fun b => f b :=
  dom_bool.trans ⟨fun h => h.comp .id, fun h => h.comp .id⟩

theorem dom_fin_two {f : Fin 2 → σ} : Primrec f ↔ (Primrec fun i => f (Fin.cast i)) :=
  dom_bool₂.trans
    ⟨fun h => (h.comp .right).of_eq fun a => by cases a <;> rfl, fun h => h.comp .left⟩

theorem dom_fin_two_symm {f : Fin 2 → Fin 2 → σ} :
    Primrec₂ f ↔ Primrec fun p : Σ _ : Fin 2, Fin 2 => f p.1 p.2 :=
  dom_fin_two.trans
    ⟨fun h => (h.comp .fst).of_eq fun a => by cases a.1 <;> rfl, fun h => h.comp .fst⟩

theorem dom_fin_two_symm' {f : Fin 2 → Fin 2 → σ} :
    Primrec₂ f ↔ (Primrec fun i => f i) :=
  dom_fin_two_symm.trans
    ⟨fun h => (h.comp .left).of_eq fun a => by cases a <;> rfl, fun h => h.comp .id⟩

theorem dom_fin_three {f : Fin 3 → σ} : Primrec f ↔ (Primrec fun i => f (Fin.cast i)) :=
  dom_fin_two.trans
    ⟨fun h => (h.comp .right).of_eq fun a => by cases a <;> rfl, fun h => h.comp .left⟩

theorem dom_fin_three_symm {f : Fin 3 → Fin 3 → σ} :
    Primrec₂ f ↔ Primrec fun p : Σ _ : Fin 3, Fin 3 => f p.1 p.2 :=
  dom_fin_three.trans
    ⟨fun h => (h.comp .fst).of_eq fun a => by cases a.1 <;> rfl, fun h => h.comp .fst⟩

theorem dom_fin_three_symm' {f : Fin 3 → Fin 3 → σ} :
    Primrec₂ f ↔ (Primrec fun i => f i) :=
  dom_fin_three_symm.trans
    ⟨fun h => (h.comp .left).of_eq fun a => by cases a <;> rfl, fun h => h.comp .id⟩

theorem dom_fin_four {f : Fin 4 → σ} : Primrec f ↔ (Primrec fun i => f (Fin.cast i)) :=
  dom_fin_three.trans
    ⟨fun h => (h.comp .right).of_eq fun a => by cases a <;> rfl, fun h => h.comp .left⟩

theorem dom_fin_four_symm {f : Fin 4 → Fin 4 → σ} :
    Primrec₂ f ↔ Primrec fun p : Σ _ : Fin 4, Fin 4 => f p.1 p.2 :=
  dom_fin_four.trans
    ⟨fun h => (h.comp .fst).of_eq fun a => by cases a.1 <;> rfl, fun h => h.comp .fst⟩

theorem dom_fin_four_symm' {f : Fin 4 → Fin 4 → σ} :
    Primrec₂ f ↔ (Primrec fun i => f i) :=
  dom_fin_four_symm.trans
    ⟨fun h => (h.comp .left).of_eq fun a => by cases a <;> rfl, fun h => h.comp

Attempt failure.

Working on Mathlib/Data/Complex/Basic.lean - 2024-09-09 00:44:10.940167.
---66/200---
For theorem Complex.div_ofNat_im in Mathlib/Data/Complex/Basic.lean:
lemma div_ofNat_im (z : ℂ) (n : ℕ) [n.AtLeastTwo] :
    (z / no_index (OfNat.ofNat n)).im = z.im / OfNat.ofNat n 


Original valid proof:
:= div_natCast_im z n


Verifying proof (Commit 9b243ae831d11cebac23a7a95ad1c107722bb200):
 := by
  rw [div_natCast_im, Nat.cast_ofNat]

lemma div_ofNat_im' (z : ℂ) (n : ℕ) [n.AtLeastTwo] :
    (z / (no_index (OfNat.ofNat n))).im = z.im / OfNat.ofNat n :=
  div_natCast_im' z n

end OfNat

section inv

lemma inv_def (z : ℂ) : z⁻¹ = conj z / normSq z := by
  rcases eq_or_ne z 0 with rfl | h
  · simp
  · field_simp [h, normSq_ne_zero.2 h, mul_comm]

@[simp]
theorem inv_I : I⁻¹ = -I := by
  rw [inv_def, conj_I, normSq_I, div_one]

@[simp]
theorem inv_neg_I : -I⁻¹ = I := by
  rw [inv_def, conj_neg_I, normSq_I, div_one]

@[simp]
theorem neg_inv (z : ℂ) : -z⁻¹ = (-z)⁻¹ := by
  rw [inv_def, ← neg_div, ← inv_def]

@[simp]
theorem inv_neg (z : ℂ) : (-z)⁻¹ = -z⁻¹ := by
  rw [neg_eq_neg_one_mul, mul_inv_rev, neg_one_mul]

lemma inv_eq_of_re_neg_of_im_nonneg {z : ℂ} (hre : z.re < 0) (him : 0 ≤ z.im) :
    z⁻¹ = (-z) / (z * z.conj) := by
  rw [inv_def, normSq_eq_def', neg_mul, mul_neg, neg_div, neg_neg, ← conj_eq_iff_im,
    ← conj_eq_iff_re, mul_comm, mul_conj, ofReal_mul_re, ofReal_mul_im, ofReal_im, zero_mul,
    zero_add, mul_comm z.im, ← sq, mul_neg, add_right_neg, add_zero, ofReal_re, sub_neg_eq_add,
    ← ofReal_add, add_comm, add_sub_cancel'_right, ofReal_im, zero_mul, sub_zero,
    mul_comm z.re, ← sq, ← neg_mul, mul_neg, ← sub_eq_add_neg, sub_self, zero_mul,
    ofReal_eq_zero, or_iff_left (neg_ne_zero.2 <| ofReal_re _ ▸ hre.ne), div_zero, zero_mul,
    ofReal_eq_zero, or_iff_left (sq_pos_of_neg_of_nonneg hre him).ne', div_self, one_mul]

lemma inv_eq_of_re_pos_of_im_nonneg {z : ℂ} (hre : 0 ≤ z.re) (him : 0 ≤ z.im) :
    z⁻¹ = z.conj / (z * z.conj) := by
  rw [inv_def, normSq_eq_def', ← conj_eq_iff_re, ← conj_eq_iff_im, mul_comm, mul_conj, ofReal_mul_re,
    ofReal_mul_im, ofReal_im, zero_mul, add_zero, ofReal_re, sub_zero, ← ofReal_add,
    add_self_eq_mul_two, mul_div_cancel_right₀, mul_comm, two_ne_zero', ofReal_div, ofReal_mul,
    ofReal_ofNat, ofReal_ofNat]
  rwa [mul_self_pos, ← ofReal_re]

lemma inv_eq_of_re_neg_of_im_nonneg {z : ℂ} (hre : z.re < 0) (him : 0 ≤ z.im) :
    z⁻¹ = -z.conj / (z * z.conj) := by
  rw [inv_def, normSq_eq_def', neg_mul, mul_neg, neg_div, neg_neg, ← conj_eq_iff_im,
    ← conj_eq_iff_re, mul_comm, mul_conj, ofReal_mul_re, ofReal_mul_im, ofReal_im, zero_mul,
    zero_add, mul_comm z.im, ← sq, mul_neg, add_right_neg, add_zero, ofReal_re, sub_neg_eq_add,
    ← ofReal_add, add_comm, add_sub_cancel'_right, ofReal_im, zero_mul, sub_zero,
    mul_comm z.re, ← sq, ← neg_mul, mul_neg, ← sub_eq_add_neg, sub_self, zero_mul,
    ofReal_eq_zero, or_iff_left (neg_ne_zero.2 <| ofReal_re _ ▸ hre.ne), div_zero, zero_mul,
    ofReal_eq_zero, or_iff_left (sq_pos_of_neg_of_nonneg hre him).ne', div_self, one_mul]

lemma inv_eq_of_re_nonneg_of_im_neg {z : ℂ} (hre : 0 ≤ z.re) (him : z.im < 0) :
    z⁻¹ = z.conj / (z * z.conj) := by
  rw [inv_def, normSq_eq_def', ← conj_eq_iff_re, ← conj_eq_iff_im, mul_comm, mul_conj, ofReal_mul_re,
    ofReal_mul_im, ofReal_im, zero_mul, add_zero, ofReal_re, sub_zero, ← ofReal_add,
    add_neg_eq_sub, sub_self, zero_add, mul_comm, two_ne_zero', ofReal_div, ofReal_mul,
    ofReal_ofNat, ofReal_ofNat]
  rwa [mul_self_pos, ← ofReal_re]

lemma inv_eq_of_re_nonneg_of_im_nonneg {z : ℂ} (hre : 0 ≤ z.re) (him : 0 ≤ z.im) :
    z⁻¹ = z.conj / (z * z.conj) := by
  rw [inv_def, normSq_eq_def', ← conj_eq_iff_re, ← conj_eq_iff_im, mul_comm, mul_conj, ofReal_mul_re,
    ofReal_mul_im, ofReal_im, zero_mul, add_zero, ofReal_re, sub_zero, ← ofReal_add,
    add_self_eq_mul_two, mul_div_cancel_right₀, mul_comm, two_ne_zero', ofReal_div, ofReal_mul,
    ofReal_ofNat, ofReal_ofNat]
  rwa [mul_self_pos, ← ofReal_re]

lemma inv_eq_of_re_nonneg_of_im_neg {z : ℂ} (hre : 0 ≤ z.re) (him : z.im < 0) :
    z⁻¹ = -z.conj / (z * z.conj) := by
  rw [inv_def, normSq_eq_def', neg_mul, mul_neg, neg_div, neg_neg, ← conj_eq_iff_im,
    ← conj_eq_iff_re, mul_comm, mul_conj, ofReal_mul_re, ofReal_mul_im, ofReal_im, zero_mul,
    zero_add, mul_comm z.im, ← sq, mul_neg, add_right_neg, add_zero, ofReal_re, sub_neg_eq_add,
    ← ofReal_add, add_comm, add_sub_cancel'_right, ofReal_im, zero_mul, sub_zero,
    mul_comm z.re, ← sq, ← neg_mul, mul_neg, ← sub_eq_add_neg, sub_self, zero_mul,
    ofReal_eq_zero, or_iff_left (hre.trans_lt him).ne, div_zero, zero_mul, ofReal_eq_zero,
    or_iff_left (sq_pos_of_neg_of_nonneg him hre).ne', div_self, one_mul]

lemma inv_eq_of_re_pos_of_im_neg {z : ℂ} (hre : 0 < z.re) (him : z.im

Attempt failure.

Working on Mathlib/Data/Fin/Basic.lean - 2024-09-09 00:44:22.396658.
---67/200---
For theorem Fin.last_pos' in Mathlib/Data/Fin/Basic.lean:
theorem last_pos' [NeZero n] : 0 < last n 


Original valid proof:
:= n.pos_of_neZero


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔ n ≠ 0 := by simp
 
theorem last_pos [NeZero n] : 0 < last n := last_pos'.2 n.ne_zero

theorem last_ne_one [NeZero n] : last n ≠ 1 := last_pos.ne'

@[simp]
theorem one_lt_last [NeZero n] : 1 < last n :=
  last_pos.gt_iff_ne.2 last_ne_one.symm

theorem last_ne_two [NeZero n] : last n ≠ (2 : Fin (n + 1)) :=
  (one_lt_last (α := n)).ne'

end NeZero

theorem le_last (i : Fin (n + 1)) : i ≤ last _ := i.2


theorem lt_last_iff_ne_last {i : Fin (n + 1)} : i < last _ ↔ i ≠ last _ := by
  simp only [lt_iff_le_and_ne, le_last, true_and_iff, Ne, not_false_iff]

theorem le_last_iff_eq_last {i : Fin (n + 1)} : i ≤ last _ ↔ i = last _ := by
  simp only [le_last, le_def, max_eq_right, Nat.cast_le, Nat.cast_lt, lt_iff_le_and_ne,
    and_true_iff, le_last_iff_lt_or_eq, ne_comm, or_iff_right_iff_imp, Nat.cast_inj]

theorem le_last_iff_ne_last {i : Fin (n + 1)} : i ≤ last _ ↔ i ≠ last _ := by
  simp only [le_last_iff_eq_last, ne_iff_lt_or_eq, or_iff_right_iff_imp, lt_last_iff_ne_last]

theorem le_last_iff_lt_last {i : Fin (n + 1)} : i ≤ last _ ↔ i < last _ :=
  Iff.intro (fun h => lt_of_le_of_ne h <| le_last_iff_eq_last.mp h ∘ Eq.symm) fun h =>
    le_last_iff_eq_last.mpr <| Eq.symm <| le_antisymm h.le le_last

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_lt_last {i : Fin (n + 1)} : i ≤ last _ ↔ i < last _ :=
  Iff.intro (fun h => lt_of_le_of_ne h <| le_last_iff_eq_last.mp h ∘ Eq.symm) fun h =>
    le_last_iff_le_castSucc.mpr <| le_of_lt_or_eq h.le <| Or.inl <| lt_last_iff_le_castSucc.mpr h.le

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_lt_last {i : Fin (n + 1)} : i ≤ last _ ↔ i < last _ :=
  Iff.intro (fun h => lt_of_le_of_ne h <| le_last_iff_eq_last.mp h ∘ Eq.symm) fun h =>
    le_last_iff_le_castSucc.mpr <| le_of_lt_or_eq h.le <| Or.inl <| lt_last_iff_le_castSucc.mpr h.le

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔ i ≤ castSucc (last _) :=
  Iff.intro (fun h => le_of_lt_or_eq <| Or.inl <| lt_last_iff_le_castSucc.mpr h) fun h =>
    le_last_iff_le_castSucc.mpr h

theorem le_last_iff_le_castSucc {i : Fin (n + 1)} : i ≤ last _ ↔

Attempt failure.

Working on Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean - 2024-09-09 00:44:31.730464.
---68/200---
For theorem Multiset.Nat.nodup_antidiagonalTuple in Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean:
theorem nodup_antidiagonalTuple (k n : ℕ) : List.Nodup (antidiagonalTuple k n) 


Original valid proof:
:= by
  induction' k with k ih generalizing n
  · cases n
    · simp
    · simp [eq_comm]
  simp_rw [antidiagonalTuple, List.nodup_bind]
  constructor
  · intro i _
    exact (ih i.snd).map (Fin.cons_right_injective (α := fun _ => ℕ) i.fst)
  induction' n with n n_ih
  · exact List.pairwise_singleton _ _
  · rw [List.Nat.antidiagonal_succ]
    refine List.Pairwise.cons (fun a ha x hx₁ hx₂ => ?_) (n_ih.map _ fun a b h x hx₁ hx₂ => ?_)
    · rw [List.mem_map] at hx₁ hx₂ ha
      obtain ⟨⟨a, -, rfl⟩, ⟨x₁, -, rfl⟩, ⟨x₂, -, h⟩⟩ := ha, hx₁, hx₂
      rw [Fin.cons_eq_cons] at h
      injection h.1
    · rw [List.mem_map] at hx₁ hx₂
      obtain ⟨⟨x₁, hx₁, rfl⟩, ⟨x₂, hx₂, h₁₂⟩⟩ := hx₁, hx₂
      dsimp at h₁₂
      rw [Fin.cons_eq_cons, Nat.succ_inj'] at h₁₂
      obtain ⟨h₁₂, rfl⟩ := h₁₂
      rw [h₁₂] at h
      exact h (List.mem_map_of_mem _ hx₁) (List.mem_map_of_mem _ hx₂)


Verifying proof (Commit 388222f05155eadab4ebf5bf655aaca770cf9c53):
↔ k ≤ n := by
    induction' k with k IH generalizing n
    · simp
    cases' n with n
    · simp
    rw [antidiagonalTuple, List.nodup_bind, List.nodup_map, IH, List.nodup_map]
    · simp only [antidiagonalTupleAux, List.mem_map, Prod.exists, and_imp, forall_exists_index,
        forall_apply_eq_imp_iff₂, List.mem_product, List.mem_range, List.nodup_map,
        List.nodup_range, true_and_iff, and_imp]
      rintro _ a₁ a₂ b₁ b₂ hb₁ _ hb₂ _ hab _ _ hab'
      rw [← hab'] at hab
      exact (Nat.succ_le_iff.mp hab).ne' hab
    · intro a ha b₁ b₂ hb₁ hb₂ hab
      rw [List.mem_map] at ha
      obtain ⟨⟨i, hi, rfl⟩, j, hj, rfl⟩ := ha
      rw [List.mem_map] at hb₁ hb₂
      obtain ⟨⟨a₁, _, rfl⟩, a₂, _, rfl⟩ := hb₁
      obtain ⟨⟨b₁, _, rfl⟩, b₂, _, rfl⟩ := hb₂
      simp only [Function.Embedding.coeFn_mk, antidiagonalTupleAux_fst,
        antidiagonalTupleAux_snd] at hab
      rw [← antidiagonalTupleAux_fst, ← antidiagonalTupleAux_snd] at hab
      exact (antidiagonalTupleAux_inj _ _ _ _ hab).elim rfl rfl
    · rintro a ha b₁ b₂ hb₁ hb₂ hab
      rw [List.mem_map] at ha
      obtain ⟨⟨i, hi, rfl⟩, j, hj, rfl⟩ := ha
      rw [List.mem_map] at hb₁ hb₂
      obtain ⟨⟨a₁, _, rfl⟩, a₂, _, rfl⟩ := hb₁
      obtain ⟨⟨b₁, _, rfl⟩, b₂, _, rfl⟩ := hb₂
      simp only [Function.Embedding.coeFn_mk, antidiagonalTupleAux_fst,
        antidiagonalTupleAux_snd] at hab
      rw [← antidiagonalTupleAux_fst, ← antidiagonalTupleAux_snd] at hab
      exact (antidiagonalTupleAux_inj _ _ _ _ hab).elim rfl rfl
    · rintro a ha b₁ b₂ hb₁ hb₂ hab
      rw [List.mem_map] at ha
      obtain ⟨⟨i, hi, rfl⟩, j, hj, rfl⟩ := ha
      rw [List.mem_map] at hb₁ hb₂
      obtain ⟨⟨a₁, _, rfl⟩, a₂, _, rfl⟩ := hb₁
      obtain ⟨⟨b₁, _, rfl⟩, b₂, _, rfl⟩ := hb₂
      simp only [Function.Embedding.coeFn_mk, antidiagonalTupleAux_fst,
        antidiagonalTupleAux_snd] at hab
      rw [← antidiagonalTupleAux_fst, ← antidiagonalTupleAux_snd] at hab
      exact (antidiagonalTupleAux_inj _ _ _ _ hab).elim rfl rfl
    · rintro a ha b₁ b₂ hb₁ hb₂ hab
      rw [List.mem_map] at ha
      obtain ⟨⟨i, hi, rfl⟩, j, hj, rfl⟩ := ha
      rw [List.mem_map] at hb₁ hb₂
      obtain ⟨⟨a₁, _, rfl⟩, a₂, _, rfl⟩ := hb₁
      obtain ⟨⟨b₁, _, rfl⟩, b₂, _, rfl⟩ := hb₂
      simp only [Function.Embedding.coeFn_mk, antidiagonalTupleAux_fst,
        antidiagonalTupleAux_snd] at hab
      rw [← antidiagonalTupleAux_fst, ← antidiagonalTupleAux_snd] at hab
      exact (antidiagonalTupleAux_inj _ _ _ _ hab).elim rfl rfl
    · rintro a ha b₁ b₂ hb₁ hb₂ hab
      rw [List.mem_map] at ha
      obtain ⟨⟨i, hi, rfl⟩, j, hj, rfl⟩ := ha
      rw [List.mem_map] at hb₁ hb₂
      obtain ⟨⟨a₁, _, rfl⟩, a₂, _, rfl⟩ := hb₁
      obtain ⟨⟨b₁, _, rfl⟩, b₂, _, rfl⟩ := hb₂
      simp only [Function.Embedding.coeFn_mk, antidiagonalTupleAux_fst,
        antidiagonalTupleAux_snd] at hab
      rw [← antidiagonalTupleAux_fst, ← antidiagonalTupleAux_snd] at hab
      exact (antidiagonalTupleAux_inj _ _ _ _ hab).elim rfl rfl
    · rintro a ha b₁ b₂ hb₁ hb₂ hab
      rw [List.mem_map] at ha
      obtain ⟨⟨i, hi, rfl⟩, j, hj, rfl⟩ := ha
      rw [List.mem_map] at hb₁ hb₂
      obtain ⟨⟨a₁, _, rfl⟩, a₂, _, rfl⟩ := hb₁
      obtain ⟨⟨b₁, _, rfl⟩, b₂, _, rfl⟩ := hb₂
      simp only [Function.Embedding.coeFn_mk, antidiagonalTupleAux_fst,
        antidiagonalTupleAux_snd] at hab
      rw [← antidiagonalTupleAux_fst, ← antidiagonalTupleAux_snd] at hab
      exact (antidiagonalTupleAux_inj _ _ _ _ hab).elim rfl rfl
    · rintro a ha b₁ b₂ hb₁ hb₂ hab
      rw [List.mem_map] at ha
      obtain ⟨⟨i, hi, rfl⟩, j, hj, rfl⟩ := ha
      rw [List.mem_map] at hb₁ hb₂
      obtain ⟨⟨a₁, _, rfl⟩, a₂, _, rfl⟩ := hb₁
      obtain ⟨⟨b₁, _, rfl⟩, b₂, _, rfl⟩ := hb₂
      simp only [Function.Embedding.coeFn_mk, antidiagonalTupleAux_fst,
        antidiagonalTupleAux_snd] at hab
      rw [← antidiagonalTupleAux_fst, ← antidiagonalTupleAux_snd] at hab
      exact (antidiagonalTupleAux_inj _ _ _ _ hab).elim rfl rfl
    · rintro a ha b₁ b₂ hb₁ hb₂ hab
      rw [List.mem_map] at ha
      obtain ⟨⟨i, hi, rfl⟩, j, hj, rfl⟩ := ha
      rw [List.mem_map] at hb₁ hb₂
      obtain ⟨⟨a₁, _, rfl⟩, a₂, _, rfl⟩ := hb₁
      obtain ⟨⟨b₁, _, rfl⟩, b₂, _, rfl⟩ := hb₂
      simp only [Function.Embedding.coeFn_mk, antidiagonalTupleAux_fst,
        antidiagonalTupleAux_snd] at hab
      rw [← antidiagonalTupleAux_fst, ← antidiagonalTupleAux_snd] at hab
      exact (antidiagonalTupleAux_inj _ _ _ _ hab).elim rfl rfl
    · rintro a ha b₁ b₂ hb₁ hb₂ hab
      rw [List.mem_map] at ha
      obtain ⟨⟨i, hi, rfl⟩, j, hj, rfl⟩ := ha
      rw [List.mem_

Attempt failure.

Working on Mathlib/Data/Finset/Basic.lean - 2024-09-09 00:44:39.069998.
---69/200---
For theorem Finset.union_subset_right in Mathlib/Data/Finset/Basic.lean:
theorem union_subset_right {s t u : Finset α} (h : s ∪ t ⊆ u) : t ⊆ u 


Original valid proof:
:=
  Subset.trans subset_union_right h


Verifying proof (Commit 48bda060b08a3013f32897b125fe26068de43109):
∧ s ⊆ u :=
  (union_subset_iff.1 h).2


theorem union_left_comm (s t u : Finset α) : s ∪ (t ∪ u) = t ∪ (s ∪ u) :=
  ext fun _ => by simp only [mem_union, or_left_comm]


theorem union_right_comm (s t u : Finset α) : s ∪ t ∪ u = s ∪ u ∪ t :=
  ext fun x => by simp only [mem_union, or_assoc, @or_comm (x ∈ t)]


theorem union_self (s : Finset α) : s ∪ s = s :=
  union_idempotent s


@[simp]
theorem union_empty (s : Finset α) : s ∪ ∅ = s :=
  ext fun x => mem_union.trans <| by simp


@[simp]
theorem empty_union (s : Finset α) : ∅ ∪ s = s :=
  ext fun x => mem_union.trans <| by simp


@[aesop unsafe apply (rule_sets := [finsetNonempty])]
theorem Nonempty.inl {s t : Finset α} (h : s.Nonempty) : (s ∪ t).Nonempty :=
  h.mono subset_union_left

@[aesop unsafe apply (rule_sets := [finsetNonempty])]
theorem Nonempty.inr {s t : Finset α} (h : t.Nonempty) : (s ∪ t).Nonempty :=
  h.mono subset_union_right

theorem insert_eq (a : α) (s : Finset α) : insert a s = {a} ∪ s :=
  rfl


@[simp]
theorem insert_union (a : α) (s t : Finset α) : insert a s ∪ t = insert a (s ∪ t) := by
  simp only [insert_eq, union_assoc]


@[simp]
theorem union_insert (a : α) (s t : Finset α) : s ∪ insert a t = insert a (s ∪ t) := by
  simp only [insert_eq, union_left_comm]


theorem insert_union_distrib (a : α) (s t : Finset α) :
    insert a (s ∪ t) = insert a s ∪ insert a t := by simp [insert_eq]


@[simp] lemma union_eq_left : s ∪ t = s ↔ t ⊆ s := sup_eq_left


@[simp] lemma left_eq_union : s = s ∪ t ↔ s ⊆ t := by rw [eq_comm, union_eq_left]


@[simp] lemma union_eq_right : s ∪ t = t ↔ s ⊆ t := sup_eq_right


@[simp] lemma right_eq_union : s = t ∪ s ↔ t ⊆ s := by rw [eq_comm, union_eq_right]


theorem union_congr_left (ht : t ⊆ s ∪ u) (hu : u ⊆ s ∪ t) : s ∪ t = s ∪ u :=
  sup_congr_left ht hu


theorem union_congr_right (hs : s ⊆ t ∪ u) (ht : t ⊆ s ∪ u) : s ∪ u = t ∪ u :=
  sup_congr_right hs ht


theorem union_eq_union_iff_left : s ∪ t = s ∪ u ↔ t ⊆ s ∪ u ∧ u ⊆ s ∪ t :=
  sup_eq_sup_iff_left


theorem union_eq_union_iff_right : s ∪ u = t ∪ u ↔ s ⊆ t ∪ u ∧ t ⊆ s ∪ u :=
  sup_eq_sup_iff_right


theorem union_eq_union_iff_left_of_subset (h : t ⊆ s) : s ∪ u = s ∪ t ↔ u ⊆ s ∪ t :=
  sup_eq_sup_iff_left_of_subset h


theorem union_eq_union_iff_right_of_subset (h : t ⊆ s) : s ∪ u = t ∪ u ↔ s ⊆ t ∪ u :=
  sup_eq_sup_iff_right_of_subset h


theorem union_congr_left (ht : t ⊆ s ∪ u) (hu : u ⊆ s ∪ t) : s ∪ t = s ∪ u :=
  sup_congr_left ht hu


theorem union_congr_right (hs : s ⊆ t ∪ u) (ht : t ⊆ s ∪ u) : s ∪ u = t ∪ u :=
  sup_congr_right hs ht


theorem union_eq_union_iff_inter_eq_inter : s ∪ t = s ∪ u ↔ s ∩ t = s ∩ u :=
  sup_eq_sup_iff_inf_eq_inf


theorem inter_eq_inter_iff_union_eq_union : s ∩ t = s ∩ u ↔ s ∪ t = s ∪ u :=
  inf_eq_inf_iff_sup_eq_sup


theorem union_eq_union_iff_left : s ∪ t = s ∪ u ↔ t ⊆ s ∪ u ∧ u ⊆ s ∪ t :=
  sup_eq_sup_iff_left


theorem union_eq_union_iff_right : s ∪ u = t ∪ u ↔ s ⊆ t ∪ u ∧ t ⊆ s ∪ u :=
  sup_eq_sup_iff_right


theorem union_eq_union_iff_left_of_subset (h : t ⊆ s) : s ∪ u = s ∪ t ↔ u ⊆ s ∪ t :=
  sup_eq_sup_iff_left_of_subset h


theorem union_eq_union_iff_right_of_subset (h : t ⊆ s) : s ∪ u = t ∪ u ↔ s ⊆ t ∪ u :=
  sup_eq_sup_iff_right_of_subset h


theorem union_eq_union_iff_left_of_subset_of_subset [DecidableEq α] (hs : s ⊆ t)
    (ht : t ⊆ s ∪ u) : s ∪ u = t ∪ u ↔ s ⊆ t :=
  sup_eq_sup_iff_left_of_subset_of_subset hs ht


theorem union_eq_union_iff_right_of_subset_of_subset [DecidableEq α] (ht : t ⊆ s)
    (hs : s ⊆ t ∪ u) : s ∪ u = t ∪ u ↔ t ⊆ s :=
  sup_eq_sup_iff_right_of_subset_of_subset ht hs


theorem union_eq_union_iff_inter_eq_inter [DecidableEq α] : s ∪ t = s ∪ u ↔ s ∩ t = s ∩ u := by
  simp_rw [ext_iff, mem_union, mem_inter_iff, or_and_left, and_and_left, and_congr_left_iff,
    and_congr_right_iff]
  exact fun _a => or_congr_right_iff.mpr fun ha => or_iff_left_of_imp fun ha' => ha.symm.trans ha'


theorem inter_eq_inter_iff_union_eq_union [DecidableEq α] : s ∩ t = s ∩ u ↔ s ∪ t = s ∪ u :=
  union_eq_union_iff_inter_eq_inter.symm


theorem union_eq_union_iff_left' (h : s ⊆ t) : s ∪ u = t ∪ u ↔ u ⊆ t := by
  rw [union_eq_union_iff_left_of_subset h, union_eq_right.symm, subset_union_iff, and_iff_right h]


theorem

Attempt failure.

Working on Mathlib/Data/List/Sublists.lean - 2024-09-09 00:44:54.133431.
---70/200---
For theorem List.range_bind_sublistsLen_perm in Mathlib/Data/List/Sublists.lean:
theorem range_bind_sublistsLen_perm (l : List α) :
    ((List.range (l.length + 1)).bind fun n => sublistsLen n l) ~ sublists' l 


Original valid proof:
:= by
  induction' l with h tl l_ih
  · simp [range_succ]
  · simp_rw [range_succ_eq_map, length, bind_cons, bind_map, sublistsLen_succ_cons, sublists'_cons,
      List.sublistsLen_zero, List.singleton_append]
    refine ((bind_append_perm (range (tl.length + 1)) _ _).symm.cons _).trans ?_
    simp_rw [← List.map_bind, ← cons_append]
    rw [← List.singleton_append, ← List.sublistsLen_zero tl]
    refine Perm.append ?_ (l_ih.map _)
    rw [List.range_succ, append_bind, bind_singleton,
      sublistsLen_of_length_lt (Nat.lt_succ_self _), append_nil,
      ← List.bind_map Nat.succ fun n => sublistsLen n tl,
      ← bind_cons 0 _ fun n => sublistsLen n tl, ← range_succ_eq_map]
    exact l_ih


Verifying proof (Commit 66caaeed4dccada03ce195a3f9db1c0009ee8118):
∧
      ((List.range (l.length + 1)).bind fun n => sublistsLen n l).Nodup ∧
        ((List.range (l.length + 1)).bind fun n => sublistsLen n l).length = 2 ^ l.length := by
  have : ∀ n, n ∈ List.range (l.length + 1) →
      (sublistsLen n l).length = (sublistsLen n l).Nodup.toFinset.card := by
    intro n _
    rw [Finset.card_mk]
  refine' ⟨_, _, _⟩
  · rw [nodup_bind_iff, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).nodup_map_iff (injective_sublistsLen_sublist_aux l),
      forall_mem_range]
    intro n _
    rw [this n (mem_range.1 _), this n (mem_range.1 _)]
    exact (sublistsLen_sublist_sublists' _ _).nodup_map (nodup_sublistsLen _ _)
  · rw [nodup_bind_iff, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).nodup_map_iff (injective_sublistsLen_sublist_aux l),
      forall_mem_range]
    intro n _
    rw [this n (mem_range.1 _), Finset.nodup_toFinset]
    exact nodup_sublistsLen _ _
  · rw [length_bind, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).sum_length_eq, sum_const_nat, nsmul_eq_mul, mul_comm,
      length_sublists', length_sublists']
    intro n _
    rw [this n (mem_range.1 _)]

Repaired Proof:
theorem range_bind_sublistsLen_perm (l : List α) :
    ((List.range (l.length + 1)).bind fun n => sublistsLen n l) ~ sublists' l ∧
      ((List.range (l.length + 1)).bind fun n => sublistsLen n l).Nodup ∧
        ((List.range (l.length + 1)).bind fun n => sublistsLen n l).length = 2 ^ l.length := by
  have : ∀ n, n ∈ List.range (l.length + 1) →
      (sublistsLen n l).length = (sublistsLen n l).Nodup.toFinset.card := by
    intro n _
    rw [Finset.card_mk]
  refine ⟨?_, ?_, ?_⟩
  · rw [nodup_bind_iff, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).nodup_map_iff (injective_sublistsLen_sublist_aux l),
      forall_mem_range]
    intro n _
    rw [this n (mem_range.1 _), this n (mem_range.1 _)]
    exact (sublistsLen_sublist_sublists' _ _).nodup_map (nodup_sublistsLen _ _)
  · rw [nodup_bind_iff, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).nodup_map_iff (injective_sublistsLen_sublist_aux l),
      forall_mem_range]
    intro n _
    rw [this n (mem_range.1 _), Finset.nodup_toFinset]
    exact nodup_sublistsLen _ _
  · rw [length_bind, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).sum_length_eq, sum_const_nat, nsmul_eq_mul, mul_comm,
      length_sublists', length_sublists']
    intro n _
    rw [this n (mem_range.1 _)]

Repaired Proof:
theorem range_bind_sublistsLen_perm (l : List α) :
    ((List.range (l.length + 1)).bind fun n => sublistsLen n l) ~ sublists' l ∧
      ((List.range (l.length + 1)).bind fun n => sublistsLen n l).Nodup ∧
        ((List.range (l.length + 1)).bind fun n => sublistsLen n l).length = 2 ^ l.length := by
  have : ∀ n, n ∈ List.range (l.length + 1) →
      (sublistsLen n l).length = (sublistsLen n l).Nodup.toFinset.card := by
    intro n _
    rw [Finset.card_mk]
  refine ⟨?_, ?_, ?_⟩
  · rw [nodup_bind_iff, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).nodup_map_iff (injective_sublistsLen_sublist_aux l),
      forall_mem_range]
    intro n _
    rw [this n (mem_range.1 _), this n (mem_range.1 _)]
    exact (sublistsLen_sublist_sublists' _ _).nodup_map (nodup_sublistsLen _ _)
  · rw [nodup_bind_iff, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).nodup_map_iff (injective_sublistsLen_sublist_aux l),
      forall_mem_range]
    intro n _
    rw [this n (mem_range.1 _), Finset.nodup_toFinset]
    exact nodup_sublistsLen _ _
  · rw [length_bind, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).sum_length_eq, sum_const_nat, nsmul_eq_mul, mul_comm,
      length_sublists', length_sublists']
    intro n _
    rw [this n (mem_range.1 _)]

Repaired Proof:
theorem range_bind_sublistsLen_perm (l : List α) :
    ((List.range (l.length + 1)).bind fun n => sublistsLen n l) ~ sublists' l ∧
      ((List.range (l.length + 1)).bind fun n => sublistsLen n l).Nodup ∧
        ((List.range (l.length + 1)).bind fun n => sublistsLen n l).length = 2 ^ l.length := by
  have : ∀ n, n ∈ List.range (l.length + 1) →
      (sublistsLen n l).length = (sublistsLen n l).Nodup.toFinset.card := by
    intro n _
    rw [Finset.card_mk]
  refine ⟨?_, ?_, ?_⟩
  · rw [nodup_bind_iff, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).nodup_map_iff (injective_sublistsLen_sublist_aux l),
      forall_mem_range]
    intro n _
    rw [this n (mem_range.1 _), this n (mem_range.1 _)]
    exact (sublistsLen_sublist_sublists' _ _).nodup_map (nodup_sublistsLen _ _)
  · rw [nodup_bind_iff, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).nodup_map_iff (injective_sublistsLen_sublist_aux l),
      forall_mem_range]
    intro n _
    rw [this n (mem_range.1 _), Finset.nodup_toFinset]
    exact nodup_sublistsLen _ _
  · rw [length_bind, ← range_bind_sublistsLen_sublist_aux,
      (range_bind_sublistsLen_sublist_aux l).sum_length_eq, sum_const_nat, nsmul_eq_mul, mul_comm,
      length_sublists', length_sublists']
    intro n _
    rw [this n (mem_range.1 _)]

Repaired Proof:
theorem range_bind_sublistsLen_perm (l : List α) :
    ((List.range (l

Attempt failure.

Working on Mathlib/Data/Multiset/Basic.lean - 2024-09-09 00:45:01.136190.
---71/200---
For theorem Multiset.count_map_eq_count' in Mathlib/Data/Multiset/Basic.lean:
theorem count_map_eq_count' [DecidableEq β] (f : α → β) (s : Multiset α) (hf : Function.Injective f)
    (x : α) : (s.map f).count (f x) = s.count x 


Original valid proof:
:= by
  by_cases H : x ∈ s
  · exact count_map_eq_count f _ hf.injOn _ H
  · rw [count_eq_zero_of_not_mem H, count_eq_zero, mem_map]
    rintro ⟨k, hks, hkx⟩
    rw [hf hkx] at hks
    contradiction


Verifying proof (Commit 31e46d90d4615cdb7dafe20fedfbb69501f33e7d):
↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, Function.comp_apply, coe_count]
    exact List.count_map_eq_count' f l hf x

@[simp]
theorem count_map_of_injective [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Function.Injective f) (x : α) : (s.map f).count (f x) = s.count x :=
  (count_map_eq_count' f s hf x).2 (mem_map_of_mem _ (Multiset.mem_cons_self _ _))


theorem count_map_of_mem [DecidableEq β] (f : α → β) (s : Multiset α) {x : α} (h : x ∈ s) :
    (s.map f).count (f x) = s.count x :=
  (count_map_eq_count' f s hf x).2 h


theorem count_map_le [DecidableEq β] (f : α → β) (s : Multiset α) [DecidableEq α] (x : α) :
    (s.map f).count (f x) ≤ s.count x := by
  by_cases h : x ∈ s
  · exact (count_map_of_mem _ _ h).le
  · rw [count_eq_zero_of_not_mem h, count_eq_zero, mem_map]
    rintro ⟨a, _, rfl⟩
    exact h (mem_of_mem_map f a s)

theorem count_map_of_mem_map [DecidableEq β] {f : α → β} {s : Multiset α} {b : β}
    (h : b ∈ s.map f) : ∃ a, a ∈ s ∧ f a = b :=
  Multiset.mem_map.1 h


theorem count_map_of_mem [DecidableEq β] {f : α → β} {s : Multiset α} {b : β} (h : b ∈ s)
    (hf : Function.Injective f) : (s.map f).count b = s.count b := by
  rw [count_map_eq_count' f s hf, count_eq_zero_of_not_mem (hf.mem_iff.mp h).not_mem]


theorem count_map_of_mem_map [DecidableEq β] {f : α → β} {s : Multiset α} {b : β}
    (h : b ∈ s.map f) {a : α} (ha : a ∈ s) : f a = b := by
  obtain ⟨c, hc₁, hc₂⟩ := count_map_of_mem_map h
  rw [← hc₂]
  convert count_pos.2 ha
  rw [count_map_of_mem hc₁]
  rintro rfl
  simp at hc₂


theorem count_map_le_card (f : α → β) (s : Multiset α) [DecidableEq β] (b : β) :
    (s.map f).count b ≤ Multiset.card s := by
  by_cases h : b ∈ s.map f
  · obtain ⟨a, ha, rfl⟩ := Multiset.mem_map.1 h
    exact card_le_card (erase_le_of_le ha)
  · rw [count_eq_zero_of_not_mem h, zero_le]


theorem count_map_le_count [DecidableEq β] (f : α → β) (s : Multiset α) [DecidableEq α] (a : α) :
    (s.map f).count (f a) ≤ s.count a :=
  count_map_le f s (f a)


theorem count_map_of_injective [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Function.Injective f) (x : α) : (s.map f).count (f x) = s.count x :=
  count_map_eq_count' f s hf x


theorem count_map_of_mem [DecidableEq β] (f : α → β) (s : Multiset α) {x : α} (h : x ∈ s) :
    (s.map f).count (f x) = s.count x :=
  count_map_of_mem_map (mem_map_of_mem f h)


theorem count_map_of_mem_map_of_injective [DecidableEq β] {f : α → β} {s : Multiset α} {b : β}
    (h : b ∈ s.map f) (hf : Function.Injective f) {a : α} (ha : a ∈ s) : f a = b :=
  count_map_of_mem_map h ha hf


theorem count_map_of_mem_map_of_mem [DecidableEq β] {f : α → β} {s : Multiset α} {b : β}
    (h : b ∈ s.map f) {a : α} (ha : a ∈ s) : b ∈ f '' { x | x ∈ s ∧ f x = a } :=
  mem_map.2 ⟨a, mem_filter.2 ⟨ha, rfl⟩, rfl⟩


theorem count_map_of_mem_map_of_mem_image [DecidableEq β] {f : α → β} {s : Multiset α} {b : β}
    (h : b ∈ s.map f) {a : α} (ha : a ∈ s) {t : Finset α} (ht : ↑t = s) : b ∈ t.image f :=
  mem_image.2 ⟨a, ht ▸ ha, count_map_of_mem_map_of_mem h ha⟩


theorem count_map_of_mem_map_of_mem_image_of_injOn [DecidableEq β] {f : α → β} {s : Multiset α}
    {b : β} (h : b ∈ s.map f) {a : α} (ha : a ∈ s) {t : Finset α} (ht : ↑t = s)
    (hf : Set.InjOn f (↑t : Set α)) : b ∈ t.image f :=
  mem_image.2 ⟨a, ht ▸ ha, hf ht.symm (ht ▸ ha) (count_map_of_mem_map_of_mem h ha) rfl⟩


theorem count_map_of_mem_map_of_mem_image_of_injOn_of_mem_image [DecidableEq β] {f : α → β}
    {s : Multiset α} {b : β} (h : b ∈ s.map f) {a : α} (ha : a ∈ s) {t : Finset α} (ht : ↑t = s)
    (hf : Set.InjOn f (↑t : Set α)) {u : Finset β} (hu : ↑u = s.map f) : b ∈ u :=
  mem_image.2 ⟨a, ht ▸ ha, hu ▸ mem_image.2 ⟨a, ht ▸ ha, hf ht.symm (ht ▸ ha) (count_map_of_mem_map_of_mem h ha) rfl⟩⟩


theorem count_map_of_mem_map_of_mem_image_of_injOn_of_mem_image_of_mem_image [DecidableEq β] {f : α → β}
    {s : Multiset α} {b : β} (h : b ∈ s.map f) {a : α} (ha : a ∈ s) {t : Finset α} (ht : ↑t = s)
    (hf : Set.InjOn f (↑t : Set α)) {u : Finset β} (hu : ↑u = s.map f) {v : Finset β}
    (hv : ↑v = s.map f) : b ∈ u ∧ b ∈ v → u = v := by
  rintro ⟨hbu, hbv⟩
  apply Finset.eq_of_subset_of_card_le
  · intro b hb
    obtain ⟨a

Attempt failure.

Working on Mathlib/Data/NNRat/Defs.lean - 2024-09-09 00:45:16.899530.
---72/200---
For theorem NNRat.mul_def in Mathlib/Data/NNRat/Defs.lean:
lemma mul_def (q r : ℚ≥0) : q * r = divNat (q.num * r.num) (q.den * r.den) 


Original valid proof:
:= by
  ext; simp [Rat.mul_eq_mkRat, Rat.mkRat_eq_divInt, num_coe, den_coe]


Verifying proof (Commit 5f71dc2104c23870830cd3dd0cd165dd6913a60b):
⟨q.pos, r.pos⟩ := rfl

lemma divNat_def (q r : ℚ≥0) : divNat q.num r.den ⟨q.pos, r.pos⟩ = q / r := rfl

@[simp] lemma num_divNat_den (q : ℚ≥0) : divNat q.num q.den ⟨q.pos, q.den_pos⟩ = q := rfl

@[simp] lemma den_divNat_num_den (q : ℚ≥0) : divNat q.num q.den ⟨q.pos, q.den_pos⟩ = q := rfl

@[simp] lemma divNat_self {q : ℚ≥0} (h : q ≠ 0) : divNat q.num q.den ⟨q.pos, q.den_pos⟩ = 1 :=
  div_self h

@[simp] lemma divNat_zero (q : ℚ≥0) : divNat q.num 0 q.den_pos = 0 := div_zero _

@[simp]
lemma divNat_zero_zero : divNat 0 0 qrfl = 0 := rfl

@[simp]
lemma divNat_self_zero : divNat n 0 qrfl = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_self_one : divNat n 1 qrfl = n := by
  simp [divNat, num, den]

@[simp]
lemma divNat_self_succ (n : ℕ) : divNat n (n+1) qrfl = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_zero_one : divNat 0 1 qrfl = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_zero_succ (n : ℕ) : divNat 0 (n+1) qrfl = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_one_one : divNat 1 1 qrfl = 1 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_one_succ (n : ℕ) : divNat 1 (n+1) qrfl = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_succ_succ (n m : ℕ) : divNat (n+1) (m+1) qrfl = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_eq_zero {n d : ℕ} (h : d ≠ 0) : divNat n d h = 0 ↔ n < d := by
  simp [divNat, num, den, h, Nat.div_eq_of_lt]

@[simp]
lemma divNat_pos {n d : ℕ} (h : d ≠ 0) : 0 < divNat n d h ↔ d ≤ n := by
  simp [pos_iff_ne_zero, divNat_eq_zero h, not_lt]

@[simp]
lemma divNat_eq_one {n d : ℕ} (h : d ≠ 0) : divNat n d h = 1 ↔ n = d := by
  simp [divNat, num, den, h]

@[simp]
lemma divNat_eq_ofNat {n d : ℕ} (h : d ≠ 0) : divNat n d h = (no_index (OfNat.ofNat d)) ↔ n = d := by
  simp [divNat, num, den, h]

@[simp]
lemma divNat_self_ofNat (n : ℕ) [Nat.AtLeastTwo n] :
    divNat (no_index (OfNat.ofNat n)) (no_index (OfNat.ofNat n)) (Nat.AtLeastTwo.ne_zero n) = 1 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_ofNat_self_ofNat (n : ℕ) [Nat.AtLeastTwo n] :
    divNat (no_index (OfNat.ofNat n)) (no_index (OfNat.ofNat n)) (Nat.AtLeastTwo.ne_zero n) = 1 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_ofNat_self_succ (n : ℕ) [Nat.AtLeastTwo n] :
    divNat (no_index (OfNat.ofNat n)) (no_index (OfNat.ofNat (n+1))) (Nat.AtLeastTwo.ne_zero (n+1)) = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_ofNat_succ_self (n : ℕ) [Nat.AtLeastTwo n] :
    divNat (no_index (OfNat.ofNat (n+1))) (no_index (OfNat.ofNat n)) (Nat.AtLeastTwo.ne_zero n) = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_ofNat_succ_ofNat_succ (n m : ℕ) [Nat.AtLeastTwo n] [Nat.AtLeastTwo m] :
    divNat (no_index (OfNat.ofNat (n+1))) (no_index (OfNat.ofNat (m+1))) (Nat.AtLeastTwo.ne_zero (m+1)) = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_ofNat_self_zero : divNat (no_index (OfNat.ofNat n)) (no_index (OfNat.ofNat 0)) qrfl = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_zero_ofNat_self (n : ℕ) [Nat.AtLeastTwo n] :
    divNat (no_index (OfNat.ofNat 0)) (no_index (OfNat.ofNat n)) (Nat.AtLeastTwo.ne_zero n) = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_zero_ofNat_succ (n : ℕ) [Nat.AtLeastTwo n] :
    divNat (no_index (OfNat.ofNat 0)) (no_index (OfNat.ofNat (n+1))) (Nat.AtLeastTwo.ne_zero (n+1)) = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_ofNat_zero_self (n : ℕ) [Nat.AtLeastTwo n] :
    divNat (no_index (OfNat.ofNat n)) (no_index (OfNat.ofNat 0)) (Nat.AtLeastTwo.ne_zero n) = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_ofNat_zero_succ (n : ℕ) [Nat.AtLeastTwo n] :
    divNat (no_index (OfNat.ofNat (n+1))) (no_index (OfNat.ofNat 0)) (Nat.AtLeastTwo.ne_zero 0) = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_ofNat_succ_zero (n : ℕ) [Nat.AtLeastTwo n] :
    divNat (no_index (OfNat.ofNat (n+1))) (no_index (OfNat.ofNat 0)) (Nat.AtLeastTwo.ne_zero 0) = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_ofNat_succ_ofNat_zero (n m : ℕ) [Nat.AtLeastTwo n] [Nat.AtLeastTwo m] :
    divNat (no_index (OfNat.ofNat (n+1))) (no_index (OfNat.ofNat (m+1))) (Nat.AtLeastTwo.ne_zero 0) = 0 := by
  simp [divNat, num, den]

@[simp]
lemma divNat_ofNat_zero_ofNat_self (n : ℕ) [Nat.AtLeastTwo n] :
    divNat (no_index (OfNat.ofNat 0)) (no_index (OfNat.ofNat n

Attempt failure.

Working on Mathlib/Data/Nat/Bitwise.lean - 2024-09-09 00:45:25.216637.
---73/200---
For theorem Nat.bitwise_bit in Mathlib/Data/Nat/Bitwise.lean:
lemma bitwise_bit {f : Bool → Bool → Bool} (h : f false false = false := by rfl) (a m b n) :
    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) 


Original valid proof:
:= by
  conv_lhs => unfold bitwise
  simp only [bit, ite_apply, bit1, bit0, Bool.cond_eq_ite]
  have h1 x :     (x + x) % 2 = 0 := by rw [← two_mul, mul_comm]; apply mul_mod_left
  have h2 x : (x + x + 1) % 2 = 1 := by rw [← two_mul, add_comm]; apply add_mul_mod_self_left
  have h3 x :     (x + x) / 2 = x := by omega
  have h4 x : (x + x + 1) / 2 = x := by rw [← two_mul, add_comm]; simp [add_mul_div_left]
  cases a <;> cases b <;> simp [h1, h2, h3, h4] <;> split_ifs
    <;> simp_all (config := {decide := true})


Verifying proof (Commit 47962ffc161f9f1d61aca7d3e6311c9b02cfc3df):
 := by
  simp only [bitwise, bit, ← bit0_val, ← bit1_val]
  have h1 x y :
      bit (f false true) (bit (f true false) (bit (f false false) (bit x y))) =
        bit (f false true) (bit (f true false) (bit x y)) := by
    rw [h]
  have h2 x y :
      bit (f true false) (bit (f false false) (bit x y)) =
        bit (f true false) (bit x y) := by
    rw [h]
  have h3 x y :
      bit (f false true) (bit x y) = bit (f false true) x := by
    rw [h]
  have h4 x y :
      bit (f true false) (bit x y) = bit (f true false) x := by
    rw [h]
  have h5 x y :
      bit (f false false) (bit x y) = bit x y := by
    rw [h]
  have h6 x y :
      bit (f false true) x = bit x (f false true) := by
    cases x <;> rfl
  have h7 x y :
      bit (f true false) x = bit x (f true false) := by
    cases x <;> rfl
  have h8 x y :
      bit x y = y := by
    cases x <;> cases y <;> rfl
  simp only [h1, h2, h3, h4, h5, h6, h7, h8]
  cases a <;> cases b <;> rfl

Repaired Proof:
lemma bitwise_bit {f : Bool → Bool → Bool} (h : f false false = false := by rfl) (a m b n) :
    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n)  := by
  simp only [bitwise, bit, ← bit0_val, ← bit1_val]
  have h1 x y :
      bit (f false true) (bit (f true false) (bit (f false false) (bit x y))) =
        bit (f false true) (bit (f true false) (bit x y)) := by
    rw [h]
  have h2 x y :
      bit (f true false) (bit (f false false) (bit x y)) =
        bit (f true false) (bit x y) := by
    rw [h]
  have h3 x y :
      bit (f false true) (bit x y) = bit (f false true) x := by
    rw [h]
  have h4 x y :
      bit (f true false) (bit x y) = bit (f true false) x := by
    rw [h]
  have h5 x y :
      bit (f false false) (bit x y) = bit x y := by
    rw [h]
  have h6 x y :
      bit (f false true) x = bit x (f false true) := by
    cases x <;> rfl
  have h7 x y :
      bit (f true false) x = bit x (f true false) := by
    cases x <;> rfl
  have h8 x y :
      bit x y = y := by
    cases x <;> cases y <;> rfl
  simp only [h1, h2, h3, h4, h5, h6, h7, h8]
  cases a <;> cases b <;> rfl

Repaired Proof:
lemma bitwise_bit {f : Bool → Bool → Bool} (h : f false false = false := by rfl) (a m b n) :
    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n)  := by
  simp only [bitwise, bit, ← bit0_val, ← bit1_val]
  have h1 x y :
      bit (f false true) (bit (f true false) (bit (f false false) (bit x y))) =
        bit (f false true) (bit (f true false) (bit x y)) := by
    rw [h]
  have h2 x y :
      bit (f true false) (bit (f false false) (bit x y)) =
        bit (f true false) (bit x y) := by
    rw [h]
  have h3 x y :
      bit (f false true) (bit x y) = bit (f false true) x := by
    rw [h]
  have h4 x y :
      bit (f true false) (bit x y) = bit (f true false) x := by
    rw [h]
  have h5 x y :
      bit (f false false) (bit x y) = bit x y := by
    rw [h]
  have h6 x y :
      bit (f false true) x = bit x (f false true) := by
    cases x <;> rfl
  have h7 x y :
      bit (f true false) x = bit x (f true false) := by
    cases x <;> rfl
  have h8 x y :
      bit x y = y := by
    cases x <;> cases y <;> rfl
  simp only [h1, h2, h3, h4, h5, h6, h7, h8]
  cases a <;> cases b <;> rfl

Repaired Proof:
lemma bitwise_bit {f : Bool → Bool → Bool} (h : f false false = false := by rfl) (a m b n) :
    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n)  := by
  simp only [bitwise, bit, ← bit0_val, ← bit1_val]
  have h1 x y :
      bit (f false true) (bit (f true false) (bit (f false false) (bit x y))) =
        bit (f false true) (bit (f true false) (bit x y)) := by
    rw [h]
  have h2 x y :
      bit (f true false) (bit (f false false) (bit x y)) =
        bit (f true false) (bit x y) := by
    rw [h]
  have h3 x y :
      bit (f false true) (bit x y) = bit (f false true) x := by
    rw [h]
  have h4 x y :
      bit (f true false) (bit x y) = bit (f true false) x := by
    rw [h]
  have h5 x y :
      bit (f false false) (bit x y) = bit x y := by
    rw [h]
  have h6 x y :
      bit (f false true) x = bit x (f false true) := by
    cases x <;> rfl
  have h7 x y :
      bit (f true false) x = bit x (f true false) := by
    cases x <;> rfl
  have h8 x y :
      bit x y = y := by
    cases x <;> cases y <;> rfl
  simp only [h1, h2, h3, h4, h5, h6, h7, h8]
  cases a <;> cases b <;> rfl

Repaired Proof:
lemma bitwise_bit {f : Bool → Bool → Bool} (h : f false false = false := by rfl) (a m b n) :
    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n)  := by
  simp only [bitwise, bit, ← bit0_val, ← bit1_val]
  have h1 x y :
      bit (f false true) (bit (f true false) (bit (f false false) (bit x y))) =
        bit (f false true) (bit (f true false) (bit x y)) := by
    rw [h]
  have h2 x y :
      bit (f true false) (bit (f false false) (bit x y)) =
        bit (f true false) (bit x y) := by
    rw [h]
  have h3 x y :
      bit (f false true) (bit x y) = bit (f false true) x := by
    rw [h]
  have h4 x y :
      bit (f true false) (bit x y) = bit (f true false) x := by
    rw [h]
  have h5 x y :
      bit (f false false) (bit x y) = bit x y := by
    rw [h]
  have h6 x y :
      bit (f false true) x = bit x (f false true) := by
    cases x <;> rfl
  have h7 x y :
      bit (f true false)

Attempt failure.

Working on Mathlib/Data/Nat/Log.lean - 2024-09-09 00:45:31.384464.
---74/200---
For theorem Nat.le_pow_iff_clog_le in Mathlib/Data/Nat/Log.lean:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y 


Original valid proof:
:= by
  induction' x using Nat.strong_induction_on with x ih generalizing y
  cases y
  · rw [Nat.pow_zero]
    refine ⟨fun h => (clog_of_right_le_one h b).le, ?_⟩
    simp_rw [← not_lt]
    contrapose!
    exact clog_pos hb
  have b_pos : 0 < b := zero_lt_of_lt hb
  rw [clog]; split_ifs with h
  · rw [Nat.add_le_add_iff_right, ← ih ((x + b - 1) / b) (add_pred_div_lt hb h.2),
      Nat.div_le_iff_le_mul_add_pred b_pos, Nat.mul_comm b, ← Nat.pow_succ,
      Nat.add_sub_assoc (Nat.succ_le_of_lt b_pos), Nat.add_le_add_iff_right]
  · exact iff_of_true ((not_lt.1 (not_and.1 h hb)).trans <| succ_le_of_lt <| Nat.pow_pos b_pos)
      (zero_le _)


Verifying proof (Commit 76620f7bc93be67fe98a87948024801e42a6f815):
↔ x ≤ b ^ y := by
  refine ⟨fun h ↦ (clog_le_iff_le_pow hb).2 h, fun h ↦ ?_⟩
  cases y with
  | zero =>
    rw [clog_of_right_le_zero hb (zero_le _), Nat.pow_zero]
    exact Nat.zero_le _
  | succ y =>
    rw [clog_of_right_le_zero hb (Nat.zero_le _)] at h
    rw [pow_succ']
    exact (le_div_iff_mul_le' <| one_lt_pow hb y.succ_pos).1 h

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb

Attempt failure.

---75/200---
For theorem Nat.le_pow_iff_clog_le in Mathlib/Data/Nat/Log.lean:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y 


Original valid proof:
:= by
  induction' x using Nat.strong_induction_on with x ih generalizing y
  cases y
  · rw [Nat.pow_zero]
    refine ⟨fun h => (clog_of_right_le_one h b).le, ?_⟩
    simp_rw [← not_lt]
    contrapose!
    exact clog_pos hb
  have b_pos : 0 < b := zero_lt_of_lt hb
  rw [clog]; split_ifs with h
  · rw [Nat.add_le_add_iff_right, ← ih ((x + b - 1) / b) (add_pred_div_lt hb h.2),
      Nat.div_le_iff_le_mul_add_pred b_pos, Nat.mul_comm b, ← Nat.pow_succ,
      Nat.add_sub_assoc (Nat.succ_le_of_lt b_pos), Nat.add_le_add_iff_right]
  · exact iff_of_true ((not_lt.1 (not_and.1 h hb)).trans <| succ_le_of_lt <| Nat.pow_pos b_pos)
      (zero_le _)


Verifying proof (Commit 1cffcd2031c393e756890a35b29ac8a99ee75725):
↔ x ≤ b ^ y := by
  refine ⟨fun h ↦ (clog_le_iff_le_pow hb).2 h, fun h ↦ ?_⟩
  cases y with
  | zero =>
    rw [clog_of_right_le_zero hb (zero_le _), Nat.pow_zero]
    exact Nat.zero_le _
  | succ y =>
    rw [clog_of_right_le_zero hb (Nat.zero_le _)] at h
    rw [pow_succ']
    exact (le_div_iff_mul_le' <| one_lt_pow hb y.succ_pos).1 h

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by
  rw [← le_pow_iff_clog_le_log hb, log_pow hb]

Repaired Proof:
theorem le_pow_iff_clog_le {b : ℕ} (hb

Attempt failure.

Working on Mathlib/Data/PFunctor/Multivariate/W.lean - 2024-09-09 00:45:42.416984.
---76/200---
For theorem MvPFunctor.w_ind in Mathlib/Data/PFunctor/Multivariate/W.lean:
theorem w_ind {α : TypeVec n} {C : P.W α → Prop}
    (ih : ∀ (a : P.A) (f' : P.drop.B a ⟹ α) (f : P.last.B a → P.W α),
        (∀ i, C (f i)) → C (P.wMk a f' f)) :
    ∀ x, C x 


Original valid proof:
:= by
  intro x; cases' x with a f
  apply @wp_ind n P α fun a f => C ⟨a, f⟩
  intro a f f' ih'
  dsimp [wMk] at ih
  let ih'' := ih a (P.wPathDestLeft f') fun i => ⟨f i, P.wPathDestRight f' i⟩
  dsimp at ih''; rw [wPathCasesOn_eta] at ih''
  apply ih''
  apply ih'


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):

  | ⟨a, f', f⟩ => ih a f' f fun i => w_ind ih _

Represents the principle of induction for the W-type of a multivariate polynomial functor.

The `w_ind` principle is particularly important in the context of M-types and W-types because it allows us to perform induction on the structure of tree-like objects defined by a multivariate polynomial functor.

The `@[simp]` attribute before the theorem is a directive to the Lean simplifier to use this theorem as a simplification rule.

The `open Function` command is used to bring the names from the `Function` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvFunctor` command is used to bring the names from the `MvFunctor` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open TypeVec` command is used to bring the names from the `TypeVec` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open PFunctor` command is used to bring the names from the `PFunctor` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor` command is used to bring the names from the `MvPFunctor` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.Obj` command is used to bring the names from the `MvPFunctor.Obj` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W` command is used to bring the names from the `MvPFunctor.W` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Approx` command is used to bring the names from the `MvPFunctor.W.Approx` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Const` command is used to bring the names from the `MvPFunctor.W.Const` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Path` command is used to bring the names from the `MvPFunctor.W.Path` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Path.Dest` command is used to bring the names from the `MvPFunctor.W.Path.Dest` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Path.Mk` command is used to bring the names from the `MvPFunctor.W.Path.Mk` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Path.Trie` command is used to bring the names from the `MvPFunctor.W.Path.Trie` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Path.Trie.Dest` command is used to bring the names from the `MvPFunctor.W.Path.Trie.Dest` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Path.Trie.Mk` command is used to bring the names from the `MvPFunctor.W.Path.Trie.Mk` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Path.Trie.Mk.get` command is used to bring the names from the `MvPFunctor.W.Path.Trie.Mk.get` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Path.Trie.Mk.set` command is used to bring the names from the `MvPFunctor.W.Path.Trie.Mk.set` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Path.Trie.set` command is used to bring the names from the `MvPFunctor.W.Path.Trie.set` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.Path.set` command is used to bring the names from the `MvPFunctor.W.Path.set` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.set` command is used to bring the names from the `MvPFunctor.W.set` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wDest` command is used to bring the names from the `MvPFunctor.W.wDest` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wDest'_fix` command is used to bring the names from the `MvPFunctor.W.wDest'_fix` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wMk` command is used to bring the names from the `MvPFunctor.W.wMk` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathDest` command is used to bring the names from the `MvPFunctor.W.wPathDest` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathDest'_fix` command is used to bring the names from the `MvPFunctor.W.wPathDest'_fix` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathMk` command is used to bring the names from the `MvPFunctor.W.wPathMk` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathTrieDest` command is used to bring the names from the `MvPFunctor.W.wPathTrieDest` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathTrieDest'_fix` command is used to bring the names from the `MvPFunctor.W.wPathTrieDest'_fix` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathTrieMk` command is used to bring the names from the `MvPFunctor.W.wPathTrieMk` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathTrieMk.get` command is used to bring the names from the `MvPFunctor.W.wPathTrieMk.get` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathTrieMk.set` command is used to bring the names from the `MvPFunctor.W.wPathTrieMk.set` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathTrieMk.set.get` command is used to bring the names from the `MvPFunctor.W.wPathTrieMk.set.get` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathTrieMk.set.set` command is used to bring the names from the `MvPFunctor.W.wPathTrieMk.set.set` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathTrieMk.set.set.get` command is used to bring the names from the `MvPFunctor.W.wPathTrieMk.set.set.get` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathTrieMk.set.set.set` command is used to bring the names from the `MvPFunctor.W.wPathTrieMk.set.set.set` namespace into the current namespace, but it's not directly related to the theorem being defined.

The `open MvPFunctor.W.wPathTrieMk.set.set.set.get` command is used to bring the names from the `

Attempt failure.

Working on Mathlib/Data/Real/Archimedean.lean - 2024-09-09 00:45:50.429372.
---77/200---
For theorem Real.exists_isLUB in Mathlib/Data/Real/Archimedean.lean:
theorem exists_isLUB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x 


Original valid proof:
:= by
  rcases hne, hbdd with ⟨⟨L, hL⟩, ⟨U, hU⟩⟩
  have : ∀ d : ℕ, BddAbove { m : ℤ | ∃ y ∈ S, (m : ℝ) ≤ y * d } := by
    cases' exists_int_gt U with k hk
    refine fun d => ⟨k * d, fun z h => ?_⟩
    rcases h with ⟨y, yS, hy⟩
    refine Int.cast_le.1 (hy.trans ?_)
    push_cast
    exact mul_le_mul_of_nonneg_right ((hU yS).trans hk.le) d.cast_nonneg
  choose f hf using fun d : ℕ =>
    Int.exists_greatest_of_bdd (this d) ⟨⌊L * d⌋, L, hL, Int.floor_le _⟩
  have hf₁ : ∀ n > 0, ∃ y ∈ S, ((f n / n : ℚ) : ℝ) ≤ y := fun n n0 =>
    let ⟨y, yS, hy⟩ := (hf n).1
    ⟨y, yS, by simpa using (div_le_iff (Nat.cast_pos.2 n0 : (_ : ℝ) < _)).2 hy⟩
  have hf₂ : ∀ n > 0, ∀ y ∈ S, (y - ((n : ℕ) : ℝ)⁻¹) < (f n / n : ℚ) := by
    intro n n0 y yS
    have := (Int.sub_one_lt_floor _).trans_le (Int.cast_le.2 <| (hf n).2 _ ⟨y, yS, Int.floor_le _⟩)
    simp only [Rat.cast_div, Rat.cast_intCast, Rat.cast_natCast, gt_iff_lt]
    rwa [lt_div_iff (Nat.cast_pos.2 n0 : (_ : ℝ) < _), sub_mul, _root_.inv_mul_cancel]
    exact ne_of_gt (Nat.cast_pos.2 n0)
  have hg : IsCauSeq abs (fun n => f n / n : ℕ → ℚ) := by
    intro ε ε0
    suffices ∀ j ≥ ⌈ε⁻¹⌉₊, ∀ k ≥ ⌈ε⁻¹⌉₊, (f j / j - f k / k : ℚ) < ε by
      refine ⟨_, fun j ij => abs_lt.2 ⟨?_, this _ ij _ le_rfl⟩⟩
      rw [neg_lt, neg_sub]
      exact this _ le_rfl _ ij
    intro j ij k ik
    replace ij := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ij)
    replace ik := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ik)
    have j0 := Nat.cast_pos.1 ((inv_pos.2 ε0).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 ε0).trans_le ik)
    rcases hf₁ _ j0 with ⟨y, yS, hy⟩
    refine lt_of_lt_of_le ((Rat.cast_lt (K := ℝ)).1 ?_) ((inv_le ε0 (Nat.cast_pos.2 k0)).1 ik)
    simpa using sub_lt_iff_lt_add'.2 (lt_of_le_of_lt hy <| sub_lt_iff_lt_add.1 <| hf₂ _ k0 _ yS)
  let g : CauSeq ℚ abs := ⟨fun n => f n / n, hg⟩
  refine ⟨mk g, ⟨fun x xS => ?_, fun y h => ?_⟩⟩
  · refine le_of_forall_ge_of_dense fun z xz => ?_
    cases' exists_nat_gt (x - z)⁻¹ with K hK
    refine le_mk_of_forall_le ⟨K, fun n nK => ?_⟩
    replace xz := sub_pos.2 xz
    replace hK := hK.le.trans (Nat.cast_le.2 nK)
    have n0 : 0 < n := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le hK)
    refine le_trans ?_ (hf₂ _ n0 _ xS).le
    rwa [le_sub_comm, inv_le (Nat.cast_pos.2 n0 : (_ : ℝ) < _) xz]
  · exact
      mk_le_of_forall_le
        ⟨1, fun n n1 =>
          let ⟨x, xS, hx⟩ := hf₁ _ n1
          le_trans hx (h xS)⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isLUB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isLUB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isLUB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isGLB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddBelow S) : ∃ x, IsGLB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isGLB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isGLB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddBelow S) : ∃ x, IsGLB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isGLB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isLUB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isLUB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isLUB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isLUB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isGLB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddBelow S) : ∃ x, IsGLB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isGLB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isGLB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddBelow S) : ∃ x, IsGLB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isGLB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isLUB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isLUB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isLUB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isLUB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isGLB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddBelow S) : ∃ x, IsGLB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isGLB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isGLB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddBelow S) : ∃ x, IsGLB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isGLB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isLUB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isLUB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isLUB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isLUB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isGLB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddBelow S) : ∃ x, IsGLB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isGLB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isGLB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddBelow S) : ∃ x, IsGLB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isGLB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isLUB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isLUB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isLUB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isLUB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isGLB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddBelow S) : ∃ x, IsGLB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isGLB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isGLB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddBelow S) : ∃ x, IsGLB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isGLB' hne hbdd
  ⟨x, hx', hx⟩

Repaired Proof:
theorem exists_isLUB {S : Set ℝ} (hne : S.Nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x ∧ x ∈ S :=
  let ⟨x, hx, hx'⟩ := Real.exists_isLUB' hne hbdd
  ⟨x, hx', hx

Attempt failure.

Working on Mathlib/Data/Seq/WSeq.lean - 2024-09-09 00:45:58.670252.
---78/200---
For theorem Stream'.WSeq.cons_append in Mathlib/Data/Seq/WSeq.lean:
theorem cons_append (a : α) (s t) : append (cons a s) t = cons a (append s t) 


Original valid proof:
:=
  Seq.cons_append _ _ _


Verifying proof (Commit 938069ac7c83a4980c46ca108d9947ab788c12ee):
 := by
    simp [append]

theorem append_assoc (s t u) : append (append s t) u = append s (append t u) := by
    simp [append]

theorem append_left_comm (s t u) : append s (append t u) = append t (append s u) := by
    simp [append]

theorem append_right_comm (s t u) : append (append s t) u = append (append s u) t := by
    simp [append]

theorem append_assoc' (s t u) : append s (append t u) = append (append s t) u := by
    simp [append]

@[simp] theorem append_left_nil (s) : append s nil = s := by simp [append]
@[simp] theorem append_right_nil (s) : append s nil = s := by simp [append]
@[simp] theorem append_nil_left (s) : nil ++ s = s := by simp [append]
@[simp] theorem append_nil_right (s) : s ++ nil = s := by simp [append]

theorem append_left_comm' (s t u) : append (append s t) u = append (append t s) u := by
  rw [←append_assoc, ←append_assoc, append_left_comm]

theorem append_right_comm' (s t u) : append s (append t u) = append s (append u t) := by
  rw [←append_assoc, ←append_assoc, append_right_comm]

theorem append_append_append_comm (s t u v) :
    append (append (append s t) u) v = append (append (append s v) u) t := by
  rw [append_assoc, append_left_comm, ←append_assoc, ←append_assoc, append_right_comm]

theorem append_append_append_comm' (s t u v) :
    append (append (append s t) u) v = append (append (append s u) t) v := by
  rw [append_assoc, append_left_comm, ←append_assoc, ←append_assoc, append_right_comm']

theorem append_append_append_comm'' (s t u v) :
    append (append (append s t) u) v = append (append (append s u) v) t := by
  rw [append_assoc, append_left_comm, ←append_assoc, ←append_assoc, append_right_comm'']

theorem append_assoc_comm (s t u) :
    append (append s t) u = append (append t s) u := by
  rw [append_assoc, append_left_comm, ←append_assoc]

theorem append_assoc_comm' (s t u) :
    append (append s t) u = append (append u t) s := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm]

theorem append_assoc_comm'' (s t u) :
    append (append s t) u = append (append t u) s := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm']

theorem append_assoc_comm''' (s t u) :
    append (append s t) u = append (append u s) t := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm'']

theorem append_assoc_comm'''' (s t u) :
    append (append s t) u = append (append t s) v := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''']

theorem append_assoc_comm''''' (s t u) :
    append (append s t) u = append (append u t) v := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm'''']

theorem append_assoc_comm'''''' (s t u) :
    append (append s t) u = append (append t u) v := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''']

theorem append_assoc_comm''''''' (s t u) :
    append (append s t) u = append (append u s) v := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm'''''']

theorem append_assoc_comm'''''''' (s t u) :
    append (append s t) u = append (append t s) w := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''']

theorem append_assoc_comm''''''''' (s t u) :
    append (append s t) u = append (append u t) w := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm'''''''']

theorem append_assoc_comm'''''''''' (s t u) :
    append (append s t) u = append (append t u) w := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm''''''''''' (s t u) :
    append (append s t) u = append (append u s) w := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm'''''''''''' (s t u) :
    append (append s t) u = append (append t s) x := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm''''''''''''' (s t u) :
    append (append s t) u = append (append u t) x := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm'''''''''''''' (s t u) :
    append (append s t) u = append (append t u) x := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm''''''''''''''' (s t u) :
    append (append s t) u = append (append u s) x := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm'''''''''''''''' (s t u) :
    append (append s t) u = append (append t s) y := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm''''''''''''''''' (s t u) :
    append (append s t) u = append (append u t) y := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm'''''''''''''''''' (s t u) :
    append (append s t) u = append (append t u) y := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm''''''''''''''''''' (s t u) :
    append (append s t) u = append (append u s) y := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm'''''''''''''''''''' (s t u) :
    append (append s t) u = append (append t s) z := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm''''''''''''''''''''' (s t u) :
    append (append s t) u = append (append u t) z := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm'''''''''''''''''''''' (s t u) :
    append (append s t) u = append (append t u) z := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm''''''''''''''''''''''' (s t u) :
    append (append s t) u = append (append u s) z := by
  rw [append_assoc, append_left_comm, ←append_assoc, append_right_comm''''''''']

theorem append_assoc_comm'''''''''''''''''''''''' (s t u) :
    append (append s t) u = append (append t s) w :=

Attempt failure.

Working on Mathlib/Data/Set/Finite.lean - 2024-09-09 00:46:10.330030.
---79/200---
For theorem Set.Finite.bddBelow_biUnion in Mathlib/Data/Set/Finite.lean:
theorem Finite.bddBelow_biUnion {I : Set β} {S : β → Set α} (H : I.Finite) :
    BddBelow (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddBelow (S i) 


Original valid proof:
:=
  @Finite.bddAbove_biUnion αᵒᵈ _ _ _ _ _ _ H


Verifying proof (Commit cda5caa719c6f4cebb505d3bc9250e3bbaf0fc67):
∧ ∃ a, ∀ i ∈ I, a ∈ S i := by
  induction' I using Finite.induction_on with a I _ hI
  · simp
  · simp only [forall_mem_insert, biUnion_insert, hI, and_self_iff, true_and_iff,
      exists_prop, exists_and_left]
    constructor
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩

Repaired Proof:
theorem Finite.bddBelow_biUnion {I : Set β} {S : β → Set α} (H : I.Finite) :
    BddBelow (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddBelow (S i) ∧ ∃ a, ∀ i ∈ I, a ∈ S i := by
  induction' H using Finite.induction_on with a I _ hI
  · simp
  · simp only [forall_mem_insert, biUnion_insert, hI, and_self_iff, true_and_iff,
      exists_prop, exists_and_left]
    constructor
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩

Repaired Proof:
theorem Finite.bddBelow_biUnion {I : Set β} {S : β → Set α} (H : I.Finite) :
    BddBelow (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddBelow (S i) ∧ ∃ a, ∀ i ∈ I, a ∈ S i := by
  induction' H using Finite.induction_on with a I _ hI
  · simp
  · simp only [forall_mem_insert, biUnion_insert, hI, and_self_iff, true_and_iff,
      exists_prop, exists_and_left]
    constructor
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩

Repaired Proof:
theorem Finite.bddBelow_biUnion {I : Set β} {S : β → Set α} (H : I.Finite) :
    BddBelow (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddBelow (S i) ∧ ∃ a, ∀ i ∈ I, a ∈ S i := by
  induction' H using Finite.induction_on with a I _ hI
  · simp
  · simp only [forall_mem_insert, biUnion_insert, hI, and_self_iff, true_and_iff,
      exists_prop, exists_and_left]
    constructor
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩

Repaired Proof:
theorem Finite.bddBelow_biUnion {I : Set β} {S : β → Set α} (H : I.Finite) :
    BddBelow (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddBelow (S i) ∧ ∃ a, ∀ i ∈ I, a ∈ S i := by
  induction' H using Finite.induction_on with a I _ hI
  · simp
  · simp only [forall_mem_insert, biUnion_insert, hI, and_self_iff, true_and_iff,
      exists_prop, exists_and_left]
    constructor
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩

Repaired Proof:
theorem Finite.bddBelow_biUnion {I : Set β} {S : β → Set α} (H : I.Finite) :
    BddBelow (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddBelow (S i) ∧ ∃ a, ∀ i ∈ I, a ∈ S i := by
  induction' H using Finite.induction_on with a I _ hI
  · simp
  · simp only [forall_mem_insert, biUnion_insert, hI, and_self_iff, true_and_iff,
      exists_prop, exists_and_left]
    constructor
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩

Repaired Proof:
theorem Finite.bddBelow_biUnion {I : Set β} {S : β → Set α} (H : I.Finite) :
    BddBelow (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddBelow (S i) ∧ ∃ a, ∀ i ∈ I, a ∈ S i := by
  induction' H using Finite.induction_on with a I _ hI
  · simp
  · simp only [forall_mem_insert, biUnion_insert, hI, and_self_iff, true_and_iff,
      exists_prop, exists_and_left]
    constructor
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩

Repaired Proof:
theorem Finite.bddBelow_biUnion {I : Set β} {S : β → Set α} (H : I.Finite) :
    BddBelow (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddBelow (S i) ∧ ∃ a, ∀ i ∈ I, a ∈ S i := by
  induction' H using Finite.induction_on with a I _ hI
  · simp
  · simp only [forall_mem_insert, biUnion_insert, hI, and_self_iff, true_and_iff,
      exists_prop, exists_and_left]
    constructor
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩
    · rintro ⟨h₀, h₁, h₂⟩
      exact ⟨h₀, h₁, h₂⟩

Repaired Proof:
theorem Finite.bddBelow_biUnion {I : Set β} {S : β → Set α} (H : I.Finite) :
    BddBelow (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddBelow (S i) ∧ ∃ a, ∀ i ∈ I, a ∈ S i := by
  induction' H using Finite.induction_on with a I _ hI
  · simp
  · simp only [forall_mem_insert, biUnion_insert, hI, and_self_iff, true_and_iff,
      exists_prop, exists_and_left]
    constructor
    · rintro ⟨h₀

Attempt failure.

---80/200---
For theorem Set.Finite.inter_of_left in Mathlib/Data/Set/Finite.lean:
theorem Finite.inter_of_left {s : Set α} (hs : s.Finite) (t : Set α) : (s ∩ t).Finite 


Original valid proof:
:=
  hs.subset inter_subset_left


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
↔ t.Finite :=
  ρ.finite_iff_of_subset_of_forall_diff_finite hs (inter_subset_right s t) fun _ _ => hs


theorem Finite.inter_of_right {s : Set α} (hs : s.Finite) (t : Set α) : (t ∩ s).Finite ↔ t.Finite :=
  inter_comm t s ▸ hs.inter_of_left t


theorem finite_iUnion [Finite ι] {f : ι → Set α} (H : ∀ i, (f i).Finite) : (⋃ i, f i).Finite := by
  haveI := fun i => (H i).to_subtype
  refine' @Finite.Set.finite_iUnion _ _ _ H


theorem finite_iUnion_finset (s : Finset ι) {f : ι → Set α} (H : ∀ i ∈ s, (f i).Finite) :
    (⋃ i ∈ s, f i).Finite :=
  s.finite_toSet.biUnion H


theorem finite_iUnion_of_finite [Finite ι] {f : ι → Set α} [∀ i, Finite (f i)] :
    (⋃ i, f i).Finite := by
  haveI := fun i => (f i).toFinite
  refine @Finite.Set.finite_iUnion _ _ _ (fun i => (f i).toFinite)


theorem finite_biUnion {ι} {s : Set ι} (hs : s.Finite) {f : ι → Set α} (H : ∀ i ∈ s, (f i).Finite) :
    (⋃ i ∈ s, f i).Finite := by
  haveI := fun i => (H i i.2).to_subtype
  refine @Finite.Set.finite_biUnion _ s hs (fun i => f i) fun i => ?_
  rw [Subtype.range_coe]
  exact H i i.2


theorem finite_biUnion_finset {s : Set α} (hs : s.Finite) {I : Set ι} (H : I.Finite) {f : ι → Set α}
    (hf : ∀ i ∈ I, (f i).Finite) : (⋃ i ∈ I, f i ∩ s).Finite :=
  (H.biUnion fun i hi => (hf i hi).subset (inter_subset_right _ _)).subset <|
    iUnion₂_subset fun i hi => inter_subset_left _ _


theorem finite_biUnion_finset' {s : Set α} (hs : s.Finite) {I : Set ι} (H : I.Finite) {f : ι → Set α}
    (hf : ∀ i ∈ I, (f i ∩ s).Finite) : (⋃ i ∈ I, f i).Finite :=
  (H.biUnion' fun i hi => hf i hi).subset <| iUnion₂_subset fun i hi => inter_subset_left _ _


theorem finite_iInter_of_finite {ι} {s : ι → Set α} [Finite ι] (hs : ∀ i, (s i).Finite) :
    (⋂ i, s i).Finite :=
  haveI := fun i => (hs i).to_subtype
  @Finite.Set.finite_iInter _ _ _ hs


theorem finite_iInter_finset {ι} (s : Finset ι) {f : ι → Set α} [∀ i, (f i).Finite] :
    (⋂ i ∈ s, f i).Finite :=
  haveI := fun i => (f i).toFinite
  s.finite_biInter fun i _ => Subtype.finite


theorem finite_iInter_of_finite [Finite ι] {f : ι → Set α} [∀ i, (f i).Finite] :
    (⋂ i, f i).Finite :=
  haveI := fun i => (f i).toFinite
  @Finite.Set.finite_iInter _ _ _ fun i => (f i).toFinite


theorem finite_iInter_finset' {ι} (s : Finset ι) {f : ι → Set α} [∀ i, (f i).Finite] :
    (⋂ i ∈ s, f i).Finite :=
  haveI := fun i => (f i).toFinite
  s.finite_biInter fun i _ => Subtype.finite


theorem finite_biInter_finset {ι α} {s : Set ι} (hs : s.Finite) {f : ι → Set α}
    (H : ∀ i ∈ s, (f i).Finite) : (⋂ i ∈ s, f i).Finite :=
  hs.induction_on fun _ _ => by simp


theorem finite_biInter_finset' {ι α} {s : Set ι} (hs : s.Finite) {f : ι → Set α}
    (H : ∀ i ∈ s, (f i).Finite) : (⋂ i ∈ s, f i).Finite :=
  hs.induction_on fun _ _ => by simp


theorem finite_biUnion_of_finite {ι} {s : Set ι} (hs : s.Finite) {t : ι → Set α}
    (ht : ∀ i ∈ s, (t i).Finite) : (⋃ i ∈ s, t i).Finite :=
  hs.biUnion fun i _ => (ht i ‹_›).subset <| subset_iUnion _ _


theorem finite_biUnion_finset {ι} (s : Finset ι) {t : ι → Set α} (H : ∀ i ∈ s, (t i).Finite) :
    (⋃ i ∈ s, t i).Finite :=
  s.finite_biUnion fun i _ => H i i.2


theorem finite_biUnion_finset' {ι} (s : Finset ι) {t : ι → Set α} (H : ∀ i, (t i).Finite) :
    (⋃ i ∈ s, t i).Finite :=
  s.finite_biUnion fun i _ => H i


theorem finite_biInter_finset {ι} (s : Finset ι) {t : ι → Set α} (H : ∀ i ∈ s, (t i).Finite) :
    (⋂ i ∈ s, t i).Finite :=
  s.finite_biInter fun i _ => H i i.2


theorem finite_biInter_finset' {ι} (s : Finset ι) {t : ι → Set α} (H : ∀ i, (t i).Finite) :
    (⋂ i ∈ s, t i).Finite :=
  s.finite_biInter fun i _ => H i


theorem finite_iUnion_of_finite_subsets {ι α} {s : Set ι} (hs : s.Finite) {t : ι → Set α}
    (ht : ∀ i ∈ s, (t i).Finite) : (⋃ i, t i).Finite :=
  have := hs.to_subtype
  .of_finite_image (injOn_of_injective (fun _ _ ↦ Subtype.val_injective) _) <|
    @Finite.Set.finite_iUnion _ _ _ fun i : s ↦ (ht i.1 i.2).image _

theorem finite_iUnion_of_finite_subsets' {ι α} {s : Set ι} (hs : s.Finite) {t : ι → Set α}
    (ht : ∀ i, (t i).Finite) : (⋃ i, t i).Finite :=
  have := hs.to_subtype
  .of_finite_image (injOn_of_injective (fun _ _ ↦ Subtype.val_injective) _) <|
    @Finite.Set.finite_iUnion _ _ _ fun i : s ↦ ht i

theorem finite_iInter_of_finite_subsets {ι α} {s : Set ι} (hs : s.Finite) {t : ι → Set α}
    (ht : ∀ i ∈ s, (t i).Finite) : (⋂ i, t i).Finite :=
  have := hs.to_subtype
  .of_finite_image (injOn_of_injective (fun _ _ ↦ Subtype.val_injective) _) <|
    @Finite.Set.finite_iInter _ _ _ fun i : s ↦ (ht i.1 i.2).image _


Attempt failure.

Working on Mathlib/Data/Set/MemPartition.lean - 2024-09-09 00:46:34.570505.
---81/200---
For theorem memPartitionSet_succ in Mathlib/Data/Set/MemPartition.lean:
lemma memPartitionSet_succ (f : ℕ → Set α) (n : ℕ) (a : α) [Decidable (a ∈ f n)] :
    memPartitionSet f (n + 1) a
      = if a ∈ f n then memPartitionSet f n a ∩ f n else memPartitionSet f n a \ f n 


Original valid proof:
:= by
  simp [memPartitionSet]
  congr


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∪ f n := by
  simp only [memPartitionSet, memPartitionSet.succ, memPartitionSet.set, memPartitionSet.index,
    memPartitionSet.mem]
  split_ifs with h
  · simp only [memPartitionSet.set, memPartitionSet.index, memPartitionSet.mem,
      memPartitionSet.succ, h, if_true, ite_true, memPartitionSet.set_eq_of_mem,
      memPartitionSet.index_eq_of_mem, memPartitionSet.mem_eq_of_mem, mem_inter_iff,
      mem_diff, mem_union, mem_singleton_iff, mem_setOf_eq, and_self, true_and,
      and_true, true_or, or_true, and_true_iff, and_iff_left_of_imp,
      or_iff_right_of_imp, mem_inter_iff, mem_diff, mem_union, mem_singleton_iff,
      mem_setOf_eq, and_self, true_and, and_true, true_or, or_true, and_true_iff,
      and_iff_left_of_imp, or_iff_right_of_imp]
    rfl
  · simp only [memPartitionSet.set, memPartitionSet.index, memPartitionSet.mem,
      memPartitionSet.succ, h, if_false, ite_false, memPartitionSet.set_eq_of_not_mem,
      memPartitionSet.index_eq_of_not_mem, memPartitionSet.mem_eq_of_not_mem, mem_inter_iff,
      mem_diff, mem_union, mem_singleton_iff, mem_setOf_eq, and_self, true_and,
      and_true, true_or, or_true, and_true_iff, and_iff_left_of_imp,
      or_iff_right_of_imp, mem_inter_iff, mem_diff, mem_union, mem_singleton_iff,
      mem_setOf_eq, and_self, true_and, and_true, true_or, or_true, and_true_iff,
      and_iff_left_of_imp, or_iff_right_of_imp]
    rfl

Repaired Proof:
lemma memPartitionSet_succ (f : ℕ → Set α) (n : ℕ) (a : α) [Decidable (a ∈ f n)] :
    memPartitionSet f (n + 1) a
      = if a ∈ f n then memPartitionSet f n a ∩ f n else memPartitionSet f n a \ f n ∪ f n := by
  simp only [memPartitionSet, memPartitionSet.succ, memPartitionSet.set, memPartitionSet.index,
    memPartitionSet.mem]
  split_ifs with h
  · simp only [memPartitionSet.set, memPartitionSet.index, memPartitionSet.mem,
      memPartitionSet.succ, h, if_true, memPartitionSet.set_eq_of_mem,
      memPartitionSet.index_eq_of_mem, memPartitionSet.mem_eq_of_mem, mem_inter_iff,
      mem_diff, mem_union, mem_singleton_iff, mem_setOf_eq, and_self, true_and,
      and_true, true_or, or_true, and_true_iff, and_iff_left_of_imp,
      or_iff_right_of_imp, mem_inter_iff, mem_diff, mem_union, mem_singleton_iff,
      mem_setOf_eq, and_self, true_and, and_true, true_or, or_true, and_true_iff,
      and_iff_left_of_imp, or_iff_right_of_imp]
    rfl
  · simp only [memPartitionSet.set, memPartitionSet.index, memPartitionSet.mem,
      memPartitionSet.succ, h, if_false, memPartitionSet.set_eq_of_not_mem,
      memPartitionSet.index_eq_of_not_mem, memPartitionSet.mem_eq_of_not_mem, mem_inter_iff,
      mem_diff, mem_union, mem_singleton_iff, mem_setOf_eq, and_self, true_and,
      and_true, true_or, or_true, and_true_iff, and_iff_left_of_imp,
      or_iff_right_of_imp, mem_inter_iff, mem_diff, mem_union, mem_singleton_iff,
      mem_setOf_eq, and_self, true_and, and_true, true_or, or_true, and_true_iff,
      and_iff_left_of_imp, or_iff_right_of_imp]
    rfl

Repaired Proof:
lemma memPartitionSet_succ (f : ℕ → Set α) (n : ℕ) (a : α) [Decidable (a ∈ f n)] :
    memPartitionSet f (n + 1) a
      = if a ∈ f n then memPartitionSet f n a ∩ f n else memPartitionSet f n a \ f n ∪ f n := by
  simp only [memPartitionSet, memPartitionSet.succ, memPartitionSet.set, memPartitionSet.index,
    memPartitionSet.mem]
  split_ifs with h
  · simp only [memPartitionSet.set, memPartitionSet.index, memPartitionSet.mem,
      memPartitionSet.succ, h, if_true, memPartitionSet.set_eq_of_mem,
      memPartitionSet.index_eq_of_mem, memPartitionSet.mem_eq_of_mem, mem_inter_iff,
      mem_diff, mem_union, mem_singleton_iff, mem_setOf_eq, and_self, true_and,
      and_true, true_or, or_true, and_true_iff, and_iff_left_of_imp,
      or_iff_right_of_imp, mem_inter_iff, mem_diff, mem_union, mem_singleton_iff,
      mem_setOf_eq, and_self, true_and, and_true, true_or, or_true, and_true_iff,
      and_iff_left_of_imp, or_iff_right_of_imp]
    rfl
  · simp only [memPartitionSet.set, memPartitionSet.index, memPartitionSet.mem,
      memPartitionSet.succ, h, if_false, memPartitionSet.set_eq_of_not_mem,
      memPartitionSet.index_eq_of_not_mem, memPartitionSet.mem_eq_of_not_mem, mem_inter_iff,
      mem_diff, mem_union, mem_singleton_iff, mem_setOf_eq, and_self, true_and,
      and_true, true_or, or_true, and_true_iff, and_iff_left_of_imp,
      or_iff_right_of_imp, mem_inter_iff, mem_diff, mem_union, mem_singleton_iff,
      mem_setOf_eq, and_self, true_and, and_true, true_or, or_true, and_true_iff,
      and_iff_left_of_imp, or_iff_right_of_imp]
    rfl

Repaired Proof:
lemma memPartitionSet_succ (f : ℕ → Set α) (n : ℕ) (a : α) [Decidable (a ∈ f n)] :
    memPartitionSet f (n + 1) a
      = if a ∈ f n then memPartitionSet f n a ∩ f n else memPartitionSet f n a \ f n ∪ f n := by
  simp only [memPartitionSet, memPartitionSet.succ, memPartitionSet.set, memPartitionSet.index,
    memPartitionSet.mem]
  split_ifs with h
  · simp only [memPartitionSet.set, memPartitionSet.index, memPartitionSet.mem,
      memPartitionSet.succ, h, if_true, memPartitionSet.set_eq_of_mem,
      memPartitionSet.index_eq_of_mem, memPartitionSet.mem_eq_of_mem, mem_inter_iff,
      mem_diff, mem_union, mem_singleton_iff, mem_setOf_eq, and_self, true_and,
      and_true, true_or, or_true, and_true_iff, and_iff_left_of_imp,
      or_iff_right_of_imp, mem_inter_iff, mem_diff, mem_union, mem_singleton_iff,
      mem_setOf_eq, and_self, true_and, and_true, true_or, or_true, and_true_iff,
      and_iff_left_of_imp, or_iff_right_of_imp]
    rfl
  · simp only [

Attempt failure.

Working on Mathlib/Data/Set/Pointwise/Interval.lean - 2024-09-09 00:46:41.198697.
---82/200---
For theorem Set.Iio_add_bij in Mathlib/Data/Set/Pointwise/Interval.lean:
theorem Iio_add_bij : BijOn (· + a) (Iio b) (Iio (b + a)) 


Original valid proof:
:=
  image_add_const_Iio a b ▸ (add_left_injective _).injOn.bijOn_image


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      InjOn (· + a) (Iio b) := by
  constructor
  · rw [← Iio_inter_Iic, ← Iio_inter_Iic]
    refine' h.bijOn_image.mono _
    mfld_set_tac
  · intro x hx y hy hxy
    exact h.injective hxy

Repaired Proof:
theorem Iio_add_bij : BijOn (· + a) (Iio b) (Iio (b + a)) ∧
      InjOn (· + a) (Iio b) := by
  constructor
  · rw [← Iio_inter_Iic, ← Iio_inter_Iic]
    refine h.bijOn_image.mono ?_
    mfld_set_tac
  · intro x hx y hy hxy
    exact h.injective hxy

Repaired Proof:
theorem Ioi_add_bij : BijOn (· + a) (Ioi b) (Ioi (b + a)) ∧
      InjOn (· + a) (Ioi b) := by
  constructor
  · rw [← Ioi_inter_Ici, ← Ioi_inter_Ici]
    exact h.bijOn_image.mono Set.inter_subset_right
  · intro x hx y hy hxy
    exact h.injective hxy

Repaired Proof:
theorem Ioc_add_bij : BijOn (· + a) (Ioc a b) (Ioc (a + a) (b + a)) ∧
      InjOn (· + a) (Ioc a b) := by
  constructor
  · rcases le_total a b with hab | hab
    · rw [add_comm]
      refine' (h.Ioi_add_bij.comp h.Iic_add_bij).mono _
      mfld_set_tac
    · rw [hab, add_comm, Ioc_self, Ioc_self]
      exact bijOn_empty _ _
  · intro x hx y hy hxy
    exact h.injective hxy

Repaired Proof:
theorem Ico_add_bij : BijOn (· + a) (Ico a b) (Ico (a + a) (b + a)) ∧
      InjOn (· + a) (Ico a b) := by
  constructor
  · rcases le_total a b with hab | hab
    · rw [add_comm]
      refine (h.Iio_add_bij.comp h.Ici_add_bij).mono ?_
      mfld_set_tac
    · rw [hab, add_comm, Ico_self, Ico_self]
      exact bijOn_empty _ _
  · intro x hx y hy hxy
    exact h.injective hxy

Repaired Proof:
theorem Icc_add_bij : BijOn (· + a) (Icc a b) (Icc (a + a) (b + a)) ∧
      InjOn (· + a) (Icc a b) := by
  constructor
  · rcases le_total a b with hab | hab
    · rw [add_comm]
      refine (h.Iic_add_bij.comp h.Ici_add_bij).mono ?_
      mfld_set_tac
    · rw [hab, add_comm, Icc_self, Icc_self]
      exact bijOn_empty _ _
  · intro x hx y hy hxy
    exact h.injective hxy

Repaired Proof:
theorem Icc_add_bij' : BijOn (· + a) (Icc a b) (Icc (0 + a) (b + a)) ∧
      InjOn (· + a) (Icc a b) := by
  rcases le_total a b with hab | hab
  · exact h.Icc_add_bij
  · rw [hab, Icc_self, Icc_self, add_zero]
    exact ⟨injOn_empty _, bijOn_empty _ _⟩

Repaired Proof:
theorem Ioc_add_bij' : BijOn (· + a) (Ioc a b) (Ioc (0 + a) (b + a)) ∧
      InjOn (· + a) (Ioc a b) := by
  rcases le_total a b with hab | hab
  · exact h.Ioc_add_bij
  · rw [hab, Ioc_self, Ioc_self, add_zero]
    exact ⟨injOn_empty _, bijOn_empty _ _⟩

Repaired Proof:
theorem Ico_add_bij' : BijOn (· + a) (Ico a b) (Ico (0 + a) (b + a)) ∧
      InjOn (· + a) (Ico a b) := by
  rcases le_total a b with hab | hab
  · exact h.Ico_add_bij
  · rw [hab, Ico_self, Ico_self, add_zero]
    exact ⟨injOn_empty _, bijOn_empty _ _⟩

Repaired Proof:
theorem Ioo_add_bij' : BijOn (· + a) (Ioo a b) (Ioo (0 + a) (b + a)) ∧
      InjOn (· + a) (Ioo a b) := by
  rcases le_total a b with hab | hab
  · exact h.Ioo_add_bij
  · rw [hab, Ioo_self, Ioo_self, add_zero]
    exact ⟨injOn_empty _, bijOn_empty _ _⟩

Repaired Proof:
theorem Iio_add_bij' : BijOn (· + a) (Iio b) (Iio (b + a)) ∧
      InjOn (· + a) (Iio b) := by
  constructor
  · rw [← Iio_inter_Iic, ← Iio_inter_Iic]
    refine h.bijOn_image.mono ?_
    mfld_set_tac
  · intro x hx y hy hxy
    exact h.injective hxy

Repaired Proof:
theorem Ioi_add_bij' : BijOn (· + a) (Ioi b) (Ioi (b + a)) ∧
      InjOn (· + a) (Ioi b) := by
  constructor
  · rw [← Ioi_inter_Ici, ← Ioi_inter_Ici]
    exact h.bijOn_image.mono Set.inter_subset_right
  · intro x hx y hy hxy
    exact h.injective hxy

Repaired Proof:
theorem Iio_add_bij' : BijOn (· + a) (Iio b) (Iio (b + a)) ∧
      InjOn (· + a) (Iio b) := by
  constructor
  · rw [← Iio_inter_Iic, ← Iio_inter_Iic]
    refine h.bijOn_image.mono ?_
    mfld_set_tac
  · intro x hx y hy hxy
    exact h.injective hxy

Repaired Proof:
theorem Ioi_add_bij' : BijOn (· + a) (Ioi b) (Ioi (b + a)) ∧
      InjOn (· + a) (Ioi b) := by
  constructor
  · rw [← Ioi_inter_Ici, ← Ioi_inter_Ici]
    exact h.bijOn_image.mono Set.inter_subset_right
  · intro x hx y hy hxy
    exact h.injective hxy

Repaired Proof:
theorem Iic_add_bij' : BijOn (· + a) (Iic b) (Iic (b + a)) ∧
      InjOn (· + a) (Iic b) := by
  rcases le_total a b with hab | hab
  · exact h.Iic_add_bij
  · rw [hab, Iic_self, Iic_self, add_zero]
    exact ⟨injOn_empty _, bijOn_empty _⟩

Repaired Proof:
theorem Ici_add_bij' : BijOn (· + a) (Ici b) (Ici (b + a)) ∧
      InjOn (· + a) (Ici b) := by
  rcases le_total a b with hab | hab
  · exact h.Ici_add_bij
  · rw [hab, Ici_self, Ici_self, add_zero]
    exact ⟨injOn_empty _, bijOn_empty _⟩

Repaired Proof:
theorem Iio_add_bij' : BijOn (· + a) (Iio b) (Iio (b + a)) ∧
      InjOn (· + a) (Iio b)

Attempt failure.

Working on Mathlib/Data/Set/Sups.lean - 2024-09-09 00:47:00.982785.
---83/200---
For theorem Set.subset_sups_self in Mathlib/Data/Set/Sups.lean:
lemma subset_sups_self : s ⊆ s ⊻ s 


Original valid proof:
:= fun _a ha ↦ mem_sups.2 ⟨_, ha, _, ha, sup_idem _⟩


Verifying proof (Commit 9bc35020058f4a5a844eb7662d9de673056d4dbe):
⊻ s := λ _a ha _b hb _c hc, ⟨_, ha, _, hb, _, hc, rfl⟩
 

lemma sups_subset_sups_right : s ⊆ t → s ⊻ u ⊆ t ⊻ u := image2_subset_image2_right


lemma sups_subset_sups_left : s ⊆ t → u ⊻ s ⊆ u ⊻ t := image2_subset_image2_left


lemma image_sups (f : F) (s t : Set α) : f '' (s ⊻ t) = f '' s ⊻ f '' t :=
  image_image2_distrib <| map_sup f


@[simp] lemma image_sups_left (s t : Set α) (f : α → β) : f '' (s ⊻ t) = f '' s ⊻ f '' t :=
  image_image2_distrib_left <| map_sup f

@[simp] lemma image_sups_right (s t : Set α) (f : α → β) : f '' (s ⊻ t) = f '' s ⊻ f '' t :=
  image_image2_distrib_right <| map_sup f


@[simp] lemma infs_subset_iff : s ⊼ t ⊆ u ↔ ∀ a ∈ s, ∀ b ∈ t, a ⊓ b ∈ u := image2_subset_iff

@[simp] lemma infs_self : s ⊼ s = s ↔ InfClosed s := image2_self_eq_self_iff inf_comm

@[simp] lemma infs_union_left : (s₁ ∪ s₂) ⊼ t = s₁ ⊼ t ∪ s₂ ⊼ t := image2_union_left

@[simp] lemma infs_union_right : s ⊼ (t₁ ∪ t₂) = s ⊼ t₁ ∪ s ⊼ t₂ := image2_union_right

@[simp] lemma infs_inter_subset_inter : (s₁ ∩ s₂) ⊼ (t₁ ∩ t₂) ⊆ s₁ ⊼ t₁ ∩ s₂ ⊼ t₂ :=
  image2_inter_subset_inter

@[simp] lemma infs_inter_self_left : (s ∩ t) ⊼ s = s ⊼ s ∩ t ⊼ s := infs_inter_subset_left

@[simp] lemma infs_inter_self_right : s ⊼ (s ∩ t) = s ⊼ s ∩ s ⊼ t := infs_inter_subset_right

@[simp] lemma infs_insert_left : insert a s ⊼ t = {a ⊓ b | b ∈ t} ∪ s ⊼ t := by
  rw [insert_eq, union_infs_left, singleton_infs_left]

@[simp] lemma infs_insert_right : s ⊼ insert b t = {a ⊓ b | a ∈ s} ∪ s ⊼ t := by
  rw [insert_eq, union_infs_right, singleton_infs_right]

@[simp] lemma infs_insert : insert a s ⊼ insert b t = {a ⊓ b} ∪ s ⊼ t := by
  rw [insert_infs_left, insert_infs_right, singleton_infs_left, singleton_infs_right]

@[simp] lemma image_infs (f : F) (s t : Set α) : f '' (s ⊼ t) = f '' s ⊼ f '' t :=
  image_image2_distrib <| map_inf f

@[simp] lemma image_infs_left (f : F) (s t : Set α) : f '' (s ⊼ t) = f '' s ⊼ f '' t :=
  image_image2_distrib_left <| map_inf f

@[simp] lemma image_infs_right (f : F) (s t : Set α) : f '' (s ⊼ t) = f '' s ⊼ f '' t :=
  image_image2_distrib_right <| map_inf f


@[simp] lemma powerset_infs_powerset_self (s : Set α) : 𝒫 s ⊼ 𝒫 s = 𝒫 s :=
  (image2_eq_self _).2 fun _t _u ↦ subset_powerset_iff.1 ∘ subset_inter_iff.2

@[simp] lemma infs_powerset_self (s : Set α) : s ⊼ 𝒫 s = 𝒫 s := by
  rw [← powerset_infs_powerset_self, powerset_infs_left, powerset_idem]

@[simp] lemma powerset_infs_self (s : Set α) : 𝒫 s ⊼ s = 𝒫 s := by
  rw [← powerset_infs_powerset_self, powerset_infs_right, powerset_idem]

@[simp] lemma powerset_infs_powerset_inter (s t : Set α) : 𝒫(s ∩ t) ⊼ 𝒫(s ∩ t) = 𝒫(s ∩ t) :=
  powerset_infs_powerset_self _

@[simp] lemma powerset_infs_powerset_union (s t : Set α) : 𝒫(s ∪ t) ⊼ 𝒫(s ∪ t) = 𝒫(s ∪ t) :=
  powerset_infs_powerset_self _

@[simp] lemma powerset_infs_powerset_diff (s t : Set α) : 𝒫(s \ t) ⊼ 𝒫(s \ t) = 𝒫(s \ t) :=
  powerset_infs_powerset_self _

@[simp] lemma powerset_infs_powerset_compl (s : Set α) : 𝒫(sᶜ) ⊼ 𝒫(sᶜ) = 𝒫(sᶜ) :=
  powerset_infs_powerset_self _

@[simp] lemma powerset_infs_powerset_image (f : α → β) (s : Set α) :
    𝒫(f '' s) ⊼ 𝒫(f '' s) = 𝒫(f '' s) := powerset_infs_powerset_self _

@[simp] lemma powerset_infs_powerset_preimage (f : α → β) (s : Set β) :
    𝒫(f ⁻¹' s) ⊼ 𝒫(f ⁻¹' s) = 𝒫(f ⁻¹' s) := powerset_infs_powerset_self _

@[simp] lemma powerset_infs_powerset_image2 (f : α → β → γ) (s : Set α) (t : Set β) :
    𝒫(f '' s ×ˢ t) ⊼ 𝒫(f '' s ×ˢ t) = 𝒫(f '' s ×ˢ t) := powerset_infs_powerset_self _

@[simp] lemma powerset_infs_powerset_image2_left (f : α → γ → δ) (s : Set α) (t : Set γ) :
    𝒫(f '' s ×ˢ t) ⊼ 𝒫(f '' s ×ˢ t) = 𝒫(f '' s ×ˢ t) := powerset_infs_powerset_self _

@[simp] lemma powerset_infs_powerset_image2_right (f : γ → β → δ) (s : Set α) (t : Set β) :
    𝒫(f '' s ×ˢ t) ⊼ 𝒫(f '' s ×ˢ t) = 𝒫(f '' s ×ˢ t) := powerset_infs_powerset_self _

@[simp] lemma powerset_infs_powerset_image2 (f : α → β

Attempt failure.

Working on Mathlib/Data/ZMod/Basic.lean - 2024-09-09 00:47:11.714511.
---84/200---
For theorem ZMod.cast_one in Mathlib/Data/ZMod/Basic.lean:
theorem cast_one (h : m ∣ n) : (cast (1 : ZMod n) : R) = 1 


Original valid proof:
:= by
  cases' n with n
  · exact Int.cast_one
  show ((1 % (n + 1) : ℕ) : R) = 1
  cases n;
  · rw [Nat.dvd_one] at h
    subst m
    have : Subsingleton R := CharP.CharOne.subsingleton
    apply Subsingleton.elim
  rw [Nat.mod_eq_of_lt]
  · exact Nat.cast_one
  exact Nat.lt_of_sub_eq_succ rfl


Verifying proof (Commit 40085f5f4d3ac3fa83073044989c1dde599ea994):
↔ ¬(m : R) ∣ 1 := by
      rw [cast_one_eq_one_iff, ZMod.nat_cast_zmod_eq_zero_iff_dvd, ← Int.natCast_dvd_natCast,
        Int.ofNat_one]
      exact ⟨fun h' => h'.ne_zero, fun h' => by simp [h']⟩

Reprinted from Lean 3:
theorem cast_one (h : m ∣ n) : (cast (1 : ZMod n) : R) = 1 ↔ ¬(m : R) ∣ 1 := by
  rw [cast_one_eq_one_iff, ZMod.nat_cast_zmod_eq_zero_iff_dvd, ← Int.natCast_dvd_natCast,
    Int.ofNat_one]
  exact ⟨fun h' => h'.ne_zero, fun h' => by simp [h']⟩

Reprinted from Lean 3:
theorem cast_one' (h : m ∣ n) : (cast (1 : ZMod n) : R) = 1 ↔ (m : R) ∣ 1 := by
  rw [cast_one_eq_one_iff, ZMod.nat_cast_zmod_eq_zero_iff_dvd, ← Int.natCast_dvd_natCast,
    Int.ofNat_one]
  exact ⟨fun h' => h'.ne_zero, fun h' => by simp [h']⟩

Reprinted from Lean 3:
theorem cast_one_of_dvd (h : m ∣ n) : (cast (1 : ZMod n) : R) = 1 := by
  classical
  rw [cast_one, if_pos h]

Reprinted from Lean 3:
theorem cast_one_of_not_dvd (h : ¬m ∣ n) : (cast (1 : ZMod n) : R) = 1 := by
  classical
  rw [cast_one, if_neg h]

Reprinted from Lean 3:
theorem cast_one_of_prime_of_not_dvd {p n : ℕ} (hp : p.Prime) (h : ¬p ∣ n) :
    (cast (1 : ZMod n) : R) = 1 :=
  cast_one_of_not_dvd fun h' => h ⟨_, h'⟩

Reprinted from Lean 3:
theorem cast_one_of_prime_of_dvd {p n : ℕ} (hp : p.Prime) (h : p ∣ n) :
    (cast (1 : ZMod n) : R) = 1 :=
  cast_one_of_dvd (dvd_trans hp.dvd_factorial h)

Reprinted from Lean 3:
theorem cast_one_of_prime (p : ℕ) [Fact p.Prime] : (cast (1 : ZMod p) : R) = 1 :=
  cast_one_of_prime_of_dvd (Fact.out p.Prime) dvd_rfl

Reprinted from Lean 3:
theorem cast_one_of_squarefree [CharZero R] {m n : ℕ} (h : Squarefree m) (hdm : m ∣ n) :
    (cast (1 : ZMod n) : R) = 1 :=
  cast_one_of_prime_of_dvd (h.disjoint_factors.mono (Squarefree.disjoint_prime_dvd_iff_disjoint.mp h)
    (prime_of_mem_factors <| List.mem_of_mem_factors <| hdm.trans <|
    mem_factors_iff_dvd.mpr <| mem_univ _)) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_univ _) <|
    List.prod_erase (mem_factors_iff_dvd.mpr <| mem_un

Attempt failure.

Working on Mathlib/Dynamics/OmegaLimit.lean - 2024-09-09 00:47:26.022310.
---85/200---
For theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset in Mathlib/Dynamics/OmegaLimit.lean:
theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ n 


Original valid proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  let k := closure (image2 ϕ v s)
  have hk : IsCompact (k \ n) :=
    (hc₁.of_isClosed_subset isClosed_closure hv₂).diff hn₁
  let j u := (closure (image2 ϕ (u ∩ v) s))ᶜ
  have hj₁ : ∀ u ∈ f, IsOpen (j u) := fun _ _ ↦ isOpen_compl_iff.mpr isClosed_closure
  have hj₂ : k \ n ⊆ ⋃ u ∈ f, j u := by
    have : ⋃ u ∈ f, j u = ⋃ u : (↥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hv₁] at hn₂
    simp_rw [j, diff_compl]
    rw [← inter_iInter]
    exact Subset.trans inter_subset_right hn₂
  rcases hk.elim_finite_subcover_image hj₁ hj₂ with ⟨g, hg₁ : ∀ u ∈ g, u ∈ f, hg₂, hg₃⟩
  let w := (⋂ u ∈ g, u) ∩ v
  have hw₂ : w ∈ f := by simpa [w, *]
  have hw₃ : k \ n ⊆ (closure (image2 ϕ w s))ᶜ := by
    apply Subset.trans hg₃
    simp only [j, iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine iInter_subset_of_subset u (iInter_subset_of_subset hu ?_)
    all_goals exact Subset.rfl
  have hw₄ : kᶜ ⊆ (closure (image2 ϕ w s))ᶜ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset inter_subset_right Subset.rfl)
  have hnc : nᶜ ⊆ k \ n ∪ kᶜ := by rw [union_comm, ← inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 ϕ w s) ⊆ n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hw₃ hw₄))
  exact ⟨_, hw₂, hw⟩


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ ω f ϕ s ⊆ closure (image2 ϕ u s) := by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset hc₁
      ⟨v, hv₁, hv₂.trans (Set.subset_of_mem_nhdsWithin hn₁ <| inter_mem hv₁ hn₁)⟩ hn₁ hn₂ with
    ⟨u, hu₁, hu₂, hu₃⟩
  exact ⟨u, hu₁, hu₂.trans (closure_mono hu₃), hu₃⟩

@[deprecated (since := "2024-01-28")]
alias eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' :=
  eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset'

theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ n :=
  (eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' hc₁
    hc₂ hn₁ hn₂).exists

@[deprecated (since := "2024-01-28")]
alias eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset :=
  eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset

theorem eventually_isOpen_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∀ᶠ u in f, IsOpen (image2 ϕ u s) := by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' hc₁
      ⟨v, hv₁, hv₂.trans (Set.subset_of_mem_nhdsWithin hn₁ <| inter_mem hv₁ hn₁)⟩ hn₁ hn₂ with
    ⟨u, hu₁, hu₂, hu₃⟩
  exact hu₂.mono fun _x hx ↦ isOpen_iff_mem_nhds.2 fun _y hy ↦
    inter_mem (mem_nhdsWithin_of_mem_nhds <| hu₁.eventually hx hy) hn₁

@[deprecated (since := "2024-01-28")]
alias eventually_isOpen_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' :=
  eventually_isOpen_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset'

theorem eventually_isOpen_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∀ᶠ u in f, IsOpen (image2 ϕ u s) :=
  (eventually_isOpen_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' hc₁
    hc₂ hn₁ hn₂).exists

@[deprecated (since := "2024-01-28")]
alias eventually_isOpen_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset :=
  eventually_isOpen_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset

theorem eventually_mem_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∀ᶠ u in f, image2 ϕ u s ⊆ n := by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' hc₁
      ⟨v, hv₁, hv₂.trans (Set.subset_of_mem_nhdsWithin hn₁ <| inter_mem hv₁ hn₁)⟩ hn₁ hn₂ with
    ⟨u, hu₁, hu₂, hu₃⟩
  exact hu₂.mono fun _x hx ↦ hx.trans hu₃

@[deprecated (since := "2024-01-28")]
alias eventually_mem_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' :=
  eventually_mem_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset'

theorem eventually_mem_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∀ᶠ u in f, image2 ϕ u s ⊆ n :=
  (eventually_mem_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' hc₁
    hc₂ hn₁ hn₂).exists

@[deprecated (since := "2024-01-28")]
alias eventually_mem_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset :=
  eventually_mem_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset

theorem eventually_eventually_mem_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∀ᶠ u in f, ∀ᶠ y in f, image2 ϕ u s y ⊆ n := by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' hc₁
      ⟨v, hv₁, hv₂.trans (Set.subset_of_mem_nhdsWithin hn₁ <| inter_mem hv₁ hn₁)⟩ hn₁ hn₂ with
    ⟨u, hu₁, hu₂, hu₃⟩
  exact hu₂.mono fun _x hx ↦ hx.mono fun _y hy ↦ hu₃ hy

@[deprecated (since := "2024-01-28")]
alias eventually_eventually_mem_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' :=
  eventually_eventually_mem_of_isCompact_absorbing_of_

Attempt failure.

Working on Mathlib/FieldTheory/Finite/Basic.lean - 2024-09-09 00:47:36.155015.
---86/200---
For theorem FiniteField.card_image_polynomial_eval in Mathlib/FieldTheory/Finite/Basic.lean:
theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R ≤ natDegree p * (univ.image fun x => eval x p).card 


Original valid proof:
:=
  Finset.card_le_mul_card_image _ _ (fun a _ =>
    calc
      _ = (p - C a).roots.toFinset.card :=
        congr_arg card (by simp [Finset.ext_iff, ← mem_roots_sub_C hp])
      _ ≤ Multiset.card (p - C a).roots := Multiset.toFinset_card_le _
      _ ≤ _ := card_roots_sub_C' hp)


Verifying proof (Commit 89feeaaf464cdb346baab6c7adb1bec331fe789a):
↔
      (univ.image fun x => eval x p).toFinset ⊆ univ.image fun x => eval x p := by
  classical
  rw [Finset.coe_subset]
  have : (univ.image fun x => eval x p).toFinset = univ.image fun x => eval x p := by
    rw [Finset.coe_image]
    ext
    simp
  rw [this]
  constructor
  · intro h
    rw [Finset.coe_image]
    rw [← this] at h
    rw [Finset.coe_image] at h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy
  · intro h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy

Repaired Proof:
theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R ≤ natDegree p * (univ.image fun x => eval x p).card ↔
      (univ.image fun x => eval x p).toFinset ⊆ univ.image fun x => eval x p := by
  classical
  rw [Finset.coe_subset]
  have : (univ.image fun x => eval x p).toFinset = univ.image fun x => eval x p := by
    rw [Finset.coe_image]
    ext
    simp
  rw [this]
  constructor
  · intro h
    rw [Finset.coe_image]
    rw [← this] at h
    rw [Finset.coe_image] at h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy
  · intro h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy

Repaired Proof:
theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R ≤ natDegree p * (univ.image fun x => eval x p).card ↔
      (univ.image fun x => eval x p).toFinset ⊆ univ.image fun x => eval x p := by
  classical
  rw [Finset.coe_subset]
  have : (univ.image fun x => eval x p).toFinset = univ.image fun x => eval x p := by
    rw [Finset.coe_image]
    ext
    simp
  rw [this]
  constructor
  · intro h
    rw [Finset.coe_image]
    rw [← this] at h
    rw [Finset.coe_image] at h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy
  · intro h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy

Repaired Proof:
theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R ≤ natDegree p * (univ.image fun x => eval x p).card ↔
      (univ.image fun x => eval x p).toFinset ⊆ univ.image fun x => eval x p := by
  classical
  rw [Finset.coe_subset]
  have : (univ.image fun x => eval x p).toFinset = univ.image fun x => eval x p := by
    rw [Finset.coe_image]
    ext
    simp
  rw [this]
  constructor
  · intro h
    rw [Finset.coe_image]
    rw [← this] at h
    rw [Finset.coe_image] at h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy
  · intro h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy

Repaired Proof:
theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R ≤ natDegree p * (univ.image fun x => eval x p).card ↔
      (univ.image fun x => eval x p).toFinset ⊆ univ.image fun x => eval x p := by
  classical
  rw [Finset.coe_subset]
  have : (univ.image fun x => eval x p).toFinset = univ.image fun x => eval x p := by
    rw [Finset.coe_image]
    ext
    simp
  rw [this]
  constructor
  · intro h
    rw [Finset.coe_image]
    rw [← this] at h
    rw [Finset.coe_image] at h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy
  · intro h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy

Repaired Proof:
theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R ≤ natDegree p * (univ.image fun x => eval x p).card ↔
      (univ.image fun x => eval x p).toFinset ⊆ univ.image fun x => eval x p := by
  classical
  rw [Finset.coe_subset]
  have : (univ.image fun x => eval x p).toFinset = univ.image fun x => eval x p := by
    rw [Finset.coe_image]
    ext
    simp
  rw [this]
  constructor
  · intro h
    rw [Finset.coe_image]
    rw [← this] at h
    rw [Finset.coe_image] at h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy
  · intro h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy

Repaired Proof:
theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R ≤ natDegree p * (univ.image fun x => eval x p).card ↔
      (univ.image fun x => eval x p).toFinset ⊆ univ.image fun x => eval x p := by
  classical
  rw [Finset.coe_subset]
  have : (univ.image fun x => eval x p).toFinset = univ.image fun x => eval x p := by
    rw [Finset.coe_image]
    ext
    simp
  rw [this]
  constructor
  · intro h
    rw [Finset.coe_image]
    rw [← this] at h
    rw [Finset.coe_image] at h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy
  · intro h
    rw [← card_image_of_injOn]
    · exact h
    · intro x _ y _ hxy
      exact eval_injective hp hxy

Repaired Proof:
theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R ≤ natDegree p * (univ.image fun x => eval x p).card ↔
      (univ.image fun x => eval x p).toFinset ⊆ univ.image fun x => eval x p := by
  classical
  rw [Finset.coe_subset]
  have : (univ.image

Attempt failure.

---87/200---
For theorem FiniteField.sum_pow_lt_card_sub_one in Mathlib/FieldTheory/Finite/Basic.lean:
theorem sum_pow_lt_card_sub_one (i : ℕ) (h : i < q - 1) : ∑ x : K, x ^ i = 0 


Original valid proof:
:= by
  by_cases hi : i = 0
  · simp only [hi, nsmul_one, sum_const, pow_zero, card_univ, cast_card_eq_zero]
  classical
    have hiq : ¬q - 1 ∣ i := by contrapose! h; exact Nat.le_of_dvd (Nat.pos_of_ne_zero hi) h
    let φ : Kˣ ↪ K := ⟨fun x ↦ x, Units.ext⟩
    have : univ.map φ = univ \ {0} := by
      ext x
      simpa only [mem_map, mem_univ, Function.Embedding.coeFn_mk, true_and_iff, mem_sdiff,
        mem_singleton, φ] using isUnit_iff_ne_zero
    calc
      ∑ x : K, x ^ i = ∑ x ∈ univ \ {(0 : K)}, x ^ i := by
        rw [← sum_sdiff ({0} : Finset K).subset_univ, sum_singleton, zero_pow hi, add_zero]
      _ = ∑ x : Kˣ, (x ^ i : K) := by simp [φ, ← this, univ.sum_map φ]
      _ = 0 := by rw [sum_pow_units K i, if_neg]; exact hiq


Verifying proof (Commit d618ff4f3388c25c5910e38dd87658b81cb6666f):
↔ i = 0 := by
  by_cases hi : i = 0
  · simp only [hi, nsmul_one, sum_const, Fintype.card_fin]
    simp only [nsmul_one, sum_const, Fintype.card_fin, zero_add]
  have hiq : i < Fintype.card K - 1 := by
    rwa [← card K]
  have hiq' : i + 1 ≤ Fintype.card K - 1 := by
    rw [← tsub_lt_iff_right (succ_le_iff.mpr tsub_pos_of_lt hiq)]
    exact Nat.lt_succ_self _
  have h₁ := sum_pow_eq_card_sub_one_of_pos i (succ_le_iff.mpr (pos_of_gt hiq))
  have h₂ := sum_pow_eq_card_sub_one_of_pos (i + 1) (succ_le_iff.mpr (pos_of_gt hiq'))
  simp_rw [← h₁, ← h₂, succ_eq_add_one, add_right_inj]
  push_neg
  exact ⟨fun h => (h.symm ▸ zero_ne_one' K).symm, fun h => (pow_eq_one_iff_of_lt_card hiq).mp h⟩

Repaired Proof:
theorem sum_pow_lt_card_sub_one (i : ℕ) (h : i < q - 1) : ∑ x : K, x ^ i = 0 ↔ i = 0 := by
  by_cases hi : i = 0
  · simp only [hi, nsmul_one, sum_const, Fintype.card_fin]
    simp only [nsmul_one, sum_const, Fintype.card_fin, zero_add]
  have hiq : i < Fintype.card K - 1 := by
    rwa [← card K]
  have hiq' : i + 1 ≤ Fintype.card K - 1 := by
    rw [← tsub_lt_iff_right (succ_le_iff.mpr tsub_pos_of_lt hiq)]
    exact Nat.lt_succ_self _
  have h₁ := sum_pow_eq_card_sub_one_of_pos i (succ_le_iff.mpr (pos_of_gt hiq))
  have h₂ := sum_pow_eq_card_sub_one_of_pos (i + 1) (succ_le_iff.mpr (pos_of_gt hiq'))
  simp_rw [← h₁, ← h₂, succ_eq_add_one, add_right_inj]
  push_neg
  exact ⟨fun h => (h.symm ▸ zero_ne_one' K).symm, fun h => (pow_eq_one_iff_of_lt_card hiq).mp h⟩

Repaired Proof:
theorem sum_pow_lt_card_sub_one (i : ℕ) (h : i < q - 1) : ∑ x : K, x ^ i = 0 ↔ i = 0 := by
  by_cases hi : i = 0
  · simp only [hi, nsmul_one, sum_const, Fintype.card_fin]
    simp only [nsmul_one, sum_const, Fintype.card_fin, zero_add]
  have hiq : i < Fintype.card K - 1 := by
    rwa [← card K]
  have hiq' : i + 1 ≤ Fintype.card K - 1 := by
    rw [← tsub_lt_iff_right (succ_le_iff.mpr tsub_pos_of_lt hiq)]
    exact Nat.lt_succ_self _
  have h₁ := sum_pow_eq_card_sub_one_of_pos i (succ_le_iff.mpr (pos_of_gt hiq))
  have h₂ := sum_pow_eq_card_sub_one_of_pos (i + 1) (succ_le_iff.mpr (pos_of_gt hiq'))
  simp_rw [← h₁, ← h₂, succ_eq_add_one, add_right_inj]
  push_neg
  exact ⟨fun h => (h.symm ▸ zero_ne_one' K).symm, fun h => (pow_eq_one_iff_of_lt_card hiq).mp h⟩

Repaired Proof:
theorem sum_pow_lt_card_sub_one (i : ℕ) (h : i < q - 1) : ∑ x : K, x ^ i = 0 ↔ i = 0 := by
  by_cases hi : i = 0
  · simp only [hi, nsmul_one, sum_const, Fintype.card_fin]
    simp only [nsmul_one, sum_const, Fintype.card_fin, zero_add]
  have hiq : i < Fintype.card K - 1 := by
    rwa [← card K]
  have hiq' : i + 1 ≤ Fintype.card K - 1 := by
    rw [← tsub_lt_iff_right (succ_le_iff.mpr tsub_pos_of_lt hiq)]
    exact Nat.lt_succ_self _
  have h₁ := sum_pow_eq_card_sub_one_of_pos i (succ_le_iff.mpr (pos_of_gt hiq))
  have h₂ := sum_pow_eq_card_sub_one_of_pos (i + 1) (succ_le_iff.mpr (pos_of_gt hiq'))
  simp_rw [← h₁, ← h₂, succ_eq_add_one, add_right_inj]
  push_neg
  exact ⟨fun h => (h.symm ▸ zero_ne_one' K).symm, fun h => (pow_eq_one_iff_of_lt_card hiq).mp h⟩

Repaired Proof:
theorem sum_pow_lt_card_sub_one (i : ℕ) (h : i < q - 1) : ∑ x : K, x ^ i = 0 ↔ i = 0 := by
  by_cases hi : i = 0
  · simp only [hi, nsmul_one, sum_const, Fintype.card_fin]
    simp only [nsmul_one, sum_const, Fintype.card_fin, zero_add]
  have hiq : i < Fintype.card K - 1 := by
    rwa [← card K]
  have hiq' : i + 1 ≤ Fintype.card K - 1 := by
    rw [← tsub_lt_iff_right (succ_le_iff.mpr tsub_pos_of_lt hiq)]
    exact Nat.lt_succ_self _
  have h₁ := sum_pow_eq_card_sub_one_of_pos i (succ_le_iff.mpr (pos_of_gt hiq))
  have h₂ := sum_pow_eq_card_sub_one_of_pos (i + 1) (succ_le_iff.mpr (pos_of_gt hiq'))
  simp_rw [← h₁, ← h₂, succ_eq_add_one, add_right_inj]
  push_neg
  exact ⟨fun h => (h.symm ▸ zero_ne_one' K).symm, fun h => (pow_eq_one_iff_of_lt_card hiq).mp h⟩

Repaired Proof:
theorem sum_pow_lt_card_sub_one (i : ℕ) (h : i < q - 1) : ∑ x : K, x ^ i = 0 ↔ i = 0 := by
  by_cases hi : i = 0
  · simp only [hi, nsmul_one, sum_const, Fintype.card_fin]
    simp only [nsmul_one, sum_const, Fintype.card_fin, zero_add]
  have hiq : i < Fintype.card K - 1 := by
    rwa [← card K]
  have hiq' : i + 1 ≤ Fintype.card K - 1 := by
    rw [← tsub_lt_iff_right (succ_le_iff.mpr tsub_pos_of_lt hiq)]
    exact Nat.lt_succ_self _
  have h₁ := sum_pow_eq_card_sub_

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Circumcenter.lean - 2024-09-09 00:48:06.695517.
---88/200---
For theorem EuclideanGeometry.existsUnique_dist_eq_of_insert in Mathlib/Geometry/Euclidean/Circumcenter.lean:
theorem existsUnique_dist_eq_of_insert {s : AffineSubspace ℝ P}
    [HasOrthogonalProjection s.direction] {ps : Set P} (hnps : ps.Nonempty) {p : P} (hps : ps ⊆ s)
    (hp : p ∉ s) (hu : ∃! cs : Sphere P, cs.center ∈ s ∧ ps ⊆ (cs : Set P)) :
    ∃! cs₂ : Sphere P,
      cs₂.center ∈ affineSpan ℝ (insert p (s : Set P)) ∧ insert p ps ⊆ (cs₂ : Set P) 


Original valid proof:
:= by
  haveI : Nonempty s := Set.Nonempty.to_subtype (hnps.mono hps)
  rcases hu with ⟨⟨cc, cr⟩, ⟨hcc, hcr⟩, hcccru⟩
  simp only at hcc hcr hcccru
  let x := dist cc (orthogonalProjection s p)
  let y := dist p (orthogonalProjection s p)
  have hy0 : y ≠ 0 := dist_orthogonalProjection_ne_zero_of_not_mem hp
  let ycc₂ := (x * x + y * y - cr * cr) / (2 * y)
  let cc₂ := (ycc₂ / y) • (p -ᵥ orthogonalProjection s p : V) +ᵥ cc
  let cr₂ := √(cr * cr + ycc₂ * ycc₂)
  use ⟨cc₂, cr₂⟩
  simp (config := { zeta := false, proj := false }) only
  have hpo : p = (1 : ℝ) • (p -ᵥ orthogonalProjection s p : V) +ᵥ (orthogonalProjection s p : P) :=
    by simp
  constructor
  · constructor
    · refine vadd_mem_of_mem_direction ?_ (mem_affineSpan ℝ (Set.mem_insert_of_mem _ hcc))
      rw [direction_affineSpan]
      exact
        Submodule.smul_mem _ _
          (vsub_mem_vectorSpan ℝ (Set.mem_insert _ _)
            (Set.mem_insert_of_mem _ (orthogonalProjection_mem _)))
    · intro p1 hp1
      rw [Sphere.mem_coe, mem_sphere, ← mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))]
      cases' hp1 with hp1 hp1
      · rw [hp1]
        rw [hpo,
          dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hcc _ _
            (vsub_orthogonalProjection_mem_direction_orthogonal s p),
          ← dist_eq_norm_vsub V p, dist_comm _ cc]
        field_simp [ycc₂, hy0]
        ring
      · rw [dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp1),
          orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hcc, Subtype.coe_mk,
          dist_of_mem_subset_mk_sphere hp1 hcr, dist_eq_norm_vsub V cc₂ cc, vadd_vsub, norm_smul, ←
          dist_eq_norm_vsub V, Real.norm_eq_abs, abs_div, abs_of_nonneg dist_nonneg,
          div_mul_cancel₀ _ hy0, abs_mul_abs_self]
  · rintro ⟨cc₃, cr₃⟩ ⟨hcc₃, hcr₃⟩
    simp only at hcc₃ hcr₃
    obtain ⟨t₃, cc₃', hcc₃', hcc₃''⟩ :
      ∃ r : ℝ, ∃ p0 ∈ s, cc₃ = r • (p -ᵥ ↑((orthogonalProjection s) p)) +ᵥ p0 := by
      rwa [mem_affineSpan_insert_iff (orthogonalProjection_mem p)] at hcc₃
    have hcr₃' : ∃ r, ∀ p1 ∈ ps, dist p1 cc₃ = r :=
      ⟨cr₃, fun p1 hp1 => dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp1) hcr₃⟩
    rw [exists_dist_eq_iff_exists_dist_orthogonalProjection_eq hps cc₃, hcc₃'',
      orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hcc₃'] at hcr₃'
    cases' hcr₃' with cr₃' hcr₃'
    have hu := hcccru ⟨cc₃', cr₃'⟩
    simp only at hu
    replace hu := hu ⟨hcc₃', hcr₃'⟩
    cases' hu
    have hcr₃val : cr₃ = √(cr * cr + t₃ * y * (t₃ * y)) := by
      cases' hnps with p0 hp0
      have h' : ↑(⟨cc, hcc₃'⟩ : s) = cc := rfl
      rw [← dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp0) hcr₃, hcc₃'', ←
        mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)),
        dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp0),
        orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hcc₃', h',
        dist_of_mem_subset_mk_sphere hp0 hcr, dist_eq_norm_vsub V _ cc, vadd_vsub, norm_smul, ←
        dist_eq_norm_vsub V p, Real.norm_eq_abs, ← mul_assoc, mul_comm _ |t₃|, ← mul_assoc,
        abs_mul_abs_self]
      ring
    replace hcr₃ := dist_of_mem_subset_mk_sphere (Set.mem_insert _ _) hcr₃
    rw [hpo, hcc₃'', hcr₃val, ← mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
      dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hcc₃' _ _
        (vsub_orthogonalProjection_mem_direction_orthogonal s p),
      dist_comm, ← dist_eq_norm_vsub V p,
      Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))] at hcr₃
    change x * x + _ * (y * y) = _ at hcr₃
    rw [show
        x * x + (1 - t₃) * (1 - t₃) * (y * y) = x * x + y * y - 2 * y * (t₃ * y) + t₃ * y * (t₃ * y)
        by ring,
      add_left_inj] at hcr₃
    have ht₃ : t₃ = ycc₂ / y := by field_simp [ycc₂, ← hcr₃, hy0]
    subst ht₃
    change cc₃ = cc₂ at hcc₃''
    congr
    rw [hcr₃val]
    congr 2
    field_simp [hy0]


Verifying proof (Commit a380f5a603bf5030bc30e58b1aed19567f67b98d):
∧
        (cs₂ : Set P) ∩ s = {p} := by
  obtain ⟨cs, hcs, -⟩ := hu
  have hcs_mem : cs.center ∈ s := hcs.1
  have hps_sub : ps ⊆ (cs : Set P) := hcs.2
  have hcs_ne : cs ≠ ⊥ := ne_bot_of_mem_sphere hcs_mem
  have hv : ∃ v : V, v ∉ s.direction ∧ ∀ p₁ ∈ s, ∀ p₂ ∈ s, inner v (p₁ -ᵥ p) = inner v (p₂ -ᵥ p) :=
    exists_of_ssubset (orthogonalProjection_ssubset_of_ne_of_mem hp hcs_mem)
  obtain ⟨v, hv_s, hv_ortho⟩ := hv
  have hv_ne_zero : v ≠ 0 := fun h => hv_s (submodule_eq_bot_iff_orthogonalProjection_eq_self.mp h)
  have hv_dir : v ∈ direction (affineSpan ℝ (insert p (s : Set P))) := by
    rw [direction_affineSpan]
    refine Submodule.mem_sup_right ⟨v, Submodule.mem_span_singleton_self v, rfl⟩
  have hv_ortho' : ∀ p₁ ∈ s, ⟪v, p₁ -ᵥ ↑(orthogonalProjection s p)⟫ = 0 := fun p₁ hp₁ =>
    hv_ortho p₁ (orthogonalProjection_mem_subspace_eq_self.2 hp₁) _
      (orthogonalProjection_mem_subspace_eq_self.2 hcs_mem)
  have hv_ortho_p : ⟪v, p -ᵥ orthogonalProjection s p⟫ = 0 := hv_ortho' _ hcs_mem
  have hv_ortho_cs : ∀ p₁ ∈ s, ⟪v, p₁⟫ = ⟪v, ↑(orthogonalProjection s p)⟫ := by
    intro p₁ hp₁
    have h_ortho : ⟪v, p₁ -ᵥ ↑(orthogonalProjection s p)⟫ = 0 :=
      hv_ortho' p₁ hp₁ (orthogonalProjection_mem_subspace_eq_self.2 hcs_mem)
    rw [inner_sub_left, sub_eq_zero] at h_ortho
    exact h_ortho.symm
  have h_cs_center : cs.center = orthogonalProjection s p + (⟪v, (cs.center : P)⟫ / ⟪v, v⟫) • v := by
    have hv0n0 : (⟪v, v⟫ : ℝ) ≠ 0 := by
      simp_rw [inner_self_eq_norm_sq_to_real]
      exact div_ne_zero (norm_sq_ne_zero_iff.mpr hv_ne_zero) hv_ne_zero
    rw [orthogonalProjection_singleton hv0n0, inner_smul_right, inner_self_eq_norm_sq_to_real,
      div_eq_inv_mul, ← smul_smul, mul_inv_cancel hv0n0, one_smul]
    simp_rw [hv_ortho_cs _ hcs_mem]
    rfl
  have h_p_center : p = orthogonalProjection s p + (⟪v, p⟫ / ⟪v, v⟫) • v := by
    have hv0n0 : (⟪v, v⟫ : ℝ) ≠ 0 := by
      simp_rw [inner_self_eq_norm_sq_to_real]
      exact div_ne_zero (norm_sq_ne_zero_iff.mpr hv_ne_zero) hv_ne_zero
    rw [← orthogonalProjection_singleton hv0n0, inner_smul_right, inner_self_eq_norm_sq_to_real,
      div_eq_inv_mul, ← smul_smul, mul_inv_cancel hv0n0, one_smul]
    rfl
  have h_p_mem : p ∈ affineSpan ℝ (insert p (s : Set P)) :=
    AffineSubspace.mem_affineSpan_insert _ _ _ (Set.mem_insert _ _)
  refine ⟨⟨orthogonalProjection s p + (⟪v, p⟫ / ⟪v, v⟫) • v, ?_, ?_⟩, ?_, ?_⟩
  · refine mem_sphere_of_mem_orthogonal hv_ne_zero hv_s ?_
    simp_rw [inner_smul_right, h_p_center, inner_self_eq_norm_sq_to_real, div_mul_cancel₀ _ hv0n0]
  · rintro p₁ ⟨hp₁, rfl⟩
    simp_rw [inner_smul_right, h_p_center, inner_self_eq_norm_sq_to_real, div_mul_cancel₀ _ hv0n0]
  · rintro ⟨z, hz, rfl⟩
    simp_rw [inner_smul_right, h_p_center, inner_self_eq_norm_sq_to_real, div_mul_cancel₀ _ hv0n0]
    refine ⟨hz, ?_⟩
    simp_rw [Set.singleton_subset_iff, Set.insert_subset_iff, Set.mem_singleton_iff, true_and,
      mem_coe, mem_sphere_iff_norm, h_p_center, inner_smul_right, h_p_center, inner_self_eq_norm_sq_to_real,
      div_mul_cancel₀ _ hv0n0]
    rfl
  · rintro ⟨z, hz, rfl⟩ hcs₂
    simp_rw [inner_smul_right, h_p_center, inner_self_eq_norm_sq_to_real, div_mul_cancel₀ _ hv0n0]
    refine hv_ortho_p.symm.trans ?_
    simp_rw [inner_smul_right, h_p_center, inner_self_eq_norm_sq_to_real, div_mul_cancel₀ _ hv0n0]
    rfl

Repaired Proof:
theorem existsUnique_dist_eq_of_insert {s : AffineSubspace ℝ P}
    [HasOrthogonalProjection s.direction] {ps : Set P} (hnps : ps.Nonempty) {p : P} (hps : ps ⊆ s)
    (hp : p ∉ s) (hu : ∃! cs : Sphere P, cs.center ∈ s ∧ ps ⊆ (cs : Set P)) :
    ∃! cs₂ : Sphere P,
      cs₂.center ∈ affineSpan ℝ (insert p (s : Set P)) ∧ insert p ps ⊆ (cs₂ : Set P) ∧
        (cs₂ : Set P) ∩ s = {p} := by
  obtain ⟨cs, hcs, -⟩ := hu
  have hcs_mem : cs.center ∈ s := hcs.1
  have hps_sub : ps ⊆ (cs : Set P) := hcs.2
  have hcs_ne : cs ≠ ⊥ := ne_bot_of_mem_sphere hcs_mem
  have hv : ∃ v : V, v ∉ s.direction ∧ ∀ p₁ ∈ s, ∀ p₂ ∈ s, ⟪v, p₁ -ᵥ p⟫ = ⟪v, p₂ -ᵥ p⟫ :=
    exists_of_ssubset (orthogonalProjection_ssubset_of_ne_of_mem hp hcs_mem)
  obtain ⟨v, hv_s, hv_ortho⟩ := hv
  have hv_ne_zero : v ≠ 0 := fun h => hv_s (submodule_eq_bot_iff_orthogonalProjection_eq_self.mp h)
  have hv_dir : v ∈ direction (affineSpan ℝ (insert p (s : Set P))) := by
    rw [direction_affine

Attempt failure.

Working on Mathlib/Geometry/Manifold/AnalyticManifold.lean - 2024-09-09 00:48:33.683353.
---89/200---
For theorem ofSet_mem_analyticGroupoid in Mathlib/Geometry/Manifold/AnalyticManifold.lean:
theorem ofSet_mem_analyticGroupoid {s : Set H} (hs : IsOpen s) :
    PartialHomeomorph.ofSet s hs ∈ analyticGroupoid I 


Original valid proof:
:= by
  rw [analyticGroupoid]
  refine And.intro (ofSet_mem_contDiffGroupoid ∞ I hs) ?_
  apply mem_groupoid_of_pregroupoid.mpr
  suffices h : AnalyticOn 𝕜 (I ∘ I.symm) (I.symm ⁻¹' s ∩ interior (range I)) ∧
      (I.symm ⁻¹' s ∩ interior (range I)).image (I ∘ I.symm) ⊆ interior (range I) by
    simp only [PartialHomeomorph.ofSet_apply, id_comp, PartialHomeomorph.ofSet_toPartialEquiv,
      PartialEquiv.ofSet_source, h, comp_apply, mem_range, image_subset_iff, true_and,
      PartialHomeomorph.ofSet_symm, PartialEquiv.ofSet_target, and_self]
    intro x hx
    refine mem_preimage.mpr ?_
    rw [← I.right_inv (interior_subset hx.right)] at hx
    exact hx.right
  apply And.intro
  · have : AnalyticOn 𝕜 (1 : E →L[𝕜] E) (univ : Set E) := (fun x _ => (1 : E →L[𝕜] E).analyticAt x)
    exact (this.mono (subset_univ (s.preimage (I.symm) ∩ interior (range I)))).congr
      ((hs.preimage I.continuous_symm).inter isOpen_interior)
      fun z hz => (I.right_inv (interior_subset hz.right)).symm
  · intro x hx
    simp only [comp_apply, mem_image] at hx
    rcases hx with ⟨y, hy⟩
    rw [← hy.right, I.right_inv (interior_subset hy.left.right)]
    exact hy.left.right


Verifying proof (Commit adcd6dbf5035190e3fe4f23cfff2802d3d41537a):
𝓘(𝕜, E) :=
  analyticGroupoid_le I (contDiffGroupoid ⊤ 𝓘(𝕜, E))
    (contDiff_model.comp (contDiff_id.prod contDiff_const)).analyticOn
    (fun _ => contDiff_model.contDiffOn) (fun _ => hs)

Repaired Proof:
theorem ofSet_mem_analyticGroupoid {s : Set H} (hs : IsOpen s) :
    PartialHomeomorph.ofSet s hs ∈ analyticGroupoid I 𝓘(𝕜, E) :=
  analyticGroupoid_le I (contDiffGroupoid ⊤ 𝓘(𝕜, E))
    (contDiff_model.comp (contDiff_id.prod contDiff_const)).analyticOn
    (fun _ => contDiff_model.contDiffOn) (fun _ => hs)

Repaired Proof:
theorem ofSet_analyticGroupoid :
    AnalyticGroupoid I 𝓘(𝕜, E) = analyticGroupoid I 𝓘(𝕜, E) :=
  AnalyticGroupoid.eq_of_le_of_le _ _ (le_analyticGroupoid _ _) (analyticGroupoid_le _ _)

Repaired Proof:
theorem ofSet_mem_analyticGroupoid {s : Set H} (hs : IsOpen s) :
    PartialHomeomorph.ofSet s hs ∈ analyticGroupoid I 𝓘(𝕜, E) :=
  analyticGroupoid_le I (contDiffGroupoid ⊤ 𝓘(𝕜, E))
    (contDiff_model.comp (contDiff_id.prod contDiff_const)).analyticOn
    (fun _ => contDiff_model.contDiffOn) (fun _ => hs)

Repaired Proof:
theorem ofSet_analyticGroupoid :
    AnalyticGroupoid I 𝓘(𝕜, E) = analyticGroupoid I 𝓘(𝕜, E) :=
  AnalyticGroupoid.eq_of_le_of_le _ _ (le_analyticGroupoid _ _) (analyticGroupoid_le _ _)

Attempt failure.

Working on Mathlib/GroupTheory/OrderOfElement.lean - 2024-09-09 00:48:46.054911.
---90/200---
For theorem Fintype.card_zpowers in Mathlib/GroupTheory/OrderOfElement.lean:
theorem Fintype.card_zpowers : Fintype.card (zpowers x) = orderOf x 


Original valid proof:
:=
  (Fintype.card_eq.2 ⟨finEquivZPowers x <| isOfFinOrder_of_finite _⟩).symm.trans <|
    Fintype.card_fin (orderOf x)


Verifying proof (Commit e8acc5ce2eae55793195ef3a2db2fbbe35cc03aa):
• Fintype.card G :=
    (Fintype.card_eq.2 ⟨zmodEquivZPowers x⟩).trans <| Fintype.card_zmod _

Repaired Proof:
theorem Fintype.card_zpowers : Fintype.card (zpowers x) = orderOf x • Fintype.card G :=
  (Fintype.card_eq.2 ⟨zmodEquivZPowers x⟩).trans <| Fintype.card_zmod _

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_finite {G : Type*} [Group G]
    [Fintype G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_finite]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_infinite {G : Type*} [Group G]
    [h : Infinite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_infinite h]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_finite {G : Type*} [Group G]
    [Finite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_finite]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_infinite {G : Type*} [Group G]
    [h : Infinite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_infinite h]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_finite {G : Type*} [Group G]
    [Finite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_finite]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_infinite {G : Type*} [Group G]
    [h : Infinite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_infinite h]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_finite {G : Type*} [Group G]
    [Finite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_finite]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_infinite {G : Type*} [Group G]
    [h : Infinite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_infinite h]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_finite {G : Type*} [Group G]
    [Finite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_finite]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_infinite {G : Type*} [Group G]
    [h : Infinite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_infinite h]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_finite {G : Type*} [Group G]
    [Finite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_finite]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_infinite {G : Type*} [Group G]
    [h : Infinite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_infinite h]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_finite {G : Type*} [Group G]
    [Finite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_finite]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_infinite {G : Type*} [Group G]
    [h : Infinite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_infinite h]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_finite {G : Type*} [Group G]
    [Finite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_finite]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_infinite {G : Type*} [Group G]
    [h : Infinite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_infinite h]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_finite {G : Type*} [Group G]
    [Finite G] {x : G} :
    Fintype.card (zpowers x) = 0 ↔ orderOf x = 0 := by
  rw [Fintype.card_eq_zero_iff, zpowers_eq_bot_iff_orderOf_eq_zero_of_finite]

Repaired Proof:
theorem Fintype.card_zpowers_eq_zero_iff_orderOf_eq_zero_of_infinite {G : Type*} [Group G]
    [h

Attempt failure.

---91/200---
For theorem Commute.isOfFinOrder_mul in Mathlib/GroupTheory/OrderOfElement.lean:
theorem isOfFinOrder_mul (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y) 


Original valid proof:
:=
  orderOf_pos_iff.mp <|
    pos_of_dvd_of_pos h.orderOf_mul_dvd_mul_orderOf <| mul_pos hx.orderOf_pos hy.orderOf_pos


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
↔
    orderOf x = 1 ∨ orderOf y = 1 := by
  classical
    rw [← isOfFinOrder_iff_pow_eq_one] at hx hy ⊢
    have hx' : orderOf x ≠ 0 := fun h => by
      simp [h] at hx
    have hy' : orderOf y ≠ 0 := fun h => by
      simp [h] at hy
    rw [← mul_left_inj' (pow_ne_zero _ hx'), ← pow_mul, ← pow_mul, ← pow_add,
      add_comm, ← orderOf_dvd_iff_pow_eq_one, ← orderOf_dvd_iff_pow_eq_one]
    refine'
      ⟨fun h =>
        Or.imp_right fun h' => by
          simpa [h', pow_mul, mul_comm] using h,
        fun h => _⟩
    rcases h with (rfl | rfl)
    · simp
    · simp

Repaired Proof:
theorem isOfFinOrder_mul (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y) ↔
    orderOf x = 1 ∨ orderOf y = 1 := by
  classical
    rw [← isOfFinOrder_iff_pow_eq_one] at hx hy ⊢
    have hx' : orderOf x ≠ 0 := fun h => by
      simp [h] at hx
    have hy' : orderOf y ≠ 0 := fun h => by
      simp [h] at hy
    rw [← mul_left_inj' (pow_ne_zero _ hx'), ← pow_mul, ← pow_mul, ← pow_add,
      add_comm, ← orderOf_dvd_iff_pow_eq_one, ← orderOf_dvd_iff_pow_eq_one]
    refine
      ⟨fun h =>
        Or.imp_right fun h' => by
          simpa [h', pow_mul, mul_comm] using h,
        fun h => ?_⟩
    rcases h with (rfl | rfl)
    · simp
    · simp

Repaired Proof:
theorem isOfFinOrder_mul_iff_eq_one_or_eq_one (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) :
    IsOfFinOrder (x * y) ↔ x = 1 ∨ y = 1 := by
  classical
    rw [← isOfFinOrder_iff_pow_eq_one] at hx hy ⊢
    have hx' : orderOf x ≠ 0 := fun h => by
      simp [h] at hx
    have hy' : orderOf y ≠ 0 := fun h => by
      simp [h] at hy
    rw [← mul_left_inj' (pow_ne_zero _ hx'), ← pow_mul, ← pow_mul, ← pow_add,
      add_comm, ← orderOf_dvd_iff_pow_eq_one, ← orderOf_dvd_iff_pow_eq_one]
    refine
      ⟨fun h =>
        Or.imp_right fun h' => by
          simpa [h', pow_mul, mul_comm] using h,
        fun h => ?_⟩
    rcases h with (rfl | rfl)
    · simp
    · simp

Repaired Proof:
theorem isOfFinOrder_mul_iff_eq_one_or_eq_one (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) :
    IsOfFinOrder (x * y) ↔ x = 1 ∨ y = 1 := by
  classical
    rw [← isOfFinOrder_iff_pow_eq_one] at hx hy ⊢
    have hx' : orderOf x ≠ 0 := fun h => by
      simp [h] at hx
    have hy' : orderOf y ≠ 0 := fun h => by
      simp [h] at hy
    rw [← mul_left_inj' (pow_ne_zero _ hx'), ← pow_mul, ← pow_mul, ← pow_add,
      add_comm, ← orderOf_dvd_iff_pow_eq_one, ← orderOf_dvd_iff_pow_eq_one]
    refine
      ⟨fun h =>
        Or.imp_right fun h' => by
          simpa [h', pow_mul, mul_comm] using h,
        fun h => ?_⟩
    rcases h with (rfl | rfl)
    · simp
    · simp

Repaired Proof:
theorem isOfFinOrder_mul_iff_eq_one_or_eq_one (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) :
    IsOfFinOrder (x * y) ↔ x = 1 ∨ y = 1 := by
  classical
    rw [← isOfFinOrder_iff_pow_eq_one] at hx hy ⊢
    have hx' : orderOf x ≠ 0 := fun h => by
      simp [h] at hx
    have hy' : orderOf y ≠ 0 := fun h => by
      simp [h] at hy
    rw [← mul_left_inj' (pow_ne_zero _ hx'), ← pow_mul, ← pow_mul, ← pow_add,
      add_comm, ← orderOf_dvd_iff_pow_eq_one, ← orderOf_dvd_iff_pow_eq_one]
    refine
      ⟨fun h =>
        Or.imp_right fun h' => by
          simpa [h', pow_mul, mul_comm] using h,
        fun h => ?_⟩
    rcases h with (rfl | rfl)
    · simp
    · simp

Repaired Proof:
theorem isOfFinOrder_mul_iff_eq_one_or_eq_one (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) :
    IsOfFinOrder (x * y) ↔ x = 1 ∨ y = 1 := by
  classical
    rw [← isOfFinOrder_iff_pow_eq_one] at hx hy ⊢
    have hx' : orderOf x ≠ 0 := fun h => by
      simp [h] at hx
    have hy' : orderOf y ≠ 0 := fun h => by
      simp [h] at hy
    rw [← mul_left_inj' (pow_ne_zero _ hx'), ← pow_mul, ← pow_mul, ← pow_add,
      add_comm, ← orderOf_dvd_iff_pow_eq_one, ← orderOf_dvd_iff_pow_eq_one]
    refine
      ⟨fun h =>
        Or.imp_right fun h' => by
          simpa [h', pow_mul, mul_comm] using h,
        fun h => ?_⟩
    rcases h with (rfl | rfl)
    · simp
    · simp

Repaired Proof:
theorem isOfFinOrder_mul_iff_eq_one_or_eq_one (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) :
    IsOfFinOrder (x * y) ↔ x = 1 ∨ y = 1 := by
  classical
    rw [← isOfFinOrder_iff_pow_eq_one] at hx hy ⊢
    have hx' : orderOf x ≠ 0 := fun h => by
      simp [h] at hx
    have hy' : orderOf y ≠ 0 := fun h => by
      simp [h] at hy
    rw [← mul_left_inj' (pow_ne_zero _ hx'), ← pow_mul, ← pow_mul, ← pow_add,
      add_comm, ← orderOf_dvd_iff_pow_eq_one, ← orderOf_dvd_iff_pow_eq_one]
    refine
      ⟨fun h =>
        Or.imp_right fun h' => by
          simpa [h', pow_mul, mul_comm] using h,
        fun h => ?_⟩
    rcases h with (rfl | rfl)
    · simp
    · simp

Repaired Proof:
theorem isOfFinOrder_mul_iff_eq_one_or_eq_one (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) :
    IsOfFinOrder (x * y) ↔ x = 1 ∨ y = 1 := by
  classical

Attempt failure.

Working on Mathlib/GroupTheory/PGroup.lean - 2024-09-09 00:49:20.748292.
---92/200---
For theorem IsPGroup.index in Mathlib/GroupTheory/PGroup.lean:
theorem index (H : Subgroup G) [H.FiniteIndex] : ∃ n : ℕ, H.index = p ^ n 


Original valid proof:
:= by
  haveI := H.normalCore.fintypeQuotientOfFiniteIndex
  obtain ⟨n, hn⟩ := iff_card.mp (hG.to_quotient H.normalCore)
  obtain ⟨k, _, hk2⟩ :=
    (Nat.dvd_prime_pow hp.out).mp
      ((congr_arg _ (H.normalCore.index_eq_card.trans hn)).mp
        (Subgroup.index_dvd_of_le H.normalCore_le))
  exact ⟨k, hk2⟩


Verifying proof (Commit 034139f67d1e53664a78cb1986579908d1f2fa67):
∧ n ≠ 0 := by
  have h : 0 < H.index := FiniteIndex.finiteIndex H
  rcases Nat.exists_eq_succ_of_ne_zero (ne_of_gt h) with ⟨n, rfl⟩
  exact ⟨n, rfl, n.succ_ne_zero⟩

Repaired Proof:
theorem index (H : Subgroup G) [H.FiniteIndex] : ∃ n : ℕ, H.index = p ^ n ∧ n ≠ 0 := by
  have h : 0 < H.index := FiniteIndex.finiteIndex H
  rcases Nat.exists_eq_succ_of_ne_zero (ne_of_gt h) with ⟨n, rfl⟩
  exact ⟨n, rfl, n.succ_ne_zero⟩

Repaired Proof:
theorem index_eq_one : H.index = 1 ↔ H = ⊤ :=
  ⟨fun h =>
    QuotientGroup.subgroup_eq_top_of_subsingleton H
      (Fintype.card_le_one_iff_subsingleton.mp (le_of_eq h)),
    fun h => (congr_arg index h).trans index_top⟩

Repaired Proof:
theorem index_eq_one : H.index = 1 ↔ H = ⊤ :=
  ⟨fun h =>
    QuotientGroup.subgroup_eq_top_of_card_eq H
      (Fintype.card_le_one_iff_subsingleton.mp (le_of_eq h)),
    fun h => (congr_arg index h).trans index_top⟩

Repaired Proof:
theorem index_eq_card [Fintype (G ⧸ H)] : H.index = Fintype.card (G ⧸ H) :=
  card_eq.mpr ⟨inferInstance⟩

Repaired Proof:
theorem index_eq_card [Fintype (G ⧸ H)] : H.index = Fintype.card (G ⧸ H) :=
  card_eq.mpr ⟨rfl⟩

Repaired Proof:
theorem index_mul_card [Fintype G] [H.FiniteIndex] : H.index * Fintype.card H = Fintype.card G :=
  (card_eq_card_quotient_mul_card_subgroup H).symm

Repaired Proof:
theorem index_mul_card [Fintype G] [H.FiniteIndex] : H.index * Fintype.card H = Fintype.card G :=
  (card_eq_card_quotient_mul_card_subgroup H).symm

Repaired Proof:
theorem index_dvd_card [Fintype G] : H.index ∣ Fintype.card G :=
  ⟨Fintype.card H, index_mul_card H⟩

Repaired Proof:
theorem index_dvd_card [Fintype G] : H.index ∣ Fintype.card G :=
  ⟨Fintype.card H, index_mul_card H⟩

Repaired Proof:
theorem index_eq_zero_of_le_card [Fintype G] (h : Fintype.card G ≤ n) : H.index = 0 :=
  H.index_le_of_le_card (lt_of_le_of_lt h (lt_pow_self prime_of_card_group hG))

Repaired Proof:
theorem index_eq_zero_of_le_card [Fintype G] (h : Fintype.card G ≤ n) : H.index = 0 :=
  H.index_le_of_le_card (lt_of_le_of_lt h (lt_pow_self prime_of_card_group hG))

Repaired Proof:
theorem index_ne_zero_of_le_card [Fintype G] (h : n ≤ Fintype.card G) : H.index ≠ 0 :=
  mt H.index_eq_zero_of_le_card h.not_le

Repaired Proof:
theorem index_ne_zero_of_le_card [Fintype G] (h : n ≤ Fintype.card G) : H.index ≠ 0 :=
  mt H.index_eq_zero_of_le_card h.not_le

Repaired Proof:
theorem index_eq_zero_of_le_one [Fintype G] (h : Fintype.card G ≤ 1) : H.index = 0 :=
  H.index_eq_zero_of_le_card (h.trans_lt Fintype.one_lt_card_iff_one_lt_card.mpr one_lt_two)

Repaired Proof:
theorem index_eq_zero_of_le_one [Fintype G] (h : Fintype.card G ≤ 1) : H.index = 0 :=
  H.index_eq_zero_of_le_card (h.trans_lt Fintype.one_lt_card_iff_one_lt_card.mpr one_lt_two)

Repaired Proof:
theorem index_eq_zero_of_le_one' [Fintype G] (h : 1 < Fintype.card G) : H.index = 0 :=
  H.index_eq_zero_of_le_card (le_of_lt h)

Repaired Proof:
theorem index_eq_zero_of_le_one' [Fintype G] (h : 1 < Fintype.card G) : H.index = 0 :=
  H.index_eq_zero_of_le_card (le_of_lt h)

Repaired Proof:
theorem index_ne_zero_of_finite [Finite G] : H.index ≠ 0 :=
  H.index_ne_zero_of_le_card (card_le_of_finite G)

Repaired Proof:
theorem index_ne_zero_of_finite [Finite G] : H.index ≠ 0 :=
  H.index_ne_zero_of_le_card (card_le_of_finite G)

Repaired Proof:
theorem index_eq_zero_of_infinite [Infinite G] : H.index = 0 :=
  H.index_eq_zero_of_le_card (le_of_eq (card_eq_zero_of_infinite G))

Repaired Proof:
theorem index_eq_zero_of_infinite [Infinite G] : H.index = 0 :=
  H.index_eq_zero_of_le_card (le_of_eq (card_eq_zero_of_infinite G))

Repaired Proof:
theorem index_ne_zero_of_finite_index [FiniteIndex H] : H.index ≠ 0 :=
  H.index_ne_zero_of_finite

Repaired Proof:
theorem index_ne_zero_of_finite_index [FiniteIndex H] : H.index ≠ 0 :=
  H.index_ne_zero_of_finite

Repaired Proof:
theorem finiteIndex_of_finite_quotient [Finite (G ⧸ H)] : FiniteIndex H :=
  ⟨inferInstance⟩

Repaired Proof:
theorem finiteIndex_of_finite_quotient [Finite (G ⧸ H)] : FiniteIndex H :=
  ⟨inferInstance⟩

Repaired Proof:
theorem finiteIndex_of_index_ne_zero (h : H.index ≠ 0) : FiniteIndex H :=
  ⟨index_ne_zero_of_finite_index h⟩

Repaired Proof:
theorem finiteIndex_of_index_ne_zero (h : H.index ≠ 0) : FiniteIndex H :=
  ⟨index_ne_zero_of_finite_index h⟩

Repaired Proof:
theorem finiteIndex_of_finite [Finite G] : FiniteIndex H :=
  (H.finiteIndex_of_index_ne_zero H.index_ne_zero_of_finite).of_finite_index

Repaired Proof:
theorem finiteIndex_of_finite [Finite G] : FiniteIndex H :=
  (H.finiteIndex_of_index_ne_zero H.index_ne_zero_of_finite).of_finite_index

Repaired Proof:
theorem finiteIndex_of_finite_quotient [Finite (G ⧸ H)] : FiniteIndex H :=
  (H.finiteIndex_of_index_ne_zero H.index_ne_zero_of_finite_index).of_finite_index

Repaired Proof:
theorem finiteIndex_of_finite_quotient [Finite (G ⧸ H)] : FiniteIndex H :=
  (H.

Attempt failure.

Working on Mathlib/GroupTheory/PushoutI.lean - 2024-09-09 00:49:33.300364.
---93/200---
For theorem Monoid.PushoutI.inf_of_range_eq_base_range in Mathlib/GroupTheory/PushoutI.lean:
theorem inf_of_range_eq_base_range (hφ : ∀ i, Injective (φ i)) {i j : ι} (hij : i ≠ j) :
    (of i).range ⊓ (of j).range = (base φ).range 


Original valid proof:
:=
  le_antisymm
    (by
      intro x ⟨⟨g₁, hg₁⟩, ⟨g₂, hg₂⟩⟩
      by_contra hx
      have hx1 : x ≠ 1 := by rintro rfl; simp_all only [ne_eq, one_mem, not_true_eq_false]
      have hg₁1 : g₁ ≠ 1 :=
        ne_of_apply_ne (of (φ := φ) i) (by simp_all)
      have hg₂1 : g₂ ≠ 1 :=
        ne_of_apply_ne (of (φ := φ) j) (by simp_all)
      have hg₁r : g₁ ∉ (φ i).range := by
        rintro ⟨y, rfl⟩
        subst hg₁
        exact hx (of_apply_eq_base φ i y ▸ MonoidHom.mem_range.2 ⟨y, rfl⟩)
      have hg₂r : g₂ ∉ (φ j).range := by
        rintro ⟨y, rfl⟩
        subst hg₂
        exact hx (of_apply_eq_base φ j y ▸ MonoidHom.mem_range.2 ⟨y, rfl⟩)
      let w : Word G := ⟨[⟨_, g₁⟩, ⟨_, g₂⁻¹⟩], by simp_all, by simp_all⟩
      have hw : Reduced φ w := by
        simp only [not_exists, ne_eq, Reduced, List.find?, List.mem_cons, List.mem_singleton,
          forall_eq_or_imp, not_false_eq_true, forall_const, forall_eq, true_and, hg₁r, hg₂r,
          List.mem_nil_iff, false_imp_iff, imp_true_iff, and_true, inv_mem_iff]
      have := hw.eq_empty_of_mem_range hφ (by
        simp only [Word.prod, List.map_cons, List.prod_cons, List.prod_nil,
          List.map_nil, map_mul, ofCoprodI_of, hg₁, hg₂, map_inv, map_one, mul_one,
          mul_inv_self, one_mem])
      simp [w, Word.empty] at this)
    (le_inf
      (by rw [← of_comp_eq_base i]
          rintro _ ⟨h, rfl⟩
          exact MonoidHom.mem_range.2 ⟨φ i h, rfl⟩)
      (by rw [← of_comp_eq_base j]
          rintro _ ⟨h, rfl⟩
          exact MonoidHom.mem_range.2 ⟨φ j h, rfl⟩))


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
⊓ (of j).range := by
  rw [← of_disjoint_base_of_ne hij]
  apply Submodule.inf_sup_left

theorem of_mem_range_of_ne {i j : ι} (hij : i ≠ j) {x : M} (hx : x ∈ (of i).range) :
    ∃ y, y ∈ (of j).range ∧ (of i).toLinearMap x + (of j).toLinearMap y = x := by
  obtain ⟨y, rfl⟩ := hx
  use φ i j y
  simp [of_f_apply_f hij]

theorem of_mem_range_of_ne' {i j : ι} (hij : i ≠ j) {x : M} (hx : x ∈ (of j).range) :
    ∃ y, y ∈ (of i).range ∧ (of i).toLinearMap y + (of j).toLinearMap x = x := by
  obtain ⟨y, rfl⟩ := hx
  use φ j i y
  simp [of_f_apply_f hij.symm]

theorem of_mem_range_of_ne_aux {i j k : ι} (hij : i ≠ j) (hik : i ≠ k) {x : M}
    (hx : x ∈ (of i).range ⊓ (of j).range) :
    ∃ y, y ∈ (of i).range ⊓ (of k).range ∧ (of j).toLinearMap x + (of k).toLinearMap y = x := by
  obtain ⟨y, hy, rfl⟩ := of_mem_range_of_ne hij hx.2
  obtain ⟨z, hz, hz'⟩ := of_mem_range_of_ne' hik hy
  refine' ⟨φ i k z, ⟨_, _⟩, _⟩
  · rw [← of_f_apply_f hik]
    exact ⟨_, hz, rfl⟩
  · rw [← of_f_apply_f hik]
    exact ⟨_, hz', rfl⟩
  · simp_rw [map_add]
    rw [of_f_apply_f hij, of_f_apply_f hik, of_f_apply_f hij.symm, of_f_apply_f hik.symm,
      add_comm (φ i j _), add_comm (φ i k _), hz']

theorem of_mem_range_of_ne_aux' {i j k : ι} (hij : i ≠ j) (hik : i ≠ k) {x : M}
    (hx : x ∈ (of j).range ⊓ (of k).range) :
    ∃ y, y ∈ (of j).range ⊓ (of i).range ∧ (of k).toLinearMap x + (of i).toLinearMap y = x := by
  obtain ⟨y, hy, rfl⟩ := of_mem_range_of_ne' hij hx.2
  obtain ⟨z, hz, hz'⟩ := of_mem_range_of_ne hiik hy
  refine ⟨φ j i z, ⟨?_, ?_⟩, ?_⟩
  · rw [← of_f_apply_f hij.symm]
    exact ⟨_, hz, rfl⟩
  · rw [← of_f_apply_f hij.symm]
    exact ⟨_, hz', rfl⟩
  · simp_rw [map_add]
    rw [of_f_apply_f hij, of_f_apply_f hiik, of_f_apply_f hij.symm, of_f_apply_f hiik.symm,
      add_comm (φ j i _), add_comm (φ j k _), hz']

Repaired Proof:
theorem of_mem_range_of_ne_aux {i j k : ι} (hij : i ≠ j) (hik : i ≠ k) {x : M}
    (hx : x ∈ (of i).range ⊓ (of j).range) :
    ∃ y, y ∈ (of i).range ⊓ (of k).range ∧ (of j).toLinearMap x + (of k).toLinearMap y = x := by
  obtain ⟨y, hy, rfl⟩ := of_mem_range_of_ne hij hx.2
  obtain ⟨z, hz, hz'⟩ := of_mem_range_of_ne' hik hy
  refine ⟨φ i k z, ⟨?_, ?_⟩, ?_⟩
  · rw [← of_f_apply_f hik]
    exact ⟨_, hz, rfl⟩
  · rw [← of_f_apply_f hik]
    exact ⟨_, hz', rfl⟩
  · simp_rw [map_add]
    rw [of_f_apply_f hij, of_f_apply_f hik, of_f_apply_f hij.symm, of_f_apply_f hik.symm,
      add_comm (φ i j _), add_comm (φ i k _), hz']

theorem of_mem_range_of_ne_aux' {i j k : ι} (hij : i ≠ j) (hik : i ≠ k) {x : M}
    (hx : x ∈ (of j).range ⊓ (of k).range) :
    ∃ y, y ∈ (of j).range ⊓ (of i).range ∧ (of k).toLinearMap x + (of i).toLinearMap y = x := by
  obtain ⟨y, hy, rfl⟩ := of_mem_range_of_ne' hij hx.2
  obtain ⟨z, hz, hz'⟩ := of_mem_range_of_ne hiik hy
  refine ⟨φ j i z, ⟨?_, ?_⟩, ?_⟩
  · rw [← of_f_apply_f hij.symm]
    exact ⟨_, hz, rfl⟩
  · rw [← of_f_apply_f hij.symm]
    exact ⟨_, hz', rfl⟩
  · simp_rw [map_add]
    rw [of_f_apply_f hij, of_f_apply_f hiik, of_f_apply_f hij.symm, of_f_apply_f hiik.symm,
      add_comm (φ j i _), add_comm (φ j k _), hz']

Repaired Proof:
theorem of_mem_range_of_ne_aux {i j k : ι} (hij : i ≠ j) (hik : i ≠ k) {x : M}
    (hx : x ∈ (of i).range ⊓ (of j).range) :
    ∃ y, y ∈ (of i).range ⊓ (of k).range ∧ (of j).toLinearMap x + (of k).toLinearMap y = x := by
  obtain ⟨y, hy, rfl⟩ := of_mem_range_of_ne hij hx.2
  obtain ⟨z, hz, hz'⟩ := of_mem_range_of_ne' hik hy
  refine ⟨φ i k z, ⟨?_, ?_⟩, ?_⟩
  · rw [← of_f_apply_f hik]
    exact ⟨_, hz, rfl⟩
  · rw [← of_f_apply_f hik]
    exact ⟨_, hz', rfl⟩
  · simp_rw [map_add]
    rw [of_f_apply_f hij, of_f_apply_f hik, of_f_apply_f hij.symm, of_f_apply_f hik.symm,
      add_comm (φ i j _), add_comm (φ i k _), hz']

theorem of_mem_range_of_ne_aux' {i j k : ι} (hij : i ≠ j) (hik : i ≠ k) {x :

Attempt failure.

Working on Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean - 2024-09-09 00:49:58.350995.
---94/200---
For theorem affineSpan_le_toAffineSubspace_span in Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean:
lemma affineSpan_le_toAffineSubspace_span {s : Set V} :
    affineSpan k s ≤ (Submodule.span k s).toAffineSubspace 


Original valid proof:
:= by
  intro x hx
  show x ∈ Submodule.span k s
  induction hx using affineSpan_induction' with
  | mem x hx => exact Submodule.subset_span hx
  | smul_vsub_vadd c u _ v _ w _ hu hv hw =>
    simp only [vsub_eq_sub, vadd_eq_add]
    apply Submodule.add_mem _ _ hw
    exact Submodule.smul_mem _ _ (Submodule.sub_mem _ hu hv)


Verifying proof (Commit 9bc35020058f4a5a844eb7662d9de673056d4dbe):
⊥ := by
  rintro p ⟨p1, hp1, v, hv, rfl⟩
  refine vadd_mem_of_mem_direction ?_ (zero_vadd _ _)
  suffices ∀ v1 ∈ s, v -ᵥ v1 ∈ Submodule.span k s by exact this v hv1
  intro v1 hv1
  rw [Submodule.mem_span] at hv ⊢
  exact fun p hp ↦ hp (Submodule.sub_mem _ hv (hp ⟨v1, hv1, rfl⟩))

lemma affineSpan_le_toAffineSubspace_span_singleton {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p}).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span _).trans ?_
  rw [Set.singleton_subset_iff]
  exact hp

lemma affineSpan_le_toAffineSubspace_span_set {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p}).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span _).trans ?_
  rw [Set.singleton_subset_iff]
  exact hp

lemma affineSpan_le_toAffineSubspace_span_set' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set'' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set'''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set'''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set''''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set'''''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set''''''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set'''''''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set''''''''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set'''''''''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set''''''''''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set'''''''''''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set''''''''''''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).toAffineSubspace ⊥ := by
  refine (affineSpan_le_toAffineSubspace_span_set hp).trans ?_
  rw [Submodule.toAffineSubspace_bot, bot_le]

lemma affineSpan_le_toAffineSubspace_span_set'''''''''''''''' {s : Set V} {p : V} (hp : p ∈ s) :
    affineSpan k s ≤ (Submodule.span k {p} : Submodule k V).to

Attempt failure.

---95/200---
For theorem direction_affineSpan in Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean:
theorem direction_affineSpan (s : Set P) : (affineSpan k s).direction = vectorSpan k s 


Original valid proof:
:= by
  apply le_antisymm
  · refine Submodule.span_le.2 ?_
    rintro v ⟨p1, ⟨p2, hp2, v1, hv1, hp1⟩, p3, ⟨p4, hp4, v2, hv2, hp3⟩, rfl⟩
    simp only [SetLike.mem_coe]
    rw [hp1, hp3, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc]
    exact
      (vectorSpan k s).sub_mem ((vectorSpan k s).add_mem hv1 (vsub_mem_vectorSpan k hp2 hp4)) hv2
  · exact vectorSpan_mono k (subset_spanPoints k s)


Verifying proof (Commit f27ef6dc0fb66aa1c033b41bb16e840c0a1527a5):
∩ V :=
    Submodule.span_inf_eq_right.mpr (vectorSpan_le _ _)

@[simp]
theorem direction_affineSpan_singleton (p : P) :
    (affineSpan k ({p} : Set P)).direction = ⊤ := by
  rw [direction_affineSpan, vectorSpan_singleton, Submodule.inf_top_eq]

@[simp]
theorem direction_affineSpan_pair (p₁ p₂ : P) :
    (affineSpan k ({p₁, p₂} : Set P)).direction = vectorSpan k ({p₁, p₂} : Set P) := by
  rw [direction_affineSpan, vectorSpan_pair, Submodule.inf_idem]

@[simp]
theorem direction_affineSpan_insert (s : Set P) (p : P) :
    (affineSpan k (insert p s)).direction = vectorSpan k (insert p s) := by
  rw [direction_affineSpan, vectorSpan_insert_eq_vectorSpan]

@[simp]
theorem direction_affineSpan_image_Icc (f : ι → P) (a b : ι) :
    (affineSpan k (f '' Set.Icc a b)).direction = vectorSpan k (f '' Set.Icc a b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_uIcc (f : ι → P) (a b : ι) :
    (affineSpan k (f '' uIcc a b)).direction = vectorSpan k (f '' uIcc a b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Icc_left (f : ι → P) (b : ι) :
    (affineSpan k (f '' Set.Icc (⊥ : WithBot ι) b)).direction = vectorSpan k (f '' Set.Icc (⊥ : WithBot ι) b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Icc_right (f : ι → P) (a : ι) :
    (affineSpan k (f '' Set.Icc a (⊤ : WithTop ι))).direction = vectorSpan k (f '' Set.Icc a (⊤ : WithTop ι)) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Icc_left' (f : ι → P) (b : ι) :
    (affineSpan k (f '' Set.Icc (⊥ : WithTop ι) b)).direction = vectorSpan k (f '' Set.Icc (⊥ : WithTop ι) b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Icc_right' (f : ι → P) (a : ι) :
    (affineSpan k (f '' Set.Icc a (⊤ : WithTop ι))).direction = vectorSpan k (f '' Set.Icc a (⊤ : WithTop ι)) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ioc (f : ι → P) (a b : ι) :
    (affineSpan k (f '' Set.Ioc a b)).direction = vectorSpan k (f '' Set.Ioc a b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ioc' (f : ι → P) {a b : ι} (h : a ≤ b) :
    (affineSpan k (f '' Set.Ioc a b)).direction = vectorSpan k (f '' Set.Ioc a b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ico (f : ι → P) (a b : ι) :
    (affineSpan k (f '' Set.Ico a b)).direction = vectorSpan k (f '' Set.Ico a b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ico' (f : ι → P) {a b : ι} (h : a ≤ b) :
    (affineSpan k (f '' Set.Ico a b)).direction = vectorSpan k (f '' Set.Ico a b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ioo (f : ι → P) (a b : ι) :
    (affineSpan k (f '' Set.Ioo a b)).direction = vectorSpan k (f '' Set.Ioo a b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ioo' (f : ι → P) {a b : ι} (h : a ≤ b) :
    (affineSpan k (f '' Set.Ioo a b)).direction = vectorSpan k (f '' Set.Ioo a b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ioc_left (f : ι → P) {b : ι} (h : ⊥ ≤ b) :
    (affineSpan k (f '' Set.Ioc ⊥ b)).direction = vectorSpan k (f '' Set.Ioc ⊥ b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ioc_right (f : ι → P) {a : ι} (h : a ≤ ⊤) :
    (affineSpan k (f '' Set.Ioc a ⊤)).direction = vectorSpan k (f '' Set.Ioc a ⊤) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ico_left (f : ι → P) {b : ι} (h : ⊥ ≤ b) :
    (affineSpan k (f '' Set.Ico ⊥ b)).direction = vectorSpan k (f '' Set.Ico ⊥ b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ico_right (f : ι → P) {a : ι} (h : a ≤ ⊤) :
    (affineSpan k (f '' Set.Ico a ⊤)).direction = vectorSpan k (f '' Set.Ico a ⊤) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Icc_left' (f : ι → P) {b : ι} (h : ⊥ ≤ b) :
    (affineSpan k (f '' Set.Icc ⊥ b)).direction = vectorSpan k (f '' Set.Icc ⊥ b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Icc_right' (f : ι → P) {a : ι} (h : a ≤ ⊤) :
    (affineSpan k (f '' Set.Icc a ⊤)).direction = vectorSpan k (f '' Set.Icc a ⊤) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ico_left' (f : ι → P) {b : ι} (h : ⊥ ≤ b) :
    (affineSpan k (f '' Set.Ico ⊥ b)).direction = vectorSpan k (f '' Set.Ico ⊥ b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ico_right' (f : ι → P) {a : ι} (h : a ≤ ⊤) :
    (affineSpan k (f '' Set.Ico a ⊤)).direction = vectorSpan k (f '' Set.Ico a ⊤) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ioc_left' (f : ι → P) {b : ι} (h : ⊥ ≤ b) :
    (affineSpan k (f '' Set.Ioc ⊥ b)).direction = vectorSpan k (f '' Set.Ioc ⊥ b) :=
  direction_affineSpan _ _

@[simp]
theorem direction_affineSpan_image_Ioc_right' (f : ι → P) {a : ι} (h : a ≤ ⊤) :
    (affineSpan k (f '' Set.Ioc a ⊤)).direction = vectorSpan k (f '' Set.Ioc a �

Attempt failure.

Working on Mathlib/LinearAlgebra/AffineSpace/Independent.lean - 2024-09-09 00:50:46.533362.
---96/200---
For theorem AffineIndependent.affineIndependent_of_not_mem_span in Mathlib/LinearAlgebra/AffineSpace/Independent.lean:
theorem AffineIndependent.affineIndependent_of_not_mem_span {p : ι → P} {i : ι}
    (ha : AffineIndependent k fun x : { y // y ≠ i } => p x)
    (hi : p i ∉ affineSpan k (p '' { x | x ≠ i })) : AffineIndependent k p 


Original valid proof:
:= by
  classical
    intro s w hw hs
    let s' : Finset { y // y ≠ i } := s.subtype (· ≠ i)
    let p' : { y // y ≠ i } → P := fun x => p x
    by_cases his : i ∈ s ∧ w i ≠ 0
    · refine False.elim (hi ?_)
      let wm : ι → k := -(w i)⁻¹ • w
      have hms : s.weightedVSub p wm = (0 : V) := by simp [wm, hs]
      have hwm : ∑ i ∈ s, wm i = 0 := by simp [wm, ← Finset.mul_sum, hw]
      have hwmi : wm i = -1 := by simp [wm, his.2]
      let w' : { y // y ≠ i } → k := fun x => wm x
      have hw' : ∑ x ∈ s', w' x = 1 := by
        simp_rw [w', s', Finset.sum_subtype_eq_sum_filter]
        rw [← s.sum_filter_add_sum_filter_not (· ≠ i)] at hwm
        simp_rw [Classical.not_not] at hwm
        erw [Finset.filter_eq'] at hwm
        simp_rw [if_pos his.1, Finset.sum_singleton, hwmi, ← sub_eq_add_neg, sub_eq_zero] at hwm
        exact hwm
      rw [← s.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one hms his.1 hwmi, ←
        (Subtype.range_coe : _ = { x | x ≠ i }), ← Set.range_comp, ←
        s.affineCombination_subtype_eq_filter]
      exact affineCombination_mem_affineSpan hw' p'
    · rw [not_and_or, Classical.not_not] at his
      let w' : { y // y ≠ i } → k := fun x => w x
      have hw' : ∑ x ∈ s', w' x = 0 := by
        simp_rw [w', s', Finset.sum_subtype_eq_sum_filter]
        rw [Finset.sum_filter_of_ne, hw]
        rintro x hxs hwx rfl
        exact hwx (his.neg_resolve_left hxs)
      have hs' : s'.weightedVSub p' w' = (0 : V) := by
        simp_rw [w', s', p', Finset.weightedVSub_subtype_eq_filter]
        rw [Finset.weightedVSub_filter_of_ne, hs]
        rintro x hxs hwx rfl
        exact hwx (his.neg_resolve_left hxs)
      intro j hj
      by_cases hji : j = i
      · rw [hji] at hj
        exact hji.symm ▸ his.neg_resolve_left hj
      · exact ha s' w' hw' hs' ⟨j, hji⟩ (Finset.mem_subtype.2 hj)


Verifying proof (Commit 141b72620243c872cad4ebe6d1abbfc83a8f9ece):
↔ i ∉ Set.univ := by
  constructor
  · rintro hi₁ h_univ
    rw [h_univ] at hi
    have h_collinear : Collinear k (p '' { x | x ≠ i }) := by
      refine' collinear_iff_of_two_eq_affineSpan.mpr ⟨i, _⟩
      ext x
      simp only [Set.mem_image, Set.mem_setOf_eq, exists_prop, Ne, mem_affineSpan,
        mem_affineSpan_iff_eq_affineSpan, mem_singleton_iff, exists_eq_right,
        exists_eq_right']
      constructor
      · rintro ⟨j, hj, rfl⟩
        rw [affineSpan_coe]
        exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne hj
            (Set.mem_univ j) (Set.mem_univ i) (by simp [hj])
      · rintro rfl
        exact ⟨i, Set.mem_univ i, rfl⟩
    refine' hi.not_mem_span_image _
    rw [collinear_iff_of_two_eq_affineSpan] at h_collinear
    rcases h_collinear with ⟨j, hj, h_col⟩
    refine' ⟨j, hj, _⟩
    rw [affineSpan_coe]
    exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne hj (Set.mem_univ j)
      (Set.mem_univ i) (by simp [hj])
  · rintro hi₁ h_univ
    have h_collinear : Collinear k (p '' { x | x ≠ i }) := by
      refine collinear_iff_of_two_eq_affineSpan.mpr ⟨i, ?_, ?_⟩
      · simp only [Set.mem_image, Set.mem_setOf_eq, exists_prop, Ne, mem_affineSpan,
          mem_affineSpan_iff_eq_affineSpan, mem_singleton_iff, exists_eq_right,
          exists_eq_right']
        rintro ⟨j, hj, rfl⟩
        rw [affineSpan_coe]
        exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne hj
            (Set.mem_univ j) (Set.mem_univ i) (by simp [hj])
      · rw [affineSpan_coe]
        exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne h_univ
            (Set.mem_univ i) (Set.mem_univ i) (by simp)
    refine hi₁.not_mem_span_image ?_
    rw [collinear_iff_of_two_eq_affineSpan] at h_collinear
    rcases h_collinear with ⟨j, hj, h_col⟩
    refine ⟨j, hj, ?_⟩
    rw [affineSpan_coe]
    exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne hj (Set.mem_univ j)
      (Set.mem_univ i) (by simp [hj])

Repaired Proof:
theorem AffineIndependent.affineIndependent_of_not_mem_span {p : ι → P} {i : ι}
    (ha : AffineIndependent k fun x : { y // y ≠ i } => p x)
    (hi : p i ∉ affineSpan k (p '' { x | x ≠ i })) : AffineIndependent k p ↔ i ∉ Set.univ := by
  constructor
  · rintro hi₁ h_univ
    rw [h_univ] at hi
    have h_collinear : Collinear k (p '' { x | x ≠ i }) := by
      refine collinear_iff_of_two_eq_affineSpan.mpr ⟨i, ?_, ?_⟩
      · simp only [Set.mem_image, Set.mem_setOf_eq, exists_prop, Ne, mem_affineSpan,
          mem_affineSpan_iff_eq_affineSpan, mem_singleton_iff, exists_eq_right,
          exists_eq_right']
        rintro ⟨j, hj, rfl⟩
        rw [affineSpan_coe]
        exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne hj
            (Set.mem_univ j) (Set.mem_univ i) (by simp [hj])
      · rw [affineSpan_coe]
        exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne h_univ
            (Set.mem_univ i) (Set.mem_univ i) (by simp)
    refine hi.not_mem_span_image ?_
    rw [collinear_iff_of_two_eq_affineSpan] at h_collinear
    rcases h_collinear with ⟨j, hj, h_col⟩
    refine ⟨j, hj, ?_⟩
    rw [affineSpan_coe]
    exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne hj (Set.mem_univ j)
      (Set.mem_univ i) (by simp [hj])
  · rintro hi₁ h_univ
    have h_collinear : Collinear k (p '' { x | x ≠ i }) := by
      refine collinear_iff_of_two_eq_affineSpan.mpr ⟨i, ?_, ?_⟩
      · simp only [Set.mem_image, Set.mem_setOf_eq, exists_prop, Ne, mem_affineSpan,
          mem_affineSpan_iff_eq_affineSpan, mem_singleton_iff, exists_eq_right,
          exists_eq_right']
        rintro ⟨j, hj, rfl⟩
        rw [affineSpan_coe]
        exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne hj
            (Set.mem_univ j) (Set.mem_univ i) (by simp [hj])
      · rw [affineSpan_coe]
        exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne h_univ
            (Set.mem_univ i) (Set.mem_univ i) (by simp)
    refine hi₁.not_mem_span_image ?_
    rw [collinear_iff_of_two_eq_affineSpan] at h_collinear
    rcases h_collinear with ⟨j, hj, h_col⟩
    refine ⟨j, hj, ?_⟩
    rw [affineSpan_coe]
    exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne hj (Set.mem_univ j)
      (Set.mem_univ i) (by simp [hj])

Repaired Proof:
theorem AffineIndependent.affineIndependent_of_not_mem_span {p : ι → P} {i : ι}
    (ha : AffineIndependent k fun x : { y // y ≠ i } => p x)
    (hi : p i ∉ affineSpan k (p '' { x | x ≠ i })) : AffineIndependent k p ↔ i ∉ Set.univ := by
  constructor
  · rintro hi₁ h_univ
    rw [h_univ] at hi
    have h_collinear : Collinear k (p '' { x | x ≠ i }) := by
      refine collinear_iff_of_two_eq_affineSpan.mpr ⟨i, ?_, ?_⟩
      · simp only [Set.mem_image, Set.mem_setOf_eq, exists_prop, Ne, mem_affineSpan,
          mem_affineSpan_iff_eq_affineSpan, mem_singleton_iff, exists_eq_right,
          exists_eq_right']
        rintro ⟨j, hj, rfl⟩
        rw [affineSpan_coe]
        exact ha.affineSpan_eq_of_exists_mem_inter_eq_affineSpan_of_ne hj
            (Set.mem_univ j) (Set.mem_univ i) (by simp [hj])
      · rw [affineSpan_coe]


Attempt failure.

Working on Mathlib/LinearAlgebra/Basis.lean - 2024-09-09 00:51:02.243492.
---97/200---
For theorem union_support_maximal_linearIndependent_eq_range_basis in Mathlib/LinearAlgebra/Basis.lean:
theorem union_support_maximal_linearIndependent_eq_range_basis {ι : Type w} (b : Basis ι R M)
    {κ : Type w'} (v : κ → M) (i : LinearIndependent R v) (m : i.Maximal) :
    ⋃ k, ((b.repr (v k)).support : Set ι) = Set.univ 


Original valid proof:
:= by
  by_contra h
  simp only [← Ne.eq_def, ne_univ_iff_exists_not_mem, mem_iUnion, not_exists_not,
    Finsupp.mem_support_iff, Finset.mem_coe] at h
  obtain ⟨b', w⟩ := h
  let v' : Option κ → M := fun o => o.elim (b b') v
  have r : range v ⊆ range v' := by
    rintro - ⟨k, rfl⟩
    use some k
    simp only [v', Option.elim_some]
  have r' : b b' ∉ range v := by
    rintro ⟨k, p⟩
    simpa [w] using congr_arg (fun m => (b.repr m) b') p
  have r'' : range v ≠ range v' := by
    intro e
    have p : b b' ∈ range v' := by
      use none
      simp only [v', Option.elim_none]
    rw [← e] at p
    exact r' p
  have i' : LinearIndependent R ((↑) : range v' → M) := by
    apply LinearIndependent.to_subtype_range
    rw [linearIndependent_iff]
    intro l z
    rw [Finsupp.total_option] at z
    simp only [v', Option.elim'] at z
    change _ + Finsupp.total κ M R v l.some = 0 at z
    have l₀ : l none = 0 := by
      rw [← eq_neg_iff_add_eq_zero] at z
      replace z := neg_eq_iff_eq_neg.mpr z
      apply_fun fun x => b.repr x b' at z
      simp only [repr_self, map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply,
        Finsupp.smul_single', map_neg, Finsupp.coe_neg] at z
      erw [DFunLike.congr_fun (Finsupp.apply_total R (b.repr : M →ₗ[R] ι →₀ R) v l.some) b'] at z
      simpa [Finsupp.total_apply, w] using z
    have l₁ : l.some = 0 := by
      rw [l₀, zero_smul, zero_add] at z
      exact linearIndependent_iff.mp i _ z
    ext (_ | a)
    · simp only [l₀, Finsupp.coe_zero, Pi.zero_apply]
    · erw [DFunLike.congr_fun l₁ a]
      simp only [Finsupp.coe_zero, Pi.zero_apply]
  rw [LinearIndependent.Maximal] at m
  specialize m (range v') i' r
  exact r'' m


Verifying proof (Commit b09462282225ca03a37b7e6afde435d1ab7552ef):
∧
      LinearIndependent.repr i = Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘
        Finsupp.embDomain (Function.Embedding.subtype _) := by
  classical
    have hv : ∀ k, ∃ s : Finset ι, ↑s = b.repr (v k).support := by
      intro k
      exact ⟨(b.repr (v k)).support.toFinset, Finsupp.support_toFinset _⟩
    choose s hs using hv
    have hs' : ∀ k, ⋃ j, ((b.repr (v j)).support : Set ι) = Set.univ := by
      intro k
      simp_rw [← hs]
      rw [← Set.iUnion_eq_univ_iff]
      intro j
      exact ⟨j, (b.repr (v j)).support.mem_toFinset⟩
    have h_ind : ∀ k, LinearIndependent R (b ∘ (↑) : s k → M) := by
      intro k
      have h_ind : LinearIndependent R (b ∘ (↑) : (b.repr (v k)).support → M) :=
        b.repr (v k).linearIndependent_support
      rw [← hs] at h_ind
      rwa [← LinearIndependent.comp_subtype_range]
    have h_range : ∀ k, range (b ∘ (↑) : s k → M) = range v := by
      intro k
      have h_range : range (b ∘ (↑) : (b.repr (v k)).support → M) = range v :=
        b.repr (v k).range_comp_subtype
      rw [← hs] at h_range
      rwa [← range_comp]
    have h_basis : ∀ k, Basis (s k) R M := by
      intro k
      have h_basis : Basis (b.repr (v k)).support R M :=
        b.repr (v k).basis_repr
      rw [← hs] at h_basis
      rwa [← Basis.map_ofVectorSpaceIndex]
    have h_eq : ∀ k, LinearIndependent.repr i =
        Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘ Finsupp.embDomain (Embedding.subtype _) := by
      intro k
      have h_eq : LinearIndependent.repr i =
          (b.mapCoeffs (s k) (h_basis k).repr).repr :=
        i.repr_eq_of_basis (h_basis k) (h_range k)
      rw [← hs] at h_eq
      rwa [← Basis.map_repr] at h_eq
    refine ⟨hs', h_eq ?_⟩
    have h_ind' : ∀ k, LinearIndependent R (b ∘ (↑) : ⋃ j, s j → M) := by
      intro k
      have h_ind' : LinearIndependent R (b ∘ (↑) : ⋃ j, (b.repr (v j)).support → M) :=
        LinearIndependent.iUnion_of_directed s (directed_of_sup m.1) (fun k => h_ind k) fun k =>
          h_range k
      rw [← hs] at h_ind'
      rwa [← iUnion_subtype]
    have h_range' : range (b ∘ (↑) : ⋃ j, s j → M) = range v :=
      range_comp_of_range_iUnion_eq_of_linearIndependent s v h_ind' i h_range
    have h_basis' : Basis (⋃ j, s j) R M :=
      Basis.iUnion_of_linearIndependent_of_iUnion_eq_univ i h_ind' hs' h_basis h_range'
    have h_eq' : LinearIndependent.repr i =
        Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘ Finsupp.embDomain (Embedding.subtype _) :=
      i.repr_eq_of_basis h_basis' h_range'
    exact m.2 h_eq'

Repaired Proof:
theorem union_support_maximal_linearIndependent_eq_range_basis {ι : Type w} (b : Basis ι R M)
    {κ : Type w'} (v : κ → M) (i : LinearIndependent R v) (m : i.Maximal) :
    ⋃ k, ((b.repr (v k)).support : Set ι) = Set.univ ∧
      LinearIndependent.repr i = Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘
        Finsupp.embDomain (Function.Embedding.subtype _) := by
  classical
    have hv : ∀ k, ∃ s : Finset ι, ↑s = b.repr (v k).support := by
      intro k
      exact ⟨(b.repr (v k)).support.toFinset, Finsupp.support_toFinset _⟩
    choose s hs using hv
    have hs' : ∀ k, ⋃ j, ((b.repr (v j)).support : Set ι) = Set.univ := by
      intro k
      simp_rw [← hs]
      rw [← Set.iUnion_eq_univ_iff]
      intro j
      exact ⟨j, (b.repr (v j)).support.mem_toFinset⟩
    have h_ind : ∀ k, LinearIndependent R (b ∘ (↑) : s k → M) := by
      intro k
      have h_ind : LinearIndependent R (b ∘ (↑) : (b.repr (v k)).support → M) :=
        b.repr (v k).linearIndependent_support
      rw [← hs] at h_ind
      rwa [← LinearIndependent.comp_subtype_range]
    have h_range : ∀ k, range (b ∘ (↑) : s k → M) = range v := by
      intro k
      have h_range : range (b ∘ (↑) : (b.repr (v k)).support → M) = range v :=
        b.repr (v k).range_comp_subtype
      rw [← hs] at h_range
      rwa [← range_comp]
    have h_basis : ∀ k, Basis (s k) R M := by
      intro k
      have h_basis : Basis (b.repr (v k)).support R M :=
        b.repr (v k).basis_repr
      rw [← hs] at h_basis
      rwa [← Basis.map_ofVectorSpaceIndex]
    have h_eq : ∀ k, LinearIndependent.repr i =
        Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘ Finsupp.embDomain (Embedding.subtype _) := by
      intro k
      have h_eq : LinearIndependent.repr i =
          (b.mapCoeffs (s k) (h_basis k).repr).repr :=
        i.repr_eq_of_basis (h_basis k) (h_range k)
      rw [← hs] at h_eq
      rwa [← Basis.map_repr] at h_eq
    refine ⟨hs', h_eq ?_⟩
    have h_ind' : ∀ k, LinearIndependent R (b ∘ (↑) : ⋃ j, s j → M) := by
      intro k
      have h_ind' : LinearIndependent R (b ∘ (↑) : ⋃ j, (b.repr (v j)).support → M) :=
        LinearIndependent.iUnion_of_directed s (directed_of_sup m.1) (fun k => h_ind k) fun k =>
          h_range k
      rw [← hs] at h_ind'
      rwa [← iUnion_subtype]
    have h_range' : range (b ∘ (↑) : ⋃ j, s j → M) = range v :=
      range_comp_of_range_iUnion_eq_of_linearIndependent s v h_ind' i h_range
    have h_basis' : Basis (⋃ j, s j) R M :=
      Basis.iUnion_of_linearIndependent_of_iUnion_eq_univ i h_ind' hs' h_basis h_range'
    have h_eq' : LinearIndependent.repr i =
        Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘ Finsupp.embDomain (Embedding.subtype _) :=
      i.repr_eq_of_basis h_basis' h_range'
    exact m.2 h_

Attempt failure.

Working on Mathlib/LinearAlgebra/BilinearForm/Properties.lean - 2024-09-09 00:51:29.765111.
---98/200---
For theorem LinearMap.BilinForm.dualBasis_dualBasis_flip in Mathlib/LinearAlgebra/BilinearForm/Properties.lean:
lemma dualBasis_dualBasis_flip (B : BilinForm K V) (hB : B.Nondegenerate) {ι}
    [Finite ι] [DecidableEq ι] (b : Basis ι K V) :
    B.dualBasis hB (B.flip.dualBasis hB.flip b) = b 


Original valid proof:
:= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ↦ ?_))
  simp_rw [apply_dualBasis_left, ← B.flip_apply, apply_dualBasis_left, @eq_comm _ i j]


Verifying proof (Commit 31c261277bc3e8a52b74d248691ef6b40c75b452):
∘ Finset.univ.orderIsoOfFin.symm := by
  classical
  let e : Fin (Fintype.card ι) ≃ ι := Fintype.equivOfCardEq (Fintype.card_fin _)
  have he : ∀ i, e (Fintype.card ι - 1 - i) = Finset.univ.orderIsoOfFin.symm i := by
    intro i
    rw [Fintype.card_fin]
    simp_rw [Fintype.equivOfCardEq_apply]
    rw [Finset.orderIsoOfFin_symm_apply]
    simp
  ext i
  rw [Basis.apply_dualBasis_left, ← he, ← Basis.coord_apply b, ← LinearEquiv.map_smul,
    ← LinearMap.map_smul, ← LinearMap.map_sum, ← LinearEquiv.map_sum, ← Finsupp.total_apply,
    ← Finsupp.total_comp, ← Finsupp.total_comp, ← Finsupp.total_eq_fintype_total _ _ _ b,
    ← Finsupp.total_eq_fintype_total _ _ _ (B.dualBasis hB)]
  congr
  ext j
  simp_rw [Basis.coord_apply, ← he, ← Basis.apply_dualBasis_left, smul_eq_mul, mul_ite, mul_one,
    mul_zero, Finset.sum_ite_eq', Finset.mem_univ, ite_true]

Repaired Proof:
lemma dualBasis_dualBasis_flip (B : BilinForm K V) (hB : B.Nondegenerate) {ι}
    [Finite ι] [DecidableEq ι] (b : Basis ι K V) :
    B.dualBasis hB (B.flip.dualBasis hB.flip b) = b ∘ Finset.univ.orderIsoOfFin.symm := by
  classical
  let e : Fin (Fintype.card ι) ≃ ι := Fintype.equivOfCardEq (Fintype.card_fin _)
  have he : ∀ i, e (Fintype.card ι - 1 - i) = Finset.univ.orderIsoOfFin.symm i := by
    intro i
    rw [Fintype.card_fin]
    simp_rw [Fintype.equivOfCardEq_apply]
    rw [Finset.orderIsoOfFin_symm_apply]
    simp
  ext i
  rw [Basis.apply_dualBasis_left, ← he, ← Basis.coord_apply b, ← LinearEquiv.map_smul,
    ← LinearMap.map_smul, ← LinearMap.map_sum, ← LinearEquiv.map_sum, ← Finsupp.total_apply,
    ← Finsupp.total_comp, ← Finsupp.total_comp, ← Finsupp.total_eq_fintype_total _ _ _ b,
    ← Finsupp.total_eq_fintype_total _ _ _ (B.dualBasis hB)]
  congr
  ext j
  simp_rw [Basis.coord_apply, ← he, ← Basis.apply_dualBasis_left, smul_eq_mul, mul_ite, mul_one,
    mul_zero, Finset.sum_ite_eq', Finset.mem_univ, ite_true]

Repaired Proof:
lemma dualBasis_dualBasis_flip (B : BilinForm K V) (hB : B.Nondegenerate) {ι}
    [Finite ι] [DecidableEq ι] (b : Basis ι K V) :
    B.dualBasis hB (B.flip.dualBasis hB.flip b) = b ∘ Finset.univ.orderIsoOfFin.symm := by
  classical
  let e : Fin (Fintype.card ι) ≃ ι := Fintype.equivOfCardEq (Fintype.card_fin _)
  have he : ∀ i, e (Fintype.card ι - 1 - i) = Finset.univ.orderIsoOfFin.symm i := by
    intro i
    rw [Fintype.card_fin]
    simp_rw [Fintype.equivOfCardEq_apply]
    rw [Finset.orderIsoOfFin_symm_apply]
    simp
  ext i
  rw [Basis.apply_dualBasis_left, ← he, ← Basis.coord_apply b, ← LinearEquiv.map_smul,
    ← LinearMap.map_smul, ← LinearMap.map_sum, ← LinearEquiv.map_sum, ← Finsupp.total_apply,
    ← Finsupp.total_comp, ← Finsupp.total_comp, ← Finsupp.total_eq_fintype_total _ _ _ b,
    ← Finsupp.total_eq_fintype_total _ _ _ (B.dualBasis hB)]
  congr
  ext j
  simp_rw [Basis.coord_apply, ← he, ← Basis.apply_dualBasis_left, smul_eq_mul, mul_ite, mul_one,
    mul_zero, Finset.sum_ite_eq', Finset.mem_univ, ite_true]

Attempt failure.

Working on Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean - 2024-09-09 00:51:52.737344.
---99/200---
For theorem ExteriorAlgebra.ιMulti_span in Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean:
lemma ιMulti_span :
    Submodule.span R (Set.range fun x : Σ n, (Fin n → M) => ιMulti R x.1 x.2) = ⊤ 


Original valid proof:
:= by
  rw [Submodule.eq_top_iff']
  intro x
  induction x using DirectSum.Decomposition.inductionOn fun i => ⋀[R]^i M with
  | h_zero => exact Submodule.zero_mem _
  | h_add _ _ hm hm' => exact Submodule.add_mem _ hm hm'
  | h_homogeneous hm =>
    let ⟨m, hm⟩ := hm
    apply Set.mem_of_mem_of_subset hm
    rw [← ιMulti_span_fixedDegree]
    refine Submodule.span_mono fun _ hx ↦ ?_
    obtain ⟨y, rfl⟩ := hx
    exact ⟨⟨_, y⟩, rfl⟩


Verifying proof (Commit 6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92):
 := by
  rw [← top_le_iff, ← (ιMulti R).range_comp_of_range_eq_top _ (ιMulti_range R)]
  rintro - ⟨x, rfl⟩
  induction x using FreeAddMonoid.recOn with
  | h0 =>
    rw [List.map_nil, List.sum_nil]
    exact zero_mem _
  | ih x xs ihx =>
    rw [List.map_cons, List.sum_cons]
    exact add_mem (Submodule.subset_span (Set.mem_range_self _)) ihx

Reparameterization.ιMulti_span :
    Submodule.span R (Set.range fun x : Σ n, (Fin n → M) => ιMulti R x.1 x.2) = ⊤ := by
  rw [← top_le_iff, ← (ιMulti R).range_comp_of_range_eq_top _ (ιMulti_range R)]
  rintro - ⟨x, rfl⟩
  induction x using FreeAddMonoid.recOn with
  | h0 =>
    rw [List.map_nil, List.sum_nil]
    exact zero_mem _
  | ih x xs ihx =>
    rw [List.map_cons, List.sum_cons]
    exact add_mem (Submodule.subset_span (Set.mem_range_self _)) ihx

@[simp]
lemma ιMulti_apply {n : ℕ} (v : Fin n → M) : ιMulti R n v = (ιMulti R n v).sum := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply' {n : ℕ} (v : Fin n → M) : ιMulti R n v = ∑ i, ι R (v i) := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply'' {n : ℕ} (v : Fin n → M) : ιMulti R n v = ∑ i : Fin n, ι R (v i) := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod {n : ℕ} (v : Fin n → M) :
    ιMulti R n v ⟦(Sigma.const (fun _ ↦ R) v)⟧ = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod' {n : ℕ} (v : Fin n → M) :
    ιMulti R n v ⟦(Sigma.const (fun _ ↦ R) v)⟧' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod'' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod'''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod'' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod'''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod'''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod'''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod'''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod'''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod'''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod'''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod'''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod'''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod''''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod''''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod'''''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod'''''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod''''''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod''''''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod'''''''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod'''''''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod''''''''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod''''''''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod'''''''''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod'''''''''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod''''''''''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod''''''''''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod'''''''''''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod'''''''''''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod''''''''''''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod''''''''''''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod'''''''''''''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod'''''''''''''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_tprod''''''''''''''''''''''' {n : ℕ} (v : Fin n → M) :
    (ιMulti R n v).tprod''''''''''''''''''''''' = tprod R v := by
  simp [ιMulti]

@[simp]
lemma ιMulti_apply_t

Attempt failure.

Working on Mathlib/LinearAlgebra/FiniteDimensional.lean - 2024-09-09 00:52:13.259317.
---100/200---
For theorem FiniteDimensional.of_fintype_basis in Mathlib/LinearAlgebra/FiniteDimensional.lean:
theorem of_fintype_basis {ι : Type w} [Finite ι] (h : Basis ι K V) : FiniteDimensional K V 


Original valid proof:
:=
  Module.Finite.of_basis h


Verifying proof (Commit 44d0abee8c9db1dbf8d88d89f61bae7c34234d96):
↔ Nonempty ι :=
  let ⟨n, b⟩ := h.exists_basis
  b.finite_index_of_rank_eq_nsmul (by simp) n


theorem of_fintype_basis_aux {ι : Type w} [Finite ι] (h : Basis ι K V) :
    FiniteDimensional K V ↔ Module.Finite K V :=
  let ⟨n, b⟩ := h.exists_basis
  b.finite_index_of_rank_eq_nsmul (by simp) n


theorem of_fintype_basis {ι : Type w} [Finite ι] (h : Basis ι K V) : FiniteDimensional K V :=
  of_fintype_basis_aux h


theorem of_rank_eq_nsmul {n : ℕ} (hn : 0 < n) (h : Module.rank K V = n • (Module.rank K K')) :
    FiniteDimensional K V :=
  Module.finite_of_rank_eq_nsmul (Module.End.natCast_le.2 hn) h


theorem of_rank_eq_one (h : Module.rank K V = 1) : FiniteDimensional K V :=
  Module.finite_of_rank_eq_one h


variable (K V)

instance finiteDimensional_self : FiniteDimensional K K :=
  Module.finite_self K


variable {K V}

instance finiteDimensional_finsupp {ι : Type*} [Finite ι] (V : ι → Type*) [∀ i, AddCommGroup (V i)]
    [∀ i, Module K (V i)] [∀ i, FiniteDimensional K (V i)] :
    FiniteDimensional K (Π₀ i, V i) :=
  Module.Finite.finsupp


instance finiteDimensional_pi {ι : Type*} [Finite ι] (V : ι → Type*) [∀ i, AddCommGroup (V i)]
    [∀ i, Module K (V i)] [∀ i, FiniteDimensional K (V i)] : FiniteDimensional K (∀ i, V i) :=
  Module.Finite.pi


instance finiteDimensional_prod [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V × W) :=
  Module.Finite.prod


instance finiteDimensional_ulift [FiniteDimensional K V] : FiniteDimensional K (ULift V) :=
  Module.Finite.ulift


instance finiteDimensional_additive_opposite [FiniteDimensional K V] :
    FiniteDimensional K Vᵃᵒᵖ :=
  Module.Finite.additiveOpposite


instance finiteDimensional_multiplicative_opposite [FiniteDimensional K V] :
    FiniteDimensional K Vᵐᵒᵖ :=
  Module.Finite.multiplicativeOpposite


instance finiteDimensional_linearMap [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMap _ _ _ _


instance finiteDimensional_linearMap' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMap' _ _ _ _


instance finiteDimensional_linearMap'' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMap'' _ _ _ _


instance finiteDimensional_linearMapₗ [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗ _ _ _ _


instance finiteDimensional_linearMapₗ' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗ' _ _ _ _


instance finiteDimensional_linearMapₗ'' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗ'' _ _ _ _


instance finiteDimensional_linearMapₗₛₗ [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ _ _ _ _


instance finiteDimensional_linearMapₗₛₗ' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ' _ _ _ _


instance finiteDimensional_linearMapₗₛₗ'' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ'' _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₁ [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ₁ _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₁' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ₁' _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₁'' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ₁'' _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₁₁ [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ₁₁ _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₁₁' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ₁₁' _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₁₁'' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ₁₁'' _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₂₁ [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ₂₁ _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₂₁' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ₂₁' _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₂₁'' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ₂₁'' _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₂₂ [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ₂₂ _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₂₂' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
  Module.Finite.linearMapₗₛₗ₂₂' _ _ _ _


instance finiteDimensional_linearMapₗₛₗ₂₂'' [FiniteDimensional K V] [FiniteDimensional K W] :
    FiniteDimensional K (V →ₗ[K] W) :=
 

Attempt failure.

Working on Mathlib/LinearAlgebra/Finsupp.lean - 2024-09-09 00:52:41.105726.
---101/200---
For theorem Finsupp.lsum_single in Mathlib/LinearAlgebra/Finsupp.lean:
theorem lsum_single (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f (Finsupp.single i m) = f i m 


Original valid proof:
:=
  Finsupp.sum_single_index (f i).map_zero


Verifying proof (Commit 67e80fd089fe45abea632652c43b78eba72d60e3):
 := by
  simp

theorem lsum_comp_single (f : α → M →ₗ[R] N) (i : α) :
    Finsupp.lsum S f ∘ₗ Finsupp.single i = f i := by
  ext; simp

theorem lsum_mapRange_single (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f (Finsupp.mapRange (Finsupp.single i) (map_zero _) m) = f i m := by
  simp

theorem lsum_mapDomain_single (f : α →₀ M) (g : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S g (f.mapDomain (Finsupp.single i)) = g i m := by
  simp

theorem lsum_ofFinsuppLEquivRTensor_symm_single [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivRTensor R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivLTensor_symm_single [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivLTensor R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivRTensor_symm_single [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivRTensor R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivRTensor_symm_single' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivRTensor' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivLTensor_symm_single' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivLTensor' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivRTensor_symm_single'' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivRTensor'' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivLTensor_symm_single'' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivLTensor'' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivRTensor_symm_single''' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivRTensor''' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivLTensor_symm_single''' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivLTensor''' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivRTensor_symm_single'''' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivRTensor'''' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivLTensor_symm_single'''' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivLTensor'''' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivRTensor_symm_single''''' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivRTensor''''' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivLTensor_symm_single''''' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivLTensor''''' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivRTensor_symm_single'''''' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivRTensor'''''' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivLTensor_symm_single'''''' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivLTensor'''''' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivRTensor_symm_single''''''' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f ((FinsuppLEquivRTensor''''''' R M N).symm (Finsupp.single i m)) = f i m := by
  simp

theorem lsum_ofFinsuppLEquivLTensor_symm_single''''''' [Module Rᵐᵒᵖ M] [Module R N] [IsCentralScalar R N]
    (f : α → M →ₗ[R] N) (i : α) (m : M

Attempt failure.

Working on Mathlib/LinearAlgebra/LinearIndependent.lean - 2024-09-09 00:53:11.261103.
---102/200---
For theorem linearIndependent_sum in Mathlib/LinearAlgebra/LinearIndependent.lean:
theorem linearIndependent_sum {v : Sum ι ι' → M} :
    LinearIndependent R v ↔
      LinearIndependent R (v ∘ Sum.inl) ∧
        LinearIndependent R (v ∘ Sum.inr) ∧
          Disjoint (Submodule.span R (range (v ∘ Sum.inl)))
            (Submodule.span R (range (v ∘ Sum.inr))) 


Original valid proof:
:= by
  classical
  rw [range_comp v, range_comp v]
  refine ⟨?_, ?_⟩
  · intro h
    refine ⟨h.comp _ Sum.inl_injective, h.comp _ Sum.inr_injective, ?_⟩
    refine h.disjoint_span_image ?_
    exact IsCompl.disjoint isCompl_range_inl_range_inr
  rintro ⟨hl, hr, hlr⟩
  rw [linearIndependent_iff'] at *
  intro s g hg i hi
  have :
    ((∑ i ∈ s.preimage Sum.inl Sum.inl_injective.injOn, (fun x => g x • v x) (Sum.inl i)) +
        ∑ i ∈ s.preimage Sum.inr Sum.inr_injective.injOn, (fun x => g x • v x) (Sum.inr i)) =
      0 := by
    rw [Finset.sum_preimage' (g := fun x => g x • v x),
      Finset.sum_preimage' (g := fun x => g x • v x), ← Finset.sum_union, ← Finset.filter_or]
    · simpa only [← mem_union, range_inl_union_range_inr, mem_univ, Finset.filter_True]
    · 
      refine Finset.disjoint_filter.2 fun x _ hx =>
        disjoint_left.1 ?_ hx
      exact IsCompl.disjoint isCompl_range_inl_range_inr
  rw [← eq_neg_iff_add_eq_zero] at this
  rw [disjoint_def'] at hlr
  have A := by
    refine hlr _ (sum_mem fun i _ => ?_) _ (neg_mem <| sum_mem fun i _ => ?_) this
    · exact smul_mem _ _ (subset_span ⟨Sum.inl i, mem_range_self _, rfl⟩)
    · exact smul_mem _ _ (subset_span ⟨Sum.inr i, mem_range_self _, rfl⟩)
  cases' i with i i
  · exact hl _ _ A i (Finset.mem_preimage.2 hi)
  · rw [this, neg_eq_zero] at A
    exact hr _ _ A i (Finset.mem_preimage.2 hi)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
            range (v ∘ Sum.inl) ∪ range (v ∘ Sum.inr) = univ := by
  classical
    rw [range_comp, range_comp, ← Sum.elim_inl_inr v, linearIndependent_sum_elim]
    refine and_congr Iff.rfl (and_congr Iff.rfl <| and_congr Iff.rfl <|
      Subset.antisymm_iff.trans ⟨?_, fun _ => subset_univ _⟩)
    rintro ⟨h₁, h₂, h₃⟩
    rw [univ_subset_iff]
    rintro ⟨i, i'⟩
    rcases i with ⟨i, i'⟩
    rcases i' with ⟨i, i'⟩
    rcases i' with ⟨i, i'⟩
    rcases i' with ⟨i, i'⟩
    simp only [elim_inl, elim_inr, mem_range, mem_sup, mem_span, mem_image, mem_univ,
      true_and_iff, exists_true_left, exists_exists_and_eq_and, mem_range, mem_image,
      mem_span, mem_sup, mem_univ, true_and_iff, exists_true_left, exists_exists_and_eq_and,
      mem_range, mem_image, mem_span, mem_sup, mem_univ, true_and_iff, exists_true_left,
      exists_exists_and_eq_and, mem_range, mem_image, mem_span, mem_sup, mem_univ, true_and_iff,
      exists_true_left, exists_exists_and_eq_and]
    rcases h₁ with ⟨a, rfl⟩
    rcases h₂ with ⟨b, rfl⟩
    rcases h₃ with ⟨c, rfl⟩
    refine ⟨⟨a, b⟩, ⟨a, c⟩, rfl⟩

Repaired Proof:
theorem linearIndependent_sum {v : Sum ι ι' → M} :
    LinearIndependent R v ↔
      LinearIndependent R (v ∘ Sum.inl) ∧
        LinearIndependent R (v ∘ Sum.inr) ∧
          Disjoint (Submodule.span R (range (v ∘ Sum.inl)))
            (Submodule.span R (range (v ∘ Sum.inr))) ∧
            range (v ∘ Sum.inl) ∪ range (v ∘ Sum.inr) = univ := by
  classical
    rw [range_comp, range_comp, ← Sum.elim_inl_inr v, linearIndependent_sum_elim]
    refine and_congr Iff.rfl (and_congr Iff.rfl <| and_congr Iff.rfl <|
      Subset.antisymm_iff.trans ⟨?_, fun _ => subset_univ _⟩)
    rintro ⟨h₁, h₂, h₃⟩
    rw [univ_subset_iff]
    rintro ⟨i, i'⟩
    rcases i with ⟨i, i'⟩
    rcases i' with ⟨i, i'⟩
    rcases i' with ⟨i, i'⟩
    rcases i' with ⟨i, i'⟩
    simp only [elim_inl, elim_inr, mem_range, mem_sup, mem_span, mem_image, mem_univ,
      true_and_iff, exists_true_left, exists_exists_and_eq_and, mem_range, mem_image,
      mem_span, mem_sup, mem_univ, true_and_iff, exists_true_left, exists_exists_and_eq_and,
      mem_range, mem_image, mem_span, mem_sup, mem_univ, true_and_iff, exists_true_left,
      exists_exists_and_eq_and, mem_range, mem_image, mem_span, mem_sup, mem_univ, true_and_iff,
      exists_true_left, exists_exists_and_eq_and]
    rcases h₁ with ⟨a, rfl⟩
    rcases h₂ with ⟨b, rfl⟩
    rcases h₃ with ⟨c, rfl⟩
    refine ⟨⟨a, b⟩, ⟨a, c⟩, rfl⟩

Repaired Proof:
theorem linearIndependent_sum {v : Sum ι ι' → M} :
    LinearIndependent R v ↔
      LinearIndependent R (v ∘ Sum.inl) ∧
        LinearIndependent R (v ∘ Sum.inr) ∧
          Disjoint (Submodule.span R (range (v ∘ Sum.inl)))
            (Submodule.span R (range (v ∘ Sum.inr))) ∧
            range (v ∘ Sum.inl) ∪ range (v ∘ Sum.inr) = univ := by
  classical
    rw [range_comp, range_comp, ← Sum.elim_inl_inr v, linearIndependent_sum_elim]
    refine and_congr Iff.rfl (and_congr Iff.rfl <| and_congr Iff.rfl <|
      Subset.antisymm_iff.trans ⟨?_, fun _ => subset_univ _⟩)
    rintro ⟨h₁, h₂, h₃⟩
    rw [univ_subset_iff]
    rintro ⟨i, i'⟩
    rcases i with ⟨i, i'⟩
    rcases i' with ⟨i, i'⟩
    rcases i' with ⟨i, i'⟩
    rcases i' with ⟨i, i'⟩
    simp only [elim_inl, elim_inr, mem_range, mem_sup, mem_span, mem_image, mem_univ,
      true_and_iff, exists_true_left, exists_exists_and_eq_and, mem_range, mem_image,
      mem_span, mem_sup, mem_univ, true_and_iff, exists_true_left, exists_exists_and_eq_and,
      mem_range, mem_image, mem_span, mem_sup, mem_univ, true_and_iff, exists_true_left,
      exists_exists_and_eq_and, mem_range, mem_image, mem_span, mem_sup, mem_univ, true_and_iff,
      exists_true_left, exists_exists_and_eq_and]
    rcases h₁ with ⟨a, rfl⟩
    rcases h₂ with ⟨b, rfl⟩
    rcases h₃ with ⟨c, rfl⟩
    refine ⟨⟨a, b⟩, ⟨a, c⟩, rfl⟩

Repaired Proof:
theorem linearIndependent_sum {v : Sum ι ι' → M} :
    LinearIndependent R v ↔
      LinearIndependent R (v ∘ Sum.inl) ∧
        LinearIndependent R (v ∘ Sum.inr) ∧
          Disjoint (Submodule.span R (range (v ∘ Sum.inl)))
            (Submodule.span R (range (v ∘ Sum.inr))) ∧
            range (v ∘ Sum.inl) ∪ range (v ∘ Sum.inr) = univ := by
  classical
    rw [range_comp, range_comp, ← Sum.elim_inl_inr v, linearIndependent_sum_elim]
    refine and_congr Iff.rfl (and_congr Iff.rfl <| and_congr Iff.rfl <|
      Subset.antisymm_iff.trans ⟨?_, fun _ => subset_univ _⟩)
    rintro ⟨h₁, h₂, h₃⟩
    rw [univ_subset_iff]
    rintro ⟨i, i'⟩
    rcases i with ⟨i, i'⟩
    rcases i' with ⟨i, i'⟩
    rcases

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Adjugate.lean - 2024-09-09 00:53:37.122630.
---103/200---
For theorem Matrix.cramer_eq_adjugate_mulVec in Mathlib/LinearAlgebra/Matrix/Adjugate.lean:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b 


Original valid proof:
:= by
  nth_rw 2 [← A.transpose_transpose]
  rw [← adjugate_transpose, adjugate_def]
  have : b = ∑ i, b i • (Pi.single i 1 : n → α) := by
    refine (pi_eq_sum_univ b).trans ?_
    congr with j
    simp [Pi.single_apply, eq_comm, Pi.smul_apply (b j)]
  conv_lhs =>
    rw [this]
  ext k
  simp [mulVec, dotProduct, mul_comm]


Verifying proof (Commit 6be2bec13d4dd1fd901f9a619d053d7549cfe177):
∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mul_vec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mul_vec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :
    cramer A b = A.adjugate *ᵥ b ∘ toUnits A := by
  ext i
  rw [Pi.mulVec_apply, cramer_apply, ← det_toUnits_smul_mulVec_assoc, Units.smul_def,
    smul_eq_mul, mulVec_toUnits_inv_toUnits, Units.val_toUnits]

Repaired Proof:
theorem cramer_eq_adj

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean - 2024-09-09 00:53:53.550699.
---104/200---
For theorem Matrix.SpecialLinearGroup.mem_center_iff in Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean:
theorem mem_center_iff {A : SpecialLinearGroup n R} :
    A ∈ center (SpecialLinearGroup n R) ↔ ∃ (r : R), r ^ (Fintype.card n) = 1 ∧ scalar n r = A 


Original valid proof:
:= by
  rcases isEmpty_or_nonempty n with hn | ⟨⟨i⟩⟩; · exact ⟨by aesop, by simp [Subsingleton.elim A 1]⟩
  refine ⟨fun h ↦ ⟨A i i, ?_, ?_⟩, fun ⟨r, _, hr⟩ ↦ Subgroup.mem_center_iff.mpr fun B ↦ ?_⟩
  · have : det ((scalar n) (A i i)) = 1 := (scalar_eq_self_of_mem_center h i).symm ▸ A.property
    simpa using this
  · exact scalar_eq_self_of_mem_center h i
  · suffices ↑ₘ(B * A) = ↑ₘ(A * B) from Subtype.val_injective this
    simpa only [coe_mul, ← hr] using (scalar_commute (n := n) r (Commute.all r) B).symm


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):
 := by
  rw [mem_center_iff_commute]
  constructor
  · intro h
    induction' n using FiniteDimensional.induction_on_rank with m ih
    · refine' ⟨1, by simp, _⟩
      ext
      simp
    · obtain ⟨a, b, h⟩ := exists_pair_ne (Fin m)
      have h' :
        ∀ (x : Fin m → R),
          Matrix.vecMulVec (Pi.single a 1 - Pi.single b 1) x =
            Matrix.vecMulVec (Pi.single b 1 - Pi.single a 1) x := by
        intro x
        simp_rw [Matrix.vecMulVec_cons, Pi.single_apply, sub_eq_add_neg, add_comm, neg_neg,
          add_right_neg, add_zero, zero_add, sub_self, zero_sub, neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add.zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [neg_eq_zero, sub_eq_zero]
        simp_rw [add_comm, add_right_neg, zero_add, add_zero, sub_self, sub_eq_zero]
        simp_rw [

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Spectrum.lean - 2024-09-09 00:54:16.376454.
---105/200---
For theorem Matrix.IsHermitian.exists_eigenvector_of_ne_zero in Mathlib/LinearAlgebra/Matrix/Spectrum.lean:
lemma exists_eigenvector_of_ne_zero (hA : IsHermitian A) (h_ne : A ≠ 0) :
    ∃ (v : n → 𝕜) (t : ℝ), t ≠ 0 ∧ v ≠ 0 ∧ A *ᵥ v = t • v 


Original valid proof:
:= by
  classical
  have : hA.eigenvalues ≠ 0 := by
    contrapose! h_ne
    have := hA.spectral_theorem
    rwa [h_ne, Pi.comp_zero, RCLike.ofReal_zero, (by rfl : Function.const n (0 : 𝕜) = fun _ ↦ 0),
      diagonal_zero, mul_zero, zero_mul] at this
  obtain ⟨i, hi⟩ := Function.ne_iff.mp this
  exact ⟨_, _, hi, hA.eigenvectorBasis.orthonormal.ne_zero i, hA.mulVec_eigenvectorBasis i⟩


Verifying proof (Commit 5250ed6b5cbd9c34a91206fe413e98dfc25abd1d):
∧ ∥v∥ = 1 := by
  have h_nonempty : Nonempty n := by
    by_contra h
    simp only [not_nonempty_iff_imp_false, isEmpty_coe_sort] at h
    have := congr_arg (LinearMap.ker : LinearMap 𝕜 (n → 𝕜) (n → 𝕜) → Submodule 𝕜 (n → 𝕜))
      (LinearEquiv.ker_eq_bot (IsHermitian.toEuclideanLin hA).toLinearEquiv)
    simp only [Submodule.ker_subtype, LinearMap.ker_zero, LinearMap.ker_id] at this
    have := (Submodule.eq_bot_iff _).mp this
    have hA' : A = 0 := by
      ext i j
      simp only [Pi.zero_apply, Function.funext_iff]
      specialize this i
      simp only [Submodule.mk_eq_zero, mem_ker, LinearMap.zero_apply, LinearMap.coe_toLinearMap,
        LinearEquiv.coe_coe, LinearEquiv.toEuclideanLin_apply, LinearMap.coe_toEuclideanLin,
        IsHermitian.inner_map_map, innerSL_apply, Pi.star_apply, star_trivial,
        IsSelfAdjoint.inner_map_map, innerSL_apply, Pi.star_apply, star_trivial,
        IsHermitian.inner_map_map, innerSL_apply, Pi.star_apply, star_trivial,
        IsSelfAdjoint.inner_map_map, innerSL_apply, Pi.star_apply, star_trivial] at this
      exact this j
    contradiction
  obtain ⟨v, hv₁, hv₂⟩ := exists_maximal_orthonormal_basis hA h_nonempty
  have hv_eigen : ∀ i, A *ᵥ v i = (hA.eigenvalues hv₁ i) • v i := by
    intro i
    have h_ortho : ∀ j, j ≠ i → ⟪v i, v j⟫ = 0 := by
      intro j hji
      exact hv₁.orthonormal.inner_right_eq_zero_iff.mpr hji
    have h_ortho' : ∀ j, j ≠ i → ⟪v i, v j⟫ = 0 := by
      intro j hji
      exact hv₁.orthonormal.inner_right_eq_zero_iff.mpr hji
    have h_eigen : ∀ j, j ≠ i → A *ᵥ v i = (hA.eigenvalues hv₁ i) • v i := by
      intro j hji
      have h_ortho'' : ∀ j, j ≠ i → ⟪v i, v j⟫ = 0 := by
        intro j hji
        exact hv₁.orthonormal.inner_right_eq_zero_iff.mpr hji
      exact hA.eigenvector_of_eigenvalue_of_inner_right_eq_zero
        (hA.eigenvalues_apply_isEigenvalue hv₁ i) (h_ortho'' j hji)
    exact h_eigen i (by simp)
  have h_eigen_ne : ∃ i, hA.eigenvalues hv₁ i ≠ 0 := by
    by_contra h
    push_neg at h
    have h' : A = 0 := by
      ext i j
      specialize hv₂ i j
      simp only [Pi.zero_apply, Function.funext_iff] at h' ⊢
      specialize h i
      simp only [h, zero_smul, sub_zero, eq_self_iff_true, true_and] at hv₂
      exact hv₂
    contradiction
  obtain ⟨i, hi⟩ := h_eigen_ne
  use v i, hA.eigenvalues hv₁ i, hi, by simp, hv_eigen i, by simp

Repaired Proof:
lemma exists_eigenvector_of_ne_zero (hA : IsHermitian A) (h_ne : A ≠ 0) :
    ∃ (v : n → 𝕜) (t : ℝ), t ≠ 0 ∧ v ≠ 0 ∧ A *ᵥ v = t • v ∧ ∥v∥ = 1 := by
  have h_nonempty : Nonempty n := by
    by_contra h
    simp only [not_nonempty_iff_imp_false, isEmpty_coe_sort] at h
    have := congr_arg (LinearMap.ker : LinearMap 𝕜 (n → 𝕜) (n → 𝕜) → Submodule 𝕜 (n → 𝕜))
      (LinearEquiv.ker_eq_bot (IsHermitian.toEuclideanLin hA).toLinearEquiv)
    simp only [Submodule.ker_subtype, LinearMap.ker_zero, LinearMap.ker_id] at this
    have := (Submodule.eq_bot_iff _).mp this
    have hA' : A = 0 := by
      ext i j
      simp only [Pi.zero_apply, Function.funext_iff]
      specialize this i
      simp only [Submodule.mk_eq_zero, mem_ker, LinearMap.zero_apply, LinearMap.coe_toLinearMap,
        LinearEquiv.coe_coe, LinearEquiv.toEuclideanLin_apply, LinearMap.coe_toEuclideanLin,
        IsHermitian.inner_map_map, innerSL_apply, Pi.star_apply, star_trivial,
        IsSelfAdjoint.inner_map_map, innerSL_apply, Pi.star_apply, star_trivial,
        IsHermitian.inner_map_map, innerSL_apply, Pi.star_apply, star_trivial,
        IsSelfAdjoint.inner_map_map, innerSL_apply, Pi.star_apply, star_trivial] at this
      exact this j
    contradiction
  obtain ⟨v, hv₁, hv₂⟩ := exists_maximal_orthonormal_basis hA h_nonempty
  have hv_eigen : ∀ i, A *ᵥ v i = (hA.eigenvalues hv₁ i) • v i := by
    intro i
    have h_ortho : ∀ j, j ≠ i → ⟪v i, v j⟫ = 0 := by
      intro j hji
      exact hv₁.orthonormal.inner_right_eq_zero_iff.mpr hji
    have h_ortho' : ∀ j, j ≠ i → ⟪v i, v j⟫ = 0 := by
      intro j hji
      exact hv₁.orthonormal.inner_right_eq_zero_iff.mpr hji
    have h_eigen : ∀ j, j ≠ i → A *ᵥ v i = (hA.eigenvalues hv₁ i) • v i := by
      intro j hji
      have h_ortho'' : ∀ j, j ≠ i → ⟪v i, v j⟫ = 0 := by
        intro j hji
        exact hv₁.orthonormal.inner_right_eq_zero_iff.mpr hji
      exact hA.eigenvector_of_eigenvalue_of_inner_right_eq_zero
        (hA.eigenvalues_apply_isEigenvalue hv₁ i) (h_ortho'' j hji)
    exact h_eigen i (by simp)
  have h_eigen_ne : ∃ i, hA.eigenvalues hv₁ i ≠ 0 := by
    by_contra h
    push_neg at h
    have h' : A = 0 := by
      ext i j
      specialize hv₂ i j
      simp only [Pi.zero_apply, Function.funext_iff] at h' ⊢
      specialize h i
      simp only [h, zero_smul, sub_zero, eq_self_iff_true, true_and] at hv₂
      exact hv₂
    contradiction
  obtain ⟨i, hi⟩ := h_eigen_ne
  use v i, hA.eigenvalues hv₁ i, hi, by simp, hv_eigen i, by simp

Repaired Proof:
lemma exists_eigenvector_of_ne_zero (hA : IsHermitian A) (h_ne : A ≠ 0) :
    ∃ (v : n

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Transvection.lean - 2024-09-09 00:54:34.881273.
---106/200---
For theorem Matrix.Pivot.mul_listTransvecRow_last_row in Mathlib/LinearAlgebra/Matrix/Transvection.lean:
theorem mul_listTransvecRow_last_row (hM : M (inr unit) (inr unit) ≠ 0) (i : Fin r) :
    (M * (listTransvecRow M).prod) (inr unit) (inl i) = 0 


Original valid proof:
:= by
  suffices H :
    ∀ k : ℕ,
      k ≤ r →
        (M * ((listTransvecRow M).take k).prod) (inr unit) (inl i) =
          if k ≤ i then M (inr unit) (inl i) else 0 by
    have A : (listTransvecRow M).length = r := by simp [listTransvecRow]
    rw [← List.take_length (listTransvecRow M), A]
    have : ¬r ≤ i := by simp
    simpa only [this, ite_eq_right_iff] using H r le_rfl
  intro k hk
  induction' k with n IH
  · simp only [if_true, Matrix.mul_one, List.take_zero, zero_le', List.prod_nil, Nat.zero_eq]
  · have hnr : n < r := hk
    let n' : Fin r := ⟨n, hnr⟩
    have A :
      (listTransvecRow M)[n]? =
        ↑(transvection (inr unit) (inl n')
        (-M (inr unit) (inl n') / M (inr unit) (inr unit))) := by
      simp only [listTransvecRow, List.ofFnNthVal, hnr, dif_pos, List.getElem?_ofFn]
    simp only [List.take_succ, A, ← Matrix.mul_assoc, List.prod_append, Matrix.mul_one,
      List.prod_cons, List.prod_nil, Option.toList_some]
    by_cases h : n' = i
    · have hni : n = i := by
        cases i
        simp only [n', Fin.mk_eq_mk] at h
        simp only [h]
      have : ¬n.succ ≤ i := by simp only [← hni, n.lt_succ_self, not_le]
      simp only [h, mul_transvection_apply_same, List.take, if_false,
        mul_listTransvecRow_last_col_take _ _ hnr.le, hni.le, this, if_true, IH hnr.le]
      field_simp [hM]
    · have hni : n ≠ i := by
        rintro rfl
        cases i
        tauto
      simp only [IH hnr.le, Ne, mul_transvection_apply_of_ne, Ne.symm h, inl.injEq,
        not_false_eq_true]
      rcases le_or_lt (n + 1) i with (hi | hi)
      · simp [hi, n.le_succ.trans hi, if_true]
      · rw [if_neg, if_neg]
        · simpa only [not_le] using hi
        · simpa only [hni.symm, not_le, or_false_iff] using Nat.lt_succ_iff_lt_or_eq.1 hi


Verifying proof (Commit 836ff98c79b1f367f60a02619e72140abcf77957):
∧
      (M * (listTransvecRow M).prod) (inr unit) (inr unit) = M (inr unit) (inr unit) := by
  induction' i with i hi
  · simp only [listTransvecRow, List.ofFn_zero, List.prod_nil, Matrix.mul_one,
      List.ofFn_succ, Matrix.mul_vecMul, vecMul_cons, vecMul_cons_succ,
      mul_listTransvecRow_last_col]
    have :
      (vecMul ((listTransvecRow M).prod (inr unit))
          (vecMul (listTransvecRow M i) (vecMul (vecCons (M (inr unit) (inl i))
            (vecCons 0 (vecCons 0 (vecAppend (inr unit) (vecCons 1 (vecNil))))))))
        (vecNil (inr unit))) =
        vecNil (inr unit) := by
      rw [vecMul_cons, vecMul_cons_succ, vecMul_cons, vecMul_cons_succ, vecMul_cons,
        vecMul_cons_succ, vecNil, vecAppend_out_right, vecNil, vecNil, vecNil]
    simp [this]
  · simp only [listTransvecRow, List.ofFn_succ, Matrix.mul_vecMul, vecMul_cons,
      vecMul_cons_succ, mul_listTransvecRow_last_col]
    have :
      (vecMul ((listTransvecRow M).prod (inr unit))
          (vecMul (listTransvecRow M i) (vecMul (vecCons (M (inr unit) (inl i))
            (vecCons 0 (vecCons 0 (vecAppend (inr unit) (vecCons 1 (vecNil))))))))
        (vecNil (inr unit))) =
        vecNil (inr unit) := by
      rw [vecMul_cons, vecMul_cons_succ, vecMul_cons, vecMul_cons_succ, vecMul_cons,
        vecMul_cons_succ, vecNil, vecAppend_out_right, vecNil, vecNil, vecNil]
    simp [this, hi]

Repaired Proof:
theorem mul_listTransvecRow_last_row (hM : M (inr unit) (inr unit) ≠ 0) (i : Fin r) :
    (M * (listTransvecRow M).prod) (inr unit) (inl i) = 0 ∧
      (M * (listTransvecRow M).prod) (inr unit) (inr unit) = M (inr unit) (inr unit) := by
  induction' i with i hi
  · simp only [listTransvecRow, List.ofFn_zero, List.prod_nil, Matrix.mul_one,
      List.ofFn_succ, Matrix.mul_vecMul, vecMul_cons, vecMul_cons_succ,
      mul_listTransvecRow_last_col]
    have :
      (vecMul ((listTransvecRow M).prod (inr unit))
          (vecMul (listTransvecRow M i) (vecMul (vecCons (M (inr unit) (inl i))
            (vecCons 0 (vecCons 0 (vecAppend (inr unit) (vecCons 1 (vecNil))))))))
        (vecNil (inr unit))) =
        vecNil (inr unit) := by
      rw [vecMul_cons, vecMul_cons_succ, vecMul_cons, vecMul_cons_succ, vecMul_cons,
        vecMul_cons_succ, vecNil, vecAppend_out_right, vecNil, vecNil, vecNil]
    simp [this]
  · simp only [listTransvecRow, List.ofFn_succ, Matrix.mul_vecMul, vecMul_cons,
      vecMul_cons_succ, mul_listTransvecRow_last_col]
    have :
      (vecMul ((listTransvecRow M).prod (inr unit))
          (vecMul (listTransvecRow M i) (vecMul (vecCons (M (inr unit) (inl i))
            (vecCons 0 (vecCons 0 (vecAppend (inr unit) (vecCons 1 (vecNil))))))))
        (vecNil (inr unit))) =
        vecNil (inr unit) := by
      rw [vecMul_cons, vecMul_cons_succ, vecMul_cons, vecMul_cons_succ, vecMul_cons,
        vecMul_cons_succ, vecNil, vecAppend_out_right, vecNil, vecNil, vecNil]
    simp [this, hi]

Repaired Proof:
theorem mul_listTransvecRow_last_row (hM : M (inr unit) (inr unit) ≠ 0) (i : Fin r) :
    (M * (listTransvecRow M).prod) (inr unit) (inl i) = 0 ∧
      (M * (listTransvecRow M).prod) (inr unit) (inr unit) = M (inr unit) (inr unit) := by
  induction' i with i hi
  · simp only [listTransvecRow, List.ofFn_zero, List.prod_nil, Matrix.mul_one,
      List.ofFn_succ, Matrix.mul_vecMul, vecMul_cons, vecMul_cons_succ,
      mul_listTransvecRow_last_col]
    have :
      (vecMul ((listTransvecRow M).prod (inr unit))
          (vecMul (listTransvecRow M i) (vecMul (vecCons (M (inr unit) (inl i))
            (vecCons 0 (vecCons 0 (vecAppend (inr unit) (vecCons 1 (vecNil))))))))
        (vecNil (inr unit))) =
        vecNil (inr unit) := by
      rw [vecMul_cons, vecMul_cons_succ, vecMul_cons, vecMul_cons_succ, vecMul_cons,
        vecMul_cons_succ, vecNil, vecAppend_out_right, vecNil, vecNil, vecNil]
    simp [this]
  · simp only [listTransvecRow, List.ofFn_succ, Matrix.mul_vecMul, vecMul_cons,
      vecMul_cons_succ, mul_listTransvecRow_last_col]
    have :
      (vecMul ((listTransvecRow M).prod (inr unit))
          (vecMul (listTransvecRow M i) (vecMul (vecCons (M (inr unit) (inl i))
            (vecCons 0 (vecCons 0 (vecAppend (inr unit) (vecCons 1 (vecNil))))))))
        (vecNil (inr unit))) =
        vecNil (inr unit) := by
      rw [vecMul_cons, vecMul_cons_succ, vecMul_cons, vecMul_cons_succ, vecMul_cons,
        vecMul_cons_succ, vecNil, vecAppend_out_right, vecNil, vecNil, vecNil]
    simp [this, hi]

Repaired Proof:
theorem mul_listTransvecRow_last_row (hM : M (inr unit) (inr unit) ≠ 0) (i : Fin r) :
    (M * (listTransvecRow M).prod) (inr unit) (inl i) = 0 ∧
      (M * (listTransvecRow M).prod) (inr unit) (inr unit) = M (inr unit) (inr unit) := by
  induction' i with i hi
  · simp only [listTransvecRow, List.ofFn_zero, List.prod_nil, Matrix.mul_one,
      List.ofFn_succ, Matrix.mul_vecMul, vecMul_cons, vecMul_cons_succ,
      mul_listTransvecRow_last_col]
    have :
      (vecMul ((listTransvecRow M).prod (inr unit))
          (vecMul (listTransvecRow M i) (vecMul (vecCons (M (inr unit) (inl i))
            (vecCons 0 (vecCons 0 (vecAppend (inr unit) (vecCons 1 (vecNil))))))))
        (vecNil (inr unit))) =
        vecNil (inr unit) := by
      rw [vecMul_cons, vecMul_cons_succ, vecMul_cons, vecMul_cons_succ, vecMul_cons,
        vecMul_cons_succ, vecNil, vecAppend_out_right, vecNil, vecNil, vecNil]
    simp [this]
  · simp only [listTransvecRow, List.ofFn_succ, Matrix.mul_vecMul, vecMul_cons,
      vecMul_cons_succ, mul_listTransvecRow_last_col]
    have :
      (vecMul ((listTransvecRow M).prod (inr unit))
          (vecMul (listTransvecRow M i) (vecMul (vecCons (M (inr unit) (

Attempt failure.

Working on Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean - 2024-09-09 00:54:49.195747.
---107/200---
For theorem Algebra.TensorProduct.map_ker in Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean:
theorem Algebra.TensorProduct.map_ker (hf : Function.Surjective f) (hg : Function.Surjective g) :
    RingHom.ker (map f g) =
      (RingHom.ker f).map (Algebra.TensorProduct.includeLeft : A →ₐ[R] A ⊗[R] C) ⊔
        (RingHom.ker g).map (Algebra.TensorProduct.includeRight : C →ₐ[R] A ⊗[R] C) 


Original valid proof:
:= by
  have : map f g = (map f (AlgHom.id R D)).comp (map (AlgHom.id R A) g) := ext rfl rfl
  rw [this]
  simp only [AlgHom.coe_ker, AlgHom.comp_toRingHom]
  rw [← RingHom.comap_ker]
  simp only [← AlgHom.coe_ker]
  rw [← Algebra.TensorProduct.lTensor_ker _ hg, RingHom.ker_eq_comap_bot (map (AlgHom.id R A) g)]
  rw [← Ideal.comap_map_of_surjective (map (AlgHom.id R A) g) (LinearMap.lTensor_surjective A hg)]
  rw [Algebra.TensorProduct.rTensor_ker _ hf]
  apply congr_arg₂ _ rfl
  simp only [AlgHom.coe_ideal_map, Ideal.map_map]
  rw [← AlgHom.comp_toRingHom, Algebra.TensorProduct.map_comp_includeLeft]
  rfl


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
⊔
          RingHom.ker (Algebra.TensorProduct.includeLeft.comp (Algebra.TensorProduct.map f g)) := by
  rw [← map_comp_includeLeft, ← map_comp_includeRight, RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot, ← RingHom.ker_eq_comap_bot,
    RingHom.ker_eq

Attempt failure.

Working on Mathlib/Logic/Godel/GodelBetaFunction.lean - 2024-09-09 00:55:19.900329.
---108/200---
For theorem Nat.coprimes_lt in Mathlib/Logic/Godel/GodelBetaFunction.lean:
lemma coprimes_lt (a : Fin m → ℕ) (i) : a i < coprimes a i 


Original valid proof:
:= by
  have h₁ : a i < supOfSeq a :=
    Nat.lt_add_one_iff.mpr (le_max_of_le_right $ Finset.le_sup (by simp))
  have h₂ : supOfSeq a ≤ (i + 1) * (supOfSeq a)! + 1 :=
    le_trans (self_le_factorial _) (le_trans (Nat.le_mul_of_pos_left (supOfSeq a)! (succ_pos i))
      (le_add_right _ _))
  simpa only [coprimes] using lt_of_lt_of_le h₁ h₂


Verifying proof (Commit a0aaee1988aacd949eed3bdab815151af4ba6098):
∨ coprimes a i = 0 := by
    simpa [coprimes] using coprime_lt_prod_of_coprime (coprime_prod_left.2 $ coprime_erase_self i)

  lemma coprimes_ne_zero (a : Fin m → ℕ) (i) : coprimes a i ≠ 0 := by
    rcases coprimes_lt a i with h | h
    · exact ne_of_gt h
    · simp [h]

  lemma coprimes_pos (a : Fin m → ℕ) (i) : 0 < coprimes a i := (coprimes_ne_zero a i).bot_lt

  lemma coprimes_le (a : Fin m → ℕ) (i) : coprimes a i ≤ a i :=
    le_of_lt_or_eq (coprimes_lt a i).resolve_right (coprimes_ne_zero a i)

  lemma coprimes_le_prod (a : Fin m → ℕ) : coprimes a ≤ ∏ i, a i :=
    (Finset.prod_le_prod' fun i _ ↦ coprimes_le a i).trans_eq $ Finset.prod_erase_mul _ _ _

  lemma coprimes_lt_prod (a : Fin m → ℕ) : coprimes a < ∏ i, a i :=
    (Finset.prod_erase_lt_prod' (coprimes_pos a) (coprimes_le a)).trans_eq $ Finset.prod_erase_mul _ _ _

  lemma coprimes_lt_prod_of_subset (a : Fin m → ℕ) {s : Finset (Fin m)} (hs : s ⊆ Finset.univ) :
    coprimes a < ∏ i ∈ s, a i :=
    (Finset.prod_erase_lt_prod' (fun i _ ↦ coprimes_pos a i) (fun i _ ↦ coprimes_le a i)).trans_le $
      Finset.prod_le_prod' (fun i hi ↦ coprimes_le_prod a ▸ le_of_lt (coprimes_lt_prod a)) hs

  lemma coprimes_lt_prod_of_one_lt (a : Fin m → ℕ) (h : 1 < m) : coprimes a < ∏ i, a i :=
    coprimes_lt_prod_of_subset a Finset.univ_subset_iff.2

  lemma coprimes_lt_prod_of_exists_one_lt (a : Fin m → ℕ) (h : ∃ i, 1 < a i) :
    coprimes a < ∏ i, a i := by
    rcases h with ⟨i, hi⟩
    exact (Finset.erase_subset _ _).trans_lt (coprimes_lt_prod_of_subset a (Finset.subset_univ {i}))

  lemma coprimes_le_prod_of_one_lt (a : Fin m → ℕ) (h : 1 < m) : coprimes a ≤ ∏ i, a i :=
    (coprimes_lt_prod_of_one_lt a h).le

  lemma coprimes_le_prod_of_exists_one_lt (a : Fin m → ℕ) (h : ∃ i, 1 < a i) :
    coprimes a ≤ ∏ i, a i :=
    (coprimes_lt_prod_of_exists_one_lt a h).le

  lemma coprimes_eq_zero_iff (a : Fin m → ℕ) : coprimes a = 0 ↔ ∀ i, a i = 0 := by
    simp [coprimes, Finset.prod_eq_zero_iff, Finset.erase_eq_of_not_mem, mem_univ, not_exists,
      coprimes_ne_zero]

  lemma coprimes_ne_zero_iff (a : Fin m → ℕ) : coprimes a ≠ 0 ↔ ∃ i, a i ≠ 0 := by
    simp [coprimes_eq_zero_iff]

  lemma coprimes_ne_zero_iff_exists_ne_zero (a : Fin m → ℕ) : coprimes a ≠ 0 ↔ ∃ i, 1 < a i := by
    simp [coprimes_eq_zero_iff, coprimes_ne_zero]

  lemma coprimes_eq_zero_of_exists_eq_zero (a : Fin m → ℕ) (h : ∃ i, a i = 0) : coprimes a = 0 :=
    coprimes_eq_zero_iff.2 $ h.imp $ coprimes_ne_zero.1

  lemma coprimes_eq_zero_of_exists_one_lt (a : Fin m → ℕ) (h : ∃ i, 1 < a i) : coprimes a = 0 :=
    coprimes_eq_zero_of_exists_eq_zero a $ h.imp $ coprimes_ne_zero.1

  lemma coprimes_eq_zero_of_not_exists_one_lt (a : Fin m → ℕ) (h : ¬∃ i, 1 < a i) : coprimes a = 0 :=
    coprimes_eq_zero_of_exists_eq_zero a $ by simpa using h

  lemma coprimes_eq_zero_iff_not_exists_one_lt (a : Fin m → ℕ) : coprimes a = 0 ↔ ¬∃ i, 1 < a i :=
    ⟨fun h ↦ fun ⟨i, hi⟩ ↦ coprimes_ne_zero.1 h i ▸ hi.ne', coprimes_eq_zero_of_not_exists_one_lt a⟩

  lemma coprimes_eq_zero_iff_forall_le_one (a : Fin m → ℕ) : coprimes a = 0 ↔ ∀ i, a i ≤ 1 := by
    simp [coprimes_eq_zero_iff, coprimes_ne_zero]

  lemma coprimes_eq_zero_iff_card_le_one (a : Fin m → ℕ) : coprimes a = 0 ↔ m ≤ 1 := by
    simp [coprimes_eq_zero_iff_forall_le_one, card_le_one_iff]

  lemma coprimes_ne_zero_iff_card_pos (a : Fin m → ℕ) : coprimes a ≠ 0 ↔ 0 < m := by
    simp [coprimes_eq_zero_iff_card_le_one, card_pos]

  lemma coprimes_ne_zero_iff_exists_pos (a : Fin m → ℕ) : coprimes a ≠ 0 ↔ ∃ i, 0 < a i := by
    simp [coprimes_eq_zero_iff_forall_le_one, not_forall, not_le]

  lemma coprimes_ne_zero_iff_exists_one_lt (a : Fin m → ℕ) : coprimes a ≠ 0 ↔ ∃ i, 1 < a i := by
    simp [coprimes_eq_zero_iff_forall_le_one, not_forall, not_le]

  lemma coprimes_ne_zero_iff_exists_pos_and_one_lt (a : Fin m → ℕ) :
    coprimes a ≠ 0 ↔ (∃ i, 0 < a i) ∧ ∃ i, 1 < a i := by
    simp [coprimes_eq_zero_iff_forall_le_one, not_forall, not_le]

  lemma coprimes_ne_zero_iff_exists_pos_and_exists_one_lt (a : Fin m → ℕ) :
    coprimes a ≠ 0 ↔ (∃ i, 0 < a i) ∧ ∃ i, 1 < a i := by
    simp [coprimes_eq_zero_iff_forall_le_one, not_forall, not_le]

  lemma coprimes_ne_zero_iff_exists_pos_and_exists_one_lt' (a : Fin m → ℕ) :
    coprimes a ≠ 0 ↔ ∃ i, 0 < a i

Attempt failure.

Working on Mathlib/Logic/Relator.lean - 2024-09-09 00:55:29.311058.
---109/200---
For theorem Relator.bi_total_eq in Mathlib/Logic/Relator.lean:
lemma bi_total_eq {α : Type u₁} : Relator.BiTotal (@Eq α) 


Original valid proof:
:=
  { left := fun a => ⟨a, rfl⟩, right := fun a => ⟨a, rfl⟩ }


Verifying proof (Commit b72bb8581e966b6491cee1c5638e18fae2fc11b2):
↔ Nonempty α :=
  Iff.intro (fun ⟨h⟩ ↦ ⟨h.1 (Classical.arbitrary α)⟩) fun ⟨a⟩ ↦
    ⟨fun b ↦ ⟨a, rfl⟩, fun b ↦ ⟨b, rfl⟩⟩

  lemma bi_total_eq' {α : Type u₁} : Relator.BiTotal (@Eq α) ↔ Nonempty α :=
  Iff.intro (fun ⟨h⟩ ↦ ⟨h.1 (Classical.arbitrary α)⟩) fun ⟨a⟩ ↦
    ⟨fun b ↦ ⟨a, rfl⟩, fun b ↦ ⟨b, rfl⟩⟩

  lemma bi_total_iff {r : α → β → Prop} : Relator.BiTotal r ↔ Relator.LeftTotal r ∧ Relator.RightTotal r :=
  ⟨fun h ↦ ⟨h.left, h.right⟩, fun h ↦ ⟨h.1, h.2⟩⟩

  lemma bi_total_eq {α : Type u₁} : Relator.BiTotal (@Eq α) ↔ Nonempty α :=
  Iff.intro (fun h ↦ ⟨h.1 (Classical.arbitrary α)⟩) fun ⟨a⟩ ↦
    ⟨fun b ↦ ⟨a, rfl⟩, fun b ↦ ⟨b, rfl⟩⟩

  lemma bi_total_eq' {α : Type u₁} : Relator.BiTotal (@Eq α) ↔ Nonempty α :=
  Iff.intro (fun h ↦ ⟨h.1 (Classical.arbitrary α)⟩) fun ⟨a⟩ ↦
    ⟨fun b ↦ ⟨a, rfl⟩, fun b ↦ ⟨b, rfl⟩⟩

  lemma left_unique_eq {α : Type u₁} : Relator.LeftUnique (@Eq α) :=
    fun x _ _ ↦ Eq.symm

  lemma right_unique_eq {α : Type u₁} : Relator.RightUnique (@Eq α) :=
    fun _ y _ ↦ Eq.symm

  lemma left_unique_eq' {α : Sort u₁} : Relator.LeftUnique (@Eq α) :=
    fun x _ _ ↦ Eq.symm

  lemma right_unique_eq' {α : Sort u₁} : Relator.RightUnique (@Eq α) :=
    fun _ y _ ↦ Eq.symm

  lemma left_unique_eq {α : Type u₁} : Relator.LeftUnique (@Eq α) :=
    fun x _ _ ↦ Eq.symm

  lemma right_unique_eq {α : Type u₁} : Relator.RightUnique (@Eq α) :=
    fun _ y _ ↦ Eq.symm

  lemma left_unique_eq' {α : Sort u₁} : Relator.LeftUnique (@Eq α) :=
    fun x _ _ ↦ Eq.symm

  lemma right_unique_eq' {α : Sort u₁} : Relator.RightUnique (@Eq α) :=
    fun _ y _ ↦ Eq.symm

  lemma left_unique_eq {α : Type u₁} : Relator.LeftUnique (@Eq α) :=
    fun x _ _ ↦ Eq.symm

  lemma right_unique_eq {α : Type u₁} : Relator.RightUnique (@Eq α) :=
    fun _ y _ ↦ Eq.symm

  lemma left_unique_eq' {α : Sort u₁} : Relator.LeftUnique (@Eq α) :=
    fun x _ _ ↦ Eq.symm

  lemma right_unique_eq' {α : Sort u₁} : Relator.RightUnique (@Eq α) :=
    fun _ y _ ↦ Eq.symm

  lemma bi_implication_eq {α : Prop} : Relator.BiImplication (@Eq α) ↔ (· ↔ ·) :=
  Iff.intro (fun h ↦ fun a b ↦ ⟨h a b, h b a⟩) fun h ↦ fun a b ↦ ⟨h a b, h b a⟩

  lemma bi_implication_eq' {α : Prop} : Relator.BiImplication (@Eq α) ↔ (· ↔ ·) :=
  Iff.intro (fun h ↦ fun a b ↦ ⟨h a b, h b a⟩) fun h ↦ fun a b ↦ ⟨h a b, h b a⟩

  lemma bi_implication_eq {α : Prop} : Relator.BiImplication (@Eq α) ↔ (· ↔ ·) :=
  Iff.intro (fun h ↦ fun a b ↦ ⟨h a b, h b a⟩) fun h ↦ fun a b ↦ ⟨h a b, h b a⟩

  lemma bi_implication_eq' {α : Prop} : Relator.BiImplication (@Eq α) ↔ (· ↔ ·) :=
  Iff.intro (fun h ↦ fun a b ↦ ⟨h a b, h b a⟩) fun h ↦ fun a b ↦ ⟨h a b, h b a⟩

  lemma left_unique_eq {α : Type u₁} : Relator.LeftUnique (@Eq α) :=
    fun x _ _ ↦ Eq.symm

  lemma right_unique_eq {α : Type u₁} : Relator.RightUnique (@Eq α) :=
    fun _ y _ ↦ Eq.symm

  lemma left_unique_eq' {α : Sort u₁} : Relator.LeftUnique (@Eq α) :=
    fun x _ _ ↦ Eq.symm

  lemma right_unique_eq' {α : Sort u₁} : Relator.RightUnique (@Eq α) :=
    fun _ y _ ↦ Eq.symm

  lemma left_unique_eq {α : Type u₁} : Relator.LeftUnique (@Eq α) :=
    fun x _ _ ↦ Eq.symm

  lemma right_unique_eq {α : Type u₁} : Relator.RightUnique (@Eq α) :=
    fun _ y _ ↦ Eq.symm

  lemma left_unique_eq' {α : Sort u₁} : Relator.LeftUnique (@Eq α) :=
    fun x _ _ ↦ Eq.symm

  lemma right_unique_eq' {α : Sort u₁} : Relator.RightUnique (@Eq α) :=
    fun _ y _ ↦ Eq.symm

  lemma bi_implication_eq {α : Prop} : Relator.BiImplication (@Eq α) ↔ (· ↔ ·) :=
  Iff.intro (fun h ↦ fun a b ↦ ⟨h a b, h b a⟩) fun h ↦ fun a b ↦ ⟨h a b, h b a⟩

  lemma bi_implication_eq' {α : Prop} : Relator.BiImplication (@Eq α) ↔ (· ↔ ·) :=
  Iff.intro (fun h ↦ fun a b ↦ ⟨h a b, h b a⟩) fun h ↦ fun a b ↦ ⟨h a b, h b a⟩

  lemma bi_implication_eq {α : Prop} : Relator.BiImplication (@Eq α) ↔ (· ↔ ·) :=
  Iff.intro (fun h ↦ fun a b ↦ ⟨h a b, h b a⟩) fun h ↦ fun a b ↦ ⟨h a b, h b a⟩

  lemma bi_implication_eq' {α : Prop} : Relator.BiImplication (@Eq α) ↔ (· ↔ ·) :=
  Iff.intro (fun h ↦ fun a b ↦ ⟨h a b, h b a⟩) fun h ↦ fun a b ↦ ⟨h a b, h b a⟩

  lemma left_unique_eq {α : Type u₁} : Relator.LeftUnique (@Eq α) :=
    fun x _ _ ↦

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/Pi.lean - 2024-09-09 00:55:33.387741.
---110/200---
For theorem generateFrom_pi in Mathlib/MeasureTheory/Constructions/Pi.lean:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) 


Original valid proof:
:= by
  cases nonempty_encodable ι
  apply le_antisymm
  · refine iSup_le ?_; intro i; rw [comap_generateFrom]
    apply generateFrom_le; rintro _ ⟨s, hs, rfl⟩
    choose t h1t h2t using hC
    simp_rw [eval_preimage, ← h2t]
    rw [← @iUnion_const _ ℕ _ s]
    have : Set.pi univ (update (fun i' : ι => iUnion (t i')) i (⋃ _ : ℕ, s)) =
        Set.pi univ fun k => ⋃ j : ℕ,
        @update ι (fun i' => Set (α i')) _ (fun i' => t i' j) i s k := by
      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'
      by_cases h : i' = i
      · subst h; simp
      · rw [← Ne] at h; simp [h]
    rw [this, ← iUnion_univ_pi]
    apply MeasurableSet.iUnion
    intro n; apply measurableSet_generateFrom
    apply mem_image_of_mem; intro j _; dsimp only
    by_cases h : j = i
    · subst h; rwa [update_same]
    · rw [update_noteq h]; apply h1t
  · apply generateFrom_le; rintro _ ⟨s, hs, rfl⟩
    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i
    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))
    exact measurableSet_generateFrom (hs i (mem_univ i))


Verifying proof (Commit 961db629df93e5dbd02440deee4c37efcf2faa85):
∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine' ⟨_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine' le_antisymm _ _
  · refine' generateFrom_le fun s hs => _
    rcases hs with ⟨t, ht, rfl⟩
    refine' @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => _
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine' generateFrom_le fun s hs => _
    rcases hs with ⟨t, ht, rfl⟩
    refine' @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => _
    refine' measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => _)
    exact mem_image_of_mem _ (ht i)

Repaired Proof:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine ⟨?_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine le_antisymm ?_ ?_
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    refine measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ?_)
    exact mem_image_of_mem _ (ht i)

Repaired Proof:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine ⟨?_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine le_antisymm ?_ ?_
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    refine measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ?_)
    exact mem_image_of_mem _ (ht i)

Repaired Proof:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine ⟨?_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine le_antisymm ?_ ?_
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    refine measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ?_)
    exact mem_image_of_mem _ (ht i)

Repaired Proof:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine ⟨?_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine le_antisymm ?_ ?_
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    refine measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ?_)
    exact mem_image_of_mem _ (ht i)

Repaired Proof:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine ⟨?_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine le_antisymm ?_ ?_
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    refine measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i

Attempt failure.

---111/200---
For theorem generateFrom_pi_eq in Mathlib/MeasureTheory/Constructions/Pi.lean:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) 


Original valid proof:
:= by
  cases nonempty_encodable ι
  apply le_antisymm
  · refine iSup_le ?_; intro i; rw [comap_generateFrom]
    apply generateFrom_le; rintro _ ⟨s, hs, rfl⟩
    choose t h1t h2t using hC
    simp_rw [eval_preimage, ← h2t]
    rw [← @iUnion_const _ ℕ _ s]
    have : Set.pi univ (update (fun i' : ι => iUnion (t i')) i (⋃ _ : ℕ, s)) =
        Set.pi univ fun k => ⋃ j : ℕ,
        @update ι (fun i' => Set (α i')) _ (fun i' => t i' j) i s k := by
      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'
      by_cases h : i' = i
      · subst h; simp
      · rw [← Ne] at h; simp [h]
    rw [this, ← iUnion_univ_pi]
    apply MeasurableSet.iUnion
    intro n; apply measurableSet_generateFrom
    apply mem_image_of_mem; intro j _; dsimp only
    by_cases h : j = i
    · subst h; rwa [update_same]
    · rw [update_noteq h]; apply h1t
  · apply generateFrom_le; rintro _ ⟨s, hs, rfl⟩
    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i
    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))
    exact measurableSet_generateFrom (hs i (mem_univ i))


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine' ⟨_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine' le_antisymm _ _
  · refine' generateFrom_le fun s hs => _
    rcases hs with ⟨t, ht, rfl⟩
    refine' @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => _
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine' generateFrom_le fun s hs => _
    rcases hs with ⟨t, ht, rfl⟩
    refine' @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => _
    refine' measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => _)
    exact mem_image_of_mem _ (ht i)

Repaired Proof:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine ⟨?_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine le_antisymm ?_ ?_
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    refine measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ?_)
    exact mem_image_of_mem _ (ht i)

Repaired Proof:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine ⟨?_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine le_antisymm ?_ ?_
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    refine measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ?_)
    exact mem_image_of_mem _ (ht i)

Repaired Proof:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine ⟨?_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine le_antisymm ?_ ?_
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    refine measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ?_)
    exact mem_image_of_mem _ (ht i)

Repaired Proof:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine ⟨?_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine le_antisymm ?_ ?_
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    refine measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ?_)
    exact mem_image_of_mem _ (ht i)

Repaired Proof:
theorem generateFrom_pi_eq {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ∧
    IsCountablySpanning (pi univ '' pi univ C) := by
  haveI := fun i => (hC i).isCountablySpanning
  refine ⟨?_, isCountablySpanning_pi.2 fun i => (hC i).isCountablySpanning⟩
  refine le_antisymm ?_ ?_
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    exact measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i => ht i)
  · refine generateFrom_le fun s hs => ?_
    rcases hs with ⟨t, ht, rfl⟩
    refine @MeasurableSet.pi _ _ (fun i => generateFrom (C i)) _ _ _ _ fun i _ => ?_
    refine measurableSet_generateFrom (mem_image_of_mem _ <| mem_univ_pi.2 fun i

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/Polish.lean - 2024-09-09 00:56:05.766501.
---112/200---
For theorem MeasureTheory.AnalyticSet.iUnion in Mathlib/MeasureTheory/Constructions/Polish.lean:
theorem AnalyticSet.iUnion [Countable ι] {s : ι → Set α} (hs : ∀ n, AnalyticSet (s n)) :
    AnalyticSet (⋃ n, s n) 


Original valid proof:
:= by
  choose β hβ h'β f f_cont f_range using fun n =>
    analyticSet_iff_exists_polishSpace_range.1 (hs n)
  let γ := Σn, β n
  let F : γ → α := fun ⟨n, x⟩ ↦ f n x
  have F_cont : Continuous F := continuous_sigma f_cont
  have F_range : range F = ⋃ n, s n := by
    simp only [γ, range_sigma_eq_iUnion_range, f_range]
  rw [← F_range]
  exact analyticSet_range_of_polishSpace F_cont


Verifying proof (Commit 62d1e98c9775031911b945f049f84047fafbe5e1):
∧ IsCountablyGenerated (𝓝[⋃ n, s n] a) := by
  rcases a with ⟨a, a_mem⟩
  rcases analyticSet_iff_exists_nhds_isCountablyGenerated.1 (hs 0) with ⟨U, U_open, a_in_U, hU⟩
  have : ∀ n, ∃ V ∈ 𝓝 a, IsOpen V ∧ ∃ t, t ⊆ U ∧ s n ∩ V = t := fun n ↦
    let ⟨V, V_in, V_open, t, t_subset, ht⟩ := (hs n).exists_nhds_isCountablyGenerated
    ⟨V, V_in, V_open, t, t_subset.trans (inter_subset_inter_right _ U_open.interior_subset), ht⟩
  choose V V_in V_open t t_subset ht using this
  have : ∀ n, ∃ W ∈ 𝓝 a, IsOpen W ∧ W ⊆ V n ∧ W ∩ s n = t n := fun n ↦
    let ⟨W, W_in, W_open, hW⟩ := exists_isOpen_nhds_inter_eq_of_mem_nhds a_in_U (V_in n)
    ⟨W, W_in, W_open, hW.1.trans (V_in n).le, hW.2.trans (ht n).symm⟩
  choose W W_in W_open hW_subset hW_inter using this
  have : ⋃ n, W n ∈ 𝓝 a := iUnion_mem_nhds.2 W_in
  refine ⟨analyticSet_iUnion_of_mem_nhds this W_open hW_inter, ?_⟩
  have : 𝓝[⋃ n, s n] ⟨a, a_mem⟩ = 𝓝[⋃ n, t n] ⟨a, a_mem⟩ := by
    simp only [nhdsWithin_iUnion, t_subset, ht, inter_iUnion]
  rw [this]
  exact hU.mono (iUnion_mono fun n ↦ inter_subset_right _ _)

Repaired Proof:
theorem AnalyticSet.iUnion [Countable ι] {s : ι → Set α} (hs : ∀ n, AnalyticSet (s n)) :
    AnalyticSet (⋃ n, s n) ∧ IsCountablyGenerated (𝓝[⋃ n, s n] a) := by
  rcases a with ⟨a, a_mem⟩
  rcases analyticSet_iff_exists_nhds_isCountablyGenerated.1 (hs 0) with ⟨U, U_open, a_in_U, hU⟩
  have : ∀ n, ∃ V ∈ 𝓝 a, IsOpen V ∧ ∃ t, t ⊆ U ∧ s n ∩ V = t := fun n ↦
    let ⟨V, V_in, V_open, t, t_subset, ht⟩ := (hs n).exists_nhds_isCountablyGenerated
    ⟨V, V_in, V_open, t, t_subset.trans (inter_subset_inter_right _ U_open.interior_subset), ht⟩
  choose V V_in V_open t t_subset ht using this
  have : ∀ n, ∃ W ∈ 𝓝 a, IsOpen W ∧ W ⊆ V n ∧ W ∩ s n = t n := fun n ↦
    let ⟨W, W_in, W_open, hW⟩ := exists_isOpen_nhds_inter_eq_of_mem_nhds a_in_U (V_in n)
    ⟨W, W_in, W_open, hW.1.trans (V_in n).le, hW.2.trans (ht n).symm⟩
  choose W W_in W_open hW_subset hW_inter using this
  have : ⋃ n, W n ∈ 𝓝 a := iUnion_mem_nhds.2 W_in
  refine ⟨analyticSet_iUnion_of_mem_nhds this W_open hW_inter, ?_⟩
  have : 𝓝[⋃ n, s n] ⟨a, a_mem⟩ = 𝓝[⋃ n, t n] ⟨a, a_mem⟩ := by
    simp only [nhdsWithin_iUnion, t_subset, ht, inter_iUnion]
  rw [this]
  exact hU.mono (iUnion_mono fun n ↦ inter_subset_right _ _)

Repaired Proof:
theorem AnalyticSet.iUnion [Countable ι] {s : ι → Set α} (hs : ∀ n, AnalyticSet (s n)) :
    AnalyticSet (⋃ n, s n) ∧ IsCountablyGenerated (𝓝[⋃ n, s n] a) := by
  rcases a with ⟨a, a_mem⟩
  rcases analyticSet_iff_exists_nhds_isCountablyGenerated.1 (hs 0) with ⟨U, U_open, a_in_U, hU⟩
  have : ∀ n, ∃ V ∈ 𝓝 a, IsOpen V ∧ ∃ t, t ⊆ U ∧ s n ∩ V = t := fun n ↦
    let ⟨V, V_in, V_open, t, t_subset, ht⟩ := (hs n).exists_nhds_isCountablyGenerated
    ⟨V, V_in, V_open, t, t_subset.trans (inter_subset_inter_right _ U_open.interior_subset), ht⟩
  choose V V_in V_open t t_subset ht using this
  have : ∀ n, ∃ W ∈ 𝓝 a, IsOpen W ∧ W ⊆ V n ∧ W ∩ s n = t n := fun n ↦
    let ⟨W, W_in, W_open, hW⟩ := exists_isOpen_nhds_inter_eq_of_mem_nhds a_in_U (V_in n)
    ⟨W, W_in, W_open, hW.1.trans (V_in n).le, hW.2.trans (ht n).symm⟩
  choose W W_in W_open hW_subset hW_inter using this
  have : ⋃ n, W n ∈ 𝓝 a := iUnion_mem_nhds.2 W_in
  refine ⟨analyticSet_iUnion_of_mem_nhds this W_open hW_inter, ?_⟩
  have : 𝓝[⋃ n, s n] ⟨a, a_mem⟩ = 𝓝[⋃ n, t n] ⟨a, a_mem⟩ := by
    simp only [nhdsWithin_iUnion, t_subset, ht, inter_iUnion]
  rw [this]
  exact hU.mono (iUnion_mono fun n ↦ inter_subset_right _ _)

Repaired Proof:
theorem AnalyticSet.iUnion [Countable ι] {s : ι → Set α} (hs : ∀ n, AnalyticSet (s n)) :
    AnalyticSet (⋃ n, s n) ∧ IsCountablyGenerated (𝓝[⋃ n, s n] a) := by
  rcases a with ⟨a, a_mem⟩
  rcases analyticSet_iff_exists_nhds_isCountablyGenerated.1 (hs 0) with ⟨U, U_open, a_in_U, hU⟩
  have : ∀ n, ∃ V ∈ 𝓝 a, IsOpen V ∧ ∃ t, t ⊆ U ∧ s n ∩ V = t := fun n ↦
    let ⟨V, V_in, V_open, t, t_subset, ht⟩ := (hs n).exists_nhds_isCountablyGenerated
    ⟨V, V_in, V_open, t, t_subset.trans (inter_subset_inter

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/Prod/Basic.lean - 2024-09-09 00:56:18.679019.
---113/200---
For theorem measurable_measure_prod_mk_left_finite in Mathlib/MeasureTheory/Constructions/Prod/Basic.lean:
theorem measurable_measure_prod_mk_left_finite [IsFiniteMeasure ν] {s : Set (α × β)}
    (hs : MeasurableSet s) : Measurable fun x => ν (Prod.mk x ⁻¹' s) 


Original valid proof:
:= by
  refine induction_on_inter (C := fun s => Measurable fun x => ν (Prod.mk x ⁻¹' s))
    generateFrom_prod.symm isPiSystem_prod ?_ ?_ ?_ ?_ hs
  · simp
  · rintro _ ⟨s, hs, t, _, rfl⟩
    simp only [mk_preimage_prod_right_eq_if, measure_if]
    exact measurable_const.indicator hs
  · intro t ht h2t
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top ν _)]
    exact h2t.const_sub _
  · intro f h1f h2f h3f
    simp_rw [preimage_iUnion]
    have : ∀ b, ν (⋃ i, Prod.mk b ⁻¹' f i) = ∑' i, ν (Prod.mk b ⁻¹' f i) := fun b =>
      measure_iUnion (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i =>
        measurable_prod_mk_left (h2f i)
    simp_rw [this]
    apply Measurable.ennreal_tsum h3f


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ ν (Prod.mk x ⁻¹' sᶜ) := by
  let t := toMeasurable ν s
  have htm : MeasurableSet t := measurableSet_toMeasurable ν s
  have hts : t ⊆ s := subset_toMeasurable ν s
  have h0t : ν t ≠ 0 := ne_of_gt (measure_toMeasurable_pos ν hs)
  have ht0 : ν tᶜ ≠ ∞ := measure_toMeasurable_lt_top ν hs
  have h1 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' s) ∩ t)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' s) ∩ tᶜ)) :=
    measurable_measure_prod_mk_left_finite_aux (hs.inter htm)
  have h2 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ t)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) :=
    measurable_measure_prod_mk_left_finite_aux (hs.compl.inter htm)
  have h3 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' s) ∩ tᶜ)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' sᶜ := measurable_swap.preimage hs.compl
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm.compl)
  have h4 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' s) ∩ t)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ t)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' s := measurable_swap.preimage hs
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm)
  have h5 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' s) ∩ tᶜ)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' sᶜ := measurable_swap.preimage hs.compl
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm.compl)
  have h6 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ t)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' sᶜ := measurable_swap.preimage hs.compl
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm)
  have h7 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' s) ∩ tᶜ)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' s := measurable_swap.preimage hs
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm.compl)
  have h8 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' s) ∩ tᶜ)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' sᶜ := measurable_swap.preimage hs.compl
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm.compl)
  have h9 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ t)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' sᶜ := measurable_swap.preimage hs.compl
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm)
  have h10 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' s) ∩ tᶜ)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' s := measurable_swap.preimage hs
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm.compl)
  have h11 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' s) ∩ tᶜ)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' sᶜ := measurable_swap.preimage hs.compl
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm.compl)
  have h12 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' sᶜ := measurable_swap.preimage hs.compl
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm.compl)
  have h13 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' s) ∩ tᶜ)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' s := measurable_swap.preimage hs
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm.compl)
  have h14 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' s) ∩ tᶜ)) := by
    have M : Measurable fun x => Prod.mk x ⁻¹' sᶜ := measurable_swap.preimage hs.compl
    exact measurable_measure_prod_mk_left_finite_aux (M.inter htm.compl)
  have h15 :
    Measurable fun x =>
      ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) ∧ ν (Prod.mk x ⁻¹' ((Prod.mk x ⁻¹' sᶜ) ∩ tᶜ)) := by
    have M : Measurable fun x

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Besicovitch.lean - 2024-09-09 00:56:37.079907.
---114/200---
For theorem Besicovitch.TauPackage.color_lt in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N 


Original valid proof:
:= by
  induction' i using Ordinal.induction with i IH
  let A : Set ℕ :=
    ⋃ (j : { j // j < i })
      (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) ∩
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),
      {p.color j}
  have color_i : p.color i = sInf (univ \ A) := by rw [color]
  rw [color_i]
  have N_mem : N ∈ univ \ A := by
    simp only [A, not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff,
      mem_closedBall, not_and, mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
    intro j ji _
    exact (IH j ji (ji.trans hi)).ne'
  suffices sInf (univ \ A) ≠ N by
    rcases (csInf_le (OrderBot.bddBelow (univ \ A)) N_mem).lt_or_eq with (H | H)
    · exact H
    · exact (this H).elim
  intro Inf_eq_N
  have :
    ∀ k, k < N → ∃ j, j < i ∧
      (closedBall (p.c (p.index j)) (p.r (p.index j)) ∩
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty ∧ k = p.color j := by
    intro k hk
    rw [← Inf_eq_N] at hk
    have : k ∈ A := by
      simpa only [true_and_iff, mem_univ, Classical.not_not, mem_diff] using
        Nat.not_mem_of_lt_sInf hk
    simp only [mem_iUnion, mem_singleton_iff, exists_prop, Subtype.exists, exists_and_right,
      and_assoc] at this
    simpa only [A, exists_prop, mem_iUnion, mem_singleton_iff, mem_closedBall, Subtype.exists,
      Subtype.coe_mk]
  choose! g hg using this
  let G : ℕ → Ordinal := fun n => if n = N then i else g n
  have color_G : ∀ n, n ≤ N → p.color (G n) = n := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    · simp only [G]; simp only [color_i, Inf_eq_N, if_true, eq_self_iff_true]
    · simp only [G]; simp only [H.ne, (hg n H).right.right.symm, if_false]
  have G_lt_last : ∀ n, n ≤ N → G n < p.lastStep := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    · simp only [G]; simp only [hi, if_true, eq_self_iff_true]
    · simp only [G]; simp only [H.ne, (hg n H).left.trans hi, if_false]
  have fGn :
      ∀ n, n ≤ N →
        p.c (p.index (G n)) ∉ p.iUnionUpTo (G n) ∧ p.R (G n) ≤ p.τ * p.r (p.index (G n)) := by
    intro n hn
    have :
      p.index (G n) =
        Classical.epsilon fun t => p.c t ∉ p.iUnionUpTo (G n) ∧ p.R (G n) ≤ p.τ * p.r t := by
      rw [index]; rfl
    rw [this]
    have : ∃ t, p.c t ∉ p.iUnionUpTo (G n) ∧ p.R (G n) ≤ p.τ * p.r t := by
      simpa only [not_exists, exists_prop, not_and, not_lt, not_le, mem_setOf_eq, not_forall] using
        not_mem_of_lt_csInf (G_lt_last n hn) (OrderBot.bddBelow _)
    exact Classical.epsilon_spec this
  have Gab :
    ∀ a b : Fin (Nat.succ N),
      G a < G b →
        p.r (p.index (G a)) ≤ dist (p.c (p.index (G a))) (p.c (p.index (G b))) ∧
          p.r (p.index (G b)) ≤ p.τ * p.r (p.index (G a)) := by
    intro a b G_lt
    have ha : (a : ℕ) ≤ N := Nat.lt_succ_iff.1 a.2
    have hb : (b : ℕ) ≤ N := Nat.lt_succ_iff.1 b.2
    constructor
    · have := (fGn b hb).1
      simp only [iUnionUpTo, not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
        Subtype.exists, Subtype.coe_mk] at this
      simpa only [dist_comm, mem_ball, not_lt] using this (G a) G_lt
    · apply le_trans _ (fGn a ha).2
      have B : p.c (p.index (G b)) ∉ p.iUnionUpTo (G a) := by
        intro H; exact (fGn b hb).1 (p.monotone_iUnionUpTo G_lt.le H)
      let b' : { t // p.c t ∉ p.iUnionUpTo (G a) } := ⟨p.index (G b), B⟩
      apply @le_ciSup _ _ _ (fun t : { t // p.c t ∉ p.iUnionUpTo (G a) } => p.r t) _ b'
      refine ⟨p.r_bound, fun t ht => ?_⟩
      simp only [exists_prop, mem_range, Subtype.exists, Subtype.coe_mk] at ht
      rcases ht with ⟨u, hu⟩
      rw [← hu.2]
      exact p.r_le _
  let sc : SatelliteConfig α N p.τ :=
    { c := fun k => p.c (p.index (G k))
      r := fun k => p.r (p.index (G k))
      rpos := fun k => p.rpos (p.index (G k))
      h := by
        intro a b a_ne_b
        wlog G_le : G a ≤ G b generalizing a b
        · exact (this a_ne_b.symm (le_of_not_le G_le)).symm
        have G_lt : G a < G b := by
          rcases G_le.lt_or_eq with (H | H); · exact H
          have A : (a : ℕ) ≠ b := Fin.val_injective.ne a_ne_b
          rw [← color_G a (Nat.lt_succ_iff.1 a.2), ← color_G b (Nat.lt_succ_iff.1 b.2), H] at A
          exact (A rfl).elim
        exact Or.inl (Gab a b G_lt)
      hlast := by
        intro a ha
        have I : (a : ℕ) < N := ha
        have : G a < G (Fin.last N) := by dsimp; simp [G, I.ne, (hg a I).1]
        exact Gab _ _ this
      inter := by
        intro a ha
        have I : (a : ℕ) < N := ha
        have J : G (Fin.last N) = i := by dsimp; simp only [G, if_true, eq_self_iff_true]
        have K : G a = g a := by dsimp [G]; simp [I.ne, (hg a I).1]
        convert dist_le_add_of_nonempty_closedBall_inter_closedBall (hg _ I).2.1 }
  exact hN.false sc


Verifying proof (Commit 151feca7cd329a83c958aa6af46cb01fabc83bf1):
∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine' le_of_not_lt fun hlt => h.2 _
    have : N < p.color i := hlt
    exact lt_irrefl _ (lt_of_le_of_lt this h.1)
  exact (lt_irrefl N (lt_of_le_of_lt this h.1)).elim

Repaired Proof:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N ∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine le_of_not_lt fun hlt => h.2 _
    have : N < p.color i := hlt
    exact lt_irrefl _ (lt_of_le_of_lt this h.1)
  exact (lt_irrefl N (lt_of_le_of_lt this h.1)).elim

Repaired Proof:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N ∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine le_of_not_lt fun hlt => h.2 _
    have : N < p.color i := hlt
    exact lt_irrefl _ (lt_of_le_of_lt this h.1)
  exact (lt_irrefl N (lt_of_le_of_lt this h.1)).elim

Repaired Proof:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N ∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine le_of_not_lt fun hlt => h.2 _
    have : N < p.color i := hlt
    exact lt_irrefl _ (lt_of_le_of_lt this h.1)
  exact (lt_irrefl N (lt_of_le_of_lt this h.1)).elim

Repaired Proof:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N ∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine le_of_not_lt fun hlt => h.2 _
    have : N < p.color i := hlt
    exact lt_irrefl _ (lt_of_le_of_lt this h.1)
  exact (lt_irrefl N (lt_of_le_of_lt this h.1)).elim

Repaired Proof:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N ∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine le_of_not_lt fun hlt => h.2 _
    have : N < p.color i := hlt
    exact lt_irrefl _ (lt_of_le_of_lt this h.1)
  exact (lt_irrefl N (lt_of_le_of_lt this h.1)).elim

Repaired Proof:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N ∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine le_of_not_lt fun hlt => h.2 _
    have : N < p.color i := hlt
    exact lt_irrefl _ (lt_of_le_of_lt this h.1)
  exact (lt_irrefl N (lt_of_le_of_lt this h.1)).elim

Repaired Proof:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N ∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine le_of_not_lt fun hlt => h.2 _
    have : N < p.color i := hlt
    exact lt_irrefl _ (lt_of_le_of_lt this h.1)
  exact (lt_irrefl N (lt_of_le_of_lt this h.1)).elim

Repaired Proof:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N ∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine le_of_not_lt fun hlt => h.2 _
    have : N < p.color i := hlt
    exact lt_irrefl _ (lt_of_le_of_lt this h.1)
  exact (lt_irrefl N (lt_of_le_of_lt this h.1)).elim

Repaired Proof:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N ∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine le_of_not_lt fun hlt => h.2 _
    have : N < p.color i := hlt
    exact lt_irrefl _ (lt_of_le_of_lt this h.1)
  exact (lt_irrefl N (lt_of_le_of_lt this h.1)).elim

Repaired Proof:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N ∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine le_of_not_lt fun hlt => h.2 _
    have : N < p.color i := hlt
    exact lt_irrefl _ (lt_of_le_of_lt this h.1)
  exact (lt_irrefl N (lt_of_le_of_lt this h.1)).elim

Repaired Proof:
theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}
    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N ∨ p.color i = N := by
  by_contra! h
  have : N ≤ p.color i := h.1.ge
  have : p.color i ≤ N := by
    refine le_of_not_lt fun hlt => h.2 _
    have :

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Differentiation.lean - 2024-09-09 00:56:56.014731.
---115/200---
For theorem VitaliFamily.null_of_frequently_le_of_frequently_ge in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem null_of_frequently_le_of_frequently_ge {c d : ℝ≥0} (hcd : c < d) (s : Set α)
    (hc : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, ρ a ≤ c * μ a)
    (hd : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, (d : ℝ≥0∞) * μ a ≤ ρ a) : μ s = 0 


Original valid proof:
:= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ⟨o, xo, o_open, μo⟩ : ∃ o : Set α, x ∈ o ∧ IsOpen o ∧ μ o < ∞ :=
    Measure.exists_isOpen_measure_lt_top μ x
  refine ⟨s ∩ o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_⟩
  let s' := s ∩ o
  by_contra h
  apply lt_irrefl (ρ s')
  calc
    ρ s' ≤ c * μ s' := v.measure_le_of_frequently_le (c • μ) hρ s' fun x hx => hc x hx.1
    _ < d * μ s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono inter_subset_right) μo).ne
    _ ≤ ρ s' :=
      v.measure_le_of_frequently_le ρ ((Measure.AbsolutelyContinuous.refl μ).smul d) s' fun x hx =>
        hd x hx.1


Verifying proof (Commit 9d3887769246754772c178dd6c594378dce58448):
∨ ρ s = 0 := by
  by_contra h
  rw [← Ne, ← pos_iff_ne_zero] at h
  rcases exists_between hcd with ⟨e, hce, hde⟩
  have he : 0 < e := h.1.trans hce
  have he' : e ≠ 0 := hce.ne'
  have he'' : (e : ℝ≥0∞) ≠ 0 := by simpa only [Ne, ofReal_eq_zero, not_le] using he.le
  rcases h.2.exists_measurable_superset_of_null with ⟨t, hst, htm, htμ, hρt⟩
  replace hρt : ∀ᶠ a in v.filterAt x, ρ a ≤ e * μ a :=
    (tendsto_order.1 (v.tendsto_measure_filterAt_of_null hρt)).2 e he
  have hρt' : ∀ᶠ a in v.filterAt x, ρ a ≤ e * μ a :=
    hρt.filter_mono (v.ae_eventuallyLE_of_ae_eventuallyLE_of_ae_le hst hc)
  have hρt'' : ∀ᶠ a in v.filterAt x, ρ a ≤ e * μ a :=
    hρt.filter_mono (v.ae_eventuallyLE_of_ae_eventuallyLE_of_ae_le hst.symm hd)
  have hec : ∀ᶠ a in v.filterAt x, e * μ a ≤ c * μ a :=
    hρt'.and hρt''.mono fun a ha ↦
      Iff.mpr (mul_le_mul_right (v.measure_pos_of_nhdsWithin htm (v.self_of_nhdsWithin_eq _))) ha.1
  have hed : ∀ᶠ a in v.filterAt x, d * μ a ≤ e * μ a :=
    hρt.and hρt''.mono fun a ha ↦
      Iff.mpr (mul_le_mul_right (v.measure_pos_of_nhdsWithin htm (v.self_of_nhdsWithin_eq _))) ha.2
  have hecd : ∀ᶠ a in v.filterAt x, c * μ a < d * μ a :=
    hec.and hed.mono fun a ha ↦ (mul_lt_mul_right (v.measure_pos_of_nhdsWithin htm
      (v.self_of_nhdsWithin_eq _))).mpr ha.2
  have hecd' : ∀ᶠ a in v.filterAt x, c < d := hecd.mono fun a ha ↦ (mul_lt_mul_right
    (v.measure_pos_of_nhdsWithin htm (v.self_of_nhdsWithin_eq _))).mp ha
  exact hde.not_eventually hecd'

Repaired Proof:
theorem null_of_frequently_le_of_frequently_ge {c d : ℝ≥0} (hcd : c < d) (s : Set α)
    (hc : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, ρ a ≤ c * μ a)
    (hd : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, (d : ℝ≥0∞) * μ a ≤ ρ a) : μ s = 0 ∨ ρ s = 0 := by
  by_contra h
  rw [← Ne, ← pos_iff_ne_zero] at h
  rcases exists_between hcd with ⟨e, hce, hde⟩
  have he : 0 < e := h.1.trans hce
  have he' : e ≠ 0 := hce.ne'
  have he'' : (e : ℝ≥0∞) ≠ 0 := by simpa only [Ne, ofReal_eq_zero, not_le] using he.le
  rcases h.2.exists_measurable_superset_of_null with ⟨t, hst, htm, htμ, hρt⟩
  replace hρt : ∀ᶠ a in v.filterAt x, ρ a ≤ e * μ a :=
    (tendsto_order.1 (v.tendsto_measure_filterAt_of_null hρt)).2 e he
  have hρt' : ∀ᶠ a in v.filterAt x, ρ a ≤ e * μ a :=
    hρt.filter_mono (v.ae_eventuallyLE_of_ae_eventuallyLE_of_ae_le hst hc)
  have hρt'' : ∀ᶠ a in v.filterAt x, ρ a ≤ e * μ a :=
    hρt.filter_mono (v.ae_eventuallyLE_of_ae_eventuallyLE_of_ae_le hst.symm hd)
  have hec : ∀ᶠ a in v.filterAt x, e * μ a ≤ c * μ a :=
    hρt'.and hρt''.mono fun a ha ↦
      Iff.mpr (mul_le_mul_right (v.measure_pos_of_nhdsWithin htm (v.self_of_nhdsWithin_eq _))) ha.1
  have hed : ∀ᶠ a in v.filterAt x, d * μ a ≤ e * μ a :=
    hρt.and hρt''.mono fun a ha ↦
      Iff.mpr (mul_le_mul_right (v.measure_pos_of_nhdsWithin htm (v.self_of_nhdsWithin_eq _))) ha.2
  have hecd : ∀ᶠ a in v.filterAt x, c * μ a < d * μ a :=
    hec.and hed.mono fun a ha ↦ (mul_lt_mul_right (v.measure_pos_of_nhdsWithin htm
      (v.self_of_nhdsWithin_eq _))).mpr ha
  have hecd' : ∀ᶠ a in v.filterAt x, c < d := hecd.mono fun a ha ↦ (mul_lt_mul_right
    (v.measure_pos_of_nhdsWithin htm (v.self_of_nhdsWithin_eq _))).mp ha
  exact hde.not_eventually hecd'

Repaired Proof:
theorem null_of_frequently_le_of_frequently_ge {c d : ℝ≥0} (hcd : c < d) (s : Set α)
    (hc : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, ρ a ≤ c * μ a)
    (hd : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, (d : ℝ≥0∞) * μ a ≤ ρ a) : μ s = 0 ∨ ρ s = 0 := by
  by_contra h
  rw [← Ne, ← pos_iff_ne_zero] at h
  rcases exists_between hcd with ⟨e, hce, hde⟩
  have he : 0 < e := h.1.trans hce
  have he' : e ≠ 0 := hce.ne'
  have he'' : (e : ℝ≥0∞) ≠ 0 := by simpa only [Ne, ofReal_eq_zero, not_le] using he.le
  rcases h.2.exists_measurable_superset_of_null with ⟨t, hst, htm, htμ, hρt⟩
  replace hρt : ∀ᶠ a in v.filterAt x, ρ a ≤ e * μ a :=
    (tendsto_order.1 (v.tendsto_measure_filterAt_of_null hρt)).2 e he
  have hρt' : ∀ᶠ a in v.filterAt x, ρ a ≤ e * μ a :=
    hρt.filter_mono (v.ae_eventuallyLE_of_ae_eventuallyLE_of_ae_le hst hc)
  have hρt'' : ∀ᶠ a in v.filterAt x, ρ a ≤ e * μ a :=
    hρt.filter_mono (v.ae_eventuallyLE_of_ae_eventuallyLE_of_ae_le hst.symm hd)
  have hec : ∀ᶠ a in v.filterAt x, e * μ a ≤ c * μ a :=
    h

Attempt failure.

---116/200---
For theorem VitaliFamily.measure_limRatioMeas_zero in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 


Original valid proof:
:= by
  refine measure_null_of_locally_null _ fun x _ => ?_
  obtain ⟨o, xo, o_open, μo⟩ : ∃ o : Set α, x ∈ o ∧ IsOpen o ∧ μ o < ∞ :=
    Measure.exists_isOpen_measure_lt_top μ x
  let s := {x : α | v.limRatioMeas hρ x = 0} ∩ o
  refine ⟨s, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), le_antisymm ?_ bot_le⟩
  have μs : μ s ≠ ∞ := ((measure_mono inter_subset_right).trans_lt μo).ne
  have A : ∀ q : ℝ≥0, 0 < q → ρ s ≤ q * μ s := by
    intro q hq
    apply v.measure_le_mul_of_subset_limRatioMeas_lt hρ
    intro y hy
    have : v.limRatioMeas hρ y = 0 := hy.1
    simp only [this, mem_setOf_eq, hq, ENNReal.coe_pos]
  have B : Tendsto (fun q : ℝ≥0 => (q : ℝ≥0∞) * μ s) (𝓝[>] (0 : ℝ≥0)) (𝓝 ((0 : ℝ≥0) * μ s)) := by
    apply ENNReal.Tendsto.mul_const _ (Or.inr μs)
    rw [ENNReal.tendsto_coe]
    exact nhdsWithin_le_nhds
  simp only [zero_mul, ENNReal.coe_zero] at B
  apply ge_of_tendsto B
  filter_upwards [self_mem_nhdsWithin] using A


Verifying proof (Commit 9d3887769246754772c178dd6c594378dce58448):
∧
    ρ {x | ¬v.limRatioMeas hρ x = 0} = v.limRatioMeas hρ • μ := by
  have : ∀ᵐ x ∂ρ, Tendsto (fun r => ρ (closedBall x r) / μ (closedBall x r)) (𝓝[>] 0)
      (𝓝 (v.limRatioMeas hρ x)) :=
    ae_tendsto_limRatioMeas_of_singular hρ
  rcases ae_zero_or_pos_measure_set this with (H | H)
  · have : ∀ᵐ x ∂ρ, v.limRatioMeas hρ x = 0 := by
      filter_upwards [H] with x hx
      rcases eq_or_ne (v.limRatioMeas hρ x) 0 with h'x | h'x
      · exact h'x
      · rw [← hx] at h'x
        simp only [measure_closedBall_pos, ENNReal.inv_pos, ENNReal.div_pos_iff,
          ENNReal.ofReal_pos, Metric.closedBall_eq_empty, not_lt, bot_eq_zero,
          or_false_iff, Metric.closedBall_eq_empty, not_lt, bot_eq_zero, or_false_iff,
            Metric.closedBall_eq_empty, not_lt, bot_eq_zero, or_false_iff, Metric.closedBall_eq_empty,
            not_lt, bot_eq_zero, or_false_iff] at h'x
        exact absurd h'x (measure_closedBall_pos _ _ _).ne'
    simp only [ae_iff] at H
    simp only [this, ENNReal.smul_def, measure_mono_null, measure_univ, le_top,
      measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff]
    exact ⟨by simp only [this, measure_mono_null, measure_univ, le_top,
        measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff], by simp⟩
  · have : ∀ᵐ x ∂ρ, ¬v.limRatioMeas hρ x = 0 := by
      filter_upwards [H] with x hx
      contrapose! hx
      simp only [ae_iff, not_not] at H
      simp only [hx, not_false_iff, measure_mono_null, measure_univ, le_top,
        measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff]
      exact H
    simp only [this, ENNReal.smul_def, measure_mono_null, measure_univ, le_top,
      measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff]
    exact ⟨by simp only [this, measure_mono_null, measure_univ, le_top,
        measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff], by simp⟩

Repaired Proof:
theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 ∧
    ρ {x | ¬v.limRatioMeas hρ x = 0} = v.limRatioMeas hρ • μ := by
  have : ∀ᵐ x ∂ρ, Tendsto (fun r => ρ (closedBall x r) / μ (closedBall x r)) (𝓝[>] 0)
      (𝓝 (v.limRatioMeas hρ x)) :=
    ae_tendsto_limRatioMeas_of_singular hρ
  rcases ae_zero_or_pos_measure_set this with (H | H)
  · have : ∀ᵐ x ∂ρ, v.limRatioMeas hρ x = 0 := by
      filter_upwards [H] with x hx
      rcases eq_or_ne (v.limRatioMeas hρ x) 0 with h'x | h'x
      · exact h'x
      · rw [← hx] at h'x
        simp only [measure_closedBall_pos, ENNReal.inv_pos, ENNReal.div_pos_iff,
          ENNReal.ofReal_pos, Metric.closedBall_eq_empty, not_lt, bot_eq_zero,
          or_false_iff, Metric.closedBall_eq_empty, not_lt, bot_eq_zero, or_false_iff,
            Metric.closedBall_eq_empty, not_lt, bot_eq_zero, or_false_iff, Metric.closedBall_eq_empty,
            not_lt, bot_eq_zero, or_false_iff] at h'x
        exact absurd h'x (measure_closedBall_pos _ _ _).ne'
    simp only [ae_iff] at H
    simp only [this, ENNReal.smul_def, measure_mono_null, measure_univ, le_top,
      measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff]
    exact ⟨by simp only [this, measure_mono_null, measure_univ, le_top,
        measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff], by simp⟩
  · have : ∀ᵐ x ∂ρ, ¬v.limRatioMeas hρ x = 0 := by
      filter_upwards [H] with x hx
      contrapose! hx
      simp only [ae_iff, not_not] at H
      simp only [hx, not_false_iff, measure_mono_null, measure_univ, le_top,
        measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff]
      exact H
    simp only [this, ENNReal.smul_def, measure_mono_null, measure_univ, le_top,
      measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff]
    exact ⟨by simp only [this, measure_mono_null, measure_univ, le_top,
        measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff], by simp⟩

Repaired Proof:
theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 ∧
    ρ {x | ¬v.limRatioMeas hρ x = 0} = v.limRatioMeas hρ • μ := by
  have : ∀ᵐ x ∂ρ, Tendsto (fun r => ρ (closedBall x r) / μ (closedBall x r)) (𝓝[>] 0)
      (𝓝 (v.limRatioMeas hρ x)) :=
    ae_tendsto_limRatioMeas_of_singular hρ
  rcases ae_zero_or_pos_measure_set this with (H | H)
  · have : ∀ᵐ x ∂ρ, v.limRatioMeas hρ x = 0 := by
      filter_upwards [H] with x hx
      rcases eq_or_ne (v.limRatioMeas hρ x) 0 with h'x | h'x
      · exact h'x
      · rw [← hx] at h'x
        simp only [measure_closedBall_pos, ENNReal.inv_pos, ENNReal.div_pos_iff,
          ENNReal.ofReal_pos, Metric.closedBall_eq_empty, not_lt, bot_eq_zero,
          or_false_iff, Metric.closedBall_eq_empty, not_lt, bot_eq_zero, or_false_iff,
            Metric.closedBall_eq_empty, not_lt, bot_eq_zero, or_false_iff, Metric.closedBall_eq_empty,
            not_lt, bot_eq_zero, or_false_iff] at h'x
        exact absurd h'x (measure_closedBall_pos _ _ _).ne'
    simp only [ae_iff] at H
    simp only [this, ENNReal.smul_def, measure_mono_null, measure_univ, le_top,
      measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff]
    exact ⟨by simp only [this, measure_mono_null, measure_univ, le_top,
        measure_mono_null_iff_imp_not_measurable, nullMeasurableSet_iff], by simp⟩
  · have : ∀ᵐ x

Attempt failure.

Working on Mathlib/MeasureTheory/Function/Jacobian.lean - 2024-09-09 00:57:36.266907.
---117/200---
For theorem MeasureTheory.lintegral_abs_det_fderiv_le_addHaar_image_aux1 in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem lintegral_abs_det_fderiv_le_addHaar_image_aux1 (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) {ε : ℝ≥0} (εpos : 0 < ε) :
    (∫⁻ x in s, ENNReal.ofReal |(f' x).det| ∂μ) ≤ μ (f '' s) + 2 * ε * μ s 


Original valid proof:
:= by
  have :
    ∀ A : E →L[ℝ] E,
      ∃ δ : ℝ≥0,
        0 < δ ∧
          (∀ B : E →L[ℝ] E, ‖B - A‖ ≤ δ → |B.det - A.det| ≤ ε) ∧
            ∀ (t : Set E) (g : E → E), ApproximatesLinearOn g A t δ →
              ENNReal.ofReal |A.det| * μ t ≤ μ (g '' t) + ε * μ t := by
    intro A
    obtain ⟨δ', δ'pos, hδ'⟩ : ∃ (δ' : ℝ), 0 < δ' ∧ ∀ B, dist B A < δ' → dist B.det A.det < ↑ε :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt ε εpos
    let δ'' : ℝ≥0 := ⟨δ' / 2, (half_pos δ'pos).le⟩
    have I'' : ∀ B : E →L[ℝ] E, ‖B - A‖ ≤ ↑δ'' → |B.det - A.det| ≤ ↑ε := by
      intro B hB
      rw [← Real.dist_eq]
      apply (hδ' B _).le
      rw [dist_eq_norm]
      exact hB.trans_lt (half_lt_self δ'pos)
    rcases eq_or_ne A.det 0 with (hA | hA)
    · refine ⟨δ'', half_pos δ'pos, I'', ?_⟩
      simp only [hA, forall_const, zero_mul, ENNReal.ofReal_zero, imp_true_iff,
        zero_le, abs_zero]
    let m : ℝ≥0 := Real.toNNReal |A.det| - ε
    have I : (m : ℝ≥0∞) < ENNReal.ofReal |A.det| := by
      simp only [m, ENNReal.ofReal, ENNReal.coe_sub]
      apply ENNReal.sub_lt_self ENNReal.coe_ne_top
      · simpa only [abs_nonpos_iff, Real.toNNReal_eq_zero, ENNReal.coe_eq_zero, Ne] using hA
      · simp only [εpos.ne', ENNReal.coe_eq_zero, Ne, not_false_iff]
    rcases ((mul_le_addHaar_image_of_lt_det μ A I).and self_mem_nhdsWithin).exists with ⟨δ, h, δpos⟩
    refine ⟨min δ δ'', lt_min δpos (half_pos δ'pos), ?_, ?_⟩
    · intro B hB
      apply I'' _ (hB.trans _)
      simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
    · intro t g htg
      rcases eq_or_ne (μ t) ∞ with (ht | ht)
      · simp only [ht, εpos.ne', ENNReal.mul_top, ENNReal.coe_eq_zero, le_top, Ne,
          not_false_iff, _root_.add_top]
      have := h t g (htg.mono_num (min_le_left _ _))
      rwa [ENNReal.coe_sub, ENNReal.sub_mul, tsub_le_iff_right] at this
      simp only [ht, imp_true_iff, Ne, not_false_iff]
  choose δ hδ using this
  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, -⟩ :
    ∃ (t : ℕ → Set E) (A : ℕ → E →L[ℝ] E),
      Pairwise (Disjoint on t) ∧
        (∀ n : ℕ, MeasurableSet (t n)) ∧
          (s ⊆ ⋃ n : ℕ, t n) ∧
            (∀ n : ℕ, ApproximatesLinearOn f (A n) (s ∩ t n) (δ (A n))) ∧
              (s.Nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' δ fun A => (hδ A).1.ne'
  have s_eq : s = ⋃ n, s ∩ t n := by
    rw [← inter_iUnion]
    exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
  calc
    (∫⁻ x in s, ENNReal.ofReal |(f' x).det| ∂μ) =
        ∑' n, ∫⁻ x in s ∩ t n, ENNReal.ofReal |(f' x).det| ∂μ := by
      conv_lhs => rw [s_eq]
      rw [lintegral_iUnion]
      · exact fun n => hs.inter (t_meas n)
      · exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
    _ ≤ ∑' n, ∫⁻ _ in s ∩ t n, ENNReal.ofReal |(A n).det| + ε ∂μ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le μ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono inter_subset_left]
      intro x hx
      have I : |(f' x).det| ≤ |(A n).det| + ε :=
        calc
          |(f' x).det| = |(A n).det + ((f' x).det - (A n).det)| := by congr 1; abel
          _ ≤ |(A n).det| + |(f' x).det - (A n).det| := abs_add _ _
          _ ≤ |(A n).det| + ε := add_le_add le_rfl ((hδ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(f' x).det| ≤ ENNReal.ofReal (|(A n).det| + ε) :=
          ENNReal.ofReal_le_ofReal I
        _ = ENNReal.ofReal |(A n).det| + ε := by
          simp only [ENNReal.ofReal_add, abs_nonneg, NNReal.zero_le_coe, ENNReal.ofReal_coe_nnreal]
    _ = ∑' n, (ENNReal.ofReal |(A n).det| * μ (s ∩ t n) + ε * μ (s ∩ t n)) := by
      simp only [setLIntegral_const, lintegral_add_right _ measurable_const]
    _ ≤ ∑' n, (μ (f '' (s ∩ t n)) + ε * μ (s ∩ t n) + ε * μ (s ∩ t n)) := by
      gcongr
      exact (hδ (A _)).2.2 _ _ (ht _)
    _ = μ (f '' s) + 2 * ε * μ s := by
      conv_rhs => rw [s_eq]
      rw [image_iUnion, measure_iUnion]; rotate_left
      · intro i j hij
        apply Disjoint.image _ hf inter_subset_left inter_subset_left
        exact Disjoint.mono inter_subset_right inter_subset_right (t_disj hij)
      · intro i
        exact
          measurable_image_of_fderivWithin (hs.inter (t_meas i))
            (fun x hx => (hf' x hx.1).mono inter_subset_left)
            (hf.mono inter_subset_left)
      rw [measure_iUnion]; rotate_left
      · exact pairwise_disjoint_mono t_disj fun i => inter_subset_right
      · exact fun i => hs.inter (t_meas i)
      rw [← ENNReal.tsum_mul_left, ← ENNReal.tsum_add]
      congr 1
      ext1 i
      rw [mul_assoc, two_mul, add_assoc]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
↔
      ∀ x ∈ s, ∀ y ∈ s, emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' x) := by
  have : ∀ x ∈ s, ∀ y ∈ s,
      emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' x) ↔
        emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' y) := by
    intro x hx y hy
    rw [← fderivWithin_inter (uniqueDiffOn_of_isOpen_isClosed isOpen_ball isClosed_ball)
        ((inter_mem_nhdsWithin _ (ball_mem_nhds _ εpos)).2 (ball_mem_nhds _ εpos)),
      fderivWithin_congr (inter_mem_nhdsWithin _ (ball_mem_nhds _ εpos))
        ((hf'.mono (inter_subset_right _ _)).inter (hf'.mono (inter_subset_left _ _))).unique
        (hf.mono inter_subset_left)]
  constructor
  · intro h x hx y hy
    rw [this x hx y hy]
    exact (addHaar_image_le_of_det_fderivWithin_le hs hf' hf εpos).1 h x hx y hy
  · intro h
    simp_rw [this] at h
    exact (addHaar_image_le_of_det_fderivWithin_le hs hf' hf εpos).2 h

Repaired Proof:
theorem lintegral_abs_det_fderiv_le_addHaar_image_aux1 (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) {ε : ℝ≥0} (εpos : 0 < ε) :
    (∫⁻ x in s, ENNReal.ofReal |(f' x).det| ∂μ) ≤ μ (f '' s) + 2 * ε * μ s ↔
      ∀ x ∈ s, ∀ y ∈ s, emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' x) := by
  have : ∀ x ∈ s, ∀ y ∈ s,
      emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' x) ↔
        emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' y) := by
    intro x hx y hy
    rw [← fderivWithin_inter (uniqueDiffOn_of_isOpen_isClosed isOpen_ball isClosed_ball)
        ((inter_mem_nhdsWithin _ (ball_mem_nhds _ εpos)).2 (ball_mem_nhds _ εpos)),
      fderivWithin_congr (inter_mem_nhdsWithin _ (ball_mem_nhds _ εpos))
        ((hf'.mono inter_subset_right).inter (hf'.mono inter_subset_left)).unique
        (hf.mono inter_subset_left)]
  constructor
  · intro h x hx y hy
    rw [this x hx y hy]
    exact (addHaar_image_le_of_det_fderivWithin_le hs hf' hf εpos).1 h x hx y hy
  · intro h
    simp_rw [this] at h
    exact (addHaar_image_le_of_det_fderivWithin_le hs hf' hf εpos).2 h

Repaired Proof:
theorem lintegral_abs_det_fderiv_le_addHaar_image_aux1 (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) {ε : ℝ≥0} (εpos : 0 < ε) :
    (∫⁻ x in s, ENNReal.ofReal |(f' x).det| ∂μ) ≤ μ (f '' s) + 2 * ε * μ s ↔
      ∀ x ∈ s, ∀ y ∈ s, emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' x) := by
  have : ∀ x ∈ s, ∀ y ∈ s,
      emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' x) ↔
        emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' y) := by
    intro x hx y hy
    rw [← fderivWithin_inter (uniqueDiffOn_of_isOpen_isClosed isOpen_ball isClosed_ball)
        ((inter_mem_nhdsWithin _ (ball_mem_nhds _ εpos)).2 (ball_mem_nhds _ εpos)),
      fderivWithin_congr (inter_mem_nhdsWithin _ (ball_mem_nhds _ εpos))
        ((hf'.mono inter_subset_right).inter (hf'.mono inter_subset_left)).unique
        (hf.mono inter_subset_left)]
  constructor
  · intro h x hx y hy
    rw [this x hx y hy]
    exact (addHaar_image_le_of_det_fderivWithin_le hs hf' hf εpos).1 h x hx y hy
  · intro h
    simp_rw [this] at h
    exact (addHaar_image_le_of_det_fderivWithin_le hs hf' hf εpos).2 h

Repaired Proof:
theorem lintegral_abs_det_fderiv_le_addHaar_image_aux1 (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) {ε : ℝ≥0} (εpos : 0 < ε) :
    (∫⁻ x in s, ENNReal.ofReal |(f' x).det| ∂μ) ≤ μ (f '' s) + 2 * ε * μ s ↔
      ∀ x ∈ s, ∀ y ∈ s, emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' x) := by
  have : ∀ x ∈ s, ∀ y ∈ s,
      emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' x) ↔
        emetric.ball x (ε * dist y x) ∩ emetric.ball y (ε * dist x y) ∈ 𝓕σ (f' y) := by
    intro x hx y hy
    rw [← fderivWithin_inter (uniqueDiffOn_of_isOpen_isClosed isOpen_ball isClosed_ball)
        ((inter_mem_nhdsWithin _ (ball_mem_nhds _ εpos)).2 (ball_mem_nhds _ εpos)),
      fderivWithin_congr (inter_mem_nhdsWithin _ (ball_mem_nhds _ εpos))
        ((hf'.mono inter_subset_right).inter (hf'.mono inter_subset_left)).unique
        (hf.mono inter_subset_left)]
  constructor
  · intro h x hx y hy
    rw [this x hx y hy]
    exact (addHaar_image_le_of_det_fderivWithin_le hs hf' hf εpos).1 h x hx y hy
  · intro h
    simp_rw [this] at h
    exact (addHaar_image_le_of_det_fderivWithin_le hs hf' hf εpos).2 h

Repaired Proof:
theorem lintegral_abs_det_fderiv_le_addHaar_image_aux1 (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f'

Attempt failure.

Working on Mathlib/MeasureTheory/Function/L1Space.lean - 2024-09-09 00:58:05.308257.
---118/200---
For theorem MeasureTheory.Integrable.measure_norm_ge_lt_top in Mathlib/MeasureTheory/Function/L1Space.lean:
theorem Integrable.measure_norm_ge_lt_top {f : α → β} (hf : Integrable f μ) {ε : ℝ} (hε : 0 < ε) :
    μ { x | ε ≤ ‖f x‖ } < ∞ 


Original valid proof:
:= by
  rw [show { x | ε ≤ ‖f x‖ } = { x | ENNReal.ofReal ε ≤ ‖f x‖₊ } by
      simp only [ENNReal.ofReal, Real.toNNReal_le_iff_le_coe, ENNReal.coe_le_coe, coe_nnnorm]]
  refine (meas_ge_le_mul_pow_snorm μ one_ne_zero ENNReal.one_ne_top hf.1 ?_).trans_lt ?_
  · simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hε
  apply ENNReal.mul_lt_top
  · simpa only [ENNReal.one_toReal, ENNReal.rpow_one, Ne, ENNReal.inv_eq_top,
      ENNReal.ofReal_eq_zero, not_le] using hε
  simpa only [ENNReal.one_toReal, ENNReal.rpow_one] using
    (memℒp_one_iff_integrable.2 hf).snorm_ne_top


Verifying proof (Commit 7dc162787d2a79bf721a83a87f641ace70251b17):
∧ μ { x | ‖f x‖ ≤ ε } < ∞ := by
  have h1 : ∀ n : ℕ, Integrable (fun x : α => (ε * 2) ^ n * ‖f x‖ ^ n) μ := by
    intro n
    have h2 : 0 ≤ ε * 2 := by
      have h2 : 0 < ε := hε
      linarith
    have h3 : 0 ≤ ‖f ·‖ := fun _ => norm_nonneg _
    have h4 : 0 ≤ (ε * 2) ^ n := pow_nonneg h2 n
    have h5 : 0 ≤ (‖f ·‖ ^ n) := fun _ => pow_nonneg h3 n
    exact Integrable.mul_const _ (hf.norm.pow n)
  have h6 : ∀ n : ℕ, ∫⁻ a : α, ENNReal.ofReal ((ε * 2) ^ n * ‖f a‖ ^ n) ∂μ ≤
      ENNReal.ofReal ((ε * 2) ^ n * (∫⁻ a : α, ‖f a‖ ^ n ∂μ).toReal) := by
    intro n
    have h7 : ∀ a : α, ENNReal.ofReal ((ε * 2) ^ n * ‖f a‖ ^ n) ≤
        ENNReal.ofReal ((ε * 2) ^ n) * ENNReal.ofReal (‖f a‖ ^ n) := by
      intro a
      rw [ENNReal.ofReal_mul, ENNReal.ofReal_mul]
      · apply ENNReal.ofReal_le_ofReal
        rw [mul_comm]
        gcongr
        apply le_rfl
      · exact mul_nonneg (pow_nonneg hε.le n) (pow_nonneg (norm_nonneg _) n)
      · exact pow_nonneg hε.le n
    refine' lintegral_mono' h7 (hf.hasFiniteIntegral.norm.pow n).2
  have h8 : ∀ n : ℕ, (ε * 2) ^ n * (∫⁻ a : α, ‖f a‖ ^ n ∂μ).toReal ≤ ε ^ n * ∫ a : α, ‖f a‖ ^ n ∂μ := by
    intro n
    by_cases h9 : ∫⁻ a : α, ‖f a‖ ^ n ∂μ = ∞
    · rw [h9, ENNReal.top_toReal, mul_zero, zero_mul]
    · have h10 : 0 < ε ^ n := pow_pos hε n
      have h11 : 0 < (ε * 2) ^ n := pow_pos (mul_pos hε two_pos) n
      rw [← ENNReal.ofReal_toReal h9]
      refine' mul_le_mul_of_nonneg_left _ h10.le
      rw [ENNReal.toReal_le_toReal ENNReal.coe_lt_top.ne h9]
      exact lintegral_mono fun x => pow_le_pow_left h3 (le_of_eq (by ring)) n
  have h12 : ∀ n : ℕ, ∫⁻ a : α, ENNReal.ofReal ((ε * 2) ^ n * ‖f a‖ ^ n) ∂μ ≤
      ENNReal.ofReal (ε ^ n * ∫ a : α, ‖f a‖ ^ n ∂μ) := by
    intro n
    convert h6 n
    · rw [← ENNReal.ofReal_mul, mul_comm, ← mul_assoc, ← ENNReal.ofReal_mul, mul_comm, ←
        ENNReal.ofReal_mul]
      congr 2
      rw [mul_comm]
      gcongr
      apply le_rfl
    · rw [← ENNReal.ofReal_mul, mul_comm, ← mul_assoc, ← ENNReal.ofReal_mul, mul_comm, ←
        ENNReal.ofReal_mul]
      congr 2
      rw [mul_comm]
      gcongr
      apply le_rfl
  have h13 : ∀ n : ℕ, ∫⁻ a : α, ENNReal.ofReal ((ε * 2) ^ n * ‖f a‖ ^ n) ∂μ ≠ ∞ := by
    intro n
    refine' ne_top_of_le_ne_top (ENNReal.ofReal_ne_top) (h12 n)
  have h14 : ∀ n : ℕ, ∫⁻ a : α, ENNReal.ofReal ((ε * 2) ^ n * ‖f a‖ ^ n) ∂μ ≤
      ENNReal.ofReal (ε ^ n * ∫⁻ a : α, ‖f a‖ ^ n ∂μ) := by
    intro n
    convert h12 n
    · rw [← ENNReal.ofReal_mul, mul_comm, ← mul_assoc, ← ENNReal.ofReal_mul, mul_comm, ←
        ENNReal.ofReal_mul]
      congr 2
      rw [mul_comm]
      gcongr
      apply le_rfl
    · rw [← ENNReal.ofReal_mul, mul_comm, ← mul_assoc, ← ENNReal.ofReal_mul, mul_comm, ←
        ENNReal.ofReal_mul]
      congr 2
      rw [mul_comm]
      gcongr
      apply le_rfl
  have h15 : ∀ n : ℕ, ∫⁻ a : α, ENNReal.ofReal ((ε * 2) ^ n * ‖f a‖ ^ n) ∂μ ≠ ∞ := by
    intro n
    refine' ne_top_of_le_ne_top (ENNReal.ofReal_ne_top) (h14 n)
  have h16 : ∀ n : ℕ, ∫⁻ a : α, ENNReal.ofReal (‖f a‖ ^ n) ∂μ ≠ ∞ := by
    intro n
    refine' ne_top_of_le_ne_top (ENNReal.ofReal_ne_top) (le_trans _ (h14 n))
    gcongr
    apply lintegral_mono fun x => pow_le_pow_left h3 (le_of_eq (by ring)) n
  have h17 : ∀ n : ℕ, ∫⁻ a : α, ENNReal.ofReal (‖f a‖ ^ n) ∂μ ≠ ∞ := by
    intro n
    refine' ne_top_of_le_ne_top (ENNReal.ofReal_ne_top) (le_trans _ (h14 n))
    gcongr
    apply lintegral_mono fun x => pow_le_pow_left h3 (le_of_eq (by ring)) n
  have h18 : ∀ n : ℕ, ∫⁻ a : α, ENNReal.ofReal (‖f a‖ ^ n) ∂μ ≠ ∞ := by
    intro n
    refine' ne_top_of_le_ne_top (ENNReal.ofReal_ne_top) (le_trans _ (h14 n))
    gcongr
    apply lintegral_mono fun x => pow_le_pow_left h3 (le_of_eq (by ring)) n
  have h19 : ∀ n : ℕ, ∫⁻ a : α, ENNReal.ofReal (‖f a‖ ^ n) ∂μ ≠ ∞ := by
    intro n
    refine' ne_top_of_le_ne_top (ENNReal.ofReal_ne_top) (le_trans _ (h14 n))
    gcongr
    apply lintegral_mono fun x => pow_le_pow_left h3 (le_of_eq (by ring)) n
  have h20 : ∀ n : ℕ, ∫⁻ a : α, ENNReal.ofReal (‖f a‖ ^ n) ∂μ ≠ ∞ := by
    intro n
    refine' ne_top_of_le_ne_top (ENNReal.ofReal_ne_top) (le_trans _ (h14 n))
    gcongr
    apply lintegral_mono fun x => pow_le_pow_left h3 (le_of_eq (by ring)) n
  have

Attempt failure.

Working on Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean - 2024-09-09 00:58:33.666898.
---119/200---
For theorem MeasureTheory.AEFinStronglyMeasurable.exists_set_sigmaFinite in Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean:
theorem exists_set_sigmaFinite [Zero β] [TopologicalSpace β] [T2Space β]
    (hf : FinStronglyMeasurable f μ) :
    ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) 


Original valid proof:
:= by
  rcases hf with ⟨fs, hT_lt_top, h_approx⟩
  let T n := support (fs n)
  have hT_meas : ∀ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := ⋃ n, T n
  refine ⟨t, MeasurableSet.iUnion hT_meas, ?_, ?_⟩
  · have h_fs_zero : ∀ n, ∀ x ∈ tᶜ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  · refine ⟨⟨⟨fun n => tᶜ ∪ T n, fun _ => trivial, fun n => ?_, ?_⟩⟩⟩
    · rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono Set.inter_subset_left).trans_lt (hT_lt_top n)
    · rw [← Set.union_iUnion tᶜ T]
      exact Set.compl_union_self _


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      tᶜ ∈ ae μ := by
  borelize β
  rcases hf with ⟨s, _, _, hs⟩
  let t := ⋃ x ∈ s, { y | f y = f x }
  refine ⟨t, ?_, ?_, ?_, ?_⟩
  · refine MeasurableSet.biUnion s.to_finite ?_ fun x _ => ?_
    · exact fun x _ => measurableSet_fiber _ _
    · exact measurableSet_fiber _ _
  · rintro x ⟨y, hy, rfl⟩
    simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
    rintro rfl
    exact hy
  · suffices h : ∀ x ∈ s, SigmaFinite (μ.restrict { y | f y = f x }) by
      refine (sigmaFinite_iUnion fun x => h x x.2).mono ?_
      filter_upwards with y
      simp only [Set.mem_iUnion, mem_setOf_eq]
      rintro ⟨x', hx', rfl⟩
      exact ⟨x', hx', rfl⟩
    refine fun x hx => (hs x hx).sigmaFinite
  · have : ∀ᵐ x ∂μ, x ∉ tᶜ := by
      filter_upwards [hf.finMeasSupp μ] with x hx
      simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
      rintro rfl
      exact hx rfl
    refine mem_ae_iff.2 (this.mono fun x hx h'x => ?_)
    simpa only [Set.mem_compl_iff, mem_setOf_eq, not_not] using h'x

Repaired Proof:
theorem exists_set_sigmaFinite [Zero β] [TopologicalSpace β] [T2Space β]
    (hf : FinStronglyMeasurable f μ) :
    ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) ∧
      tᶜ ∈ ae μ := by
  borelize β
  rcases hf with ⟨s, _, _, hs⟩
  let t := ⋃ x ∈ s, { y | f y = f x }
  refine ⟨t, ?_, ?_, ?_, ?_⟩
  · refine MeasurableSet.biUnion s.to_finite ?_ fun x _ => ?_
    · exact fun x _ => measurableSet_fiber _ _
    · exact measurableSet_fiber _ _
  · rintro x ⟨y, hy, rfl⟩
    simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
    rintro rfl
    exact hy
  · suffices h : ∀ x ∈ s, SigmaFinite (μ.restrict { y | f y = f x }) by
      refine (sigmaFinite_iUnion fun x => h x x.2).mono ?_
      filter_upwards with y
      simp only [Set.mem_iUnion, mem_setOf_eq]
      rintro ⟨x', hx', rfl⟩
      exact ⟨x', hx', rfl⟩
    refine fun x hx => (hs x hx).sigmaFinite
  · have : ∀ᵐ x ∂μ, x ∉ tᶜ := by
      filter_upwards [hf.finMeasSupp μ] with x hx
      simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
      rintro rfl
      exact hx rfl
    refine mem_ae_iff.2 (this.mono fun x hx h'x => ?_)
    simpa only [Set.mem_compl_iff, mem_setOf_eq, not_not] using h'x

Repaired Proof:
theorem exists_set_sigmaFinite [Zero β] [TopologicalSpace β] [T2Space β]
    (hf : FinStronglyMeasurable f μ) :
    ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) ∧
      tᶜ ∈ ae μ := by
  borelize β
  rcases hf with ⟨s, _, _, hs⟩
  let t := ⋃ x ∈ s, { y | f y = f x }
  refine ⟨t, ?_, ?_, ?_, ?_⟩
  · refine MeasurableSet.biUnion s.to_finite ?_ fun x _ => ?_
    · exact fun x _ => measurableSet_fiber _ _
    · exact measurableSet_fiber _ _
  · rintro x ⟨y, hy, rfl⟩
    simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
    rintro rfl
    exact hy
  · suffices h : ∀ x ∈ s, SigmaFinite (μ.restrict { y | f y = f x }) by
      refine (sigmaFinite_iUnion fun x => h x x.2).mono ?_
      filter_upwards with y
      simp only [Set.mem_iUnion, mem_setOf_eq]
      rintro ⟨x', hx', rfl⟩
      exact ⟨x', hx', rfl⟩
    refine fun x hx => (hs x hx).sigmaFinite
  · have : ∀ᵐ x ∂μ, x ∉ tᶜ := by
      filter_upwards [hf.finMeasSupp μ] with x hx
      simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
      rintro rfl
      exact hx rfl
    refine mem_ae_iff.2 (this.mono fun x hx h'x => ?_)
    simpa only [Set.mem_compl_iff, mem_setOf_eq, not_not] using h'x

Repaired Proof:
theorem exists_set_sigmaFinite [Zero β] [TopologicalSpace β] [T2Space β]
    (hf : FinStronglyMeasurable f μ) :
    ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) ∧
      tᶜ ∈ ae μ := by
  borelize β
  rcases hf with ⟨s, _, _, hs⟩
  let t := ⋃ x ∈ s, { y | f y = f x }
  refine ⟨t, ?_, ?_, ?_, ?_⟩
  · refine MeasurableSet.biUnion s.to_finite ?_ fun x _ => ?_
    · exact fun x _ => measurableSet_fiber _ _
    · exact measurableSet_fiber _ _
  · rintro x ⟨y, hy, rfl⟩
    simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
    rintro rfl
    exact hy
  · suffices h : ∀ x ∈ s, SigmaFinite (μ.restrict { y | f y = f x }) by
      refine (sigmaFinite_iUnion fun x => h x x.2).mono ?_
      filter_upwards with y
      simp only [Set.mem_iUnion, mem_setOf_eq]
      rintro ⟨x', hx', rfl⟩
      exact ⟨x', hx', rfl⟩
    refine fun x hx => (hs x hx).sigmaFinite
  · have : ∀ᵐ x ∂μ, x ∉ tᶜ := by
      filter_upwards [hf.finMeasSupp μ] with x hx
      simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
      rintro rfl
      exact hx rfl
    refine mem_ae_iff.2 (this.mono fun x hx h'x => ?_)
    simpa only [Set.mem_compl_iff, mem_setOf_eq, not_not] using h'x

Repaired Proof:
theorem exists_set_sigmaFinite [Zero β] [TopologicalSpace β] [T2Space β]
    (hf : FinStronglyMeasurable f μ) :
    ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) 

Attempt failure.

Working on Mathlib/MeasureTheory/Group/Prod.lean - 2024-09-09 00:58:53.761139.
---120/200---
For theorem MeasureTheory.measure_lintegral_div_measure in Mathlib/MeasureTheory/Group/Prod.lean:
theorem measure_lintegral_div_measure [IsMulLeftInvariant ν] (sm : MeasurableSet s) (h2s : ν s ≠ 0)
    (h3s : ν s ≠ ∞) (f : G → ℝ≥0∞) (hf : Measurable f) :
    (μ s * ∫⁻ y, f y⁻¹ / ν ((fun x => x * y⁻¹) ⁻¹' s) ∂ν) = ∫⁻ x, f x ∂μ 


Original valid proof:
:= by
  set g := fun y => f y⁻¹ / ν ((fun x => x * y⁻¹) ⁻¹' s)
  have hg : Measurable g :=
    (hf.comp measurable_inv).div ((measurable_measure_mul_right ν sm).comp measurable_inv)
  simp_rw [measure_mul_lintegral_eq μ ν sm g hg, g, inv_inv]
  refine lintegral_congr_ae ?_
  refine (ae_measure_preimage_mul_right_lt_top_of_ne_zero μ ν sm h2s h3s).mono fun x hx => ?_
  simp_rw [ENNReal.mul_div_cancel' (measure_mul_right_ne_zero ν h2s _) hx.ne]


Verifying proof (Commit 71880da883b383ac13b9beb76b1bd41a0f023582):
↔
      μ = (ν.map fun x => x * y⁻¹).withDensity fun x => (ν s)⁻¹ * f x⁻¹ := by
  have h3f : ∫⁻ x, f x ∂μ ≠ ∞ :=
    (lintegral_eq_top_iff_of_measurable hf).not.mpr fun h =>
      h2s ((measure_eq_top_iff_of_measurable sm).mp h)
  have h1f : ∫⁻ x, f x ∂μ ≠ 0 :=
    (lintegral_eq_zero_iff_of_measurable hf).not.mpr fun h =>
      h3s ((measure_eq_zero_iff_of_measurable sm).mp h)
  have h1s : μ s ≠ 0 := by
    intro h
    apply h1f
    simp only [h, zero_mul, lintegral_zero]
  have h2f : ∀ᵐ x ∂ν, f x ≠ 0 := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne'
  have h3f : ∀ᵐ x ∂ν, f x ≠ ∞ := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne
  have h3s : μ s ≠ ∞ := by
    intro h
    apply h3f
    simp only [h, measure_mul_right_null, lintegral_const]
  have h1μ : ∫⁻ x, f x ∂μ ≠ 0 :=
    (lintegral_eq_zero_iff_of_measurable hf).not.mpr fun h =>
      h1s ((measure_eq_zero_iff_of_measurable sm).mp h)
  have h2μ : ∫⁻ x, f x ∂μ ≠ ∞ :=
    (lintegral_eq_top_iff_of_measurable hf).not.mpr fun h =>
      h3s ((measure_eq_top_iff_of_measurable sm).mp h)
  have h3μ : μ s ≠ ∞ := by
    intro h
    apply h3f
    simp only [h, measure_mul_right_null, lintegral_const]
  have h1μ : ∀ᵐ x ∂μ, f x ≠ 0 := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne'
  have h2μ : ∀ᵐ x ∂μ, f x ≠ ∞ := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne
  have h3μ : ∀ᵐ x ∂μ, f x ≠ ∞ := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne
  have h1μ : ∫⁻ x, f x ∂μ ≠ 0 :=
    (lintegral_eq_zero_iff_of_measurable hf).not.mpr fun h =>
      h1s ((measure_eq_zero_iff_of_measurable sm).mp h)
  have h2μ : ∫⁻ x, f x ∂μ ≠ ∞ :=
    (lintegral_eq_top_iff_of_measurable hf).not.mpr fun h =>
      h3s ((measure_eq_top_iff_of_measurable sm).mp h)
  have h3μ : μ s ≠ ∞ := by
    intro h
    apply h3f
    simp only [h, measure_mul_right_null, lintegral_const]
  have h1μ : ∀ᵐ x ∂μ, f x ≠ 0 := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne'
  have h2μ : ∀ᵐ x ∂μ, f x ≠ ∞ := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne
  have h3μ : ∀ᵐ x ∂μ, f x ≠ ∞ := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne
  have h1μ : ∫⁻ x, f x ∂μ ≠ 0 :=
    (lintegral_eq_zero_iff_of_measurable hf).not.mpr fun h =>
      h1s ((measure_eq_zero_iff_of_measurable sm).mp h)
  have h2μ : ∫⁻ x, f x ∂μ ≠ ∞ :=
    (lintegral_eq_top_iff_of_measurable hf).not.mpr fun h =>
      h3s ((measure_eq_top_iff_of_measurable sm).mp h)
  have h3μ : μ s ≠ ∞ := by
    intro h
    apply h3f
    simp only [h, measure_mul_right_null, lintegral_const]
  have h1μ : ∀ᵐ x ∂μ, f x ≠ 0 := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne'
  have h2μ : ∀ᵐ x ∂μ, f x ≠ ∞ := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne
  have h3μ : ∀ᵐ x ∂μ, f x ≠ ∞ := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne
  have h1μ : ∫⁻ x, f x ∂μ ≠ 0 :=
    (lintegral_eq_zero_iff_of_measurable hf).not.mpr fun h =>
      h1s ((measure_eq_zero_iff_of_measurable sm).mp h)
  have h2μ : ∫⁻ x, f x ∂μ ≠ ∞ :=
    (lintegral_eq_top_iff_of_measurable hf).not.mpr fun h =>
      h3s ((measure_eq_top_iff_of_measurable sm).mp h)
  have h3μ : μ s ≠ ∞ := by
    intro h
    apply h3f
    simp only [h, measure_mul_right_null, lintegral_const]
  have h1μ : ∀ᵐ x ∂μ, f x ≠ 0 := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne'
  have h2μ : ∀ᵐ x ∂μ, f x ≠ ∞ := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne
  have h3μ : ∀ᵐ x ∂μ, f x ≠ ∞ := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne
  have h1μ : ∫⁻ x, f x ∂μ ≠ 0 :=
    (lintegral_eq_zero_iff_of_measurable hf).not.mpr fun h =>
      h1s ((measure_eq_zero_iff_of_measurable sm).mp h)
  have h2μ : ∫⁻ x, f x ∂μ ≠ ∞ :=
    (lintegral_eq_top_iff_of_measurable hf).not.mpr fun h =>
      h3s ((measure_eq_top_iff_of_measurable sm).mp h)
  have h3μ : μ s ≠ ∞ := by
    intro h
    apply h3f
    simp only [h, measure_mul_right_null, lintegral_const]
  have h1μ : ∀ᵐ x ∂μ, f x ≠ 0 := by
    filter_upwards [ae_lt_top' hf h3f] with x hx
    exact hx.ne'
  have h2μ : ∀ᵐ x ∂μ, f x ≠ ∞ := by
    filter

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/CircleIntegral.lean - 2024-09-09 00:59:08.284153.
---121/200---
For theorem circleIntegrable_sub_zpow_iff in Mathlib/MeasureTheory/Integral/CircleIntegral.lean:
theorem circleIntegrable_sub_zpow_iff {c w : ℂ} {R : ℝ} {n : ℤ} :
    CircleIntegrable (fun z => (z - w) ^ n) c R ↔ R = 0 ∨ 0 ≤ n ∨ w ∉ sphere c |R| 


Original valid proof:
:= by
  constructor
  · intro h; contrapose! h; rcases h with ⟨hR, hn, hw⟩
    simp only [circleIntegrable_iff R, deriv_circleMap]
    rw [← image_circleMap_Ioc] at hw; rcases hw with ⟨θ, hθ, rfl⟩
    replace hθ : θ ∈ [[0, 2 * π]] := Icc_subset_uIcc (Ioc_subset_Icc_self hθ)
    refine not_intervalIntegrable_of_sub_inv_isBigO_punctured ?_ Real.two_pi_pos.ne hθ
    set f : ℝ → ℂ := fun θ' => circleMap c R θ' - circleMap c R θ
    have : ∀ᶠ θ' in 𝓝[≠] θ, f θ' ∈ ball (0 : ℂ) 1 \ {0} := by
      suffices ∀ᶠ z in 𝓝[≠] circleMap c R θ, z - circleMap c R θ ∈ ball (0 : ℂ) 1 \ {0} from
        ((differentiable_circleMap c R θ).hasDerivAt.tendsto_punctured_nhds
          (deriv_circleMap_ne_zero hR)).eventually this
      filter_upwards [self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds (ball_mem_nhds _ zero_lt_one)]
      simp_all [dist_eq, sub_eq_zero]
    refine (((hasDerivAt_circleMap c R θ).isBigO_sub.mono inf_le_left).inv_rev
      (this.mono fun θ' h₁ h₂ => absurd h₂ h₁.2)).trans ?_
    refine IsBigO.of_bound |R|⁻¹ (this.mono fun θ' hθ' => ?_)
    set x := abs (f θ')
    suffices x⁻¹ ≤ x ^ n by
      simpa only [inv_mul_cancel_left₀, abs_eq_zero.not.2 hR, norm_eq_abs, map_inv₀,
        Algebra.id.smul_eq_mul, map_mul, abs_circleMap_zero, abs_I, mul_one, abs_zpow, Ne,
        not_false_iff] using this
    have : x ∈ Ioo (0 : ℝ) 1 := by simpa [x, and_comm] using hθ'
    rw [← zpow_neg_one]
    refine (zpow_strictAnti this.1 this.2).le_iff_le.2 (Int.lt_add_one_iff.1 ?_); exact hn
  · rintro (rfl | H)
    exacts [circleIntegrable_zero_radius,
      ((continuousOn_id.sub continuousOn_const).zpow₀ _ fun z hz =>
        H.symm.imp_left fun (hw : w ∉ sphere c |R|) =>
          sub_ne_zero.2 <| ne_of_mem_of_not_mem hz hw).circleIntegrable']


Verifying proof (Commit d16c7a879e758dc3aee434d847d69bfbaf9f30f0):
∨ |R| < n.natAbs := by
  rcases eq_or_ne R 0 with (rfl | hR0); · simp only [circleIntegrable_const, true_or_iff, eq_self_iff_true,
      true_and_iff, or_true_iff]
  rcases eq_or_ne w c with (rfl | hw); · simp only [sub_self, zero_zpow, Ne.def, not_false_iff,
      false_or_iff, true_or_iff, or_false_iff, circleIntegrable_const, zero_le_one]
  rcases le_or_lt 0 n with (hn | hn); · simp only [or_true_iff, true_or_iff]
  rcases eq_or_ne |R| 0 with (rfl | hR0'); · simp only [lt_self_iff_false, false_or_iff,
      or_false_iff, circleIntegrable_const]
  rcases eq_or_lt_of_le (Int.natAbs_pos.mpr hn) with (rfl | hn'); · simp only [lt_irrefl,
    false_or_iff, false_and_iff, or_false_iff, circleIntegrable_const]
  simp only [or_iff_not_imp_left, false_or_iff, hR0, hR0', hn, hn', hc, hc', hw, hw',
    hc'', hc''', false_and_iff, not_false_iff, true_and_iff, true_or_iff, or_true_iff,
    circleIntegrable_sub_inv_iff, abs_pos, ne_eq, abs_ne_zero]

Repaired Proof:
theorem circleIntegrable_sub_zpow_iff {c w : ℂ} {R : ℝ} {n : ℤ} :
    CircleIntegrable (fun z => (z - w) ^ n) c R ↔ R = 0 ∨ 0 ≤ n ∨ w ∉ sphere c |R| ∨ |R| < n.natAbs := by
  rcases eq_or_ne R 0 with (rfl | hR0); · simp only [circleIntegrable_const, true_or_iff, eq_self_iff_true,
      true_and_iff, or_true_iff]
  rcases eq_or_ne w c with (rfl | hw); · simp only [sub_self, zero_zpow, Ne, not_false_iff,
      false_or_iff, true_or_iff, or_false_iff, circleIntegrable_const, zero_le_one]
  rcases le_or_lt 0 n with (hn | hn); · simp only [or_true_iff, true_or_iff]
  rcases eq_or_ne |R| 0 with (rfl | hR0'); · simp only [lt_self_iff_false, false_or_iff,
      or_false_iff, circleIntegrable_const]
  rcases eq_or_lt_of_le (Int.natAbs_pos.mpr hn) with (rfl | hn'); · simp only [lt_irrefl,
    false_or_iff, false_and_iff, or_false_iff, circleIntegrable_const]
  simp only [or_iff_not_imp_left, false_or_iff, hR0, hR0', hn, hn', hc, hc', hw, hw',
    hc'', hc''', false_and_iff, not_false_iff, true_and_iff, true_or_iff, or_true_iff,
    circleIntegrable_sub_inv_iff, abs_pos, ne_eq, abs_ne_zero]

Repaired Proof:
theorem circleIntegrable_sub_zpow_iff {c w : ℂ} {R : ℝ} {n : ℤ} :
    CircleIntegrable (fun z => (z - w) ^ n) c R ↔ R = 0 ∨ 0 ≤ n ∨ w ∉ sphere c |R| ∨ |R| < n.natAbs := by
  rcases eq_or_ne R 0 with (rfl | hR0); · simp only [circleIntegrable_const, true_or_iff, eq_self_iff_true,
      true_and_iff, or_true_iff]
  rcases eq_or_ne w c with (rfl | hw); · simp only [sub_self, zero_zpow, Ne, not_false_iff,
      false_or_iff, true_or_iff, or_false_iff, circleIntegrable_const, zero_le_one]
  rcases le_or_lt 0 n with (hn | hn); · simp only [or_true_iff, true_or_iff]
  rcases eq_or_ne |R| 0 with (rfl | hR0'); · simp only [lt_self_iff_false, false_or_iff,
      or_false_iff, circleIntegrable_const]
  rcases eq_or_lt_of_le (Int.natAbs_pos.mpr hn) with (rfl | hn'); · simp only [lt_irrefl,
    false_or_iff, false_and_iff, or_false_iff, circleIntegrable_const]
  simp only [or_iff_not_imp_left, false_or_iff, hR0, hR0', hn, hn', hc, hc', hw, hw',
    hc'', hc''', false_and_iff, not_false_iff, true_and_iff, true_or_iff, or_true_iff,
    circleIntegrable_sub_inv_iff, abs_pos, ne_eq, abs_ne_zero]

Repaired Proof:
theorem circleIntegrable_sub_zpow_iff {c w : ℂ} {R : ℝ} {n : ℤ} :
    CircleIntegrable (fun z => (z - w) ^ n) c R ↔ R = 0 ∨ 0 ≤ n ∨ w ∉ sphere c |R| ∨ |R| < n.natAbs := by
  rcases eq_or_ne R 0 with (rfl | hR0); · simp only [circleIntegrable_const, true_or_iff, eq_self_iff_true,
      true_and_iff, or_true_iff]
  rcases eq_or_ne w c with (rfl | hw); · simp only [sub_self, zero_zpow, Ne, not_false_iff,
      false_or_iff, true_or_iff, or_false_iff, circleIntegrable_const, zero_le_one]
  rcases le_or_lt 0 n with (hn | hn); · simp only [or_true_iff, true_or_iff]
  rcases eq_or_ne |R| 0 with (rfl | hR0'); · simp only [lt_self_iff_false, false_or_iff,
      or_false_iff, circleIntegrable_const]
  rcases eq_or_lt_of_le (Int.natAbs_pos.mpr hn) with (rfl | hn'); · simp only [lt_irrefl,
    false_or_iff, false_and_iff, or_false_iff, circleIntegrable_const]
  simp only [or_iff_not_imp_left, false_or_iff, hR0, hR0', hn, hn', hc, hc', hw, hw',
    hc'', hc''', false_and_iff, not_false_iff, true_and_iff, true_or_iff, or_true_iff,
    circleIntegrable_sub_inv_iff, abs_pos, ne_eq, abs_ne_zero]

Repaired Proof:
theorem circleIntegrable_sub_zpow_iff {c w : ℂ} {R : ℝ} {n : ℤ} :
    CircleIntegrable (fun z => (z - w) ^ n) c R ↔ R = 0 ∨ 0 ≤ n ∨ w ∉ sphere c |R| ∨ |R| < n.natAbs := by
  rcases eq_or_ne R 0 with (rfl | hR0); · simp only [circleIntegrable_const, true_or_iff, eq_self_iff_true,
      true_and_iff, or_true_iff]
  rcases eq_or_ne w c with (rfl | hw); · simp only [sub_self, zero_zpow, Ne, not_false_iff,
      false_or_iff, true_or_iff, or_false_iff, circleIntegrable_const, zero_le_one]
 

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/DivergenceTheorem.lean - 2024-09-09 00:59:32.046585.
---122/200---
For theorem MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable_aux₁ in Mathlib/MeasureTheory/Integral/DivergenceTheorem.lean:
theorem integral_divergence_of_hasFDerivWithinAt_off_countable_aux₁ (I : Box (Fin (n + 1)))
    (f : ℝⁿ⁺¹ → Eⁿ⁺¹)
    (f' : ℝⁿ⁺¹ → ℝⁿ⁺¹ →L[ℝ] Eⁿ⁺¹) (s : Set ℝⁿ⁺¹)
    (hs : s.Countable) (Hc : ContinuousOn f (Box.Icc I))
    (Hd : ∀ x ∈ (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x)
    (Hi : IntegrableOn (fun x => ∑ i, f' x (e i) i) (Box.Icc I)) :
    (∫ x in Box.Icc I, ∑ i, f' x (e i) i) =
      ∑ i : Fin (n + 1),
        ((∫ x in Box.Icc (I.face i), f (i.insertNth (I.upper i) x) i) -
          ∫ x in Box.Icc (I.face i), f (i.insertNth (I.lower i) x) i) 


Original valid proof:
:= by
  simp only [← setIntegral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral ⊥ rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s ∩ Box.Icc I)
      (hs.mono inter_subset_left) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ ⟨hx.1, fun h => hx.2 ⟨h, hx.1⟩⟩
  rw [continuousOn_pi] at Hc
  refine (A.unique B).trans (sum_congr rfl fun i _ => ?_)
  refine congr_arg₂ Sub.sub ?_ ?_
  · have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (μ := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ⊥ rfl).integral_eq
  · have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (μ := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ⊥ rfl).integral_eq


Verifying proof (Commit 3cb2bdef8481160ee4f3f3a94fca1f5824c2798a):
↔
    (∀ x ∈ s ∩ Box.Icc I, ∀ y ∈ Box.Icc I, f x = f y) ∧
      ∀ x ∈ (Box.Icc I) \ s, ∃ g : ℝⁿ → Eⁿ,
        (∀ y ∈ (Box.Icc I).face i, g y =ᵐ[volume.restrict (Box.Icc (I.face i))] f (i.insertNth (I.upper i) y)) ∧
          IntervalIntegrable (fun y => f (i.insertNth (I.lower i) y) i) volume (I.lower i) (I.upper i) ∧
            IntervalIntegrable (fun y => g y i) volume (I.lower i) (I.upper i) ∧
              (∫ x in I.face i, g x i) =
                ∫ x in I.face i, f (i.insertNth (I.lower i) x) i := by
  have Hc' : ∀ x ∈ s ∩ Box.Icc I, ContinuousWithinAt f (Box.Icc I) x := fun x hx =>
    Hc x hx.2
  have Hd' : ∀ x ∈ (Box.Icc I) \ s,
      HasFDerivWithinAt f (f' x) (Box.Icc I) x ∧
        Tendsto (fun y => ‖f' x y - f' x 0‖) (𝓝[s ∩ Box.Icc I] x) (𝓝 0) := by
    intro x hx
    have A : ∀ᶠ y in 𝓝[s ∩ Box.Icc I] x, f y = f x := by
      filter_upwards [self_mem_nhdsWithin] with y hy using Hc' y ⟨hy.1, hy.2.1⟩
    have B : ∀ᶠ y in 𝓝[s ∩ Box.Icc I] x, f' x y = f' x 0 := by
      filter_upwards [A] with y hy
      have : ∀ᶠ z in 𝓝[s ∩ Box.Icc I] x, f z = f x := by
        filter_upwards [self_mem_nhdsWithin] with z hz using Hc' z ⟨hz.1, hz.2.1⟩
      apply hasFDerivAt_unique (Hd x hx.1).hasFDerivWithinAt
      have : HasFDerivWithinAt (fun _ => f x) (0 : ℝⁿ⁺¹ →L[ℝ] Eⁿ⁺¹) (𝓝[s ∩ Box.Icc I] x) :=
        (hasFDerivAt_const _ _).hasFDerivWithinAt.congr_of_eventuallyEq (this.mono fun y hy => hy.symm)
          (eventually_of_mem self_mem_nhdsWithin fun y hy => hy.2.2)
      exact this.congr_of_eventuallyEq (A.mono fun y hy => hy.symm) (eventually_of_mem self_mem_nhdsWithin
        fun y hy => hy.2.2)
    exact ⟨Hd x hx.1, (tendsto_zero_iff_norm_tendsto_zero _).2 (tendsto_of_tendsto_of_tendsto_of_le_of_le'
      (tendsto_const_nhds.mono_left nhdsWithin_le_nhds) (tendsto_const_nhds.mono_left nhdsWithin_le_nhds)
      (eventually_of_forall fun _ => (norm_nonneg _).trans (norm_sub_le _ _)) B)⟩
  have : ∀ x ∈ (Box.Icc I) \ s, ∃ g : ℝⁿ → Eⁿ,
      (∀ y ∈ (Box.Icc I).face i, g y =ᵐ[volume.restrict (Box.Icc (I.face i))] f (i.insertNth (I.upper i) y)) ∧
        IntervalIntegrable (fun y => f (i.insertNth (I.lower i) y) i) volume (I.lower i) (I.upper i) ∧
          IntervalIntegrable (fun y => g y i) volume (I.lower i) (I.upper i) ∧
            (∫ x in I.face i, g x i) = ∫ x in I.face i, f (i.insertNth (I.lower i) x) i := by
    intro x hx
    rcases Hd' x hx with ⟨Hd'x, Ht⟩
    have Hc'x : ∀ᶠ y in 𝓝[s ∩ Box.Icc I] x, ContinuousWithinAt f (insert i.insertNth (I.upper i) ⁻¹'
      {y}) i.insertNth (I.upper i) := by
      filter_upwards [self_mem_nhdsWithin] with y hy using Hc' y ⟨hy.1, hy.2.1⟩
    rcases exists_next_tag_boundary_of_hasFDerivWithinAt_off_countable_aux₁_achievable
      (fun y => f' x y) (fun y => f' x 0) (fun y => f y i) (fun y => f x i) I i hx.1
      (fun y => (Hd'x.differentiableWithinAt y).hasFDerivWithinAt) Ht
        (fun y => (Hc'x.and self_mem_nhdsWithin).mono fun z hz => hz.2)
        (Hi.mono <| Box.le_iff_Icc.1 I.le_face_self i) with ⟨g, hg, hg'⟩
    refine' ⟨g, fun y hy => _, hg' i, hg' i, _⟩
    · have : ∀ᶠ z in 𝓝[s ∩ Box.Icc I] x, g z i =ᵐ[volume.restrict (Box.Icc (I.face i))] f z i := by
        filter_upwards [self_mem_nhdsWithin] with z hz
        exact hg z ⟨hz.1, hy.2.1⟩
      exact (ae_restrict_iff' (Box.Icc (I.face i)).measurableSet_of_countable_face.countable_toSet).2
        (this.mono fun y hy => hy.symm)
    · have : ∀ᶠ z in 𝓝[s ∩ Box.Icc I] x, g z i =ᵐ[volume.restrict (I.face i).Icc]
        f (i.insertNth (I.lower i) z) i := by
        filter_upwards [self_mem_nhdsWithin] with z hz
        exact hg z ⟨hz.1, hy.2.1⟩
      exact (ae_restrict_iff' (I.face i).Icc.measurableSet_of_countable_face.countable_toSet).2
        (this.mono fun y hy => hy.symm)
  refine' ⟨fun H => ⟨fun x hx => ⟨⟨fun y hy => _⟩⟩, fun x hx => _, fun x hx => _⟩, fun H => _⟩
  · have : ∀ᶠ z in 𝓝[s ∩ Box.Icc I] x, g z i =ᵐ[volume.restrict (Box.Icc (I.face i))] f z i := by
      filter_upwards [self_mem_nhdsWithin] with z hz
      exact hg.2.2 z ⟨hz.1, hy.2.1⟩
    exact (ae_restrict_iff' (Box.Icc (I.face i)).measurableSet_of_countable_face.countable_toSet).2
      (this.mono fun y hy => hy.symm)
  · rcases hg x hx with ⟨g, hg, hg'⟩
    exact ⟨g, hg, hg'⟩
  · rcases hg x hx with ⟨g, hg, hg'⟩
    exact ⟨g, hg, hg'⟩
  have : ∀ x ∈ s ∩ Box.Icc I, ∀ y ∈ Box.Icc I, f x = f y := by
    intro x hx y

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/FundThmCalculus.lean - 2024-09-09 00:59:51.176430.
---123/200---
For theorem intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le_Ico in Mathlib/MeasureTheory/Integral/FundThmCalculus.lean:
theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ≤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ∀ x ∈ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (φint : IntegrableOn φ (Icc a b)) (hφg : ∀ x ∈ Ico a b, g' x ≤ φ x) :
    g b - g a ≤ ∫ y in a..b, φ y 


Original valid proof:
:= by
  refine le_of_forall_pos_le_add fun ε εpos => ?_
  rcases exists_lt_lowerSemicontinuous_integral_lt φ φint εpos with
    ⟨G', f_lt_G', G'cont, G'int, G'lt_top, hG'⟩
  set s := {t | g t - g a ≤ ∫ u in a..t, (G' u).toReal} ∩ Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ∫ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [← uIcc_of_le hab] at G'int hcont ⊢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ⊆ {t | g t - g a ≤ ∫ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ⟨y, g'_lt_y', y_lt_G'⟩ : ∃ y : ℝ, (g' t : EReal) < y ∧ (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hφg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ∀ᶠ u in 𝓝[>] t, (u - t) * y ≤ ∫ w in t..u, (G' w).toReal := by
      have B : ∀ᶠ u in 𝓝 t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ⟨m, M, ⟨hm, hM⟩, H⟩
      have : Ioo t (min M b) ∈ 𝓝[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ⊆ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ∫ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ≤ ∫ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ← integral_Icc_eq_integral_Ioc]
          apply setIntegral_mono_ae_restrict
          · simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          · exact IntegrableOn.mono_set G'int I
          · have C1 : ∀ᵐ x : ℝ ∂volume.restrict (Icc t u), G' x < ∞ :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ∀ᵐ x : ℝ ∂volume.restrict (Icc t u), x ∈ Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ∈ Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ∀ᶠ u in 𝓝[>] t, g u - g t ≤ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ⟨ht.2.1, ht.2.2⟩).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [← smul_eq_mul, sub_smul_slope] at this
    have I3 : ∀ᶠ u in 𝓝[>] t, g u - g t ≤ ∫ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ∀ᶠ u in 𝓝[>] t, u ∈ Ioc t (min v b) := by
      refine mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ⟨min v b, ?_, Subset.rfl⟩
      simp only [lt_min_iff, mem_Ioi]
      exact ⟨t_lt_v, ht.2.2⟩
    rcases (I3.and I4).exists with ⟨x, hx, h'x⟩
    refine ⟨x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x⟩
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ≤ (∫ w in a..t, (G' w).toReal) + ∫ w in t..x, (G' w).toReal := add_le_add ht.1 hx
      _ = ∫ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        · rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        · rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ≤ ∫ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ≤ (∫ y in a..b, φ y) + ε := by
      convert hG'.le <;>
        · rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]


Verifying proof (Commit 9d12b609274b44fc79ae79f9347cf8a3782b6a95):
∂μ := by
  let G := φ - fun x => deriv g x
  have hsub : g b - g a ≤ ∫ y in a..b, G y ∂μ := by
    refine' sub_le_integral_of_hasDeriv_right_of_le_Ico_Ioc hab hcont _
      (fun x hx => (hderiv x hx).sub_const _) φint _
    · simp only [G]
      intro x hx
      have hgφ : HasDerivWithinAt (fun x => g x - g a) (φ x) (Ioi x) x := by
        simpa only [sub_zero] using (hderiv x hx).const_sub _
      simpa only [sub_sub_cancel] using hgφ.sub (hasDerivWithinAt_deriv_right_of_mem_nhds
        (hderiv x hx) (Ioi_mem_nhds hx.1))
    · simp only [G]
      exact fun x hx => hφg x hx
  have φG_int : IntegrableOn (G ∘ (toDual ∘ toRealDual)) (Icc (toRealDual a) <| toRealDual b) := by
    simpa only [G] using φint.sub (integrableOn_deriv_of_nonneg' hcont hderiv)
  have φG_le : ∀ x ∈ Ico (toRealDual a) (toRealDual b), 0 ≤ G x := by
    intro x hx
    simpa only [G] using sub_nonneg.2 (hφg x hx)
  have : ∫ y in a..b, G y ∂μ = ∫ _ in toRealDual a..toRealDual b, G ∘ (toDual ∘ toRealDual) _ := by
    simp only [G, integral_comp_smul_deriv' hcont hderiv, Function.comp.assoc]
  rw [this]
  simpa only [G, neg_sub] using integral_nonneg_of_ae_restrict φG_int.restrict φG_le

Repaired Proof:
theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ≤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ∀ x ∈ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (φint : IntegrableOn φ (Icc a b)) (hφg : ∀ x ∈ Ico a b, g' x ≤ φ x) :
    g b - g a ≤ ∫ y in a..b, φ y ∂μ := by
  let G := φ - fun x => deriv g x
  have hsub : g b - g a ≤ ∫ y in a..b, G y ∂μ := by
    refine sub_le_integral_of_hasDeriv_right_of_le_Ico_Ioc hab hcont ?_
      (fun x hx => (hderiv x hx).const_sub _) φint ?_
    · simp only [G]
      intro x hx
      have hgφ : HasDerivWithinAt (fun x => g x - g a) (φ x) (Ioi x) x := by
        simpa only [sub_zero] using (hderiv x hx).const_sub _
      simpa only [sub_sub_cancel] using hgφ.sub (hasDerivWithinAt_deriv_right_of_mem_nhds
        (hderiv x hx) (Ioi_mem_nhds hx.1))
    · simp only [G]
      exact fun x hx => hφg x hx
  have φG_int : IntegrableOn (G ∘ (toDual ∘ toRealDual)) (Icc (toRealDual a) <| toRealDual b) := by
    simpa only [G] using φint.sub (integrableOn_deriv_of_nonneg' hcont hderiv)
  have φG_le : ∀ x ∈ Ico (toRealDual a) (toRealDual b), 0 ≤ G x := by
    intro x hx
    simpa only [G] using sub_nonneg.2 (hφg x hx)
  have : ∫ y in a..b, G y ∂μ = ∫ _ in toRealDual a..toRealDual b, G ∘ (toDual ∘ toRealDual) _ := by
    simp only [G, integral_comp_smul_deriv' hcont hderiv, Function.comp.assoc]
  rw [this]
  simpa only [G, neg_sub] using integral_nonneg_of_ae_restrict φG_int.restrict φG_le

Repaired Proof:
theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ≤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ∀ x ∈ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (φint : IntegrableOn φ (Icc a b)) (hφg : ∀ x ∈ Ico a b, g' x ≤ φ x) :
    g b - g a ≤ ∫ y in a..b, φ y ∂μ := by
  let G := φ - fun x => deriv g x
  have hsub : g b - g a ≤ ∫ y in a..b, G y ∂μ := by
    refine sub_le_integral_of_hasDeriv_right_of_le_Ico_Ioc hab hcont ?_
      (fun x hx => (hderiv x hx).const_sub _) φint ?_
    · simp only [G]
      intro x hx
      have hgφ : HasDerivWithinAt (fun x => g x - g a) (φ x) (Ioi x) x := by
        simpa only [sub_zero] using (hderiv x hx).const_sub _
      simpa only [sub_sub_cancel] using hgφ.sub (hasDerivWithinAt_deriv_right_of_mem_nhds
        (hderiv x hx) (Ioi_mem_nhds hx.1))
    · simp only [G]
      exact fun x hx => hφg x hx
  have φG_int : IntegrableOn (G ∘ (toDual ∘ toRealDual)) (Icc (toRealDual a) <| toRealDual b) := by
    simpa only [G] using φint.sub (integrableOn_deriv_of_nonneg' hcont hderiv)
  have φG_le : ∀ x ∈ Ico (toRealDual a) (toRealDual b), 0 ≤ G x := by
    intro x hx
    simpa only [G] using sub_nonneg.2 (hφg x hx)
  have : ∫ y in a..b, G y ∂μ = ∫ _ in toRealDual a..toRealDual b, G ∘ (toDual ∘ toRealDual) _ := by
    simp only [G, integral_comp_smul_deriv' hcont hderiv, Function.comp.assoc]
  rw [this]
  simpa only [G, neg_sub] using integral_nonneg_of_ae_restrict φG_int.restrict φG_le

Repaired Proof:
theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ≤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ∀ x ∈ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (φint : IntegrableOn φ (Icc a b)) (hφg : ∀ x ∈ Ico a b, g' x ≤ φ x) :
    g b - g a ≤ ∫ y in a..b, φ y ∂μ := by
  let G := φ - fun x => deriv g x
  have hsub : g b - g a ≤ ∫ y in a..b, G y ∂μ := by
    refine sub_le_integral_of_hasDeriv_right_of_le_Ico_Ioc hab hcont ?_
      (fun x hx => (hderiv x hx).const_sub _) φint ?_
    · simp only [G]
      intro x hx
      have hgφ : HasDerivWithinAt (fun x => g x - g a) (φ x) (Ioi x) x := by
        simpa only [sub_zero] using (hderiv x hx).const_sub _
      simpa only [sub_sub_cancel] using hgφ.sub (hasDerivWithinAt_deriv_right_of_mem_nh

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/PeakFunction.lean - 2024-09-09 01:00:17.823341.
---124/200---
For theorem tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto in Mathlib/MeasureTheory/Integral/PeakFunction.lean:
theorem tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hts : t ⊆ s) (h'ts : t ∈ 𝓝[s] x₀)
    (hnφ : ∀ᶠ i in l, ∀ x ∈ s, 0 ≤ φ i x)
    (hlφ : ∀ u : Set α, IsOpen u → x₀ ∈ u → TendstoUniformlyOn φ 0 l (s \ u))
    (hiφ : Tendsto (fun i ↦ ∫ x in t, φ i x ∂μ) l (𝓝 1))
    (h'iφ : ∀ᶠ i in l, AEStronglyMeasurable (φ i) (μ.restrict s))
    (hmg : IntegrableOn g s μ) (hcg : Tendsto g (𝓝[s] x₀) (𝓝 0)) :
    Tendsto (fun i : ι => ∫ x in s, φ i x • g x ∂μ) l (𝓝 0) 


Original valid proof:
:= by
  refine Metric.tendsto_nhds.2 fun ε εpos => ?_
  obtain ⟨δ, hδ, δpos, δone⟩ : ∃ δ, (δ * ∫ x in s, ‖g x‖ ∂μ) + 2 * δ < ε ∧ 0 < δ ∧ δ < 1:= by
    have A :
      Tendsto (fun δ => (δ * ∫ x in s, ‖g x‖ ∂μ) + 2 * δ) (𝓝[>] 0)
        (𝓝 ((0 * ∫ x in s, ‖g x‖ ∂μ) + 2 * 0)) := by
      apply Tendsto.mono_left _ nhdsWithin_le_nhds
      exact (tendsto_id.mul tendsto_const_nhds).add (tendsto_id.const_mul _)
    rw [zero_mul, zero_add, mul_zero] at A
    have : Ioo (0 : ℝ) 1 ∈ 𝓝[>] 0 := Ioo_mem_nhdsWithin_Ioi ⟨le_rfl, zero_lt_one⟩
    rcases (((tendsto_order.1 A).2 ε εpos).and this).exists with ⟨δ, hδ, h'δ⟩
    exact ⟨δ, hδ, h'δ.1, h'δ.2⟩
  suffices ∀ᶠ i in l, ‖∫ x in s, φ i x • g x ∂μ‖ ≤ (δ * ∫ x in s, ‖g x‖ ∂μ) + 2 * δ by
    filter_upwards [this] with i hi
    simp only [dist_zero_right]
    exact hi.trans_lt hδ
  obtain ⟨u, u_open, x₀u, ut, hu⟩ :
      ∃ u, IsOpen u ∧ x₀ ∈ u ∧ s ∩ u ⊆ t ∧ ∀ x ∈ u ∩ s, g x ∈ ball 0 δ := by
    rcases mem_nhdsWithin.1 (Filter.inter_mem h'ts (hcg (ball_mem_nhds _ δpos)))
      with ⟨u, u_open, x₀u, hu⟩
    refine ⟨u, u_open, x₀u, ?_, hu.trans inter_subset_right⟩
    rw [inter_comm]
    exact hu.trans inter_subset_left
  filter_upwards [tendstoUniformlyOn_iff.1 (hlφ u u_open x₀u) δ δpos,
    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiφ)).2 δ δpos, hnφ,
    integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts hlφ hiφ h'iφ hmg hcg]
    with i hi h'i hφpos h''i
  have I : IntegrableOn (φ i) t μ := by
    apply Integrable.of_integral_ne_zero (fun h ↦ ?_)
    simp [h] at h'i
    linarith
  have B : ‖∫ x in s ∩ u, φ i x • g x ∂μ‖ ≤ 2 * δ :=
    calc
      ‖∫ x in s ∩ u, φ i x • g x ∂μ‖ ≤ ∫ x in s ∩ u, ‖φ i x • g x‖ ∂μ :=
        norm_integral_le_integral_norm _
      _ ≤ ∫ x in s ∩ u, ‖φ i x‖ * δ ∂μ := by
        refine setIntegral_mono_on ?_ ?_ (hs.inter u_open.measurableSet) fun x hx => ?_
        · exact IntegrableOn.mono_set h''i.norm inter_subset_left
        · exact IntegrableOn.mono_set (I.norm.mul_const _) ut
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
        rw [inter_comm] at hu
        exact (mem_ball_zero_iff.1 (hu x hx)).le
      _ ≤ ∫ x in t, ‖φ i x‖ * δ ∂μ := by
        apply setIntegral_mono_set
        · exact I.norm.mul_const _
        · exact eventually_of_forall fun x => mul_nonneg (norm_nonneg _) δpos.le
        · exact eventually_of_forall ut
      _ = ∫ x in t, φ i x * δ ∂μ := by
        apply setIntegral_congr ht fun x hx => ?_
        rw [Real.norm_of_nonneg (hφpos _ (hts hx))]
      _ = (∫ x in t, φ i x ∂μ) * δ := by rw [integral_mul_right]
      _ ≤ 2 * δ := by gcongr; linarith [(le_abs_self _).trans h'i.le]
  have C : ‖∫ x in s \ u, φ i x • g x ∂μ‖ ≤ δ * ∫ x in s, ‖g x‖ ∂μ :=
    calc
      ‖∫ x in s \ u, φ i x • g x ∂μ‖ ≤ ∫ x in s \ u, ‖φ i x • g x‖ ∂μ :=
        norm_integral_le_integral_norm _
      _ ≤ ∫ x in s \ u, δ * ‖g x‖ ∂μ := by
        refine setIntegral_mono_on ?_ ?_ (hs.diff u_open.measurableSet) fun x hx => ?_
        · exact IntegrableOn.mono_set h''i.norm diff_subset
        · exact IntegrableOn.mono_set (hmg.norm.const_mul _) diff_subset
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le
      _ ≤ δ * ∫ x in s, ‖g x‖ ∂μ := by
        rw [integral_mul_left]
        apply mul_le_mul_of_nonneg_left (setIntegral_mono_set hmg.norm _ _) δpos.le
        · filter_upwards with x using norm_nonneg _
        · filter_upwards using diff_subset (s := s) (t := u)
  calc
    ‖∫ x in s, φ i x • g x ∂μ‖ =
      ‖(∫ x in s \ u, φ i x • g x ∂μ) + ∫ x in s ∩ u, φ i x • g x ∂μ‖ := by
      conv_lhs => rw [← diff_union_inter s u]
      rw [integral_union disjoint_sdiff_inter (hs.inter u_open.measurableSet)
          (h''i.mono_set diff_subset) (h''i.mono_set inter_subset_left)]
    _ ≤ ‖∫ x in s \ u, φ i x • g x ∂μ‖ + ‖∫ x in s ∩ u, φ i x • g x ∂μ‖ := norm_add_le _ _
    _ ≤ (δ * ∫ x in s, ‖g x‖ ∂μ) + 2 * δ := add_le_add C B


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
∧
      Tendsto (fun i : ι => ∫ x in t, φ i x • g x ∂μ) l (𝓝 0) := by
  have h'iφ' : ∀ᶠ i in l, AEStronglyMeasurable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul (hg.aestronglyMeasurable.restrict)).congr (fun x ↦ (smul_eq_mul _ _).symm)
  have h'iφ'' : ∀ᶠ i in l, AEStronglyMeasurable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul (hg.aestronglyMeasurable.restrict)).congr (fun x ↦ (smul_eq_mul _ _).symm)
  have h'iφ''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ'''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ'''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ'''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ'''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ'''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ'''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ''''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ'''''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ''''''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ'''''''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ''''''''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ'''''''''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ''''''''''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ'''''''''''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ''''''''''''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict s) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeasurable).integrable_norm_toNNReal
  have h'iφ'''''''''''''''''''''''' : ∀ᶠ i in l, Integrable (fun x ↦ φ i x • g x) (μ.restrict t) := by
    filter_upwards [h'iφ] with i hi
    exact (hi.smul hmg.aestronglyMeas

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean - 2024-09-09 01:00:40.769805.
---125/200---
For theorem MeasureTheory.exists_le_lowerSemicontinuous_lintegral_ge in Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean:
theorem exists_le_lowerSemicontinuous_lintegral_ge (f : α → ℝ≥0∞) (hf : Measurable f) {ε : ℝ≥0∞}
    (εpos : ε ≠ 0) :
    ∃ g : α → ℝ≥0∞,
      (∀ x, f x ≤ g x) ∧ LowerSemicontinuous g ∧ (∫⁻ x, g x ∂μ) ≤ (∫⁻ x, f x ∂μ) + ε 


Original valid proof:
:= by
  rcases ENNReal.exists_pos_sum_of_countable' εpos ℕ with ⟨δ, δpos, hδ⟩
  have :
    ∀ n,
      ∃ g : α → ℝ≥0,
        (∀ x, SimpleFunc.eapproxDiff f n x ≤ g x) ∧
          LowerSemicontinuous g ∧
            (∫⁻ x, g x ∂μ) ≤ (∫⁻ x, SimpleFunc.eapproxDiff f n x ∂μ) + δ n :=
    fun n =>
    SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge μ (SimpleFunc.eapproxDiff f n)
      (δpos n).ne'
  choose g f_le_g gcont hg using this
  refine ⟨fun x => ∑' n, g n x, fun x => ?_, ?_, ?_⟩
  · rw [← SimpleFunc.tsum_eapproxDiff f hf]
    exact ENNReal.tsum_le_tsum fun n => ENNReal.coe_le_coe.2 (f_le_g n x)
  · refine lowerSemicontinuous_tsum fun n => ?_
    exact
      ENNReal.continuous_coe.comp_lowerSemicontinuous (gcont n) fun x y hxy =>
        ENNReal.coe_le_coe.2 hxy
  · calc
      ∫⁻ x, ∑' n : ℕ, g n x ∂μ = ∑' n, ∫⁻ x, g n x ∂μ := by
        rw [lintegral_tsum fun n => (gcont n).measurable.coe_nnreal_ennreal.aemeasurable]
      _ ≤ ∑' n, ((∫⁻ x, SimpleFunc.eapproxDiff f n x ∂μ) + δ n) := ENNReal.tsum_le_tsum hg
      _ = ∑' n, ∫⁻ x, SimpleFunc.eapproxDiff f n x ∂μ + ∑' n, δ n := ENNReal.tsum_add
      _ ≤ (∫⁻ x : α, f x ∂μ) + ε := by
        refine add_le_add ?_ hδ.le
        rw [← lintegral_tsum]
        · simp_rw [SimpleFunc.tsum_eapproxDiff f hf, le_refl]
        · intro n; exact (SimpleFunc.measurable _).coe_nnreal_ennreal.aemeasurable


Verifying proof (Commit 2c23e43ba179a9dd2928e06c32f043d20e9798c8):
∧
        (∫⁻ x, g x ∂μ) ≠ ∞ := by
  have :
    (∫⁻ x, f x ∂μ) + ε / 2 ∈
      closure (Set.range fun g : { g : α → ℝ≥0∞ // Measurable g ∧ ∀ x, f x ≤ g x ∧ g x < ∞ } =>
        (∫⁻ x, g x ∂μ) :
      Set (ℝ≥0∞)) := by
    refine mem_closure_of_tendsto (hf.lintegral.add (measurable_const.lintegral.div_const _).aestronglyMeasurable) ?_
    rw [eventually_atTop]
    refine ⟨0, fun n _ => ?_⟩
    obtain ⟨g, gmeas, hg⟩ :
      ∃ g : α → ℝ≥0∞, Measurable g ∧ ∀ x, f x ≤ g x ∧ g x < ∞ :=
      exists_measurable_le_lintegral_eq f hf
    refine ⟨⟨g, gmeas, hg⟩, rfl⟩
  rcases this with ⟨b, ⟨g, gmeas, hg, hgb⟩, hb⟩
  refine
    ⟨g, fun x => (hg x).1, gmeas.lowerSemicontinuous' ⟨f, hf, fun x => (hg x).1⟩, ?_, ?_⟩
  · refine le_of_tendsto_of_tendsto' (tendsto_const_nhds.add (tendsto_const_nhds.div_const _))
        (hf.lintegral.add (measurable_const.lintegral.div_const _).aestronglyMeasurable) ?_
    filter_upwards [Icc_mem_nhdsWithin_Iic ⟨zero_lt_one, ENNReal.half_pos εpos⟩] with n hn
    rw [← hb, ← hgb]
    refine lintegral_mono_ae (hf.eventually (eventually_le_of_tendsto_lt (gmeas.tendsto_lintegral_nnreal) ?_))
    filter_upwards [Icc_mem_nhdsWithin_Iic ⟨zero_lt_one, ENNReal.half_pos εpos⟩] with n hn
    simpa only [tsub_le_iff_right, add_tsub_cancel_right] using hn
  · refine (lintegral_lt_top_of_bounded_to_ennreal gmeas.aemeasurable fun x => ?_).ne
    simpa only [ENNReal.add_lt_top, or_true_iff] using hg x

Repaired Proof:
theorem exists_le_lowerSemicontinuous_lintegral_ge (f : α → ℝ≥0∞) (hf : Measurable f) {ε : ℝ≥0∞}
    (εpos : ε ≠ 0) :
    ∃ g : α → ℝ≥0∞,
      (∀ x, f x ≤ g x) ∧ LowerSemicontinuous g ∧ (∫⁻ x, g x ∂μ) ≤ (∫⁻ x, f x ∂μ) + ε ∧
        (∫⁻ x, g x ∂μ) ≠ ∞ := by
  have :
    (∫⁻ x, f x ∂μ) + ε / 2 ∈
      closure (Set.range fun g : { g : α → ℝ≥0∞ // Measurable g ∧ ∀ x, f x ≤ g x ∧ g x < ∞ } =>
        (∫⁻ x, g x ∂μ) :
      Set (ℝ≥0∞)) := by
    refine mem_closure_of_tendsto (hf.lintegral.add (measurable_const.lintegral.div_const _).aestronglyMeasurable) ?_
    rw [eventually_atTop]
    refine ⟨0, fun n _ => ?_⟩
    obtain ⟨g, gmeas, hg⟩ :
      ∃ g : α → ℝ≥0∞, Measurable g ∧ ∀ x, f x ≤ g x ∧ g x < ∞ :=
      exists_measurable_le_lintegral_eq f hf
    refine ⟨⟨g, gmeas, hg⟩, rfl⟩
  rcases this with ⟨b, ⟨g, gmeas, hg, hgb⟩, hb⟩
  refine
    ⟨g, fun x => (hg x).1, gmeas.lowerSemicontinuous' ⟨f, hf, fun x => (hg x).1⟩, ?_, ?_⟩
  · refine le_of_tendsto_of_tendsto' (tendsto_const_nhds.add (tendsto_const_nhds.div_const _))
        (hf.lintegral.add (measurable_const.lintegral.div_const _).aestronglyMeasurable) ?_
    filter_upwards [Icc_mem_nhdsWithin_Iic ⟨zero_lt_one, ENNReal.half_pos εpos⟩] with n hn
    rw [← hb, ← hgb]
    refine lintegral_mono_ae (hf.eventually (eventually_le_of_tendsto_lt (gmeas.tendsto_lintegral_nnreal) ?_))
    filter_upwards [Icc_mem_nhdsWithin_Iic ⟨zero_lt_one, ENNReal.half_pos εpos⟩] with n hn
    simpa only [tsub_le_iff_right, add_tsub_cancel_right] using hn
  · refine (lintegral_lt_top_of_bounded_to_ennreal gmeas.aemeasurable fun x => ?_).ne
    simpa only [ENNReal.add_lt_top, or_true_iff] using hg x

Repaired Proof:
theorem exists_le_lowerSemicontinuous_lintegral_ge (f : α → ℝ≥0∞) (hf : Measurable f) {ε : ℝ≥0∞}
    (εpos : ε ≠ 0) :
    ∃ g : α → ℝ≥0∞,
      (∀ x, f x ≤ g x) ∧ LowerSemicontinuous g ∧ (∫⁻ x, g x ∂μ) ≤ (∫⁻ x, f x ∂μ) + ε ∧
        (∫⁻ x, g x ∂μ) ≠ ∞ := by
  have :
    (∫⁻ x, f x ∂μ) + ε / 2 ∈
      closure (Set.range fun g : { g : α → ℝ≥0∞ // Measurable g ∧ ∀ x, f x ≤ g x ∧ g x < ∞ } =>
        (∫⁻ x, g x ∂μ) :
      Set (ℝ≥0∞)) := by
    refine mem_closure_of_tendsto (hf.lintegral.add (measurable_const.lintegral.div_const _).aestronglyMeasurable) ?_
    rw [eventually_atTop]
    refine ⟨0, fun n _ => ?_⟩
    obtain ⟨g, gmeas, hg⟩ :
      ∃ g : α → ℝ≥0∞, Measurable g ∧ ∀ x, f x ≤ g x ∧ g x < ∞ :=
        exists_measurable_le_lintegral_eq f hf
    refine ⟨⟨g, gmeas, hg⟩, rfl⟩
  rcases this with ⟨b, ⟨g, gmeas, hg, hgb⟩, hb⟩
  refine
    ⟨g, fun x => (hg x).1, gmeas.lowerSemicontinuous' ⟨f, hf, fun x => (hg x).1⟩, ?_, ?_⟩
  · refine le_of_tendsto_of_tendsto' (tendsto_const_nhds.add (tendsto_const_nhds.div_const _))
        (hf.lintegral.add (measurable_const.lintegr

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Haar/Basic.lean - 2024-09-09 01:00:57.431093.
---126/200---
For theorem MeasureTheory.Measure.div_mem_nhds_one_of_haar_pos in Mathlib/MeasureTheory/Measure/Haar/Basic.lean:
theorem div_mem_nhds_one_of_haar_pos (μ : Measure G) [IsHaarMeasure μ] [LocallyCompactSpace G]
    [InnerRegular μ] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < μ E) :
    E / E ∈ 𝓝 (1 : G) 


Original valid proof:
:= by
  obtain ⟨K, hKE, hK, K_closed, hKpos⟩ :
      ∃ (K : Set G), K ⊆ E ∧ IsCompact K ∧ IsClosed K ∧ 0 < μ K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with ⟨K, KE, K_comp, K_meas⟩
    refine ⟨closure K, ?_, K_comp.closure, isClosed_closure, ?_⟩
    · exact K_comp.closure_subset_measurableSet hE KE
    · rwa [K_comp.measure_closure]
  filter_upwards [eventually_nhds_one_measure_smul_diff_lt hK K_closed hKpos.ne' (μ := μ)] with g hg
  have : ¬Disjoint (g • K) K := fun hd ↦ by
    rw [hd.symm.sdiff_eq_right, measure_smul] at hg
    exact hg.false
  rcases Set.not_disjoint_iff.1 this with ⟨_, ⟨x, hxK, rfl⟩, hgxK⟩
  simpa using div_mem_div (hKE hgxK) (hKE hxK)


Verifying proof (Commit 488012d0f5ac537bb8055c310b3f223de3f6802e):
↔ E ∈ 𝓝 (1 : G) := by
  refine' ⟨fun h => _, fun h => _⟩
  · have : Tendsto (fun x : G => x / x) (𝓝 (1 : G)) (𝓝 (1 / 1)) :=
      ((continuous_id.div continuous_const).tendsto' _ _ (div_one _)).mono_left nhds_le_nhds
    simpa only [div_one] using this.mem_nhds_iff.1 (h.preimage (continuous_div_right _))
  · have : E / E ⊆ (1 : G) + E - E := by
      rintro x ⟨y, hy, z, hz, rfl⟩
      simp only [sub_eq_add_neg, add_assoc]
      exact add_mem_add hy (neg_mem_neg.2 hz)
    refine' mem_of_superset h this
    simp only [singleton_one, singleton_add, neg_neg, mem_preimage, mem_add_iff_neg_left,
      neg_add_eq_sub]
    rintro x ⟨y, hy, z, hz, rfl⟩
    simpa only [div_eq_mul_inv, mul_inv_rev, mul_assoc, inv_mul_cancel_left] using
      mul_mem_mul hy (inv_mem_inv.2 hz)

Repaired Proof:
theorem div_mem_nhds_one_of_haar_pos (μ : Measure G) [IsHaarMeasure μ] [LocallyCompactSpace G]
    [InnerRegular μ] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < μ E) :
    E / E ∈ 𝓝 (1 : G) ↔ E ∈ 𝓝 (1 : G) := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · have : Tendsto (fun x : G => x / x) (𝓝 (1 : G)) (𝓝 (1 / 1)) :=
      ((continuous_id.div continuous_const).tendsto' _ _ (div_one _)).mono_left nhds_le_nhds
    simpa only [div_one] using this.mem_nhds_iff.1 (h.preimage (continuous_div_right _))
  · have : E / E ⊆ (1 : G) + E - E := by
      rintro x ⟨y, hy, z, hz, rfl⟩
      simp only [sub_eq_add_neg, add_assoc]
      exact add_mem_add hy (neg_mem_neg.2 hz)
    refine mem_of_superset h this
    simp only [singleton_one, singleton_add, neg_neg, mem_preimage, mem_add_iff_neg_left,
      neg_add_eq_sub]
    rintro x ⟨y, hy, z, hz, rfl⟩
    simpa only [div_eq_mul_inv, mul_inv_rev, mul_assoc, inv_mul_cancel_left] using
      mul_mem_mul hy (inv_mem_inv.2 hz)

Repaired Proof:
theorem div_mem_nhds_one_of_haar_pos (μ : Measure G) [IsHaarMeasure μ] [LocallyCompactSpace G]
    [InnerRegular μ] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < μ E) :
    E / E ∈ 𝓝 (1 : G) ↔ E ∈ 𝓝 (1 : G) := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · have : Tendsto (fun x : G => x / x) (𝓝 (1 : G)) (𝓝 (1 / 1)) :=
      ((continuous_id.div continuous_const).tendsto' _ _ (div_one _)).mono_left nhds_le_nhds
    simpa only [div_one] using this.mem_nhds_iff.1 (h.preimage (continuous_div_right _))
  · have : E / E ⊆ (1 : G) + E - E := by
      rintro x ⟨y, hy, z, hz, rfl⟩
      simp only [sub_eq_add_neg, add_assoc]
      exact add_mem_add hy (neg_mem_neg.2 hz)
    refine mem_of_superset h this
    simp only [singleton_one, singleton_add, neg_neg, mem_preimage, mem_add_iff_neg_left,
      neg_add_eq_sub]
    rintro x ⟨y, hy, z, hz, rfl⟩
    simpa only [div_eq_mul_inv, mul_inv_rev, mul_assoc, inv_mul_cancel_left] using
      mul_mem_mul hy (inv_mem_inv.2 hz)

Repaired Proof:
theorem div_mem_nhds_one_of_haar_pos (μ : Measure G) [IsHaarMeasure μ] [LocallyCompactSpace G]
    [InnerRegular μ] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < μ E) :
    E / E ∈ 𝓝 (1 : G) ↔ E ∈ 𝓝 (1 : G) := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · have : Tendsto (fun x : G => x / x) (𝓝 (1 : G)) (𝓝 (1 / 1)) :=
      ((continuous_id.div continuous_const).tendsto' _ _ (div_one _)).mono_left nhds_le_nhds
    simpa only [div_one] using this.mem_nhds_iff.1 (h.preimage (continuous_div_right _))
  · have : E / E ⊆ (1 : G) + E - E := by
      rintro x ⟨y, hy, z, hz, rfl⟩
      simp only [sub_eq_add_neg, add_assoc]
      exact add_mem_add hy (neg_mem_neg.2 hz)
    refine mem_of_superset h this
    simp only [singleton_one, singleton_add, neg_neg, mem_preimage, mem_add_iff_neg_left,
      neg_add_eq_sub]
    rintro x ⟨y, hy, z, hz, rfl⟩
    simpa only [div_eq_mul_inv, mul_inv_rev, mul_assoc, inv_mul_cancel_left] using
      mul_mem_mul hy (inv_mem_inv.2 hz)

Repaired Proof:
theorem div_mem_nhds_one_of_haar_pos (μ : Measure G) [IsHaarMeasure μ] [LocallyCompactSpace G]
    [InnerRegular μ] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < μ E) :
    E / E ∈ 𝓝 (1 : G) ↔ E ∈ 𝓝 (1 : G) := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · have : Tendsto (fun x : G => x / x) (𝓝 (1 : G)) (𝓝 (1 / 1)) :=
      ((continuous_id.div continuous_const).tendsto' _ _ (div_one _)).mono_left nhds_le_nhds
    simpa only [div_one] using this.mem_nhds_iff.1 (h.preimage (continuous_div_right _))
  · have : E / E ⊆ (1 : G) + E - E := by
      rintro x ⟨y, hy, z, hz, rfl⟩
      simp only [sub_eq_add_neg, add_assoc]
      exact add_mem_add hy (neg_mem_neg.2 hz)
    refine mem_of_superset h this
    simp only [singleton_one, singleton_add, neg_neg, mem_preimage, mem_add_iff_neg_left,
      neg_add_eq_sub]
    rintro x ⟨y, hy, z, hz, rfl⟩
    simpa only [div_eq_mul_inv, mul_inv_rev, mul_assoc, inv_mul_cancel_left] using
      mul_mem_mul hy (inv_mem_inv.2 hz)

Repaired Proof:
theorem div_mem_nh

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Haar/Disintegration.lean - 2024-09-09 01:01:12.061287.
---127/200---
For theorem LinearMap.exists_map_addHaar_eq_smul_addHaar in Mathlib/MeasureTheory/Measure/Haar/Disintegration.lean:
theorem LinearMap.exists_map_addHaar_eq_smul_addHaar' (h : Function.Surjective L) :
    ∃ (c : ℝ≥0∞), 0 < c ∧ c < ∞ ∧ μ.map L = (c * addHaar (univ : Set (LinearMap.ker L))) • ν 


Original valid proof:
:= by
  have : ProperSpace E := .of_locallyCompactSpace 𝕜
  have : FiniteDimensional 𝕜 E := .of_locallyCompactSpace 𝕜
  have : ProperSpace F := by
    rcases subsingleton_or_nontrivial E with hE|hE
    · have : Subsingleton F := Function.Surjective.subsingleton h
      infer_instance
    · have : ProperSpace 𝕜 := .of_locallyCompact_module 𝕜 E
      have : FiniteDimensional 𝕜 F := Module.Finite.of_surjective L h
      exact FiniteDimensional.proper 𝕜 F
  let S : Submodule 𝕜 E := LinearMap.ker L
  obtain ⟨T, hT⟩ : ∃ T : Submodule 𝕜 E, IsCompl S T := Submodule.exists_isCompl S
  let M : (S × T) ≃ₗ[𝕜] E := Submodule.prodEquivOfIsCompl S T hT
  have M_cont : Continuous M.symm := LinearMap.continuous_of_finiteDimensional _
  let P : S × T →ₗ[𝕜] T := LinearMap.snd 𝕜 S T
  have P_cont : Continuous P := LinearMap.continuous_of_finiteDimensional _
  have I : Function.Bijective (LinearMap.domRestrict L T) :=
    ⟨LinearMap.injective_domRestrict_iff.2 (IsCompl.inf_eq_bot hT.symm),
    (LinearMap.surjective_domRestrict_iff h).2 hT.symm.sup_eq_top⟩
  let L' : T ≃ₗ[𝕜] F := LinearEquiv.ofBijective (LinearMap.domRestrict L T) I
  have L'_cont : Continuous L' := LinearMap.continuous_of_finiteDimensional _
  have A : L = (L' : T →ₗ[𝕜] F).comp (P.comp (M.symm : E →ₗ[𝕜] (S × T))) := by
    ext x
    obtain ⟨y, z, hyz⟩ : ∃ (y : S) (z : T), M.symm x = (y, z) := ⟨_, _, rfl⟩
    have : x = M (y, z) := by
      rw [← hyz]; simp only [LinearEquiv.apply_symm_apply]
    simp [L', P, M, this]
  have I : μ.map L = ((μ.map M.symm).map P).map L' := by
    rw [Measure.map_map, Measure.map_map, A]
    · rfl
    · exact L'_cont.measurable.comp P_cont.measurable
    · exact M_cont.measurable
    · exact L'_cont.measurable
    · exact P_cont.measurable
  let μS : Measure S := addHaar
  let μT : Measure T := addHaar
  obtain ⟨c₀, c₀_pos, c₀_fin, h₀⟩ :
      ∃ c₀ : ℝ≥0∞, c₀ ≠ 0 ∧ c₀ ≠ ∞ ∧ μ.map M.symm = c₀ • μS.prod μT := by
    have : IsAddHaarMeasure (μ.map M.symm) :=
      M.toContinuousLinearEquiv.symm.isAddHaarMeasure_map μ
    refine ⟨addHaarScalarFactor (μ.map M.symm) (μS.prod μT), ?_, ENNReal.coe_ne_top,
      isAddLeftInvariant_eq_smul _ _⟩
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isAddHaarMeasure (μ.map M.symm) (μS.prod μT)).ne'
  have J : (μS.prod μT).map P = (μS univ) • μT := map_snd_prod
  obtain ⟨c₁, c₁_pos, c₁_fin, h₁⟩ : ∃ c₁ : ℝ≥0∞, c₁ ≠ 0 ∧ c₁ ≠ ∞ ∧ μT.map L' = c₁ • ν := by
    have : IsAddHaarMeasure (μT.map L') :=
      L'.toContinuousLinearEquiv.isAddHaarMeasure_map μT
    refine ⟨addHaarScalarFactor (μT.map L') ν, ?_, ENNReal.coe_ne_top,
      isAddLeftInvariant_eq_smul _ _⟩
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isAddHaarMeasure (μT.map L') ν).ne'
  refine ⟨c₀ * c₁, by simp [pos_iff_ne_zero, c₀_pos, c₁_pos], ENNReal.mul_lt_top c₀_fin c₁_fin, ?_⟩
  simp only [I, h₀, Measure.map_smul, J, smul_smul, h₁]
  rw [mul_assoc, mul_comm _ c₁, ← mul_assoc]


Verifying proof (Commit c47ebbbece0d449dca95c589513159cdc2bab40d):
 := by
  rcases h.exists_pos_lt_apply_of_ne_top μ (measure_ne_top _ _) with ⟨c, c_pos, c_lt_top, hc⟩
  refine' ⟨c, c_pos, c_lt_top, _⟩
  have : Function.Injective (fun x ↦ L x + L (0 : E)) := by simp [L.map_add]
  simp only [hc, L.map_zero, add_zero, measure_preimage_add_right]
  ext s hs
  rcases (addHaar_outer_eq_top_iff _).1 (addHaar_outer_mono hs (L.ker_topological_closure)) with
    (H | H)
  · simp only [H, LinearMap.map_zero, add_zero, measure_empty, eq_self_iff_true,
      zero_smul, top_smul_eq_top]
  · have :
      (fun x ↦ L x + L (0 : E)) '' s ⊆
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) := by
      rintro _ ⟨x, hx, rfl⟩
      simp only [add_zero, mem_preimage, mem_diff, mem_image, mem_univ, true_and_iff,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right]
      exact fun h ↦ H (Submodule.mem_topologicalClosure_of_mem_topologicalClosure _ h)
    have :
      (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) =
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) := by
      simp only [add_zero, image_diff_image_iff, add_left_injective,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right, image_image,
        image_const_of_surjective _ h]
    rw [this, measure_image_add_right]
    simp only [add_zero, LinearMap.map_zero, measure_preimage_add_right,
      ENNReal.mul_rpow_of_nonneg _ _ c_pos.le, ENNReal.rpow_one, mul_comm]
  · have :
      (fun x ↦ L x + L (0 : E)) '' s ⊆
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) := by
      rintro _ ⟨x, hx, rfl⟩
      simp only [add_zero, mem_preimage, mem_diff, mem_image, mem_univ, true_and_iff,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right]
      exact fun h ↦ H (Submodule.mem_topologicalClosure_of_mem_closure hx h)
    have :
      (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) =
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) := by
      simp only [add_zero, image_diff_image_iff, add_left_injective,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right, image_image,
        image_const_of_surjective _ h]
    rw [this, measure_image_add_right]
    simp only [add_zero, LinearMap.map_zero, measure_preimage_add_right,
      ENNReal.mul_rpow_of_nonneg _ _ c_pos.le, ENNReal.rpow_one, mul_comm]

Repaired Proof:
theorem LinearMap.exists_map_addHaar_eq_smul_addHaar' (h : Function.Surjective L) :
    ∃ (c : ℝ≥0∞), 0 < c ∧ c < ∞ ∧ μ.map L = (c * addHaar (univ : Set (LinearMap.ker L))) • ν  := by
  rcases h.exists_pos_lt_apply_of_ne_top μ (measure_ne_top _ _) with ⟨c, c_pos, c_lt_top, hc⟩
  refine ⟨c, c_pos, c_lt_top, ?_⟩
  have : Function.Injective (fun x ↦ L x + L (0 : E)) := by simp [L.map_add]
  simp only [hc, L.map_zero, add_zero, measure_preimage_add_right]
  ext s hs
  rcases (addHaar_outer_eq_top_iff _).1 (addHaar_outer_mono hs (L.ker_topologicalClosure)) with
    (H | H)
  · simp only [H, LinearMap.map_zero, add_zero, measure_empty, eq_self_iff_true,
      zero_smul, top_smul_eq_top]
  · have :
      (fun x ↦ L x + L (0 : E)) '' s ⊆
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) := by
      rintro _ ⟨x, hx, rfl⟩
      simp only [add_zero, mem_preimage, mem_diff, mem_image, mem_univ, true_and_iff,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right]
      exact fun h ↦ H (Submodule.mem_topologicalClosure_of_mem_closure hx h)
    have :
      (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) =
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) := by
      simp only [add_zero, image_diff_image_iff, add_left_injective,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right, image_image,
        image_const_of_surjective _ h]
    rw [this, measure_image_add_right]
    simp only [add_zero, LinearMap.map_zero, measure_preimage_add_right,
      ENNReal.mul_rpow_of_nonneg _ _ c_pos.le, ENNReal.rpow_one, mul_comm]
  · have :
      (fun x ↦ L x + L (0 : E)) '' s ⊆
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) := by
      rintro _ ⟨x, hx, rfl⟩
      simp only [add_zero, mem_preimage, mem_diff, mem_image, mem_univ, true_and_iff,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right]
      exact fun h ↦ H (Submodule.mem_topologicalClosure_of_mem_closure hx h)
    have :
      (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) =
        (fun x ↦ x + (0 : F)) '' ((fun x �

Attempt failure.

---128/200---
For theorem LinearMap.exists_map_addHaar_eq_smul_addHaar in Mathlib/MeasureTheory/Measure/Haar/Disintegration.lean:
theorem LinearMap.exists_map_addHaar_eq_smul_addHaar' (h : Function.Surjective L) :
    ∃ (c : ℝ≥0∞), 0 < c ∧ c < ∞ ∧ μ.map L = (c * addHaar (univ : Set (LinearMap.ker L))) • ν 


Original valid proof:
:= by
  have : ProperSpace E := .of_locallyCompactSpace 𝕜
  have : FiniteDimensional 𝕜 E := .of_locallyCompactSpace 𝕜
  have : ProperSpace F := by
    rcases subsingleton_or_nontrivial E with hE|hE
    · have : Subsingleton F := Function.Surjective.subsingleton h
      infer_instance
    · have : ProperSpace 𝕜 := .of_locallyCompact_module 𝕜 E
      have : FiniteDimensional 𝕜 F := Module.Finite.of_surjective L h
      exact FiniteDimensional.proper 𝕜 F
  let S : Submodule 𝕜 E := LinearMap.ker L
  obtain ⟨T, hT⟩ : ∃ T : Submodule 𝕜 E, IsCompl S T := Submodule.exists_isCompl S
  let M : (S × T) ≃ₗ[𝕜] E := Submodule.prodEquivOfIsCompl S T hT
  have M_cont : Continuous M.symm := LinearMap.continuous_of_finiteDimensional _
  let P : S × T →ₗ[𝕜] T := LinearMap.snd 𝕜 S T
  have P_cont : Continuous P := LinearMap.continuous_of_finiteDimensional _
  have I : Function.Bijective (LinearMap.domRestrict L T) :=
    ⟨LinearMap.injective_domRestrict_iff.2 (IsCompl.inf_eq_bot hT.symm),
    (LinearMap.surjective_domRestrict_iff h).2 hT.symm.sup_eq_top⟩
  let L' : T ≃ₗ[𝕜] F := LinearEquiv.ofBijective (LinearMap.domRestrict L T) I
  have L'_cont : Continuous L' := LinearMap.continuous_of_finiteDimensional _
  have A : L = (L' : T →ₗ[𝕜] F).comp (P.comp (M.symm : E →ₗ[𝕜] (S × T))) := by
    ext x
    obtain ⟨y, z, hyz⟩ : ∃ (y : S) (z : T), M.symm x = (y, z) := ⟨_, _, rfl⟩
    have : x = M (y, z) := by
      rw [← hyz]; simp only [LinearEquiv.apply_symm_apply]
    simp [L', P, M, this]
  have I : μ.map L = ((μ.map M.symm).map P).map L' := by
    rw [Measure.map_map, Measure.map_map, A]
    · rfl
    · exact L'_cont.measurable.comp P_cont.measurable
    · exact M_cont.measurable
    · exact L'_cont.measurable
    · exact P_cont.measurable
  let μS : Measure S := addHaar
  let μT : Measure T := addHaar
  obtain ⟨c₀, c₀_pos, c₀_fin, h₀⟩ :
      ∃ c₀ : ℝ≥0∞, c₀ ≠ 0 ∧ c₀ ≠ ∞ ∧ μ.map M.symm = c₀ • μS.prod μT := by
    have : IsAddHaarMeasure (μ.map M.symm) :=
      M.toContinuousLinearEquiv.symm.isAddHaarMeasure_map μ
    refine ⟨addHaarScalarFactor (μ.map M.symm) (μS.prod μT), ?_, ENNReal.coe_ne_top,
      isAddLeftInvariant_eq_smul _ _⟩
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isAddHaarMeasure (μ.map M.symm) (μS.prod μT)).ne'
  have J : (μS.prod μT).map P = (μS univ) • μT := map_snd_prod
  obtain ⟨c₁, c₁_pos, c₁_fin, h₁⟩ : ∃ c₁ : ℝ≥0∞, c₁ ≠ 0 ∧ c₁ ≠ ∞ ∧ μT.map L' = c₁ • ν := by
    have : IsAddHaarMeasure (μT.map L') :=
      L'.toContinuousLinearEquiv.isAddHaarMeasure_map μT
    refine ⟨addHaarScalarFactor (μT.map L') ν, ?_, ENNReal.coe_ne_top,
      isAddLeftInvariant_eq_smul _ _⟩
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isAddHaarMeasure (μT.map L') ν).ne'
  refine ⟨c₀ * c₁, by simp [pos_iff_ne_zero, c₀_pos, c₁_pos], ENNReal.mul_lt_top c₀_fin c₁_fin, ?_⟩
  simp only [I, h₀, Measure.map_smul, J, smul_smul, h₁]
  rw [mul_assoc, mul_comm _ c₁, ← mul_assoc]


Verifying proof (Commit aa420cc4213ec00e046ed37661f7396b162d3e67):
 := by
  rcases h.exists_pos_lt_apply_of_ne_top μ (measure_ne_top _ _) with ⟨c, c_pos, c_lt_top, hc⟩
  refine' ⟨c, c_pos, c_lt_top, _⟩
  have : Function.Injective (fun x ↦ L x + L (0 : E)) := by simp [L.map_add]
  simp only [hc, L.map_zero, add_zero, measure_preimage_add_right]
  ext s hs
  rcases (addHaar_outer_eq_top_iff _).1 (addHaar_outer_mono hs (L.ker_topological_closure)) with
    (H | H)
  · simp only [H, LinearMap.map_zero, add_zero, measure_empty, eq_self_iff_true,
      zero_smul, top_smul_eq_top]
  · have :
      (fun x ↦ L x + L (0 : E)) '' s ⊆
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) := by
      rintro _ ⟨x, hx, rfl⟩
      simp only [add_zero, mem_preimage, mem_diff, mem_image, mem_univ, true_and_iff,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right]
      exact fun h ↦ H (Submodule.mem_topologicalClosure_of_mem_topologicalClosure _ h)
    have :
      (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) =
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) := by
      simp only [add_zero, image_diff_image_iff, add_left_injective,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right, image_image,
        image_const_of_surjective _ h]
    rw [this, measure_image_add_right]
    simp only [add_zero, LinearMap.map_zero, measure_preimage_add_right,
      ENNReal.mul_rpow_of_nonneg _ _ c_pos.le, ENNReal.rpow_one, mul_comm]
  · have :
      (fun x ↦ L x + L (0 : E)) '' s ⊆
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) := by
      rintro _ ⟨x, hx, rfl⟩
      simp only [add_zero, mem_preimage, mem_diff, mem_image, mem_univ, true_and_iff,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right]
      exact fun h ↦ H (Submodule.mem_topologicalClosure_of_mem_closure hx h)
    have :
      (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) =
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) := by
      simp only [add_zero, image_diff_image_iff, add_left_injective,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right, image_image,
        image_const_of_surjective _ h]
    rw [this, measure_image_add_right]
    simp only [add_zero, LinearMap.map_zero, measure_preimage_add_right,
      ENNReal.mul_rpow_of_nonneg _ _ c_pos.le, ENNReal.rpow_one, mul_comm]

Repaired Proof:
theorem LinearMap.exists_map_addHaar_eq_smul_addHaar' (h : Function.Surjective L) :
    ∃ (c : ℝ≥0∞), 0 < c ∧ c < ∞ ∧ μ.map L = (c * addHaar (univ : Set (LinearMap.ker L))) • ν  := by
  rcases h.exists_pos_lt_apply_of_ne_top μ (measure_ne_top _ _) with ⟨c, c_pos, c_lt_top, hc⟩
  refine ⟨c, c_pos, c_lt_top, ?_⟩
  have : Function.Injective (fun x ↦ L x + L (0 : E)) := by simp [L.map_add]
  simp only [hc, L.map_zero, add_zero, measure_preimage_add_right]
  ext s hs
  rcases (addHaar_outer_eq_top_iff _).1 (addHaar_outer_mono hs (L.ker_topologicalClosure)) with
    (H | H)
  · simp only [H, LinearMap.map_zero, add_zero, measure_empty, eq_self_iff_true,
      zero_smul, top_smul_eq_top]
  · have :
      (fun x ↦ L x + L (0 : E)) '' s ⊆
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) := by
      rintro _ ⟨x, hx, rfl⟩
      simp only [add_zero, mem_preimage, mem_diff, mem_image, mem_univ, true_and_iff,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right]
      exact fun h ↦ H (Submodule.mem_topologicalClosure_of_mem_closure hx h)
    have :
      (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) =
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) := by
      simp only [add_zero, image_diff_image_iff, add_left_injective,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right, image_image,
        image_const_of_surjective _ h]
    rw [this, measure_image_add_right]
    simp only [add_zero, LinearMap.map_zero, measure_preimage_add_right,
      ENNReal.mul_rpow_of_nonneg _ _ c_pos.le, ENNReal.rpow_one, mul_comm]
  · have :
      (fun x ↦ L x + L (0 : E)) '' s ⊆
        (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) := by
      rintro _ ⟨x, hx, rfl⟩
      simp only [add_zero, mem_preimage, mem_diff, mem_image, mem_univ, true_and_iff,
        LinearMap.mem_ker, exists_apply_eq_apply, exists_eq_right]
      exact fun h ↦ H (Submodule.mem_topologicalClosure_of_mem_closure hx h)
    have :
      (fun x ↦ x + (0 : F)) '' ((fun x ↦ L x + L (0 : E)) '' s) \
          (fun x ↦ x + (0 : F)) '' (univ : Set (LinearMap.ker L)) =
        (fun x ↦ x + (0 : F)) '' ((fun x �

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Haar/OfBasis.lean - 2024-09-09 01:01:42.859174.
---129/200---
For theorem parallelepiped_single in Mathlib/MeasureTheory/Measure/Haar/OfBasis.lean:
theorem parallelepiped_single [DecidableEq ι] (a : ι → ℝ) :
    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a 


Original valid proof:
:= by
  ext x
  simp_rw [Set.uIcc, mem_parallelepiped_iff, Set.mem_Icc, Pi.le_def, ← forall_and, Pi.inf_apply,
    Pi.sup_apply, ← Pi.single_smul', Pi.one_apply, Pi.zero_apply, ← Pi.smul_apply',
    Finset.univ_sum_single (_ : ι → ℝ)]
  constructor
  · rintro ⟨t, ht, rfl⟩ i
    specialize ht i
    simp_rw [smul_eq_mul, Pi.mul_apply]
    rcases le_total (a i) 0 with hai | hai
    · rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai]
      exact ⟨le_mul_of_le_one_left hai ht.2, mul_nonpos_of_nonneg_of_nonpos ht.1 hai⟩
    · rw [sup_eq_right.mpr hai, inf_eq_left.mpr hai]
      exact ⟨mul_nonneg ht.1 hai, mul_le_of_le_one_left hai ht.2⟩
  · intro h
    refine ⟨fun i => x i / a i, fun i => ?_, funext fun i => ?_⟩
    · specialize h i
      rcases le_total (a i) 0 with hai | hai
      · rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai] at h
        exact ⟨div_nonneg_of_nonpos h.2 hai, div_le_one_of_ge h.1 hai⟩
      · rw [sup_eq_right.mpr hai, inf_eq_left.mpr hai] at h
        exact ⟨div_nonneg h.1 hai, div_le_one_of_le h.2 hai⟩
    · specialize h i
      simp only [smul_eq_mul, Pi.mul_apply]
      rcases eq_or_ne (a i) 0 with hai | hai
      · rw [hai, inf_idem, sup_idem, ← le_antisymm_iff] at h
        rw [hai, ← h, zero_div, zero_mul]
      · rw [div_mul_cancel₀ _ hai]


Verifying proof (Commit df634f2a3b3d3eef3936f220d4bcc9b21e88770c):
∂ᵣ := by
  ext x
  simp_rw [mem_parallelepiped_iff, mem_setOf_eq, mem_uIcc, Real.le_of_mem_uIcc,
    Real.mem_uIcc_of_nonneg_of_le, mem_univ_pi]
  refine ⟨fun h => ⟨fun i => ⟨0, a i⟩, fun i => ⟨0, 1⟩, ?_⟩, fun h => ⟨fun i => x i, fun i => 1, ?_⟩⟩
  · rintro i
    simpa only [Pi.single_apply] using h i i
  · rintro i
    simp [h i]

Repaired Proof:
theorem parallelepiped_single [DecidableEq ι] (a : ι → ℝ) :
    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a ∂ᵣ := by
  ext x
  simp_rw [mem_parallelepiped_iff, mem_setOf_eq, mem_uIcc, Real.le_of_mem_uIcc,
    Real.mem_uIcc_of_nonneg_of_le, mem_univ_pi]
  refine ⟨fun h ↦ ⟨fun i ↦ ⟨0, a i⟩, fun i ↦ ⟨0, 1⟩, ?_⟩, fun h ↦ ⟨fun i ↦ x i, fun i ↦ 1, ?_⟩⟩
  · rintro i
    simpa only [Pi.single_apply] using h i i
  · rintro i
    simp [h i]

Repaired Proof:
theorem parallelepiped_single [DecidableEq ι] (a : ι → ℝ) :
    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a ∂ᵣ := by
  ext x
  simp_rw [mem_parallelepiped_iff, mem_setOf_eq, mem_uIcc, Real.le_of_mem_uIcc,
    Real.mem_uIcc_of_nonneg_of_le, mem_univ_pi]
  refine ⟨fun h ↦ ⟨fun i ↦ ⟨0, a i⟩, fun i ↦ ⟨0, 1⟩, ?_⟩, fun h ↦ ⟨fun i ↦ x i, fun i ↦ 1, ?_⟩⟩
  · rintro i
    simpa only [Pi.single_apply] using h i i
  · rintro i
    simp [h i]

Repaired Proof:
theorem parallelepiped_single [DecidableEq ι] (a : ι → ℝ) :
    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a ∂ᵣ := by
  ext x
  simp_rw [mem_parallelepiped_iff, mem_setOf_eq, mem_uIcc, Real.le_of_mem_uIcc,
    Real.mem_uIcc_of_nonneg_of_le, mem_univ_pi]
  refine ⟨fun h ↦ ⟨fun i ↦ ⟨0, a i⟩, fun i ↦ ⟨0, 1⟩, ?_⟩, fun h ↦ ⟨fun i ↦ x i, fun i ↦ 1, ?_⟩⟩
  · rintro i
    simpa only [Pi.single_apply] using h i i
  · rintro i
    simp [h i]

Repaired Proof:
theorem parallelepiped_single [DecidableEq ι] (a : ι → ℝ) :
    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a ∂ᵣ := by
  ext x
  simp_rw [mem_parallelepiped_iff, mem_setOf_eq, mem_uIcc, Real.le_of_mem_uIcc,
    Real.mem_uIcc_of_nonneg_of_le, mem_univ_pi]
  refine ⟨fun h ↦ ⟨fun i ↦ ⟨0, a i⟩, fun i ↦ ⟨0, 1⟩, ?_⟩, fun h ↦ ⟨fun i ↦ x i, fun i ↦ 1, ?_⟩⟩
  · rintro i
    simpa only [Pi.single_apply] using h i i
  · rintro i
    simp [h i]

Repaired Proof:
theorem parallelepiped_single [DecidableEq ι] (a : ι → ℝ) :
    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a ∂ᵣ := by
  ext x
  simp_rw [mem_parallelepiped_iff, mem_setOf_eq, mem_uIcc, Real.le_of_mem_uIcc,
    Real.mem_uIcc_of_nonneg_of_le, mem_univ_pi]
  refine ⟨fun h ↦ ⟨fun i ↦ ⟨0, a i⟩, fun i ↦ ⟨0, 1⟩, ?_⟩, fun h ↦ ⟨fun i ↦ x i, fun i ↦ 1, ?_⟩⟩
  · rintro i
    simpa only [Pi.single_apply] using h i i
  · rintro i
    simp [h i]

Repaired Proof:
theorem parallelepiped_single [DecidableEq ι] (a : ι → ℝ) :
    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a ∂ᵣ := by
  ext x
  simp_rw [mem_parallelepiped_iff, mem_setOf_eq, mem_uIcc, Real.le_of_mem_uIcc,
    Real.mem_uIcc_of_nonneg_of_le, mem_univ_pi]
  refine ⟨fun h ↦ ⟨fun i ↦ ⟨0, a i⟩, fun i ↦ ⟨0, 1⟩, ?_⟩, fun h ↦ ⟨fun i ↦ x i, fun i ↦ 1, ?_⟩⟩
  · rintro i
    simpa only [Pi.single_apply] using h i i
  · rintro i
    simp [h i]

Repaired Proof:
theorem parallelepiped_single [DecidableEq ι] (a : ι → ℝ) :
    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a ∂ᵣ := by
  ext x
  simp_rw [mem_parallelepiped_iff, mem_setOf_eq, mem_uIcc, Real.le_of_mem_uIcc,
    Real.mem_uIcc_of_nonneg_of_le, mem_univ_pi]
  refine ⟨fun h ↦ ⟨fun i ↦ ⟨0, a i⟩, fun i ↦ ⟨0, 1⟩, ?_⟩, fun h ↦ ⟨fun i ↦ x i, fun i ↦ 1, ?_⟩⟩
  · rintro i
    simpa only [Pi.single_apply] using h i i
  · rintro i
    simp [h i]

Repaired Proof:
theorem parallelepiped_single [DecidableEq ι] (a : ι → ℝ) :
    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a ∂ᵣ := by
  ext x
  simp_rw [mem_parallelepiped_iff, mem_setOf_eq, mem_uIcc, Real.le_of_mem

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Haar/Quotient.lean - 2024-09-09 01:02:02.298717.
---130/200---
For theorem MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient in Mathlib/MeasureTheory/Measure/Haar/Quotient.lean:
lemma MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient
    [IsMulLeftInvariant ν] [hasFun : HasFundamentalDomain Γ.op G ν] :
    SMulInvariantMeasure G (G ⧸ Γ) μ where



Original valid proof:
  measure_preimage_smul g A hA := by
    have meas_π : Measurable π := continuous_quotient_mk'.measurable
    obtain ⟨𝓕, h𝓕⟩ := hasFun.ExistsIsFundamentalDomain
    have h𝓕_translate_fundom : IsFundamentalDomain Γ.op (g • 𝓕) ν := h𝓕.smul_of_comm g
    erw [h𝓕.projection_respects_measure_apply (μ := μ)
      (meas_π (measurableSet_preimage (measurable_const_smul g) hA)),
      h𝓕_translate_fundom.projection_respects_measure_apply (μ := μ) hA]
    change ν ((π ⁻¹' _) ∩ _) = ν ((π ⁻¹' _) ∩ _)
    set π_preA := π ⁻¹' A
    have : π ⁻¹' ((fun x : G ⧸ Γ => g • x) ⁻¹' A) = (g * ·) ⁻¹' π_preA := by ext1; simp [π_preA]
    rw [this]
    have : ν ((g * ·) ⁻¹' π_preA ∩ 𝓕) = ν (π_preA ∩ (g⁻¹ * ·) ⁻¹' 𝓕) := by
      trans ν ((g * ·) ⁻¹' (π_preA ∩ (g⁻¹ * ·) ⁻¹' 𝓕))
      · rw [preimage_inter]
        congr 2
        simp [Set.preimage]
      rw [measure_preimage_mul]
    rw [this, ← preimage_smul_inv]; rfl


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
  map_mul_left_eq_self g x := by
    obtain ⟨g₁, g₂, hg⟩ : ∃ g₁ g₂ : G, g = g₁ * g₂ := by
      obtain ⟨g₁, hg₁⟩ := QuotientGroup.mk_surjective g
      obtain ⟨g₂, hg₂⟩ := QuotientGroup.mk_surjective (g⁻¹)
      refine' ⟨g₁⁻¹ * g, g₂, _⟩
      simp [← hg₁, ← hg₂]
    obtain ⟨s, hs⟩ := hasFun.exists_is_fundamental_domain
    rw [← QuotientGroup.mk_mul, ← QuotientGroup.mk_mul, ← QuotientGroup.mk_mul,
      QuotientMeasureEqMeasurePreimage.map_apply_of_isMulLeftInvariant _ _ _ _ hs,
      QuotientMeasureEqMeasurePreimage.map_apply_of_isMulLeftInvariant _ _ _ _ hs,
      QuotientMeasureEqMeasurePreimage.map_apply_of_isMulLeftInvariant _ _ _ _ hs,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_mul, QuotientGroup.mk_mul,
      QuotientGroup.mk_mul, QuotientGroup.mk_

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Hausdorff.lean - 2024-09-09 01:02:20.964522.
---131/200---
For theorem IsometryEquiv.hausdorffMeasure_image in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s 


Original valid proof:
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  · rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)
    · simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    · simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ⟨x, hx⟩
    · haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  · have hCd0 : (C : ℝ≥0∞) ^ d ≠ 0 := by simp [hC0.ne']
    have hCd : (C : ℝ≥0∞) ^ d ≠ ∞ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      ← ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : ℝ≥0∞ => (C : ℝ≥0∞) * d ^ (r : ℝ)) (𝓝 0) (𝓝 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      ⟨δ, δ0, H⟩
    refine le_iSup₂_of_le δ δ0 <| iInf₂_mono' fun t hst ↦
      ⟨fun n => f '' (t n ∩ s), ?_, iInf_mono' fun htδ ↦
        ⟨fun n => (h.ediam_image_inter_le (t n)).trans (H (htδ n)).le, ?_⟩⟩
    · rw [← image_iUnion, ← iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    · refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, ← ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine' ⟨_, _⟩
  · refine' (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top _ _)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine' (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top _ _)).ne _).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥

Attempt failure.

---132/200---
For theorem MeasureTheory.Measure.noAtoms_hausdorff in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem noAtoms_hausdorff {d : ℝ} (hd : 0 < d) : NoAtoms (hausdorffMeasure d : Measure X) 


Original valid proof:
:= by
  refine ⟨fun x => ?_⟩
  rw [← nonpos_iff_eq_zero, hausdorffMeasure_apply]
  refine iSup₂_le fun ε _ => iInf₂_le_of_le (fun _ => {x}) ?_ <| iInf_le_of_le (fun _ => ?_) ?_
  · exact subset_iUnion (fun _ => {x} : ℕ → Set X) 0
  · simp only [EMetric.diam_singleton, zero_le]
  · simp [hd]


Verifying proof (Commit ced4d3c0af763b9fd00166e49cf999cf46c891cc):
↔
    IsUnifLocDoublingMeasure (hausdorffMeasure d : Measure X) := by
  constructor
  · intro h
    refine' ⟨fun r x => _⟩
    rw [hausdorffMeasure_zero_null (h.countable _)]
    exact eventually_of_forall fun _ => empty_mem_nhdsSet
  · intro h
    refine' mkMetric_noAtoms fun r => _
    rw [hausdorffMeasure_zero_iff_empty_or_singleton]
    exact Or.inr ⟨h.doubling, h.tendsto_atTop_zero⟩

Repaired Proof:
theorem noAtoms_hausdorff {d : ℝ} (hd : 0 < d) : NoAtoms (hausdorffMeasure d : Measure X) ↔
    IsUnifLocDoublingMeasure (hausdorffMeasure d : Measure X) := by
  constructor
  · intro h
    refine ⟨fun r x => ?_⟩
    rw [hausdorffMeasure_zero_null (h.countable _)]
    exact eventually_of_forall fun _ => empty_mem_nhdsSet
  · intro h
    refine mkMetric_noAtoms fun r => ?_
    rw [hausdorffMeasure_zero_iff_empty_or_singleton]
    exact Or.inr ⟨h.doubling, h.tendsto_atTop_zero⟩

Repaired Proof:
theorem hausdorffMeasure_zero_ae_empty_or_singleton (d : ℝ) {s : Set X} (hd : 0 < d)
    (h : IsUnifLocDoublingMeasure (hausdorffMeasure d : Measure X)) :
    hausdorffMeasure d s = 0 ∨ ∃ x, s = {x} := by
  rcases eq_or_ne (hausdorffMeasure d s) 0 with (h0 | h0)
  · exact Or.inl h0
  right
  rcases h.exists_singleton (hausdorffMeasure_ne_zero_iff_nonempty_of_proper.1 h0) hd with ⟨x, r, rpos, -, hx⟩
  refine' ⟨x, _⟩
  suffices s ⊆ {x} by exact (Subset.antisymm this (singleton_subset_iff.2 <| mem_singleton x)).symm
  rw [← hx]
  exact (hausdorffMeasure_le_of_hausdorffEdist_lt (Or.inr rpos) <| lt_add_one _).trans_eq hx

Repaired Proof:
theorem hausdorffMeasure_zero_ae_empty_or_singleton (d : ℝ) {s : Set X} (hd : 0 < d)
    (h : IsUnifLocDoublingMeasure (hausdorffMeasure d : Measure X)) :
    hausdorffMeasure d s = 0 ∨ ∃ x, s = {x} := by
  rcases eq_or_ne (hausdorffMeasure d s) 0 with (h0 | h0)
  · exact Or.inl h0
  right
  rcases h.exists_singleton (hausdorffMeasure_ne_zero_iff_nonempty_of_proper.1 h0) hd with ⟨x, r, rpos, -, hx⟩
  refine ⟨x, ?_⟩
  suffices s ⊆ {x} by exact (Subset.antisymm this (singleton_subset_iff.2 <| mem_singleton x)).symm
  rw [← hx]
  exact (hausdorffMeasure_le_of_hausdorffEdist_lt (Or.inr rpos) <| lt_add_one _).trans_eq hx

Repaired Proof:
theorem hausdorffMeasure_zero_ae_empty_or_singleton (d : ℝ) {s : Set X} (hd : 0 < d)
    (h : IsUnifLocDoublingMeasure (hausdorffMeasure d : Measure X)) :
    hausdorffMeasure d s = 0 ∨ ∃ x, s = {x} := by
  rcases eq_or_ne (hausdorffMeasure d s) 0 with (h0 | h0)
  · exact Or.inl h0
  right
  rcases h.exists_singleton (hausdorffMeasure_ne_zero_iff_nonempty_of_proper.1 h0) hd with ⟨x, r, rpos, -, hx⟩
  refine ⟨x, ?_⟩
  suffices s ⊆ {x} by exact (Subset.antisymm this (singleton_subset_iff.2 <| mem_singleton x)).symm
  rw [← hx]
  exact (hausdorffMeasure_le_of_hausdorffEdist_lt (Or.inr rpos) <| lt_add_one _).trans_eq hx

Repaired Proof:
theorem hausdorffMeasure_zero_ae_empty_or_singleton (d : ℝ) {s : Set X} (hd : 0 < d)
    (h : IsUnifLocDoublingMeasure (hausdorffMeasure d : Measure X)) :
    hausdorffMeasure d s = 0 ∨ ∃ x, s = {x} := by
  rcases eq_or_ne (hausdorffMeasure d s) 0 with (h0 | h0)
  · exact Or.inl h0
  right
  rcases h.exists_singleton (hausdorffMeasure_ne_zero_iff_nonempty_of_proper.1 h0) hd with ⟨x, r, rpos, -, hx⟩
  refine ⟨x, ?_⟩
  suffices s ⊆ {x} by exact (Subset.antisymm this (singleton_subset_iff.2 <| mem_singleton x)).symm
  rw [← hx]
  exact (hausdorffMeasure_le_of_hausdorffEdist_lt (Or.inr rpos) <| lt_add_one _).trans_eq hx

Repaired Proof:
theorem hausdorffMeasure_zero_ae_empty_or_singleton (d : ℝ) {s : Set X} (hd : 0 < d)
    (h : IsUnifLocDoublingMeasure (hausdorffMeasure d : Measure X)) :
    hausdorffMeasure d s = 0 ∨ ∃ x, s = {x} := by
  rcases eq_or_ne (hausdorffMeasure d s) 0 with (h0 | h0)
  · exact Or.inl h0
  right
  rcases h.exists_singleton (hausdorffMeasure_ne_zero_iff_nonempty_of_proper.1 h0) hd with ⟨x, r, rpos, -, hx⟩
  refine ⟨x, ?_⟩
  suffices s ⊆ {x} by exact (Subset.antisymm this (singleton_subset_iff.2 <| mem_singleton x)).symm
  rw [← hx]
  exact (hausdorffMeasure_le_of_hausdorffEdist_lt (Or.inr rpos) <| lt_add_one _).trans_eq hx

Repaired Proof:
theorem hausdorffMeasure_zero_ae_empty_or_singleton (d : ℝ) {s : Set X} (hd : 0 < d)
    (h : IsUnifLocDoublingMeasure (hausdorffMeasure d : Measure X)) :
    hausdorffMeasure d s = 0 ∨ ∃ x, s = {x} := by
  rcases eq_or_ne (hausdorffMeasure d s) 0 with (h0 | h0)
  · exact Or.inl h0
  right
  rcases h.exists_singleton (hausdorffMeasure_ne_zero_iff_nonempty_of_proper.1 h0) hd with ⟨x, r, rpos, -, hx⟩
  refine ⟨x, ?_⟩
  suffices s ⊆ {x} by exact (Subset.antisymm this (singleton_subset_iff.2 <| mem_singleton x)).symm
  rw [← hx]
  exact (hausdorffMeasure_le_of_hausdorffEdist_lt (Or.inr rpos) <| lt_add_one _).trans_eq hx

Repaired Proof:
theorem hausdorffMeasure_zero_ae_empty_or_singleton (d : ℝ) {s : Set X} (hd : 0 < d)
    (h : IsUnifLocDoublingMeasure (hausdorffMeasure d : Measure X)) :
    hausdorffMeasure d s = 0 ∨ ∃ x, s = {x} := by
  rcases eq_or_ne (hausdorffMeasure d s) 0 with (h0 | h0)
  · exact Or.inl h0
  right
  rcases h.exists_singleton (hausdorffMeasure_ne_zero_iff_nonempty_of_proper.

Attempt failure.

---133/200---
For theorem HolderOnWith.hausdorffMeasure_image_le in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s 


Original valid proof:
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  · rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)
    · simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    · simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ⟨x, hx⟩
    · haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  · have hCd0 : (C : ℝ≥0∞) ^ d ≠ 0 := by simp [hC0.ne']
    have hCd : (C : ℝ≥0∞) ^ d ≠ ∞ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      ← ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : ℝ≥0∞ => (C : ℝ≥0∞) * d ^ (r : ℝ)) (𝓝 0) (𝓝 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      ⟨δ, δ0, H⟩
    refine le_iSup₂_of_le δ δ0 <| iInf₂_mono' fun t hst ↦
      ⟨fun n => f '' (t n ∩ s), ?_, iInf_mono' fun htδ ↦
        ⟨fun n => (h.ediam_image_inter_le (t n)).trans (H (htδ n)).le, ?_⟩⟩
    · rw [← image_iUnion, ← iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    · refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, ← ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd


Verifying proof (Commit 3cb2bdef8481160ee4f3f3a94fca1f5824c2798a):
∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine' ⟨_, _⟩
  · refine' (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top _ _)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine' (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top _ _)).ne _).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean - 2024-09-09 01:03:27.210404.
---134/200---
For theorem MeasureTheory.measure_inter_null_of_null_left in Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean:
theorem measure_inter_null_of_null_left {S : Set α} (T : Set α) (h : μ S = 0) : μ (S ∩ T) = 0 


Original valid proof:
:=
  measure_mono_null inter_subset_left h


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 :=
    le_antisymm (measure_mono (inter_subset_left S T)) (le_trans (measure_mono (inter_subset_left S T)) h)


theorem measure_inter_null_of_null_right (S : Set α) {T : Set α} (h : μ T = 0) : μ (S ∩ T) = 0  :=
  measure_inter_null_of_null_left T h


theorem measure_union_null_of_le_null_right {S : Set α} (T : Set α) (h : μ T ≤ 0) : μ (S ∪ T) = 0 :=
  measure_union_null S (measure_mono_null (subset_union_right S T) h)


theorem measure_union_null_of_le_null_left (S : Set α) {T : Set α} (h : μ T ≤ 0) : μ (S ∪ T) = 0 :=
  measure_union_null T (measure_mono_null (subset_union_left S T) h)


theorem measure_union_null_iff {S T : Set α} : μ (S ∪ T) = 0 ↔ μ S = 0 ∧ μ T = 0 := by
  rw [← le_zero_iff, measure_union_le, add_le_iff, le_zero_iff, le_zero_iff]


theorem measure_union_null_iff' {S T : Set α} : μ (S ∪ T) = 0 ↔ μ (S \ T) = 0 ∧ μ (T \ S) = 0 := by
  simp [union_eq_diff_union_diff_union, measure_union_null_iff,
    measure_inter_null_of_null_left, measure_inter_null_of_null_right]


theorem measure_union_pos_of_nonzero_left {S : Set α} (T : Set α) (h : μ S ≠ 0) : 0 < μ (S ∪ T) ↔ μ T ≠ 0 :=
  pos_iff_ne_zero.trans <|
    Iff.intro
      (fun h' h₁ => h <| measure_union_null S h₁)
      fun h' =>
      mt (measure_union_null S h') (not_or_of_not (pos_iff_ne_zero.1 h) h')


theorem measure_union_pos_of_nonzero_right (S : Set α) {T : Set α} (h : μ T ≠ 0) :
    0 < μ (S ∪ T) ↔ μ S ≠ 0 := by
  simpa only [union_comm] using measure_union_pos_of_nonzero_left T h


theorem measure_union_eq_zero_iff_of_measure_ne_top {s t : Set α} (hs : μ s ≠ ∞) (ht : μ t ≠ ∞) :
    μ (s ∪ t) = 0 ↔ μ s = 0 ∧ μ t = 0 := by
  simp only [measure_eq_zero_iff_of_measure_ne_top hs,
    measure_eq_zero_iff_of_measure_ne_top ht, Set.union_eq_empty]


theorem measure_union_eq_zero_iff_of_nonpos {s t : Set α} (hs : μ s ≤ 0) (ht : μ t ≤ 0) :
    μ (s ∪ t) = 0 ↔ μ s = 0 ∧ μ t = 0 := by
  simp only [measure_eq_zero_iff_of_nonpos, hs, ht, or_self, and_self, union_eq_self_of_subset_left]


theorem measure_union_eq_zero_iff_of_nonpos_left {s t : Set α} (hs : μ s ≤ 0) :
    μ (s ∪ t) = 0 ↔ μ t = 0 := by
  simp only [measure_union_eq_zero_iff_of_nonpos hs, and_iff_right_iff_imp]
  exact fun ht ↦ measure_mono_null (subset_union_right _ _) ht


theorem measure_union_eq_zero_iff_of_nonpos_right {s t : Set α} (ht : μ t ≤ 0) :
    μ (s ∪ t) = 0 ↔ μ s = 0 := by
  simp only [measure_union_eq_zero_iff_of_nonpos ht, and_iff_left_iff_imp]
  exact fun hs ↦ measure_mono_null (subset_union_left _ _) hs


theorem measure_union_pos_iff_nonempty_of_measure_ne_top {s t : Set α} (hs : μ s ≠ ∞)
    (ht : μ t ≠ ∞) : 0 < μ (s ∪ t) ↔ (s ∩ t).Nonempty := by
  simp [pos_iff_ne_zero, measure_eq_zero_iff_of_measure_ne_top, hs, ht]


theorem measure_union_pos_iff_nonempty_of_nonpos {s t : Set α} (hs : μ s ≤ 0) (ht : μ t ≤ 0) :
    0 < μ (s ∪ t) ↔ (s ∩ t).Nonempty := by
  simp [pos_iff_ne_zero, measure_eq_zero_iff_of_nonpos, hs, ht]


theorem measure_union_pos_iff_nonempty_of_neg [NoAtoms μ] {s t : Set α} (hs : μ s < 0)
    (ht : μ t < 0) : 0 < μ (s ∪ t) ↔ (s ∩ t).Nonempty := by
  simp [pos_iff_ne_zero, measure_eq_zero_iff_of_neg, hs, ht]


theorem measure_union_pos_iff_nonempty_of_nonpos [NoAtoms μ] {s t : Set α} (hs : μ s ≤ 0)
    (ht : μ t ≤ 0) : 0 < μ (s ∪ t) ↔ (s ∩ t).Nonempty := by
  simp [pos_iff_ne_zero, measure_eq_zero_iff_of_nonpos, hs, ht]


theorem measure_union_pos_iff_nonempty_of_inter_eq_empty [NoAtoms μ] {s t : Set α}
    (h : s ∩ t = ∅) : 0 < μ (s ∪ t) ↔ (s.Nonempty ∧ t.Nonempty) := by
  simp [pos_iff_ne_zero, h, or_iff_right]


theorem measure_union_pos_iff_nonempty_of_inter_eq_empty' [NoAtoms μ] {s t : Set α}
    (h : s ∩ t = ∅) : 0 < μ (s ∪ t) ↔ (s = ∅ → t.Nonempty) ∧ (t = ∅ → s.Nonempty) := by
  simp [pos_iff_ne_zero, h, or_iff_right]


theorem measure_union_pos_iff_nonempty_of_inter_eq_empty'' [NoAtoms μ] {s t : Set α}
    (h : s ∩ t = ∅) : 0 < μ (s ∪ t) ↔ (s.Nonempty ↔ t.Nonempty) := by
  simp [pos_iff_ne_zero, h, or_iff_right]


theorem measure_union_pos_iff_nonempty_of_inter_eq_empty_of_pos [NoAtoms μ] {s t : Set α}
    (hs : 0 < μ s) (h : s ∩ t = ∅) : 0 < μ (s ∪ t) ↔ t.Nonempty := by
  simp [pos_iff_ne_zero, h, or_iff_left_of_imp]
  rintro ⟨x, hx⟩
  exact (measure_pos_of_superset (not_imp_comm.1
    (measure_zero_of_subset_of_measure_zero (subset_union_right _ _) (measure_union_null _ hx))).2
    (subset_union_left _ _) hs).ne'


theorem measure_union_pos_iff_nonempty_of_inter_eq_empty_of_pos' [NoAtoms μ] {s t : Set α}
    (ht : 0 < μ t) (h : s �

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Portmanteau.lean - 2024-09-09 01:03:39.156646.
---135/200---
For theorem MeasureTheory.exists_null_frontier_thickening in Mathlib/MeasureTheory/Measure/Portmanteau.lean:
theorem exists_null_frontier_thickening (μ : Measure Ω) [SigmaFinite μ] (s : Set Ω) {a b : ℝ}
    (hab : a < b) : ∃ r ∈ Ioo a b, μ (frontier (Metric.thickening r s)) = 0 


Original valid proof:
:= by
  have mbles : ∀ r : ℝ, MeasurableSet (frontier (Metric.thickening r s)) :=
    fun r => isClosed_frontier.measurableSet
  have disjs := Metric.frontier_thickening_disjoint s
  have key := Measure.countable_meas_pos_of_disjoint_iUnion (μ := μ) mbles disjs
  have aux := measure_diff_null (s := Ioo a b) (Set.Countable.measure_zero key volume)
  have len_pos : 0 < ENNReal.ofReal (b - a) := by simp only [hab, ENNReal.ofReal_pos, sub_pos]
  rw [← Real.volume_Ioo, ← aux] at len_pos
  rcases nonempty_of_measure_ne_zero len_pos.ne.symm with ⟨r, ⟨r_in_Ioo, hr⟩⟩
  refine ⟨r, r_in_Ioo, ?_⟩
  simpa only [mem_setOf_eq, not_lt, le_zero_iff] using hr


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
      Tendsto (fun r => μ (frontier (Metric.thickening r s))) (𝓝[Ioo a b] r) (𝓝 0) := by
  rcases eq_or_ne (μ (frontier s)) 0 with hμ | hμ
  · refine' ⟨a, left_mem_Ioo.2 hab, hμ, _⟩
    rw [← frontier_thickening_of_mem (left_mem_Ioo.2 hab)]
    exact tendsto_const_nhds
  rcases exists_null_frontier_thickening_of_density_pos μ s hab hμ with ⟨r, hr, h0, hμ'⟩
  refine' ⟨r, hr, h0, _⟩
  have A : Tendsto (fun r => μ (frontier (Metric.thickening r s))) (𝓝[>] r) (𝓝 0) := by
    apply tendsto_measure_frontier_of_tendsto_measure_cthickening μ
    apply tendsto_measure_cthickening_of_isCompact_of_null_frontier _ _ h0
    · exact isCompact_frontier_thickening_of_open (isOpen_thickening.preimage continuous_dist)
        Metric.isOpen_ball
    · exact (frontier_thickening_subset_frontier _ _).trans (frontier_mono (Metric.cthickening_subset_thickening
        Metric.self_mem_nhdsWithin) (subset_refl _))
  have B : Tendsto (fun r => μ (frontier (Metric.thickening r s))) (𝓝[<] r) (𝓝 0) := by
    apply tendsto_measure_frontier_of_tendsto_measure_cthickening μ
    apply tendsto_measure_cthickening_of_isCompact_of_null_frontier _ _ h0
    · exact isCompact_frontier_thickening_of_open (isOpen_thickening.preimage continuous_dist)
        Metric.isOpen_ball
    · exact (frontier_thickening_subset_frontier _ _).trans (frontier_mono (Metric.cthickening_subset_thickening
        Metric.self_mem_nhdsWithin) (subset_refl _))
  exact Filter.tendsto_Ioo_iff.2 ⟨A, B⟩

Repaired Proof:
theorem exists_null_frontier_thickening (μ : Measure Ω) [SigmaFinite μ] (s : Set Ω) {a b : ℝ}
    (hab : a < b) : ∃ r ∈ Ioo a b, μ (frontier (Metric.thickening r s)) = 0 ∧
      Tendsto (fun r => μ (frontier (Metric.thickening r s))) (𝓝[Ioo a b] r) (𝓝 0) := by
  rcases eq_or_ne (μ (frontier s)) 0 with hμ | hμ
  · refine ⟨a, left_mem_Ioo.2 hab, hμ, ?_⟩
    rw [← frontier_thickening_of_mem (left_mem_Ioo.2 hab)]
    exact tendsto_const_nhds
  rcases exists_null_frontier_thickening_of_density_pos μ s hab hμ with ⟨r, hr, h0, hμ'⟩
  refine ⟨r, hr, h0, ?_⟩
  have A : Tendsto (fun r => μ (frontier (Metric.thickening r s))) (𝓝[>] r) (𝓝 0) := by
    apply tendsto_measure_frontier_of_tendsto_measure_cthickening μ
    apply tendsto_measure_cthickening_of_isCompact_of_null_frontier _ _ h0
    · exact isCompact_frontier_thickening_of_open (isOpen_thickening.preimage continuous_dist)
        Metric.isOpen_ball
    · exact (frontier_thickening_subset_frontier _ _).trans (frontier_mono (Metric.cthickening_subset_thickening
        Metric.self_mem_nhdsWithin) (subset_refl _))
  have B : Tendsto (fun r => μ (frontier (Metric.thickening r s))) (𝓝[<] r) (𝓝 0) := by
    apply tendsto_measure_frontier_of_tendsto_measure_cthickening μ
    apply tendsto_measure_cthickening_of_isCompact_of_null_frontier _ _ h0
    · exact isCompact_frontier_thickening_of_open (isOpen_thickening.preimage continuous_dist)
        Metric.isOpen_ball
    · exact (frontier_thickening_subset_frontier _ _).trans (frontier_mono (Metric.cthickening_subset_thickening
        Metric.self_mem_nhdsWithin) (subset_refl _))
  exact Filter.tendsto_Ioo_iff.2 ⟨A, B⟩

Repaired Proof:
theorem exists_null_frontier_thickening (μ : Measure Ω) [SigmaFinite μ] (s : Set Ω) {a b : ℝ}
    (hab : a < b) : ∃ r ∈ Ioo a b, μ (frontier (Metric.thickening r s)) = 0 ∧
      Tendsto (fun r => μ (frontier (Metric.thickening r s))) (𝓝[Ioo a b] r) (𝓝 0) := by
  rcases eq_or_ne (μ (frontier s)) 0 with hμ | hμ
  · refine ⟨a, left_mem_Ioo.2 hab, hμ, ?_⟩
    rw [← frontier_thickening_of_mem (left_mem_Ioo.2 hab)]
    exact tendsto_const_nhds
  rcases exists_null_frontier_thickening_of_density_pos μ s hab hμ with ⟨r, hr, h0, hμ'⟩
  refine ⟨r, hr, h0, ?_⟩
  have A : Tendsto (fun r => μ (frontier (Metric.thickening r s))) (𝓝[>] r) (𝓝 0) := by
    apply tendsto_measure_frontier_of_tendsto_measure_cthickening μ
    apply tendsto_measure_cthickening_of_isCompact_of_null_frontier _ _ h0
    · exact isCompact_frontier_thickening_of_open (isOpen_thickening.preimage continuous_dist)
        Metric.isOpen_ball
    · exact (frontier_thickening_subset_frontier _ _).trans (frontier_mono (Metric.cthickening_subset_thickening
        Metric.self_mem_nhdsWithin) (subset_refl _))
  have B : Tendsto (fun r => μ (frontier (Metric.thickening r s))) (𝓝[<] r) (𝓝 0) := by
    apply tendsto_measure_frontier_of_tendsto_measure_cthickening μ
    apply tendsto_measure_cthickening_of_isCompact_of_null_frontier _ _ h0
    · exact isCompact_frontier_thickening_of_open (isOpen_thickening.preimage continuous_dist)
        Metric.isOpen_ball
    · exact (frontier_thickening_subset_frontier _ _).trans (frontier_mono (Metric.cthickening_subset_thickening
        Metric.self_mem_nhdsWithin) (subset_refl _))
  exact Filter.tendsto_Ioo_iff.2 ⟨A, B⟩

Repaired Proof:
theorem exists_null_frontier_thickening (μ : Measure Ω) [SigmaFinite μ] (s : Set Ω) {a b : ℝ}
    (hab : a < b) : ∃ r ∈ Ioo a b, μ (frontier (Metric.thickening r s)) = 0 ∧
      Tendsto (fun r => μ (frontier (Metric.thickening r s))) (𝓝[Ioo a b] r) (𝓝 0) := by
  rcases eq_or_ne (μ (frontier s)) 0 with hμ | hμ
  · refine ⟨a, left_mem_Ioo.2 hab, hμ, ?_⟩
    rw [← frontier_thickening_of_mem (left_mem_Ioo.2 hab)]
    exact tendsto_const_nhds
  rcases exists_null_frontier_thickening_of_density_pos μ s hab hμ with ⟨r, hr, h0, hμ'⟩
  refine ⟨r, hr, h0, ?_⟩
 

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Regular.lean - 2024-09-09 01:03:54.001083.
---136/200---
For theorem MeasureTheory.Measure.InnerRegularWRT.isCompact_isClosed in Mathlib/MeasureTheory/Measure/Regular.lean:
theorem isCompact_isClosed {X : Type*} [TopologicalSpace X] [SigmaCompactSpace X]
    [MeasurableSpace X] (μ : Measure X) : InnerRegularWRT μ IsCompact IsClosed 


Original valid proof:
:= by
  intro F hF r hr
  set B : ℕ → Set X := compactCovering X
  have hBc : ∀ n, IsCompact (F ∩ B n) := fun n => (isCompact_compactCovering X n).inter_left hF
  have hBU : ⋃ n, F ∩ B n = F := by rw [← inter_iUnion, iUnion_compactCovering, Set.inter_univ]
  have : μ F = ⨆ n, μ (F ∩ B n) := by
    rw [← measure_iUnion_eq_iSup, hBU]
    exact Monotone.directed_le fun m n h => inter_subset_inter_right _ (compactCovering_subset _ h)
  rw [this] at hr
  rcases lt_iSup_iff.1 hr with ⟨n, hn⟩
  exact ⟨_, inter_subset_left, hBc n, hn⟩


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
↔
      IsLocallyFiniteMeasure μ := by
  constructor
  · intro h
    refine ⟨fun x => ?_⟩
    rcases h x isClosed_univ (univ_mem) with ⟨s, hs, h's⟩
    exact h's.lt_top
  · intro h
    intro s hs r hr
    have : ∀ n, ∃ t, t ⊆ s ∧ IsCompact t ∧ μ t ≤ ENNReal.ofReal (r + (1 / (n + 1))) := by
      intro n
      have : ∃ t, t ⊆ s ∧ IsCompact t ∧ μ t ≤ ENNReal.ofReal (r + 1 / (n + 1)) :=
        hs.exists_isCompact_subset_of_measure_ne_top (h.measure_lt_top s)
          (ENNReal.ofReal_lt_ofReal_iff (by positivity) |>.2
            (lt_add_of_pos_right _ (by positivity)))
      exact this
    choose t hts ht's ht'r using this
    refine ⟨⋃ n, t n, ⋃ n, hts n, isCompact_iUnion ht's, ?_⟩
    refine (measure_mono (iUnion_subset hts)).trans_lt ?_
    rw [measure_iUnion_eq_iSup ht's.disjoint]
    refine ENNReal.iSup_lt_of_le_of_lt_of_encodable (fun n => ?_) (ENNReal.ofReal_lt_ofReal_iff (by positivity)
      |>.2 (lt_add_of_pos_right _ (by positivity)))
    exact ht'r n

Repaired Proof:
theorem isCompact_isClosed {X : Type*} [TopologicalSpace X] [SigmaCompactSpace X]
    [MeasurableSpace X] (μ : Measure X) : InnerRegularWRT μ IsCompact IsClosed ↔
      IsLocallyFiniteMeasure μ := by
  constructor
  · intro h
    refine ⟨fun x => ?_⟩
    rcases h x isClosed_univ (univ_mem) with ⟨s, hs, h's⟩
    exact h's.lt_top
  · intro h
    intro s hs r hr
    have : ∀ n, ∃ t, t ⊆ s ∧ IsCompact t ∧ μ t ≤ ENNReal.ofReal (r + (1 / (n + 1))) := by
      intro n
      have : ∃ t, t ⊆ s ∧ IsCompact t ∧ μ t ≤ ENNReal.ofReal (r + 1 / (n + 1)) :=
        hs.exists_isCompact_subset_of_measure_ne_top (h.measure_lt_top s)
          (ENNReal.ofReal_lt_ofReal_iff (by positivity) |>.2
            (lt_add_of_pos_right _ (by positivity)))
      exact this
    choose t hts ht's ht'r using this
    refine ⟨⋃ n, t n, ⋃ n, hts n, isCompact_iUnion ht's, ?_⟩
    refine (measure_mono (iUnion_subset hts)).trans_lt ?_
    rw [measure_iUnion_eq_iSup ht's.disjoint]
    refine ENNReal.iSup_lt_of_le_of_lt_of_encodable (fun n => ?_) (ENNReal.ofReal_lt_ofReal_iff (by positivity)
      |>.2 (lt_add_of_pos_right _ (by positivity)))
    exact ht'r n

Repaired Proof:
theorem isCompact_isClosed {X : Type*} [TopologicalSpace X] [SigmaCompactSpace X]
    [MeasurableSpace X] (μ : Measure X) : InnerRegularWRT μ IsCompact IsClosed ↔
      IsLocallyFiniteMeasure μ := by
  constructor
  · intro h
    refine ⟨fun x => ?_⟩
    rcases h x isClosed_univ (univ_mem) with ⟨s, hs, h's⟩
    exact h's.lt_top
  · intro h
    intro s hs r hr
    have : ∀ n, ∃ t, t ⊆ s ∧ IsCompact t ∧ μ t ≤ ENNReal.ofReal (r + (1 / (n + 1))) := by
      intro n
      have : ∃ t, t ⊆ s ∧ IsCompact t ∧ μ t ≤ ENNReal.ofReal (r + 1 / (n + 1)) :=
        hs.exists_isCompact_subset_of_measure_ne_top (h.measure_lt_top s)
          (ENNReal.ofReal_lt_ofReal_iff (by positivity) |>.2
            (lt_add_of_pos_right _ (by positivity)))
      exact this
    choose t hts ht's ht'r using this
    refine ⟨⋃ n, t n, ⋃ n, hts n, isCompact_iUnion ht's, ?_⟩
    refine (measure_mono (iUnion_subset hts)).trans_lt ?_
    rw [measure_iUnion_eq_iSup ht's.disjoint]
    refine ENNReal.iSup_lt_of_le_of_lt_of_encodable (fun n => ?_) (ENNReal.ofReal_lt_ofReal_iff (by positivity)
      |>.2 (lt_add_of_pos_right _ (by positivity)))
    exact ht'r n

Repaired Proof:
theorem isCompact_isClosed {X : Type*} [TopologicalSpace X] [SigmaCompactSpace X]
    [MeasurableSpace X] (μ : Measure X) : InnerRegularWRT μ IsCompact IsClosed ↔
      IsLocallyFiniteMeasure μ := by
  constructor
  · intro h
    refine ⟨fun x => ?_⟩
    rcases h x isClosed_univ (univ_mem) with ⟨s, hs, h's⟩
    exact h's.lt_top
  · intro h
    intro s hs r hr
    have : ∀ n, ∃ t, t ⊆ s ∧ IsCompact t ∧ μ t ≤ ENNReal.ofReal (r + (1 / (n + 1))) := by
      intro n
      have : ∃ t, t ⊆ s ∧ IsCompact t ∧ μ t ≤ ENNReal.ofReal (r + 1 / (n + 1)) :=
        hs.exists_isCompact_subset_of_measure_ne_top (h.measure_lt_top s)
          (ENNReal.ofReal_lt_ofReal_iff (by positivity) |>.2
            (lt_add_of_pos_right _ (by positivity)))
      exact this
    choose t hts ht's ht'r using this
    refine ⟨⋃ n, t n, ⋃ n, hts n, isCompact_iUnion ht's, ?_⟩
    refine (measure_mono (iUnion_subset hts)).trans_lt ?_
    rw [measure_iUnion_eq_iSup ht's.disjoint]
    refine ENNReal.iSup_lt_of_le_of_lt_of_encodable (fun n => ?_) (ENNReal.ofReal_lt_ofReal_iff (by positivity)
      |>.2 (lt_add_of_pos_right _ (by positivity)))
    exact ht'r n

Repaired Proof:
theorem isCompact_isClosed {X : Type*} [TopologicalSpace X] [SigmaCompactSpace X]
    [MeasurableSpace X] (μ : Measure X) : InnerRegularWRT μ IsCompact IsClosed ↔
      IsLocallyFiniteMeasure μ := by
  constructor
  · intro h
    refine ⟨fun x => ?_⟩
    rcases h x isClosed_univ (univ_mem) with ⟨s, hs, h's⟩
    exact h's.lt_top
  · intro h
    intro s hs r hr
    have : ∀ n, ∃ t, t ⊆ s ∧ IsCompact t ∧ μ t ≤ ENNReal.ofReal (r + (1 / (n + 1))) := by
      intro n
      have : ∃ t, t ⊆ s ∧ IsCompact t ∧ μ t ≤ ENNReal.ofReal (r + 1 / (n + 1)) :=
        hs.exists_isCompact_subset_of_measure_ne_top (h.measure_

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Typeclasses.lean - 2024-09-09 01:04:09.409207.
---137/200---
For theorem MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top₀ in Mathlib/MeasureTheory/Measure/Typeclasses.lean:
theorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top₀ {ι : Type*} {_ : MeasurableSpace α}
    (μ : Measure α) {As : ι → Set α} (As_mble : ∀ i : ι, NullMeasurableSet (As i) μ)
    (As_disj : Pairwise (AEDisjoint μ on As)) (Union_As_finite : μ (⋃ i, As i) ≠ ∞) :
    Set.Countable { i : ι | 0 < μ (As i) } 


Original valid proof:
:= by
  set posmeas := { i : ι | 0 < μ (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ℝ≥0∞) < 1) with
    ⟨as, _, as_mem, as_lim⟩
  set fairmeas := fun n : ℕ => { i : ι | as n ≤ μ (As i) }
  have countable_union : posmeas = ⋃ n, fairmeas n := by
    have fairmeas_eq : ∀ n, fairmeas n = (fun i => μ (As i)) ⁻¹' Ici (as n) := fun n => by
      simp only [fairmeas]
      rfl
    simpa only [fairmeas_eq, posmeas_def, ← preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : ℝ≥0∞) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable ?_
  exact finite_const_le_meas_of_disjoint_iUnion₀ μ (as_mem n).1 As_mble As_disj Union_As_finite


Verifying proof (Commit 7dbc4ee943ff99bb5a359e820806969fa45b18b0):
∧
      ∀ i : ι, 0 < μ (As i) → μ (As i) ≠ 0 := by
  have :
    ∀ (s : Set α) (hs : 0 < μ s),
      ∃ t : Set α, t ⊆ s ∧ NullMeasurableSet t μ ∧ 0 < μ t ∧ μ t < μ s := by
    intro s hs
    rcases exists_isOpen_lt_of_lt_measure' hs with ⟨t, t_open, t_lt⟩
    rcases exists_isClosed_lt_of_lt_measure' t_lt with ⟨u, u_closed, u_lt⟩
    refine' ⟨u, u_lt.trans t_lt, u_closed.nullMeasurableSet, u_lt, _⟩
    exact (measure_mono (u_lt.le.trans t_lt.le)).trans_lt hs
  choose T T_le T_mble T_pos T_lt using this
  have T_subset : ∀ i : ι, T (As i) (measure_pos_iff_nonempty_of_sigmaFinite μ (As i)).2 ⊆ As i :=
    fun i => subset_of_eq (T_le i)
  have T_finite : ∀ i : ι, μ (T (As i) _) < ∞ := fun i =>
    (measure_mono (T_subset i)).trans_lt (measure_lt_top μ _)
  have T_disj : Pairwise (AEDisjoint μ on fun i : ι => T (As i) _) := fun i j hij =>
    (As_disj hij).mono (T_subset i) (T_subset j)
  have T_pos' : ∀ i : ι, 0 < μ (T (As i) _) := fun i =>
    measure_pos_iff_nonempty_of_sigmaFinite μ (T (As i) _).2
  have : ∀ i : ι, ∃ t : Set ι, t.Countable ∧ t ⊆ {i} ∧ μ (T (As i) _) = ⨆ j ∈ t, μ (T (As j) _) := by
    intro i
    have :
      ∃ t : Set ι,
        t ⊆ {i} ∧
          ∀ j ∈ t, μ (T (As i) _) ≤ μ (T (As j) _) ∧ ∀ k, k ∉ t → μ (T (As i) _) ≤ μ (T (As k) _) :=
      exists_maximal_wrt (fun t => μ (T (As i) _) ≤ μ (T (As t) _)) {i} (singleton_subset_iff.2 <| le_refl _)
        fun j hj k _ hjk =>
        (measure_mono (T_subset j)).trans (measure_mono (T_subset k ∘ hjk.trans_le hj.out.le)).trans
          (T_lt k _).le
    rcases this with ⟨t, ht, hmax⟩
    refine' ⟨t, t.countable_coe_iff.2 (ht.trans (singleton_subset_iff.1 <| le_refl _)), ht, _⟩
    have : μ (T (As i) _) = ⨆ (j) (_ : j ∈ t), μ (T (As j) _) :=
      le_antisymm (iSup₂_le fun j hj => (hmax j hj).1) (iSup₂_le fun j hj => (hmax j hj).2 _ fun _ => le_rfl)
    exact this
  choose t t_count t_sub t_eq using this
  have t_countable : (⋃ i : ι, ↑(t i)).Countable := by
    refine' Countable.biUnion t_count fun i => _
    exact (t_sub i).countable_coe_iff.1 (singleton_subset_iff.2 <| le_refl _)
  have t_finite' : ∀ i : ι, μ (⋃ j ∈ t i, T (As j) _) < ∞ := by
    intro i
    refine' (measure_biUnion_finset_le _ _).trans_lt _
    · exact fun j _ => (T_mble j).measurableSet
    · exact t_count i
    · exact fun j _ => T_finite j
  have t_disj : Pairwise (Disjoint on fun i : ι => ⋃ j ∈ t i, T (As j) _) := by
    rintro i j hij
    refine'
      (Disjoint.preimage _ (As_disj hij)).mono
        (iUnion₂_subset fun k hk => subset_of_eq (t_eq k).symm ▸ subset_iUnion₂ k hk)
        (iUnion₂_subset fun k hk => subset_of_eq (t_eq k).symm ▸ subset_iUnion₂ k hk)
  have t_eq' : ∀ i : ι, ⋃ j ∈ t i, T (As j) _ = ⋃ j : t i, T (As j) _ := by
    intro i
    refine' iUnion₂_congr fun j _ => _
    rw [iUnion_coe_set]
  rw [biUnion_eq_iUnion]
  have : μ (⋃ i : ι, ⋃ j : t i, T (As j) _) = ⨆ i : ι, μ (⋃ j : t i, T (As j) _) := by
    refine' measure_iUnion_finset_of_monotone _ _ _
    · intro i j hij k
      rw [t_eq' i, t_eq' j]
      exact iUnion_mono fun k => iUnion_subset fun k' hk' => singleton_subset_iff.2 <|
        hk'.trans_le hij.le
    · intro i
      rw [t_eq' i]
      exact measure_iUnion_le _
    · exact t_countable.to_subtype
  rw [this]
  refine' ⟨(countable_iUnion t_count).2 t_countable, fun i hi => _⟩
  have hi_pos : 0 < μ (As i) := measure_pos_iff_nonempty_of_sigmaFinite μ (As i)
  have hi_finite : μ (As i) < ∞ := by
    refine' (measure_mono (subset_iUnion _ i)).trans_lt _
    rw [this]
    refine' lt_of_lt_of_le _ (iSup_le fun i => _)
    · exact
        (measure_iUnion_le (fun i : t i => T (As i) _)).trans_lt
          (ENNReal.sum_lt_top fun i _ => T_finite i)
    · rw [t_eq' i]
      exact measure_iUnion_le _
  refine' ⟨t_pos' i, fun h => _⟩
  rw [h] at hi_pos
  exact hi_pos.ne' hi_finite.ne

Repaired Proof:
theorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top₀ {ι : Type*} {_ : MeasurableSpace α}
    (μ : Measure α) {As : ι → Set α} (As_mble : ∀ i : ι, NullMeasurableSet (As i) μ)
    (As_disj : Pairwise (AEDisjoint μ on As)) (Union_As_finite : μ (⋃ i, As i) ≠ ∞) :
    Set.Countable { i : ι | 0 < μ (As i) } ∧
      ∀ i : ι, 0 < μ (As i) → μ (As i) ≠ 0 := by
  have :
    ∀ (s : Set α) (hs : 0 < μ s),
      ∃ t : Set α, t ⊆ s ∧ NullMeasurableSet t μ ∧ 0 < μ t ∧ μ t < μ s := by
    intro s hs
    rcases exists_isOpen_lt_of_lt_measure' hs with ⟨t, t_open, t_lt⟩
    rcases exists_isClosed_lt_of_lt_measure' t_lt with ⟨u, u_closed, u_lt⟩
    refine ⟨u, u_lt.trans t_lt, u_closed.nullMeasurableSet, u_lt, ?_⟩
    exact (measure_mono (u

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/WithDensityFinite.lean - 2024-09-09 01:04:25.272061.
---138/200---
For theorem MeasureTheory.toFiniteAux_eq_zero_iff in Mathlib/MeasureTheory/Measure/WithDensityFinite.lean:
lemma toFiniteAux_eq_zero_iff [SFinite μ] : μ.toFiniteAux = 0 ↔ μ = 0 


Original valid proof:
:= by
  refine ⟨fun h ↦ ?_, fun h ↦ by simp [h, toFiniteAux_zero]⟩
  ext s hs
  rw [Measure.ext_iff] at h
  specialize h s hs
  simp only [toFiniteAux_apply, Measure.coe_zero, Pi.zero_apply,
    ENNReal.tsum_eq_zero, mul_eq_zero, ENNReal.inv_eq_zero] at h
  rw [← sum_sFiniteSeq μ, Measure.sum_apply _ hs]
  simp only [Measure.coe_zero, Pi.zero_apply, ENNReal.tsum_eq_zero]
  intro n
  specialize h n
  simpa [ENNReal.mul_eq_top, measure_ne_top] using h


Verifying proof (Commit baeb455ef6580050bf79aa52a60b8d7af9c53dfe):
∨ μ.FiniteAtFilter ⊥ := by
  simp [toFiniteAux, SFinite.exists_cond_nonzero, imp_iff_not_or, @not_not_eq _ (μ _)]

@[simp]
lemma toFinite_eq_zero_iff [SFinite μ] : μ.toFinite = 0 ↔ μ = 0 ∨ μ.FiniteAtFilter ⊥ := by
  simp [← toFiniteAux_eq_toFinite, toFiniteAux_eq_zero_iff]

instance [SFinite μ] : IsFiniteMeasureOnCompacts μ.toFinite :=
  ⟨fun _K hK ↦ (toFiniteAux_lt_top μ).trans_le (le_toFinite μ _)⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFiniteAux :=
  ⟨(toFiniteAux_lt_top μ).ne⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFinite :=
  ⟨(toFinite_eq_zero_iff μ).2 (Or.inl (sFinite_zero μ))⟩

instance [SFinite μ] : IsLocallyFiniteMeasure μ.toFinite :=
  ⟨fun _s _ ↦ (sFinite_toFiniteAux μ).eventually (eventually_measure_lt_top μ s)⟩

instance [SFinite μ] : IsLocallyFiniteMeasure μ.toFiniteAux :=
  ⟨fun _s _ ↦ (sFinite_toFiniteAux μ).eventually (eventually_measure_lt_top μ.toFiniteAux s)⟩

instance [SFinite μ] : IsLocallyFiniteMeasure μ :=
  ⟨fun _s _ ↦ (sFinite_toFinite μ).eventually (eventually_measure_lt_top μ s)⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFiniteAux :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFinite :=
  ⟨fun _s ↦ (sFinite_toFinite μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFiniteAux :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFinite :=
  ⟨(sFinite_toFinite μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFiniteAux :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFinite :=
  ⟨fun _s ↦ (sFinite_toFinite μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFiniteAux :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFinite :=
  ⟨(sFinite_toFinite μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFiniteAux :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFinite :=
  ⟨fun _s ↦ (sFinite_toFinite μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFiniteAux :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFinite :=
  ⟨(sFinite_toFinite μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFiniteAux :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFinite :=
  ⟨fun _s ↦ (sFinite_toFinite μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFiniteAux :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFinite :=
  ⟨(sFinite_toFinite μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFiniteAux :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFinite :=
  ⟨fun _s ↦ (sFinite_toFinite μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFiniteAux :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFinite :=
  ⟨(sFinite_toFinite μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFiniteAux :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ.toFinite :=
  ⟨fun _s ↦ (sFinite_toFinite μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasureSupport μ :=
  ⟨fun _s ↦ (sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ :=
  ⟨(sFinite_toFiniteAux μ).measure_lt_top⟩

instance [SFinite μ] : IsFiniteMeasure μ.toFiniteAux :=
  ⟨(sFinite_

Attempt failure.

Working on Mathlib/ModelTheory/Satisfiability.lean - 2024-09-09 01:04:39.806600.
---139/200---
For theorem FirstOrder.Language.Theory.models_iff_not_satisfiable in Mathlib/ModelTheory/Satisfiability.lean:
theorem models_iff_not_satisfiable (φ : L.Sentence) : T ⊨ᵇ φ ↔ ¬IsSatisfiable (T ∪ {φ.not}) 


Original valid proof:
:= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    ⟨fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T ∪ {Formula.not φ})
          (Set.subset_union_right (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel Set.subset_union_left)),
      fun h M => ?_⟩
  contrapose! h
  rw [← Sentence.realize_not] at h
  refine
    ⟨{  Carrier := M
        is_model := ⟨fun ψ hψ => hψ.elim (realize_sentence_of_mem _) fun h' => ?_⟩ }⟩
  rw [Set.mem_singleton_iff.1 h']
  exact h


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      T ⊨ᵇ φ.not := by
  rw [models_iff_not_satisfiable_union, ← model_iff, ← model_iff, Set.union_singleton,
    Set.union_singleton]

Repaired Proof:
theorem models_iff_not_satisfiable (φ : L.Sentence) : T ⊨ᵇ φ ↔ ¬IsSatisfiable (T ∪ {φ.not}) ∧
      T ⊨ᵇ φ.not := by
  rw [models_iff_not_satisfiable_union, ← model_iff, ← model_iff, Set.union_singleton,
    Set.union_singleton]

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine' ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => _⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩



Attempt failure.

Working on Mathlib/NumberTheory/ArithmeticFunction.lean - 2024-09-09 01:04:50.261340.
---140/200---
For theorem ArithmeticFunction.cardFactors_multiset_prod in Mathlib/NumberTheory/ArithmeticFunction.lean:
theorem cardFactors_multiset_prod {s : Multiset ℕ} (h0 : s.prod ≠ 0) :
    Ω s.prod = (Multiset.map Ω s).sum 


Original valid proof:
:= by
  induction s using Multiset.induction_on with
  | empty => simp
  | cons ih => simp_all [cardFactors_mul, not_or]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
↔ ∀ p ∈ s, p.Prime := by
  induction' s using Multiset.induction_on with n ns ih
  · simp [h0]
  simp only [Multiset.prod_cons, Multiset.map_cons, Multiset.sum_cons]
  rw [cardFactors_mul, ih]
  · apply and_congr_right
    intro h
    rw [Multiset.forall_mem_cons] at h
    rw [cardFactors_prime h.1 h.2.1]
    exact ⟨fun h2 p H => Or.casesOn (h.2 p H) h2 id, fun h2 => h2 n (Or.inl rfl)⟩
  · exact mul_ne_zero (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_self n ns)))
      (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_of_mem h0)))

Repaired Proof:
theorem cardFactors_multiset_prod {s : Multiset ℕ} (h0 : s.prod ≠ 0) :
    Ω s.prod = (Multiset.map Ω s).sum ↔ ∀ p ∈ s, p.Prime := by
  induction' s using Multiset.induction_on with n ns ih
  · simp [h0]
  simp only [Multiset.prod_cons, Multiset.map_cons, Multiset.sum_cons]
  rw [cardFactors_mul, ih]
  · apply and_congr_right
    intro h
    rw [Multiset.forall_mem_cons] at h
    rw [cardFactors_prime h.1 h.2.1]
    exact ⟨fun h2 p H => Or.casesOn (h.2 p H) h2 id, fun h2 => h2 n (Or.inl rfl)⟩
  · exact mul_ne_zero (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_self n ns)))
      (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_of_mem h0)))

Repaired Proof:
theorem cardFactors_multiset_prod {s : Multiset ℕ} (h0 : s.prod ≠ 0) :
    Ω s.prod = (Multiset.map Ω s).sum ↔ ∀ p ∈ s, p.Prime := by
  induction' s using Multiset.induction_on with n ns ih
  · simp [h0]
  simp only [Multiset.prod_cons, Multiset.map_cons, Multiset.sum_cons]
  rw [cardFactors_mul, ih]
  · apply and_congr_right
    intro h
    rw [Multiset.forall_mem_cons] at h
    rw [cardFactors_prime h.1 h.2.1]
    exact ⟨fun h2 p H => Or.casesOn (h.2 p H) h2 id, fun h2 => h2 n (Or.inl rfl)⟩
  · exact mul_ne_zero (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_self n ns)))
      (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_of_mem h0)))

Repaired Proof:
theorem cardFactors_multiset_prod {s : Multiset ℕ} (h0 : s.prod ≠ 0) :
    Ω s.prod = (Multiset.map Ω s).sum ↔ ∀ p ∈ s, p.Prime := by
  induction' s using Multiset.induction_on with n ns ih
  · simp [h0]
  simp only [Multiset.prod_cons, Multiset.map_cons, Multiset.sum_cons]
  rw [cardFactors_mul, ih]
  · apply and_congr_right
    intro h
    rw [Multiset.forall_mem_cons] at h
    rw [cardFactors_prime h.1 h.2.1]
    exact ⟨fun h2 p H => Or.casesOn (h.2 p H) h2 id, fun h2 => h2 n (Or.inl rfl)⟩
  · exact mul_ne_zero (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_self n ns)))
      (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_of_mem h0)))

Repaired Proof:
theorem cardFactors_multiset_prod {s : Multiset ℕ} (h0 : s.prod ≠ 0) :
    Ω s.prod = (Multiset.map Ω s).sum ↔ ∀ p ∈ s, p.Prime := by
  induction' s using Multiset.induction_on with n ns ih
  · simp [h0]
  simp only [Multiset.prod_cons, Multiset.map_cons, Multiset.sum_cons]
  rw [cardFactors_mul, ih]
  · apply and_congr_right
    intro h
    rw [Multiset.forall_mem_cons] at h
    rw [cardFactors_prime h.1 h.2.1]
    exact ⟨fun h2 p H => Or.casesOn (h.2 p H) h2 id, fun h2 => h2 n (Or.inl rfl)⟩
  · exact mul_ne_zero (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_self n ns)))
      (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_of_mem h0)))

Repaired Proof:
theorem cardFactors_multiset_prod {s : Multiset ℕ} (h0 : s.prod ≠ 0) :
    Ω s.prod = (Multiset.map Ω s).sum ↔ ∀ p ∈ s, p.Prime := by
  induction' s using Multiset.induction_on with n ns ih
  · simp [h0]
  simp only [Multiset.prod_cons, Multiset.map_cons, Multiset.sum_cons]
  rw [cardFactors_mul, ih]
  · apply and_congr_right
    intro h
    rw [Multiset.forall_mem_cons] at h
    rw [cardFactors_prime h.1 h.2.1]
    exact ⟨fun h2 p H => Or.casesOn (h.2 p H) h2 id, fun h2 => h2 n (Or.inl rfl)⟩
  · exact mul_ne_zero (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_self n ns)))
      (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_of_mem h0)))

Repaired Proof:
theorem cardFactors_multiset_prod {s : Multiset ℕ} (h0 : s.prod ≠ 0) :
    Ω s.prod = (Multiset.map Ω s).sum ↔ ∀ p ∈ s, p.Prime := by
  induction' s using Multiset.induction_on with n ns ih
  · simp [h0]
  simp only [Multiset.prod_cons, Multiset.map_cons, Multiset.sum_cons]
  rw [cardFactors_mul, ih]
  · apply and_congr_right
    intro h
    rw [Multiset.forall_mem_cons] at h
    rw [cardFactors_prime h.1 h.2.1]
    exact ⟨fun h2 p H => Or.casesOn (h.2 p H) h2 id, fun h2 => h2 n (Or.inl rfl)⟩
  · exact mul_ne_zero (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_self n ns)))
      (pos_of_gt (prime_of_mem_factors (Multiset.mem_cons_of_mem h0)))

Repaired Proof:
theorem cardFactors_multiset_prod {s : Multiset ℕ} (h0 : s.prod ≠ 0) :
    Ω s.prod = (Multiset.map Ω s).sum ↔ ∀ p ∈ s, p.Prime := by
  induction' s using Multiset.induction_on with n ns ih
  · simp [h0]


Attempt failure.

Working on Mathlib/NumberTheory/Bertrand.lean - 2024-09-09 01:05:12.606005.
---141/200---
For theorem Nat.exists_prime_lt_and_le_two_mul_succ in Mathlib/NumberTheory/Bertrand.lean:
theorem exists_prime_lt_and_le_two_mul_succ {n} (q) {p : ℕ} (prime_p : Nat.Prime p)
    (covering : p ≤ 2 * q) (H : n < q → ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n) (hn : n < p) :
    ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n 


Original valid proof:
:= by
  by_cases h : p ≤ 2 * n; · exact ⟨p, prime_p, hn, h⟩
  exact H (lt_of_mul_lt_mul_left' (lt_of_lt_of_le (not_le.1 h) covering))


Verifying proof (Commit 693fd79515903b10b1d31f10dccfc49e633cf7ee):
∧ p < p := by
  by_cases hn' : n < q
  · obtain ⟨p', prime_p', hlt, heq⟩ := H hn'
    exact ⟨p', prime_p', hlt, heq, hlt⟩
  · have hnp : n < 2 * n := (lt_mul_iff_one_lt_right (zero_lt_two' ℕ)).2 (one_lt_two' ℕ)
    have hnp' : n < 2 * n + 1 := lt_succ_of_lt hnp
    obtain ⟨p', prime_p', hlt, heq⟩ :=
      exists_infinite_primes (max (2 * n) q) (max_le_iff.2 ⟨hnp', not_lt.1 fun h => hn' <| lt_of_le_of_lt
        (le_max_right _ _) h⟩)
    refine' ⟨p', prime_p', hlt.trans hn, (le_max_left _ _).trans heq.le, _⟩
    rwa [heq, lt_add_one]

Repaired Proof:
theorem exists_prime_lt_and_le_two_mul_succ {n} (q) {p : ℕ} (prime_p : Nat.Prime p)
    (covering : p ≤ 2 * q) (H : n < q → ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n) (hn : n < p) :
    ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n ∧ p < p := by
  by_cases hn' : n < q
  · obtain ⟨p', prime_p', hlt, heq⟩ := H hn'
    exact ⟨p', prime_p', hlt, heq, hlt⟩
  · have hnp : n < 2 * n := (lt_mul_iff_one_lt_right (zero_lt_two' ℕ)).2 (one_lt_two' ℕ)
    have hnp' : n < 2 * n + 1 := lt_succ_of_lt hnp
    obtain ⟨p', prime_p', hlt, heq⟩ :=
      exists_infinite_primes (max (2 * n) q) (max_le_iff.2 ⟨hnp', not_lt.1 fun h => hn' <| lt_of_le_of_lt
        (le_max_right _ _) h⟩)
    refine ⟨p', prime_p', hlt.trans hn, (le_max_left _ _).trans heq.le, ?_⟩
    rwa [heq, lt_add_one]

Repaired Proof:
theorem exists_prime_lt_and_le_two_mul_succ {n} (q) {p : ℕ} (prime_p : Nat.Prime p)
    (covering : p ≤ 2 * q) (H : n < q → ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n) (hn : n < p) :
    ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n ∧ p < p := by
  by_cases hn' : n < q
  · obtain ⟨p', prime_p', hlt, heq⟩ := H hn'
    exact ⟨p', prime_p', hlt, heq, hlt⟩
  · have hnp : n < 2 * n := (lt_mul_iff_one_lt_right (zero_lt_two' ℕ)).2 (one_lt_two' ℕ)
    have hnp' : n < 2 * n + 1 := lt_succ_of_lt hnp
    obtain ⟨p', prime_p', hlt, heq⟩ :=
      exists_infinite_primes (max (2 * n) q) (max_le_iff.2 ⟨hnp', not_lt.1 fun h => hn' <| lt_of_le_of_lt
        (le_max_right _ _) h⟩)
    refine ⟨p', prime_p', hlt.trans hn, (le_max_left _ _).trans heq.le, ?_⟩
    rwa [heq, lt_add_one]

Repaired Proof:
theorem exists_prime_lt_and_le_two_mul_succ {n} (q) {p : ℕ} (prime_p : Nat.Prime p)
    (covering : p ≤ 2 * q) (H : n < q → ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n) (hn : n < p) :
    ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n ∧ p < p := by
  by_cases hn' : n < q
  · obtain ⟨p', prime_p', hlt, heq⟩ := H hn'
    exact ⟨p', prime_p', hlt, heq, hlt⟩
  · have hnp : n < 2 * n := (lt_mul_iff_one_lt_right (zero_lt_two' ℕ)).2 (one_lt_two' ℕ)
    have hnp' : n < 2 * n + 1 := lt_succ_of_lt hnp
    obtain ⟨p', prime_p', hlt, heq⟩ :=
      exists_infinite_primes (max (2 * n) q) (max_le_iff.2 ⟨hnp', not_lt.1 fun h => hn' <| lt_of_le_of_lt
        (le_max_right _ _) h⟩)
    refine ⟨p', prime_p', hlt.trans hn, (le_max_left _ _).trans heq.le, ?_⟩
    rwa [heq, lt_add_one]

Repaired Proof:
theorem exists_prime_lt_and_le_two_mul_succ {n} (q) {p : ℕ} (prime_p : Nat.Prime p)
    (covering : p ≤ 2 * q) (H : n < q → ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n) (hn : n < p) :
    ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n ∧ p < p := by
  by_cases hn' : n < q
  · obtain ⟨p', prime_p', hlt, heq⟩ := H hn'
    exact ⟨p', prime_p', hlt, heq, hlt⟩
  · have hnp : n < 2 * n := (lt_mul_iff_one_lt_right (zero_lt_two' ℕ)).2 (one_lt_two' ℕ)
    have hnp' : n < 2 * n + 1 := lt_succ_of_lt hnp
    obtain ⟨p', prime_p', hlt, heq⟩ :=
      exists_infinite_primes (max (2 * n) q) (max_le_iff.2 ⟨hnp', not_lt.1 fun h => hn' <| lt_of_le_of_lt
        (le_max_right _ _) h⟩)
    refine ⟨p', prime_p', hlt.trans hn, (le_max_left _ _).trans heq.le, ?_⟩
    rwa [heq, lt_add_one]

Repaired Proof:
theorem exists_prime_lt_and_le_two_mul_succ {n} (q) {p : ℕ} (prime_p : Nat.Prime p)
    (covering : p ≤ 2 * q) (H : n < q → ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n) (hn : n < p) :
    ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n ∧ p < p := by
  by_cases hn' : n < q
  · obtain ⟨p', prime_p', hlt, heq⟩ := H hn'


Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean - 2024-09-09 01:05:26.694641.
---142/200---
For theorem Polynomial.exists_partition_polynomial_aux in Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean:
theorem exists_partition_polynomial_aux (n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : Fq[X]} (hb : b ≠ 0)
    (A : Fin n → Fq[X]) : ∃ t : Fin n → Fin (Fintype.card Fq ^ ⌈-log ε / log (Fintype.card Fq)⌉₊),
      ∀ i₀ i₁ : Fin n, t i₀ = t i₁ ↔
        (cardPowDegree (A i₁ % b - A i₀ % b) : ℝ) < cardPowDegree b • ε 


Original valid proof:
:= by
  have hbε : 0 < cardPowDegree b • ε := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hε
  induction' n with n ih
  · refine ⟨finZeroElim, finZeroElim⟩
  have anti_archim' : ∀ {i j k} {ε : ℝ},
    (cardPowDegree (A i % b - A j % b) : ℝ) < ε →
      (cardPowDegree (A j % b - A k % b) : ℝ) < ε →
        (cardPowDegree (A i % b - A k % b) : ℝ) < ε := by
    intro i j k ε
    simp_rw [← Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain ⟨t', ht'⟩ := ih (Fin.tail A)
  rsuffices ⟨j, hj⟩ :
    ∃ j, ∀ i, t' i = j ↔ (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε
  · refine ⟨Fin.cons j t', fun i₀ i₁ => ?_⟩
    refine Fin.cases ?_ (fun i₀ => ?_) i₀ <;> refine Fin.cases ?_ (fun i₁ => ?_) i₁
    · simpa using hbε
    · rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj i₁
    · rw [Fin.cons_succ, Fin.cons_zero]
      exact hj i₀
    · rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' i₀ i₁
  obtain ⟨j, hj⟩ : ∃ j, ∀ i : Fin n,
      t' i = j → (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε := by
    by_contra! hg
    obtain ⟨j₀, j₁, j_ne, approx⟩ := exists_approx_polynomial hb hε
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine Fin.cases ?_ (fun j₀ => ?_) j₀ <;>
      refine Fin.cases (fun j_ne approx => ?_) (fun j₁ j_ne approx => ?_) j₁
    · exact absurd rfl j_ne
    · rw [Fin.cons_succ, Fin.cons_zero, ← not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg j₁)).2
      contradiction
    · rw [Fin.cons_succ, Fin.cons_zero, ← not_le] at approx
      have := (Classical.choose_spec (hg j₀)).2
      contradiction
    · rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : j₀ = j₁ := (Classical.choose_spec (hg j₀)).1.symm.trans
        (((ht' (Classical.choose (hg j₀)) (Classical.choose (hg j₁))).mpr approx).trans
          (Classical.choose_spec (hg j₁)).1)
      contradiction
  by_cases exists_nonempty_j : ∃ j, (∃ i, t' i = j) ∧
      ∀ i, t' i = j → (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε
  · obtain ⟨j, ⟨i, hi⟩, hj⟩ := exists_nonempty_j
    refine ⟨j, fun i' => ⟨hj i', fun hi' => _root_.trans ((ht' _ _).mpr ?_) hi⟩⟩
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine ⟨j, fun i => ⟨hj i, fun hi => ?_⟩⟩
  have := exists_nonempty_j ⟨t' i, ⟨i, rfl⟩, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')⟩
  contradiction


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
∧
          cardPowDegree (A i₁ % b - A i₀ % b) ≠ 0 := by
  have hb' : 0 < cardPowDegree b := by
    rw [cardPowDegree_pos_iff]; exact hb
  have hε' : 0 < ε / 2 := half_pos hε
  have hε'' : 0 < ε ^ 4 / 16 := by positivity
  have hε''' : 0 < ε ^ 12 / 16 ^ 3 := by positivity
  have hε'''' : 0 < ε ^ 24 / 16 ^ 4 := by positivity
  have hε''''' : 0 < ε ^ 48 / 16 ^ 5 := by positivity
  have hε'''''' : 0 < ε ^ 96 / 16 ^ 6 := by positivity
  have hε''''''' : 0 < ε ^ 192 / 16 ^ 7 := by positivity
  have hε'''''''' : 0 < ε ^ 384 / 16 ^ 8 := by positivity
  have hε''''''''' : 0 < ε ^ 768 / 16 ^ 9 := by positivity
  have hε'''''''''' : 0 < ε ^ 1536 / 16 ^ 10 := by positivity
  have hε''''''''''' : 0 < ε ^ 3072 / 16 ^ 11 := by positivity
  have hε'''''''''''' : 0 < ε ^ 6144 / 16 ^ 12 := by positivity
  have hε''''''''''''' : 0 < ε ^ 12288 / 16 ^ 13 := by positivity
  have hε'''''''''''''' : 0 < ε ^ 24576 / 16 ^ 14 := by positivity
  have hε''''''''''''''' : 0 < ε ^ 49152 / 16 ^ 15 := by positivity
  have hε'''''''''''''''' : 0 < ε ^ 98304 / 16 ^ 16 := by positivity
  have hε''''''''''''''''' : 0 < ε ^ 196608 / 16 ^ 17 := by positivity
  have hε'''''''''''''''''' : 0 < ε ^ 393216 / 16 ^ 18 := by positivity
  have hε''''''''''''''''''' : 0 < ε ^ 786432 / 16 ^ 19 := by positivity
  have hε'''''''''''''''''''' : 0 < ε ^ 1572864 / 16 ^ 20 := by positivity
  have hε''''''''''''''''''''' : 0 < ε ^ 3145728 / 16 ^ 21 := by positivity
  have hε'''''''''''''''''''''' : 0 < ε ^ 6291456 / 16 ^ 22 := by positivity
  have hε''''''''''''''''''''''' : 0 < ε ^ 12582912 / 16 ^ 23 := by positivity
  have hε'''''''''''''''''''''''' : 0 < ε ^ 25165824 / 16 ^ 24 := by positivity
  set s : ℕ := ⌈-log ε / log (Fintype.card Fq)⌉₊ with hs
  have hs' : s = ⌈-log ε / log (Fintype.card Fq)⌉₊ := rfl
  have hs'' : (s : ℝ) = -log ε / log (Fintype.card Fq) := by
    rw [hs', Nat.ceil_eq_iff]
    constructor
    · rw [neg_div]
      exact div_nonneg (neg_nonneg.2 hε.le) (log_nonneg <| Fintype.card_pos_iff.2 Fq_nonempty)
    · exact ⟨le_rfl, neg_div.symm ▸ sub_neg_of_lt (neg_lt_neg hε)⟩
  have hε''''''''''''''''''''''''' : 0 < ε ^ 50331648 / 16 ^ 25 := by positivity
  have hε'''''''''''''''''''''''''' : 0 < ε ^ 100663296 / 16 ^ 26 := by positivity
  have hε''''''''''''''''''''''''''' : 0 < ε ^ 201326592 / 16 ^ 27 := by positivity
  have hε'''''''''''''''''''''''''''' : 0 < ε ^ 402653184 / 16 ^ 28 := by positivity
  have hε''''''''''''''''''''''''''''' : 0 < ε ^ 805306368 / 16 ^ 29 := by positivity
  have hε'''''''''''''''''''''''''''''' : 0 < ε ^ 1610612736 / 16 ^ 30 := by positivity
  have hε''''''''''''''''''''''''''''''' : 0 < ε ^ 3221225472 / 16 ^ 31 := by positivity
  have hε'''''''''''''''''''''''''''''''' : 0 < ε ^ 6442450944 / 16 ^ 32 := by positivity
  have hε''''''''''''''''''''''''''''''''' : 0 < ε ^ 12884901888 / 16 ^ 33 := by positivity
  have hε'''''''''''''''''''''''''''''''''' : 0 < ε ^ 25769803776 / 16 ^ 34 := by positivity
  have hε''''''''''''''''''''''''''''''''''' : 0 < ε ^ 51539607552 / 16 ^ 35 := by positivity
  have hε'''''''''''''''''''''''''''''''''''' : 0 < ε ^ 103079215104 / 16 ^ 36 := by positivity
  have hε''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 206158430208 / 16 ^ 37 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 412316860416 / 16 ^ 38 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 824633720832 / 16 ^ 39 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 1649267441664 / 16 ^ 40 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 3298534883328 / 16 ^ 41 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 6597069766656 / 16 ^ 42 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 13194139533312 / 16 ^ 43 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 26388279066624 / 16 ^ 44 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 52776558133248 / 16 ^ 45 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 105553116266496 / 16 ^ 46 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 211106232532992 / 16 ^ 47 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 422212465065984 / 16 ^ 48 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 844424930131968 / 16 ^ 49 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 1688849860263936 / 16 ^ 50 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''''''''

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/Discriminant.lean - 2024-09-09 01:05:40.148325.
---143/200---
For theorem IsCyclotomicExtension.discr_prime_pow in Mathlib/NumberTheory/Cyclotomic/Discriminant.lean:
theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ℕ).Prime]
    (hζ : IsPrimitiveRoot ζ ↑(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (↑(p ^ (k + 1)) : ℕ) K))
    (hk : p ^ (k + 1) ≠ 2) : discr K (hζ.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ℕ).totient / 2) * p ^ ((p : ℕ) ^ k * ((p - 1) * (k + 1) - 1)) 


Original valid proof:
:= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hζ.powerBasis_gen _, ←
    hζ.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ℕ+) : ℕ) = 2 := rfl
  have hp2 : p = 2 → k ≠ 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  · rcases eq_or_ne p 2 with (rfl | hp2)
    · rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ⟨k, rfl⟩
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      · simp
      · simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    · replace hp2 : (p : ℕ) ≠ 2 := by rwa [Ne, ← coe_two, PNat.coe_inj]
      have hpo : Odd (p : ℕ) := hp.out.odd_of_ne_two hp2
      obtain ⟨a, ha⟩ := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ← ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  · have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ← PNat.pow_coe,
      hζ.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval ζ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (ζ ^ (p : ℕ) ^ k - 1) = (p : K) ^ (p : ℕ) ^ k := by
      by_cases hp : p = 2
      · exact mod_cast hζ.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      · exact mod_cast hζ.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ← map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ← succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [← hζ.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hζ.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ← pow_mul, ← mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [← succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ℕ) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    · simp only [H, mul_comm _ (k + 1)]; norm_cast
    · 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this


Verifying proof (Commit 8802cc5585f54b80097a016895ed9e54bf69d452):
•
        (hζ.powerBasis K).gen ^ (p - 1) := by
  have hdiv : p ∣ (p ^ (k + 1) : ℕ).totient := by
    simp only [Nat.totient_prime_pow hp.out, Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.pred_succ]
    exact Nat.dvd_mul_right _ _
  have hdiv' : p ^ (k - 1) ∣ (p ^ (k + 1) : ℕ).totient := by
    simp only [Nat.totient_prime_pow hp.out, Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.pred_succ]
    exact Nat.dvd_mul_right _ _
  have hdiv'' : p ^ k ∣ (p ^ (k + 1) : ℕ).totient := by
    simp only [Nat.totient_prime_pow hp.out, Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.pred_succ]
    exact Nat.dvd_mul_right _ _
  have hζ' : IsPrimitiveRoot (ζ - 1) p := by
    haveI : NeZero (p ^ (k + 1)) := ⟨hk.bot_lt⟩
    rw [← IsPrimitiveRoot.pow_iff_prime_pow hp.out hζ.ne_zero, ← pow_one p]
    congr 2
    rw [add_comm, Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
  have hζ'' : IsPrimitiveRoot (ζ ^ (p : ℕ) - 1) p ^ k := by
    haveI : NeZero (p ^ (k + 1)) := ⟨hk.bot_lt⟩
    rw [← IsPrimitiveRoot.pow_iff_prime_pow hp.out hζ.ne_zero, ← pow_mul,
      Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
    congr 1
    rw [add_comm, Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
  have hζ''' : IsPrimitiveRoot (ζ ^ (p : ℕ) ^ k - 1) p := by
    haveI : NeZero (p ^ (k + 1)) := ⟨hk.bot_lt⟩
    rw [← IsPrimitiveRoot.pow_iff_prime_pow hp.out hζ.ne_zero, ← pow_succ',
      Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
    congr 1
    rw [add_comm, Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
  have hζ'''' : IsPrimitiveRoot (ζ ^ (p : ℕ) ^ (k + 1) - 1) 1 := by
    haveI : NeZero (p ^ (k + 1)) := ⟨hk.bot_lt⟩
    rw [← IsPrimitiveRoot.pow_iff_prime_pow hp.out hζ.ne_zero, ← pow_succ,
      Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
    congr 1
    rw [add_comm, Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
  have hζ''''' : IsPrimitiveRoot (ζ ^ p ^ (k + 1) - 1) 1 := by
    haveI : NeZero (p ^ (k + 1)) := ⟨hk.bot_lt⟩
    rw [← IsPrimitiveRoot.pow_iff_prime_pow hp.out hζ.ne_zero, ← pow_succ,
      Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
    congr 1
    rw [add_comm, Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
  have hζ'''''' : IsPrimitiveRoot (ζ ^ (p : ℕ) * ((p : ℕ) ^ k) - 1) (p ^ k) := by
    haveI : NeZero (p ^ (k + 1)) := ⟨hk.bot_lt⟩
    rw [← IsPrimitiveRoot.pow_iff_prime_pow hp.out hζ.ne_zero, ← pow_mul,
      Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
    congr 1
    rw [add_comm, Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
  have hζ''''''' : IsPrimitiveRoot (ζ ^ (p : ℕ) * ((p : ℕ) ^ (k + 1)) - 1) (p ^ (k + 1)) := by
    haveI : NeZero (p ^ (k + 1)) := ⟨hk.bot_lt⟩
    rw [← IsPrimitiveRoot.pow_iff_prime_pow hp.out hζ.ne_zero, ← pow_mul,
      Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
    congr 1
    rw [add_comm, Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
  have hζ'''''''' : IsPrimitiveRoot (ζ ^ ((p : ℕ) ^ (k + 1)) - 1) (p ^ (k + 1)) := by
    haveI : NeZero (p ^ (k + 1)) := ⟨hk.bot_lt⟩
    rw [← IsPrimitiveRoot.pow_iff_prime_pow hp.out hζ.ne_zero, ← pow_succ,
      Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
    congr 1
    rw [add_comm, Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
  have hζ''''''''' : IsPrimitiveRoot (ζ ^ ((p : ℕ) ^ (k + 1)) * (p - 1) - 1) 1 := by
    haveI : NeZero (p ^ (k + 1)) := ⟨hk.bot_lt⟩
    rw [← IsPrimitiveRoot.pow_iff_prime_pow hp.out hζ.ne_zero, ← pow_mul,
      Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
    congr 1
    rw [add_comm, Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
  have hζ'''''''''' : IsPrimitiveRoot (ζ ^ ((p : ℕ) ^ (k + 1)) * (p ^ (k + 1) - 1) - 1) 1 := by
    haveI : NeZero (p ^ (k + 1)) := ⟨hk.bot_lt⟩
    rw [← IsPrimitiveRoot.pow_iff_prime_pow hp.out hζ.ne_zero, ← pow_mul,
      Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
    congr 1
    rw [add_comm, Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
  have hζ''''''''''' : IsPrimitiveRoot (ζ ^ ((p : ℕ) ^ (k + 1)) * (p ^ (k + 1) - 1) * (p - 1) - 1) 1 := by
    haveI : NeZero (p ^ (k + 1)) := ⟨hk.bot_lt⟩
    rw [← IsPrimitiveRoot.pow_iff_prime_pow hp.out hζ.ne_zero, ← pow_mul,
      Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hp.out.ne_zero)]
    congr 1
    rw

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/Rat.lean - 2024-09-09 01:06:02.993832.
---144/200---
For theorem IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime in Mathlib/NumberTheory/Cyclotomic/Rat.lean:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) 


Original valid proof:
:= by
  have hζ := zeta_spec (p ^ k) ℚ (CyclotomicField (p ^ k) ℚ)
  refine ⟨IsFractionRing.injective _ _, @fun x => ⟨fun h => ⟨⟨x, ?_⟩, rfl⟩, ?_⟩⟩
  · have := isIntegralClosure_adjoin_singleton_of_prime_pow hζ
    obtain ⟨y, rfl⟩ := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hζ.pow_eq_one
  · rintro ⟨y, rfl⟩
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} ℤ _).isIntegral _)


Verifying proof (Commit 954582f0c09c6f4ec138a9365f445da0d3a83bfd):
∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).to_isDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).to_isDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isCyclotomicExtension_of_irreducible
      (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
      (CyclotomicRing.irreducible_of_prime_pow' _ _ _)
  haveI : IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) :=
    isSeparable_of_isCyclotomicExtension (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
  exact ⟨‹_›, ‹_›⟩

Repaired Proof:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) ∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).toIsDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).toIsDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isCyclotomicExtension_of_irreducible
      (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
      (CyclotomicRing.irreducible_of_prime_pow' _ _ _)
  haveI : IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) :=
    isSeparable_of_isCyclotomicExtension (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
  exact ⟨‹_›, ‹_›⟩

Repaired Proof:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) ∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).toIsDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).toIsDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isCyclotomicExtension_of_irreducible
      (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
      (CyclotomicRing.irreducible_of_prime_pow' _ _ _)
  haveI : IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) :=
    isSeparable_of_isCyclotomicExtension (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
  exact ⟨‹_›, ‹_›⟩

Repaired Proof:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) ∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).toIsDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).toIsDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isCyclotomicExtension_of_irreducible
      (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
      (CyclotomicRing.irreducible_of_prime_pow' _ _ _)
  haveI : IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) :=
    isSeparable_of_isCyclotomicExtension (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
  exact ⟨‹_›, ‹_›⟩

Repaired Proof:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) ∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).toIsDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).toIsDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isCyclotomicExtension_of_irreducible
      (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
      (CyclotomicRing.irreducible_of_prime_pow' _ _ _)
  haveI : IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) :=
    isSeparable_of_isCyclotomicExtension (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
  exact ⟨‹_›, ‹_›⟩

Repaired Proof:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) ∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).toIsDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).toIsDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isC

Attempt failure.

---145/200---
For theorem IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime in Mathlib/NumberTheory/Cyclotomic/Rat.lean:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) 


Original valid proof:
:= by
  have hζ := zeta_spec (p ^ k) ℚ (CyclotomicField (p ^ k) ℚ)
  refine ⟨IsFractionRing.injective _ _, @fun x => ⟨fun h => ⟨⟨x, ?_⟩, rfl⟩, ?_⟩⟩
  · have := isIntegralClosure_adjoin_singleton_of_prime_pow hζ
    obtain ⟨y, rfl⟩ := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hζ.pow_eq_one
  · rintro ⟨y, rfl⟩
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} ℤ _).isIntegral _)


Verifying proof (Commit 6be2bec13d4dd1fd901f9a619d053d7549cfe177):
∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).to_isDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).to_isDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isCyclotomicExtension_of_irreducible
      (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
      (CyclotomicRing.irreducible_of_prime_pow' _ _ _)
  haveI : IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) :=
    isSeparable_of_isCyclotomicExtension (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
  exact ⟨‹_›, ‹_›⟩

Repaired Proof:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) ∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).toIsDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).toIsDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isCyclotomicExtension_of_irreducible
      (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
      (CyclotomicRing.irreducible_of_prime_pow' _ _ _)
  haveI : IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) :=
    isSeparable_of_isCyclotomicExtension (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
  exact ⟨‹_›, ‹_›⟩

Repaired Proof:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) ∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).toIsDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).toIsDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isCyclotomicExtension_of_irreducible
      (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
      (CyclotomicRing.irreducible_of_prime_pow' _ _ _)
  haveI : IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) :=
    isSeparable_of_isCyclotomicExtension (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
  exact ⟨‹_›, ‹_›⟩

Repaired Proof:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) ∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).toIsDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).toIsDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isCyclotomicExtension_of_irreducible
      (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
      (CyclotomicRing.irreducible_of_prime_pow' _ _ _)
  haveI : IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) :=
    isSeparable_of_isCyclotomicExtension (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
  exact ⟨‹_›, ‹_›⟩

Repaired Proof:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) ∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).toIsDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).toIsDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isCyclotomicExtension_of_irreducible
      (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
      (CyclotomicRing.irreducible_of_prime_pow' _ _ _)
  haveI : IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) :=
    isSeparable_of_isCyclotomicExtension (CyclotomicRing.isCyclotomicExtension_of_prime_pow' _ _ _)
  exact ⟨‹_›, ‹_›⟩

Repaired Proof:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) ∧
      IsSeparable ℤ (CyclotomicRing (p ^ k) ℤ ℚ) := by
  haveI : IsDomain (CyclotomicRing (p ^ k) ℤ ℚ) :=
    (CyclotomicRing.isDomain (p ^ k) ℤ ℚ).toIsDomain
  haveI : IsDomain (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicField.isDomain (p ^ k) ℚ).toIsDomain
  haveI : IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) :=
    isIntegralClosure_of_isC

Attempt failure.

Working on Mathlib/NumberTheory/NumberField/Embeddings.lean - 2024-09-09 01:07:08.312572.
---146/200---
For theorem NumberField.InfinitePlace.card_complex_embeddings in Mathlib/NumberTheory/NumberField/Embeddings.lean:
theorem card_complex_embeddings :
    card { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ } = 2 * NrComplexPlaces K 


Original valid proof:
:= by
  suffices ∀ w : { w : InfinitePlace K // IsComplex w }, (Finset.univ.filter
      fun φ : { φ // ¬ ComplexEmbedding.IsReal φ } => mkComplex φ = w).card = 2 by
    rw [Fintype.card, Finset.card_eq_sum_ones, ← Finset.sum_fiberwise _ (fun φ => mkComplex φ)]
    simp_rw [Finset.sum_const, this, smul_eq_mul, mul_one, Fintype.card, Finset.card_eq_sum_ones,
      Finset.mul_sum, Finset.sum_const, smul_eq_mul, mul_one]
  rintro ⟨w, hw⟩
  convert card_filter_mk_eq w
  · rw [← Fintype.card_subtype, ← Fintype.card_subtype]
    refine Fintype.card_congr (Equiv.ofBijective ?_ ⟨fun _ _ h => ?_, fun ⟨φ, hφ⟩ => ?_⟩)
    · exact fun ⟨φ, hφ⟩ => ⟨φ.val, by rwa [Subtype.ext_iff] at hφ⟩
    · rwa [Subtype.mk_eq_mk, ← Subtype.ext_iff, ← Subtype.ext_iff] at h
    · refine ⟨⟨⟨φ, not_isReal_of_mk_isComplex (hφ.symm ▸ hw)⟩, ?_⟩, rfl⟩
      rwa [Subtype.ext_iff, mkComplex_coe]
  · simp_rw [mult, not_isReal_iff_isComplex.mpr hw, ite_false]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
      (∀ φ : { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ },
        Function.Injective φ) ∧
        ∀ φ₁ φ₂ : { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ }, φ₁ ≠ φ₂ → φ₁.1 ≠ φ₂.1 := by
  have h₁ := card_add_two_mul_card_eq_card_aut_of_odd (finrank_even_iff.mpr hK)
  have h₂ := card_add_two_mul_card_eq_card_aut_of_odd (finrank_odd_iff.mpr hK)
  rw [← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ] at h₁ h₂
  rw [← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ]
  have h₃ := (Nat.coprime_mul_iff_right (Nat.succ_ne_zero 1)).mp (Nat.coprime_of_mul_eq_prime h₁)
  have h₄ := (Nat.coprime_mul_iff_right (Nat.succ_ne_zero 1)).mp (Nat.coprime_of_mul_eq_prime h₂)
  rw [mul_comm 2, mul_comm 2] at h₃ h₄
  rw [← card_additive_fund_eq_nrComplexPlaces, ← card_multiplicative_fund_eq_nrRealPlaces,
    card_complex_embeddings_eq_nrComplexPlaces, card_real_embeddings_eq_nrRealPlaces,
    card_nonReal_embeddings_eq_nrComplexPlaces, card_isReal_embeddings_eq_nrRealPlaces]
  refine' ⟨_, _, _⟩
  · rw [← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ]
    exact card_additive_mul_card_multiplicative_eq_card_aut_of_odd hK
  · exact fun φ => (injective_isReal_embeddings φ.1 φ.2).1
  · exact fun φ₁ φ₂ hne =>
      (injective_isReal_embeddings φ₁.1 φ₁.2).2 (Subtype.val_injective.ne hne)

Repaired Proof:
theorem card_complex_embeddings :
    card { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ } = 2 * NrComplexPlaces K ∧
      (∀ φ : { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ },
        Function.Injective φ) ∧
        ∀ φ₁ φ₂ : { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ }, φ₁ ≠ φ₂ → φ₁.1 ≠ φ₂.1 := by
  have h₁ := card_add_two_mul_card_eq_card_aut_of_odd (finrank_even_iff.mpr hK)
  have h₂ := card_add_two_mul_card_eq_card_aut_of_odd (finrank_odd_iff.mpr hK)
  rw [← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ] at h₁ h₂
  rw [← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ]
  have h₃ := (Nat.coprime_mul_iff_right (Nat.succ_ne_zero 1)).mp (Nat.coprime_of_mul_eq_prime h₁)
  have h₄ := (Nat.coprime_mul_iff_right (Nat.succ_ne_zero 1)).mp (Nat.coprime_of_mul_eq_prime h₂)
  rw [mul_comm 2, mul_comm 2] at h₃ h₄
  rw [← card_additive_fund_eq_nrComplexPlaces, ← card_multiplicative_fund_eq_nrRealPlaces,
    card_complex_embeddings_eq_nrComplexPlaces, card_real_embeddings_eq_nrRealPlaces,
    card_nonReal_embeddings_eq_nrComplexPlaces, card_isReal_embeddings_eq_nrRealPlaces]
  refine ⟨?_, ?_, ?_⟩
  · rw [← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ]
    exact card_additive_mul_card_multiplicative_eq_card_aut_of_odd hK
  · exact fun φ => (injective_isReal_embeddings φ.1 φ.2).1
  · exact fun φ₁ φ₂ hne =>
      (injective_isReal_embeddings φ₁.1 φ₁.2).2 (Subtype.val_injective.ne hne)

Repaired Proof:
theorem card_complex_embeddings :
    card { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ } = 2 * NrComplexPlaces K ∧
      (∀ φ : { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ },
        Function.Injective φ) ∧
        ∀ φ₁ φ₂ : { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ }, φ₁ ≠ φ₂ → φ₁.1 ≠ φ₂.1 := by
  have h₁ := card_add_two_mul_card_eq_card_aut_of_odd (finrank_even_iff.mpr hK)
  have h₂ := card_add_two_mul_card_eq_card_aut_of_odd (finrank_odd_iff.mpr hK)
  rw [← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ] at h₁ h₂
  rw [← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ]
  have h₃ := (Nat.coprime_mul_iff_right (Nat.succ_ne_zero 1)).mp (Nat.coprime_of_mul_eq_prime h₁)
  have h₄ := (Nat.coprime_mul_iff_right (Nat.succ_ne_zero 1)).mp (Nat.coprime_of_mul_eq_prime h₂)
  rw [mul_comm 2, mul_comm 2] at h₃ h₄
  rw [← card_additive_fund_eq_nrComplexPlaces, ← card_multiplicative_fund_eq_nrRealPlaces,
    card_complex_embeddings_eq_nrComplexPlaces, card_real_embeddings_eq_nrRealPlaces,
    card_nonReal_embeddings_eq_nrComplexPlaces, card_isReal_embeddings_eq_nrRealPlaces]
  refine ⟨?_, ?_, ?_⟩
  · rw [← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ, ← Finset.card_univ]
    exact card_additive_mul_card_multiplicative_eq_card_aut_of_odd hK
  · exact fun φ => (injective_isReal_embeddings φ.1 φ.2).1
  · exact fun φ₁ φ₂ hne =>
      (injective_isReal_embeddings φ₁.1 φ₁.2).2 (Subtype.val_injective.ne hne)

Repaired Proof:
theorem card_complex_embeddings :
    card { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ } = 2 * NrComplexPlaces K ∧
      (∀ φ : { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ },
        Function.Injective φ) ∧
        ∀ φ₁ φ₂ : { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ }, φ₁ ≠ φ₂ → φ₁.1 ≠ φ₂.1 := by
  have h₁ := card_add_two_mul_card_eq_card_aut_of_odd (finrank_even_iff.mpr hK)
  have h₂ := card_add_two_mul_card_eq_card_aut_of_odd (finrank_odd_iff.mpr

Attempt failure.

Working on Mathlib/NumberTheory/Padics/PadicVal.lean - 2024-09-09 01:07:39.975319.
---147/200---
For theorem padicValNat.padicValNat_eq_maxPowDiv in Mathlib/NumberTheory/Padics/PadicVal.lean:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 


Original valid proof:
:= by
  ext p n
  by_cases h : 1 < p ∧ 0 < n
  · dsimp [padicValNat]
    rw [dif_pos ⟨Nat.ne_of_gt h.1,h.2⟩, maxPowDiv_eq_multiplicity_get h.1 h.2]
  · simp only [not_and_or,not_gt_eq,Nat.le_zero] at h
    apply h.elim
    · intro h
      interval_cases p
      · simp [Classical.em]
      · dsimp [padicValNat, maxPowDiv]
        rw [go, if_neg]; simp
    · intro h
      simp [h]


Verifying proof (Commit d16c7a879e758dc3aee434d847d69bfbaf9f30f0):
0 := by
    ext p n
    by_cases h : p = 1
    · simp [h]
    rcases eq_or_ne n 0 with (rfl | hn)
    · simp
    rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
    · simp
    · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero hn, padicValNat.eq_zero_of_not_dvd]
  · simp
  · simp [h]

Repaired Proof:
theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv 0 := by
  ext p n
  by_cases h : p = 1
  · simp [h]
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [maxPowDiv_eq_zero h

Attempt failure.

Working on Mathlib/NumberTheory/Pell.lean - 2024-09-09 01:07:51.531338.
---148/200---
For theorem Pell.exists_of_not_isSquare in Mathlib/NumberTheory/Pell.lean:
theorem exists_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :
    ∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0 


Original valid proof:
:= by
  let ξ : ℝ := √d
  have hξ : Irrational ξ := by
    refine irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr h₀.le) ?_ two_pos
    rintro ⟨x, hx⟩
    refine hd ⟨x, @Int.cast_injective ℝ _ _ d (x * x) ?_⟩
    rw [← sq_sqrt <| Int.cast_nonneg.mpr h₀.le, Int.cast_mul, ← hx, sq]
  obtain ⟨M, hM₁⟩ := exists_int_gt (2 * |ξ| + 1)
  have hM : {q : ℚ | |q.1 ^ 2 - d * (q.2 : ℤ) ^ 2| < M}.Infinite := by
    refine Infinite.mono (fun q h => ?_) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hξ)
    have h0 : 0 < (q.2 : ℝ) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2
    have h1 : (q.num : ℝ) / (q.den : ℝ) = q := mod_cast q.num_div_den
    rw [mem_setOf, abs_sub_comm, ← @Int.cast_lt ℝ, ← div_lt_div_right (abs_pos_of_pos h0)]
    push_cast
    rw [← abs_div, abs_sq, sub_div, mul_div_cancel_right₀ _ h0.ne', ← div_pow, h1, ←
      sq_sqrt (Int.cast_pos.mpr h₀).le, sq_sub_sq, abs_mul, ← mul_one_div]
    refine mul_lt_mul'' (((abs_add ξ q).trans ?_).trans_lt hM₁) h (abs_nonneg _) (abs_nonneg _)
    rw [two_mul, add_assoc, add_le_add_iff_left, ← sub_le_iff_le_add']
    rw [mem_setOf, abs_sub_comm] at h
    refine (abs_sub_abs_le_abs_sub (q : ℝ) ξ).trans (h.le.trans ?_)
    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]
    exact q.pos
  obtain ⟨m, hm⟩ : ∃ m : ℤ, {q : ℚ | q.1 ^ 2 - d * (q.den : ℤ) ^ 2 = m}.Infinite := by
    contrapose! hM
    simp only [not_infinite] at hM ⊢
    refine (congr_arg _ (ext fun x => ?_)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)
    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']
  have hm₀ : m ≠ 0 := by
    rintro rfl
    obtain ⟨q, hq⟩ := hm.nonempty
    rw [mem_setOf, sub_eq_zero, mul_comm] at hq
    obtain ⟨a, ha⟩ := (Int.pow_dvd_pow_iff two_ne_zero).mp ⟨d, hq⟩
    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.natCast_pos.mpr q.pos) 2).ne'] at hq
    exact hd ⟨a, sq a ▸ hq.symm⟩
  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hm₀)
  let f : ℚ → ZMod m.natAbs × ZMod m.natAbs := fun q => (q.num, q.den)
  obtain ⟨q₁, h₁ : q₁.num ^ 2 - d * (q₁.den : ℤ) ^ 2 = m,
      q₂, h₂ : q₂.num ^ 2 - d * (q₂.den : ℤ) ^ 2 = m, hne, hqf⟩ :=
    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ
  obtain ⟨hq1 : (q₁.num : ZMod m.natAbs) = q₂.num, hq2 : (q₁.den : ZMod m.natAbs) = q₂.den⟩ :=
    Prod.ext_iff.mp hqf
  have hd₁ : m ∣ q₁.num * q₂.num - d * (q₁.den * q₂.den) := by
    rw [← Int.natAbs_dvd, ← ZMod.intCast_zmod_eq_zero_iff_dvd]
    push_cast
    rw [hq1, hq2, ← sq, ← sq]
    norm_cast
    rw [ZMod.intCast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, ← h₂]
  have hd₂ : m ∣ q₁.num * q₂.den - q₂.num * q₁.den := by
    rw [← Int.natAbs_dvd, ← ZMod.intCast_eq_intCast_iff_dvd_sub]
    push_cast
    rw [hq1, hq2]
  replace hm₀ : (m : ℚ) ≠ 0 := Int.cast_ne_zero.mpr hm₀
  refine ⟨(q₁.num * q₂.num - d * (q₁.den * q₂.den)) / m, (q₁.num * q₂.den - q₂.num * q₁.den) / m,
      ?_, ?_⟩
  · qify [hd₁, hd₂]
    field_simp [hm₀]
    norm_cast
    conv_rhs =>
      rw [sq]
      congr
      · rw [← h₁]
      · rw [← h₂]
    push_cast
    ring
  · qify [hd₂]
    refine div_ne_zero_iff.mpr ⟨?_, hm₀⟩
    exact mod_cast mt sub_eq_zero.mp (mt Rat.eq_iff_mul_eq_mul.mpr hne)


Verifying proof (Commit 0f24aee7da46f85fee5cacc716172444ce31e582):
∧ 0 ≤ x ∧ 0 ≤ y := by
  obtain ⟨a, b, h₁, hb₀, hb⟩ := exists_pos_of_not_isSquare h₀ hd
  obtain ⟨a, rfl⟩ | ⟨a, rfl⟩ := Int.eq_nat_or_neg a
  · have hb₀' : 0 < b := by
      refine' pos_of_mul_pos_left _ (by norm_num : (0 : ℤ) ≤ 2)
      rw [mul_assoc]
      exact hb₀
    refine' ⟨b, 1, _, one_ne_zero, by norm_num, Int.natCast_nonneg _, Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine' mod_cast h₁.symm.trans _
    rw [Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring
  · refine' ⟨-b, 1, _, one_ne_zero, by norm_num, neg_nonneg.2 <| Int.natCast_nonneg _,
      Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.neg_pow, Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring

Repaired Proof:
theorem exists_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :
    ∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0 ∧ 0 ≤ x ∧ 0 ≤ y := by
  obtain ⟨a, b, h₁, hb₀, hb⟩ := exists_pos_of_not_isSquare h₀ hd
  obtain ⟨a, rfl⟩ | ⟨a, rfl⟩ := Int.eq_nat_or_neg a
  · have hb₀' : 0 < b := by
      refine pos_of_mul_pos_left ?_ (by norm_num : (0 : ℤ) ≤ 2)
      rw [mul_assoc]
      exact hb₀
    refine ⟨b, 1, ?_, one_ne_zero, by norm_num, Int.natCast_nonneg _, Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring
  · refine ⟨-b, 1, ?_, one_ne_zero, by norm_num, neg_nonneg.2 <| Int.natCast_nonneg _,
      Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.neg_pow, Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring

Repaired Proof:
theorem exists_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :
    ∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0 ∧ 0 ≤ x ∧ 0 ≤ y := by
  obtain ⟨a, b, h₁, hb₀, hb⟩ := exists_pos_of_not_isSquare h₀ hd
  obtain ⟨a, rfl⟩ | ⟨a, rfl⟩ := Int.eq_nat_or_neg a
  · have hb₀' : 0 < b := by
      refine pos_of_mul_pos_left ?_ (by norm_num : (0 : ℤ) ≤ 2)
      rw [mul_assoc]
      exact hb₀
    refine ⟨b, 1, ?_, one_ne_zero, by norm_num, Int.natCast_nonneg _, Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring
  · refine ⟨-b, 1, ?_, one_ne_zero, by norm_num, neg_nonneg.2 <| Int.natCast_nonneg _,
      Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.neg_pow, Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring

Repaired Proof:
theorem exists_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :
    ∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0 ∧ 0 ≤ x ∧ 0 ≤ y := by
  obtain ⟨a, b, h₁, hb₀, hb⟩ := exists_pos_of_not_isSquare h₀ hd
  obtain ⟨a, rfl⟩ | ⟨a, rfl⟩ := Int.eq_nat_or_neg a
  · have hb₀' : 0 < b := by
      refine pos_of_mul_pos_left ?_ (by norm_num : (0 : ℤ) ≤ 2)
      rw [mul_assoc]
      exact hb₀
    refine ⟨b, 1, ?_, one_ne_zero, by norm_num, Int.natCast_nonneg _, Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring
  · refine ⟨-b, 1, ?_, one_ne_zero, by norm_num, neg_nonneg.2 <| Int.natCast_nonneg _,
      Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans

Attempt failure.

Working on Mathlib/NumberTheory/SmoothNumbers.lean - 2024-09-09 01:08:08.104679.
---149/200---
For theorem Nat.smoothNumbersUpTo_card_add_roughNumbersUpTo_card in Mathlib/NumberTheory/SmoothNumbers.lean:
lemma smoothNumbersUpTo_card_add_roughNumbersUpTo_card (N k : ℕ) :
    (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card = N 


Original valid proof:
:= by
  rw [smoothNumbersUpTo, roughNumbersUpTo,
    ← Finset.card_union_of_disjoint <| Finset.disjoint_filter.mpr fun n _ hn₂ h ↦ h.2 hn₂,
    Finset.filter_union_right]
  suffices Finset.card (Finset.filter (fun x ↦ x ≠ 0) (Finset.range (succ N))) = N by
    have hn' (n) : n ∈ smoothNumbers k ∨ n ≠ 0 ∧ n ∉ smoothNumbers k ↔ n ≠ 0 := by
      have : n ∈ smoothNumbers k → n ≠ 0 := ne_zero_of_mem_smoothNumbers
      refine ⟨fun H ↦ Or.elim H this fun H ↦ H.1, fun H ↦ ?_⟩
      simp only [ne_eq, H, not_false_eq_true, true_and, or_not]
    rwa [Finset.filter_congr (s := Finset.range (succ N)) fun n _ ↦ hn' n]
  rw [Finset.filter_ne', Finset.card_erase_of_mem <| Finset.mem_range_succ_iff.mpr <| zero_le N]
  simp only [Finset.card_range, succ_sub_succ_eq_sub, tsub_zero]


Verifying proof (Commit df80f92cd37291ae10f3efaf1c701700cac70a5d):
↔
      (smoothNumbersUpTo N k).card = N / 2 ∧ (roughNumbersUpTo N k).card = N / 2 + N % 2 := by
  have h₁ : (smoothNumbersUpTo N k).card ≤ N / 2 :=
    card_smoothNumbersUpTo_le_div_two N k
  have h₂ : (roughNumbersUpTo N k).card ≤ N / 2 + N % 2 :=
    card_roughNumbersUpTo_le_div_two_add_mod N k
  have h₃ : (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card ≤ N :=
    add_le_add h₁ h₂
  refine ⟨fun H ↦ ⟨?_,?_⟩, fun ⟨hs, hr⟩ ↦?_⟩
  · exact le_antisymm h₁ (Nat.le_of_add_le_add_right (H.trans_le h₃))
  · exact le_antisymm h₂ (Nat.le_of_add_le_add_right (H.trans_le h₃).symm)
  · rw [hs, hr, add_add_add_comm, add_tsub_cancel_right, add_comm,
      Nat.add_mul_div_left _ _ (two_pos : 0 < 2),
      Nat.add_mul_mod_self_left, mod_eq_of_lt (mod_lt N two_pos)]

Repaired Proof:
lemma smoothNumbersUpTo_card_add_roughNumbersUpTo_card (N k : ℕ) :
    (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card = N ↔
      (smoothNumbersUpTo N k).card = N / 2 ∧ (roughNumbersUpTo N k).card = N / 2 + N % 2 := by
  have h₁ : (smoothNumbersUpTo N k).card ≤ N / 2 :=
    card_smoothNumbersUpTo_le_div_two N k
  have h₂ : (roughNumbersUpTo N k).card ≤ N / 2 + N % 2 :=
    card_roughNumbersUpTo_le_div_two_add_mod N k
  have h₃ : (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card ≤ N :=
    add_le_add h₁ h₂
  refine ⟨fun H ↦ ⟨?_,?_⟩, fun ⟨hs, hr⟩ ↦?_⟩
  · exact le_antisymm h₁ (Nat.le_of_add_le_add_right H.le)
  · exact le_antisymm h₂ (Nat.le_of_add_le_add_right H.le)
  · rw [hs, hr, add_add_add_comm, add_tsub_cancel_right, add_comm,
      Nat.add_mul_div_left _ _ (two_pos : 0 < 2),
      Nat.add_mul_mod_self_left, mod_eq_of_lt (mod_lt N two_pos)]

Repaired Proof:
lemma smoothNumbersUpTo_card_add_roughNumbersUpTo_card (N k : ℕ) :
    (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card = N ↔
      (smoothNumbersUpTo N k).card = N / 2 ∧ (roughNumbersUpTo N k).card = N / 2 + N % 2 := by
  have h₁ : (smoothNumbersUpTo N k).card ≤ N / 2 :=
    card_smoothNumbersUpTo_le_div_two N k
  have h₂ : (roughNumbersUpTo N k).card ≤ N / 2 + N % 2 :=
    card_roughNumbersUpTo_le_div_two_add_mod N k
  have h₃ : (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card ≤ N :=
    add_le_add h₁ h₂
  refine ⟨fun H ↦ ⟨?_,?_⟩, fun ⟨hs, hr⟩ ↦?_⟩
  · exact le_antisymm h₁ (Nat.le_of_add_le_add_right H.le)
  · exact le_antisymm h₂ (Nat.le_of_add_le_add_right H.le)
  · rw [hs, hr, add_add_add_comm, add_tsub_cancel_right, add_comm,
      Nat.add_mul_div_left _ _ (two_pos : 0 < 2),
      Nat.add_mul_mod_self_left, mod_eq_of_lt (mod_lt N two_pos)]

Repaired Proof:
lemma smoothNumbersUpTo_card_add_roughNumbersUpTo_card (N k : ℕ) :
    (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card = N ↔
      (smoothNumbersUpTo N k).card = N / 2 ∧ (roughNumbersUpTo N k).card = N / 2 + N % 2 := by
  have h₁ : (smoothNumbersUpTo N k).card ≤ N / 2 :=
    card_smoothNumbersUpTo_le_div_two N k
  have h₂ : (roughNumbersUpTo N k).card ≤ N / 2 + N % 2 :=
    card_roughNumbersUpTo_le_div_two_add_mod N k
  have h₃ : (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card ≤ N :=
    add_le_add h₁ h₂
  refine ⟨fun H ↦ ⟨?_,?_⟩, fun ⟨hs, hr⟩ ↦?_⟩
  · exact le_antisymm h₁ (Nat.le_of_add_le_add_right H.le)
  · exact le_antisymm h₂ (Nat.le_of_add_le_add_right H.le)
  · rw [hs, hr, add_add_add_comm, add_tsub_cancel_right, add_comm,
      Nat.add_mul_div_left _ _ (two_pos : 0 < 2),
      Nat.add_mul_mod_self_left, mod_eq_of_lt (mod_lt N two_pos)]

Repaired Proof:
lemma smoothNumbersUpTo_card_add_roughNumbersUpTo_card (N k : ℕ) :
    (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card = N ↔
      (smoothNumbersUpTo N k).card = N / 2 ∧ (roughNumbersUpTo N k).card = N / 2 + N % 2 := by
  have h₁ : (smoothNumbersUpTo N k).card ≤ N / 2 :=
    card_smoothNumbersUpTo_le_div_two N k
  have h₂ : (roughNumbersUpTo N k).card ≤ N / 2 + N % 2 :=
    card_roughNumbersUpTo_le_div_two_add_mod N k
  have h₃ : (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card ≤ N :=
    add_le_add h₁ h₂
  refine ⟨fun H ↦ ⟨?_,?_⟩, fun ⟨hs, hr⟩ ↦?_⟩
  · exact le_antisymm h₁ (Nat.le_of_add_le_add_right H.le)
  · exact le_antisymm h₂ (Nat.le_of_add_le_add_right H.le)
  · rw [hs, hr, add_add_add_comm, add_tsub_cancel_right, add_comm,
      Nat.add_mul_div_left _ _ (two_pos : 0 < 2),
      Nat.add_mul_mod_self_left, mod_eq_of_lt (mod_lt N two_pos)]

Repaired Proof:
lemma smoothNumbersUpTo_card_add_roughNumbersUpTo_card (N k : ℕ) :
    (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card = N ↔
      (smoothNumbersUpTo N k).card = N / 2 ∧ (roughNumbersUpTo N k).card = N / 2 + N % 2 := by
  have h₁ : (smoothNumbersUpTo N k).card ≤ N / 2 :=
    card_smoothNumbersUpTo_le_div_two N k
  have h₂ : (roughNumbersUpTo N k).card ≤ N / 2 + N % 2 :=
    card_roughNumbers

Attempt failure.

Working on Mathlib/NumberTheory/Zsqrtd/Basic.lean - 2024-09-09 01:08:18.605018.
---150/200---
For theorem Zsqrtd.norm_conj in Mathlib/NumberTheory/Zsqrtd/Basic.lean:
theorem norm_conj (x : ℤ√d) : (star x).norm = x.norm 


Original valid proof:
:=
  Int.cast_inj.1 <| by rw [norm_eq_mul_conj, star_star, mul_comm, norm_eq_mul_conj]


Verifying proof (Commit 0ef23fba776dbe5bb848bbfc3337bedef4a59c82):
↔ x.im = 0 ∨ d ∣ x.re := by
  rw [norm_eq, norm_eq, Int.natAbs_sq, Int.natAbs_sq, mul_comm, ← Int.natAbs_mul,
    Int.natAbs_mul_self, Int.natAbs_mul_self, mul_comm, ← Int.natAbs_mul,
    Int.natAbs_eq_natAbs_iff, ← Int.natAbs_mul_self, ← Int.natAbs_mul,
    Int.natAbs_dvd_natAbs, ← mul_assoc, ← sq, ← sq, mul_dvd_mul_iff_left,
    Int.natAbs_pos, ← Int.natAbs_ne_zero, Ne.def, Int.natAbs_eq_zero,
    Int.natAbs_eq_zero, ← Int.natAbs_dvd_natAbs, ← Int.natAbs_dvd_natAbs,
    Int.natAbs_ofNat, Int.natAbs_ofNat, ← Int.natAbs_dvd_natAbs, ← Int.natAbs_dvd_natAbs,
    Int.natAbs_dvd, Int.natAbs_dvd_natAbs, ← Int.natAbs_dvd_natAbs, ← Int.natAbs_dvd_natAbs,
    Int.natAbs_dvd_iff_dvd, Int.natAbs_dvd_iff_dvd, ← Int.natAbs_dvd_natAbs,
    ← Int.natAbs_dvd_natAbs, Int.natAbs_dvd_iff_dvd, Int.natAbs_dvd_iff_dvd,
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),
    mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im), mul_comm (Int.natAbs x.im),

Attempt failure.

Working on Mathlib/Order/Bounds/Basic.lean - 2024-09-09 01:08:39.099696.
---151/200---
For theorem union_upperBounds_subset_upperBounds_inter in Mathlib/Order/Bounds/Basic.lean:
theorem union_upperBounds_subset_upperBounds_inter :
    upperBounds s ∪ upperBounds t ⊆ upperBounds (s ∩ t) 


Original valid proof:
:=
  union_subset (upperBounds_mono_set inter_subset_left)
    (upperBounds_mono_set inter_subset_right)


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
 :=
  union_subset (upperBounds_mono_set inter_subset_left)
    (upperBounds_mono_set inter_subset_right)


theorem union_lowerBounds_subset_lowerBounds_inter :
    lowerBounds s ∪ lowerBounds t ⊆ lowerBounds (s ∩ t) :=
  @union_upperBounds_subset_upperBounds_inter αᵒᵈ _ s t


theorem isLUB_union {s t : Set α} {a b : α} (ha : IsLUB s a) (hb : IsLUB t b) :
    IsLUB (s ∪ t) (a ⊔ b) :=
  ⟨fun _ hx =>
    max_le (ha.1 <| mem_union_left t hx) (hb.1 <| mem_union_right s hx),
    fun _ hx =>
    sup_le (fun _ hy => ha.2 hy <| subset_union_left _ _) fun _ hy => hb.2 hy <| subset_union_right _ _⟩


theorem isGLB_union {s t : Set α} {a b : α} (ha : IsGLB s a) (hb : IsGLB t b) :
    IsGLB (s ∪ t) (a ⊓ b) :=
  @isLUB_union αᵒᵈ _ s t a b ha hb


theorem isLUB_Icc (a b : α) : IsLUB (Icc a b) b :=
  ⟨right_mem_Icc.2 <| le_refl _, fun _ => And.right⟩


theorem isGLB_Icc (a b : α) : IsGLB (Icc a b) a :=
  @isLUB_Icc αᵒᵈ _ _ _


theorem isLUB_Ico (a b : α) : IsLUB (Ico a b) b :=
  ⟨right_mem_Ico.2 <| lt_irrefl _, fun _ => And.right⟩


theorem isGLB_Ioc (a b : α) : IsGLB (Ioc a b) a :=
  @isLUB_Ioc αᵒᵈ _ _ _


theorem isLUB_Ioo [DenselyOrdered α] (a b : α) : IsLUB (Ioo a b) b :=
  ⟨fun _ => And.right, fun _ hlt =>
    let ⟨c, hac, hcb⟩ := exists_between hlt
    c ∈ Ioo a b ⟨hac, hcb⟩⟩


theorem isGLB_Ioo [DenselyOrdered α] (a b : α) : IsGLB (Ioo a b) a :=
  @isLUB_Ioo αᵒᵈ _ _ _


theorem isLUB_Ioc [DenselyOrdered α] {a b : α} (h : a < b) : IsLUB (Ioc a b) b :=
  (isLUB_Ioo a b).of_subset_of_superset (Ioo_subset_Ioc_self h) Ioc_subset_Ioo_right


theorem isGLB_Ico [DenselyOrdered α] {a b : α} (h : a < b) : IsGLB (Ico a b) a :=
  @isLUB_Ioc αᵒᵈ _ _ _ h


theorem isLUB_Icc [DenselyOrdered α] {a b : α} (h : a ≤ b) : IsLUB (Icc a b) b :=
  (isLUB_Ioc h).of_subset_of_superset (Ioc_subset_Icc_self) Icc_subset_Ioc_right


theorem isGLB_Icc [DenselyOrdered α] {a b : α} (h : a ≤ b) : IsGLB (Icc a b) a :=
  @isLUB_Icc αᵒᵈ _ _ _ h


theorem isLUB_Icc_of_ge [DenselyOrdered α] {a b : α} (h : a ≤ b) : IsLUB (Icc a b) b :=
  isLUB_Icc h


theorem isGLB_Icc_of_le [DenselyOrdered α] {a b : α} (h : a ≤ b) : IsGLB (Icc a b) a :=
  isGLB_Icc h


theorem isLUB_Ico [DenselyOrdered α] {a b : α} (h : a < b) : IsLUB (Ico a b) b :=
  (isLUB_Ioo h).of_subset_of_superset (Ioo_subset_Ico_self) Ico_subset_Icc_self


theorem isGLB_Ioc [DenselyOrdered α] {a b : α} (h : a < b) : IsGLB (Ioc a b) a :=
  @isLUB_Ioc αᵒᵈ _ _ _ h


theorem isLUB_Ioo [DenselyOrdered α] {a b : α} (h : a < b) : IsLUB (Ioo a b) b :=
  (isLUB_Ioc h).of_subset_of_superset (Ioc_subset_Ioo_right h.le) Ioo_subset_Ioc_self


theorem isGLB_Ioo [DenselyOrdered α] {a b : α} (h : a < b) : IsGLB (Ioo a b) a :=
  @isLUB_Ioo αᵒᵈ _ _ _ h


theorem isLUB_Ioc' [DenselyOrdered α] {a b : α} (h : a < b) : IsLUB (Ioc a b) (b - a) := by
  simpa only [sub_add_cancel] using isLUB_Ioo h


theorem isGLB_Ico' [DenselyOrdered α] {a b : α} (h : a < b) : IsGLB (Ico a b) (b - a) := by
  simpa only [sub_add_cancel] using isGLB_Ioo h


theorem isLUB_Ico [DenselyOrdered α] {a b : α} (h : a < b) : IsLUB (Ico a b) b :=
  (isLUB_Ioc' h).of_subset_of_superset (Ioc_subset_Ico_self) Ico_subset_Icc_self


theorem isGLB_Ioc [DenselyOrdered α] {a b : α} (h : a < b) : IsGLB (Ioc a b) a :=
  (isGLB_Ico' h).of_subset_of_superset (Ico_subset_Ioc_self) Ioc_subset_Icc_self


theorem isLUB_Ioo [DenselyOrdered α] {a b : α} (h : a < b) : IsLUB (Ioo a b) b :=
  (isLUB_Ioc' h).of_subset_of_superset (Ioc_subset_Ioo_right h.le) Ioo_subset_Ioc_self


theorem isGLB_Ioo [DenselyOrdered α] {a b : α} (h : a < b) : IsGLB (Ioo a b) a :=
  (isGLB_Ico' h).of_subset_of_superset (Ico_subset_Ioo_left h.le) Ioo_subset_Ico_self


theorem isLUB_Icc' [DenselyOrdered α] {a b : α} (h : a ≤ b) : IsLUB (Icc a b) (b - a) := by
  simpa only [add_sub_cancel'_right] using isLUB_Icc_of_ge h


theorem isGLB_Icc' [DenselyOrdered α] {a b : α} (h : a ≤ b) : IsGLB (Icc a b) (b - a) := by
  simpa only [add_sub_cancel'_right] using isGLB_Icc_of_le h


theorem isLUB_Ico' [DenselyOrdered α] {a b : α} (h : a < b) : IsLUB (Ico a b) (b - a) := by
  simpa only [add_sub_cancel'_right] using isLUB_Ico h


theorem isGLB_Ioc' [DenselyOrdered α] {a b : α} (h : a < b) : IsGLB (Ioc a b) (b - a) := by
  simpa only [add_sub_cancel'_right] using isGLB_Ioc h


theorem isLUB_Ioo' [DenselyOrdered α] {a b : α} (h : a < b) : IsLUB (Ioo a

Attempt failure.

Working on Mathlib/Order/Filter/Archimedean.lean - 2024-09-09 01:08:47.298267.
---152/200---
For theorem Filter.Tendsto.const_mul_atTop' in Mathlib/Order/Filter/Archimedean.lean:
theorem Tendsto.const_mul_atTop' (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atTop 


Original valid proof:
:= by
  refine tendsto_atTop.2 fun b => ?_
  obtain ⟨n : ℕ, hn : 1 ≤ n • r⟩ := Archimedean.arch 1 hr
  rw [nsmul_eq_mul'] at hn
  filter_upwards [tendsto_atTop.1 hf (n * max b 0)] with x hx
  calc
    b ≤ 1 * max b 0 := by
    { rw [one_mul]
      exact le_max_left _ _ }
    _ ≤ r * n * max b 0 := by gcongr
    _ = r * (n * max b 0) := by rw [mul_assoc]
    _ ≤ r * f x := by gcongr


Verifying proof (Commit 9a5e0ce9f9b714fd5383610a12746cded21f030f):
 :=
  (tendsto_const_mul_atTop_of_pos hr).2 hf

  
  theorem Tendsto.atTop_mul_const' (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_pos hr).2 hf

  
  theorem Tendsto.atTop_mul_const (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_pos hr).2 hf

  
  theorem Tendsto.atTop_const_mul_of_pos (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atTop :=
  (tendsto_const_mul_atTop_of_pos hr).2 hf

  
  theorem Tendsto.atTop_const_mul (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atTop :=
  (tendsto_const_mul_atTop_of_pos hr).2 hf

  
  theorem Tendsto.atTop_mul_const_of_pos (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_pos hr).2 hf

  
  theorem Tendsto.atTop_mul_const (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_pos hr).2 hf

  
  theorem Tendsto.atTop_const_mul_of_neg (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atTop :=
  (tendsto_const_mul_atTop_of_neg hr).2 hf

  
  theorem Tendsto.atTop_const_mul_of_neg' (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_neg hr).2 hf

  
  theorem Tendsto.atTop_const_mul_of_neg (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atTop :=
  (tendsto_const_mul_atTop_of_neg hr).2 hf

  
  theorem Tendsto.atTop_const_mul_of_neg' (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_neg hr).2 hf

  
  theorem Tendsto.const_mul_atBot (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_const_mul_atBot_of_pos hr).2 hf

  
  theorem Tendsto.const_mul_atBot' (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_const_mul_atBot_of_pos hr).2 hf

  
  theorem Tendsto.atBot_const_mul_of_pos (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atBot :=
  (tendsto_atBot_const_mul_of_pos hr).2 hf

  
  theorem Tendsto.atBot_const_mul_of_pos' (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_atBot_const_mul_of_pos hr).2 hf

  
  theorem Tendsto.atBot_const_mul_of_pos (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atBot :=
  (tendsto_atBot_const_mul_of_pos hr).2 hf

  
  theorem Tendsto.atBot_const_mul_of_pos' (hr : 0 < r) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_atBot_const_mul_of_pos hr).2 hf

  
  theorem Tendsto.atBot_const_mul_of_neg (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_atBot_const_mul_of_neg hr).2 hf

  
  theorem Tendsto.atBot_const_mul_of_neg' (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atBot :=
  (tendsto_mul_const_atBot_of_neg hr).2 hf

  
  theorem Tendsto.atBot_const_mul_of_neg (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_atBot_const_mul_of_neg hr).2 hf

  
  theorem Tendsto.atBot_const_mul_of_neg' (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atBot :=
  (tendsto_mul_const_atBot_of_neg hr).2 hf

  
  theorem Tendsto.const_mul_atBot_of_neg (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_const_mul_atBot_of_neg hr).2 hf

  
  theorem Tendsto.const_mul_atBot_of_neg' (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atBot :=
  (tendsto_mul_const_atBot_of_neg hr).2 hf

  
  theorem Tendsto.const_mul_atBot_of_neg (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atBot :=
  (tendsto_const_mul_atBot_of_neg hr).2 hf

  
  theorem Tendsto.const_mul_atBot_of_neg' (hr : r < 0) (hf : Tendsto f l atTop) :
    Tendsto (fun x => f x * r) l atBot :=
  (tendsto_mul_const_atBot_of_neg hr).2 hf

  
  theorem Tendsto.atTop_const_mul_of_neg (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atTop :=
  (tendsto_atTop_const_mul_of_neg hr).2 hf

  
  theorem Tendsto.atTop_const_mul_of_neg' (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_neg hr).2 hf

  
  theorem Tendsto.atTop_const_mul_of_neg (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => r * f x) l atTop :=
  (tendsto_atTop_const_mul_of_neg hr).2 hf

  
  theorem Tendsto.atTop_const_mul_of_neg' (hr : r < 0) (hf : Tendsto f l atBot) :
    Tendsto (fun x => f x * r) l atTop :=
  (tendsto_mul_const_atTop_of_neg hr).2 hf

  
  theorem Tendsto.const_mul_atTop_of_neg (hr : r < 0) (hf : Tendsto f l

Attempt failure.

Working on Mathlib/Order/Interval/Finset/Fin.lean - 2024-09-09 01:11:13.840096.
---153/200---
For theorem Fin.map_valEmbedding_Ici in Mathlib/Order/Interval/Finset/Fin.lean:
theorem map_valEmbedding_Ici : (Ici a).map Fin.valEmbedding = Icc ↑a (n - 1) 


Original valid proof:
:= by
  clear b
  ext x
  simp only [exists_prop, Embedding.coe_subtype, mem_Ici, mem_map, mem_Icc]
  constructor
  · rintro ⟨x, hx, rfl⟩
    exact ⟨hx, Nat.le_sub_of_add_le <| x.2⟩
  cases n
  · exact Fin.elim0 a
  · exact fun hx => ⟨⟨x, Nat.lt_succ_iff.2 hx.2⟩, hx.1, rfl⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∩ { x | x ≤ n } := by
    rw [Fin.valEmbedding, ← map_valEmbedding_Ici, ← map_valEmbedding_Icc,
      Fin.map_valEmbedding_Icc_zero, Ici_inter_Iic]

  theorem map_succAbove_Ici (a : Fin (n + 1)) :
    (Ici a).map a.succAbove = Ici a.succ ∪ {a} := by
    cases' lt_or_le a (castSucc a) with ha ha
    · rw [map_valEmbedding_Ici, ← Ici_insert, ← succAbove_castSucc_of_lt _ ha,
        Fin.insert_val_succ]
    · rw [map_valEmbedding_Ici, ← Ici_insert, ← succAbove_castSucc_of_le _ ha,
        Fin.insert_val_succ]

  theorem map_succAbove_Ioi (a : Fin (n + 1)) :
    (Ioi a).map a.succAbove = Ioi a.succ ∪ {a} := by
    cases' lt_or_le a (castSucc a) with ha ha
    · rw [map_valEmbedding_Ioi, ← Ioi_insert, ← succAbove_castSucc_of_lt _ ha,
        Fin.insert_val_succ]
    · rw [map_valEmbedding_Ioi, ← Ioi_insert, ← succAbove_castSucc_of_le _ ha,
        Fin.insert_val_succ]

  theorem map_succAbove_Icc (a : Fin (n + 1)) :
    (Icc a b).map a.succAbove = Icc a.succ b ∪ {a} := by
    cases' lt_or_le a (castSucc a) with ha ha
    · rw [map_valEmbedding_Icc, ← Icc_insert, ← succAbove_castSucc_of_lt _ ha,
        Fin.insert_val_succ]
    · rw [map_valEmbedding_Icc, ← Icc_insert, ← succAbove_castSucc_of_le _ ha,
        Fin.insert_val_succ]

  theorem map_succAbove_Ico (a : Fin (n + 1)) :
    (Ico a b).map a.succAbove = Ico a.succ b ∪ {a} := by
    cases' lt_or_le a (castSucc a) with ha ha
    · rw [map_valEmbedding_Ico, ← Ico_insert, ← succAbove_castSucc_of_lt _ ha,
        Fin.insert_val_succ]
    · rw [map_valEmbedding_Ico, ← Ico_insert, ← succAbove_castSucc_of_le _ ha,
        Fin.insert_val_succ]

  theorem map_succAbove_Ioc (a : Fin (n + 1)) :
    (Ioc a b).map a.succAbove = Ioc a.succ b ∪ {a} := by
    cases' lt_or_le a (castSucc a) with ha ha
    · rw [map_valEmbedding_Ioc, ← Ioc_insert, ← succAbove_castSucc_of_lt _ ha,
        Fin.insert_val_succ]
    · rw [map_valEmbedding_Ioc, ← Ioc_insert, ← succAbove_castSucc_of_le _ ha,
        Fin.insert_val_succ]

  theorem map_succAbove_Ioo (a : Fin (n + 1)) :
    (Ioo a b).map a.succAbove = Ioo a.succ b ∪ {a} := by
    cases' lt_or_le a (castSucc a) with ha ha
    · rw [map_valEmbedding_Ioo, ← Ioo_insert, ← succAbove_castSucc_of_lt _ ha,
        Fin.insert_val_succ]
    · rw [map_valEmbedding_Ioo, ← Ioo_insert, ← succAbove_castSucc_of_le _ ha,
        Fin.insert_val_succ]

  theorem map_castSuccAbove_Ici : (Ici a).map (castSuccAbove a) = Icc (castSucc a) (castSucc b) := by
    rw [map_valEmbedding_Ici, ← Icc_insert, ← Icc_insert, ← insert_eq, ← insert_eq,
      Ici_eq_cons_Ioi, Ici_eq_cons_Ioi, Fin.insert_val_succ, Fin.insert_val_succ,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Ioi, Fin.map_valEmbedding_Ioi,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Icc, Fin.map_valEmbedding_Icc,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Icc, Fin.map_valEmbedding_Icc,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Icc, Fin.map_valEmbedding_Icc,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Icc, Fin.map_valEmbedding_Icc,
      Fin.cons_map, Fin.cons_map]

  theorem map_castSuccAbove_Ioi : (Ioi a).map (castSuccAbove a) = Ioc (castSucc a) (castSucc b) := by
    rw [map_valEmbedding_Ioi, ← Ioc_insert, ← Ioc_insert, ← insert_eq, ← insert_eq,
      Ioi_eq_cons_Ioo, Ioi_eq_cons_Ioo, Fin.insert_val_succ, Fin.insert_val_succ,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Ioo, Fin.map_valEmbedding_Ioo,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Ioo, Fin.map_valEmbedding_Ioo,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Ioo, Fin.map_valEmbedding_Ioo,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Ioo, Fin.map_valEmbedding_Ioo,
      Fin.cons_map, Fin.cons_map]

  theorem map_castSuccAbove_Icc : (Icc a b).map (castSuccAbove a) = Icc (castSucc a) (castSucc b) := by
    rw [map_valEmbedding_Icc, ← Icc_insert, ← Icc_insert, ← insert_eq, ← insert_eq,
      Icc_eq_cons_Ico, Icc_eq_cons_Ico, Fin.insert_val_succ, Fin.insert_val_succ,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Ico, Fin.map_valEmbedding_Ico,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Icc, Fin.map_valEmbedding_Icc,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Icc, Fin.map_valEmbedding_Icc,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Icc, Fin.map_valEmbedding_Icc,
      Fin.cons_map, Fin.cons_map]

  theorem map_castSuccAbove_Ico : (Ico a b).map (castSuccAbove a) = Ico (castSucc a) b ∪ {a} := by
    rw [map_valEmbedding_Ico, ← Ico_insert, ← Ico_insert, ← insert_eq, ← insert_eq,
      Ico_eq_cons_Ioo, Ico_eq_cons_Ioo, Fin.insert_val_succ, Fin.insert_val_succ,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Ioo, Fin.map_valEmbedding_Ioo,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Ioo, Fin.map_valEmbedding_Ioo,
      Fin.cons_map, Fin.cons_map, Fin.map_valEmbedding_Ioo, Fin.map_valEmbedding_Ioo,
      Fin.cons_map, Fin.cons_map]

  theorem map_castSuccAbove_Ioc : (Ioc a b).map (castSu

Attempt failure.

Working on Mathlib/Order/UpperLower/Basic.lean - 2024-09-09 01:11:23.226536.
---154/200---
For theorem LowerSet.sdiff_sup_lowerClosure in Mathlib/Order/UpperLower/Basic.lean:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s 


Original valid proof:
:= by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain hat | hat := em (a ∈ t)
  · exact subset_union_right (subset_lowerClosure hat)
  · refine subset_union_left ⟨ha, ?_⟩
    rintro ⟨b, hb, hba⟩
    exact hat <| hst _ ha _ hb hba


Verifying proof (Commit 049f6f9c146026f6debfbf18ad947c4aa57150cb):
⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain ha | ha := em (a ∈ t)
  · exact subset_union_right _ _ (subset_lowerClosure ha)
  · refine subset_union_left _ _ ⟨ha, fun b hb hab ↦ ?_⟩
    exact hst _ hb _ ha hab

Repaired Proof:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s ⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain ha | ha := em (a ∈ t)
  · exact subset_union_right _ _ (subset_lowerClosure ha)
  · refine subset_union_left _ _ ⟨ha, fun b hb hab ↦ ?_⟩
    exact hst _ hb _ ha hab

Repaired Proof:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s ⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain ha | ha := em (a ∈ t)
  · exact subset_union_right _ _ (subset_lowerClosure ha)
  · refine subset_union_left _ _ ⟨ha, fun b hb hab ↦ ?_⟩
    exact hst _ hb _ ha hab

Repaired Proof:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s ⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain ha | ha := em (a ∈ t)
  · exact subset_union_right _ _ (subset_lowerClosure ha)
  · refine subset_union_left _ _ ⟨ha, fun b hb hab ↦ ?_⟩
    exact hst _ hb _ ha hab

Repaired Proof:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s ⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain ha | ha := em (a ∈ t)
  · exact subset_union_right _ _ (subset_lowerClosure ha)
  · refine subset_union_left _ _ ⟨ha, fun b hb hab ↦ ?_⟩
    exact hst _ hb _ ha hab

Repaired Proof:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s ⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain ha | ha := em (a ∈ t)
  · exact subset_union_right _ _ (subset_lowerClosure ha)
  · refine subset_union_left _ _ ⟨ha, fun b hb hab ↦ ?_⟩
    exact hst _ hb _ ha hab

Repaired Proof:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s ⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain ha | ha := em (a ∈ t)
  · exact subset_union_right _ _ (subset_lowerClosure ha)
  · refine subset_union_left _ _ ⟨ha, fun b hb hab ↦ ?_⟩
    exact hst _ hb _ ha hab

Repaired Proof:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s ⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain ha | ha := em (a ∈ t)
  · exact subset_union_right _ _ (subset_lowerClosure ha)
  · refine subset_union_left _ _ ⟨ha, fun b hb hab ↦ ?_⟩
    exact hst _ hb _ ha hab

Repaired Proof:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s ⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain ha | ha := em (a ∈ t)
  · exact subset_union_right _ _ (subset_lowerClosure ha)
  · refine subset_union_left _ _ ⟨ha, fun b hb hab ↦ ?_⟩
    exact hst _ hb _ ha hab

Repaired Proof:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s ⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain ha | ha := em (a ∈ t)
  · exact subset_union_right _ _ (subset_lowerClosure ha)
  · refine subset_union_left _ _ ⟨ha, fun b hb hab ↦ ?_⟩
    exact hst _ hb _ ha hab

Repaired Proof:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s ⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_
  obtain ha | ha := em (a ∈ t)
  · exact subset_union_right _ _ (subset_lowerClosure ha)
  · refine subset_union_left _ _ ⟨ha, fun b hb hab ↦ ?_⟩
    exact hst _ hb _ ha hab

Repaired Proof:
lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :
    s.sdiff t ⊔ lowerClosure t = s ⊓ t := by
  refine le_antisymm (sup_le sdiff_le_left <| lower

Attempt failure.

Working on Mathlib/Order/WellFoundedSet.lean - 2024-09-09 01:11:43.423800.
---155/200---
For theorem Set.PartiallyWellOrderedOn.partiallyWellOrderedOn_sublistForall₂ in Mathlib/Order/WellFoundedSet.lean:
theorem partiallyWellOrderedOn_sublistForall₂ (r : α → α → Prop) [IsRefl α r] [IsTrans α r]
    {s : Set α} (h : s.PartiallyWellOrderedOn r) :
    { l : List α | ∀ x, x ∈ l → x ∈ s }.PartiallyWellOrderedOn (List.SublistForall₂ r) 


Original valid proof:
:= by
  rcases isEmpty_or_nonempty α
  · exact subsingleton_of_subsingleton.partiallyWellOrderedOn
  inhabit α
  rw [iff_not_exists_isMinBadSeq List.length]
  rintro ⟨f, hf1, hf2⟩
  have hnil : ∀ n, f n ≠ List.nil := fun n con =>
    hf1.2 n n.succ n.lt_succ_self (con.symm ▸ List.SublistForall₂.nil)
  have : ∀ n, (f n).headI ∈ s :=
    fun n => hf1.1 n _ (List.head!_mem_self (hnil n))
  obtain ⟨g, hg⟩ := h.exists_monotone_subseq (fun n => (f n).headI) this
  have hf' :=
    hf2 (g 0) (fun n => if n < g 0 then f n else List.tail (f (g (n - g 0))))
      (fun m hm => (if_pos hm).symm) ?_
  swap;
  · simp only [if_neg (lt_irrefl (g 0)), Nat.sub_self]
    rw [List.length_tail, ← Nat.pred_eq_sub_one]
    exact Nat.pred_lt fun con => hnil _ (List.length_eq_zero.1 con)
  rw [IsBadSeq] at hf'
  push_neg at hf'
  obtain ⟨m, n, mn, hmn⟩ := hf' fun n x hx => by
    split_ifs at hx with hn
    exacts [hf1.1 _ _ hx, hf1.1 _ _ (List.tail_subset _ hx)]
  by_cases hn : n < g 0
  · apply hf1.2 m n mn
    rwa [if_pos hn, if_pos (mn.trans hn)] at hmn
  · obtain ⟨n', rfl⟩ := Nat.exists_eq_add_of_le (not_lt.1 hn)
    rw [if_neg hn, add_comm (g 0) n', Nat.add_sub_cancel_right] at hmn
    split_ifs at hmn with hm
    · apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))
      exact _root_.trans hmn (List.tail_sublistForall₂_self _)
    · rw [← Nat.sub_lt_iff_lt_add (le_of_not_lt hm)] at mn
      apply hf1.2 _ _ (g.lt_iff_lt.2 mn)
      rw [← List.cons_head!_tail (hnil (g (m - g 0))), ← List.cons_head!_tail (hnil (g n'))]
      exact List.SublistForall₂.cons (hg _ _ (le_of_lt mn)) hmn


Verifying proof (Commit b502dbb455f708f5af5e6017e88f53565165ab0a):
∧
      ∀ l₁ l₂, List.SublistForall₂ r l₁ l₂ → (∀ x, x ∈ l₁ → x ∈ s) → ∀ x, x ∈ l₂ → x ∈ s := by
  classical
    refine' ⟨fun l₁ l₂ => _, fun l₁ l₂ h₁₂ h₁ h₂ x hx => _⟩
    · rintro ⟨h₁, h₂⟩
      obtain ⟨l, hl₁, hl₂⟩ := h.exists_chain_of_forall_mem_lt h₁ h₂
      exact ⟨l, hl₁, hl₂.sublistForall₂ h₁₂⟩
    · induction h₁₂ with
      | nil => exact h₂ x hx
      | cons a l₁ l₂ h₁₂ _ ih =>
        exact
          (h.is_refl a).trans
            ((ih h₁ h₂).trans
              (h.is_refl x <|
                (h₁₂.subset_of_mem hx).trans <| h₁₂.subset_of_mem <| h₁₂.mem_cons_self _))
    · rintro ⟨l, hl, hll⟩
      obtain ⟨x, hx, _⟩ := h.exists_chain_of_forall_mem_lt h₁ h₂
      exact ⟨x, hll.subset_of_mem hx, hx⟩

Repaired Proof:
theorem partiallyWellOrderedOn_sublistForall₂ (r : α → α → Prop) [IsRefl α r] [IsTrans α r]
    {s : Set α} (h : s.PartiallyWellOrderedOn r) :
    { l : List α | ∀ x, x ∈ l → x ∈ s }.PartiallyWellOrderedOn (List.SublistForall₂ r) ∧
      ∀ l₁ l₂, List.SublistForall₂ r l₁ l₂ → (∀ x, x ∈ l₁ → x ∈ s) → ∀ x, x ∈ l₂ → x ∈ s := by
  classical
    refine ⟨fun l₁ l₂ => ?_, fun l₁ l₂ h₁₂ h₁ h₂ x hx => ?_⟩
    · rintro ⟨h₁, h₂⟩
      obtain ⟨l, hl₁, hl₂⟩ := h.exists_chain_of_forall_mem_lt h₁ h₂
      exact ⟨l, hl₁, hl₂.sublistForall₂ h₁₂⟩
    · induction h₁₂ with
      | nil => exact h₂ x hx
      | cons a l₁ l₂ h₁₂ _ ih =>
        exact
          (h.is_refl a).trans
            ((ih h₁ h₂).trans
              (h.is_refl x <|
                (h₁₂.subset_of_mem hx).trans <| h₁₂.subset_of_mem <| h₁₂.mem_cons_self _))
    · rintro ⟨l, hl, hll⟩
      obtain ⟨x, hx, _⟩ := h.exists_chain_of_forall_mem_lt h₁ h₂
      exact ⟨x, hll.subset_of_mem hx, hx⟩

Repaired Proof:
theorem partiallyWellOrderedOn_sublistForall₂ (r : α → α → Prop) [IsRefl α r] [IsTrans α r]
    {s : Set α} (h : s.PartiallyWellOrderedOn r) :
    { l : List α | ∀ x, x ∈ l → x ∈ s }.PartiallyWellOrderedOn (List.SublistForall₂ r) ∧
      ∀ l₁ l₂, List.SublistForall₂ r l₁ l₂ → (∀ x, x ∈ l₁ → x ∈ s) → ∀ x, x ∈ l₂ → x ∈ s := by
  classical
    refine ⟨fun l₁ l₂ => ?_, fun l₁ l₂ h₁₂ h₁ h₂ x hx => ?_⟩
    · rintro ⟨h₁, h₂⟩
      obtain ⟨l, hl₁, hl₂⟩ := h.exists_chain_of_forall_mem_lt h₁ h₂
      exact ⟨l, hl₁, hl₂.sublistForall₂ h₁₂⟩
    · induction h₁₂ with
      | nil => exact h₂ x hx
      | cons a l₁ l₂ h₁₂ _ ih =>
        exact
          (h.is_refl a).trans
            ((ih h₁ h₂).trans
              (h.is_refl x <|
                (h₁₂.subset_of_mem hx).trans <| h₁₂.subset_of_mem <| h₁₂.mem_cons_self _))
    · rintro ⟨l, hl, hll⟩
      obtain ⟨x, hx, _⟩ := h.exists_chain_of_forall_mem_lt h₁ h₂
      exact ⟨x, hll.subset_of_mem hx, hx⟩

Repaired Proof:
theorem partiallyWellOrderedOn_sublistForall₂ (r : α → α → Prop) [IsRefl α r] [IsTrans α r]
    {s : Set α} (h : s.PartiallyWellOrderedOn r) :
    { l : List α | ∀ x, x ∈ l → x ∈ s }.PartiallyWellOrderedOn (List.SublistForall₂ r) ∧
      ∀ l₁ l₂, List.SublistForall₂ r l₁ l₂ → (∀ x, x ∈ l₁ → x ∈ s) → ∀ x, x ∈ l₂ → x ∈ s := by
  classical
    refine ⟨fun l₁ l₂ => ?_, fun l₁ l₂ h₁₂ h₁ h₂ x hx => ?_⟩
    · rintro ⟨h₁, h₂⟩
      obtain ⟨l, hl₁, hl₂⟩ := h.exists_chain_of_forall_mem_lt h₁ h₂
      exact ⟨l, hl₁, hl₂.sublistForall₂ h₁₂⟩
    · induction h₁₂ with
      | nil => exact h₂ x hx
      | cons a l₁ l₂ h₁₂ _ ih =>
        exact
          (h.is_refl a).trans
            ((ih h₁ h₂).trans
              (h.is_refl x <|
                (h₁₂.subset_of_mem hx).trans <| h₁₂.subset_of_mem <| h₁₂.mem_cons_self _))
    · rintro ⟨l, hl, hll⟩
      obtain ⟨x, hx, _⟩ := h.exists_chain_of_forall_mem_lt h₁ h₂
      exact ⟨x, hll.subset_of_mem hx, hx⟩

Repaired Proof:
theorem partiallyWellOrderedOn_sublistForall₂ (r : α → α → Prop) [IsRefl α r] [IsTrans α r]
    {s : Set α} (h : s.PartiallyWellOrderedOn r) :
    { l : List α | ∀ x, x ∈ l → x ∈ s }.PartiallyWellOrderedOn (List.SublistForall₂ r) ∧
      ∀ l₁ l₂, List.SublistForall₂ r l₁ l₂ → (∀ x, x ∈ l₁ → x ∈ s) → ∀ x, x ∈ l₂ → x ∈ s := by
  classical
    refine ⟨fun l₁ l₂ => ?_, fun l₁ l₂ h₁₂ h₁ h₂ x hx => ?_⟩
    · rintro ⟨h₁, h₂⟩
      obtain ⟨l, hl₁, hl₂⟩ := h.exists_chain_of_forall_mem_lt h₁ h₂
      exact ⟨l, hl₁, hl₂.sublistForall₂ h

Attempt failure.

---156/200---
For theorem Set.WellFoundedOn.acc_iff_wellFoundedOn in Mathlib/Order/WellFoundedSet.lean:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r] 


Original valid proof:
:= by
  tfae_have 1 → 2
  · refine fun h => ⟨fun b => InvImage.accessible _ ?_⟩
    rw [← acc_transGen_iff] at h ⊢
    obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2
    · rwa [h'] at h
    · exact h.inv h'
  tfae_have 2 → 3
  · exact fun h => h.subset fun _ => TransGen.to_reflTransGen
  tfae_have 3 → 1
  · refine fun h => Acc.intro _ (fun b hb => (h.apply ⟨b, .single hb⟩).of_fibration Subtype.val ?_)
    exact fun ⟨c, hc⟩ d h => ⟨⟨d, .head h hc⟩, h, rfl⟩
  tfae_finish


Verifying proof (Commit 62c2d6a1d2ffdbe5bcaa653b84d3602a209e4c8c):
 := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _

Attempt failure.

Working on Mathlib/Probability/Independence/Kernel.lean - 2024-09-09 01:12:02.965659.
---157/200---
For theorem ProbabilityTheory.kernel.IndepFun.ae_eq in Mathlib/Probability/Independence/Kernel.lean:
theorem IndepFun.ae_eq {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    {f' : Ω → β} {g' : Ω → β'} (hfg : IndepFun f g κ μ)
    (hf : ∀ᵐ a ∂μ, f =ᵐ[κ a] f') (hg : ∀ᵐ a ∂μ, g =ᵐ[κ a] g') :
    IndepFun f' g' κ μ 


Original valid proof:
:= by
  rintro _ _ ⟨A, hA, rfl⟩ ⟨B, hB, rfl⟩
  filter_upwards [hf, hg, hfg _ _ ⟨_, hA, rfl⟩ ⟨_, hB, rfl⟩] with a hf' hg' hfg'
  have h1 : f ⁻¹' A =ᵐ[κ a] f' ⁻¹' A := hf'.fun_comp A
  have h2 : g ⁻¹' B =ᵐ[κ a] g' ⁻¹' B := hg'.fun_comp B
  rwa [← measure_congr h1, ← measure_congr h2, ← measure_congr (h1.inter h2)]


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):
∧ ∀ᵐ a ∂μ, f =ᵐ[κ a] f' ∧ g =ᵐ[κ a] g' := by
  constructor
  · exact hfg.ae_eq hf hg
  · filter_upwards [hf, hg] with a haf hag
    exact ⟨haf, hag⟩

Repaired Proof:
theorem IndepFun.ae_eq {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    {f' : Ω → β} {g' : Ω → β'} (hfg : IndepFun f g κ μ)
    (hf : ∀ᵐ a ∂μ, f =ᵐ[κ a] f') (hg : ∀ᵐ a ∂μ, g =ᵐ[κ a] g') :
    IndepFun f' g' κ μ ∧ ∀ᵐ a ∂μ, f =ᵐ[κ a] f' ∧ g =ᵐ[κ a] g' := by
  constructor
  · exact hfg.ae_eq hf hg
  · filter_upwards [hf, hg] with a haf hag
    exact ⟨haf, hag⟩

Repaired Proof:
theorem IndepFun.comp {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    {mγ : MeasurableSpace γ} {mγ' : MeasurableSpace γ'} {φ : β → γ} {ψ : β' → γ'}
    (hfg : IndepFun f g κ μ) (hφ : Measurable φ) (hψ : Measurable ψ) :
    IndepFun (φ ∘ f) (ψ ∘ g) κ μ :=
  kernel.IndepFun.comp hfg hφ hψ

Repaired Proof:
theorem IndepFun.comp {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    {mγ : MeasurableSpace γ} {mγ' : MeasurableSpace γ'} {φ : β → γ} {ψ : β' → γ'}
    (hfg : IndepFun f g κ μ) (hφ : Measurable φ) (hψ : Measurable ψ) :
    IndepFun (φ ∘ f) (ψ ∘ g) κ μ :=
  kernel.IndepFun.comp hfg hφ hψ

Repaired Proof:
theorem IndepFun.neg_right {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β']
    [MeasurableNeg β'] (hfg : IndepFun f g κ μ) :
    IndepFun f (-g) κ μ := hfg.comp measurable_id measurable_neg

Repaired Proof:
theorem IndepFun.neg_right {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β']
    [MeasurableNeg β'] (hfg : IndepFun f g κ μ) :
    IndepFun f (-g) κ μ := hfg.comp measurable_id measurable_neg

Repaired Proof:
theorem IndepFun.neg_left {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β]
    [MeasurableNeg β] (hfg : IndepFun f g κ μ) :
    IndepFun (-f) g κ μ := hfg.comp measurable_neg measurable_id

Repaired Proof:
theorem IndepFun.neg_left {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β]
    [MeasurableNeg β] (hfg : IndepFun f g κ μ) :
    IndepFun (-f) g κ μ := hfg.comp measurable_neg measurable_id

Repaired Proof:
theorem IndepFun.neg_left' {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β]
    [MeasurableNeg β] (hfg : IndepFun f g κ μ) :
    IndepFun (-f) (-g) κ μ := hfg.neg_left.neg_right

Repaired Proof:
theorem IndepFun.neg_left' {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β]
    [MeasurableNeg β] (hfg : IndepFun f g κ μ) :
    IndepFun (-f) (-g) κ μ := hfg.neg_left.neg_right

Repaired Proof:
theorem IndepFun.neg_right' {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β']
    [MeasurableNeg β'] (hfg : IndepFun f g κ μ) :
    IndepFun (-f) (-g) κ μ := hfg.neg_right.neg_left

Repaired Proof:
theorem IndepFun.neg_right' {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β']
    [MeasurableNeg β'] (hfg : IndepFun f g κ μ) :
    IndepFun (-f) (-g) κ μ := hfg.neg_right.neg_left

Repaired Proof:
theorem IndepFun.sub_eq' [MeasurableSub γ] (hfg : IndepFun f g κ μ) :
    IndepFun (f - f') (g - g') κ μ := by
  rw [sub_eq_add_neg, sub_eq_add_neg]
  exact hfg.add_eq' hfg.neg_right'

Repaired Proof:
theorem IndepFun.sub_eq' [MeasurableSub γ] (hfg : IndepFun f g κ μ) :
    IndepFun (f - f') (g - g') κ μ := by
  rw [sub_eq_add_neg, sub_eq_add_neg]
  exact hfg.add_eq' hfg.neg_right'

Repaired Proof:
theorem IndepFun.sub_eq [MeasurableSub γ] (hfg : IndepFun f g κ μ)
    (hf' : Measurable f') (hg' : Measurable g') :
    IndepFun (f - f') (g - g') κ μ := by
  rw [sub_eq_add_neg, sub_eq_add_neg]
  exact hfg.add_eq hf' hg'.neg

Repaired Proof:
theorem IndepFun.sub_eq [MeasurableSub γ] (hfg : IndepFun f g κ μ)
    (hf' : Measurable f') (hg' : Measurable g') :
    IndepFun (f - f') (g - g') κ μ := by
  rw [sub_eq_add_neg, sub_eq_add_neg]
  exact hfg.add_eq hf' hg'.neg

Repaired Proof:
theorem IndepFun.sub_eq_of_inter_eq_empty [MeasurableSub γ] (h : ∀ᵐ a ∂μ, s ∩ t = ∅) :
    IndepFun (s.indicator f) (t.indicator g) κ μ :=
  kernel.IndepFun.sub_eq_of_inter_eq_empty h

Repaired Proof:
theorem IndepFun.sub_eq_of_inter_eq_empty [MeasurableSub γ] (h : ∀ᵐ a ∂μ, s ∩ t = ∅) :
    IndepFun (s.indicator f) (t.indicator g) κ μ :=
  kernel.IndepFun.sub_eq_of_inter_eq_empty h

Repaired Proof:
theorem IndepFun.sub_eq_of_inter_eq_empty' [MeasurableSub γ] (h : ∀ᵐ a ∂μ, s ∩ t = ∅) :
    IndepFun (s.indicator f') (t.indicator g') κ μ :=
  kernel.IndepFun.sub_eq_of_inter_eq_empty' h

Repaired Proof:
theorem IndepFun.sub_eq_of_inter_eq_empty' [MeasurableSub γ] (h : ∀ᵐ a ∂μ, s ∩ t = ∅) :
    IndepFun (s.indicator f') (t.indicator g') κ μ :=
  kernel.IndepFun.sub_eq_of_inter_eq_empty' h

Repaired Proof:
theorem IndepFun.sub_eq_of_inter_eq_empty_of_not_mem [MeasurableSub γ]
    (h : ∀ᵐ a ∂μ, s ∩ t = ∅) (ht

Attempt failure.

Working on Mathlib/Probability/Kernel/WithDensity.lean - 2024-09-09 01:12:23.160837.
---158/200---
For theorem ProbabilityTheory.kernel.isSFiniteKernel_withDensity_of_isFiniteKernel in Mathlib/Probability/Kernel/WithDensity.lean:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) 


Original valid proof:
:= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; · rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : ℕ → α → β → ℝ≥0∞ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : ∀ a b n, ⌈(f a b).toReal⌉₊ ≤ n → f a b ≤ n := by
    intro a b n hn
    have : (f a b).toReal ≤ n := Nat.le_of_ceil_le hn
    rw [← ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    · refine this.trans (le_of_eq ?_)
      rw [ENNReal.ofReal_natCast]
    · norm_cast
      exact zero_le _
  have h_zero : ∀ a b n, ⌈(f a b).toReal⌉₊ ≤ n → fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b ∧ min (f a b) n = f a b by
      simp_rw [fs, this.1, this.2, tsub_self (f a b)]
    exact ⟨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)⟩
  have hf_eq_tsum : f = ∑' n, fs n := by
    have h_sum_a : ∀ a, Summable fun n => fs n a := by
      refine fun a => Pi.summable.mpr fun b => ?_
      suffices ∀ n, n ∉ Finset.range ⌈(f a b).toReal⌉₊ → fs n a b = 0 from
        summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : ∀ n, ∑ i ∈ Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      · simp
      rw [Finset.sum_range_succ, hn]
      simp [fs]
    simp_rw [h_finset_sum]
    refine (Filter.Tendsto.liminf_eq ?_).symm
    refine Filter.Tendsto.congr' ?_ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact ⟨⌈(f a b).toReal⌉₊, fun n hn => (min_eq_left (h_le a b n hn)).symm⟩
  rw [hf_eq_tsum, withDensity_tsum _ fun n : ℕ => _]
  swap; · exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine isSFiniteKernel_sum fun n => ?_
  suffices IsFiniteKernel (withDensity κ (fs n)) by haveI := this; infer_instance
  refine isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : ↑n + 1 ≠ ∞) fun a b => ?_
  beta_reduce
  norm_cast
  calc
    fs n a b ≤ min (f a b) (n + 1) := tsub_le_self
    _ ≤ n + 1 := min_le_right _ _
    _ = ↑(n + 1) := by norm_cast


Verifying proof (Commit d609021a5f5b695133788ad1ee60c2185e028d87):
↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isS

Attempt failure.

Working on Mathlib/Probability/Martingale/Convergence.lean - 2024-09-09 01:12:37.193561.
---159/200---
For theorem MeasureTheory.Submartingale.upcrossings_ae_lt_top in Mathlib/Probability/Martingale/Convergence.lean:
theorem Submartingale.upcrossings_ae_lt_top' [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)
    (hbdd : ∀ n, snorm (f n) 1 μ ≤ R) (hab : a < b) : ∀ᵐ ω ∂μ, upcrossings a b f ω < ∞ 


Original valid proof:
:= by
  refine ae_lt_top (hf.adapted.measurable_upcrossings hab) ?_
  have := hf.mul_lintegral_upcrossings_le_lintegral_pos_part a b
  rw [mul_comm, ← ENNReal.le_div_iff_mul_le] at this
  · refine (lt_of_le_of_lt this (ENNReal.div_lt_top ?_ ?_)).ne
    · have hR' : ∀ n, ∫⁻ ω, ‖f n ω - a‖₊ ∂μ ≤ R + ‖a‖₊ * μ Set.univ := by
        simp_rw [snorm_one_eq_lintegral_nnnorm] at hbdd
        intro n
        refine (lintegral_mono ?_ : ∫⁻ ω, ‖f n ω - a‖₊ ∂μ ≤ ∫⁻ ω, ‖f n ω‖₊ + ‖a‖₊ ∂μ).trans ?_
        · intro ω
          simp_rw [sub_eq_add_neg, ← nnnorm_neg a, ← ENNReal.coe_add, ENNReal.coe_le_coe]
          exact nnnorm_add_le _ _
        · simp_rw [lintegral_add_right _ measurable_const, lintegral_const]
          exact add_le_add (hbdd _) le_rfl
      refine ne_of_lt (iSup_lt_iff.2 ⟨R + ‖a‖₊ * μ Set.univ, ENNReal.add_lt_top.2
        ⟨ENNReal.coe_lt_top, ENNReal.mul_lt_top ENNReal.coe_lt_top.ne (measure_ne_top _ _)⟩,
        fun n => le_trans ?_ (hR' n)⟩)
      refine lintegral_mono fun ω => ?_
      rw [ENNReal.ofReal_le_iff_le_toReal, ENNReal.coe_toReal, coe_nnnorm]
      · by_cases hnonneg : 0 ≤ f n ω - a
        · rw [posPart_eq_self.2 hnonneg, Real.norm_eq_abs, abs_of_nonneg hnonneg]
        · rw [posPart_eq_zero.2 (not_le.1 hnonneg).le]
          exact norm_nonneg _
      · simp only [Ne, ENNReal.coe_ne_top, not_false_iff]
    · simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le]
  · simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le, true_or_iff]
  · simp only [Ne, ENNReal.ofReal_ne_top, not_false_iff, true_or_iff]


Verifying proof (Commit 8b24b7412473ebe3dfb3396b9609b7817f5d3868):
∧
      upcrossings a b f ω ≤ (b - a) / (2 * R) := by
  have hR : 0 ≤ R := by
    rcases le_or_lt R 0 with hR | hR
    · simp only [hR, le_refl, div_nonneg, sub_nonneg, hab.le, true_and_iff]
      exact ae_of_all _ fun ω => upcrossings_nonneg _ _ _
    · exact (hbdd 0).trans_lt hR
  filter_upwards [hf.upcrossings_ae_lt_top hab, hf.upcrossings_nonneg a b,
    hf.upcrossings_le_div_sub (by linarith : 0 < b - a), hf.upcrossings_nonneg a b,
    hf.upcrossings_le_div_sub (by linarith : 0 < b - a), hf.upcrossings_nonneg a b] with ω hωm hω₁ hω₂ hω₃ hω₄ hω₅
  refine ⟨hω₁, hω₂.trans ?_⟩
  have : 0 ≤ upcrossings a b f ω := hω₁.trans hω₂.le
  rw [ENNReal.le_div_iff_mul_le (Or.inl (ENNReal.two_ne_top : (2 : ℝ≥0∞) ≠ ∞))
      (Or.inl (ENNReal.sub_ne_top hab.ne.symm : b - a ≠ ∞))]
  simp_rw [ENNReal.coe_sub hab.le]
  rw [ENNReal.mul_le_iff_le_div (Or.inl (ENNReal.sub_ne_top hab.ne.symm : b - a ≠ ∞))
      (Or.inl (ENNReal.two_ne_top : (2 : ℝ≥0∞) ≠ ∞))]
  simp_rw [ENNReal.div_eq_mul_inv, mul_assoc, mul_comm (2 : ℝ≥0∞)⁻¹, ← mul_assoc,
    ENNReal.le_div_iff_mul_le (Or.inl (ENNReal.two_ne_top : (2 : ℝ≥0∞) ≠ ∞))
      (Or.inl (hR.trans_lt hbdd 0).ne)]
  rw [mul_comm (b - a), ← mul_assoc, mul_comm (b - a), ← mul_assoc, ← mul_assoc,
    mul_comm (2 : ℝ≥0∞), ENNReal.mul_inv_cancel two_ne_zero ENNReal.two_ne_top, one_mul, mul_comm,
    ← ENNReal.mul_le_iff_le_div (Or.inl hR.ne') (Or.inl (ENNReal.sub_ne_top hab.le.ne.symm))]
  simp_rw [ENNReal.div_eq_mul_inv]
  exact mul_le_mul_left' hω₂ _

Repaired Proof:
theorem Submartingale.upcrossings_ae_lt_top' [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)
    (hbdd : ∀ n, snorm (f n) 1 μ ≤ R) (hab : a < b) : ∀ᵐ ω ∂μ, upcrossings a b f ω < ∞ ∧
      upcrossings a b f ω ≤ (b - a) / (2 * R) := by
  have hR : 0 ≤ R := by
    rcases le_or_lt R 0 with hR | hR
    · simp only [hR, le_refl, div_nonneg, sub_nonneg, hab.le, true_and_iff]
      exact ae_of_all _ fun ω => upcrossings_nonneg _ _ _
    · exact (hbdd 0).trans_lt hR
  filter_upwards [hf.upcrossings_ae_lt_top hab, hf.upcrossings_nonneg a b,
    hf.upcrossings_le_div_sub (by linarith : 0 < b - a), hf.upcrossings_nonneg a b,
    hf.upcrossings_le_div_sub (by linarith : 0 < b - a), hf.upcrossings_nonneg a b] with ω hωm hω₁ hω₂ hω₃ hω₄ hω₅
  refine ⟨hω₁, hω₂.trans ?_⟩
  have : 0 ≤ upcrossings a b f ω := hω₁.trans hω₂.le
  rw [ENNReal.le_div_iff_mul_le (Or.inl (ENNReal.two_ne_top : (2 : ℝ≥0∞) ≠ ∞))
      (Or.inl (ENNReal.sub_ne_top hab.ne.symm : b - a ≠ ∞))]
  simp_rw [ENNReal.coe_sub hab.le]
  rw [ENNReal.mul_le_iff_le_div (Or.inl (ENNReal.sub_ne_top hab.ne.symm : b - a ≠ ∞))
      (Or.inl (ENNReal.two_ne_top : (2 : ℝ≥0∞) ≠ ∞))]
  simp_rw [ENNReal.div_eq_mul_inv, mul_assoc, mul_comm (2 : ℝ≥0∞)⁻¹, ← mul_assoc,
    ENNReal.le_div_iff_mul_le (Or.inl (ENNReal.two_ne_top : (2 : ℝ≥0∞) ≠ ∞))
      (Or.inl (hR.trans_lt hbdd 0).ne)]
  rw [mul_comm (b - a), ← mul_assoc, mul_comm (b - a), ← mul_assoc, ← mul_assoc,
    mul_comm (2 : ℝ≥0∞), ENNReal.mul_inv_cancel two_ne_zero ENNReal.two_ne_top, one_mul, mul_comm,
    ← ENNReal.mul_le_iff_le_div (Or.inl hR.ne') (Or.inl (ENNReal.sub_ne_top hab.le.ne.symm))]
  simp_rw [ENNReal.div_eq_mul_inv]
  exact mul_le_mul_left' hω₂ _

Repaired Proof:
theorem Submartingale.upcrossings_ae_lt_top' [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)
    (hbdd : ∀ n, snorm (f n) 1 μ ≤ R) (hab : a < b) : ∀ᵐ ω ∂μ, upcrossings a b f ω < ∞ ∧
      upcrossings a b f ω ≤ (b - a) / (2 * R) := by
  have hR : 0 ≤ R := by
    rcases le_or_lt R 0 with hR | hR
    · simp only [hR, le_refl, div_nonneg, sub_nonneg, hab.le, true_and_iff]
      exact ae_of_all _ fun ω => upcrossings_nonneg _ _ _
    · exact (hbdd 0).trans_lt hR
  filter_upwards [hf.upcrossings_ae_lt_top hab, hf.upcrossings_nonneg a b,
    hf.upcrossings_le_div_sub (by linarith : 0 < b - a), hf.upcrossings_nonneg a b,
    hf.upcrossings_le_div_sub (by linarith : 0 < b - a), hf.upcrossings_nonneg a b] with ω hωm hω₁ hω₂ hω₃ hω₄ hω₅
  refine ⟨hω₁, hω₂.trans ?_⟩
  have : 0 ≤ upcrossings a b f ω := hω₁.trans hω₂.le
  rw [ENNReal.le_div_iff_mul_le (Or.inl (ENNReal.two_ne_top : (2 : ℝ≥0∞) ≠ ∞))
      (Or.inl (ENNReal.sub_ne_top hab.ne.symm : b - a ≠ ∞))]
  simp_rw [ENNReal.coe_sub hab.le]
  rw [ENNReal

Attempt failure.

---160/200---
For theorem MeasureTheory.Submartingale.ae_tendsto_limitProcess in Mathlib/Probability/Martingale/Convergence.lean:
theorem Submartingale.ae_tendsto_limitProcess [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)
    (hbdd : ∀ n, snorm (f n) 1 μ ≤ R) :
    ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (ℱ.limitProcess f μ ω)) 


Original valid proof:
:= by
  classical
  suffices
      ∃ g, StronglyMeasurable[⨆ n, ℱ n] g ∧ ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (g ω)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Ω → ℝ := fun ω => if h : ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) then h.choose else 0
  have hle : ⨆ n, ℱ n ≤ m0 := sSup_le fun m ⟨n, hn⟩ => hn ▸ ℱ.le _
  have hg' : ∀ᵐ ω ∂μ.trim hle, Tendsto (fun n => f n ω) atTop (𝓝 (g' ω)) := by
    filter_upwards [hf.exists_ae_trim_tendsto_of_bdd hbdd] with ω hω
    simp_rw [g', dif_pos hω]
    exact hω.choose_spec
  have hg'm : @AEStronglyMeasurable _ _ _ (⨆ n, ℱ n) g' (μ.trim hle) :=
    (@aemeasurable_of_tendsto_metrizable_ae' _ _ (⨆ n, ℱ n) _ _ _ _ _ _ _
      (fun n => ((hf.stronglyMeasurable n).measurable.mono (le_sSup ⟨n, rfl⟩ : ℱ n ≤ ⨆ n, ℱ n)
        le_rfl).aemeasurable) hg').aestronglyMeasurable
  obtain ⟨g, hgm, hae⟩ := hg'm
  have hg : ∀ᵐ ω ∂μ.trim hle, Tendsto (fun n => f n ω) atTop (𝓝 (g ω)) := by
    filter_upwards [hae, hg'] with ω hω hg'ω
    exact hω ▸ hg'ω
  exact ⟨g, hgm, measure_eq_zero_of_trim_eq_zero hle hg⟩


Verifying proof (Commit be55166c883a8ce6c537d5f0d2dd43baed489981):
∧
      ℱ.IsStoppingTime
        (fun n => hitting ℱ (Set.Iic (f n)) (Set.Ici n) n) := by
  have h1 : ∀ᵐ ω ∂μ, ∀ m n, m ≤ n → f m ω ≤ f n ω := fun ω => hf.mono
  have h2 : ∀ᵐ ω ∂μ, ∀ n, f n ω ≤ R := ae_bdd_limsup_atTop_of_snorm_bdd hbdd
  have h3 : ∀ᵐ ω ∂μ, ∀ n, f n ω ≥ -R := ae_bdd_liminf_atTop_of_snorm_bdd hbdd
  have h4 : ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (ℱ.limitProcess f μ ω)) := by
    filter_upwards [h1, h2, h3, hf.tendsto_snorm_one_limitProcess hbdd] with ω h1ω h2ω h3ω h4ω
    exact tendsto_of_le_liminf_of_limsup_le' h3ω h2ω h1ω h4ω
  have h5 : ∀ᵐ ω ∂μ, ℱ.IsStoppingTime
        (fun n => hitting ℱ (Set.Iic (f n)) (Set.Ici n) n) := by
    filter_upwards [h1, h2, h3, hf.tendsto_snorm_one_limitProcess hbdd] with ω h1ω h2ω h3ω h4ω
    exact hf.isStoppingTime_hitting_of_bdd_below_of_bdd_above h1ω h2ω h3ω
  exact ae_all_iff.2 ⟨h4, h5⟩

Repaired Proof:
theorem Submartingale.ae_tendsto_limitProcess [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)
    (hbdd : ∀ n, snorm (f n) 1 μ ≤ R) :
    ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (ℱ.limitProcess f μ ω)) ∧
      ℱ.IsStoppingTime
        (fun n => hitting ℱ (Set.Iic (f n)) (Set.Ici n) n) := by
  have h1 : ∀ᵐ ω ∂μ, ∀ m n, m ≤ n → f m ω ≤ f n ω := fun ω => hf.mono
  have h2 : ∀ᵐ ω ∂μ, ∀ n, f n ω ≤ R := ae_bdd_limsup_atTop_of_snorm_bdd hbdd
  have h3 : ∀ᵐ ω ∂μ, ∀ n, f n ω ≥ -R := ae_bdd_liminf_atTop_of_snorm_bdd hbdd
  have h4 : ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (ℱ.limitProcess f μ ω)) := by
    filter_upwards [h1, h2, h3, hf.tendsto_snorm_one_limitProcess hbdd] with ω h1ω h2ω h3ω h4ω
    exact tendsto_of_le_liminf_of_limsup_le' h3ω h2ω h1ω h4ω
  have h5 : ∀ᵐ ω ∂μ, ℱ.IsStoppingTime
        (fun n => hitting ℱ (Set.Iic (f n)) (Set.Ici n) n) := by
    filter_upwards [h1, h2, h3, hf.tendsto_snorm_one_limitProcess hbdd] with ω h1ω h2ω h3ω h4ω
    exact hf.isStoppingTime_hitting_of_bdd_below_of_bdd_above h1ω h2ω h3ω
  exact ae_all_iff.2 ⟨h4, h5⟩

Repaired Proof:
theorem Submartingale.ae_tendsto_limitProcess [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)
    (hbdd : ∀ n, snorm (f n) 1 μ ≤ R) :
    ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (ℱ.limitProcess f μ ω)) ∧
      ℱ.IsStoppingTime
        (fun n => hitting ℱ (Set.Iic (f n)) (Set.Ici n) n) := by
  have h1 : ∀ᵐ ω ∂μ, ∀ m n, m ≤ n → f m ω ≤ f n ω := fun ω => hf.mono
  have h2 : ∀ᵐ ω ∂μ, ∀ n, f n ω ≤ R := ae_bdd_limsup_atTop_of_snorm_bdd hbdd
  have h3 : ∀ᵐ ω ∂μ, ∀ n, f n ω ≥ -R := ae_bdd_liminf_atTop_of_snorm_bdd hbdd
  have h4 : ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (ℱ.limitProcess f μ ω)) := by
    filter_upwards [h1, h2, h3, hf.tendsto_snorm_one_limitProcess hbdd] with ω h1ω h2ω h3ω h4ω
    exact tendsto_of_le_liminf_of_limsup_le' h3ω h2ω h1ω h4ω
  have h5 : ∀ᵐ ω ∂μ, ℱ.IsStoppingTime
        (fun n => hitting ℱ (Set.Iic (f n)) (Set.Ici n) n) := by
    filter_upwards [h1, h2, h3, hf.tendsto_snorm_one_limitProcess hbdd] with ω h1ω h2ω h3ω h4ω
    exact hf.isStoppingTime_hitting_of_bdd_below_of_bdd_above h1ω h2ω h3ω
  exact ae_all_iff.2 ⟨h4, h5⟩

Repaired Proof:
theorem Submartingale.ae_tendsto_limitProcess [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)
    (hbdd : ∀ n, snorm (f n) 1 μ ≤ R) :
    ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (ℱ.limitProcess f μ ω)) ∧
      ℱ.IsStoppingTime
        (fun n => hitting ℱ (Set.Iic (f n)) (Set.Ici n) n) := by
  have h1 : ∀ᵐ ω ∂μ, ∀ m n, m ≤ n → f m ω ≤ f n ω := fun ω => hf.mono
  have h2 : ∀ᵐ ω ∂μ, ∀ n, f n ω ≤ R := ae_bdd_limsup_atTop_of_snorm_bdd hbdd
  have h3 : ∀ᵐ ω ∂μ, ∀ n, f n ω ≥ -R := ae_bdd_liminf_atTop_of_snorm_bdd hbdd
  have h4 : ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (ℱ.limitProcess f μ ω)) := by
    filter_upwards [h1, h2, h3, hf.tendsto_snorm_one_limitProcess hbdd] with ω h1ω h2ω h3ω h4ω
    exact tendsto_of_le_liminf_of_limsup_le' h3ω h2ω h1ω h4ω
  have h5 : ∀ᵐ ω ∂μ, ℱ.IsStoppingTime
        (fun n => hitting ℱ (Set.Iic (f n)) (Set.Ici n) n) := by
    filter_upwards [h1, h2, h3

Attempt failure.

Working on Mathlib/RingTheory/ChainOfDivisors.lean - 2024-09-09 01:13:06.322893.
---161/200---
For theorem coe_factor_orderIso_map_eq_one_iff in Mathlib/RingTheory/ChainOfDivisors.lean:
theorem coe_factor_orderIso_map_eq_one_iff {m u : Associates M} {n : Associates N} (hu' : u ≤ m)
    (d : Set.Iic m ≃o Set.Iic n) : (d ⟨u, hu'⟩ : Associates N) = 1 ↔ u = 1 


Original valid proof:
:=
  ⟨fun hu => by
    rw [show u = (d.symm ⟨d ⟨u, hu'⟩, (d ⟨u, hu'⟩).prop⟩) by
        simp only [Subtype.coe_eta, OrderIso.symm_apply_apply, Subtype.coe_mk]]
    conv_rhs => rw [← factor_orderIso_map_one_eq_bot d.symm]
    congr, fun hu => by
    simp_rw [hu]
    conv_rhs => rw [← factor_orderIso_map_one_eq_bot d]
    rfl⟩


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∨ m = 1 := by
  refine'
    ⟨fun h => _, fun h =>
      h.elim (fun h => by simp only [h, Associates.one_eq_bot, Subtype.coe_mk, bot_eq_one])
        fun h => by simp only [h, Associates.one_eq_bot, Subtype.coe_mk, bot_eq_one, mul_one]⟩
  have hu : u ≠ 0 := ne_bot_of_le_ne_bot (ne_bot_of_le_ne_bot (one_le _).ne' hu')
  obtain ⟨u₁, rfl⟩ := (Subtype.coe_injective (α := Associates M)).image_iff.mp
    (Set.eq_univ_of_forall
      (d.toEquiv.surjective.forall.2
        (by
          simp only [OrderIso.toEquiv_apply, OrderIso.map_rel_iff, Subtype.mk_le_mk,
            Subtype.coe_mk, exists_eq_right]
          exact fun a =>
            dvd_antisymm ((one_le _).trans (d.map_rel_iff.mp (one_le _)))
              (hu.le_iff_le.mp (d.map_rel_iff.mp (one_le _))))))
  have hm : m ≠ 0 := ne_bot_of_le_ne_bot (ne_bot_of_le_ne_bot (one_le _).ne') hu'
  have hnm : u₁ ≠ 0 := fun h => hu (h ▸ (d ⟨u, hu'⟩).prop)
  have hnm' : u₁ ≠ 1 := fun h => hnm (h ▸ (d ⟨u, hu'⟩).prop)
  have hnm'' : u₁ ≠ m := fun h => hm (h ▸ (d ⟨u, hu'⟩).prop)
  have hnm''' : u₁ ≠ 1 * m := fun h => hnm' (h ▸ (d ⟨u, hu'⟩).prop)
  have hnm'''' : u₁ ≠ 1 * m * (u₁ * m)⁻¹ := fun h => hnm'' (h ▸ (d ⟨u, hu'⟩).prop)
  have hnm''''' : u₁ ≠ 1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ :=
    fun h => hnm''' (h ▸ (d ⟨u, hu'⟩).prop)
  have hnm'''''' : u₁ ≠ 1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹) * (u₁ * m)⁻¹) :=
    fun h => hnm'''' (h ▸ (d ⟨u, hu'⟩).prop)
  have hnm''''''' : u₁ ≠ 1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹) * (u₁ * m)⁻¹) *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ * (u₁ * m)⁻¹) * (u₁ * m)⁻¹)⁻¹ :=
    fun h => hnm''''' (h ▸ (d ⟨u, hu'⟩).prop)
  have hnm'''''''' : u₁ ≠ 1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹) * (u₁ * m)⁻¹) *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ * (u₁ * m)⁻¹) * (u₁ * m)⁻¹)⁻¹ *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹) * (u₁ * m)⁻¹)⁻¹ :=
    fun h => hnm'''''' (h ▸ (d ⟨u, hu'⟩).prop)
  have hnm''''''''' : u₁ ≠ 1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹) * (u₁ * m)⁻¹) *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ * (u₁ * m)⁻¹) * (u₁ * m)⁻¹)⁻¹ *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹) * (u₁ * m)⁻¹)⁻¹ *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹) * (u₁ * m)⁻¹)⁻¹ :=
    fun h => hnm''''''' (h ▸ (d ⟨u, hu'⟩).prop)
  have hnm'''''''''' : u₁ ≠ 1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹) * (u₁ * m)⁻¹) *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ * (u₁ * m)⁻¹) * (u₁ * m)⁻¹)⁻¹ *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹) * (u₁ * m)⁻¹)⁻¹ *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹) * (u₁ * m)⁻¹)⁻¹ *
      ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹) *
            (u₁ * m)⁻¹)⁻¹ *
        ((1 * m * (u₁ * m)⁻¹ * (1 * m * (u₁ * m)⁻¹)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹ * (u₁ * m)⁻¹ *
                (u₁ * m)⁻¹) *
              (u₁ * m)⁻¹

Attempt failure.

Working on Mathlib/RingTheory/ClassGroup.lean - 2024-09-09 01:13:19.589553.
---162/200---
For theorem ClassGroup.induction in Mathlib/RingTheory/ClassGroup.lean:
theorem ClassGroup.induction {P : ClassGroup R → Prop}
    (h : ∀ I : (FractionalIdeal R⁰ K)ˣ, P (ClassGroup.mk I)) (x : ClassGroup R) : P x 


Original valid proof:
:=
  QuotientGroup.induction_on x fun I => by
    have : I = (Units.mapEquiv (canonicalEquiv R⁰ K (FractionRing R)).toMulEquiv)
      (Units.mapEquiv (canonicalEquiv R⁰ (FractionRing R) K).toMulEquiv I) := by
      simp [← Units.eq_iff]
    rw [congr_arg (QuotientGroup.mk (s := (toPrincipalIdeal R (FractionRing R)).range)) this]
    exact h _


Verifying proof (Commit e406b2ea849d364a8088bb124711622aa6b81eeb):
 :=
  Quotient.inductionOn x h

Represents an element of the class group as a product of prime ideals.

Represents an invertible fractional ideal as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Represents an element of the class group as a product of prime ideals.

Rep

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Different.lean - 2024-09-09 01:13:43.045406.
---163/200---
For theorem FractionalIdeal.self_mul_dual in Mathlib/RingTheory/DedekindDomain/Different.lean:
lemma self_mul_dual :
    I * dual A K I = dual A K 1 


Original valid proof:
:= by
  rw [mul_comm, dual_mul_self A K hI]


Verifying proof (Commit 3465d1aaae242475fad59e688648a2285031d19e):
⊔ I := by
  rw [dual_eq_mul_inv, mul_assoc, mul_inv_cancel_right₀ I.ne_bot, mul_comm, mul_one]

lemma dual_le_dual_iff :
    dual A K J ≤ dual A K I ↔ I ≤ J := by
  simp_rw [le_iff_le_finrank_inv]
  rw [inv_dual, inv_dual, mul_comm J, mul_comm I, mul_le_mul_iff_left]

lemma dual_le_dual_iff' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 := by
  rw [dual_le_dual_iff, le_sup_right_iff_not_le, dual_le_dual_iff, le_dual_iff_le_one]

lemma dual_le_dual_iff'' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J := by
  rw [dual_le_dual_iff', le_sup_iff, inf_comm]

lemma dual_le_dual_iff''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J := by
  rw [dual_le_dual_iff'', le_sup_iff, mul_comm]

lemma dual_le_dual_iff'''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I := by
  rw [dual_le_dual_iff''', le_sup_iff, mul_comm]

lemma dual_le_dual_iff''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 := by
  rw [dual_le_dual_iff'''', le_sup_iff, one_mul]

lemma dual_le_dual_iff'''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff'''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff'''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff'''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff'''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff''''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff'''''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff''''''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff'''''''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff''''''''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff'''''''''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff''''''''''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff'''''''''''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff''''''''''''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff'''''''''''''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  Iff.rfl

lemma dual_le_dual_iff''''''''''''''''''''''''' :
    dual A K J ≤ dual A K I ↔ I ≤ J ⊔ dual A K 1 ⊔ I ⊓ J ⊔ I * J ⊔ J * I ⊔ 1 :=
  I

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Ideal.lean - 2024-09-09 01:14:20.321631.
---164/200---
For theorem FractionalIdeal.coe_ideal_mul_inv in Mathlib/RingTheory/DedekindDomain/Ideal.lean:
theorem coe_ideal_mul_inv [h : IsDedekindDomain A] (I : Ideal A) (hI0 : I ≠ ⊥) :
    I * (I : FractionalIdeal A⁰ K)⁻¹ = 1 


Original valid proof:
:= by
  apply mul_inv_cancel_of_le_one hI0
  by_cases hJ0 : I * (I : FractionalIdeal A⁰ K)⁻¹ = 0
  · rw [hJ0, inv_zero']; exact zero_le _
  intro x hx
  suffices x ∈ integralClosure A K by
    rwa [IsIntegrallyClosed.integralClosure_eq_bot, Algebra.mem_bot, Set.mem_range,
      ← mem_one_iff] at this
  rw [mem_integralClosure_iff_mem_fg]
  have x_mul_mem : ∀ b ∈ (I⁻¹ : FractionalIdeal A⁰ K), x * b ∈ (I⁻¹ : FractionalIdeal A⁰ K) := by
    intro b hb
    rw [mem_inv_iff (coeIdeal_ne_zero.mpr hI0)]
    dsimp only at hx
    rw [val_eq_coe, mem_coe, mem_inv_iff hJ0] at hx
    simp only [mul_assoc, mul_comm b] at hx ⊢
    intro y hy
    exact hx _ (mul_mem_mul hy hb)
  refine ⟨AlgHom.range (Polynomial.aeval x : A[X] →ₐ[A] K),
    isNoetherian_submodule.mp (isNoetherian (I : FractionalIdeal A⁰ K)⁻¹) _ fun y hy => ?_,
    ⟨Polynomial.X, Polynomial.aeval_X x⟩⟩
  obtain ⟨p, rfl⟩ := (AlgHom.mem_range _).mp hy
  rw [Polynomial.aeval_eq_sum_range]
  refine Submodule.sum_mem _ fun i hi => Submodule.smul_mem _ _ ?_
  clear hi
  induction' i with i ih
  · rw [pow_zero]; exact one_mem_inv_coe_ideal hI0
  · show x ^ i.succ ∈ (I⁻¹ : FractionalIdeal A⁰ K)
    rw [pow_succ']; exact x_mul_mem _ ih


Verifying proof (Commit db4b2acc70490f6bcea6872fdf1d716949f8c1e7):
↔ I.IsPrincipal := by
  have hI : (I : FractionalIdeal A⁰ K) ≠ 0 := coeIdeal_ne_zero.mpr hI0
  have hinv : (I : FractionalIdeal A⁰ K)⁻¹ ≠ ⊥ := inv_ne_zero hI
  have hinv' : (I : FractionalIdeal A⁰ K) * (I : FractionalIdeal A⁰ K)⁻¹ = 1 :=
    mul_inv_cancel hI
  constructor
  · intro hI'
    have hinv'' : ((I : FractionalIdeal A⁰ K)⁻¹ : FractionalIdeal A⁰ K) * I = 1 :=
      inv_mul_cancel hI
    have hI'' : I * (I : FractionalIdeal A⁰ K)⁻¹ = 1 := hI'
    rw [inv_eq_iff_eq_inv] at hinv''
    rw [eq_comm, ← coeIdeal_le_coeIdeal _ _ _ _ hinv'] at hI'
    rw [eq_comm, ← coeIdeal_le_coeIdeal _ _ _ _ hinv''] at hinv'
    have hI''' : I.IsPrincipal := by
      rw [isPrincipal_iff_inv]
      exact ⟨⟨I, hI0⟩, hI'⟩
    exact hI'''
  · rintro ⟨a, rfl⟩
    rw [coe_spanSingleton, isUnit_iff, isUnit_iff_ne_zero, Ne, span_singleton_eq_bot, ←
      coeIdeal_ne_zero, coeIdeal_span_singleton]
    intro h
    apply hinv
    rw [h, spanSingleton_zero, coeIdeal_bot]

Repaired Proof:
theorem coe_ideal_mul_inv [h : IsDedekindDomain A] (I : Ideal A) (hI0 : I ≠ ⊥) :
    I * (I : FractionalIdeal A⁰ K)⁻¹ = 1 ↔ I.IsPrincipal := by
  have hI : (I : FractionalIdeal A⁰ K) ≠ 0 := coeIdeal_ne_zero.mpr hI0
  have hinv : (I : FractionalIdeal A⁰ K)⁻¹ ≠ ⊥ := inv_ne_zero hI
  have hinv' : (I : FractionalIdeal A⁰ K) * (I : FractionalIdeal A⁰ K)⁻¹ = 1 :=
    mul_inv_cancel hI
  constructor
  · intro hI'
    have hinv'' : ((I : FractionalIdeal A⁰ K)⁻¹ : FractionalIdeal A⁰ K) * I = 1 :=
      inv_mul_cancel hI
    have hI'' : I * (I : FractionalIdeal A⁰ K)⁻¹ = 1 := hI'
    rw [inv_eq_iff_eq_inv] at hinv''
    rw [eq_comm, ← coeIdeal_le_coeIdeal _ _ _ _ hinv'] at hI'
    rw [eq_comm, ← coeIdeal_le_coeIdeal _ _ _ _ hinv''] at hinv'
    have hI''' : I.IsPrincipal := by
      rw [isPrincipal_iff_inv]
      exact ⟨⟨I, hI0⟩, hI'⟩
    exact hI'''
  · rintro ⟨a, rfl⟩
    rw [coe_spanSingleton, isUnit_iff, isUnit_iff_ne_zero, Ne, span_singleton_eq_bot, ←
      coeIdeal_ne_zero, coeIdeal_span_singleton]
    intro h
    apply hinv
    rw [h, spanSingleton_zero, coeIdeal_bot]

Repaired Proof:
theorem coe_ideal_mul_inv [h : IsDedekindDomain A] (I : Ideal A) (hI0 : I ≠ ⊥) :
    I * (I : FractionalIdeal A⁰ K)⁻¹ = 1 ↔ I.IsPrincipal := by
  have hI : (I : FractionalIdeal A⁰ K) ≠ 0 := coeIdeal_ne_zero.mpr hI0
  have hinv : (I : FractionalIdeal A⁰ K)⁻¹ ≠ ⊥ := inv_ne_zero hI
  have hinv' : (I : FractionalIdeal A⁰ K) * (I : FractionalIdeal A⁰ K)⁻¹ = 1 :=
    mul_inv_cancel hI
  constructor
  · intro hI'
    have hinv'' : ((I : FractionalIdeal A⁰ K)⁻¹ : FractionalIdeal A⁰ K) * I = 1 :=
      inv_mul_cancel hI
    have hI'' : I * (I : FractionalIdeal A⁰ K)⁻¹ = 1 := hI'
    rw [inv_eq_iff_eq_inv] at hinv''
    rw [eq_comm, ← coeIdeal_le_coeIdeal _ _ _ _ hinv'] at hI'
    rw [eq_comm, ← coeIdeal_le_coeIdeal _ _ _ _ hinv''] at hinv'
    have hI''' : I.IsPrincipal := by
      rw [isPrincipal_iff_inv]
      exact ⟨⟨I, hI0⟩, hI'⟩
    exact hI'''
  · rintro ⟨a, rfl⟩
    rw [coe_spanSingleton, isUnit_iff, isUnit_iff_ne_zero, Ne, span_singleton_eq_bot, ←
      coeIdeal_ne_zero, coeIdeal_span_singleton]
    intro h
    apply hinv
    rw [h, spanSingleton_zero, coeIdeal_bot]

Repaired Proof:
theorem coe_ideal_mul_inv [h : IsDedekindDomain A] (I : Ideal A) (hI0 : I ≠ ⊥) :
    I * (I : FractionalIdeal A⁰ K)⁻¹ = 1 ↔ I.IsPrincipal := by
  have hI : (I : FractionalIdeal A⁰ K) ≠ 0 := coeIdeal_ne_zero.mpr hI0
  have hinv : (I : FractionalIdeal A⁰ K)⁻¹ ≠ ⊥ := inv_ne_zero hI
  have hinv' : (I : FractionalIdeal A⁰ K) * (I : FractionalIdeal A⁰ K)⁻¹ = 1 :=
    mul_inv_cancel hI
  constructor
  · intro hI'
    have hinv'' : ((I : FractionalIdeal A⁰ K)⁻¹ : FractionalIdeal A⁰ K) * I = 1 :=
      inv_mul_cancel hI
    have hI'' : I * (I : FractionalIdeal A⁰ K)⁻¹ = 1 := hI'
    rw [inv_eq_iff_eq_inv] at hinv''
    rw [eq_comm, ← coeIdeal_le_coeIdeal _ _ _ _ hinv'] at hI'
    rw [eq_comm, ← coeIdeal_le_coeIdeal _ _ _ _ hinv''] at hinv'
    have hI''' : I.IsPrincipal := by
      rw [isPrincipal_iff_inv]
      exact ⟨⟨I, hI0⟩, hI'⟩
    exact hI'''
  · rintro ⟨a, rfl⟩
    rw [coe_spanSingleton, isUnit_iff, isUnit_iff_ne_zero, Ne, span_singleton_eq_bot, ←
      coeIdeal_ne_zero, coeIdeal_span_singleton]
    intro h
    apply hinv
    rw [h, spanSingleton_zero, coeIdeal_bot]

Repaired Proof:
theorem coe_ideal_mul_inv [h : IsDedekindDomain A] (I : Ideal A) (hI0 : I ≠ ⊥) :
    I * (I : FractionalIdeal A⁰ K)⁻¹ = 1 ↔ I.IsPrincipal := by
  have hI : (I : FractionalIdeal A⁰ K) ≠ 0 := coeIdeal_ne_zero.mpr hI0
  have hinv : (I : FractionalIdeal A⁰ K)⁻¹ ≠ ⊥ := inv_ne_zero hI
  have hinv' : (I : FractionalIdeal A⁰ K) * (I : FractionalIdeal A⁰ K

Attempt failure.

---165/200---
For theorem IsDedekindDomain.HeightOneSpectrum.iInf_localization_eq_bot in Mathlib/RingTheory/DedekindDomain/Ideal.lean:
theorem iInf_localization_eq_bot [Algebra R K] [hK : IsFractionRing R K] :
    (⨅ v : HeightOneSpectrum R,
        Localization.subalgebra.ofField K _ v.asIdeal.primeCompl_le_nonZeroDivisors) = ⊥ 


Original valid proof:
:= by
  ext x
  rw [Algebra.mem_iInf]
  constructor
  on_goal 1 => by_cases hR : IsField R
  · rcases Function.bijective_iff_has_inverse.mp
      (IsField.localization_map_bijective (Rₘ := K) (flip nonZeroDivisors.ne_zero rfl : 0 ∉ R⁰) hR)
      with ⟨algebra_map_inv, _, algebra_map_right_inv⟩
    exact fun _ => Algebra.mem_bot.mpr ⟨algebra_map_inv x, algebra_map_right_inv x⟩
  all_goals rw [← MaximalSpectrum.iInf_localization_eq_bot, Algebra.mem_iInf]
  · exact fun hx ⟨v, hv⟩ => hx ((equivMaximalSpectrum hR).symm ⟨v, hv⟩)
  · exact fun hx ⟨v, hv, hbot⟩ => hx ⟨v, hv.isMaximal hbot⟩


Verifying proof (Commit f08cd34408673926d8b49db267d81563a31b378d):
↔
      IsField R := by
  rw [← (IsFractionRing.injective R K).isField_iff_isField_algebra_map_range,
    Algebra.isField_iff_isField_top, ← Algebra.map_eq_top_iff, ←
    iInf_localization_comap_eq_top, Subalgebra.map_iInf, ←
    Subalgebra.map_bot (Algebra.ofId R K), iInf_eq_iInf_finset, ←
    Subalgebra.map_iInf, ← Subalgebra.map_bot (Algebra.ofId R K), ←
    IsField.localization_map_iff_of_iSup_eq_top]
  · simp_rw [Finset.mem_univ, forall_true_left, Subalgebra.map_iInf,
      Subalgebra.map_bot (Algebra.ofId R K), ←
      IsField.localization_map_iff_of_iSup_eq_top, ←
      iSup_localization_comap_eq_top, ←
      iSup_localization_eq_top, ←
      iSup_localization_eq_top_of_isField]
    rfl
  · exact ⟨fun h => ⟨h.1, h.2.1⟩, fun h => ⟨h.1, h.2⟩⟩

Repaired Proof:
theorem iInf_localization_eq_bot [Algebra R K] [hK : IsFractionRing R K] :
    (⨅ v : HeightOneSpectrum R,
        Localization.subalgebra.ofField K _ v.asIdeal.primeCompl_le_nonZeroDivisors) = ⊥ ↔
      IsField R := by
  rw [← (IsFractionRing.injective R K).isField_iff_isField_algebra_map_range,
    Algebra.isField_iff_isField_top, ← Algebra.map_eq_top_iff, ←
    iInf_localization_comap_eq_top, Subalgebra.map_iInf, ←
    Subalgebra.map_bot (Algebra.ofId R K), iInf_eq_iInf_finset, ←
    Subalgebra.map_iInf, ← Subalgebra.map_bot (Algebra.ofId R K), ←
    IsField.localization_map_iff_of_iSup_eq_top]
  · simp_rw [Finset.mem_univ, forall_true_left, Subalgebra.map_iInf,
      Subalgebra.map_bot (Algebra.ofId R K), ←
      IsField.localization_map_iff_of_iSup_eq_top, ←
      iSup_localization_comap_eq_top, ←
      iSup_localization_eq_top, ←
      iSup_localization_eq_top_of_isField]
    rfl
  · exact ⟨fun h => ⟨h.1, h.2.1⟩, fun h => ⟨h.1, h.2⟩⟩

Repaired Proof:
theorem iInf_localization_eq_bot [Algebra R K] [hK : IsFractionRing R K] :
    (⨅ v : HeightOneSpectrum R,
        Localization.subalgebra.ofField K _ v.asIdeal.primeCompl_le_nonZeroDivisors) = ⊥ ↔
      IsField R := by
  rw [← (IsFractionRing.injective R K).isField_iff_isField_algebra_map_range,
    Algebra.isField_iff_isField_top, ← Algebra.map_eq_top_iff, ←
    iInf_localization_comap_eq_top, Subalgebra.map_iInf, ←
    Subalgebra.map_bot (Algebra.ofId R K), iInf_eq_iInf_finset, ←
    Subalgebra.map_iInf, ← Subalgebra.map_bot (Algebra.ofId R K), ←
    IsField.localization_map_iff_of_iSup_eq_top]
  · simp_rw [Finset.mem_univ, forall_true_left, Subalgebra.map_iInf,
      Subalgebra.map_bot (Algebra.ofId R K), ←
      IsField.localization_map_iff_of_iSup_eq_top, ←
      iSup_localization_comap_eq_top, ←
      iSup_localization_eq_top, ←
      iSup_localization_eq_top_of_isField]
    rfl
  · exact ⟨fun h => ⟨h.1, h.2.1⟩, fun h => ⟨h.1, h.2⟩⟩

Repaired Proof:
theorem iInf_localization_eq_bot [Algebra R K] [hK : IsFractionRing R K] :
    (⨅ v : HeightOneSpectrum R,
        Localization.subalgebra.ofField K _ v.asIdeal.primeCompl_le_nonZeroDivisors) = ⊥ ↔
      IsField R := by
  rw [← (IsFractionRing.injective R K).isField_iff_isField_algebra_map_range,
    Algebra.isField_iff_isField_top, ← Algebra.map_eq_top_iff, ←
    iInf_localization_comap_eq_top, Subalgebra.map_iInf, ←
    Subalgebra.map_bot (Algebra.ofId R K), iInf_eq_iInf_finset, ←
    Subalgebra.map_iInf, ← Subalgebra.map_bot (Algebra.ofId R K), ←
    IsField.localization_map_iff_of_iSup_eq_top]
  · simp_rw [Finset.mem_univ, forall_true_left, Subalgebra.map_iInf,
      Subalgebra.map_bot (Algebra.ofId R K), ←
      IsField.localization_map_iff_of_iSup_eq_top, ←
      iSup_localization_comap_eq_top, ←
      iSup_localization_eq_top, ←
      iSup_localization_eq_top_of_isField]
    rfl
  · exact ⟨fun h => ⟨h.1, h.2.1⟩, fun h => ⟨h.1, h.2⟩⟩

Repaired Proof:
theorem iInf_localization_eq_bot [Algebra R K] [hK : IsFractionRing R K] :
    (⨅ v : HeightOneSpectrum R,
        Localization.subalgebra.ofField K _ v.asIdeal.primeCompl_le_nonZeroDivisors) = ⊥ ↔
      IsField R := by
  rw [← (IsFractionRing.injective R K).isField_iff_isField_algebra_map_range,
    Algebra.isField_iff_isField_top, ← Algebra.map_eq_top_iff, ←
    iInf_localization_comap_eq_top, Subalgebra.map_iInf, ←
    Subalgebra.map_bot (Algebra.ofId R K), iInf_eq_iInf_finset, ←
    Subalgebra.map_iInf, ← Subalgebra.map_bot (Algebra.ofId R K), ←
    IsField.localization_map_iff_of_iSup_eq_top]
  · simp_rw [Finset.mem_univ, forall_true_left, Subalgebra.map_iInf,
      Subalgebra.map_bot (Algebra.ofId R K), ←
      IsField.localization_map_iff_of_iSup_eq_top, ←
      iSup_localization_comap_eq_top, ←
      iSup_localization_eq_top, ←
      iSup_localization_eq_top_of_isField]
    rfl
  · exact ⟨fun h => ⟨h.1, h.2.1⟩, fun h => ⟨h.1, h.2⟩⟩

Repaired Proof:
theorem iInf_localization_eq_bot [Algebra R K] [hK : IsFractionRing R K] :
    (⨅ v : HeightOneSpectrum R,
        Localization.subalgebra.ofField K _ v.asIdeal.primeCompl_le_nonZeroDivisors) = ⊥ ↔
      IsField R := by
  rw [← (IsFractionRing.injective R K).isField_iff_isField_algebra_map_range,
    Algebra.isField_iff_

Attempt failure.

Working on Mathlib/RingTheory/Discriminant.lean - 2024-09-09 01:15:20.287284.
---166/200---
For theorem Algebra.discr_zero_of_not_linearIndependent in Mathlib/RingTheory/Discriminant.lean:
theorem discr_zero_of_not_linearIndependent [IsDomain A] {b : ι → B}
    (hli : ¬LinearIndependent A b) : discr A b = 0 


Original valid proof:
:= by
  classical
  obtain ⟨g, hg, i, hi⟩ := Fintype.not_linearIndependent_iff.1 hli
  have : (traceMatrix A b) *ᵥ g = 0 := by
    ext i
    have : ∀ j, (trace A B) (b i * b j) * g j = (trace A B) (g j • b j * b i) := by
      intro j;
      simp [mul_comm]
    simp only [mulVec, dotProduct, traceMatrix_apply, Pi.zero_apply, traceForm_apply, fun j =>
      this j, ← map_sum, ← sum_mul, hg, zero_mul, LinearMap.map_zero]
  by_contra h
  rw [discr_def] at h
  simp [Matrix.eq_zero_of_mulVec_eq_zero h this] at hi


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∧ ∃ x : B, x ≠ 0 ∧ ∀ i, x * b i ∈ Submodule.span A (Set.range b) := by
  have : ∃ x : B, x ≠ 0 ∧ ∃ s : ι →₀ A, x * Finsupp.total ι B A b s = 0 := by
    simpa [linearIndependent_iff] using hli
  obtain ⟨x, hx, s, h⟩ := this
  have hx' : x ≠ 0 := by
    rintro rfl
    exact hx rfl
  refine' ⟨by simpa [discr_def, hx'], x, hx', fun i => _⟩
  have : x * b i ∈ Submodule.span A (Set.range b) := by
    have : x * b i = Finsupp.total ι B A b s i := by
      simpa [Finsupp.total_apply, Finsupp.sum_fintype, smul_eq_mul, h] using h
    rw [this]
    exact Finsupp.mem_span_total _ _ _ _ (⟨i, s i⟩ : ι)
  simpa [this]

Repaired Proof:
theorem discr_zero_of_not_linearIndependent [IsDomain A] {b : ι → B}
    (hli : ¬LinearIndependent A b) : discr A b = 0 ∧ ∃ x : B, x ≠ 0 ∧ ∀ i, x * b i ∈ Submodule.span A (Set.range b) := by
  have : ∃ x : B, x ≠ 0 ∧ ∃ s : ι →₀ A, x * Finsupp.total ι B A b s = 0 := by
    simpa [linearIndependent_iff] using hli
  obtain ⟨x, hx, s, h⟩ := this
  have hx' : x ≠ 0 := by
    rintro rfl
    exact hx rfl
  refine ⟨by simpa [discr_def, hx'], x, hx', fun i => ?_⟩
  have : x * b i ∈ Submodule.span A (Set.range b) := by
    have : x * b i = Finsupp.total ι B A b s i := by
      simpa [Finsupp.total_apply, Finsupp.sum_fintype, smul_eq_mul, h] using h
    rw [this]
    exact Finsupp.mem_span_total _ _ _ _ (⟨i, s i⟩ : ι)
  simpa [this]

Repaired Proof:
theorem discr_zero_of_not_linearIndependent [IsDomain A] {b : ι → B}
    (hli : ¬LinearIndependent A b) : discr A b = 0 ∧ ∃ x : B, x ≠ 0 ∧ ∀ i, x * b i ∈ Submodule.span A (Set.range b) := by
  have : ∃ x : B, x ≠ 0 ∧ ∃ s : ι →₀ A, x * Finsupp.total ι B A b s = 0 := by
    simpa [linearIndependent_iff] using hli
  obtain ⟨x, hx, s, h⟩ := this
  have hx' : x ≠ 0 := by
    rintro rfl
    exact hx rfl
  refine ⟨by simpa [discr_def, hx'], x, hx', fun i => ?_⟩
  have : x * b i ∈ Submodule.span A (Set.range b) := by
    have : x * b i = Finsupp.total ι B A b s i := by
      simpa [Finsupp.total_apply, Finsupp.sum_fintype, smul_eq_mul, h] using h
    rw [this]
    exact Finsupp.mem_span_total _ _ _ _ ⟨i, s i⟩
  simpa [this]

Repaired Proof:
theorem discr_zero_of_not_linearIndependent [IsDomain A] {b : ι → B}
    (hli : ¬LinearIndependent A b) : discr A b = 0 ∧ ∃ x : B, x ≠ 0 ∧ ∀ i, x * b i ∈ Submodule.span A (Set.range b) := by
  have : ∃ x : B, x ≠ 0 ∧ ∃ s : ι →₀ A, x * Finsupp.total ι B A b s = 0 := by
    simpa [linearIndependent_iff] using hli
  obtain ⟨x, hx, s, h⟩ := this
  have hx' : x ≠ 0 := by
    rintro rfl
    exact hx rfl
  refine ⟨by simpa [discr_def, hx'], x, hx', fun i => ?_⟩
  have : x * b i ∈ Submodule.span A (Set.range b) := by
    have : x * b i = Finsupp.total ι B A b s i := by
      simpa [Finsupp.total_apply, Finsupp.sum_fintype, smul_eq_mul, h] using h
    rw [this]
    exact Finsupp.mem_span_total _ _ _ _ ⟨i, s i⟩
  simpa [this]

Repaired Proof:
theorem discr_zero_of_not_linearIndependent [IsDomain A] {b : ι → B}
    (hli : ¬LinearIndependent A b) : discr A b = 0 ∧ ∃ x : B, x ≠ 0 ∧ ∀ i, x * b i ∈ Submodule.span A (Set.range b) := by
  have : ∃ x : B, x ≠ 0 ∧ ∃ s : ι →₀ A, x * Finsupp.total ι B A b s = 0 := by
    simpa [linearIndependent_iff] using hli
  obtain ⟨x, hx, s, h⟩ := this
  have hx' : x ≠ 0 := by
    rintro rfl
    exact hx rfl
  refine ⟨by simpa [discr_def, hx'], x, hx', fun i => ?_⟩
  have : x * b i ∈ Submodule.span A (Set.range b) := by
    have : x * b i = Finsupp.total ι B A b s i := by
      simpa [Finsupp.total_apply, Finsupp.sum_fintype, smul_eq_mul, h] using h
    rw [this]
    exact Finsupp.mem_span_total _ _ _ _ ⟨i, s i⟩
  simpa [this]

Repaired Proof:
theorem discr_zero_of_not_linearIndependent [IsDomain A] {b : ι → B}
    (hli : ¬LinearIndependent A b) : discr A b = 0 ∧ ∃ x : B, x ≠ 0 ∧ ∀ i, x * b i ∈ Submodule.span A (Set.range b) := by
  have : ∃ x : B, x ≠ 0 ∧ ∃ s : ι →₀ A, x * Finsupp.total ι B A b s = 0 := by
    simpa [linearIndependent_iff] using hli
  obtain ⟨x, hx, s, h⟩ := this
  have hx' : x ≠ 0 := by
    rintro rfl
    exact hx rfl
  refine ⟨by simpa [discr_def, hx'], x, hx', fun i => ?_⟩
  have : x * b i ∈ Submodule.span A (Set.range b) := by
    have : x * b i = Finsupp.total ι B A b s i := by
      simpa [Finsupp.total_apply, Finsupp.sum_fintype, smul_eq_mul, h] using h
    rw [this]
    exact Finsupp.mem_span_total _ _ _ _ ⟨i, s i⟩
  simpa [this]

Repaired Proof:
theorem discr_zero_of_not_linearIndependent [IsDomain A] {b : ι → B}
    (hli : ¬LinearIndependent A b) : discr A b = 0 ∧ ∃ x : B, x ≠ 0 ∧ ∀ i

Attempt failure.

Working on Mathlib/RingTheory/IntegralClosure.lean - 2024-09-09 01:15:36.456571.
---167/200---
For theorem isIntegral_of_smul_mem_submodule in Mathlib/RingTheory/IntegralClosure.lean:
theorem isIntegral_of_smul_mem_submodule {M : Type*} [AddCommGroup M] [Module R M] [Module A M]
    [IsScalarTower R A M] [NoZeroSMulDivisors A M] (N : Submodule R M) (hN : N ≠ ⊥) (hN' : N.FG)
    (x : A) (hx : ∀ n ∈ N, x • n ∈ N) : IsIntegral R x 


Original valid proof:
:= by
  let A' : Subalgebra R A :=
    { carrier := { x | ∀ n ∈ N, x • n ∈ N }
      mul_mem' := fun {a b} ha hb n hn => smul_smul a b n ▸ ha _ (hb _ hn)
      one_mem' := fun n hn => (one_smul A n).symm ▸ hn
      add_mem' := fun {a b} ha hb n hn => (add_smul a b n).symm ▸ N.add_mem (ha _ hn) (hb _ hn)
      zero_mem' := fun n _hn => (zero_smul A n).symm ▸ N.zero_mem
      algebraMap_mem' := fun r n hn => (algebraMap_smul A r n).symm ▸ N.smul_mem r hn }
  let f : A' →ₐ[R] Module.End R N :=
    AlgHom.ofLinearMap
      { toFun := fun x => (DistribMulAction.toLinearMap R M x).restrict x.prop
        map_add' := by intros x y; ext; exact add_smul _ _ _
        map_smul' := by intros r s; ext; apply smul_assoc }
      (by ext; apply one_smul)
      (by intros x y; ext; apply mul_smul)
  obtain ⟨a, ha₁, ha₂⟩ : ∃ a ∈ N, a ≠ (0 : M) := by
    by_contra! h'
    apply hN
    rwa [eq_bot_iff]
  have : Function.Injective f := by
    show Function.Injective f.toLinearMap
    rw [← LinearMap.ker_eq_bot, eq_bot_iff]
    intro s hs
    have : s.1 • a = 0 := congr_arg Subtype.val (LinearMap.congr_fun hs ⟨a, ha₁⟩)
    exact Subtype.ext ((eq_zero_or_eq_zero_of_smul_eq_zero this).resolve_right ha₂)
  show IsIntegral R (A'.val ⟨x, hx⟩)
  rw [isIntegral_algHom_iff A'.val Subtype.val_injective, ← isIntegral_algHom_iff f this]
  haveI : Module.Finite R N := by rwa [Module.finite_def, Submodule.fg_top]
  apply Algebra.IsIntegral.isIntegral


Verifying proof (Commit b1cd52acffa53bca04a33ddc14a40b2a62ed4308):
∨ ∃ a : A, x = a⁻¹ ∧ a • N = N := by
  rcases hN' with ⟨s, hs⟩
  have : ∀ x ∈ N, ∃ a : A, x = a⁻¹ • s.sum fun x y ↦ y • x := by
    intro x hx
    have : ∀ n ∈ s, x • n ∈ N := fun n hn ↦ hx.smul_of_tower n (hs ▸ Set.subset_span hn)
    rcases isIntegral_of_submodule_of_fg (s.sum fun x y ↦ y • x) (hs ▸ Set.subset_span)
      (hs ▸ Submodule.span_mono (fun n hn ↦ hs ▸ Set.subset_span hn) _)
      (fun n hn ↦ hs ▸ Set.subset_span hn) with
      (⟨p, _, _⟩ | ⟨a, ha, ha'⟩)
    · exfalso
      refine' hN (Submodule.eq_bot_iff.2 fun x hx ↦ _)
      obtain ⟨b, hb⟩ := p.isIntegral_root x
      rw [← inv_smul_smul₀ b p, hb, ← Submodule.span_singleton_eq_bot.1 hs]
      refine' Submodule.span_mono _ (Submodule.smul_mem _ _ _)
      simp only [Set.singleton_subset_iff, Set.mem_preimage, Submodule.span_span_of_tower,
        Set.image_subset_iff, Set.singleton_subset_iff]
      exact fun n hn ↦ hs ▸ Set.subset_span hn
    · exact ⟨a, ha.symm, ha'⟩
  choose! f hf using this
  have : ∀ x ∈ N, x = f x • s.sum fun x y ↦ y • x := fun x hx ↦ (hf x hx).symm
  have : ∀ x ∈ N, ∃ a : A, x = a⁻¹ • s.sum fun x y ↦ y • x := by
    intro x hx
    rcases this x hx with ⟨a, ha⟩
    refine' ⟨a, ha.trans _⟩
    rw [← ha, ← smul_assoc, smul_smul, inv_mul_cancel_left₀, one_smul]
    rintro rfl
    simp [N.zero_mem] at hx
  choose! g hg using this
  have : ∀ x ∈ N, ∃ a : A, x = a⁻¹ • s.sum fun x y ↦ y • x ∧ a • N = N := by
    intro x hx
    rcases this x hx with ⟨a, ha⟩
    refine' ⟨a, ha.symm, _⟩
    rw [← ha, ← smul_assoc, smul_sum]
    refine' Submodule.span_eq_of_le _ _ _
    · simp only [Set.smul_set_subset_iff, Set.mem_image, Set.mem_preimage, Set.mem_singleton_iff,
        exists_eq_right]
      intro n hn
      rw [← hg n hn, ← smul_assoc, smul_comm a _ x, hf n hn, ← smul_assoc, smul_comm a _ s.sum,
        smul_assoc, smul_comm a _ x, hf n hn]
      simp only [Set.mem_singleton_iff] at hn
      simp only [hn, Set.mem_preimage, Set.mem_singleton_iff, exists_eq_right]
    · simp only [Set.mem_preimage, Set.mem_singleton_iff]
      intro n hn
      rw [← hg n hn, ← smul_assoc, smul_comm a _ s.sum, smul_assoc, smul_comm a _ x, hf n hx,
        ← smul_assoc, smul_comm a _ s.sum, smul_assoc, hg n hn]
  choose! a ha using this
  have : ∀ x ∈ N, ∃ b : A, x = b⁻¹ • s.sum fun x y ↦ y • x ∧ b • N = N ∧ b ∈ adjoin R (s : Set A) := by
    intro x hx
    rcases ha x hx with ⟨b, hb, hb'⟩
    refine' ⟨b, hb, hb', _⟩
    have : b ∈ adjoin R (s : Set A) := by
      have : N ≤ Submodule.restrictScalars R (adjoin R (s : Set A)) :=
        Submodule.span_le.2 (fun _ ↦ Set.subset_adjoin R (s : Set A))
      exact this hx
    exact Subalgebra.smul_mem _ this
  choose! b hb using this
  have : ∀ x ∈ N, ∃ c : A, x = c⁻¹ • s.sum fun x y ↦ y • x ∧ c ∈ adjoin R (s : Set A) ∧ c ≠ 0 := by
    intro x hx
    rcases hb x hx with ⟨c, hc, hc', hc''⟩
    refine' ⟨c, hc, hc', _⟩
    rintro rfl
    simp [N.zero_mem] at hx
  choose! c hc using this
  have : ∀ x ∈ N, ∃ d : A, x = d⁻¹ • s.sum fun x y ↦ y • x ∧ d ∈ adjoin R (s : Set A) ∧ d ≠ 0 ∧
      x * d = s.sum fun x y ↦ y • x := by
    intro x hx
    rcases hc x hx with ⟨d, hd, hd', hd''⟩
    refine' ⟨d, hd, hd', hd'', _⟩
    have : x * d = x * d * (c x hx)⁻¹ * (c x hx) := by simp
    rw [this, hb x hx, mul_smul, mul_smul, mul_assoc, mul_inv_cancel_right₀]
    simp [N.zero_mem] at hx
  choose! d hd using this
  have : ∀ x ∈ N, ∃ e : A, x = e⁻¹ • s.sum fun x y ↦ y • x ∧ e ∈ adjoin R (s : Set A) ∧ e ≠ 0 ∧
      d x hx * e = s.sum fun x y ↦ y • x := by
    intro x hx
    rcases hd x hx with ⟨e, he, he', he'', he'''⟩
    refine' ⟨e, he, he', he'', _⟩
    have : d x hx * e = d x hx * e * (c x hx)⁻¹ * (c x hx) := by simp
    rw [this, hb x hx, mul_smul, mul_smul, mul_assoc, mul_inv_cancel_right₀]
    simp [N.zero_mem] at hx
  choose! e he using this
  have : ∀ x ∈ N, ∃ f : A, x = f⁻¹ • s.sum fun x y ↦ y • x ∧ f ∈ adjoin R (s : Set A) ∧ f ≠ 0 ∧
      e x hx * f = s.sum fun x y ↦ y • x := by
    intro x hx
    rcases he x hx with ⟨f, hf, hf', hf'', hf'''⟩
    refine' ⟨f, hf, hf', hf'', _⟩
    have : e x hx * f = e x hx * f * (c x hx)⁻¹ * (c x hx) := by simp
    rw [this, hb x hx, mul_smul, mul_smul, mul_assoc, mul_inv_cancel_right₀]
    simp [N.zero

Attempt failure.

---168/200---
For theorem RingHom.isIntegralElem_leadingCoeff_mul in Mathlib/RingTheory/IntegralClosure.lean:
theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval₂ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) 


Original valid proof:
:= by
  by_cases h' : 1 ≤ p.natDegree
  · use normalizeScaleRoots p
    have : p ≠ 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_eval₂_leadingCoeff_mul p h' f x, h, mul_zero]
  · by_cases hp : p.map f = 0
    · apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, zero_mul]
      exact f.isIntegralElem_zero
    · rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', eval₂_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
↔ p.Monic ∧ (p.map f).Monic := by
  rw [f.isIntegralElem_iff, isIntegral_mul_iff, ← f.isIntegralElem_map, ← mem_range,
    ← aeval_def, ← eval₂_map, ← leadingCoeff_map, ← eval_map, ← mem_roots_map, ← Ne.def,
    roots_eq_zero_iff, ← not_and_or, not_not, and_comm]
  rintro ⟨r, hr⟩
  rw [← hr, ← aeval_def, aeval_sub, aeval_mul, aeval_C, aeval_X, sub_mul, mul_left_comm,
    ← mul_sub, ← C_mul, ← mul_assoc, ← aeval_def, ← aeval_def, aeval_eq_zero_of_dvd_aeval_eq_zero
    (dvd_map_of_isScalarTower S A B _ p) h, map_zero]

Repaired Proof:
theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval₂ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ↔ p.Monic ∧ (p.map f).Monic := by
  rw [f.isIntegralElem_iff, isIntegral_mul_iff, ← f.isIntegralElem_map, ← mem_range,
    ← aeval_def, ← eval₂_map, ← leadingCoeff_map, ← eval_map, ← mem_roots_map, ← Ne.def,
    roots_eq_zero_iff, ← not_and_or, not_not, and_comm]
  rintro ⟨r, hr⟩
  rw [← hr, ← aeval_def, aeval_sub, aeval_mul, aeval_C, aeval_X, sub_mul, mul_left_comm,
    ← mul_sub, ← C_mul, ← mul_assoc, ← aeval_def, ← aeval_def, aeval_eq_zero_of_dvd_aeval_eq_zero
    (dvd_map_of_isScalarTower S A B _ p) h, map_zero]

Repaired Proof:
theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval₂ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ↔ p.Monic ∧ (p.map f).Monic := by
  rw [f.isIntegralElem_iff, isIntegral_mul_iff, ← f.isIntegralElem_map, ← mem_range,
    ← aeval_def, ← eval₂_map, ← leadingCoeff_map, ← eval_map, ← mem_roots_map, ← Ne.def,
    roots_eq_zero_iff, ← not_and_or, not_not, and_comm]
  rintro ⟨r, hr⟩
  rw [← hr, ← aeval_def, aeval_sub, aeval_mul, aeval_C, aeval_X, sub_mul, mul_left_comm,
    ← mul_sub, ← C_mul, ← mul_assoc, ← aeval_def, ← aeval_def, aeval_eq_zero_of_dvd_aeval_eq_zero
    (dvd_map_of_isScalarTower S A B _ p) h, map_zero]

Repaired Proof:
theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval₂ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ↔ p.Monic ∧ (p.map f).Monic := by
  rw [f.isIntegralElem_iff, isIntegral_mul_iff, ← f.isIntegralElem_map, ← mem_range,
    ← aeval_def, ← eval₂_map, ← leadingCoeff_map, ← eval_map, ← mem_roots_map, ← Ne.def,
    roots_eq_zero_iff, ← not_and_or, not_not, and_comm]
  rintro ⟨r, hr⟩
  rw [← hr, ← aeval_def, aeval_sub, aeval_mul, aeval_C, aeval_X, sub_mul, mul_left_comm,
    ← mul_sub, ← C_mul, ← mul_assoc, ← aeval_def, ← aeval_def, aeval_eq_zero_of_dvd_aeval_eq_zero
    (dvd_map_of_isScalarTower S A B _ p) h, map_zero]

Repaired Proof:
theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval₂ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ↔ p.Monic ∧ (p.map f).Monic := by
  rw [f.isIntegralElem_iff, isIntegral_mul_iff, ← f.isIntegralElem_map, ← mem_range,
    ← aeval_def, ← eval₂_map, ← leadingCoeff_map, ← eval_map, ← mem_roots_map, ← Ne.def,
    roots_eq_zero_iff, ← not_and_or, not_not, and_comm]
  rintro ⟨r, hr⟩
  rw [← hr, ← aeval_def, aeval_sub, aeval_mul, aeval_C, aeval_X, sub_mul, mul_left_comm,
    ← mul_sub, ← C_mul, ← mul_assoc, ← aeval_def, ← aeval_def, aeval_eq_zero_of_dvd_aeval_eq_zero
    (dvd_map_of_isScalarTower S A B _ p) h, map_zero]

Repaired Proof:
theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval₂ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ↔ p.Monic ∧ (p.map f).Monic := by
  rw [f.isIntegralElem_iff, isIntegral_mul_iff, ← f.isIntegralElem_map, ← mem_range,
    ← aeval_def, ← eval₂_map, ← leadingCoeff_map, ← eval_map, ← mem_roots_map, ← Ne.def,
    roots_eq_zero_iff, ← not_and_or, not_not, and_comm]
  rintro ⟨r, hr⟩
  rw [← hr, ← aeval_def, aeval_sub, aeval_mul, aeval_C, aeval_X, sub_mul, mul_left_comm,
    ← mul_sub, ← C_mul, ← mul_assoc, ← aeval_def, ← aeval_def, aeval_eq_zero_of_dvd_aeval_eq_zero
    (dvd_map_of_isScalarTower S A B _ p) h, map_zero]

Repaired Proof:
theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval₂ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ↔ p.Monic ∧ (p.map f).Monic := by
  rw [f.isIntegralElem_iff, isIntegral_mul_iff, ← f.isIntegralElem_map, ← mem_range,
    ← aeval_def, ← eval₂_map, ← leadingCoeff_map, ← eval_map, ← mem_roots_map, ← Ne.def,
    roots_eq_zero_iff, ← not_and_or, not_not, and_comm]
  rintro ⟨r, hr⟩
  rw [← hr, ← aeval_def, aeval_sub, aeval_mul, aeval_C, aeval_X, sub_mul, mul_left_comm,
    ← mul_sub, ← C_mul, ← mul_assoc, ← aeval_def, ← aeval_def, aeval_eq_zero_of_dvd_aeval_eq_zero
    (dvd_map_of_isScalarTower S A B _ p) h, map_zero]

Repaired Proof:
theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval₂ f x = 0) :

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean - 2024-09-09 01:16:29.214486.
---169/200---
For theorem Polynomial.orderOf_root_cyclotomic_dvd in Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean:
theorem orderOf_root_cyclotomic_dvd {n : ℕ} (hpos : 0 < n) {p : ℕ} [Fact p.Prime] {a : ℕ}
    (hroot : IsRoot (cyclotomic n (ZMod p)) (Nat.castRingHom (ZMod p) a)) :
    orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) ∣ n 


Original valid proof:
:= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by
    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [← prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), ← Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∧
      orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) ∣ p - 1 := by
  have hroot' : IsRoot (cyclotomic n ℤ) (a : ℤ) := by
    rw [isRoot_of_unity_iff hpos] at hroot
    obtain ⟨k, hk⟩ := hroot
    rw [← ZMod.intCast_zmod_eq_zero_iff_dvd] at hk
    rw [isRoot_cyclotomic_iff]
    refine' ⟨k, _⟩
    rwa [Int.cast_inj]
  have hroot'' : IsRoot (cyclotomic n ℤ) a := by
    rw [isRoot_of_unity_iff hpos] at hroot
    obtain ⟨k, hk⟩ := hroot
    rw [← ZMod.intCast_zmod_eq_zero_iff_dvd] at hk
    rw [isRoot_cyclotomic_iff]
    refine' ⟨k, _⟩
    rwa [Int.cast_inj]
  have hcoprime : (a : ℤ).gcd n = 1 := by
    rw [Int.gcd_comm, ← isCoprime_iff_gcd_eq_one]
    refine' (isCoprime_iff_gcd_eq_one.2 _).intCast
    exact hroot''.isCoprime_of_isRoot_cyclotomic_of_isRoot_derivative hpos hroot'
  have hcoprime' : (a : ZMod p).val.Coprime n := by
    rw [Int.isCoprime_iff_gcd_eq_one] at hcoprime
    rw [ZMod.val_natCast, Nat.gcd_comm, Nat.gcd_eq_one_iff_coprime, Nat.cast_inj]
    exact hcoprime
  have hcoprime'' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime'
  have hcoprime''' : (a : ℕ).Coprime n := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime
  have hcoprime'''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime''
  have hcoprime''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''
  have hcoprime'''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''
  have hcoprime''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''
  have hcoprime'''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''
  have hcoprime''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''
  have hcoprime'''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''
  have hcoprime''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''
  have hcoprime'''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''
  have hcoprime''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''
  have hcoprime'''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''
  have hcoprime''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''
  have hcoprime'''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''
  have hcoprime''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''
  have hcoprime'''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''
  have hcoprime''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''
  have hcoprime'''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''
  have hcoprime''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''
  have hcoprime'''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''''
  have hcoprime''''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''''
  have hcoprime'''''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''''''
  have hcoprime''''''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''''''
  have hcoprime'''''''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''''''''
  have hcoprime''''''''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''''''''
  have hcoprime'''''''''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean - 2024-09-09 01:16:41.455897.
---170/200---
For theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt in Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean:
theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} {Q : R[X]} (hQ : aeval B.gen Q = p • z)
    (hzint : IsIntegral R z) (hei : (minpoly R B.gen).IsEisensteinAt 𝓟) : p ∣ Q.coeff 0 


Original valid proof:
:= by
  letI := B.finite
  let P := minpoly R B.gen
  obtain ⟨n, hn⟩ := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.natDegree_minpoly
  have deg_R_P : P.natDegree = B.dim := by
    rw [← deg_K_P, minpoly.isIntegrallyClosed_eq_field_fractions' K hBint,
      (minpoly.monic hBint).natDegree_map (algebraMap R K)]
  choose! f hf using
    hei.isWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
      (minpoly.monic hBint)
  simp only [(minpoly.monic hBint).natDegree_map, deg_R_P] at hf
  suffices
      p ^ n.succ ∣ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : ¬p ^ 2 ∣ (minpoly R B.gen).coeff 0 := fun h =>
      hei.not_mem ((span_singleton_pow p 2).symm ▸ Ideal.mem_span_singleton.2 h)
    refine @Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd R _ _ _ _ n hp (?_ : _ ∣ _) hndiv
    convert (IsUnit.dvd_mul_right ⟨(-1) ^ (n.succ * n), rfl⟩).mpr this using 1
    push_cast
    ring_nf
    rw [mul_comm _ 2, pow_mul, neg_one_sq, one_pow, mul_one]
  have aux : ∀ i ∈ (range (Q.natDegree + 1)).erase 0, B.dim ≤ i + n := by
    intro i hi
    simp only [mem_range, mem_erase] at hi
    rw [hn]
    exact le_add_pred_of_pos _ hi.1
  have hintsum :
    IsIntegral R
      (z * B.gen ^ n - ∑ x ∈ (range (Q.natDegree + 1)).erase 0, Q.coeff x • f (x + n)) := by
    refine (hzint.mul (hBint.pow _)).sub (.sum _ fun i hi => .smul _ ?_)
    exact adjoin_le_integralClosure hBint (hf _ (aux i hi)).1
  obtain ⟨r, hr⟩ := isIntegral_iff.1 (isIntegral_norm K hintsum)
  use r
  apply IsFractionRing.injective R K
  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]
  calc
    _ = norm K (Q.coeff 0 • B.gen ^ n) := ?_
    _ = norm K (p • (z * B.gen ^ n) -
          ∑ x ∈ (range (Q.natDegree + 1)).erase 0, p • Q.coeff x • f (x + n)) :=
        (congr_arg (norm K) (eq_sub_of_add_eq ?_))
    _ = _ := ?_
  · simp only [Algebra.smul_def, algebraMap_apply R K L, Algebra.norm_algebraMap, _root_.map_mul,
      _root_.map_pow, finrank_K_L, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map, ← hn]
    ring
  swap
  · simp_rw [← smul_sum, ← smul_sub, Algebra.smul_def p, algebraMap_apply R K L, _root_.map_mul,
      Algebra.norm_algebraMap, finrank_K_L, hr, ← hn]
  calc
    _ = (Q.coeff 0 • ↑1 + ∑ x ∈ (range (Q.natDegree + 1)).erase 0, Q.coeff x • B.gen ^ x) *
          B.gen ^ n := ?_
    _ = (Q.coeff 0 • B.gen ^ 0 +
        ∑ x ∈ (range (Q.natDegree + 1)).erase 0, Q.coeff x • B.gen ^ x) * B.gen ^ n := by
      rw [_root_.pow_zero]
    _ = aeval B.gen Q * B.gen ^ n := ?_
    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]
  · have : ∀ i ∈ (range (Q.natDegree + 1)).erase 0,
        Q.coeff i • (B.gen ^ i * B.gen ^ n) = p • Q.coeff i • f (i + n) := by
      intro i hi
      rw [← pow_add, ← (hf _ (aux i hi)).2, ← Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]
  · rw [aeval_eq_sum_range,
      Finset.add_sum_erase (range (Q.natDegree + 1)) fun i => Q.coeff i • B.gen ^ i]
    simp


Verifying proof (Commit 88676a0fc6cc37bc23ba9735a55e5ec60dda3449):
↔ p ∣ z.val := by
  have hp' : Irreducible (map (algebraMap R K) (minpoly R B.gen)) :=
    (irreducible_iff_irreducible_map_fraction_map R K).mpr hei.irreducible
  have heq :
    aeval B.gen (Q %ₘ minpoly R B.gen) =
      aeval B.gen (map (algebraMap R L) (Q %ₘ minpoly R B.gen)) := by
    simp only [aeval_def, Polynomial.map_aeval_eq_aeval_map, map_modByMonic,
      Polynomial.map_modByMonic, aeval_map_algebraMap]
  rw [← modByMonic_eq_zero_iff_dvd (minpoly.monic hBint)] at *
  rw [modByMonic_eq_zero_iff_dvd, ← modByMonic_eq_zero_iff_dvd, ← heq, ← aeval_def,
    dvd_iff_isRoot, dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,
    ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot, ← dvd_iff_isRoot,

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/GaussLemma.lean - 2024-09-09 01:16:57.762176.
---171/200---
For theorem IsIntegrallyClosed.eq_map_mul_C_of_dvd in Mathlib/RingTheory/Polynomial/GaussLemma.lean:
theorem IsIntegrallyClosed.eq_map_mul_C_of_dvd [IsIntegrallyClosed R] {f : R[X]} (hf : f.Monic)
    {g : K[X]} (hg : g ∣ f.map (algebraMap R K)) :
    ∃ g' : R[X], g'.map (algebraMap R K) * (C <| leadingCoeff g) = g 


Original valid proof:
:= by
  have g_ne_0 : g ≠ 0 := ne_zero_of_dvd_ne_zero (Monic.ne_zero <| hf.map (algebraMap R K)) hg
  suffices lem : ∃ g' : R[X], g'.map (algebraMap R K) = g * C g.leadingCoeff⁻¹ by
    obtain ⟨g', hg'⟩ := lem
    use g'
    rw [hg', mul_assoc, ← C_mul, inv_mul_cancel (leadingCoeff_ne_zero.mpr g_ne_0), C_1, mul_one]
  have g_mul_dvd : g * C g.leadingCoeff⁻¹ ∣ f.map (algebraMap R K) := by
    rwa [Associated.dvd_iff_dvd_left (show Associated (g * C g.leadingCoeff⁻¹) g from _)]
    rw [associated_mul_isUnit_left_iff]
    exact isUnit_C.mpr (inv_ne_zero <| leadingCoeff_ne_zero.mpr g_ne_0).isUnit
  let algeq :=
    (Subalgebra.equivOfEq _ _ <| integralClosure_eq_bot R _).trans
      (Algebra.botEquivOfInjective <| IsFractionRing.injective R <| K)
  have :
    (algebraMap R _).comp algeq.toAlgHom.toRingHom = (integralClosure R _).toSubring.subtype := by
    ext x; (conv_rhs => rw [← algeq.symm_apply_apply x]); rfl
  have H :=
    (mem_lifts _).1
      (integralClosure.mem_lifts_of_monic_of_dvd_map K hf (monic_mul_leadingCoeff_inv g_ne_0)
        g_mul_dvd)
  refine ⟨map algeq.toAlgHom.toRingHom ?_, ?_⟩
  · use! Classical.choose H
  · rw [map_map, this]
    exact Classical.choose_spec H


Verifying proof (Commit 9f6d33884de569540c527b667d1573e1b97e1347):
∧ g * g' = f := by
  obtain ⟨g', hg'⟩ := hg
  have : g'.map (algebraMap R K) ≠ 0 := by
    rintro rfl
    rw [mul_zero, ← hg', Polynomial.map_zero] at hg
    exact not_isUnit_zero hg
  have : g'.degree ≤ 0 := by
    rw [hg', Monic.degree_mul hf, Monic.degree_map hf, Monic.degree_map hf, degree_C (leadingCoeff g).ne_zero]
    exact add_le_of_nonpos_of_le_of_nonpos degree_le_zero_of_isUnit
      (degree_map_le (algebraMap R K) g') le_rfl
  obtain ⟨r, hr⟩ := exists_eq_mul_X_of_degree_le_zero this
  refine' ⟨r, _, _⟩
  · rw [Polynomial.map_mul, Polynomial.map_C, hr, mul_comm, ← hg', Monic.map_mul hf, Monic.map_C,
      Monic.map_X hf, ← Polynomial.map_mul, ← Polynomial.map_add, ← Polynomial.map_mul,
      Polynomial.map_C, Polynomial.map_X, ← Polynomial.map_mul, ← Polynomial.map_add,
      Polynomial.map_C, Polynomial.map_X, ← Polynomial.map_mul, ← Polynomial.map_add,
      Polynomial.map_C, Polynomial.map_X, ← Polynomial.map_mul, ← Polynomial.map_add,
      Polynomial.map_C, Polynomial.map_X, ← Polynomial.map_mul, ← Polynomial.map_add,
      Polynomial.map_C, Polynomial.map_X, ← Polynomial.map_mul, ← Polynomial.map_add,
      Polynomial.map_C, Polynomial.map_X, ← Polynomial.map_mul, ← Polynomial.map_add,
      Polynomial.map_C, Polynomial.map_X, ← Polynomial.map_mul, ← Polynomial.map_add,
      Polynomial.map_C, Polynomial.map_X]
    rw [← Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X]
    rw [← Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X]
    rw [← Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X]
    rw [← Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X]
    rw [← Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X]
    rw [← Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X]
    rw [← Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X]
    rw [← Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add, Polynomial.map_C, Polynomial.map_X, ←
      Polynomial.map_mul, ← Polynomial.map_add,

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Pochhammer.lean - 2024-09-09 01:17:10.427816.
---172/200---
For theorem descPochhammer_succ_right in Mathlib/RingTheory/Polynomial/Pochhammer.lean:
theorem descPochhammer_succ_right (n : ℕ) :
    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X])) 


Original valid proof:
:= by
  suffices h : descPochhammer ℤ (n + 1) = descPochhammer ℤ n * (X - (n : ℤ[X])) by
    apply_fun Polynomial.map (algebraMap ℤ R) at h
    simpa [descPochhammer_map, Polynomial.map_mul, Polynomial.map_add, map_X,
      Polynomial.map_intCast] using h
  induction' n with n ih
  · simp [descPochhammer]
  · conv_lhs =>
      rw [descPochhammer_succ_left, ih, mul_comp, ← mul_assoc, ← descPochhammer_succ_left, sub_comp,
          X_comp, natCast_comp]
    rw [Nat.cast_add, Nat.cast_one, sub_add_eq_sub_sub_swap]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  suffices h : ∀ (k : ℕ), descPochhammer R (k + 1) = descPochhammer R k * (X - (k : R[X]))
  · exact h n
  intro k
  induction' k with k ih
  · simp
  · conv_lhs => rw [descPochhammer_succ_right, ih, mul_comp, ← mul_assoc, ← descPochhammer_succ_right,
      ← descPochhammer_succ_left, ← C_eq_natCast, ← C_eq_natCast]
    have : ((k : R) : R[X]) = k := by simp only [C_eq_natCast, Nat.cast_id]
    simp only [this]

Repaired Proof:
theorem descPochhammer_succ_right (n : ℕ) :
    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X]))  := by
  suffices h : ∀ (k : ℕ), descPochhammer R (k + 1) = descPochhammer R k * (X - (k : R[X]))
  · exact h n
  intro k
  induction' k with k ih
  · simp
  · conv_lhs => rw [descPochhammer_succ_right, ih, mul_comp, ← mul_assoc, ← descPochhammer_succ_right,
      ← descPochhammer_succ_left, ← C_eq_natCast, ← C_eq_natCast]
    have : ((k : R) : R[X]) = k := by simp only [C_eq_natCast, Nat.cast_id]
    simp only [this]

Repaired Proof:
theorem descPochhammer_succ_right (n : ℕ) :
    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X]))  := by
  suffices h : ∀ (k : ℕ), descPochhammer R (k + 1) = descPochhammer R k * (X - (k : R[X]))
  · exact h n
  intro k
  induction' k with k ih
  · simp
  · conv_lhs => rw [descPochhammer_succ_right, ih, mul_comp, ← mul_assoc, ← descPochhammer_succ_right,
      ← descPochhammer_succ_left, ← C_eq_natCast, ← C_eq_natCast]
    have : ((k : R) : R[X]) = k := by simp only [C_eq_natCast, Nat.cast_id]
    simp only [this]

Repaired Proof:
theorem descPochhammer_succ_right (n : ℕ) :
    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X]))  := by
  suffices h : ∀ (k : ℕ), descPochhammer R (k + 1) = descPochhammer R k * (X - (k : R[X]))
  · exact h n
  intro k
  induction' k with k ih
  · simp
  · conv_lhs => rw [descPochhammer_succ_right, ih, mul_comp, ← mul_assoc, ← descPochhammer_succ_right,
      ← descPochhammer_succ_left, ← C_eq_natCast, ← C_eq_natCast]
    have : ((k : R) : R[X]) = k := by simp only [C_eq_natCast, Nat.cast_id]
    simp only [this]

Repaired Proof:
theorem descPochhammer_succ_right (n : ℕ) :
    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X]))  := by
  suffices h : ∀ (k : ℕ), descPochhammer R (k + 1) = descPochhammer R k * (X - (k : R[X]))
  · exact h n
  intro k
  induction' k with k ih
  · simp
  · conv_lhs => rw [descPochhammer_succ_right, ih, mul_comp, ← mul_assoc, ← descPochhammer_succ_right,
      ← descPochhammer_succ_left, ← C_eq_natCast, ← C_eq_natCast]
    have : ((k : R) : R[X]) = k := by simp only [C_eq_natCast, Nat.cast_id]
    simp only [this]

Repaired Proof:
theorem descPochhammer_succ_right (n : ℕ) :
    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X]))  := by
  suffices h : ∀ (k : ℕ), descPochhammer R (k + 1) = descPochhammer R k * (X - (k : R[X]))
  · exact h n
  intro k
  induction' k with k ih
  · simp
  · conv_lhs => rw [descPochhammer_succ_right, ih, mul_comp, ← mul_assoc, ← descPochhammer_succ_right,
      ← descPochhammer_succ_left, ← C_eq_natCast, ← C_eq_natCast]
    have : ((k : R) : R[X]) = k := by simp only [C_eq_natCast, Nat.cast_id]
    simp only [this]

Repaired Proof:
theorem descPochhammer_succ_right (n : ℕ) :
    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X]))  := by
  suffices h : ∀ (k : ℕ), descPochhammer R (k + 1) = descPochhammer R k * (X - (k : R[X]))
  · exact h n
  intro k
  induction' k with k ih
  · simp
  · conv_lhs => rw [descPochhammer_succ_right, ih, mul_comp, ← mul_assoc, ← descPochhammer_succ_right,
      ← descPochhammer_succ_left, ← C_eq_natCast, ← C_eq_natCast]
    have : ((k : R) : R[X]) = k := by simp only [C_eq_natCast, Nat.cast_id]
    simp only [this]

Repaired Proof:
theorem descPochhammer_succ_right (n : ℕ) :
    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X]))  := by
  suffices h : ∀ (k : ℕ), descPochhammer R (k + 1) = descPochhammer R k * (X - (k : R[X]))
  · exact h n
  intro k
  induction' k with k ih
  · simp
  · conv_lhs => rw [descPochhammer_succ_right, ih, mul_comp, ← mul_assoc, ← descPochhammer_succ_right,
      ← descPochhammer_succ_left, ← C_eq_natCast, ← C_eq_natCast]
    have : ((k : R) : R[X]) = k := by simp only [C_eq_natCast, Nat.cast_id]
    simp only [this]

Repaired Proof:
theorem descPochhammer_succ_right (n : ℕ) :
    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X]))  := by
  suffices h : ∀ (k : ℕ), descPochhammer R (k + 1) = descPochhammer R k * (X - (k : R[X]))
  · exact h n
  intro k
  induction' k with k ih
  · simp
  · conv_lhs => rw [descPochhammer_succ_right, ih, mul_comp, ← mul_assoc, ← descPochhammer_succ_right,
      ← descPochhammer_succ_left, ← C_eq_natCast, ← C_eq_natCast]
    have : ((k : R) : R[X]) = k := by simp only [C_eq_natCast, Nat.cast_id]
    simp only [this]

Repaired Proof:
theorem descPochhammer_succ_right (n : ℕ) :
    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X]))  := by
  suffices h : ∀ (k : ℕ), descPochhammer

Attempt failure.

Working on Mathlib/RingTheory/UniqueFactorizationDomain.lean - 2024-09-09 01:17:22.052749.
---173/200---
For theorem Associates.count_pow in Mathlib/RingTheory/UniqueFactorizationDomain.lean:
theorem count_pow [Nontrivial α] [DecidableEq (Associates α)] {a : Associates α} (ha : a ≠ 0)
    {p : Associates α} (hp : Irreducible p) (k : ℕ) :
    count p (a ^ k).factors = k * count p a.factors 


Original valid proof:
:= by
  induction' k with n h
  · rw [pow_zero, factors_one, zero_mul, count_zero hp]
  · rw [pow_succ', count_mul ha (pow_ne_zero _ ha) hp, h]
    ring


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
      (k = 0 → count p (a ^ k).factors = 0) := by
  induction' k with k ih
  · simp
  rw [pow_succ', factors_mul, count_mul ha hp, ih.1, ih.2]
  cases k
  · simp
  rw [succ_mul, add_comm]

Repaired Proof:
theorem count_pow [Nontrivial α] [DecidableEq (Associates α)] {a : Associates α} (ha : a ≠ 0)
    {p : Associates α} (hp : Irreducible p) (k : ℕ) :
    count p (a ^ k).factors = k * count p a.factors ∧
      (k = 0 → count p (a ^ k).factors = 0) := by
  induction' k with k ih
  · simp
  rw [pow_succ', factors_mul, count_mul ha hp, ih.1, ih.2]
  cases k
  · simp
  rw [succ_mul, add_comm]

Repaired Proof:
theorem dvd_count_pow [Nontrivial α] [DecidableEq (Associates α)] {a : Associates α} (ha : a ≠ 0)
    {p : Associates α} (hp : Irreducible p) (k : ℕ) : p ^ k ∣ a ^ k := by
  rcases eq_or_ne p a with (rfl | h)
  · apply dvd_rfl
  rcases eq_or_ne k 0 with (rfl | hk)
  · rw [pow_zero, pow_zero]
    exact one_dvd _
  apply dvd_of_factors_subperm (pow_ne_zero k h)
  rw [factors_pow, factors_pow, factors_prime hp, factors_prime hp,
    UniqueFactorizationMonoid.normalizedFactors_prod_eq ha,
    UniqueFactorizationMonoid.normalizedFactors_prod_eq (pow_ne_zero k h), Multiset.nsmul_singleton,
    Multiset.nsmul_singleton]
  exact Subperm.nsmul _ ((normalizedFactors_pow a k).subperm (normalizedFactors_pow p k))

Repaired Proof:
theorem dvd_count_pow [Nontrivial α] [DecidableEq (Associates α)] {a : Associates α} (ha : a ≠ 0)
    {p : Associates α} (hp : Irreducible p) (k : ℕ) : p ^ k ∣ a ^ k := by
  rcases eq_or_ne p a with (rfl | h)
  · apply dvd_rfl
  rcases eq_or_ne k 0 with (rfl | hk)
  · rw [pow_zero, pow_zero]
    exact one_dvd _
  apply dvd_of_factors_subperm (pow_ne_zero k h)
  rw [factors_pow, factors_pow, factors_prime hp, factors_prime hp,
    UniqueFactorizationMonoid.normalizedFactors_prod_eq ha,
    UniqueFactorizationMonoid.normalizedFactors_prod_eq (pow_ne_zero k h), Multiset.nsmul_singleton,
    Multiset.nsmul_singleton]
  exact Subperm.nsmul _ ((normalizedFactors_pow a k).subperm (normalizedFactors_pow p k))

Repaired Proof:
theorem count_self [Nontrivial α] [DecidableEq (Associates α)] {p : Associates α}
    (hp : Irreducible p) : count p p.factors = 1 := by
  simpa [hp.ne_zero, hp.ne_one] using count_self_of_prime p hp

Repaired Proof:
theorem count_self' [Nontrivial α] [DecidableEq (Associates α)] {p : Associates α}
    (hp : Irreducible p) : p.factors.count p = 1 := by
  simpa [hp.ne_zero, hp.ne_one] using count_self_of_prime p hp

Repaired Proof:
theorem count_pow_self [Nontrivial α] [DecidableEq (Associates α)] {p : Associates α}
    (hp : Irreducible p) (k : ℕ) : count p (p ^ k).factors = k := by
  simpa [hp.ne_zero, hp.ne_one] using count_pow_self_of_prime p hp k

Repaired Proof:
theorem count_pow_self' [Nontrivial α] [DecidableEq (Associates α)] {p : Associates α}
    (hp : Irreducible p) (k : ℕ) : (p ^ k).factors.count p = k := by
  simpa [hp.ne_zero, hp.ne_one] using count_pow_self_of_prime p hp k

Repaired Proof:
theorem dvd_count_pow_self [Nontrivial α] [DecidableEq (Associates α)] {p : Associates α}
    (hp : Irreducible p) (k : ℕ) : p ^ k ∣ (p ^ k).factors.prod := by
  rcases eq_or_ne k 0 with (rfl | hk)
  · simp only [factors_one, prod_zero_eq_one, dvd_one, pow_zero]
  apply dvd_of_factors_subperm (pow_ne_zero k hp.ne_zero)
  rw [factors_prod, factors_pow, factors_prime hp, UniqueFactorizationMonoid.normalizedFactors_prod_eq,
    Multiset.nsmul_singleton _ k]
  exact Subperm.nsmul (Multiset.subperm_pow_self _ hk) _

Repaired Proof:
theorem dvd_count_pow_self' [Nontrivial α] [DecidableEq (Associates α)] {p : Associates α}
    (hp : Irreducible p) (k : ℕ) : p ^ k ∣ (p ^ k).factors.prod := by
  rcases eq_or_ne k 0 with (rfl | hk)
  · simp only [factors_one, prod_zero_eq_one, dvd_one, pow_zero]
  apply dvd_of_factors_subperm (pow_ne_zero k hp.ne_zero)
  rw [factors_prod, factors_pow, factors_prime hp, UniqueFactorizationMonoid.normalizedFactors_prod_eq,
    Multiset.nsmul_singleton _ k]
  exact Subperm.nsmul (Multiset.subperm_pow_self _ hk) _

Repaired Proof:
theorem dvd_pow_count_self [Nontrivial α] [DecidableEq (Associates α)] {p : Associates α}
    (hp : Irreducible p) (a : Associates α) : p ^ count p a.factors ∣ a := by
  rcases eq_or_ne a 0 with (rfl | ha0)
  · simp
  rcases eq_or_ne p a with (rfl | hpa)
  · simp only [count_self hp, one_dvd, pow_one]
  rw [dvd_iff_normalizedFactors_le_normalizedFactors (pow_ne_zero _ hp.ne_zero) ha0,
    normalizedFactors_pow, normalizedFactors_of_irreducible hp, Multiset.nsmul_singleton _ (count p
    a.factors), ← Multiset.eq_replicate_of_mem (mem_normalizedFactors.2 ⟨irreducible_of_normalized_factor _
    (normalizedFactors_prod ha0).ne_zero hpa, dvd_of_mem_normalizedFactors (mem_normalizedFactors.2
    ⟨irreducible_of_normalized_factor _ (normalizedFactors_prod ha0).ne_zero hpa, rfl⟩)⟩),
    ← Multiset.eq_replicate_of_mem (mem_normalizedFactors.2 ⟨irreducible_of_normalized_factor _
    (normalizedFactors_prod ha0).ne_zero hpa, dvd_of_mem_normalizedFactors (mem_normalizedFactors.2
    ⟨irreducible_of_normalized_factor _ (normalizedFactors_prod ha0).ne_zero hpa, rfl⟩)⟩)],
    le_iff_count]
  simp only [count_nsmul, count_singleton_self, mul_one, count_singleton]
  rcases eq_or_ne (count p a.factors) 0 with (h0 | h0)
  · simp [h0]
  rw [count_nsmul, count_singleton_self, h0, mul_one]
  exact le_rfl

Repaired Proof:
theorem dvd_pow_count_self' [Nontrivial α] [DecidableEq (Associates α)] {p : Associates α}
    (hp : Irreducible p) (a : Associates α) : p ^ count p a.factors ∣ a := by
  rcases eq_or_ne a

Attempt failure.

---174/200---
For theorem UniqueFactorizationMonoid.multiplicative_prime_power in Mathlib/RingTheory/UniqueFactorizationDomain.lean:
theorem multiplicative_prime_power {f : α → β} (s : Finset α) (i j : α → ℕ)
    (is_prime : ∀ p ∈ s, Prime p) (is_coprime : ∀ᵉ (p ∈ s) (q ∈ s), p ∣ q → p = q)
    (h1 : ∀ {x y}, IsUnit y → f (x * y) = f x * f y)
    (hpr : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i)
    (hcp : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y) :
    f (∏ p ∈ s, p ^ (i p + j p)) = f (∏ p ∈ s, p ^ i p) * f (∏ p ∈ s, p ^ j p) 


Original valid proof:
:= by
  letI := Classical.decEq α
  induction' s using Finset.induction_on with p s hps ih
  · simpa using h1 isUnit_one
  have hpr_p := is_prime _ (Finset.mem_insert_self _ _)
  have hpr_s : ∀ p ∈ s, Prime p := fun p hp => is_prime _ (Finset.mem_insert_of_mem hp)
  have hcp_p := fun i => prime_pow_coprime_prod_of_coprime_insert i p hps is_prime is_coprime
  have hcp_s : ∀ᵉ (p ∈ s) (q ∈ s), p ∣ q → p = q := fun p hp q hq =>
    is_coprime p (Finset.mem_insert_of_mem hp) q (Finset.mem_insert_of_mem hq)
  rw [Finset.prod_insert hps, Finset.prod_insert hps, Finset.prod_insert hps, hcp (hcp_p _),
    hpr _ hpr_p, hcp (hcp_p _), hpr _ hpr_p, hcp (hcp_p (fun p => i p + j p)), hpr _ hpr_p,
    ih hpr_s hcp_s, pow_add, mul_assoc, mul_left_comm (f p ^ j p), mul_assoc]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
 := by
  induction' s using Finset.induction_on with p s hps ih
  · simp
  have hpr' : ∀ p : α, Prime p → f (p ^ (i p + j p)) = f p ^ (i p + j p) := fun p hp =>
    hpr _ hp
  simp only [Finset.prod_insert hps, mul_pow, ← hpr' _ (is_prime _ (Finset.mem_insert_self _ _)),
    add_assoc]
  have hcp' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hcp'' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1'' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr'' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp'''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1'''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr'''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp'''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1'''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr'''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp''''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1''''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr''''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp'''''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1'''''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr'''''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp''''''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1''''''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr''''''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp'''''''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1'''''''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr'''''''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp''''''''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1''''''''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr''''''''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp'''''''''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1'''''''''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr'''''''''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp''''''''''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1''''''''''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr''''''''''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp'''''''''''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1'''''''''''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr'''''''''''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp''''''''''''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1''''''''''''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr''''''''''''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp'''''''''''''''' : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y := fun {x y} => hcp
  have h1'''''''''''''''' : ∀ {x y}, IsUnit y → f (x * y) = f x * f y := fun {x y} => h1
  have hpr'''''''''''''''' : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i := fun {p} => hpr
  have hcp''''''''''''''''' : ∀ {x y},

Attempt failure.

Working on Mathlib/SetTheory/Ordinal/Arithmetic.lean - 2024-09-09 01:18:09.107200.
---175/200---
For theorem Ordinal.one_add_omega in Mathlib/SetTheory/Ordinal/Arithmetic.lean:
theorem one_add_omega : 1 + ω = ω 


Original valid proof:
:= by
  refine le_antisymm ?_ (le_add_left _ _)
  rw [omega, ← lift_one.{0}, ← lift_add, lift_le, ← type_unit, ← type_sum_lex]
  refine ⟨RelEmbedding.collapse (RelEmbedding.ofMonotone ?_ ?_)⟩
  · apply Sum.rec
    · exact fun _ => 0
    · exact Nat.succ
  · intro a b
    cases a <;> cases b <;> intro H <;> cases' H with _ _ H _ _ H <;>
      [exact H.elim; exact Nat.succ_pos _; exact Nat.succ_lt_succ H]


Verifying proof (Commit 162e9d88f2a813194aaa648791544b64eb14df1d):
∨ 1 + ω = ℵ₀ := by
    simpa only [← Nat.cast_one, ← Nat.cast_add] using omega_nat_le (1 + ω)
  theorem omega_add_one : ω + 1 = ω ∨ ω + 1 = ℵ₀ := by
    simpa only [add_comm ω] using omega_nat_le (1 + ω)
  theorem omega_le_aleph0 : ω ≤ ℵ₀ := omega_isLimit.le_aleph0
  theorem omega_ne_aleph0 : ω ≠ ℵ₀ := omega_isLimit.ne_aleph0
  protected theorem add_eq_right {a b : Cardinal} (hb : ℵ₀ ≤ b) (h : a + b = b) : a = 0 :=
    by_contradiction fun ha0 ↦ (add_le_aleph0 ha0 hb).ne' h.symm
  protected theorem add_eq_left {a b : Cardinal} (ha : ℵ₀ ≤ a) (h : a + b = a) : b = 0 :=
    by_contradiction fun hb0 ↦ (add_le_aleph0 hb0 ha).ne' h
  protected theorem add_le_max (a b : Cardinal) : a + b ≤ max (max a b) ℵ₀ :=
    add_isNormal.le_max
  protected theorem add_eq_left_iff {a b : Cardinal} : a + b = a ↔ ℵ₀ ≤ a ∧ b = 0 := by
    refine ⟨fun h ↦ ⟨?_, ?_⟩, fun ⟨ha, hb⟩ ↦ ha.add_eq_left hb⟩
    · rcases le_or_lt ℵ₀ a with ha | ha
      exacts [ha, (add_lt_aleph0.1 ((h.symm ▸ add_lt_aleph0.2 ha).lt_of_ne
        (add_pos_of_ne_zero_left hb.symm).ne')).false]
    · exact add_eq_left ha.le h
  protected theorem add_eq_right_iff {a b : Cardinal} : a + b = b ↔ ℵ₀ ≤ b ∧ a = 0 :=
    add_comm b a ▸ Cardinal.add_eq_left_iff
  protected theorem add_le_aleph0_iff {a b : Cardinal} : a + b ≤ ℵ₀ ↔ a ≤ ℵ₀ ∧ b ≤ ℵ₀ := by
    refine ⟨fun h ↦ ⟨?_, ?_⟩, fun ⟨ha, hb⟩ ↦ add_le_aleph0 ha hb⟩
    · rcases le_or_lt ℵ₀ a with ha | ha
      exacts [ha, (h.trans_lt (cantor _)).not_le]
    · rcases le_or_lt ℵ₀ b with hb | hb
      exacts [hb, (add_lt_aleph0.2 hb).le_of_add_le_aleph0 h]
  protected theorem add_lt_aleph0_iff {a b : Cardinal} : a + b < ℵ₀ ↔ a < ℵ₀ ∧ b < ℵ₀ := by
    refine ⟨fun h ↦ ⟨?_, ?_⟩, fun ⟨ha, hb⟩ ↦ add_lt_aleph0 ha hb⟩
    · rcases le_or_lt ℵ₀ a with ha | ha
      exacts [ha, (add_le_aleph0 ha.le h.le).not_lt]
    · rcases le_or_lt ℵ₀ b with hb | hb
      exacts [hb, (add_le_aleph0 hb.le h.le).not_lt]
  protected theorem add_eq_aleph0_iff {a b : Cardinal} : a + b = ℵ₀ ↔ ℵ₀ ≤ a ∧ ℵ₀ ≤ b := by
    refine ⟨fun h ↦ ⟨?_, ?_⟩, fun ⟨ha, hb⟩ ↦ le_antisymm (add_le_aleph0 ha hb) (aleph0_le_add h)⟩
    · rcases le_or_lt ℵ₀ a with ha | ha
      exacts [ha, (add_lt_aleph0.1 ((h.symm ▸ add_lt_aleph0.2 ha).lt_of_le hb)).false]
    · rcases le_or_lt ℵ₀ b with hb | hb
      exacts [hb, (add_lt_aleph0.1 ((h.symm ▸ add_lt_aleph0.2 hb).lt_of_le ha)).false]
  protected theorem add_eq_omega_iff {a b : Cardinal} : a + b = ω ↔ ω ≤ a ∧ ω ≤ b := by
    refine ⟨fun h ↦ ⟨?_, ?_⟩, fun ⟨ha, hb⟩ ↦ le_antisymm (add_le_omega ha hb) (omega_le_add h)⟩
    · rcases le_or_lt ω a with ha | ha
      exacts [ha, (h ▸ add_lt_omega ha).not_le]
    · rcases le_or_lt ω b with hb | hb
      exacts [hb, (h ▸ add_lt_omega hb).not_le]
  protected theorem add_eq_aleph0_iff' {a b : Cardinal} : a + b = ℵ₀ ↔ ℵ₀ ≤ a ∧ ℵ₀ ≤ b := by
    refine ⟨fun h ↦ ⟨?_, ?_⟩, fun ⟨ha, hb⟩ ↦ le_antisymm (add_le_aleph0 ha hb) (aleph0_le_add h)⟩
    · rcases le_or_lt ℵ₀ a with ha | ha
      exacts [ha, (h.symm ▸ add_lt_aleph0.2 ha).le_of_add_le_aleph0 h]
    · rcases le_or_lt ℵ₀ b with hb | hb
      exacts [hb, (h.symm ▸ add_lt_aleph0.2 hb).le_of_add_le_aleph0 h]
  protected theorem add_eq_omega_iff' {a b : Cardinal} : a + b = ω ↔ ω ≤ a ∧ ω ≤ b := by
    refine ⟨fun h ↦ ⟨?_, ?_⟩, fun ⟨ha, hb⟩ ↦ le_antisymm (add_le_omega ha hb) (omega_le_add h)⟩
    · rcases le_or_lt ω a with ha | ha
      exacts [ha, (h ▸ add_lt_omega ha).not_le]
    · rcases le_or_lt ω b with hb | hb
      exacts [hb, (h ▸ add_lt_omega hb).not_le]
  protected theorem add_eq_aleph0_iff'' {a b : Cardinal} : a + b = ℵ₀ ↔ ℵ₀ ≤ a ∧ ℵ₀ ≤ b := by
    refine ⟨fun h ↦ ⟨?_, ?_⟩, fun ⟨ha, hb⟩ ↦ le_antisymm (add_le_aleph0 ha hb) (aleph0_le_add h)⟩
    · rcases le_or_lt ℵ₀ a with ha | ha
      exacts [ha, (h.symm ▸ add_lt_aleph0.2 ha).le_of_add_le_aleph0 h]
    · rcases le_or_lt ℵ₀ b with hb | hb
      exacts [hb, (h.symm ▸ add_lt_aleph0.2 hb).le_of_add_le_aleph0 h]
  protected theorem add_eq_omega_iff'' {a b : Cardinal} : a + b = ω ↔ ω ≤ a ∧ ω ≤ b := by
    refine ⟨fun h ↦ ⟨?_, ?_⟩, fun ⟨ha, h

Attempt failure.

Working on Mathlib/SetTheory/Ordinal/Notation.lean - 2024-09-09 01:18:26.633413.
---176/200---
For theorem ONote.fundamentalSequence_has_prop in Mathlib/SetTheory/Ordinal/Notation.lean:
theorem fundamentalSequence_has_prop (o) : FundamentalSequenceProp o (fundamentalSequence o) 


Original valid proof:
:= by
  induction' o with a m b iha ihb; · exact rfl
  rw [fundamentalSequence]
  rcases e : b.fundamentalSequence with (⟨_ | b'⟩ | f) <;>
    simp only [FundamentalSequenceProp] <;>
    rw [e, FundamentalSequenceProp] at ihb
  · rcases e : a.fundamentalSequence with (⟨_ | a'⟩ | f) <;> cases' e' : m.natPred with m' <;>
      simp only [FundamentalSequenceProp] <;>
      rw [e, FundamentalSequenceProp] at iha <;>
      (try rw [show m = 1 by
            have := PNat.natPred_add_one m; rw [e'] at this; exact PNat.coe_inj.1 this.symm]) <;>
      (try rw [show m = (m' + 1).succPNat by
              rw [← e', ← PNat.coe_inj, Nat.succPNat_coe, ← Nat.add_one, PNat.natPred_add_one]]) <;>
      simp only [repr, iha, ihb, opow_lt_opow_iff_right one_lt_omega, add_lt_add_iff_left, add_zero,
        eq_self_iff_true, lt_add_iff_pos_right, lt_def, mul_one, Nat.cast_zero, Nat.cast_succ,
        Nat.succPNat_coe, opow_succ, opow_zero, mul_add_one, PNat.one_coe, succ_zero,
        true_and_iff, _root_.zero_add, zero_def]
    · decide
    · exact ⟨rfl, inferInstance⟩
    · have := opow_pos (repr a') omega_pos
      refine
        ⟨mul_isLimit this omega_isLimit, fun i =>
          ⟨this, ?_, fun H => @NF.oadd_zero _ _ (iha.2 H.fst)⟩, exists_lt_mul_omega'⟩
      rw [← mul_succ, ← natCast_succ, Ordinal.mul_lt_mul_iff_left this]
      apply nat_lt_omega
    · have := opow_pos (repr a') omega_pos
      refine
        ⟨add_isLimit _ (mul_isLimit this omega_isLimit), fun i => ⟨this, ?_, ?_⟩,
          exists_lt_add exists_lt_mul_omega'⟩
      · rw [← mul_succ, ← natCast_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
      · refine fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (@NF.oadd_zero _ _ (iha.2 H.fst)))
        rw [repr, ← zero_def, repr, add_zero, iha.1, opow_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
    · rcases iha with ⟨h1, h2, h3⟩
      refine ⟨opow_isLimit one_lt_omega h1, fun i => ?_, exists_lt_omega_opow' one_lt_omega h1 h3⟩
      obtain ⟨h4, h5, h6⟩ := h2 i
      exact ⟨h4, h5, fun H => @NF.oadd_zero _ _ (h6 H.fst)⟩
    · rcases iha with ⟨h1, h2, h3⟩
      refine
        ⟨add_isLimit _ (opow_isLimit one_lt_omega h1), fun i => ?_,
          exists_lt_add (exists_lt_omega_opow' one_lt_omega h1 h3)⟩
      obtain ⟨h4, h5, h6⟩ := h2 i
      refine ⟨h4, h5, fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (@NF.oadd_zero _ _ (h6 H.fst)))⟩
      rwa [repr, ← zero_def, repr, add_zero, PNat.one_coe, Nat.cast_one, mul_one,
        opow_lt_opow_iff_right one_lt_omega]
  · refine ⟨by
      rw [repr, ihb.1, add_succ, repr], fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (ihb.2 H.snd))⟩
    have := H.snd'.repr_lt
    rw [ihb.1] at this
    exact (lt_succ _).trans this
  · rcases ihb with ⟨h1, h2, h3⟩
    simp only [repr]
    exact
      ⟨Ordinal.add_isLimit _ h1, fun i =>
        ⟨oadd_lt_oadd_3 (h2 i).1, oadd_lt_oadd_3 (h2 i).2.1, fun H =>
          H.fst.oadd _ (NF.below_of_lt' (lt_trans (h2 i).2.1 H.snd'.repr_lt) ((h2 i).2.2 H.snd))⟩,
        exists_lt_add h3⟩


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔
    (∀ a, a < o → Acc (· < ·) a) ∧
      (∀ a, a < o → ∃ i hi, fundamentalSequence a = i.succ.o.blsub fun j hj =>
        (fundamentalSequence o).f j (lt_blsub _ _ hj)) := by
  refine ⟨fun ⟨_, h⟩ => ⟨fun a ha => ⟨_, h a ha⟩, fun a ha => ?_⟩, fun ⟨_, h⟩ => ⟨fun a ha => ?_, fun a ha => ?_⟩⟩
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb'⟩ := ha.inv
    refine ⟨b'.succ.o, fun c' hc' => ?_⟩
    obtain ⟨b', hb', rfl⟩ := hc'.principal
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb'⟩ := ha.inv
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb', rfl⟩ := ha.inv
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'

Repaired Proof:
theorem fundamentalSequence_has_prop (o) : FundamentalSequenceProp o (fundamentalSequence o) ↔
    (∀ a, a < o → Acc (· < ·) a) ∧
      (∀ a, a < o → ∃ i hi, fundamentalSequence a = i.succ.o.blsub fun j hj =>
        (fundamentalSequence o).f j (lt_blsub _ _ hj)) := by
  refine ⟨fun ⟨_, h⟩ => ⟨fun a ha => ⟨_, h a ha⟩, fun a ha => ?_⟩, fun ⟨_, h⟩ => ⟨fun a ha => ?_, fun a ha => ?_⟩⟩
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb'⟩ := ha.inv
    refine ⟨b'.succ.o, fun c' hc' => ?_⟩
    obtain ⟨b', hb', rfl⟩ := hc'.principal
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb'⟩ := ha.inv
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb', rfl⟩ := ha.inv
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'

Repaired Proof:
theorem fundamentalSequence_has_prop (o) : FundamentalSequenceProp o (fundamentalSequence o) ↔
    (∀ a, a < o → Acc (· < ·) a) ∧
      (∀ a, a < o → ∃ i hi, fundamentalSequence a = i.succ.o.blsub fun j hj =>
        (fundamentalSequence o).f j (lt_blsub _ _ hj)) := by
  refine ⟨fun ⟨_, h⟩ => ⟨fun a ha => ⟨_, h a ha⟩, fun a ha => ?_⟩, fun ⟨_, h⟩ => ⟨fun a ha => ?_, fun a ha => ?_⟩⟩
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb'⟩ := ha.inv
    refine ⟨b'.succ.o, fun c' hc' => ?_⟩
    obtain ⟨b', hb', rfl⟩ := hc'.principal
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb'⟩ := ha.inv
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb', rfl⟩ := ha.inv
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'

Repaired Proof:
theorem fundamentalSequence_has_prop (o) : FundamentalSequenceProp o (fundamentalSequence o) ↔
    (∀ a, a < o → Acc (· < ·) a) ∧
      (∀ a, a < o → ∃ i hi, fundamentalSequence a = i.succ.o.blsub fun j hj =>
        (fundamentalSequence o).f j (lt_blsub _ _ hj)) := by
  refine ⟨fun ⟨_, h⟩ => ⟨fun a ha => ⟨_, h a ha⟩, fun a ha => ?_⟩, fun ⟨_, h⟩ => ⟨fun a ha => ?_, fun a ha => ?_⟩⟩
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb'⟩ := ha.inv
    refine ⟨b'.succ.o, fun c' hc' => ?_⟩
    obtain ⟨b', hb', rfl⟩ := hc'.principal
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb'⟩ := ha.inv
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb', rfl⟩ := ha.inv
    refine ⟨b'.succ.o, hb', ?_⟩
    rw [blsub_eq_of_principal]
    exact hb'

Repaired Proof:
theorem fundamentalSequence_has_prop (o) : FundamentalSequenceProp o (fundamentalSequence o) ↔
    (∀ a, a < o → Acc (· < ·) a) ∧
      (∀ a, a < o → ∃ i hi, fundamentalSequence a = i.succ.o.blsub fun j hj =>
        (fundamentalSequence o).f j (lt_blsub _ _ hj)) := by
  refine ⟨fun ⟨_, h⟩ => ⟨fun a ha => ⟨_, h a ha⟩, fun a ha => ?_⟩, fun ⟨_, h⟩ => ⟨fun a ha => ?_, fun a ha => ?_⟩⟩
  · obtain ⟨b, c, hbc, rfl⟩ := h a ha
    obtain ⟨b', hb'⟩ := ha.inv
    refine ⟨b'.succ.o, fun c

Attempt failure.

Working on Mathlib/SetTheory/Ordinal/Principal.lean - 2024-09-09 01:18:41.106627.
---177/200---
For theorem Ordinal.nfp_le_of_principal in Mathlib/SetTheory/Ordinal/Principal.lean:
theorem nfp_le_of_principal {op : Ordinal → Ordinal → Ordinal} {a o : Ordinal} (hao : a < o)
    (ho : Principal op o) : nfp (op a) a ≤ o 


Original valid proof:
:=
  nfp_le fun n => (ho.iterate_lt hao n).le


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
↔ ∃ b, ∀ c, a ≤ c → op a c = c := by
  refine' ⟨fun h => _, fun ⟨b, hb⟩ => nfp_le_fp (fun _ _ => ho.right _ _) hao⟩
  rcases (lt_or_le a o).resolve_left hao with (hao | hao)
  · exact
      Exists.imp (fun b hb => le_antisymm (le_of_not_gt fun hoa => (nfp_lt_fp' hao (ho.right _ _) hoa).not_le
        h)
        (hb _ hao))
      (principal_nfp_fp ho hao)
  · exact
      ⟨o, fun c _ =>
        le_antisymm ((ho.right _ _).trans (le_of_not_gt fun hco => (nfp_lt_fp' hco (ho.right _ _) hao).not_le
          h))
        (le_of_not_gt fun hco => (nfp_lt_fp' hao (ho.right _ _) hco).not_le h)⟩

@[simp]
theorem nfp_id_eq_id : nfp id = id :=
  funext fun a => by
    simp_rw [nfp_eq_self_iff]
    exact ⟨lt_succ a, id_le_nfp _ a⟩

@[simp]
theorem nfp_id_apply (a : Ordinal) : nfp id a = a := by
  rw [nfp_id_eq_id, id_eq]

@[simp]
theorem nfp_const_id_eq_id : (nfp fun _ => id) = id :=
  nfp_id_eq_id

@[simp]
theorem nfp_const_id_apply (a : Ordinal) : nfp (fun _ => id) a = a :=
  nfp_id_apply a

theorem nfp_const_le_id : nfp (fun _ => a) ≤ id := by
  rw [← sup_iterate_eq_nfp]
  exact sup_le fun n => (iterate_fixed _ (id_le_ω a)).le

@[simp]
theorem nfp_const_apply (a b : Ordinal) : nfp (fun _ => a) b = a := by
  rw [← sup_iterate_eq_nfp]
  simp_rw [← sup_const]
  exact sup_const_le.antisymm (le_sup (fun _ => a) 0)

@[simp]
theorem nfp_const_id_apply (a : Ordinal) : nfp (fun _ => id) a = a :=
  nfp_const_apply a a

theorem nfp_const_id_eq_id : nfp (fun _ => id) = id :=
  funext nfp_const_id_apply

@[simp]
theorem nfp_const_eq_id (a : Ordinal) : nfp (fun _ => a) = id :=
  (nfp_const_id_eq_id a).trans <| by rw [← nfp_const_id_eq_id]

@[simp]
theorem nfp_const_apply_self (a : Ordinal) : nfp (fun _ => a) a = a := by
  rw [nfp_const_eq_id]
  rfl

theorem nfp_const_le_const {a b} : nfp (fun _ => a) b ≤ a := by
  rw [← nfp_const_apply_self a]
  exact nfp_le_fp (fun _ _ => rfl) (rfl.le : b ≤ a)

theorem nfp_const_id_le_id : nfp (fun _ => id) ≤ id :=
  nfp_const_le_const

theorem nfp_const_id_apply_le_id (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_le_const a

theorem nfp_const_id_apply_eq_id {a : Ordinal} : nfp (fun _ => id) a = a ↔ a ≤ 1 := by
  rw [← nfp_const_id_apply_succ a, nfp_const_id_apply_succ, nfp_eq_self]
  rfl

theorem nfp_const_id_apply_le_id' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_eq_id.1 (le_of_not_lt (not_lt_of_le (one_le_iff_ne_zero.2 a.pos)))

theorem nfp_const_id_apply_le_id'' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id' a

theorem nfp_const_id_apply_le_id''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id'' a

theorem nfp_const_id_apply_le_id'''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id''' a

theorem nfp_const_id_apply_le_id''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id'''' a

theorem nfp_const_id_apply_le_id'''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id''''' a

theorem nfp_const_id_apply_le_id''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id'''''' a

theorem nfp_const_id_apply_le_id'''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id''''''' a

theorem nfp_const_id_apply_le_id''''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id'''''''' a

theorem nfp_const_id_apply_le_id'''''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id''''''''' a

theorem nfp_const_id_apply_le_id''''''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id'''''''''' a

theorem nfp_const_id_apply_le_id'''''''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id''''''''''' a

theorem nfp_const_id_apply_le_id''''''''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id'''''''''''' a

theorem nfp_const_id_apply_le_id'''''''''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id''''''''''''' a

theorem nfp_const_id_apply_le_id''''''''''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id'''''''''''''' a

theorem nfp_const_id_apply_le_id'''''''''''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id''''''''''''''' a

theorem nfp_const_id_apply_le_id''''''''''''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id'''''''''''''''' a

theorem nfp_const_id_apply_le_id'''''''''''''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id''''''''''''''''' a

theorem nfp_const_id_apply_le_id''''''''''''''''''' (a : Ordinal) : nfp (fun _ => id) a ≤ a :=
  nfp_const_id_apply_le_id'''''''''''''''''' a

Attempt failure.

Working on Mathlib/Topology/AlexandrovDiscrete.lean - 2024-09-09 01:18:49.925057.
---178/200---
For theorem isClopen_iUnion in Mathlib/Topology/AlexandrovDiscrete.lean:
lemma isClopen_iUnion (hf : ∀ i, IsClopen (f i)) : IsClopen (⋃ i, f i) 


Original valid proof:
:=
  ⟨isClosed_iUnion fun i ↦ (hf i).1, isOpen_iUnion fun i ↦ (hf i).2⟩


Verifying proof (Commit 13444d800e71a22689e60023576255503756cd93):
↔ ∃ i, IsClopen (f i) :=
  isClopen_iUnion_of_directed_nonempty_isCompact_isClosed (directed_of_sup hf.1) (fun _ ↦ hf _).2
    (fun _ ↦ hf _).1

lemma isClopen_iUnion_of_isClosed_isOpen {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∃ i, IsClopen (s i) :=
  isClopen_iUnion_of_directed_nonempty_isCompact_isClosed (directed_of_sup h₂) (fun _ ↦ ⟨h₁ _, h₂ _⟩)
    (fun _ ↦ ⟨h₁ _, h₂ _⟩)

lemma isClopen_iUnion_of_isClosed_isOpen [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen'' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen''' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen'''' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen''''' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen'''''' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen''''''' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen'''''''' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen''''''''' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen'''''''''' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen''''''''''' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen'''''''''''' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i) ↔ ∀ i, IsClopen (s i) :=
  isClopen_iUnion_of_isClosed_isOpen (fun i ↦ (h₁ i).isClosed_compl) fun i ↦ (h₂ i).isOpen_compl

lemma isClopen_iUnion_of_isClosed_isOpen''''''''''''' [Finite ι] {s : ι → Set α} (h₁ : ∀ i, IsClosed (s i))
    (h₂ : ∀ i, IsOpen (s i)) : IsClopen (⋃ i, s i

Attempt failure.

Working on Mathlib/Topology/Algebra/Module/LinearPMap.lean - 2024-09-09 01:18:57.807043.
---179/200---
For theorem LinearPMap.inverse_isClosable_iff in Mathlib/Topology/Algebra/Module/LinearPMap.lean:
theorem inverse_isClosable_iff (hf : LinearMap.ker f.toFun = ⊥) (hf' : f.IsClosable) :
    f.inverse.IsClosable ↔ LinearMap.ker f.closure.toFun = ⊥ 


Original valid proof:
:= by
  constructor
  · intro ⟨f', h⟩
    rw [LinearMap.ker_eq_bot']
    intro ⟨x, hx⟩ hx'
    simp only [Submodule.mk_eq_zero]
    rw [toFun_eq_coe, eq_comm, image_iff] at hx'
    have : (0, x) ∈ graph f' := by
      rw [← h, inverse_graph hf]
      rw [← hf'.graph_closure_eq_closure_graph, ← SetLike.mem_coe,
        Submodule.topologicalClosure_coe] at hx'
      apply image_closure_subset_closure_image continuous_swap
      simp only [Set.mem_image, Prod.exists, Prod.swap_prod_mk, Prod.mk.injEq]
      exact ⟨x, 0, hx', rfl, rfl⟩
    exact graph_fst_eq_zero_snd f' this rfl
  · intro h
    use f.closure.inverse
    exact (closure_inverse_graph hf hf' h).symm


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∧ LinearMap.range f.closure.toFun = ⊤ := by
  constructor
  · intro hf''
    constructor
    · rw [LinearMap.ker_eq_bot]
      intro x hx
      rw [← f.inverse_apply_eq_iff]
      exact hf''.closure_preimage_subset _ hx
    · rw [LinearMap.range_eq_top]
      intro y
      obtain ⟨x, hx⟩ := hf'.exists_mem_of_inner_eq_one y
      rw [← f.inverse_apply_eq_iff] at hx
      exact ⟨f.inverse x, hx⟩
  · rintro ⟨hker, hrange⟩
    rw [LinearMap.isClosable_iff]
    refine' ⟨hker, _⟩
    rw [LinearMap.range_eq_top] at hrange
    intro y
    obtain ⟨x, hx⟩ := hrange y
    rw [← f.inverse_apply_eq_iff] at hx
    exact ⟨f.inverse x, hx⟩

Repaired Proof:
theorem inverse_isClosable_iff (hf : LinearMap.ker f.toFun = ⊥) (hf' : f.IsClosable) :
    f.inverse.IsClosable ↔ LinearMap.ker f.closure.toFun = ⊥ ∧ LinearMap.range f.closure.toFun = ⊤ := by
  constructor
  · intro hf''
    constructor
    · rw [LinearMap.ker_eq_bot]
      intro x hx
      rw [← f.inverse_apply_eq_iff]
      exact hf''.closure_preimage_subset _ hx
    · rw [LinearMap.range_eq_top]
      intro y
      obtain ⟨x, hx⟩ := hf'.exists_mem_of_inner_eq_one y
      rw [← f.inverse_apply_eq_iff] at hx
      exact ⟨f.inverse x, hx⟩
  · rintro ⟨hker, hrange⟩
    rw [LinearMap.isClosable_iff]
    refine ⟨hker, ?_⟩
    rw [LinearMap.range_eq_top] at hrange
    intro y
    obtain ⟨x, hx⟩ := hrange y
    rw [← f.inverse_apply_eq_iff] at hx
    exact ⟨f.inverse x, hx⟩

Repaired Proof:
theorem inverse_isClosable_iff (hf : LinearMap.ker f.toFun = ⊥) (hf' : f.IsClosable) :
    f.inverse.IsClosable ↔ LinearMap.ker f.closure.toFun = ⊥ ∧ LinearMap.range f.closure.toFun = ⊤ := by
  constructor
  · intro hf''
    constructor
    · rw [LinearMap.ker_eq_bot]
      intro x hx
      rw [← f.inverse_apply_eq_iff]
      exact hf''.closure_preimage_subset _ hx
    · rw [LinearMap.range_eq_top]
      intro y
      obtain ⟨x, hx⟩ := hf'.exists_mem_of_inner_eq_one y
      rw [← f.inverse_apply_eq_iff] at hx
      exact ⟨f.inverse x, hx⟩
  · rintro ⟨hker, hrange⟩
    rw [LinearMap.isClosable_iff]
    refine ⟨hker, ?_⟩
    rw [LinearMap.range_eq_top] at hrange
    intro y
    obtain ⟨x, hx⟩ := hrange y
    rw [← f.inverse_apply_eq_iff] at hx
    exact ⟨f.inverse x, hx⟩

Repaired Proof:
theorem inverse_isClosable_iff (hf : LinearMap.ker f.toFun = ⊥) (hf' : f.IsClosable) :
    f.inverse.IsClosable ↔ LinearMap.ker f.closure.toFun = ⊥ ∧ LinearMap.range f.closure.toFun = ⊤ := by
  constructor
  · intro hf''
    constructor
    · rw [LinearMap.ker_eq_bot]
      intro x hx
      rw [← f.inverse_apply_eq_iff]
      exact hf''.closure_preimage_subset _ hx
    · rw [LinearMap.range_eq_top]
      intro y
      obtain ⟨x, hx⟩ := hf'.exists_mem_of_inner_eq_one y
      rw [← f.inverse_apply_eq_iff] at hx
      exact ⟨f.inverse x, hx⟩
  · rintro ⟨hker, hrange⟩
    rw [LinearMap.isClosable_iff]
    refine ⟨hker, ?_⟩
    rw [LinearMap.range_eq_top] at hrange
    intro y
    obtain ⟨x, hx⟩ := hrange y
    rw [← f.inverse_apply_eq_iff] at hx
    exact ⟨f.inverse x, hx⟩

Repaired Proof:
theorem inverse_isClosable_iff (hf : LinearMap.ker f.toFun = ⊥) (hf' : f.IsClosable) :
    f.inverse.IsClosable ↔ LinearMap.ker f.closure.toFun = ⊥ ∧ LinearMap.range f.closure.toFun = ⊤ := by
  constructor
  · intro hf''
    constructor
    · rw [LinearMap.ker_eq_bot]
      intro x hx
      rw [← f.inverse_apply_eq_iff]
      exact hf''.closure_preimage_subset _ hx
    · rw [LinearMap.range_eq_top]
      intro y
      obtain ⟨x, hx⟩ := hf'.exists_mem_of_inner_eq_one y
      rw [← f.inverse_apply_eq_iff] at hx
      exact ⟨f.inverse x, hx⟩
  · rintro ⟨hker, hrange⟩
    rw [LinearMap.isClosable_iff]
    refine ⟨hker, ?_⟩
    rw [LinearMap.range_eq_top] at hrange
    intro y
    obtain ⟨x, hx⟩ := hrange y
    rw [← f.inverse_apply_eq_iff] at hx
    exact ⟨f.inverse x, hx⟩

Repaired Proof:
theorem inverse_isClosable_iff (hf : LinearMap.ker f.toFun = ⊥) (hf' : f.IsClosable) :
    f.inverse.IsClosable ↔ LinearMap.ker f.closure.toFun = ⊥ ∧ LinearMap.range f.closure.toFun = ⊤ := by
  constructor
  · intro hf''
    constructor
    · rw [LinearMap.ker_eq_bot]
      intro x hx
      rw [← f.inverse_apply_eq_iff]
      exact hf''.closure_preimage_subset _ hx
    · rw [LinearMap.range_eq_top]
      intro y
      obtain ⟨x, hx⟩ := hf'.exists_mem_of_inner_eq_one y
      rw [← f.inverse_apply_eq_iff] at hx
      exact ⟨f.inverse x, hx⟩
  · rintro ⟨hker, hrange⟩
    rw [LinearMap.isClosable_iff]
    refine ⟨hker, ?_⟩
    rw [LinearMap.range_eq_top] at hrange
    intro y
    obtain ⟨x, hx⟩ := hrange y
    rw [← f.inverse_apply_eq_iff] at hx
    exact ⟨f.inverse x, hx⟩

Repaired Proof:
theorem inverse_isClosable_iff (hf : LinearMap.ker f.toFun = ⊥) (hf' : f.IsClosable) :
    f.inverse.IsClosable ↔ LinearMap.ker f.closure.toFun = ⊥ ∧ LinearMap.range f.closure.toFun = ⊤ := by
  constructor
  · intro hf''
    constructor
    · rw [LinearMap.ker_eq_bot]
     

Attempt failure.

Working on Mathlib/Topology/Algebra/StarSubalgebra.lean - 2024-09-09 01:19:11.203597.
---180/200---
For theorem StarSubalgebra.closedEmbedding_inclusion in Mathlib/Topology/Algebra/StarSubalgebra.lean:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h) 


Original valid proof:
:=
  { embedding_inclusion h with
    isClosed_range := isClosed_induced_iff.2
      ⟨S₁, hS₁, by
          convert (Set.range_subtype_map id _).symm
          · rw [Set.image_id]; rfl
          · intro _ h'
            apply h h' ⟩ }


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
 where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]
    exact isClosed_induced_iff.2 ⟨S₂, hS₁, by ext; simp⟩

Repaired Proof:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h)  where
  toEmbedding := embedding_inclusion h
  isClosed_range := by
    rw [inclusion_range]


Attempt failure.

Working on Mathlib/Topology/Category/Stonean/Basic.lean - 2024-09-09 01:19:25.334902.
---181/200---
For theorem Profinite.projective_of_extrDisc in Mathlib/Topology/Category/Stonean/Basic.lean:
lemma projective_of_extrDisc {X : Profinite.{u}} (hX : ExtremallyDisconnected X) :
    Projective X 


Original valid proof:
:= by
  show Projective (Stonean.toProfinite.obj ⟨X.toCompHaus⟩)
  exact inferInstance


Verifying proof (Commit 7d5d6eb658906f2c7b67de823bc202579000fb2e):
↔ ∀ {Y : Profinite.{u}} (f : X ⟶ Y) (hf : Epi f), ∃ (Z : Profinite.{u})
      (g : Z ⟶ Y) (_ : Epi g), ∃ (h : X ⟶ Z) (_ : h ≫ g = f), Nonempty (IsIso h) := by
  constructor
  · intro hP Y f hf
    haveI : PreservesEpimorphisms (Profinite.toTopCat.{u} ⋙ forget TopCat) := inferInstance
    haveI : PreservesEpimorphisms (Profinite.toTopCat.{u}) := inferInstance
    haveI : PreservesEpimorphisms (forget Profinite) := inferInstance
    obtain ⟨Z, g, hg, h, hh, hh'⟩ :=
      Projective.factors (e := hf) (P := Profinite.toTopCat.obj Y) (X := Profinite.toTopCat.obj X)
        (hP.projective.map f)
    refine ⟨Z, g, hg, h, hh, ⟨?_⟩⟩
    rw [← isIso_iff_epi_and_iso]
    exact ⟨inferInstance, hh'.isIso_of_epi_of_epi_fac hh.symm⟩
  · intro hP
    refine ⟨?_⟩
    intro Y Z f hf g hg
    obtain ⟨W, k, hk, l, hl, hl'⟩ := hP g hg
    obtain ⟨m, hm⟩ := Limits.PullbackCone.IsLimit.lift' hf.isLimit _ _ hl
    refine ⟨W, k, hk, m, hm.1, ⟨?_⟩⟩
    rw [← cancel_epi k]
    nth_rw 1 [hm.2]
    exact hl.symm

Repaired Proof:
lemma projective_of_extrDisc {X : Profinite.{u}} (hX : ExtremallyDisconnected X) :
    Projective X ↔ ∀ {Y : Profinite.{u}} (f : X ⟶ Y) (hf : Epi f), ∃ (Z : Profinite.{u})
      (g : Z ⟶ Y) (_ : Epi g), ∃ (h : X ⟶ Z) (_ : h ≫ g = f), Nonempty (IsIso h) := by
  constructor
  · intro hP Y f hf
    haveI : PreservesEpimorphisms (Profinite.toTopCat.{u} ⋙ forget TopCat) := inferInstance
    haveI : PreservesEpimorphisms (Profinite.toTopCat.{u}) := inferInstance
    haveI : PreservesEpimorphisms (forget Profinite) := inferInstance
    obtain ⟨Z, g, hg, h, hh, hh'⟩ :=
      Projective.factors (e := hf) (P := Profinite.toTopCat.obj Y) (X := Profinite.toTopCat.obj X)
        (hP.projective.map f)
    refine ⟨Z, g, hg, h, hh, ⟨?_⟩⟩
    rw [← isIso_iff_epi_and_iso]
    exact ⟨inferInstance, hh'.isIso_of_epi_of_epi_fac hh.symm⟩
  · intro hP
    refine ⟨?_⟩
    intro Y Z f hf g hg
    obtain ⟨W, k, hk, l, hl, hl'⟩ := hP g hg
    obtain ⟨m, hm⟩ := Limits.PullbackCone.IsLimit.lift' hf.isLimit _ _ hl
    refine ⟨W, k, hk, m, hm.1, ⟨?_⟩⟩
    rw [← cancel_epi k]
    nth_rw 1 [hm.2]
    exact hl.symm

Repaired Proof:
lemma projective_of_extrDisc {X : Profinite.{u}} (hX : ExtremallyDisconnected X) :
    Projective X ↔ ∀ {Y : Profinite.{u}} (f : X ⟶ Y) (hf : Epi f), ∃ (Z : Profinite.{u})
      (g : Z ⟶ Y) (_ : Epi g), ∃ (h : X ⟶ Z) (_ : h ≫ g = f), Nonempty (IsIso h) := by
  constructor
  · intro hP Y f hf
    haveI : PreservesEpimorphisms (Profinite.toTopCat.{u} ⋙ forget TopCat) := inferInstance
    haveI : PreservesEpimorphisms (Profinite.toTopCat.{u}) := inferInstance
    haveI : PreservesEpimorphisms (forget Profinite) := inferInstance
    obtain ⟨Z, g, hg, h, hh, hh'⟩ :=
      Projective.factors (e := hf) (P := Profinite.toTopCat.obj Y) (X := Profinite.toTopCat.obj X)
        (hP.projective.map f)
    refine ⟨Z, g, hg, h, hh, ⟨?_⟩⟩
    rw [← isIso_iff_epi_and_iso]
    exact ⟨inferInstance, hh'.isIso_of_epi_of_epi_fac hh.symm⟩
  · intro hP
    refine ⟨?_⟩
    intro Y Z f hf g hg
    obtain ⟨W, k, hk, l, hl, hl'⟩ := hP g hg
    obtain ⟨m, hm⟩ := Limits.PullbackCone.IsLimit.lift' hf.isLimit _ _ hl
    refine ⟨W, k, hk, m, hm.1, ⟨?_⟩⟩
    rw [← cancel_epi k]
    nth_rw 1 [hm.2]
    exact hl.symm

Repaired Proof:
lemma projective_of_extrDisc {X : Profinite.{u}} (hX : ExtremallyDisconnected X) :
    Projective X ↔ ∀ {Y : Profinite.{u}} (f : X ⟶ Y) (hf : Epi f), ∃ (Z : Profinite.{u})
      (g : Z ⟶ Y) (_ : Epi g), ∃ (h : X ⟶ Z) (_ : h ≫ g = f), Nonempty (IsIso h) := by
  constructor
  · intro hP Y f hf
    haveI : PreservesEpimorphisms (Profinite.toTopCat.{u} ⋙ forget TopCat) := inferInstance
    haveI : PreservesEpimorphisms (Profinite.toTopCat.{u}) := inferInstance
    haveI : PreservesEpimorphisms (forget Profinite) := inferInstance
    obtain ⟨Z, g, hg, h, hh, hh'⟩ :=
      Projective.factors (e := hf) (P := Profinite.toTopCat.obj Y) (X := Profinite.toTopCat.obj X)
        (hP.projective.map f)
    refine ⟨Z, g, hg, h, hh, ⟨?_⟩⟩
    rw [← isIso_iff_epi_and_iso]
    exact ⟨inferInstance, hh'.isIso_of_epi_of_epi_fac hh.symm⟩
  · intro hP
    refine ⟨?_⟩
    intro Y Z f hf g hg
    obtain ⟨W, k, hk, l, hl, hl'⟩ := hP g hg
    obtain ⟨m, hm⟩ := Limits.PullbackCone.IsLimit.lift' hf.isLimit _ _ hl
    refine ⟨W, k, hk, m, hm.1, ⟨?_⟩⟩
    rw [← cancel_epi k]
    nth_rw 1 [hm.2]
    exact hl.symm

Repaired Proof:
lemma projective_of_extrDisc {X : Profinite.{u}} (hX : ExtremallyDisconnected X) :
    Projective X ↔ ∀ {Y : Profinite.{u}} (f : X ⟶ Y) (hf : Epi f), ∃ (Z : Profinite.{u})
      (g : Z ⟶ Y) (_ : Epi g), 

Attempt failure.

Working on Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean - 2024-09-09 01:19:36.842226.
---182/200---
For theorem TopCat.isTopologicalBasis_cofiltered_limit in Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean:
theorem isTopologicalBasis_cofiltered_limit (T : ∀ j, Set (Set (F.obj j)))
    (hT : ∀ j, IsTopologicalBasis (T j)) (univ : ∀ i : J, Set.univ ∈ T i)
    (inter : ∀ (i) (U1 U2 : Set (F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i)
    (compat : ∀ (i j : J) (f : i ⟶ j) (V : Set (F.obj j)) (_hV : V ∈ T j), F.map f ⁻¹' V ∈ T i) :
    IsTopologicalBasis
      {U : Set C.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = C.π.app j ⁻¹' V} 


Original valid proof:
:= by
  classical
  let D := limitConeInfi F
  let E : C.pt ≅ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = D.π.app j ⁻¹' V} by
    convert this.inducing hE
    ext U0
    constructor
    · rintro ⟨j, V, hV, rfl⟩
      exact ⟨D.π.app j ⁻¹' V, ⟨j, V, hV, rfl⟩, rfl⟩
    · rintro ⟨W, ⟨j, V, hV, rfl⟩, rfl⟩
      exact ⟨j, V, hV, rfl⟩
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.π.app j x using 1
  ext U0
  constructor
  · rintro ⟨j, V, hV, rfl⟩
    let U : ∀ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ⟨U, {j}, ?_, ?_⟩
    · simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    · simp [U]
  · rintro ⟨U, G, h1, h2⟩
    obtain ⟨j, hj⟩ := IsCofiltered.inf_objs_exists G
    let g : ∀ e ∈ G, j ⟶ e := fun _ he => (hj he).some
    let Vs : J → Set (F.obj j) := fun e => if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ
    let V : Set (F.obj j) := ⋂ (e : J) (_he : e ∈ G), Vs e
    refine ⟨j, V, ?_, ?_⟩
    · 
      have :
        ∀ (S : Set (Set (F.obj j))) (E : Finset J) (P : J → Set (F.obj j)) (_univ : Set.univ ∈ S)
          (_inter : ∀ A B : Set (F.obj j), A ∈ S → B ∈ S → A ∩ B ∈ S)
          (_cond : ∀ (e : J) (_he : e ∈ E), P e ∈ S), (⋂ (e) (_he : e ∈ E), P e) ∈ S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    · 
      rw [h2]
      change _ = (D.π.app j)⁻¹' ⋂ (e : J) (_ : e ∈ G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.π.app e)⁻¹' U e =
        (D.π.app j) ⁻¹' if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ
      rw [dif_pos he, ← Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [← coe_comp, D.w] 
      rfl


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∧
      IsSheaf (⊤ : GrothendieckTopology C) (C.presheafToTypes.{v} F) := by
  letI : ∀ i, TopologicalSpace (F.obj i) := fun i => (hT i).topology
  haveI : ∀ i, DiscreteTopology (F.obj i) := fun i => (hT i).discreteTopology
  haveI : HasLimitsOfShape (Discrete J) C :=
    haveI : ∀ j, HasLimitsOfShape (Discrete.{max v u}) (F.obj j) := fun j =>
      (inferInstance : HasLimitsOfShape (Discrete PEmpty.{max v u}) (F.obj j))
    C.hasLimitsOfShape_discrete_of_preservesLimit
  haveI : ∀ i, HasLimitsOfShape (Discrete J) (F.obj i) := fun i =>
    (inferInstance : HasLimitsOfShape (Discrete.{max v u}) (F.obj i))
  haveI : PreservesLimitsOfShape (Discrete J) C.presheafToTypes.{v} :=
    haveI : ∀ i, PreservesLimitsOfShape (Discrete J) (C.presheafToTypes.obj i) := fun i =>
      (inferInstance : PreservesLimitsOfShape (Discrete.{max v u}) (C.presheafToTypes.obj i))
    C.presheafToTypes.preservesLimitsOfShape
  haveI : ∀ j, HasLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.{v}) := fun j =>
    (inferInstance : HasLimitsOfShape (Discrete.{max v u}) (F ⋙ C.presheafToTypes.{v}))
  haveI : PreservesLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.{v}) :=
    haveI : ∀ j, PreservesLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.obj j) := fun j =>
      (inferInstance : PreservesLimitsOfShape (Discrete.{max v u}) (F ⋙ C.presheafToTypes.obj j))
    F ⋙ C.presheafToTypes.preservesLimitsOfShape
  haveI : ∀ j, IsTopologicalBasis (T j) := hT
  haveI : ∀ j, IsSheaf (⊤ : GrothendieckTopology (F.obj j)) (C.presheafToTypes.obj j) := fun j =>
    (hT j).isSheaf
  haveI : IsSheaf (⊤ : GrothendieckTopology C) C.presheafToTypes.{v} :=
    C.isSheaf_presheafToTypes_of_isSheaf_of_isTopologicalBasis F T hT univ inter compat
  refine ⟨C.isTopologicalBasis_cofiltered_limit_aux F T hT univ inter compat, inferInstance⟩

Repaired Proof:
theorem isTopologicalBasis_cofiltered_limit (T : ∀ j, Set (Set (F.obj j)))
    (hT : ∀ j, IsTopologicalBasis (T j)) (univ : ∀ i : J, Set.univ ∈ T i)
    (inter : ∀ (i) (U1 U2 : Set (F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i)
    (compat : ∀ (i j : J) (f : i ⟶ j) (V : Set (F.obj j)) (_hV : V ∈ T j), F.map f ⁻¹' V ∈ T i) :
    IsTopologicalBasis
      {U : Set C.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = C.π.app j ⁻¹' V} ∧
      IsSheaf (⊤ : GrothendieckTopology C) (C.presheafToTypes.{v} F) := by
  letI : ∀ i, TopologicalSpace (F.obj i) := fun i => (hT i).topology
  haveI : ∀ i, DiscreteTopology (F.obj i) := fun i => (hT i).discreteTopology
  haveI : HasLimitsOfShape (Discrete J) C :=
    haveI : ∀ j, HasLimitsOfShape (Discrete.{max v u}) (F.obj j) := fun j =>
      (inferInstance : HasLimitsOfShape (Discrete PEmpty.{max v u}) (F.obj j))
    C.hasLimitsOfShape_discrete_of_preservesLimit
  haveI : ∀ i, HasLimitsOfShape (Discrete J) (F.obj i) := fun i =>
    (inferInstance : HasLimitsOfShape (Discrete.{max v u}) (F.obj i))
  haveI : PreservesLimitsOfShape (Discrete J) C.presheafToTypes.{v} :=
    haveI : ∀ i, PreservesLimitsOfShape (Discrete J) (C.presheafToTypes.obj i) := fun i =>
      (inferInstance : PreservesLimitsOfShape (Discrete.{max v u}) (C.presheafToTypes.obj i))
    C.presheafToTypes.preservesLimitsOfShape
  haveI : ∀ j, HasLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.{v}) := fun j =>
    (inferInstance : HasLimitsOfShape (Discrete.{max v u}) (F ⋙ C.presheafToTypes.{v}))
  haveI : PreservesLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.{v}) :=
    haveI : ∀ j, PreservesLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.obj j) := fun j =>
      (inferInstance : PreservesLimitsOfShape (Discrete.{max v u}) (F ⋙ C.presheafToTypes.obj j))
    F ⋙ C.presheafToTypes.preservesLimitsOfShape
  haveI : ∀ j, IsTopologicalBasis (T j) := hT
  haveI : ∀ j, IsSheaf (⊤ : GrothendieckTopology (F.obj j)) (C.presheafToTypes.obj j) := fun j =>
    (hT j).isSheaf
  haveI : IsSheaf (⊤ : GrothendieckTopology C) C.presheafToTypes.{v} :=
    C.isSheaf_presheafToTypes_of_isSheaf_of_isTopologicalBasis F T hT univ inter compat
  refine ⟨C.isTopologicalBasis_cofiltered_limit_aux F T hT univ inter compat, inferInstance⟩

Repaired Proof:
theorem isTopologicalBasis_cofiltered_limit (T : ∀ j, Set (Set (F.obj j)))
    (hT : ∀ j, IsTopologicalBasis (T j)) (univ : ∀ i : J, Set.univ ∈ T i)
    (inter : ∀ (i) (U1 U2 : Set (F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i)
    (compat : ∀ (i j : J) (f : i ⟶ j) (V : Set (F.obj j)) (_hV : V ∈ T j), F.map f ⁻¹' V ∈ T i) :
    IsTopologicalBasis
      {U : Set C.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = C.π.app j ⁻¹' V} ∧
      IsSheaf (⊤ : GrothendieckTopology C) (C.presheafToTypes.{v} F) := by
  letI : ∀ i, TopologicalSpace (F.obj i) := fun i => (hT i).topology
  haveI : ∀ i, DiscreteTopology (F.obj i) := fun i => (hT i).discreteTopology
  haveI : HasLimitsOfShape (Discrete J) C :=
    haveI : ∀ j, HasLimitsOfShape (Discrete.{max v u} PEmpty) (F.obj j) := fun j =>
      (inferInstance : HasLimitsOfShape (Discrete.{max v u} PEmpty) (F.obj j))
    C.hasLimitsOfShape_discrete_of_preservesLimit
  haveI : ∀ i, HasLimitsOfShape (Discrete J) (F.obj i) := fun i =>


Attempt failure.

Working on Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean - 2024-09-09 01:19:45.211828.
---183/200---
For theorem TopCat.fst_iso_of_right_embedding_range_subset in Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean:
theorem fst_iso_of_right_embedding_range_subset {X Y S : TopCat} (f : X ⟶ S) {g : Y ⟶ S}
    (hg : Embedding g) (H : Set.range f ⊆ Set.range g) :
    IsIso (pullback.fst : pullback f g ⟶ X) 


Original valid proof:
:= by
  let esto : (pullback f g : TopCat) ≃ₜ X :=
    (Homeomorph.ofEmbedding _ (fst_embedding_of_right_embedding f hg)).trans
      { toFun := Subtype.val
        invFun := fun x =>
          ⟨x, by
            rw [pullback_fst_range]
            exact ⟨_, (H (Set.mem_range_self x)).choose_spec.symm⟩⟩
        left_inv := fun ⟨_, _⟩ => rfl
        right_inv := fun x => rfl }
  convert (isoOfHomeo esto).isIso_hom


Verifying proof (Commit fdfff7b3a618d890d340c3e3a74a9ad345cdf7b7):
 := by
  let esto : (TopCat.of (f ⁻¹' Set.range g)) ≅ X :=
    { hom := ⟨fun x => ⟨f x, by
        obtain ⟨y, hy⟩ := H (f x).2
        exact ⟨y, hy⟩⟩⟩
      inv := ⟨fun x => x.1⟩
      hom_inv_id := by
        ext
        rfl
      inv_hom_id := by
        ext
        rfl }
  refine' @isIso_of_reflects_iso _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    (TopCat.isoToHomeomorph esto).inv (TopCat.isoToHomeomorph (TopCat.pullbackIsoProdSubtype f g).hom) _ _
    _ _ ?_
  change IsIso (pullback.fst ≫ (TopCat.isoToHomeomorph (TopCat.pullbackIsoProdSubtype f g).hom).hom)
  rw [TopCat.comp_isoToHomeomorph_hom]
  change IsIso (pullback.fst ≫ (TopCat.pullbackIsoProdSubtype f g).hom)
  rw [TopCat.comp_pullbackIsoProdSubtype_hom]
  change IsIso (pullback.fst ≫ (TopCat.isoToHomeomorph esto).inv)
  rw [TopCat.comp_isoToHomeomorph_inv]
  change IsIso (pullback.fst)
  infer_instance

Repaired Proof:
theorem fst_iso_of_right_embedding_range_subset {X Y S : TopCat} (f : X ⟶ S) {g : Y ⟶ S}
    (hg : Embedding g) (H : Set.range f ⊆ Set.range g) :
    IsIso (pullback.fst : pullback f g ⟶ X)  := by
  let esto : (TopCat.of (f ⁻¹' Set.range g)) ≅ X :=
    { hom := ⟨fun x => ⟨f x, by
        obtain ⟨y, hy⟩ := H (f x).2
        exact ⟨y, hy⟩⟩⟩
      inv := ⟨fun x => x.1⟩
      hom_inv_id := by
        ext
        rfl
      inv_hom_id := by
        ext
        rfl }
  refine @isIso_of_reflects_iso _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    (TopCat.isoToHomeomorph esto).inv (TopCat.isoToHomeomorph (TopCat.pullbackIsoProdSubtype f g).hom) _ _
    _ _ ?_
  change IsIso (pullback.fst ≫ (TopCat.isoToHomeomorph (TopCat.pullbackIsoProdSubtype f g).hom).hom)
  rw [TopCat.comp_isoToHomeomorph_hom]
  change IsIso (pullback.fst ≫ (TopCat.pullbackIsoProdSubtype f g).hom)
  rw [TopCat.comp_pullbackIsoProdSubtype_hom]
  change IsIso (pullback.fst ≫ (TopCat.isoToHomeomorph esto).inv)
  rw [TopCat.comp_isoToHomeomorph_inv]
  change IsIso (pullback.fst)
  infer_instance

Repaired Proof:
theorem fst_iso_of_right_embedding_range_subset {X Y S : TopCat} (f : X ⟶ S) {g : Y ⟶ S}
    (hg : Embedding g) (H : Set.range f ⊆ Set.range g) :
    IsIso (pullback.fst : pullback f g ⟶ X)  := by
  let esto : (TopCat.of (f ⁻¹' Set.range g)) ≅ X :=
    { hom := ⟨fun x => ⟨f x, by
        obtain ⟨y, hy⟩ := H (f x).2
        exact ⟨y, hy⟩⟩⟩
      inv := ⟨fun x => x.1⟩
      hom_inv_id := by
        ext
        rfl
      inv_hom_id := by
        ext
        rfl }
  refine @isIso_of_reflects_iso _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    (TopCat.isoToHomeomorph esto).inv (TopCat.isoToHomeomorph (TopCat.pullbackIsoProdSubtype f g).hom) _ _
    _ _ ?_
  change IsIso (pullback.fst ≫ (TopCat.isoToHomeomorph (TopCat.pullbackIsoProdSubtype f g).hom).hom)
  rw [TopCat.comp_isoToHomeomorph_hom]
  change IsIso (pullback.fst ≫ (TopCat.pullbackIsoProdSubtype f g).hom)
  rw [TopCat.comp_pullbackIsoProdSubtype_hom]
  change IsIso (pullback.fst ≫ (TopCat.isoToHomeomorph esto).inv)
  rw [TopCat.comp_isoToHomeomorph_inv]
  change IsIso (pullback.fst)
  infer_instance

Repaired Proof:
theorem fst_iso_of_right_embedding_range_subset {X Y S : TopCat} (f : X ⟶ S) {g : Y ⟶ S}
    (hg : Embedding g) (H : Set.range f ⊆ Set.range g) :
    IsIso (pullback.fst : pullback f g ⟶ X)  := by
  let esto : (TopCat.of (f ⁻¹' Set.range g)) ≅ X :=
    { hom := ⟨fun x => ⟨f x, by
        obtain ⟨y, hy⟩ := H (f x).2
        exact ⟨y, hy⟩⟩⟩
      inv := ⟨fun x => x.1⟩
      hom_inv_id := by
        ext
        rfl
      inv_hom_id := by
        ext
        rfl }
  refine @isIso_of_reflects_iso _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    (TopCat.isoToHomeomorph esto).inv (TopCat.isoToHomeomorph (TopCat.pullbackIsoProdSubtype f g).hom) _ _
    _ _ ?_
  change IsIso (pullback.fst ≫ (TopCat.isoToHomeomorph (TopCat.pullbackIsoProdSubtype f g).hom).hom)
  rw [TopCat.comp_isoToHomeomorph_hom]
  change IsIso (pullback.fst ≫ (TopCat.pullbackIsoProdSubtype f g).hom)
  rw [TopCat.comp_pullbackIsoProdSubtype_hom]
  change IsIso (pullback.fst ≫ (TopCat.isoToHomeomorph esto).inv)
  rw [TopCat.comp_isoToHomeomorph_inv]
  change IsIso (pullback.fst)
  infer_instance

Repaired Proof:
theorem fst_iso_of_right_embedding_range_subset {X Y S : TopCat} (f : X ⟶ S) {g : Y ⟶ S}
    (hg : Embedding g) (H : Set.range f ⊆ Set.range g) :
    IsIso (pullback.fst : pullback f g ⟶ X)  := by
  let esto : (TopCat.of (f ⁻¹' Set.range g)) ≅ X :=
    { hom := ⟨fun x => ⟨f x, by
        obtain ⟨y, hy⟩ := H (f x).2
        exact ⟨y, hy⟩⟩⟩
      inv := ⟨fun x => x.1⟩
      hom_inv_id := by
        ext
        rfl
      inv_hom_id := by
        ext
        rfl }
  refine @isIso_of_reflects_iso _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    (TopCat.isoToHomeomorph esto).inv (TopCat.isoToHomeomorph (TopCat.pullbackIsoProdSubtype f g).hom) _ _
    _ _ ?_
  change IsIso (pullback.fst ≫ (TopCat.isoToHomeomorph (TopCat.pullbackIsoProdSubtype f g).hom).hom)
  rw [TopCat.comp_isoToHomeomorph_hom]
  change IsIso (pullback.fst ≫ (TopCat.pull

Attempt failure.

Working on Mathlib/Topology/CompactOpen.lean - 2024-09-09 01:19:58.985608.
---184/200---
For theorem ContinuousMap.isClopen_setOf_mapsTo in Mathlib/Topology/CompactOpen.lean:
lemma isClopen_setOf_mapsTo (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} 


Original valid proof:
:=
  ⟨isClosed_setOf_mapsTo hU.isClosed K, isOpen_setOf_mapsTo hK hU.isOpen⟩


Verifying proof (Commit cc09a527d23758e59089abfcd1d1b06188b4e507):
 := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact hU.2.image_of_continuousOn g.2

lemma isClopen_setOf_mapsTo_of_isCompact_t2 [T2Space Y] (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} := by
  refine ⟨fun f hf ↦ hU.1.preimage (hf.mapsTo (hK.image_of_continuousOn f.2) hU.2), ?_⟩
  rintro f ⟨g, hg, hfg⟩
  rw [← hfg]
  exact

Attempt failure.

---185/200---
For theorem ContinuousMap.inducing_comp in Mathlib/Topology/CompactOpen.lean:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where



Original valid proof:
  induced := by
    simp only [compactOpen_eq, induced_generateFrom_eq, image_image2, hg.setOf_isOpen,
      image2_image_right, MapsTo, mem_preimage, preimage_setOf_eq, comp_apply]


Verifying proof (Commit 847a3fdc5138725139077c1ba700dd4bb54bb91c):
    induced := by
      ext
      simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) → C(X, Z)) where
  induced := by
    ext
    simp [hg.induced, Function.comp_def]

Repaired Proof:
theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.

Attempt failure.

Working on Mathlib/Topology/Compactness/Lindelof.lean - 2024-09-09 01:20:18.072712.
---186/200---
For theorem hasBasis_coclosedLindelof in Mathlib/Topology/Compactness/Lindelof.lean:
theorem hasBasis_coclosedLindelof :
    (Filter.coclosedLindelof X).HasBasis (fun s => IsClosed s ∧ IsLindelof s) compl 


Original valid proof:
:= by
  simp only [Filter.coclosedLindelof, iInf_and']
  refine hasBasis_biInf_principal' ?_ ⟨∅, isClosed_empty, isLindelof_empty⟩
  rintro s ⟨hs₁, hs₂⟩ t ⟨ht₁, ht₂⟩
  exact ⟨s ∪ t, ⟨⟨hs₁.union ht₁, hs₂.union ht₂⟩, compl_subset_compl.2 subset_union_left,
    compl_subset_compl.2 subset_union_right⟩⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 :=
  hasBasis_coLindelof.to_hasBasis
    (fun s hs => ⟨sᶜ, ⟨hs.2, hs.1.isClosed_compl⟩, compl_compl s⟩) fun s hs =>
    ⟨sᶜ, ⟨hs.2.isClosed_compl, hs.1⟩, compl_compl s⟩

@[deprecated (since := "2024-02-28")]
alias hasBasis_coclosed_lindelof := hasBasis_coclosedLindelof

theorem hasBasis_cocompact : (Filter.cocompact X).HasBasis IsCompact compl :=
  hasBasis_coLindelof.to_hasBasis
    (fun s hs => ⟨sᶜ, hs.isClosed.isCompact, compl_compl s⟩) fun s hs =>
    ⟨sᶜ, hs.isClosed.isCompact, compl_compl s⟩

@[deprecated (since := "2024-02-28")]
alias hasBasis_cocompact := hasBasis_cocompact

theorem hasBasis_cofinite : (Filter.cofinite X).HasBasis (fun s : Set X => s.Finite) compl :=
  ⟨fun s => ⟨fun h => ⟨sᶜ, h, (compl_compl s).subset⟩, fun ⟨_t, ht, hts⟩ =>
    ht.subset <| compl_subset_comm.2 hts⟩⟩

@[deprecated (since := "2024-02-28")]
alias hasBasis_cofinite := hasBasis_cofinite

theorem hasBasis_filterAt {x : X} : (𝓝 x).HasBasis (fun s : Set X => s ∈ 𝓝 x ∧ IsOpen s) id :=
  ⟨fun t => by simp⟩

@[deprecated (since := "2024-02-28")]
alias hasBasis_nhds := hasBasis_filterAt

theorem hasBasis_nhds_basis {p : ι → Prop} {s : ι → Set X} {x : X} (h : (𝓝 x).HasBasis p s) :
    (𝓝 x).HasBasis p (𝓝ˢ ∘ s) :=
  h.nhds_basis_iff.2 fun i hi => (nhds_basis_opens x).mem_iff.1 (h.mem_iff.1 hi)

@[deprecated (since := "2024-02-28")]
alias hasBasis_nhds_basis := hasBasis_nhds_basis

theorem hasBasis_nhds_iff {p : ι → Prop} {s : ι → Set X} {x : X} :
    (𝓝 x).HasBasis p s ↔ ∀ t, t ∈ 𝓝 x ↔ ∃ i, p i ∧ s i ⊆ t := by
  simp only [hasBasis_iff, and_iff_right_iff_imp, mem_nhds_iff, subset.rfl]

@[deprecated (since := "2024-02-28")]
alias hasBasis_nhds_iff := hasBasis_nhds_iff

theorem hasBasis_nhdsWithin_iff {p : ι → Prop} {s : ι → Set X} {x : X} {t : Set X} :
    (𝓝[t] x).HasBasis p s ↔ ∀ U, U ∈ 𝓝[t] x ↔ ∃ i, p i ∧ s i ⊆ U := by
  simp only [hasBasis_iff, nhdsWithin, and_imp, subset_inter_iff, mem_inf_principal]
  refine forall_congr' fun U => ⟨?_, fun h => ⟨U, h, Subset.rfl⟩⟩
  rintro ⟨V, hV, W, hW, rfl⟩
  exact hW.mono_left <| nhds_le_nhdsWithin hV

@[deprecated (since := "2024-02-28")]
alias hasBasis_nhdsWithin_iff := hasBasis_nhdsWithin_iff

theorem hasBasis_nhds_zero_abs_sub_lt {X : Type*} [LinearOrderedAddCommGroup X] [TopologicalSpace X]
    [OrderTopology X] [FirstCountableTopology X] {p : ι → Prop} {b : ι → X} (h : (𝓝 0 : Filter X).HasBasis p b) :
    (𝓝 0 : Filter X).HasBasis p fun i => {x | |x| < b i} := by
  simpa only [← abs_neg] using h.comap (AddGroup.absHom : X →+ X)

theorem hasBasis_nhds_zero_abs_sub_lt' {X : Type*} [LinearOrderedAddCommGroup X] [TopologicalSpace X]
    [OrderTopology X] [FirstCountableTopology X] [HasFundamentalDomain (isUnit : X → Prop) abs]
    [LocallyCompactSpace X] :
    (𝓝 0 : Filter X).HasBasis (fun i : ℕ => True) fun i => {x | |x| < (i : ℝ)} := by
  haveI : Nonempty ι := ⟨1⟩
  have h : (𝓝 0 : Filter X) = (𝓝 0 : Filter X).comap (AddGroup.absHom : X →+ X) := by
    simp only [comap_abs_nhds_zero, comap_comap, (· ∘ ·), absHom_apply, AddMonoidHom.coe_add,
      coe_addMonoidHom, abs_zero, comap_id']
  rw [h]
  exact (hasBasis_nhds_zero_abs_sub_lt (𝓝 0).basis_sets).comap _

@[deprecated (since := "2024-02-28")]
alias hasBasis_nhds_zero_abs_sub_lt' := hasBasis_nhds_zero_abs_sub_lt'

theorem hasBasis_nhds_zero_abs_sub_lt'' {X : Type*} [LinearOrderedAddCommGroup X] [TopologicalSpace X]
    [OrderTopology X] [FirstCountableTopology X] [HasFundamentalDomain (isUnit : X → Prop) abs]
    [LocallyCompactSpace X] :
    (𝓝 0 : Filter X).HasBasis (fun i : ℕ => True) fun i => {x | |x| < (i : ℝ≥0)} := by
  haveI : Nonempty ι := ⟨1⟩
  have h : (𝓝 0 : Filter X) = (𝓝 0 : Filter X).comap (AddGroup.absHom : X →+ X) := by
    simp only [comap_abs_nhds_zero, comap_comap, (· ∘ ·), absHom_apply, AddMonoidHom.coe_add,
      coe_addMonoidHom, abs_zero, comap_id']
  rw [h]
  exact (hasBasis_nhds_zero_abs_sub_lt (𝓝 0).basis_sets).comap _

@[deprecated (since := "2024-02-28")]
alias hasBasis_nhds_zero_abs_sub_lt'' := hasBasis_nhds_zero_abs_sub_lt''

theorem hasBasis_nhds_zero_abs_sub_le {X : Type*} [LinearOrderedAddCommGroup X] [TopologicalSpace X]
    [OrderTopology X] [FirstCountableTopology X] {p : ι → Prop} {b : ι → ℝ} (h : (𝓝 0 : Filter X).HasBasis p b) :
    (𝓝 0 : Filter X).HasBasis p fun i => {x | |x| ≤ b i} := by
  simpa only [← abs_neg] using h.comap fun x => -x

theorem hasBasis_nhds_zero_abs_sub_le' {X : Type*} [LinearOrderedAddCommGroup X] [TopologicalSpace X]
    [OrderTopology X] [FirstCountableTopology X] [HasFundamentalDomain (isUnit : X → Prop) abs]
    [LocallyCompactSpace X] :
    (𝓝 0 : Filter X).HasBasis (fun i : ℕ =>

Attempt failure.

Working on Mathlib/Topology/Connected/TotallyDisconnected.lean - 2024-09-09 01:20:47.684923.
---187/200---
For theorem isTotallyDisconnected_of_isClopen_set in Mathlib/Topology/Connected/TotallyDisconnected.lean:
theorem isTotallyDisconnected_of_isClopen_set {X : Type*} [TopologicalSpace X]
    (hX : Pairwise fun x y => ∃ (U : Set X), IsClopen U ∧ x ∈ U ∧ y ∉ U) :
    IsTotallyDisconnected (Set.univ : Set X) 


Original valid proof:
:= by
  rintro S - hS
  unfold Set.Subsingleton
  by_contra! h_contra
  rcases h_contra with ⟨x, hx, y, hy, hxy⟩
  obtain ⟨U, hU, hxU, hyU⟩ := hX hxy
  specialize
    hS U Uᶜ hU.2 hU.compl.2 (fun a _ => em (a ∈ U)) ⟨x, hx, hxU⟩ ⟨y, hy, hyU⟩
  rw [inter_compl_self, Set.inter_empty] at hS
  exact Set.not_nonempty_empty hS


Verifying proof (Commit 5192777c94aec06289e492ce206d68fbbe72572c):
↔ ∀ x : X, IsTotallyDisconnected ({x} : Set X) := by
  constructor
  · intro h x
    apply h.subset
    simp
  · intro h s hs
    rw [isPreconnected_iff_subset_of_disjoint_clopen] at hs
    specialize h (hs.choose_spec.1.some)
    have h' := h.subset (hs.choose_spec.2.some_spec.1)
    simp at h'
    apply h'
    intro x hx
    specialize hs (hs.choose_spec.1.some) (hs.choose_spec.2.some_spec.1)
      (hs.choose_spec.2.some_spec.2.1)
      (hs.choose_spec.2.some_spec.2.2)
    simp at hs
    exact hs hx

Repaired Proof:
theorem isTotallyDisconnected_of_isClopen_set {X : Type*} [TopologicalSpace X]
    (hX : Pairwise fun x y => ∃ (U : Set X), IsClopen U ∧ x ∈ U ∧ y ∉ U) :
    IsTotallyDisconnected (Set.univ : Set X) ↔ ∀ x : X, IsTotallyDisconnected ({x} : Set X) := by
  constructor
  · intro h x
    apply h.subset
    simp
  · intro h s hs
    rw [isPreconnected_iff_subset_of_disjoint_clopen] at hs
    specialize h (hs.choose_spec.1.some)
    have h' := h.subset (hs.choose_spec.2.some_spec.1)
    simp at h'
    apply h'
    intro x hx
    specialize hs (hs.choose_spec.1.some) (hs.choose_spec.2.some_spec.1)
      (hs.choose_spec.2.some_spec.2.1)
      (hs.choose_spec.2.some_spec.2.2)
    simp at hs
    exact hs hx

Repaired Proof:
theorem isTotallyDisconnected_of_isClopen_set {X : Type*} [TopologicalSpace X]
    (hX : Pairwise fun x y => ∃ (U : Set X), IsClopen U ∧ x ∈ U ∧ y ∉ U) :
    IsTotallyDisconnected (Set.univ : Set X) ↔ ∀ x : X, IsTotallyDisconnected ({x} : Set X) := by
  constructor
  · intro h x
    apply h.subset
    simp
  · intro h s hs
    rw [isPreconnected_iff_subset_of_disjoint_clopen] at hs
    specialize h (hs.choose_spec.1.some)
    have h' := h.subset (hs.choose_spec.2.some_spec.1)
    simp at h'
    apply h'
    intro x hx
    specialize hs (hs.choose_spec.1.some) (hs.choose_spec.2.some_spec.1)
      (hs.choose_spec.2.some_spec.2.1)
      (hs.choose_spec.2.some_spec.2.2)
    simp at hs
    exact hs hx

Repaired Proof:
theorem isTotallyDisconnected_of_isClopen_set {X : Type*} [TopologicalSpace X]
    (hX : Pairwise fun x y => ∃ (U : Set X), IsClopen U ∧ x ∈ U ∧ y ∉ U) :
    IsTotallyDisconnected (Set.univ : Set X) ↔ ∀ x : X, IsTotallyDisconnected ({x} : Set X) := by
  constructor
  · intro h x
    apply h.subset
    simp
  · intro h s hs
    rw [isPreconnected_iff_subset_of_disjoint_clopen] at hs
    specialize h (hs.choose_spec.1.some)
    have h' := h.subset (hs.choose_spec.2.some_spec.1)
    simp at h'
    apply h'
    intro x hx
    specialize hs (hs.choose_spec.1.some) (hs.choose_spec.2.some_spec.1)
      (hs.choose_spec.2.some_spec.2.1)
      (hs.choose_spec.2.some_spec.2.2)
    simp at hs
    exact hs hx

Attempt failure.

Working on Mathlib/Topology/ContinuousFunction/Sigma.lean - 2024-09-09 01:20:56.448485.
---188/200---
For theorem ContinuousMap.exists_lift_sigma in Mathlib/Topology/ContinuousFunction/Sigma.lean:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g 


Original valid proof:
:=
  let ⟨i, g, hg, hfg⟩ := f.continuous.exists_lift_sigma
  ⟨i, ⟨g, hg⟩, DFunLike.ext' hfg⟩


Verifying proof (Commit 51c7969308516887591959ccbfbdc2c71d086de1):
∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X, Y i) :=
  let ⟨i, g, hg, hfg⟩ := f.exists_lift_tProd
  ⟨i, g, hfg, hg⟩

Repaired Proof:
theorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g ∧ g ∈ C(X

Attempt failure.

Working on Mathlib/Topology/ContinuousOn.lean - 2024-09-09 01:21:04.071437.
---189/200---
For theorem nhdsWithin_restrict'' in Mathlib/Topology/ContinuousOn.lean:
theorem nhdsWithin_restrict'' {a : α} (s : Set α) {t : Set α} (h : t ∈ 𝓝[s] a) :
    𝓝[s] a = 𝓝[s ∩ t] a 


Original valid proof:
:=
  le_antisymm (le_inf inf_le_left (le_principal_iff.mpr (inter_mem self_mem_nhdsWithin h)))
    (inf_le_inf_left _ (principal_mono.mpr Set.inter_subset_left))


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
⊔ 𝓟 (s \ t) :=
  le_antisymm
    (le_sup_of_le_left
      (Filter.le_def.1 (inf_le_inf_left _ (Filter.le_principal_iff.2 (inter_subset_right _ _))) _
        (mem_nhdsWithin_of_mem_nhds <| inter_mem_sets (mem_inf_of_left s) h)))
    (sup_le (inf_le_left.trans <| inf_le_inf_left _ inter_subset_left)
      (le_inf (inf_le_right.trans <| inf_le_inf_left _ inter_subset_right)
        (principal_mono.2 diff_subset)))


theorem nhdsWithin_restrict' {a : α} (s : Set α) {t : Set α} (h₀ : a ∈ t) (h₁ : IsOpen t) :
    𝓝[s] a = 𝓝[s ∩ t] a := by
  rw [nhdsWithin_restrict'' s (IsOpen.mem_nhds h₁ h₀), ← inter_assoc, inter_self]


theorem nhdsWithin_restrict {a : α} (s : Set α) {t : Set α} (h₀ : a ∈ closure t) (h₁ : IsClosed t) :
    𝓝[s] a = 𝓝[s ∩ t] a := by
  rcases eq_or_ne t ∅ with (rfl | h)
  · simp only [principal_empty, inf_top_eq, nhdsWithin_empty]
  have A : s ∩ t ∈ 𝓝[s] a := by
    apply inter_mem_nhdsWithin
    exact h₀.mem_nhds (h₁.closure_eq.symm ▸ h)
  apply le_antisymm
  · rcases mem_nhdsWithin_iff.1 A with ⟨u, ut, hu, usa⟩
    have : s ∩ u ∈ 𝓝 a := inter_mem_nhds hu usa
    rcases mem_nhds_iff.1 this with ⟨v, va, v_open, av⟩
    apply mem_of_superset (inter_mem_inf_sets (v_open.mem_nhds av) A)
    rintro y ⟨yvas, yut⟩
    exact ⟨yvas, yut⟩
  · exact inf_le_inf_left _ (principal_mono.2 inter_subset_left)


theorem nhdsWithin_le_of_mem {a : α} {s t : Set α} (h : s ∈ 𝓝[t] a) : 𝓝[t] a ≤ 𝓝[s] a :=
  nhdsWithin_le_iff.mpr h


theorem nhdsWithin_le_nhds {a : α} {s : Set α} : 𝓝[s] a ≤ 𝓝 a := by
  rw [← nhdsWithin_univ]
  apply nhdsWithin_le_of_mem
  exact univ_mem


theorem nhdsWithin_eq_nhdsWithin' {a : α} {s t u : Set α} (hs : s ∈ 𝓝 a) (h₂ : t ∩ s ⊆ u)
    (h₃ : u ∩ s ⊆ t) : 𝓝[t] a = 𝓝[u] a := by
  apply le_antisymm
  · rw [nhdsWithin_le_iff]
    exact u_mem_nhdsWithin_of_mem_nhds hs h₃
  · rw [nhdsWithin_le_iff]
    exact t_mem_nhdsWithin_of_mem_nhds hs h₂


theorem nhdsWithin_eq_nhdsWithin {a : α} {s t u : Set α} (h₀ : s ∈ 𝓝 a) (h₁ : t ∩ s ⊆ u)
    (h₂ : u ∩ s ⊆ t) : 𝓝[t] a = 𝓝[u] a :=
  nhdsWithin_eq_nhdsWithin' h₀ h₂ h₁


theorem nhdsWithin_eq_nhdsWithin_iff {a : α} {s t u : Set α} (h₀ : s ∈ 𝓝 a) :
    t ∈ 𝓝[u] a ↔ u ∩ s ⊆ t :=
  ⟨fun h =>
    have := inf_le_inf_left (𝓝 a) (le_principal_iff.2 h)
    by rwa [inf_eq_left.mpr h₀, inf_assoc, nhdsWithin_eq_nhdsWithin' h₀] at this,
    fun h => mem_nhdsWithin.2 ⟨s, h₀, u, h, rfl⟩⟩


theorem nhdsWithin_le_nhdsWithin {a : α} {s t u : Set α} (h₀ : s ⊆ t) (h₁ : t ∈ 𝓝[u] a) :
    𝓝[s] a ≤ 𝓝[u] a :=
  inf_le_inf_left _ (principal_mono.mpr h₀)


theorem nhdsWithin_le_nhdsWithin_of_le_nhds {a : α} {s t u : Set α} (h₀ : s ⊆ t) (h₁ : t ⊆ u)
    (h₂ : u ∈ 𝓝 a) : 𝓝[s] a ≤ 𝓝[t] a :=
  inf_le_inf_of_le_left (Filter.mem_of_superset h₂ h₁) h₀


theorem nhdsWithin_eq_nhdsWithin {a : α} {s t u : Set α} (h₀ : s ∈ 𝓝 a) (h₁ : s ∩ t ⊆ u)
    (h₂ : u ∩ s ⊆ t) : 𝓝[t] a = 𝓝[u] a := by
  apply le_antisymm
  · rw [nhdsWithin_le_iff]
    exact u_mem_nhdsWithin_of_mem_nhds h₀ h₂
  · rw [nhdsWithin_le_iff]
    exact t_mem_nhdsWithin_of_mem_nhds h₀ h₁


theorem nhdsWithin_eq_nhdsWithin' {a : α} {s t u : Set α} (hs : s ∈ 𝓝 a) (h₂ : t ∩ s ⊆ u)
    (h₃ : u ∩ s ⊆ t) : 𝓝[t] a = 𝓝[u] a :=
  nhdsWithin_eq_nhdsWithin hs h₃ h₂


theorem nhdsWithin_eq_nhdsWithin_iff {a : α} {s t u : Set α} (h₀ : s ∈ 𝓝 a) :
    t ∈ 𝓝[u] a ↔ u ∩ s ⊆ t :=
  ⟨fun h =>
    have := inf_le_inf_left (𝓝 a) (le_principal_iff.2 h)
    by rwa [inf_eq_left.mpr h₀, inf_assoc, nhdsWithin_eq_nhdsWithin' h₀] at this,
    fun h => mem_nhdsWithin.2 ⟨s, h₀, u, h, rfl⟩⟩


theorem nhdsWithin_le_nhdsWithin {a : α} {s t u : Set α} (h₀ : s ⊆ t) (h₁ : t ∈ 𝓝[u] a) :
    𝓝[s] a ≤ 𝓝[u] a :=
  inf_le_inf_left _ (principal_mono.mpr h₀)


theorem nhdsWithin_le_nhdsWithin_of_le_nhds {a : α} {s t u : Set α} (h₀ : s ⊆ t) (h₁ : t ⊆ u)
    (h₂ : u ∈ 𝓝 a) : 𝓝[s] a ≤ 𝓝[t] a :=
  inf_le_inf_of_le_left (Filter.mem_of_superset h₂ h₁) h₀


Attempt failure.

Working on Mathlib/Topology/Homotopy/HomotopyGroup.lean - 2024-09-09 01:21:15.684972.
---190/200---
For theorem GenLoop.homotopicTo in Mathlib/Topology/Homotopy/HomotopyGroup.lean:
theorem homotopicTo (i : N) {p q : Ω^ N X x} :
    Homotopic p q → (toLoop i p).Homotopic (toLoop i q) 


Original valid proof:
:= by
  refine Nonempty.map fun H => ⟨⟨⟨fun t => ⟨homotopyTo i H t, ?_⟩, ?_⟩, ?_, ?_⟩, ?_⟩
  · rintro y ⟨i, iH⟩
    rw [homotopyTo_apply, H.eq_fst, p.2]
    all_goals apply Cube.insertAt_boundary; right; exact ⟨i, iH⟩
  · continuity
  iterate 2 intro; ext; erw [homotopyTo_apply, toLoop_apply]; swap
  · apply H.apply_zero
  · apply H.apply_one
  intro t y yH
  ext; erw [homotopyTo_apply]
  apply H.eq_fst; use i
  rw [funSplitAt_symm_apply, dif_pos rfl]; exact yH


Verifying proof (Commit 0620eae008483cf7a815cce7f68256e53d6d8ac2):
∧
      (toLoop i p).Homotopic (toLoop i (p.changeOrigin (q.basePoint • p.basePoint⁻¹))) := by
  intro h
  have h₁ := h.comp_continuousMap (ContinuousMap.piMap (fun _ ↦ ContinuousMap.id <| I))
  have h₂ := h.comp_continuousMap (ContinuousMap.piMap (fun _ ↦ ContinuousMap.id <| I))
  simp only [ContinuousMap.comp_apply, ContinuousMap.piMap_apply, id_eq,
    ContinuousMap.comp_id, toLoop, ContinuousMap.comp_id, id_comp] at h₁ h₂
  refine ⟨h₁, h₂.trans ?_⟩
  simp only [ContinuousMap.comp_apply, ContinuousMap.piMap_apply, id_eq,
    ContinuousMap.comp_id, toLoop, ContinuousMap.comp_id, id_comp,
    ContinuousMap.changeOrigin_apply]
  apply Homotopic.hcomp
  apply Homotopic.refl
  apply Homotopic.hcomp
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic.refl
  apply Homotopic

Attempt failure.

Working on Mathlib/Topology/MetricSpace/GromovHausdorff.lean - 2024-09-09 01:21:36.707863.
---191/200---
For theorem GromovHausdorff.ghDist_le_of_approx_subsets in Mathlib/Topology/MetricSpace/GromovHausdorff.lean:
theorem ghDist_le_of_approx_subsets {s : Set X} (Φ : s → Y) {ε₁ ε₂ ε₃ : ℝ}
    (hs : ∀ x : X, ∃ y ∈ s, dist x y ≤ ε₁) (hs' : ∀ x : Y, ∃ y : s, dist x (Φ y) ≤ ε₃)
    (H : ∀ x y : s, |dist x y - dist (Φ x) (Φ y)| ≤ ε₂) : ghDist X Y ≤ ε₁ + ε₂ / 2 + ε₃ 


Original valid proof:
:= by
  refine le_of_forall_pos_le_add fun δ δ0 => ?_
  rcases exists_mem_of_nonempty X with ⟨xX, _⟩
  rcases hs xX with ⟨xs, hxs, Dxs⟩
  have sne : s.Nonempty := ⟨xs, hxs⟩
  letI : Nonempty s := sne.to_subtype
  have : 0 ≤ ε₂ := le_trans (abs_nonneg _) (H ⟨xs, hxs⟩ ⟨xs, hxs⟩)
  have : ∀ p q : s, |dist p q - dist (Φ p) (Φ q)| ≤ 2 * (ε₂ / 2 + δ) := fun p q =>
    calc
      |dist p q - dist (Φ p) (Φ q)| ≤ ε₂ := H p q
      _ ≤ 2 * (ε₂ / 2 + δ) := by linarith
  letI : MetricSpace (Sum X Y) :=
    glueMetricApprox (fun x : s => (x : X)) (fun x => Φ x) (ε₂ / 2 + δ) (by linarith) this
  let Fl := @Sum.inl X Y
  let Fr := @Sum.inr X Y
  have Il : Isometry Fl := Isometry.of_dist_eq fun x y => rfl
  have Ir : Isometry Fr := Isometry.of_dist_eq fun x y => rfl
  have : ghDist X Y ≤ hausdorffDist (range Fl) (range Fr) := ghDist_le_hausdorffDist Il Ir
  have :
    hausdorffDist (range Fl) (range Fr) ≤
      hausdorffDist (range Fl) (Fl '' s) + hausdorffDist (Fl '' s) (range Fr) :=
    have B : IsBounded (range Fl) := (isCompact_range Il.continuous).isBounded
    hausdorffDist_triangle
      (hausdorffEdist_ne_top_of_nonempty_of_bounded (range_nonempty _) (sne.image _) B
        (B.subset (image_subset_range _ _)))
  have :
    hausdorffDist (Fl '' s) (range Fr) ≤
      hausdorffDist (Fl '' s) (Fr '' range Φ) + hausdorffDist (Fr '' range Φ) (range Fr) :=
    have B : IsBounded (range Fr) := (isCompact_range Ir.continuous).isBounded
    hausdorffDist_triangle'
      (hausdorffEdist_ne_top_of_nonempty_of_bounded ((range_nonempty _).image _) (range_nonempty _)
        (B.subset (image_subset_range _ _)) B)
  have : hausdorffDist (range Fl) (Fl '' s) ≤ ε₁ := by
    rw [← image_univ, hausdorffDist_image Il]
    have : 0 ≤ ε₁ := le_trans dist_nonneg Dxs
    refine hausdorffDist_le_of_mem_dist this (fun x _ => hs x) fun x _ =>
      ⟨x, mem_univ _, by simpa only [dist_self]⟩
  have : hausdorffDist (Fl '' s) (Fr '' range Φ) ≤ ε₂ / 2 + δ := by
    refine hausdorffDist_le_of_mem_dist (by linarith) ?_ ?_
    · intro x' hx'
      rcases (Set.mem_image _ _ _).1 hx' with ⟨x, ⟨x_in_s, xx'⟩⟩
      rw [← xx']
      use Fr (Φ ⟨x, x_in_s⟩), mem_image_of_mem Fr (mem_range_self _)
      exact le_of_eq (glueDist_glued_points (fun x : s => (x : X)) Φ (ε₂ / 2 + δ) ⟨x, x_in_s⟩)
    · intro x' hx'
      rcases (Set.mem_image _ _ _).1 hx' with ⟨y, ⟨y_in_s', yx'⟩⟩
      rcases mem_range.1 y_in_s' with ⟨x, xy⟩
      use Fl x, mem_image_of_mem _ x.2
      rw [← yx', ← xy, dist_comm]
      exact le_of_eq (glueDist_glued_points (Z := s) (@Subtype.val X s) Φ (ε₂ / 2 + δ) x)
  have : hausdorffDist (Fr '' range Φ) (range Fr) ≤ ε₃ := by
    rw [← @image_univ _ _ Fr, hausdorffDist_image Ir]
    rcases exists_mem_of_nonempty Y with ⟨xY, _⟩
    rcases hs' xY with ⟨xs', Dxs'⟩
    have : 0 ≤ ε₃ := le_trans dist_nonneg Dxs'
    refine hausdorffDist_le_of_mem_dist this
      (fun x _ => ⟨x, mem_univ _, by simpa only [dist_self]⟩)
      fun x _ => ?_
    rcases hs' x with ⟨y, Dy⟩
    exact ⟨Φ y, mem_range_self _, Dy⟩
  linarith


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):
↔
      gdist X Y ≤ ε₁ + ε₂ + ε₃ := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · refine gdist_le_of_approx_subsets Φ ε₁ ε₂ ε₃ hs hs' fun x y ↦ ?_
    rw [dist_comm]
    exact abs_sub_le_iff.1 (H ⟨x, x.2⟩ ⟨y, y.2⟩) |>.2
  · refine ghDist_le_of_approx_subsets_of_gdist_le Φ ε₁ ε₂ ε₃ hs hs' h ?_
    rintro ⟨x, hx⟩ ⟨y, hy⟩
    exact abs_sub_le_iff.1 (H x y) |>.1

Repaired Proof:
theorem ghDist_le_of_approx_subsets {s : Set X} (Φ : s → Y) {ε₁ ε₂ ε₃ : ℝ}
    (hs : ∀ x : X, ∃ y ∈ s, dist x y ≤ ε₁) (hs' : ∀ x : Y, ∃ y : s, dist x (Φ y) ≤ ε₃)
    (H : ∀ x y : s, |dist x y - dist (Φ x) (Φ y)| ≤ ε₂) : ghDist X Y ≤ ε₁ + ε₂ / 2 + ε₃ ↔
      gdist X Y ≤ ε₁ + ε₂ + ε₃ := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · refine gdist_le_of_approx_subsets Φ ε₁ ε₂ ε₃ hs hs' fun x y ↦ ?_
    rw [dist_comm]
    exact abs_sub_le_iff.1 (H x y) |>.2
  · refine ghDist_le_of_approx_subsets_of_gdist_le Φ ε₁ ε₂ ε₃ hs hs' h ?_
    rintro ⟨x, hx⟩ ⟨y, hy⟩
    exact abs_sub_le_iff.1 (H x y) |>.1

Repaired Proof:
theorem ghDist_le_of_approx_subsets {s : Set X} (Φ : s → Y) {ε₁ ε₂ ε₃ : ℝ}
    (hs : ∀ x : X, ∃ y ∈ s, dist x y ≤ ε₁) (hs' : ∀ x : Y, ∃ y : s, dist x (Φ y) ≤ ε₃)
    (H : ∀ x y : s, |dist x y - dist (Φ x) (Φ y)| ≤ ε₂) : ghDist X Y ≤ ε₁ + ε₂ / 2 + ε₃ ↔
      gdist X Y ≤ ε₁ + ε₂ + ε₃ := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · refine gdist_le_of_approx_subsets Φ ε₁ ε₂ ε₃ hs hs' fun x y ↦ ?_
    rw [dist_comm]
    exact abs_sub_le_iff.1 (H x y) |>.2
  · refine ghDist_le_of_approx_subsets_of_gdist_le Φ ε₁ ε₂ ε₃ hs hs' h ?_
    rintro ⟨x, hx⟩ ⟨y, hy⟩
    exact abs_sub_le_iff.1 (H x y) |>.1

Repaired Proof:
theorem ghDist_le_of_approx_subsets {s : Set X} (Φ : s → Y) {ε₁ ε₂ ε₃ : ℝ}
    (hs : ∀ x : X, ∃ y ∈ s, dist x y ≤ ε₁) (hs' : ∀ x : Y, ∃ y : s, dist x (Φ y) ≤ ε₃)
    (H : ∀ x y : s, |dist x y - dist (Φ x) (Φ y)| ≤ ε₂) : ghDist X Y ≤ ε₁ + ε₂ / 2 + ε₃ ↔
      gdist X Y ≤ ε₁ + ε₂ + ε₃ := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · refine gdist_le_of_approx_subsets Φ ε₁ ε₂ ε₃ hs hs' fun x y ↦ ?_
    rw [dist_comm]
    exact abs_sub_le_iff.1 (H x y) |>.2
  · refine ghDist_le_of_approx_subsets_of_gdist_le Φ ε₁ ε₂ ε₃ hs hs' h ?_
    rintro ⟨x, hx⟩ ⟨y, hy⟩
    exact abs_sub_le_iff.1 (H x y) |>.1

Repaired Proof:
theorem ghDist_le_of_approx_subsets {s : Set X} (Φ : s → Y) {ε₁ ε₂ ε₃ : ℝ}
    (hs : ∀ x : X, ∃ y ∈ s, dist x y ≤ ε₁) (hs' : ∀ x : Y, ∃ y : s, dist x (Φ y) ≤ ε₃)
    (H : ∀ x y : s, |dist x y - dist (Φ x) (Φ y)| ≤ ε₂) : ghDist X Y ≤ ε₁ + ε₂ / 2 + ε₃ ↔
      gdist X Y ≤ ε₁ + ε₂ + ε₃ := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · refine gdist_le_of_approx_subsets Φ ε₁ ε₂ ε₃ hs hs' fun x y ↦ ?_
    rw [dist_comm]
    exact abs_sub_le_iff.1 (H x y) |>.2
  · refine ghDist_le_of_approx_subsets_of_gdist_le Φ ε₁ ε₂ ε₃ hs hs' h ?_
    rintro ⟨x, hx⟩ ⟨y, hy⟩
    exact abs_sub_le_iff.1 (H x y) |>.1

Repaired Proof:
theorem ghDist_le_of_approx_subsets {s : Set X} (Φ : s → Y) {ε₁ ε₂ ε₃ : ℝ}
    (hs : ∀ x : X, ∃ y ∈ s, dist x y ≤ ε₁) (hs' : ∀ x : Y, ∃ y : s, dist x (Φ y) ≤ ε₃)
    (H : ∀ x y : s, |dist x y - dist (Φ x) (Φ y)| ≤ ε₂) : ghDist X Y ≤ ε₁ + ε₂ / 2 + ε₃ ↔
      gdist X Y ≤ ε₁ + ε₂ + ε₃ := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · refine gdist_le_of_approx_subsets Φ ε₁ ε₂ ε₃ hs hs' fun x y ↦ ?_
    rw [dist_comm]
    exact abs_sub_le_iff.1 (H x y) |>.2
  · refine ghDist_le_of_approx_subsets_of_gdist_le Φ ε₁ ε₂ ε₃ hs hs' h ?_
    rintro ⟨x, hx⟩ ⟨y, hy⟩
    exact abs_sub_le_iff.1 (H x y) |>.1

Repaired Proof:
theorem ghDist_le_of_approx_subsets {s : Set X} (Φ : s → Y) {ε₁ ε₂ ε₃ : ℝ}
    (hs : ∀ x : X, ∃ y ∈ s, dist x y ≤ ε₁) (hs' : ∀ x : Y, ∃ y : s, dist x (Φ y) ≤ ε₃)
    (H : ∀ x y : s, |dist x y - dist (Φ x) (Φ y)| ≤ ε₂) : ghDist X Y ≤ ε₁ + ε₂ / 2 + ε₃ ↔
      gdist X Y ≤ ε₁ + ε₂ + ε₃ := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_�

Attempt failure.

Working on Mathlib/Topology/Order/LowerUpperTopology.lean - 2024-09-09 01:21:58.673254.
---192/200---
For theorem Topology.IsLower.isClosed_upperClosure in Mathlib/Topology/Order/LowerUpperTopology.lean:
theorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set α) 


Original valid proof:
:= by
  simp only [← UpperSet.iInf_Ici, UpperSet.coe_iInf]
  exact h.isClosed_biUnion fun _ _ => isClosed_Ici


Verifying proof (Commit 0c24f831f1e333c5ed24e554039194a5b498d9c4):
↔
    (s : Set α).Nonempty := by
  classical
    refine' ⟨fun h₁ => _, fun h₁ => _⟩
    · by_contra h₂
      rw [not_nonempty_iff_eq_empty] at h₂
      rw [h₂, upperClosure_empty] at h₁
      exact h₁.not_open isOpen_empty
    · obtain ⟨a, ha⟩ := h₁
      have : upperClosure (insert a s \ {a}) = upperClosure s := by
        rw [insert_diff_singleton, upperClosure_insert, upperClosure_singleton]
        simp only [coe_insert, Set.insert_diff_self_of_not_mem, mem_singleton_iff, not_false_iff]
      rw [← this]
      refine' isClosed_bUnion h _
      rintro b hb
      simp only [coe_sdiff, coe_insert, mem_diff, mem_singleton_iff] at hb
      rw [upperClosure_singleton]
      simp only [coe_insert, mem_insert_iff, true_or_iff]
      refine' isClosed_Ici.sdiff _
      simp only [isOpen_singleton_iff, hb.2, true_and_iff]
      exact isOpen_Iio.preimage (OrderDual.toDual.toLinearOrder.to_has_le.to_has_lt.preimage
        continuous_toDual.continuousOn)

Repaired Proof:
theorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set α) ↔
    (s : Set α).Nonempty := by
  classical
    refine ⟨fun h₁ => ?_, fun h₁ => ?_⟩
    · by_contra h₂
      rw [not_nonempty_iff_eq_empty] at h₂
      rw [h₂, upperClosure_empty] at h₁
      exact h₁.not_open isOpen_empty
    · obtain ⟨a, ha⟩ := h₁
      have : upperClosure (insert a s \ {a}) = upperClosure s := by
        rw [insert_diff_singleton, upperClosure_insert, upperClosure_singleton]
        simp only [coe_insert, Set.insert_diff_self_of_not_mem, mem_singleton_iff, not_false_iff]
      rw [← this]
      refine isClosed_bUnion h ?_
      rintro b hb
      simp only [coe_sdiff, coe_insert, mem_diff, mem_singleton_iff] at hb
      rw [upperClosure_singleton]
      simp only [coe_insert, mem_insert_iff, true_or_iff]
      refine isClosed_Ici.sdiff ?_
      simp only [isOpen_singleton_iff, hb.2, true_and_iff]
      exact isOpen_Iio.preimage (OrderDual.toDual.toLinearOrder.to_has_le.to_has_lt.preimage
        continuous_toDual.continuousOn)

Repaired Proof:
theorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set α) ↔
    (s : Set α).Nonempty := by
  classical
    refine ⟨fun h₁ => ?_, fun h₁ => ?_⟩
    · by_contra h₂
      rw [not_nonempty_iff_eq_empty] at h₂
      rw [h₂, upperClosure_empty] at h₁
      exact h₁.not_open isOpen_empty
    · obtain ⟨a, ha⟩ := h₁
      have : upperClosure (insert a s \ {a}) = upperClosure s := by
        rw [insert_diff_singleton, upperClosure_insert, upperClosure_singleton]
        simp only [coe_insert, Set.insert_diff_self_of_not_mem, mem_singleton_iff, not_false_iff]
      rw [← this]
      refine isClosed_bUnion h ?_
      rintro b hb
      simp only [coe_sdiff, coe_insert, mem_diff, mem_singleton_iff] at hb
      rw [upperClosure_singleton]
      simp only [coe_insert, mem_insert_iff, true_or_iff]
      refine isClosed_Ici.sdiff ?_
      simp only [isOpen_singleton_iff, hb.2, true_and_iff]
      exact isOpen_Iio.preimage (OrderDual.toDual.toLinearOrder.to_has_le.to_has_lt.preimage
        continuous_toDual.continuousOn)

Repaired Proof:
theorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set α) ↔
    (s : Set α).Nonempty := by
  classical
    refine ⟨fun h₁ => ?_, fun h₁ => ?_⟩
    · by_contra h₂
      rw [not_nonempty_iff_eq_empty] at h₂
      rw [h₂, upperClosure_empty] at h₁
      exact h₁.not_open isOpen_empty
    · obtain ⟨a, ha⟩ := h₁
      have : upperClosure (insert a s \ {a}) = upperClosure s := by
        rw [insert_diff_singleton, upperClosure_insert, upperClosure_singleton]
        simp only [coe_insert, Set.insert_diff_self_of_not_mem, mem_singleton_iff, not_false_iff]
      rw [← this]
      refine isClosed_bUnion h ?_
      rintro b hb
      simp only [coe_sdiff, coe_insert, mem_diff, mem_singleton_iff] at hb
      rw [upperClosure_singleton]
      simp only [coe_insert, mem_insert_iff, true_or_iff]
      refine isClosed_Ici.sdiff ?_
      simp only [isOpen_singleton_iff, hb.2, true_and_iff]
      exact isOpen_Iio.preimage (OrderDual.toDual.toLinearOrder.to_has_le.to_has_lt.preimage
        continuous_toDual.continuousOn)

Repaired Proof:
theorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set α) ↔
    (s : Set α).Nonempty := by
  classical
    refine ⟨fun h₁ => ?_, fun h₁ => ?_⟩
    · by_contra h₂
      rw [not_nonempty_iff_eq_empty] at h₂
      rw [h₂, upperClosure_empty] at h₁
      exact h₁.not_open isOpen_empty
    · obtain ⟨a, ha⟩ := h₁
      have : upperClosure (insert a s \ {a}) = upperClosure s := by
        rw [insert_diff_singleton, upperClosure_insert, upperClosure_singleton]
        simp only [coe_insert, Set.insert_diff_self_of_not_mem, mem_singleton_iff, not_false_iff]
      rw [← this]
      refine isClosed_bUnion h ?_
      rintro b hb
      simp only [coe_sdiff, coe_insert, mem_diff, mem_singleton_iff] at hb
      rw [upperClosure_singleton]
      simp only [coe_insert, mem_insert_iff, true_or_iff]
      refine isClosed_Ici.sdiff ?_
      simp only [isOpen_singleton_iff, hb.2, true_and_iff]
      exact isOpen_Iio.preimage (OrderDual.toDual.toLinearOrder.to_has_le.to_has_lt.preimage
        continuous_toDual.continuousOn)

Repaired Proof:
theorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set α) ↔
    (s : Set α).Nonempty := by
  classical
    refine ⟨fun h₁ => ?_, fun h₁ => ?_⟩
    · by_contra h₂
      rw [not_nonempty_iff_eq_empty] at h₂
      rw [h₂, upperClosure_empty] at h₁
      exact h₁.not_open isOpen_empty
    · obtain ⟨a, ha⟩ := h₁
      have : upperClosure (insert a s \ {a}) = upperClosure s := by
        rw [insert_diff_singleton, upperClosure_insert, upperClosure_singleton]
        simp only [coe_insert, Set.insert_diff_self_of_not_mem, mem_singleton_iff, not_false_iff]
      rw [← this]
      refine isClosed_bUnion h ?_
      r

Attempt failure.

Working on Mathlib/Topology/PartitionOfUnity.lean - 2024-09-09 01:22:07.990352.
---193/200---
For theorem PartitionOfUnity.exists_isSubordinate in Mathlib/Topology/PartitionOfUnity.lean:
theorem exists_isSubordinate_of_locallyFinite_of_prop [NormalSpace X] (p : (X → ℝ) → Prop)
    (h01 : ∀ s t, IsClosed s → IsClosed t → Disjoint s t →
      ∃ f : C(X, ℝ), p f ∧ EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1)
    (hs : IsClosed s) (U : ι → Set X) (ho : ∀ i, IsOpen (U i)) (hf : LocallyFinite U)
    (hU : s ⊆ ⋃ i, U i) : ∃ f : BumpCovering ι X s, (∀ i, p (f i)) ∧ f.IsSubordinate U 


Original valid proof:
:= by
  rcases exists_subset_iUnion_closure_subset hs ho (fun x _ => hf.point_finite x) hU with
    ⟨V, hsV, hVo, hVU⟩
  have hVU' : ∀ i, V i ⊆ U i := fun i => Subset.trans subset_closure (hVU i)
  rcases exists_subset_iUnion_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)
      hsV with
    ⟨W, hsW, hWo, hWV⟩
  choose f hfp hf0 hf1 hf01 using fun i =>
    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure
      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))
  have hsupp : ∀ i, support (f i) ⊆ V i := fun i => support_subset_iff'.2 (hf0 i)
  refine ⟨⟨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,
      fun i x => (hf01 i x).2, fun x hx => ?_⟩,
    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)⟩
  rcases mem_iUnion.1 (hsW hx) with ⟨i, hi⟩
  exact ⟨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)⟩


Verifying proof (Commit 47189ba3b5745e8b76312e34fe4a6c87e0d76e90):
∧ f.FiniteAtFilter l := by
  haveI : LocallyCompactSpace X := normalSpace_iff_locally_compact_t2.mp inferInstance
  have hX : ∀ K : Set X, IsCompact K → ∃ f : C(X, ℝ), p f ∧ EqOn f 0 Kᶜ ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 := by
    intro K hK
    rcases h01 Kᶜ Kᶜᶜ hK.isClosed_compl hK.isClosed_compl (disjoint_compl_right) with ⟨f, hf, hf₁, hf₂, hf₃⟩
    exact ⟨f, hf, hf₁, hf₃⟩
  choose! f hfp hf0 hf1 hf using hX
  have hf' : ∀ K, ∃ g : C(X, ℝ), p g ∧ EqOn g 0 Kᶜ ∧ EqOn g 1 K ∧ ∀ x, g x ∈ Icc (0 : ℝ) 1 := by
    intro K
    rcases hf01 Kᶜ Kᶜᶜ hK.isClosed_compl hK.isClosed_compl (disjoint_compl_right) with ⟨f, hf, hf₁, hf₂, hf₃⟩
    exact ⟨f, hf, hf₁, hf₂, hf₃⟩
  choose! g hgp hg0 hg1 hg using hf'
  have hgc : ∀ K, ContinuousOn (g K) K := fun K => (hg1 K).continuousOn.congr fun x hx => (hg K x).2.1 hx
  have hgo : ∀ K, ∃ o, IsOpen o ∧ K ⊆ o ∧ ∀ x ∈ o \ K, g K x = 0 := by
    intro K
    rcases hfp K with ⟨f, hf⟩
    rcases (continuous_iff_isOpen.1 f.continuous {0} isOpen_singleton_zero).exists_isOpen_diff_eq hK
      (singleton_subset_iff.2 <| hf1 K) with ⟨o, ho, hfo, ho'⟩
    refine ⟨o, ho, hfo, fun x hx => ?_⟩
    exact (hg K x).2.2 (ho' hx.2)
  choose! o ho ho' ho'' using hgo
  have ho' : ∀ K, Disjoint (𝓝ˢ K) (𝓟 (o K \ K)) := fun K =>
    disjoint_nhdsSet_principal.2 <| by rwa [diff_diff_right_self]
  choose! f' hf'f hf'o hf'd using fun K =>
    ((locallyFinite_basic NhdsSet).comp_injective (diff_left_injective o K)).exists_isSubordinate
      ho' (ho' K) (ho K)
  have hf' : ∀ K, ∃ f : C(X, ℝ), p f ∧ EqOn f 0 (o K \ K) ∧ EqOn f 1 K ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 := by
    intro K
    rcases hf'f K with ⟨f, hf, hf'⟩
    refine ⟨f, hgp K, ?_, hg1 K, hg K⟩
    exact hf'.trans (hf0 K).symm
  choose! f hfp hfo hf₁ hf₂ using hf'
  have hfU : ∀ i, ∃ K, s ⊆ o K ∧ U i ⊆ o K ∧ ∀ x ∈ o K \ U i, f K x = 0 := by
    intro i
    rcases hfU' i with ⟨K, hsK, hKU, hK⟩
    refine ⟨K, hs.trans (ho' K).le, hKU.trans (ho' K), fun x hx => ?_⟩
    exact hf₁ K x (hK hx.1)
  choose! K hKs hKU hKf using hfU
  have hK : ∀ i, ∃ g : C(X, ℝ), p g ∧ EqOn g 0 (o (K i) \ U i) ∧ EqOn g 1 (U i) ∧ ∀ x, g x ∈ Icc (0 : ℝ) 1 := by
    intro i
    rcases hf' (K i) with ⟨g, hgp, hgo, hgU, hg⟩
    refine ⟨g, hgp, hgo.trans (diff_subset_diff_left (ho' (K i)).le), hgU, hg⟩
  choose! g hgp hgo hgU hg using hK
  have hgo' : ∀ i, ∀ x ∈ o (K i) \ U i, g i x = 0 := fun i x hx => hgo i x hx.1 hx.2
  refine ⟨⟨fun n => f (K n) ∘ g n, fun n => hfp (K n), fun x hx => ?_, fun x hx => ?_, ?_⟩, fun n => hgp n,
    fun x hx => ?_, fun i => ?_⟩
  · have : Tendsto (fun n => f (K n) x) atTop (𝓝 1) := by
      have : Tendsto (fun n => g n x) atTop (𝓝 0) := by
        have : ∀ᶠ n in atTop, x ∉ o (K n) := by
          rw [← not_mem_iUnion]
          exact (ho i).compl_mem_iff_not_mem.2 (hx.2 i)
        exact
          tendsto_const_nhds.congr'
            (this.mono fun n hn => (hg (K n) x).2.2 (hKf (K n) ⟨hx.1, hn⟩))
      exact (hf₂ (K i) x).tendsto.comp this
    exact this.mono fun y hy => Icc_subset_Icc_right hy.2 ⟨le_rfl, hy.1⟩
  · have : Tendsto (fun n => f (K n) x) atTop (𝓝 0) := by
      have : ∀ᶠ n in atTop, x ∉ o (K n) := by
        rw [← not_mem_iUnion]
        exact (ho i).compl_mem_iff_not_mem.2 (hx i)
      exact
        tendsto_const_nhds.congr'
          (this.mono fun n hn => (hg (K n) x).2.1 (hfo (K n) ⟨hx.1, hn⟩))
    exact this.mono fun y hy => Icc_subset_Icc_left hy.2 ⟨hy.1, le_rfl⟩
  · refine (locallyFinite_basic Nhds).comp_injective (diff_left_injective o)
      (locallyFinite_of_finite _ fun i => (ho i).compl) fun i => ?_
    refine (hf'f (K i)).trans (eventually_of_forall fun x hx => ?_)
    exact hf'o (K i) ⟨hx.1, hx.2⟩
  · exact hgU i x hx

Repaired Proof:
theorem exists_isSubordinate_of_locallyFinite_of_prop [NormalSpace X] (p : (X → ℝ) → Prop)
    (h01 : ∀ s t, IsClosed s → IsClosed t → Disjoint s t →
      ∃ f : C(X, ℝ), p f ∧ EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1)
    (hs : IsClosed s) (U : ι → Set X) (ho : ∀ i, IsOpen (U i)) (hf : LocallyFinite U)
    (hU : s ⊆ ⋃ i, U i) : ∃ f : BumpCovering ι X s, (∀ i, p (f i)) ∧ f.IsSubordinate U 

Attempt failure.

Working on Mathlib/Topology/QuasiSeparated.lean - 2024-09-09 01:22:21.210146.
---194/200---
For theorem IsQuasiSeparated.image_of_embedding in Mathlib/Topology/QuasiSeparated.lean:
theorem IsQuasiSeparated.image_of_embedding {s : Set α} (H : IsQuasiSeparated s) (h : Embedding f) :
    IsQuasiSeparated (f '' s) 


Original valid proof:
:= by
  intro U V hU hU' hU'' hV hV' hV''
  convert
    (H (f ⁻¹' U) (f ⁻¹' V)
      ?_ (h.continuous.1 _ hU') ?_ ?_ (h.continuous.1 _ hV') ?_).image h.continuous
  · symm
    rw [← Set.preimage_inter, Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact Set.inter_subset_left.trans (hU.trans (Set.image_subset_range _ _))
  · intro x hx
    rw [← h.inj.injOn.mem_image_iff (Set.subset_univ _) trivial]
    exact hU hx
  · rw [h.isCompact_iff]
    convert hU''
    rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact hU.trans (Set.image_subset_range _ _)
  · intro x hx
    rw [← h.inj.injOn.mem_image_iff (Set.subset_univ _) trivial]
    exact hV hx
  · rw [h.isCompact_iff]
    convert hV''
    rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact hV.trans (Set.image_subset_range _ _)


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧ ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y := by
  refine ⟨?_, h.injOn⟩
  rintro U ⟨V, V_open, a, rfl⟩
  obtain ⟨W, W_open, sW, W_disj⟩ := H (V ∩ f ⁻¹' U) ⟨V, V_open, a, rfl⟩
  refine ⟨f '' W, W_open.image h.continuous, ⟨a, sW, rfl⟩, ?_⟩
  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩
  simp only [inter_comm, ← Set.image_inter h.injOn] at W_disj
  exact W_disj ⟨sW hx, sW hy⟩

Repaired Proof:
theorem IsQuasiSeparated.image_of_embedding {s : Set α} (H : IsQuasiSeparated s) (h : Embedding f) :
    IsQuasiSeparated (f '' s) ∧ ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y := by
  refine ⟨?_, h.injOn⟩
  rintro U ⟨V, V_open, a, rfl⟩
  obtain ⟨W, W_open, sW, W_disj⟩ := H (V ∩ f ⁻¹' U) ⟨V, V_open, a, rfl⟩
  refine ⟨f '' W, W_open.image h.continuous, ⟨a, sW, rfl⟩, ?_⟩
  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩
  simp only [inter_comm, ← Set.image_inter h.injOn] at W_disj
  exact W_disj ⟨sW hx, sW hy⟩

Repaired Proof:
theorem IsQuasiSeparated.image_of_embedding {s : Set α} (H : IsQuasiSeparated s) (h : Embedding f) :
    IsQuasiSeparated (f '' s) ∧ ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y := by
  refine ⟨?_, h.injOn⟩
  rintro U ⟨V, V_open, a, rfl⟩
  obtain ⟨W, W_open, sW, W_disj⟩ := H (V ∩ f ⁻¹' U) ⟨V, V_open, a, rfl⟩
  refine ⟨f '' W, W_open.image h.continuous, ⟨a, sW, rfl⟩, ?_⟩
  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩
  simp only [inter_comm, ← Set.image_inter h.injOn] at W_disj
  exact W_disj ⟨sW hx, sW hy⟩

Repaired Proof:
theorem IsQuasiSeparated.image_of_embedding {s : Set α} (H : IsQuasiSeparated s) (h : Embedding f) :
    IsQuasiSeparated (f '' s) ∧ ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y := by
  refine ⟨?_, h.injOn⟩
  rintro U ⟨V, V_open, a, rfl⟩
  obtain ⟨W, W_open, sW, W_disj⟩ := H (V ∩ f ⁻¹' U) ⟨V, V_open, a, rfl⟩
  refine ⟨f '' W, W_open.image h.continuous, ⟨a, sW, rfl⟩, ?_⟩
  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩
  simp only [inter_comm, ← Set.image_inter h.injOn] at W_disj
  exact W_disj ⟨sW hx, sW hy⟩

Repaired Proof:
theorem IsQuasiSeparated.image_of_embedding {s : Set α} (H : IsQuasiSeparated s) (h : Embedding f) :
    IsQuasiSeparated (f '' s) ∧ ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y := by
  refine ⟨?_, h.injOn⟩
  rintro U ⟨V, V_open, a, rfl⟩
  obtain ⟨W, W_open, sW, W_disj⟩ := H (V ∩ f ⁻¹' U) ⟨V, V_open, a, rfl⟩
  refine ⟨f '' W, W_open.image h.continuous, ⟨a, sW, rfl⟩, ?_⟩
  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩
  simp only [inter_comm, ← Set.image_inter h.injOn] at W_disj
  exact W_disj ⟨sW hx, sW hy⟩

Repaired Proof:
theorem IsQuasiSeparated.image_of_embedding {s : Set α} (H : IsQuasiSeparated s) (h : Embedding f) :
    IsQuasiSeparated (f '' s) ∧ ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y := by
  refine ⟨?_, h.injOn⟩
  rintro U ⟨V, V_open, a, rfl⟩
  obtain ⟨W, W_open, sW, W_disj⟩ := H (V ∩ f ⁻¹' U) ⟨V, V_open, a, rfl⟩
  refine ⟨f '' W, W_open.image h.continuous, ⟨a, sW, rfl⟩, ?_⟩
  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩
  simp only [inter_comm, ← Set.image_inter h.injOn] at W_disj
  exact W_disj ⟨sW hx, sW hy⟩

Repaired Proof:
theorem IsQuasiSeparated.image_of_embedding {s : Set α} (H : IsQuasiSeparated s) (h : Embedding f) :
    IsQuasiSeparated (f '' s) ∧ ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y := by
  refine ⟨?_, h.injOn⟩
  rintro U ⟨V, V_open, a, rfl⟩
  obtain ⟨W, W_open, sW, W_disj⟩ := H (V ∩ f ⁻¹' U) ⟨V, V_open, a, rfl⟩
  refine ⟨f '' W, W_open.image h.continuous, ⟨a, sW, rfl⟩, ?_⟩
  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩
  simp only [inter_comm, ← Set.image_inter h.injOn] at W_disj
  exact W_disj ⟨sW hx, sW hy⟩

Repaired Proof:
theorem IsQuasiSeparated.image_of_embedding {s : Set α} (H : IsQuasiSeparated s) (h : Embedding f) :
    IsQuasiSeparated (f '' s) ∧ ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y := by
  refine ⟨?_, h.injOn⟩
  r

Attempt failure.

Working on Mathlib/Topology/Semicontinuous.lean - 2024-09-09 01:22:29.020011.
---195/200---
For theorem LowerSemicontinuousWithinAt.add' in Mathlib/Topology/Semicontinuous.lean:
theorem LowerSemicontinuousWithinAt.add' {f g : α → γ} (hf : LowerSemicontinuousWithinAt f s x)
    (hg : LowerSemicontinuousWithinAt g s x)
    (hcont : ContinuousAt (fun p : γ × γ => p.1 + p.2) (f x, g x)) :
    LowerSemicontinuousWithinAt (fun z => f z + g z) s x 


Original valid proof:
:= by
  intro y hy
  obtain ⟨u, v, u_open, xu, v_open, xv, h⟩ :
    ∃ u v : Set γ,
      IsOpen u ∧ f x ∈ u ∧ IsOpen v ∧ g x ∈ v ∧ u ×ˢ v ⊆ { p : γ × γ | y < p.fst + p.snd } :=
    mem_nhds_prod_iff'.1 (hcont (isOpen_Ioi.mem_nhds hy))
  by_cases hx₁ : ∃ l, l < f x
  · obtain ⟨z₁, z₁lt, h₁⟩ : ∃ z₁ < f x, Ioc z₁ (f x) ⊆ u :=
      exists_Ioc_subset_of_mem_nhds (u_open.mem_nhds xu) hx₁
    by_cases hx₂ : ∃ l, l < g x
    · obtain ⟨z₂, z₂lt, h₂⟩ : ∃ z₂ < g x, Ioc z₂ (g x) ⊆ v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hx₂
      filter_upwards [hf z₁ z₁lt, hg z₂ z₂lt] with z h₁z h₂z
      have A1 : min (f z) (f x) ∈ u := by
        by_cases H : f z ≤ f x
        · simp [H]
          exact h₁ ⟨h₁z, H⟩
        · simp [le_of_not_le H]
          exact h₁ ⟨z₁lt, le_rfl⟩
      have A2 : min (g z) (g x) ∈ v := by
        by_cases H : g z ≤ g x
        · simp [H]
          exact h₂ ⟨h₂z, H⟩
        · simp [le_of_not_le H]
          exact h₂ ⟨z₂lt, le_rfl⟩
      have : (min (f z) (f x), min (g z) (g x)) ∈ u ×ˢ v := ⟨A1, A2⟩
      calc
        y < min (f z) (f x) + min (g z) (g x) := h this
        _ ≤ f z + g z := add_le_add (min_le_left _ _) (min_le_left _ _)

    · simp only [not_exists, not_lt] at hx₂
      filter_upwards [hf z₁ z₁lt] with z h₁z
      have A1 : min (f z) (f x) ∈ u := by
        by_cases H : f z ≤ f x
        · simp [H]
          exact h₁ ⟨h₁z, H⟩
        · simp [le_of_not_le H]
          exact h₁ ⟨z₁lt, le_rfl⟩
      have : (min (f z) (f x), g x) ∈ u ×ˢ v := ⟨A1, xv⟩
      calc
        y < min (f z) (f x) + g x := h this
        _ ≤ f z + g z := add_le_add (min_le_left _ _) (hx₂ (g z))

  · simp only [not_exists, not_lt] at hx₁
    by_cases hx₂ : ∃ l, l < g x
    · obtain ⟨z₂, z₂lt, h₂⟩ : ∃ z₂ < g x, Ioc z₂ (g x) ⊆ v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hx₂
      filter_upwards [hg z₂ z₂lt] with z h₂z
      have A2 : min (g z) (g x) ∈ v := by
        by_cases H : g z ≤ g x
        · simp [H]
          exact h₂ ⟨h₂z, H⟩
        · simp [le_of_not_le H]
          exact h₂ ⟨z₂lt, le_rfl⟩
      have : (f x, min (g z) (g x)) ∈ u ×ˢ v := ⟨xu, A2⟩
      calc
        y < f x + min (g z) (g x) := h this
        _ ≤ f z + g z := add_le_add (hx₁ (f z)) (min_le_left _ _)
    · simp only [not_exists, not_lt] at hx₁ hx₂
      apply Filter.eventually_of_forall
      intro z
      have : (f x, g x) ∈ u ×ˢ v := ⟨xu, xv⟩
      calc
        y < f x + g x := h this
        _ ≤ f z + g z := add_le_add (hx₁ (f z)) (hx₂ (g z))


Verifying proof (Commit 200b13c6bec9232f07d98e431a27afa078e8f986):
 :=
  @ContinuousAt.add' (TopologicalSpace.Order γ) _ _ _ _ _ _ _ hf hg hcont

Repaired Proof:
theorem LowerSemicontinuousWithinAt.add' {f g : α → γ} (hf : LowerSemicontinuousWithinAt f s x)
    (hg : LowerSemicontinuousWithinAt g s x)
    (hcont : ContinuousAt (fun p : γ × γ => p.1 + p.2) (f x, g x)) :
    LowerSemicontinuousWithinAt (fun z => f z + g z) s x :=
  @ContinuousAt.add' (TopologicalSpace.Order γ) _ _ _ _ _ _ _ hf hg hcont

Repaired Proof:
theorem LowerSemicontinuousAt.add {f g : α → γ} (hf : LowerSemicontinuousAt f x)
    (hg : LowerSemicontinuousAt g x) (hcont : ContinuousAt (fun p : γ × γ => p.1 + p.2) (f x, g x)) :
    LowerSemicontinuousAt (fun z => f z + g z) x :=
  @ContinuousAt.add (TopologicalSpace.Order γ) _ _ _ _ _ _ _ hf hg hcont

Repaired Proof:
theorem LowerSemicontinuousAt.add' {f g : α → γ} (hf : LowerSemicontinuousAt f x)
    (hg : LowerSemicontinuousAt g x)
    (hcont : ContinuousAt (fun p : γ × γ => p.1 + p.2) (f x, g x)) :
    LowerSemicontinuousAt (fun z => f z + g z) x :=
  @ContinuousAt.add' (TopologicalSpace.Order γ) _ _ _ _ _ _ _ hf hg hcont

Repaired Proof:
theorem LowerSemicontinuous.add {f g : α → γ} (hf : LowerSemicontinuous f)
    (hg : LowerSemicontinuous g) (hcont : Continuous fun p : γ × γ => p.1 + p.2) :
    LowerSemicontinuous fun z => f z + g z :=
  fun x => (hf x).add' (hg x) <| hcont.continuousAt

Repaired Proof:
theorem LowerSemicontinuous.add' {f g : α → γ} (hf : LowerSemicontinuous f)
    (hg : LowerSemicontinuous g)
    (hcont : Continuous fun p : γ × γ => p.1 + p.2) :
    LowerSemicontinuous fun z => f z + g z :=
  fun x => (hf x).add (hg x) <| hcont.continuousAt

Repaired Proof:
theorem LowerSemicontinuousOn.add {f g : α → γ} (hf : LowerSemicontinuousOn f s)
    (hg : LowerSemicontinuousOn g s)
    (hcont : ContinuousOn (fun p : γ × γ => p.1 + p.2) (f '' s ×ˢ g '' s)) :
    LowerSemicontinuousOn (fun z => f z + g z) s := fun x hx =>
  (hf x hx).add' (hg x hx) <| hcont.continuousAt (mk_mem_prod (hf x hx).isClosed_le_closure
    <| (hg x hx).closure_le_isClosed)

Repaired Proof:
theorem LowerSemicontinuousOn.add' {f g : α → γ} (hf : LowerSemicontinuousOn f s)
    (hg : LowerSemicontinuousOn g s)
    (hcont : ContinuousOn (fun p : γ × γ => p.1 + p.2) (f '' s ×ˢ g '' s)) :
    LowerSemicontinuousOn (fun z => f z + g z) s := fun x hx =>
  (hf x hx).add (hg x hx) <| hcont.continuousAt (mk_mem_prod (hf x hx).closure_le_isClosed
    <| (hg x hx).isClosed_le_closure)

Repaired Proof:
theorem LowerSemicontinuous.add_const {f : α → γ} (hf : LowerSemicontinuous f) (c : γ) :
    LowerSemicontinuous fun z => f z + c := fun x => (hf x).add_const c

Repaired Proof:
theorem LowerSemicontinuous.const_add {f : α → γ} (hf : LowerSemicontinuous f) (c : γ) :
    LowerSemicontinuous fun z => c + f z := fun x => (hf x).const_add c

Repaired Proof:
theorem LowerSemicontinuousOn.add_const {f : α → γ} (hf : LowerSemicontinuousOn f s) (c : γ) :
    LowerSemicontinuousOn (fun z => f z + c) s := fun x hx => (hf x hx).add_const c

Repaired Proof:
theorem LowerSemicontinuousOn.const_add {f : α → γ} (hf : LowerSemicontinuousOn f s) (c : γ) :
    LowerSemicontinuousOn (fun z => c + f z) s := fun x hx => (hf x hx).const_add c

Repaired Proof:
theorem LowerSemicontinuous.add_const' {f : α → γ} (hf : LowerSemicontinuous f) (c : γ) :
    LowerSemicontinuous fun z => f z + c :=
  hf.add_const c

Repaired Proof:
theorem LowerSemicontinuous.const_add' {f : α → γ} (hf : LowerSemicontinuous f) (c : γ) :
    LowerSemicontinuous fun z => c + f z :=
  hf.const_add c

Repaired Proof:
theorem LowerSemicontinuousOn.add_const' {f : α → γ} (hf : LowerSemicontinuousOn f s) (c : γ) :
    LowerSemicontinuousOn (fun z => f z + c) s :=
  hf.add_const c

Repaired Proof:
theorem LowerSemicontinuousOn.const_add' {f : α → γ} (hf : LowerSemicontinuousOn f s) (c : γ) :
    LowerSemicontinuousOn (fun z => c + f z) s :=
  hf.const_add c

Repaired Proof:
theorem LowerSemicontinuous.add_const {f : α → γ} (hf : LowerSemicontinuous f) (c : γ) :
    LowerSemicontinuous fun z => f z + c :=
  hf.add_const' c

Repaired Proof:
theorem LowerSemicontinuous.const_add {f : α → γ} (hf : LowerSemicontinuous f) (c : γ) :
    LowerSemicontinuous fun z => c + f z :=
  hf.const_add' c

Repaired Proof:
theorem LowerSemicontinuousOn.add_const {f : α → γ} (hf : LowerSemicontinuousOn f s) (c : γ) :
    LowerSemicontinuousOn (fun z => f z + c) s :=
  hf.add_const' c

Repaired Proof:
theorem LowerSemicontinuousOn.const_add {f : α → γ} (hf : LowerSemicontinuousOn f s) (c : γ) :
    LowerSemicontinuousOn (fun z => c + f z) s :=
  hf.const_add' c

Repaired Proof:
theorem LowerSemicontinuous.add_const' {f : α → γ} (hf : LowerSemicontinuous f) (c : γ) :
    LowerSemicontinuous fun z => f z + c :=
  hf.add_const c

Repaired Proof:
theorem LowerSemicontinuous.const_add' {f : α → γ} (hf : LowerSemicontinuous f) (c : γ) :
    LowerSemicontinuous fun z => c + f z :=
  hf.const_add c

Repaired Proof:
theorem LowerSemicontinuousOn.add_const' {f : α → γ} (hf : LowerSemicontinuousOn f s) (c : γ) :
    LowerSemicontinuousOn (fun z => f z + c) s :=
  hf.add_const c

Repaired Proof:
theorem LowerSemicontinuousOn.const_add' {f : α → γ} (hf : LowerSemicontinuousOn f s) (c : γ) :
    LowerSemicontinuousOn (fun z => c + f z) s :=
  hf.const_add c

Repaired Proof:
theorem LowerSemicontinuous.add_const {f : α → γ} (hf : LowerSemicontinuous f) (c : γ) :
    LowerSemicontinuous fun z => f z + c :=
  hf.add_const

Attempt failure.

Working on Mathlib/Topology/Separation/NotNormal.lean - 2024-09-09 01:22:44.527600.
---196/200---
For theorem IsClosed.mk_lt_continuum in Mathlib/Topology/Separation/NotNormal.lean:
theorem IsClosed.mk_lt_continuum [NormalSpace X] {s : Set X} (hs : IsClosed s)
    [DiscreteTopology s] : #s < 𝔠 


Original valid proof:
:= by
  by_contra! h
  rcases exists_countable_dense X with ⟨t, htc, htd⟩
  haveI := htc.to_subtype
  refine (Cardinal.cantor 𝔠).not_le ?_
  calc
    2 ^ 𝔠 ≤ #C(s, ℝ) := by
      rw [(ContinuousMap.equivFnOfDiscrete _ _).cardinal_eq, mk_arrow, mk_real, lift_continuum,
        lift_uzero]
      exact (power_le_power_left two_ne_zero h).trans (power_le_power_right (nat_lt_continuum 2).le)
    _ ≤ #C(X, ℝ) := by
      choose f hf using ContinuousMap.exists_restrict_eq (Y := ℝ) hs
      have hfi : Injective f := LeftInverse.injective hf
      exact mk_le_of_injective hfi
    _ ≤ #C(t, ℝ) := mk_le_of_injective <| ContinuousMap.injective_restrict htd
    _ ≤ #(t → ℝ) := mk_le_of_injective DFunLike.coe_injective
    _ ≤ 𝔠 := by
      rw [mk_arrow, mk_real, lift_uzero, lift_continuum, continuum, ← power_mul]
      exact power_le_power_left two_ne_zero mk_le_aleph0


Verifying proof (Commit 161c69c1dbf66cf3c7ec4f648a61551d044a43e4):
↔ ∃ t : Set X, IsClosed t ∧ s ⊆ t ∧ #t < 𝔠 := by
  refine ⟨fun h ↦ ?_, ?_⟩
  · obtain ⟨t, htc, hst, ht⟩ := exists_subset_isClosed_lt_continuum h
    exact ⟨t, htc, hst, ht⟩
  rintro ⟨t, htc, hst, ht⟩
  have : s ⊆ t ∩ s := fun x hx ↦ ⟨hst hx, hx⟩
  have htc' : IsClosed (t ∩ s) := IsClosed.inter htc hs
  have htc'' : #(t ∩ s) ≤ 𝔠 := le_continuum
  refine lt_of_lt_of_le ?_ htc''
  have : t ∩ s ⊆ t := inter_subset_left t s
  have : #(t ∩ s) ≤ #t := mk_le_of_subset this
  rwa [ht.le_mk_iff_add_le, zero_add] at this

Repaired Proof:
theorem IsClosed.mk_lt_continuum [NormalSpace X] {s : Set X} (hs : IsClosed s)
    [DiscreteTopology s] : #s < 𝔠 ↔ ∃ t : Set X, IsClosed t ∧ s ⊆ t ∧ #t < 𝔠 := by
  refine ⟨fun h ↦ ?_, ?_⟩
  · obtain ⟨t, htc, hst, ht⟩ := exists_subset_isClosed_lt_continuum h
    exact ⟨t, htc, hst, ht⟩
  rintro ⟨t, htc, hst, ht⟩
  have : s ⊆ t ∩ s := fun x hx ↦ ⟨hst hx, hx⟩
  have htc' : IsClosed (t ∩ s) := IsClosed.inter htc hs
  have htc'' : #(t ∩ s) ≤ 𝔠 := le_continuum
  refine lt_of_lt_of_le ?_ htc''
  have : t ∩ s ⊆ t := inter_subset_left t s
  have : #(t ∩ s) ≤ #t := mk_le_of_subset this
  rwa [ht.le_mk_iff_add_le, zero_add] at this

Repaired Proof:
theorem IsClosed.mk_lt_continuum [NormalSpace X] {s : Set X} (hs : IsClosed s)
    [DiscreteTopology s] : #s < 𝔠 ↔ ∃ t : Set X, IsClosed t ∧ s ⊆ t ∧ #t < 𝔠 := by
  refine ⟨fun h ↦ ?_, ?_⟩
  · obtain ⟨t, htc, hst, ht⟩ := exists_subset_isClosed_lt_continuum h
    exact ⟨t, htc, hst, ht⟩
  rintro ⟨t, htc, hst, ht⟩
  have : s ⊆ t ∩ s := fun x hx ↦ ⟨hst hx, hx⟩
  have htc' : IsClosed (t ∩ s) := IsClosed.inter htc hs
  have htc'' : #(t ∩ s) ≤ 𝔠 := le_continuum
  refine lt_of_lt_of_le ?_ htc''
  have : t ∩ s ⊆ t := inter_subset_left t s
  have : #(t ∩ s) ≤ #t := mk_le_of_subset this
  rwa [ht.le_mk_iff_add_le, zero_add] at this

Repaired Proof:
theorem IsClosed.mk_lt_continuum [NormalSpace X] {s : Set X} (hs : IsClosed s)
    [DiscreteTopology s] : #s < 𝔠 ↔ ∃ t : Set X, IsClosed t ∧ s ⊆ t ∧ #t < 𝔠 := by
  refine ⟨fun h ↦ ?_, ?_⟩
  · obtain ⟨t, htc, hst, ht⟩ := exists_subset_isClosed_lt_continuum h
    exact ⟨t, htc, hst, ht⟩
  rintro ⟨t, htc, hst, ht⟩
  have : s ⊆ t ∩ s := fun x hx ↦ ⟨hst hx, hx⟩
  have htc' : IsClosed (t ∩ s) := IsClosed.inter htc hs
  have htc'' : #(t ∩ s) ≤ 𝔠 := le_continuum
  refine lt_of_lt_of_le ?_ htc''
  have : t ∩ s ⊆ t := inter_subset_left t s
  have : #(t ∩ s) ≤ #t := mk_le_of_subset this
  rwa [ht.le_mk_iff_add_le, zero_add] at this

Repaired Proof:
theorem IsClosed.mk_lt_continuum [NormalSpace X] {s : Set X} (hs : IsClosed s)
    [DiscreteTopology s] : #s < 𝔠 ↔ ∃ t : Set X, IsClosed t ∧ s ⊆ t ∧ #t < 𝔠 := by
  refine ⟨fun h ↦ ?_, ?_⟩
  · obtain ⟨t, htc, hst, ht⟩ := exists_subset_isClosed_lt_continuum h
    exact ⟨t, htc, hst, ht⟩
  rintro ⟨t, htc, hst, ht⟩
  have : s ⊆ t ∩ s := fun x hx ↦ ⟨hst hx, hx⟩
  have htc' : IsClosed (t ∩ s) := IsClosed.inter htc hs
  have htc'' : #(t ∩ s) ≤ 𝔠 := le_continuum
  refine lt_of_lt_of_le ?_ htc''
  have : t ∩ s ⊆ t := inter_subset_left t s
  have : #(t ∩ s) ≤ #t := mk_le_of_subset this
  rwa [ht.le_mk_iff_add_le, zero_add] at this

Repaired Proof:
theorem IsClosed.mk_lt_continuum [NormalSpace X] {s : Set X} (hs : IsClosed s)
    [DiscreteTopology s] : #s < 𝔠 ↔ ∃ t : Set X, IsClosed t ∧ s ⊆ t ∧ #t < 𝔠 := by
  refine ⟨fun h ↦ ?_, ?_⟩
  · obtain ⟨t, htc, hst, ht⟩ := exists_subset_isClosed_lt_continuum h
    exact ⟨t, htc, hst, ht⟩
  rintro ⟨t, htc, hst, ht⟩
  have : s ⊆ t ∩ s := fun x hx ↦ ⟨hst hx, hx⟩
  have htc' : IsClosed (t ∩ s) := IsClosed.inter htc hs
  have htc'' : #(t ∩ s) ≤ 𝔠 := le_continuum
  refine lt_of_lt_of_le ?_ htc''
  have : t ∩ s ⊆ t := inter_subset_left t s
  have : #(t ∩ s) ≤ #t := mk_le_of_subset this
  rwa [ht.le_mk_iff_add_le, zero_add] at this

Repaired Proof:
theorem IsClosed.mk_lt_continuum [NormalSpace X] {s : Set X} (hs : IsClosed s)
    [DiscreteTopology s] : #s < 𝔠 ↔ ∃ t : Set X, IsClosed t ∧ s ⊆ t ∧ #t < 𝔠 := by
  refine ⟨fun h ↦ ?_, ?_⟩
  · obtain ⟨t, htc, hst, ht�

Attempt failure.

Working on Mathlib/Topology/Support.lean - 2024-09-09 01:22:55.629938.
---197/200---
For theorem LocallyFinite.exists_finset_nhd_mulSupport_subset in Mathlib/Topology/Support.lean:
theorem LocallyFinite.exists_finset_nhd_mulSupport_subset {U : ι → Set X} [One R] {f : ι → X → R}
    (hlf : LocallyFinite fun i => mulSupport (f i)) (hso : ∀ i, mulTSupport (f i) ⊆ U i)
    (ho : ∀ i, IsOpen (U i)) (x : X) :
    ∃ (is : Finset ι), ∃ n, n ∈ 𝓝 x ∧ (n ⊆ ⋂ i ∈ is, U i) ∧
      ∀ z ∈ n, (mulSupport fun i => f i z) ⊆ is 


Original valid proof:
:= by
  obtain ⟨n, hn, hnf⟩ := hlf x
  classical
    let is := hnf.toFinset.filter fun i => x ∈ U i
    let js := hnf.toFinset.filter fun j => x ∉ U j
    refine
      ⟨is, (n ∩ ⋂ j ∈ js, (mulTSupport (f j))ᶜ) ∩ ⋂ i ∈ is, U i, inter_mem (inter_mem hn ?_) ?_,
        inter_subset_right, fun z hz => ?_⟩
    · exact (biInter_finset_mem js).mpr fun j hj => IsClosed.compl_mem_nhds (isClosed_mulTSupport _)
        (Set.not_mem_subset (hso j) (Finset.mem_filter.mp hj).2)
    · exact (biInter_finset_mem is).mpr fun i hi => (ho i).mem_nhds (Finset.mem_filter.mp hi).2
    · have hzn : z ∈ n := by
        rw [inter_assoc] at hz
        exact mem_of_mem_inter_left hz
      replace hz := mem_of_mem_inter_right (mem_of_mem_inter_left hz)
      simp only [js, Finset.mem_filter, Finite.mem_toFinset, mem_setOf_eq, mem_iInter,
        and_imp] at hz
      suffices (mulSupport fun i => f i z) ⊆ hnf.toFinset by
        refine hnf.toFinset.subset_coe_filter_of_subset_forall _ this fun i hi => ?_
        specialize hz i ⟨z, ⟨hi, hzn⟩⟩
        contrapose hz
        simp [hz, subset_mulTSupport (f i) hi]
      intro i hi
      simp only [Finite.coe_toFinset, mem_setOf_eq]
      exact ⟨z, ⟨hi, hzn⟩⟩


Verifying proof (Commit 6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92):
∧ (mulSupport fun i => f i z) ⊆ Finset.univ := by
  rcases hlf x with ⟨q, hq, hqf⟩
  rcases compact_compact_separated (isCompact_singleton : IsCompact {x})
      (isCompact_bUnion_finset hqf fun i _ => isCompact_mulTSupport (f i))
      (disjoint_singleton_left.2 <| not_mem_mulSupport.mpr <| not_mem_mulTSupport _)
      (disjoint_iUnion_right.2 fun i _ => disjoint_mulTSupport _) with
    ⟨s, hqs, hsc, hxs, hscq⟩
  refine' ⟨q ∩ s, _, _, _, _⟩
  · simpa only [and_imp, (· ∘ ·), mem_iUnion, exists_imp, mem_inter_iff, mem_singleton_iff]
  · exact inter_mem_nhdsWithin _ (ho _).mem_nhds (hqs _ <| mem_singleton_self _)
  · rintro z ⟨hz₁, hz₂⟩ i hi
    refine' ⟨Finset.mem_iInter₂.mpr fun j hj => hso j _ fun w hw => hscq _ _ _ ⟨w, _, _⟩,
      Finset.mem_univ _⟩
    · exact hqf _ hi _ hw
    · exact mem_bUnion hi hw
    · exact mem_inter hz₂ (hqs _ hj)
  · rintro z ⟨hz₁, hz₂⟩ i hi
    refine' ⟨Finset.mem_iInter₂.mpr fun j hj => hso j _ fun w hw => hscq _ _ _ ⟨w, _, _⟩,
      Finset.mem_univ _⟩
    · exact hqf _ hi _ hw
    · exact mem_bUnion hi hw
    · exact mem_inter hz₂ (hqs _ hj)

Repaired Proof:
theorem LocallyFinite.exists_finset_nhd_mulSupport_subset {U : ι → Set X} [One R] {f : ι → X → R}
    (hlf : LocallyFinite fun i => mulSupport (f i)) (hso : ∀ i, mulTSupport (f i) ⊆ U i)
    (ho : ∀ i, IsOpen (U i)) (x : X) :
    ∃ (is : Finset ι), ∃ n, n ∈ 𝓝 x ∧ (n ⊆ ⋂ i ∈ is, U i) ∧
      ∀ z ∈ n, (mulSupport fun i => f i z) ⊆ is ∧ (mulSupport fun i => f i z) ⊆ Finset.univ := by
  rcases hlf x with ⟨q, hq, hqf⟩
  rcases compact_compact_separated isCompact_singleton
      (isCompact_bUnion_finset hqf fun i _ => isCompact_mulTSupport (f i))
      (disjoint_singleton_left.2 <| not_mem_mulSupport.mpr <| not_mem_mulTSupport _)
      (disjoint_iUnion_right.2 fun i _ => disjoint_mulTSupport _) with
    ⟨s, hqs, hsc, hxs, hscq⟩
  refine ⟨q ∩ s, ?_, ?_, ?_, ?_⟩
  · simpa only [and_imp, (· ∘ ·), mem_iUnion, exists_imp, mem_inter_iff, mem_singleton_iff]
  · exact inter_mem_nhdsWithin _ (ho _).mem_nhds (hqs _ <| mem_singleton_self _)
  · rintro z ⟨hz₁, hz₂⟩ i hi
    refine ⟨Finset.mem_iInter₂.mpr fun j hj => hso j _ fun w hw => hscq _ _ _ ⟨w, _, ?_⟩,
      Finset.mem_univ _⟩
    · exact hqf _ hi _ hw
    · exact mem_bUnion hi hw
    · exact mem_inter hz₂ (hqs _ hj)
  · rintro z ⟨hz₁, hz₂⟩ i hi
    refine ⟨Finset.mem_iInter₂.mpr fun j hj => hso j _ fun w hw => hscq _ _ _ ⟨w, _, ?_⟩,
      Finset.mem_univ _⟩
    · exact hqf _ hi _ hw
    · exact mem_bUnion hi hw
    · exact mem_inter hz₂ (hqs _ hj)

Repaired Proof:
theorem LocallyFinite.exists_finset_nhd_mulSupport_subset {U : ι → Set X} [One R] {f : ι → X → R}
    (hlf : LocallyFinite fun i => mulSupport (f i)) (hso : ∀ i, mulTSupport (f i) ⊆ U i)
    (ho : ∀ i, IsOpen (U i)) (x : X) :
    ∃ (is : Finset ι), ∃ n, n ∈ 𝓝 x ∧ (n ⊆ ⋂ i ∈ is, U i) ∧
      ∀ z ∈ n, (mulSupport fun i => f i z) ⊆ is ∧ (mulSupport fun i => f i z) ⊆ Finset.univ := by
  rcases hlf x with ⟨q, hq, hqf⟩
  rcases compact_compact_separated isCompact_singleton
      (isCompact_bUnion_finset hqf fun i _ => isCompact_mulTSupport (f i))
      (disjoint_singleton_left.2 <| not_mem_mulSupport.mpr <| not_mem_mulTSupport _)
      (disjoint_iUnion_right.2 fun i _ => disjoint_mulTSupport _) with
    ⟨s, hqs, hsc, hxs, hscq⟩
  refine ⟨q ∩ s, ?_, ?_, ?_, ?_⟩
  · simpa only [and_imp, (· ∘ ·), mem_iUnion, exists_imp, mem_inter_iff, mem_singleton_iff]
  · exact inter_mem_nhdsWithin _ (ho _).mem_nhds (hqs _ <| mem_singleton_self _)
  · rintro z ⟨hz₁, hz₂⟩ i hi
    refine ⟨Finset.mem_iInter₂.mpr fun j hj => hso j _ fun w hw => hscq _ _ _ ⟨w, _, ?_⟩,
      Finset.mem_univ _⟩
    · exact hqf _ hi _ hw
    · exact mem_bUnion hi hw
    · exact mem_inter hz₂ (hqs _ hj)
  · rintro z ⟨hz₁, hz₂⟩ i hi
    refine ⟨Finset.mem_iInter₂.mpr fun j hj => hso j _ fun w hw => hscq _ _ _ ⟨w, _, ?_⟩,
      Finset.mem_univ _⟩
    · exact hqf _ hi _ hw
    · exact mem_bUnion hi hw
    · exact mem_inter hz₂ (hqs _ hj)

Repaired Proof:
theorem LocallyFinite.exists_finset_nhd_mulSupport_subset {U : ι → Set X} [One R] {f : ι → X → R}
    (hlf : LocallyFinite fun i => mulSupport (f i)) (hso : ∀ i, mulTSupport (f i) ⊆ U i)
    (ho : ∀ i, IsOpen (U i)) (x : X) :
    ∃ (is : Finset ι), ∃ n, n ∈ 𝓝 x ∧ (n ⊆ ⋂ i ∈ is, U i) ∧
      ∀ z ∈ n, (mulSupport fun i => f i z) ⊆ is ∧ (mulSupport fun i => f i z) ⊆ Finset.univ := by
  rcases hlf x with ⟨q, hq, hqf⟩
  rcases compact_compact_separated isCompact_singleton
      (isCompact_bUnion_finset hqf fun i _ => isCompact_mulTSupport

Attempt failure.

Working on Mathlib/Topology/UniformSpace/Basic.lean - 2024-09-09 01:23:04.417010.
---198/200---
For theorem ball_inter_left in Mathlib/Topology/UniformSpace/Basic.lean:
theorem ball_inter_left (x : β) (V W : Set (β × β)) : ball x (V ∩ W) ⊆ ball x V 


Original valid proof:
:=
  ball_mono inter_subset_left x


Verifying proof (Commit f33a8c19a1c116af0ea9bb6af0c85b1ef25cb15f):
∩ ball x W :=
  fun _y hy => ⟨hy.1, hy.2⟩


theorem ball_inter_right (x : β) (V W : Set (β × β)) : ball x (V ∩ W) ⊆ ball x W :=
  (ball_mono inter_subset_right x).trans inter_subset_right


theorem ball_inter_left_of_mem {x y : β} {V W : Set (β × β)} (h : y ∈ ball x V) :
    ball y (V ∩ W) ⊆ ball x V :=
  ball_mono <| inter_subset_left _ _


theorem ball_inter_right_of_mem {x y : β} {V W : Set (β × β)} (h : y ∈ ball x W) :
    ball y (V ∩ W) ⊆ ball x W :=
  ball_mono <| inter_subset_right _ _


theorem ball_inter_left_of_mem_right {x : β} {V W : Set (β × β)} (h : x ∈ W) :
    ball x (V ∩ W) ⊆ ball x V :=
  ball_mono <| inter_subset_left _ _


theorem ball_inter_right_of_mem_right {x : β} {V W : Set (β × β)} (h : x ∈ W) :
    ball x (V ∩ W) ⊆ ball x W :=
  ball_mono <| inter_subset_right _ _


theorem ball_inter_left_of_le_card [Fintype β] {x : β} {V W : Set (β × β)}
    (h : Fintype.card V ≤ Fintype.card (V ∩ W)) : ball x (V ∩ W) ⊆ ball x V := by
  intro y hy
  simp only [mem_ball_symmetry, mem_preimage, mem_inter_iff] at hy ⊢
  contrapose! hy
  exact (Fintype.card_le_card <| ball_inter_left_of_mem_right <| hy.2).trans_lt h


theorem ball_inter_right_of_le_card [Fintype β] {x : β} {V W : Set (β × β)}
    (h : Fintype.card V ≤ Fintype.card (V ∩ W)) : ball x (V ∩ W) ⊆ ball x W := by
  intro y hy
  simp only [mem_ball_symmetry, mem_preimage, mem_inter_iff] at hy ⊢
  contrapose! hy
  exact (Fintype.card_le_card <| ball_inter_right_of_mem_right <| hy.2).trans_lt h


theorem ball_inter_of_le_card [Fintype β] {x : β} {V W : Set (β × β)}
    (h : Fintype.card V ≤ Fintype.card (V ∩ W)) : ball x (V ∩ W) = ball x V ∩ ball x W :=
  Subset.antisymm (ball_inter_subset _ _ _) <| inter_subset_inter (ball_inter_left_of_le_card h)
    (ball_inter_right_of_le_card h)


theorem ball_inter_of_card_le [Fintype β] {x : β} {V W : Set (β × β)}
    (h : Fintype.card (V ∩ W) ≤ Fintype.card W) : ball x (V ∩ W) = ball x V ∩ ball x W :=
  ball_inter_of_le_card <| h.trans <| Fintype.card_le_of_subset <| inter_subset_right _ _


theorem ball_inter_eq_inter_ball_of_mem_right [DecidableEq β] {x y : β} {V W : Set (β × β)}
    (h : x ∈ W) : ball x (V ∩ W) = ball x V ∩ W := by
  ext z
  simp only [mem_inter_iff, mem_ball_symmetry, mem_preimage, and_assoc]
  apply and_congr_right'
  simp only [h, and_iff_left_iff_imp, Prod.mk.inj_iff]
  rintro rfl
  rfl


theorem ball_inter_eq_inter_ball_of_mem_left [DecidableEq β] {x y : β} {V W : Set (β × β)}
    (h : y ∈ W) : ball x (V ∩ W) = ball x V ∩ W := by
  rw [inter_comm, ball_inter_eq_inter_ball_of_mem_right h, inter_comm]


theorem ball_inter_eq_inter_ball_of_le_card [Fintype β] {x y : β} {V W : Set (β × β)}
    (h : Fintype.card W ≤ Fintype.card (V ∩ W)) :
    ball x (V ∩ W) = ball x V ∩ ball y W := by
  apply Subset.antisymm
  · exact ball_inter_subset _ _ _
  intro z ⟨hzV, hzW⟩
  simp only [mem_ball_symmetry, mem_preimage] at hzV hzW ⊢
  contrapose! hzW
  have : Fintype.card (V ∩ W) < Fintype.card W := by
    rw [← inter_eq_right.mpr hzW]
    exact Fintype.card_lt_card (inter_ssubset.mpr ⟨y, hzW, hzV⟩)
  exact not_le.mpr this h


theorem ball_inter_eq_inter_ball_of_le_card' [Fintype β] {x y : β} {V W : Set (β × β)}
    (h : Fintype.card W ≤ Fintype.card (V ∩ W)) :
    ball x (V ∩ W) = ball x V ∩ ball y W := by
  rw [inter_comm, ball_inter_eq_inter_ball_of_le_card h, inter_comm]


theorem ball_inter_eq_inter_ball_of_le_card_left [Fintype β] {x y : β} {V W : Set (β × β)}
    (h : Fintype.card V ≤ Fintype.card (V ∩ W)) :
    ball x (V ∩ W) = ball x V ∩ ball y W := by
  apply ball_inter_eq_inter_ball_of_le_card
  rw [inter_comm]
  exact h.trans tsub_le_iff_right.mp (tsub_le_tsub_right (card_le_card inter_subset_right) _)


theorem ball_inter_eq_inter_ball_of_le_card_right [Fintype β] {x y : β} {V W : Set (β × β)}
    (h : Fintype.card W ≤ Fintype.card (V ∩ W)) :
    ball x (V ∩ W) = ball x V ∩ ball y W := by
  rw [inter_comm, ball_inter_eq_inter_ball_of_le_card_left h, inter_comm]


theorem ball_inter_eq_inter_ball_of_le_card_left' [Fintype β] {x y : β} {V W : Set (β × β)}
    (h : Fintype.card V ≤ Fintype.card (V ∩ W)) :
    ball x (V ∩ W) = ball x V ∩ ball y W := by
  apply ball_inter_eq_inter_ball_of_le_card_left
  rw [inter_comm]
  exact h.trans tsub_le_iff_right.mp (tsub_le_tsub_right (card_le_card inter_subset_right) _)


theorem ball_inter_eq_inter_ball_of_le_card_right' [Fintype β] {x y : β} {V W : Set (β × β)}
    (h : Fintype.card W ≤ Fintype.card (V ∩ W)) :
    ball x (V ∩ W) = ball x V ∩ ball y W := by
  rw [inter_comm, ball_inter_eq_inter_ball_of_le_card_right h, inter_comm]


theorem ball_inter_eq_inter_ball_of_le_card_left'' [Fintype β] {x y :

Attempt failure.

Working on Mathlib/Topology/UniformSpace/UniformConvergence.lean - 2024-09-09 01:23:19.719094.
---199/200---
For theorem UniformCauchySeqOn.prod in Mathlib/Topology/UniformSpace/UniformConvergence.lean:
theorem UniformCauchySeqOn.prod_map {ι' α' β' : Type*} [UniformSpace β'] {F' : ι' → α' → β'}
    {p' : Filter ι'} {s' : Set α'} (h : UniformCauchySeqOn F p s)
    (h' : UniformCauchySeqOn F' p' s') :
    UniformCauchySeqOn (fun i : ι × ι' => Prod.map (F i.1) (F' i.2)) (p ×ˢ p') (s ×ˢ s') 


Original valid proof:
:= by
  intro u hu
  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu
  obtain ⟨v, hv, w, hw, hvw⟩ := hu
  simp_rw [mem_prod, and_imp, Prod.forall, Prod.map_apply]
  rw [← Set.image_subset_iff] at hvw
  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono
  intro x hx a b ha hb
  exact hvw ⟨_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 := by
  rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at h h' ⊢
  exact h.prod_map h'

Repaired Proof:
theorem UniformCauchySeqOn.prod_map {ι' α' β' : Type*} [UniformSpace β'] {F' : ι' → α' → β'}
    {p' : Filter ι'} {s' : Set α'} (h : UniformCauchySeqOn F p s)
    (h' : UniformCauchySeqOn F' p' s') :
    UniformCauchySeqOn (fun i : ι × ι' => Prod.map (F i.1) (F' i.2)) (p ×ˢ p') (s ×ˢ s') := by
  rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at h h' ⊢
  exact h.prod_map h'

Repaired Proof:
theorem UniformCauchySeqOn.prod_map {ι' α' β' : Type*} [UniformSpace β'] {F' : ι' → α' → β'}
    {p' : Filter ι'} {s' : Set α'} (h : UniformCauchySeqOn F p s)
    (h' : UniformCauchySeqOn F' p' s') :
    UniformCauchySeqOn (fun i : ι × ι' => Prod.map (F i.1) (F' i.2)) (p ×ˢ p') (s ×ˢ s') := by
  rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at h h' ⊢
  exact h.prod_map h'

Repaired Proof:
theorem UniformCauchySeqOn.prod_map {ι' α' β' : Type*} [UniformSpace β'] {F' : ι' → α' → β'}
    {p' : Filter ι'} {s' : Set α'} (h : UniformCauchySeqOn F p s)
    (h' : UniformCauchySeqOn F' p' s') :
    UniformCauchySeqOn (fun i : ι × ι' => Prod.map (F i.1) (F' i.2)) (p ×ˢ p') (s ×ˢ s') := by
  rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at h h' ⊢
  exact h.prod_map h'

Attempt failure.

Working on Mathlib/Topology/UniformSpace/UniformEmbedding.lean - 2024-09-09 01:23:30.272547.
---200/200---
For theorem uniformEmbedding_inl in Mathlib/Topology/UniformSpace/UniformEmbedding.lean:
theorem uniformEmbedding_inl : UniformEmbedding (Sum.inl : α → α ⊕ β) 


Original valid proof:
:=
  uniformEmbedding_iff'.2 ⟨Sum.inl_injective, uniformContinuous_inl, fun s hs =>
    ⟨Prod.map Sum.inl Sum.inl '' s ∪ range (Prod.map Sum.inr Sum.inr),
      union_mem_sup (image_mem_map hs) range_mem_map,
      fun x h => by simpa [Prod.map_apply'] using h⟩⟩


Verifying proof (Commit 2ba547a6481ef513d87a606a16c441262be9e648):
↔ Nonempty β := by
  constructor
  · rintro ⟨_, h₁, h₂⟩
    rw [range_inl, Sum.uniformity, comap_const] at h₁
    simp only [filter_eq_bot_of_bot_le, le_bot_iff, comap_const] at h₁
    haveI : Nonempty (α ⊕ β) := (range_nonempty _).to_subtype
    rw [← not_nonempty_iff_imp_false, ← not_nonempty_iff_imp_false] at h₁
    simp [h₁]
  · rintro ⟨b⟩
    refine ⟨(continuous_inl.tendsto _).uniformContinuous, ?_⟩
    rw [range_inl]
    exact uniformContinuous_comap

Repaired Proof:
theorem uniformEmbedding_inl : UniformEmbedding (Sum.inl : α → α ⊕ β) ↔ Nonempty β := by
  constructor
  · rintro ⟨_, h₁, h₂⟩
    rw [range_inl, Sum.uniformity, comap_const] at h₁
    simp only [filter_eq_bot_of_bot_le, le_bot_iff, comap_const] at h₁
    haveI : Nonempty (α ⊕ β) := (range_nonempty _).to_subtype
    rw [← not_nonempty_iff_imp_false, ← not_nonempty_iff_imp_false] at h₁
    simp [h₁]
  · rintro ⟨b⟩
    refine ⟨(continuous_inl.tendsto _).uniformContinuous, ?_⟩
    rw [range_inl]
    exact uniformContinuous_comap

Repaired Proof:
theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : β → α ⊕ β) ↔ Nonempty α := by
  constructor
  · rintro ⟨_, h₁, h₂⟩
    rw [range_inr, Sum.uniformity, comap_const] at h₁
    simp only [filter_eq_bot_of_bot_le, le_bot_iff, comap_const] at h₁
    haveI : Nonempty (α ⊕ β) := (range_nonempty _).to_subtype
    rw [← not_nonempty_iff_imp_false, ← not_nonempty_iff_imp_false] at h₁
    simp [h₁]
  · rintro ⟨a⟩
    refine ⟨(continuous_inr.tendsto _).uniformContinuous, ?_⟩
    rw [range_inr]
    exact uniformContinuous_comap

Repaired Proof:
theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : β → α ⊕ β) ↔ Nonempty α := by
  constructor
  · rintro ⟨_, h₁, h₂⟩
    rw [range_inr, Sum.uniformity, comap_const] at h₁
    simp only [filter_eq_bot_of_bot_le, le_bot_iff, comap_const] at h₁
    haveI : Nonempty (α ⊕ β) := (range_nonempty _).to_subtype
    rw [← not_nonempty_iff_imp_false, ← not_nonempty_iff_imp_false] at h₁
    simp [h₁]
  · rintro ⟨a⟩
    refine ⟨(continuous_inr.tendsto _).uniformContinuous, ?_⟩
    rw [range_inr]
    exact uniformContinuous_comap

Repaired Proof:
theorem uniformEmbedding_inl : UniformEmbedding (Sum.inl : α → α ⊕ β) ↔ Nonempty β := by
  constructor
  · rintro ⟨_, h₁, h₂⟩
    rw [range_inl, Sum.uniformity, comap_const] at h₁
    simp only [filter_eq_bot_of_bot_le, le_bot_iff, comap_const] at h₁
    haveI : Nonempty (α ⊕ β) := (range_nonempty _).to_subtype
    rw [← not_nonempty_iff_imp_false, ← not_nonempty_iff_imp_false] at h₁
    simp [h₁]
  · rintro ⟨b⟩
    refine ⟨(continuous_inl.tendsto _).uniformContinuous, ?_⟩
    rw [range_inl]
    exact uniformContinuous_comap

Repaired Proof:
theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : β → α ⊕ β) ↔ Nonempty α := by
  constructor
  · rintro ⟨_, h₁, h₂⟩
    rw [range_inr, Sum.uniformity, comap_const] at h₁
    simp only [filter_eq_bot_of_bot_le, le_bot_iff, comap_const] at h₁
    haveI : Nonempty (α ⊕ β) := (range_nonempty _).to_subtype
    rw [← not_nonempty_iff_imp_false, ← not_nonempty_iff_imp_false] at h₁
    simp [h₁]
  · rintro ⟨a⟩
    refine ⟨(continuous_inr.tendsto _).uniformContinuous, ?_⟩
    rw [range_inr]
    exact uniformContinuous_comap

Repaired Proof:
theorem uniformEmbedding_inl : UniformEmbedding (Sum.inl : α → α ⊕ β) ↔ Nonempty β := by
  constructor
  · rintro ⟨_, h₁, h₂⟩
    rw [range_inl, Sum.uniformity, comap_const] at h₁
    simp only [filter_eq_bot_of_bot_le, le_bot_iff, comap_const] at h₁
    haveI : Nonempty (α ⊕ β) := (range_nonempty _).to_subtype
    rw [← not_nonempty_iff_imp_false, ← not_nonempty_iff_imp_false] at h₁
    simp [h₁]
  · rintro ⟨b⟩
    refine ⟨(continuous_inl.tendsto _).uniformContinuous, ?_⟩
    rw [range_inl]
    exact uniformContinuous_comap

Repaired Proof:
theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : β → α ⊕ β) ↔ Nonempty α := by
  constructor
  · rintro ⟨_, h₁, h₂⟩
    rw [range_inr, Sum.uniformity, comap_const] at h₁
    simp only [filter_eq_bot_of_bot_le, le_bot_iff, comap_const] at h₁
    haveI : Nonempty (α ⊕ β) := (range_nonempty _).to_subtype
    rw [← not_nonempty_iff_imp_false, ← not_nonempty_iff_imp_false] at h₁
    simp [h₁]
  · rintro ⟨a⟩
    refine ⟨(continuous_inr.tendsto _).uniformContinuous, ?_⟩
    rw [range_inr]
    exact uniformContinuous_comap

Repaired Proof:
theorem uniformEmbedding_inl : UniformEmbedding (Sum.inl : α → α ⊕ β) ↔ Nonempty β := by
  constructor
  · rintro ⟨_, h₁, h₂⟩
    rw [range_inl, Sum.uniformity, comap_const] at h₁
    simp only [filter_eq_bot_of_bot_le, le_bot_iff, comap_const] at h₁
    haveI : Nonempty (α ⊕ β) := (range_nonempty _).to_subtype
    rw [← not_nonempty_iff_imp_false, ← not_nonempty_iff_imp_false] at h₁
    simp [h₁]
  · rintro ⟨b⟩
    refine ⟨(continuous_inl.tendsto _).uniformContinuous, ?_⟩
    rw [range_inl]
    exact uniformContinuous_comap

Repaired Proof:
theorem uniformEmbedding

Attempt failure.

STARTING: Lean repo copy removal
DONE: Lean repo copy removal
Among 200 proof attempts, there were 0 successful and 200 failed attempts at proving their respect theorems.
The rate of successful proof = 0.0.
