STARTING: verification of proofs from predicted_proof column in dataset from models/deepseek_sft_proving/finetuned/test_random_deepseek_sft_proving_tuned_prediction.csv - 2024-09-09 00:05:01.998092
STARTING: Lean repo copy creation
DONE: Lean repo copy creation
STARTING: retrieve cache
installing leantar 0.1.13
Attempting to download 4738 file(s)
Decompressing 4738 file(s)
Unpacked in 217034 ms
Completed successfully!
DONE: retrieved cache
Working on Mathlib/Algebra/AddTorsor.lean - 2024-09-09 00:22:18.988222.
---1/200---
For theorem Equiv.pointReflection_fixed_iff_of_injective_bit0 in Mathlib/Algebra/AddTorsor.lean:
theorem pointReflection_fixed_iff_of_injective_bit0 {x y : P} (h : Injective (bit0 : G → G)) :
    pointReflection x y = y ↔ y = x 


Original valid proof:
:= by
  rw [pointReflection_apply, eq_comm, eq_vadd_iff_vsub_eq, ← neg_vsub_eq_vsub_rev,
    neg_eq_iff_add_eq_zero, ← bit0, ← bit0_zero, h.eq_iff, vsub_eq_zero_iff_eq, eq_comm]


Verifying proof (Commit b0c1460c9fd4a5058bcae6b919686bc5e8a0ee37):
∨ y = x + x := by
  rw [pointReflection_apply, vsub_eq_sub, vadd_eq_add, eq_comm,
    vsub_eq_zero_iff_eq, add_left_eq_self, h.eq_iff, eq_comm, ←
    two_nsmul_eq_two_mul, two_nsmul_eq_two_mul]

theorem pointReflection_fixed_iff_of_module [CharZero G] {x y : P} :
    pointReflection x y = y ↔ y = x ∨ y = 2 • x := by
  rcases eq_or_ne x y with (rfl | hne)
  · simp
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa [two_smul] using eq_or_eq_neg_of_sq_eq_sq _ _ (sub_self _).symm
  rw [pointReflection_fixed_iff_of_injective_bit0 hx.injective_bit0, or_iff_right hne,
    bit0, ← two_smul]

theorem pointReflection_fixed_iff_of_module' [Invertible (2 : G)] [CharZero G] {x y : P} :
    pointReflection x y = y ↔ y = x ∨ y = (⅟ 2 : G) • x := by
  rcases eq_or_ne x y with (rfl | hne)
  · simp
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa [two_smul] using eq_or_eq_neg_of_sq_eq_sq _ _ (sub_self _).symm
  rw [pointReflection_fixed_iff_of_injective_bit0 hx.injective_bit0, or_iff_right hne,
    bit0, ← smul_smul, invOf_mul_self, one_smul]

theorem pointReflection_fixed_iff_of_module [Invertible (2 : G)] [CharZero G] {x y : P} :
    pointReflection x y = y ↔ y = x ∨ y = x + x := by
  rcases eq_or_ne x y with (rfl | hne)
  · simp
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa [two_smul] using eq_or_eq_neg_of_sq_eq_sq _ _ (sub_self _).symm
  rw [pointReflection_fixed_iff_of_injective_bit0 hx.injective_bit0, or_iff_right hne,
    bit0, ← two_smul]
  simp only [invOf_mul_self, one_smul]

theorem pointReflection_fixed_iff_of_module₀ [Invertible (2 : G)] [CharZero G] {x y : P} :
    pointReflection x y = y ↔ y = x ∨ y = x + x := by
  rcases eq_or_ne x y with (rfl | hne)
  · simp
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa [two_smul] using eq_or_eq_neg_of_sq_eq_sq _ _ (sub_self _).symm
  rw [pointReflection_fixed_iff_of_injective_bit0 hx.injective_bit0, or_iff_right hne,
    bit0, ← two_smul]
  simp only [invOf_mul_self, one_smul]

theorem pointReflection_fixed_iff_of_module₀' [CharZero G] {x y : P} :
    pointReflection x y = y ↔ y = x ∨ y = (2 : G)⁻¹ • x := by
  rcases eq_or_ne x y with (rfl | hne)
  · simp
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa [two_smul] using eq_or_eq_neg_of_sq_eq_sq _ _ (sub_self _).symm
  rw [pointReflection_fixed_iff_of_injective_bit0 hx.injective_bit0, or_iff_right hne,
    bit0, ← smul_smul, invOf_mul_self, one_smul]

theorem pointReflection_fixed_iff_of_module₀' [Invertible (2 : G)] [CharZero G] {x y : P} :
    pointReflection x y = y ↔ y = x ∨ y = x + x := by
  rcases eq_or_ne x y with (rfl | hne)
  · simp
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa [two_smul] using eq_or_eq_neg_of_sq_eq_sq _ _ (sub_self _).symm
  rw [pointReflection_fixed_iff_of_injective_bit0 hx.injective_bit0, or_iff_right hne,
    bit0, ← two_smul]
  simp only [invOf_mul_self, one_smul]

theorem pointReflection_fixed_iff_of_module₀'' [Invertible (2 : G)] [CharZero G] {x y : P} :
    pointReflection x y = y ↔ y = x ∨ y = x + x := by
  rcases eq_or_ne x y with (rfl | hne)
  · simp
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa [two_smul] using eq_or_eq_neg_of_sq_eq_sq _ _ (sub_self _).symm
  rw [pointReflection_fixed_iff_of_injective_bit0 hx.injective_bit0, or_iff_right hne,
    bit0, ← two_smul]
  simp only [invOf_mul_self, one_smul]

theorem pointReflection_fixed_iff_of_module₀''' [Invertible (2 : G)] [CharZero G] {x y : P} :
    pointReflection x y = y ↔ y = x ∨ y = x + x := by
  rcases eq_or_ne x y with (rfl | hne)
  · simp
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa [two_smul] using eq_or_eq_neg_of_sq_eq_sq _ _ (sub_self _).symm
  rw [pointReflection_fixed_iff_of_injective_bit0 hx.injective_bit0, or_iff_right hne,
    bit0, ← two_smul]
  simp only [invOf_mul_self, one_smul]

theorem pointReflection_fixed_iff_of_module₀'''' [Invertible (2 : G)] [CharZero G] {x y : P} :
    pointReflection x y = y ↔ y = x ∨ y = x + x := by
  rcases eq_or_ne x y with (rfl | hne)
  · simp
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa [two_smul] using eq_or_eq_neg_of_sq_eq_sq _ _ (sub_self _).symm
  rw [pointReflection_fixed_iff_of_injective_bit0 hx.injective_bit0, or_iff_right hne,
    bit0, ← two_smul]
  simp only [invOf_mul_self, one_smul]

theorem pointReflection_fixed_iff_of_module₀''''' [Invertible (2 : G)] [CharZero G] {x y : P} :
    pointReflection x y = y ↔ y = x ∨ y = x + x := by
  rcases eq_or_ne x y with (rfl | hne)
  · simp
  rcases eq_or_ne x 0 with (rfl | hx)
  · simpa [two_smul] using eq_or_eq_neg_of_sq_eq_sq _ _ (sub_self _).symm
  rw [pointReflection_fixed_iff_of_injective_bit0 hx.injective_bit0, or_iff_right hne,
    bit0, ← two_smul]
  simp only [invOf_mul_self, one_smul]

theorem pointReflection_fixed_iff_of_module₀'''''' [Invertible (2 : G)] [CharZero G] {x y : P} :
    pointReflection x

Attempt failure.

Working on Mathlib/Algebra/BigOperators/Fin.lean - 2024-09-09 00:22:38.487473.
---2/200---
For theorem Fin.prod_ofFn in Mathlib/Algebra/BigOperators/Fin.lean:
theorem prod_ofFn [CommMonoid β] {n : ℕ} (f : Fin n → β) : (List.ofFn f).prod = ∏ i, f i 


Original valid proof:
:= by
  simp [prod_eq_multiset_prod]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 :=
    (List.ofFn_mul_prod f).symm

theorem sum_ofFn [AddCommMonoid β] {n : ℕ} (f : Fin n → β) : (List.ofFn f).sum = ∑ i, f i :=
    (List.ofFn_sum_eq f).symm

theorem sum_ofFn_zero [AddCommMonoid β] {n : ℕ} (f : Fin n → β) :
    (List.ofFn fun _ ↦ 0).sum = 0 := by
  rw [List.ofFn_zero, List.sum_nil]

theorem sum_ofFn_succ [AddCommMonoid β] {n : ℕ} (f : Fin n.succ → β) :
    (List.ofFn f).sum = f 0 + (List.ofFn fun i ↦ f i.succ).sum := by
  rw [List.ofFn_succ, List.sum_cons]

theorem sum_ofFn_eq_sum_range [AddCommMonoid β] {n : ℕ} (f : ℕ → β) :
    (List.ofFn f).sum = ∑ i ∈ Finset.range n, f i := by
  rw [List.ofFn_eq_map, List.sum_map, ← List.sum_range_reflect]
  simp_rw [List.ofFn_eq_map, Function.comp, List.map_map]

theorem sum_ofFn_eq_sum_fin [AddCommMonoid β] {n : ℕ} (f : Fin n → β) :
    (List.ofFn f).sum = ∑ i, f i := by
  simp_rw [List.ofFn_eq_map, List.sum_map, Function.comp, List.sum_ofFn]

theorem prod_ofFn_eq_prod_range [CommMonoid β] {n : ℕ} (f : ℕ → β) :
    (List.ofFn f).prod = ∏ i ∈ Finset.range n, f i := by
  rw [List.ofFn_eq_map, List.prod_map, ← List.prod_toFinset, ← List.prod_range]
  simp_rw [List.ofFn_eq_map, Function.comp, List.map_map]

theorem prod_ofFn_eq_prod_fin [CommMonoid β] {n : ℕ} (f : Fin n → β) :
    (List.ofFn f).prod = ∏ i, f i := by
  simp_rw [List.ofFn_eq_map, List.prod_map, Function.comp, List.prod_ofFn]

theorem sum_ofFn_zero' [AddCommMonoid β] {n : ℕ} (f : Fin n → β) :
    (List.ofFn fun _ ↦ 0).sum = 0 := by
  rw [← List.ofFn_const]
  exact sum_ofFn_zero _

theorem sum_ofFn_succ' [AddCommMonoid β] {n : ℕ} (f : Fin n.succ → β) :
    (List.ofFn f).sum = f 0 + (List.ofFn fun i ↦ f i.succ).sum := by
  rw [← List.ofFn_succ]
  exact sum_ofFn_succ _

theorem sum_ofFn_eq_sum_range' [AddCommMonoid β] {n : ℕ} (f : ℕ → β) :
    (List.ofFn f).sum = ∑ i ∈ Finset.range n, f i := by
  rw [← List.ofFn_eq_map, List.sum_map, ← List.sum_range_reflect]
  simp_rw [List.ofFn_eq_map, Function.comp, List.map_map]

theorem sum_ofFn_eq_sum_fin' [AddCommMonoid β] {n : ℕ} (f : Fin n → β) :
    (List.ofFn f).sum = ∑ i, f i := by
  simp_rw [List.ofFn_eq_map, List.sum_map, Function.comp, List.sum_ofFn]

theorem prod_ofFn_eq_prod_range' [CommMonoid β] {n : ℕ} (f : ℕ → β) :
    (List.ofFn f).prod = ∏ i ∈ Finset.range n, f i := by
  rw [← List.ofFn_eq_map, List.prod_map, ← List.prod_toFinset, ← List.prod_range]
  simp_rw [List.ofFn_eq_map, Function.comp, List.map_map]

theorem prod_ofFn_eq_prod_fin' [CommMonoid β] {n : ℕ} (f : Fin n → β) :
    (List.ofFn f).prod = ∏ i, f i := by
  simp_rw [List.ofFn_eq_map, List.prod_map, Function.comp, List.prod_ofFn]

theorem sum_ofFn_zero'' [AddCommMonoid β] {n : ℕ} (f : Fin n → β) :
    (List.ofFn fun _ ↦ 0).sum = 0 := by
  rw [← List.ofFn_const]
  exact sum_ofFn_zero _

theorem sum_ofFn_succ'' [AddCommMonoid β] {n : ℕ} (f : Fin n.succ → β) :
    (List.ofFn f).sum = f 0 + (List.ofFn fun i ↦ f i.succ).sum := by
  rw [← List.ofFn_succ]
  exact sum_ofFn_succ _

theorem sum_ofFn_eq_sum_range'' [AddCommMonoid β] {n : ℕ} (f : ℕ → β) :
    (List.ofFn f).sum = ∑ i ∈ Finset.range n, f i := by
  rw [← List.ofFn_eq_map, List.sum_map, ← List.sum_range_reflect]
  simp_rw [List.ofFn_eq_map, Function.comp, List.map_map]

theorem sum_ofFn_eq_sum_fin'' [AddCommMonoid β] {n : ℕ} (f : Fin n → β) :
    (List.ofFn f).sum = ∑ i, f i := by
  simp_rw [List.ofFn_eq_map, List.sum_map, Function.comp, List.sum_ofFn]

theorem prod_ofFn_eq_prod_range'' [CommMonoid β] {n : ℕ} (f : ℕ → β) :
    (List.ofFn f).prod = ∏ i ∈ Finset.range n, f i := by
  rw [← List.ofFn_eq_map, List.prod_map, ← List.prod_toFinset, ← List.prod_range]
  simp_rw [List.ofFn_eq_map, Function.comp, List.map_map]

theorem prod_ofFn_eq_prod_fin'' [CommMonoid β] {n : ℕ} (f : Fin n → β) :
    (List.ofFn f).prod = ∏ i, f i := by
  simp_rw [List.ofFn_eq_map, List.prod_map, Function.comp, List.prod_ofFn]

theorem sum_ofFn_zero''' [AddCommMonoid β] {n : ℕ} (f : Fin n → β) :
    (List.ofFn fun _ ↦ 0).sum = 0 := by
  rw [← List.ofFn_const]
  exact sum_ofFn_zero _

theorem sum_ofFn_succ''' [AddCommMonoid β] {n : ℕ} (f : Fin n.succ → β) :
    (List.ofFn f).sum = f 0 + (List.ofFn fun i ↦ f i.succ).sum := by
  rw [← List.ofFn_succ]
  exact sum_ofFn_succ _

theorem sum_ofFn_eq_sum_range''' [AddCommMonoid β] {n : ℕ} (f : ℕ → β) :
    (List.ofFn f).sum = ∑ i ∈ Finset.range n, f i := by
  rw [← List.ofFn_eq_map, List.sum_map, ← List.sum_range_reflect]
  simp_rw [List.ofFn_eq_map, Function.comp, List.map_map]

theorem sum_ofFn_eq_sum_fin'''

Attempt failure.

Working on Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean - 2024-09-09 00:22:52.188400.
---3/200---
For theorem GeneralizedContinuedFraction.get?_of_eq_some_of_succ_get?_intFractPair_stream in Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean:
theorem get?_of_eq_some_of_succ_get?_intFractPair_stream {ifp_succ_n : IntFractPair K}
    (stream_succ_nth_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) :
    (of v).s.get? n = some ⟨1, ifp_succ_n.b⟩ 


Original valid proof:
:= by
  unfold of IntFractPair.seq1
  simp [Stream'.Seq.map_tail, Stream'.Seq.get?_tail, Stream'.Seq.map_get?, stream_succ_nth_eq]


Verifying proof (Commit 67bb925387960887a3b36a6aab219b9c613883f7):
∧
      IntFractPair.of ifp_succ_n.fr =
        IntFractPair.of ((Int.fract v * 10 ^ (ifp_succ_n.stream.length + 1)) % 1) := by
  induction' n with n
  · have stream_succ_eq : IntFractPair.stream v 1 = some ⟨0, Int.fract v⟩ := by
      have stream_zero_eq : IntFractPair.stream v 0 = some ⟨⌊v⌋, Int.fract v⟩ := rfl
      erw [IntFractPair.stream, stream_zero_eq, Part.bind_some, Part.map_some,
        Part.pure_get]
      rfl
    have : Int.fract v * 10 = Int.fract (v * 10) := by
      simp [Int.fract]
    simp [IntFractPair.of, stream_succ_eq, this]
  · have stream_succ_n_eq : IntFractPair.stream v (n + 2) = some ifp_succ_n := by
      have : IntFractPair.stream v (n + 1 + 1) = some ifp_succ_n := stream_succ_nth_eq
      rwa [Nat.add_assoc] at this
    rcases get?_eq_some'.mp (IntFractPair.get?_stream_succ_eq_some_iff.mpr stream_succ_n_eq) with
      ⟨stream_n_eq, _, _, ifp_n_eq⟩
    rcases IntFractPair.of_correctness_of_stream_succ ifp_n_eq with
      ⟨stream_succ_n_eq, _, _, _, _, ifp_succ_n_eq⟩
    rcases get?_eq_some'.mp (ifp_succ_n_eq.symm ▸ ifp_n_eq) with ⟨ifp_n_stream_eq, _, ifp_n_eq'⟩
    rcases IntFractPair.of_correctness_of_stream_succ ifp_n_stream_eq with
      ⟨ifp_succ_n_stream_eq, _, _, _, _, ifp_succ_n_eq'⟩
    simp_all

Repaired Proof:
theorem get?_of_eq_some_of_succ_get?_intFractPair_stream {ifp_succ_n : IntFractPair K}
    (stream_succ_nth_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) :
    (of v).s.get? n = some ⟨1, ifp_succ_n.b⟩ ∧
      IntFractPair.of ifp_succ_n.fr =
        IntFractPair.of ((Int.fract v * 10 ^ (ifp_succ_n.stream.length + 1)) % 1) := by
  induction' n with n
  · have stream_succ_eq : IntFractPair.stream v 1 = some ⟨0, Int.fract v⟩ := by
      have stream_zero_eq : IntFractPair.stream v 0 = some ⟨⌊v⌋, Int.fract v⟩ := rfl
      erw [IntFractPair.stream, stream_zero_eq, Part.bind_some, Part.map_some,
        Part.pure_get]
      rfl
    have : Int.fract v * 10 = Int.fract (v * 10) := by
      simp [Int.fract]
    simp [IntFractPair.of, stream_succ_eq, this]
  · have stream_succ_n_eq : IntFractPair.stream v (n + 2) = some ifp_succ_n := by
      have : IntFractPair.stream v (n + 1 + 1) = some ifp_succ_n := stream_succ_nth_eq
      rwa [Nat.add_assoc] at this
    rcases get?_eq_some.mp (IntFractPair.get?_stream_succ_eq_some_iff.mpr stream_succ_n_eq) with
      ⟨stream_n_eq, _, _, ifp_n_eq⟩
    rcases IntFractPair.of_correctness_of_stream_succ ifp_n_eq with
      ⟨stream_succ_n_eq, _, _, _, _, ifp_succ_n_eq⟩
    rcases get?_eq_some.mp (ifp_succ_n_eq.symm ▸ ifp_n_eq) with ⟨ifp_n_stream_eq, _, ifp_n_eq'⟩
    rcases IntFractPair.of_correctness_of_stream_succ ifp_n_stream_eq with
      ⟨ifp_succ_n_stream_eq, _, _, _, _, ifp_succ_n_eq'⟩
    simp_all

@[simp]
theorem coe_of : (of v : Stream'.Seq <| Pairing K) = (of v).s :=
  rfl

@[simp, norm_cast]
theorem coe_get?_of_eq_some_get?_intFractPair_stream {ifp_n : IntFractPair K}
    (stream_nth_eq : IntFractPair.stream v n = some ifp_n) :
    (of v).s.get? n = some ⟨1, ifp_n.b⟩ := by
  simp [get?_of, stream_nth_eq]

@[simp, norm_cast]
theorem coe_get?_of_eq_some_get?_intFractPair_stream' {ifp_n : IntFractPair K}
    (stream_nth_eq : IntFractPair.stream v n = some ifp_n) :
    (of v).s.get? n = some ⟨ifp_n, true⟩ := by
  simp [get?_of, stream_nth_eq]

@[simp, norm_cast]
theorem coe_get?_of_eq_some_succ_get?_intFractPair_stream {ifp_succ_n : IntFractPair K}
    (stream_succ_nth_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) :
    (of v).s.get? n = some ⟨1, ifp_succ_n.b⟩ ∧
      IntFractPair.of ifp_succ_n.fr =
        IntFractPair.of ((Int.fract v * 10 ^ (ifp_succ_n.stream.length + 1)) % 1) := by
  induction' n with n
  · have stream_succ_eq : IntFractPair.stream v 1 = some ⟨0, Int.fract v⟩ := by
      have stream_zero_eq : IntFractPair.stream v 0 = some ⟨⌊v⌋, Int.fract v⟩ := rfl
      erw [IntFractPair.stream, stream_zero_eq, Part.bind_some, Part.map_some,
        Part.pure_get]
      rfl
    have : Int.fract v * 10 = Int.fract (v * 10) := by
      simp [Int.fract]
    simp [IntFractPair.of, stream_succ_eq, this]
  · have stream_succ_n_eq : IntFractPair.stream v (n + 2) = some ifp_succ_n := by
      have : IntFractPair.stream v (n + 1 + 1) = some ifp_succ_n := stream_succ_nth_eq
      rwa [Nat.add_assoc] at this
    rcases get?_eq_some.mp (IntFractPair.get?_stream_succ_eq_some_iff.mpr stream_succ_n_eq) with
      ⟨stream_n_eq, _, _, ifp_n_eq⟩
    rcases IntFractPair.of_correctness_of_stream_succ ifp_n_eq with
      ⟨stream_succ_n_eq, _, _, _, _, ifp_succ_n_eq⟩
    rcases get?_eq_some.mp (ifp_succ_n_eq.symm ▸ ifp_n_eq) with ⟨ifp_n_stream_eq, _, ifp_n_eq'⟩
    rcases IntFractPair.of_correctness_of_stream_succ ifp_n_stream_eq with
      ⟨ifp_succ_n_stream_eq, _, _, _, _, ifp_succ

Attempt failure.

---4/200---
For theorem GeneralizedContinuedFraction.of_s_tail in Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean:
theorem of_s_tail : (of v).s.tail = (of (fract v)⁻¹).s 


Original valid proof:
:=
  Stream'.Seq.ext fun n => Stream'.Seq.get?_tail (of v).s n ▸ of_s_succ v n


Verifying proof (Commit 67bb925387960887a3b36a6aab219b9c613883f7):
∨ (of v).s.tail = (of (fract v)⁻¹).s.tail := by
    have hv : fract v ≠ 0 → fract (fract v)⁻¹ = fract v := by
      rintro h
      simp [fract_eq_iff, h, le_of_lt (fract_pos.2 h)]
    cases' eq_or_ne (fract v) 0 with h h <;> simp [h, of_s_head, hv h]
  have hv : v = v.floor + fract v := mod_cast (floor_add_fract v).symm
  have hv' : (of v).s.map (↑) = Stream'.Seq.map (↑) (of v).s := rfl
  have hv₀ : (of v).s.get? 0 = ↑⌊v⌋ := rfl
  have hv₁ : (of v).s.tail.map (↑) = Stream'.Seq.map (↑) (of v).s.tail := rfl
  have hv₂ : (of v).s.tail.get? 0 = ↑(fract v)⁻¹ := rfl
  simp [hv, hv₀, hv₁, hv₂, Stream'.Seq.map_tail, Stream'.Seq.map_get?, Stream'.Seq.get?_tail]
  rcases of_s_head v with (rfl | ⟨rfl, h⟩) <;>
    · simp [Stream'.Seq.tail_cons, Stream'.Seq.get?_tail, Stream'.Seq.map_tail]
      rcases of_s_tail v with (rfl | rfl) <;> simp [Stream'.Seq.map_tail]

Repaired Proof:
theorem of_s_head : (of v).s.head = ⌊v⌋ ∨ (of v).s.head = (of (fract v)⁻¹).s.head := by
  simp [of, Stream'.Seq.head]

theorem of_s_tail : (of v).s.tail = (of (fract v)⁻¹).s ∨ (of v).s.tail = (of (fract v)⁻¹).s.tail := by
    have hv : fract v ≠ 0 → fract (fract v)⁻¹ = fract v := by
      rintro h
      simp [fract_eq_iff, h, le_of_lt (fract_pos.2 h)]
    cases' eq_or_ne (fract v) 0 with h h <;> simp [h, of_s_head, hv h]
  have hv : v = v.floor + fract v := mod_cast (floor_add_fract v).symm
  have hv' : (of v).s.map (↑) = Stream'.Seq.map (↑) (of v).s := rfl
  have hv₀ : (of v).s.get? 0 = ↑⌊v⌋ := rfl
  have hv₁ : (of v).s.tail.map (↑) = Stream'.Seq.map (↑) (of v).s.tail := rfl
  have hv₂ : (of v).s.tail.get? 0 = ↑(fract v)⁻¹ := rfl
  simp [hv, hv₀, hv₁, hv₂, Stream'.Seq.map_tail, Stream'.Seq.map_get?, Stream'.Seq.get?_tail]
  rcases of_s_head v with (rfl | ⟨rfl, h⟩) <;>
    · simp [Stream'.Seq.tail_cons, Stream'.Seq.get?_tail, Stream'.Seq.map_tail]
      rcases of_s_tail v with (rfl | rfl) <;> simp [Stream'.Seq.map_tail]

Repaired Proof:
theorem of_s_head : (of v).s.head = ⌊v⌋ ∨ (of v).s.head = (of (fract v)⁻¹).s.head := by
  simp [of, Stream'.Seq.head]

theorem of_s_tail : (of v).s.tail = (of (fract v)⁻¹).s ∨ (of v).s.tail = (of (fract v)⁻¹).s.tail := by
    have hv : fract v ≠ 0 → fract (fract v)⁻¹ = fract v := by
      rintro h
      simp [fract_eq_iff, h, le_of_lt (fract_pos.2 h)]
    cases' eq_or_ne (fract v) 0 with h h <;> simp [h, of_s_head, hv h]
  have hv : v = v.floor + fract v := mod_cast (floor_add_fract v).symm
  have hv' : (of v).s.map (↑) = Stream'.Seq.map (↑) (of v).s := rfl
  have hv₀ : (of v).s.get? 0 = ↑⌊v⌋ := rfl
  have hv₁ : (of v).s.tail.map (↑) = Stream'.Seq.map (↑) (of v).s.tail := rfl
  have hv₂ : (of v).s.tail.get? 0 = ↑(fract v)⁻¹ := rfl
  simp [hv, hv₀, hv₁, hv₂, Stream'.Seq.map_tail, Stream'.Seq.map_get?, Stream'.Seq.get?_tail]
  rcases of_s_head v with (rfl | ⟨rfl, h⟩) <;>
    · simp [Stream'.Seq.tail_cons, Stream'.Seq.get?_tail, Stream'.Seq.map_tail]
      rcases of_s_tail v with (rfl | rfl) <;> simp [Stream'.Seq.map_tail]

Repaired Proof:
theorem of_s_head : (of v).s.head = ⌊v⌋ ∨ (of v).s.head = (of (fract v)⁻¹).s.head := by
  simp [of, Stream'.Seq.head]

theorem of_s_tail : (of v).s.tail = (of (fract v)⁻¹).s ∨ (of v).s.tail = (of (fract v)⁻¹).s.tail := by
    have hv : fract v ≠ 0 → fract (fract v)⁻¹ = fract v := by
      rintro h
      simp [fract_eq_iff, h, le_of_lt (fract_pos.2 h)]
    cases' eq_or_ne (fract v) 0 with h h <;> simp [h, of_s_head, hv h]
  have hv : v = v.floor + fract v := mod_cast (floor_add_fract v).symm
  have hv' : (of v).s.map (↑) = Stream'.Seq.map (↑) (of v).s := rfl
  have hv₀ : (of v).s.get? 0 = ↑⌊v⌋ := rfl
  have hv₁ : (of v).s.tail.map (↑) = Stream'.Seq.map (↑) (of v).s.tail := rfl
  have hv₂ : (of v).s.tail.get? 0 = ↑(fract v)⁻¹ := rfl
  simp [hv, hv₀, hv₁, hv₂, Stream'.Seq.map_tail, Stream'.Seq.map_get?, Stream'.Seq.get?_tail]
  rcases of_s_head v with (rfl | ⟨rfl, h⟩) <;>
    · simp [Stream'.Seq.tail_cons, Stream'.Seq.get?_tail, Stream'.Seq.map_tail]
      rcases of_s_tail v with (rfl | rfl) <;> simp [Stream'.Seq.map_tail]

Repaired Proof:
theorem of_s_head : (of v).s.head = ⌊v⌋ ∨ (of v).s.head = (of (fract v)⁻¹).s.head := by
  simp [of, Stream'.Seq.head]

theorem of_s_tail : (of v).s.tail = (of (fract v)⁻¹).s ∨ (of v).s.tail = (of (fract v)⁻¹).s.tail := by
    have hv : fract v ≠ 0 → fract (fract v)⁻¹ = fract v := by
      rintro h
      simp [fract_eq_iff, h, le_

Attempt failure.

Working on Mathlib/Algebra/DirectLimit.lean - 2024-09-09 00:23:11.712371.
---5/200---
For theorem AddCommGroup.DirectLimit.map_comp in Mathlib/Algebra/DirectLimit.lean:
lemma map_comp [IsDirected ι (· ≤ ·)]
    (g₁ : (i : ι) → G i →ₗ[R] G' i) (g₂ : (i : ι) → G' i →ₗ[R] G'' i)
    (hg₁ : ∀ i j h, g₁ j ∘ₗ f i j h = f' i j h ∘ₗ g₁ i)
    (hg₂ : ∀ i j h, g₂ j ∘ₗ f' i j h = f'' i j h ∘ₗ g₂ i) :
    (map g₂ hg₂ ∘ₗ map g₁ hg₁ :
      DirectLimit G f →ₗ[R] DirectLimit G'' f'') =
    (map (fun i ↦ g₂ i ∘ₗ g₁ i) fun i j h ↦ by
        rw [LinearMap.comp_assoc, hg₁ i, ← LinearMap.comp_assoc, hg₂ i, LinearMap.comp_assoc] :
      DirectLimit G f →ₗ[R] DirectLimit G'' f'') 


Original valid proof:
:=
  DFunLike.ext _ _ fun x ↦ (isEmpty_or_nonempty ι).elim (fun _ ↦ Subsingleton.elim _ _) fun _ ↦
    x.induction_on fun i g ↦ by simp


Verifying proof (Commit af1e1921fa808d9f4d24fd674214116943e9fbb8):
 :=
  ext fun i ↦ (lift_unique _ _ _ _).symm.trans <|
    (lift_unique _ _ _ _).trans <| LinearMap.ext_ringHom _ _ fun r ↦
      show _ = _ ∘ₗ _  by
        rw [LinearMap.comp_assoc, map_comp_apply, ← LinearMap.comp_assoc,
          map_comp_apply, LinearMap.comp_assoc, map_comp_apply]

Repaired Proof:
lemma map_comp [IsDirected ι (· ≤ ·)]
    (g₁ : (i : ι) → G i →ₗ[R] G' i) (g₂ : (i : ι) → G' i →ₗ[R] G'' i)
    (hg₁ : ∀ i j h, g₁ j ∘ₗ f i j h = f' i j h ∘ₗ g₁ i)
    (hg₂ : ∀ i j h, g₂ j ∘ₗ f' i j h = f'' i j h ∘ₗ g₂ i) :
    (map g₂ hg₂ ∘ₗ map g₁ hg₁ :
      DirectLimit G f →ₗ[R] DirectLimit G'' f'') =
    (map (fun i ↦ g₂ i ∘ₗ g₁ i) fun i j h ↦ by
        rw [LinearMap.comp_assoc, hg₁ i, ← LinearMap.comp_assoc, hg₂ i, LinearMap.comp_assoc] :
      DirectLimit G f →ₗ[R] DirectLimit G'' f'')  :=
  ext fun i ↦ (lift_unique _ _ _ _).symm.trans <|
    (lift_unique _ _ _ _).trans <| LinearMap.ext_ringHom _ _ fun r ↦
      show _ = _ ∘ₗ _  by
        rw [LinearMap.comp_assoc, map_comp_apply, ← LinearMap.comp_assoc,
          map_comp_apply, LinearMap.comp_assoc, map_comp_apply]

Repaired Proof:
lemma map_comp [IsDirected ι (· ≤ ·)]
    (g₁ : (i : ι) → G i →ₗ[R] G' i) (g₂ : (i : ι) → G' i →ₗ[R] G'' i)
    (hg₁ : ∀ i j h, g₁ j ∘ₗ f i j h = f' i j h ∘ₗ g₁ i)
    (hg₂ : ∀ i j h, g₂ j ∘ₗ f' i j h = f'' i j h ∘ₗ g₂ i) :
    (map g₂ hg₂ ∘ₗ map g₁ hg₁ :
      DirectLimit G f →ₗ[R] DirectLimit G'' f'') =
    (map (fun i ↦ g₂ i ∘ₗ g₁ i) fun i j h ↦ by
        rw [LinearMap.comp_assoc, hg₁ i, ← LinearMap.comp_assoc, hg₂ i, LinearMap.comp_assoc] :
      DirectLimit G f →ₗ[R] DirectLimit G'' f'')  :=
  ext fun i ↦ (lift_unique _ _ _ _).symm.trans <|
    (lift_unique _ _ _ _).trans <| LinearMap.ext_ringHom _ _ fun r ↦
      show _ = _ ∘ₗ _  by
        rw [LinearMap.comp_assoc, map_comp_apply, ← LinearMap.comp_assoc,
          map_comp_apply, LinearMap.comp_assoc, map_comp_apply]

Repaired Proof:
lemma map_comp [IsDirected ι (· ≤ ·)]
    (g₁ : (i : ι) → G i →ₗ[R] G' i) (g₂ : (i : ι) → G' i →ₗ[R] G'' i)
    (hg₁ : ∀ i j h, g₁ j ∘ₗ f i j h = f' i j h ∘ₗ g₁ i)
    (hg₂ : ∀ i j h, g₂ j ∘ₗ f' i j h = f'' i j h ∘ₗ g₂ i) :
    (map g₂ hg₂ ∘ₗ map g₁ hg₁ :
      DirectLimit G f →ₗ[R] DirectLimit G'' f'') =
    (map (fun i ↦ g₂ i ∘ₗ g₁ i) fun i j h ↦ by
        rw [LinearMap.comp_assoc, hg₁ i, ← LinearMap.comp_assoc, hg₂ i, LinearMap.comp_assoc] :
      DirectLimit G f →ₗ[R] DirectLimit G'' f'')  :=
  ext fun i ↦ (lift_unique _ _ _ _).symm.trans <|
    (lift_unique _ _ _ _).trans <| LinearMap.ext_ringHom _ _ fun r ↦
      show _ = _ ∘ₗ _  by
        rw [LinearMap.comp_assoc, map_comp_apply, ← LinearMap.comp_assoc,
          map_comp_apply, LinearMap.comp_assoc, map_comp_apply]

Attempt failure.

Working on Mathlib/Algebra/DirectSum/Decomposition.lean - 2024-09-09 00:23:47.857286.
---6/200---
For theorem DirectSum.decompose_lhom_ext in Mathlib/Algebra/DirectSum/Decomposition.lean:
theorem decompose_lhom_ext {N} [AddCommMonoid N] [Module R N] ⦃f g : M →ₗ[R] N⦄
    (h : ∀ i, f ∘ₗ (ℳ i).subtype = g ∘ₗ (ℳ i).subtype) : f = g 


Original valid proof:
:=
  LinearMap.ext <| (decomposeLinearEquiv ℳ).symm.surjective.forall.mpr <|
    suffices f ∘ₗ (decomposeLinearEquiv ℳ).symm
           = (g ∘ₗ (decomposeLinearEquiv ℳ).symm : (⨁ i, ℳ i) →ₗ[R] N) from
      DFunLike.congr_fun this
    linearMap_ext _ fun i => by
      simp_rw [LinearMap.comp_assoc, decomposeLinearEquiv_symm_comp_lof ℳ i, h]


Verifying proof (Commit b071b57a84e9970e988d47cb1622531297757a79):
 := by
  ext x
  classical
    obtain ⟨s, _, t, _, rfl⟩ := DirectSum.exists_of_mem_sup (decompose_mem_ideal ℳ x)
    simp_rw [LinearMap.coe_comp, Function.comp_apply, decompose_coe, Submodule.coe_subtype,
      Submodule.coe_subtype, decompose_coe] at h
    simp_rw [map_sum, map_smul, h]

Repaired Proof:
theorem decompose_lhom_ext {N} [AddCommMonoid N] [Module R N] ⦃f g : M →ₗ[R] N⦄
    (h : ∀ i, f ∘ₗ (ℳ i).subtype = g ∘ₗ (ℳ i).subtype) : f = g := by
  ext x
  classical
    obtain ⟨s, _, t, _, rfl⟩ := DirectSum.exists_of_mem_sup (decompose_mem_ideal ℳ x)
    simp_rw [LinearMap.coe_comp, Function.comp_apply, decompose_coe, Submodule.coe_subtype,
      Submodule.coe_subtype, decompose_coe] at h
    simp_rw [map_sum, map_smul, h]

Repaired Proof:
theorem decompose_lhom_ext {N} [AddCommMonoid N] [Module R N] ⦃f g : M →ₗ[R] N⦄
    (h : ∀ i, f ∘ₗ (ℳ i).subtype = g ∘ₗ (ℳ i).subtype) : f = g := by
  ext x
  classical
    obtain ⟨s, _, t, _, rfl⟩ := DirectSum.exists_of_mem_sup (decompose_mem_ideal ℳ x)
    simp_rw [LinearMap.coe_comp, Function.comp_apply, decompose_coe, Submodule.coe_subtype,
      Submodule.coe_subtype, decompose_coe] at h
    simp_rw [map_sum, map_smul, h]

Repaired Proof:
theorem decompose_lhom_ext {N} [AddCommMonoid N] [Module R N] ⦃f g : M →ₗ[R] N⦄
    (h : ∀ i, f ∘ₗ (ℳ i).subtype = g ∘ₗ (ℳ i).subtype) : f = g := by
  ext x
  classical
    obtain ⟨s, _, t, _, rfl⟩ := DirectSum.exists_of_mem_sup (decompose_mem_ideal ℳ x)
    simp_rw [LinearMap.coe_comp, Function.comp_apply, decompose_coe, Submodule.coe_subtype,
      Submodule.coe_subtype, decompose_coe] at h
    simp_rw [map_sum, map_smul, h]

Repaired Proof:
theorem decompose_lhom_ext {N} [AddCommMonoid N] [Module R N] ⦃f g : M →ₗ[R] N⦄
    (h : ∀ i, f ∘ₗ (ℳ i).subtype = g ∘ₗ (ℳ i).subtype) : f = g := by
  ext x
  classical
    obtain ⟨s, _, t, _, rfl⟩ := DirectSum.exists_of_mem_sup (decompose_mem_ideal ℳ x)
    simp_rw [LinearMap.coe_comp, Function.comp_apply, decompose_coe, Submodule.coe_subtype,
      Submodule.coe_subtype, decompose_coe] at h
    simp_rw [map_sum, map_smul, h]

Attempt failure.

Working on Mathlib/Algebra/Homology/ExactSequence.lean - 2024-09-09 00:24:02.559150.
---7/200---
For theorem CategoryTheory.ComposableArrows.exact_iff_δlast in Mathlib/Algebra/Homology/ExactSequence.lean:
lemma exact_iff_δlast {n : ℕ} (S : ComposableArrows C (n + 2)) :
    S.Exact ↔ S.δlast.Exact ∧ (mk₂ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact 


Original valid proof:
:= by
  constructor
  · intro h
    constructor
    · exact Exact.mk (IsComplex.mk (fun i hi => h.toIsComplex.zero i))
        (fun i hi => h.exact i)
    · rw [exact₂_iff]; swap
      · rw [isComplex₂_iff]
        exact h.toIsComplex.zero n
      exact h.exact n (by omega)
  · rintro ⟨h, h'⟩
    refine Exact.mk (IsComplex.mk (fun i hi => ?_)) (fun i hi => ?_)
    · simp only [add_le_add_iff_right, ge_iff_le] at hi
      obtain hi | rfl := hi.lt_or_eq
      · exact h.toIsComplex.zero i
      · exact h'.toIsComplex.zero 0
    · simp only [add_le_add_iff_right, ge_iff_le] at hi
      obtain hi | rfl := hi.lt_or_eq
      · exact h.exact i
      · exact h'.exact 0


Verifying proof (Commit 4ce1bee1aec1b13e15aa7ab6b7f2b65c272ebb54):
∧
      (mk₂ (S.map' (n + 1) (n + 2)) (S.map' (n + 2) (n + 3))).Exact := by
  simp only [exact_iff_δlast_exact_and_epi_and_mono, exact_iff_δlast_exact]
  tauto

lemma exact_iff_δlast_exact_and_epi_and_mono_and_δlast_exact_iff_δlast_exact_and_epi_and_mono
    {n : ℕ} (S : ComposableArrows C (n + 3)) :
    S.Exact ↔ S.δlast.Exact ∧ (mk₂ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact ∧
      (mk₂ (S.map' (n + 1) (n + 2)) (S.map' (n + 2) (n + 3))).Exact ∧
      (mk₂ (S.map' (n + 2) (n + 3)) (S.map' (n + 3) (n + 4))).Exact := by
  simp only [exact_iff_δlast_exact_and_epi_and_mono, exact_iff_δlast_exact]
  tauto

lemma exact_iff_δlast_exact_and_epi_and_mono_and_δlast_exact_and_epi_and_mono
    {n : ℕ} (S : ComposableArrows C (n + 4)) :
    S.Exact ↔ S.δlast.Exact ∧ (mk₂ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact ∧
      (mk₂ (S.map' (n + 1) (n + 2)) (S.map' (n + 2) (n + 3))).Exact ∧
      (mk₂ (S.map' (n + 2) (n + 3)) (S.map' (n + 3) (n + 4))).Exact ∧
      (mk₂ (S.map' (n + 3) (n + 4)) (S.map' (n + 4) (n + 5))).Exact := by
  simp only [exact_iff_δlast_exact_and_epi_and_mono, exact_iff_δlast_exact]
  tauto

lemma exact_iff_δlast_exact_and_epi_and_mono_and_δlast_exact_and_epi_and_mono_and_δlast_exact_and_
    epi_and_mono {n : ℕ} (S : ComposableArrows C (n + 5)) :
    S.Exact ↔ S.δlast.Exact ∧ (mk₂ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact ∧
      (mk₂ (S.map' (n + 1) (n + 2)) (S.map' (n + 2) (n + 3))).Exact ∧
      (mk₂ (S.map' (n + 2) (n + 3)) (S.map' (n + 3) (n + 4))).Exact ∧
      (mk₂ (S.map' (n + 3) (n + 4)) (S.map' (n + 4) (n + 5))).Exact ∧
      (mk₂ (S.map' (n + 4) (n + 5)) (S.map' (n + 5) (n + 6))).Exact := by
  simp only [exact_iff_δlast_exact_and_epi_and_mono, exact_iff_δlast_exact]
  tauto

lemma exact_iff_δlast_exact_and_epi_and_mono_and_δlast_exact_and_epi_and_mono_and_δlast_exact_and_
    epi_and_mono_and_δlast_exact_and_epi_and_mono {n : ℕ} (S : ComposableArrows C (n + 6)) :
    S.Exact ↔ S.δlast.Exact ∧ (mk₂ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact ∧
      (mk₂ (S.map' (n + 1) (n + 2)) (S.map' (n + 2) (n + 3))).Exact ∧
      (mk₂ (S.map' (n + 2) (n + 3)) (S.map' (n + 3) (n + 4))).Exact ∧
      (mk₂ (S.map' (n + 3) (n + 4)) (S.map' (n + 4) (n + 5))).Exact ∧
      (mk₂ (S.map' (n + 4) (n + 5)) (S.map' (n + 5) (n + 6))).Exact ∧
      (mk₂ (S.map' (n + 5) (n + 6)) (S.map' (n + 6) (n + 7))).Exact := by
  simp only [exact_iff_δlast_exact_and_epi_and_mono, exact_iff_δlast_exact]
  tauto

lemma exact_iff_δlast_exact_and_epi_and_mono_and_δlast_exact_and_epi_and_mono_and_δlast_exact_and_
    epi_and_mono_and_δlast_exact_and_epi_and_mono_and_δlast_exact_and_epi_and_mono {n : ℕ}
    (S : ComposableArrows C (n + 7)) :
    S.Exact ↔ S.δlast.Exact ∧ (mk₂ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact ∧
      (mk₂ (S.map' (n + 1) (n + 2)) (S.map' (n + 2) (n + 3))).Exact ∧
      (mk₂ (S.map' (n + 2) (n + 3)) (S.map' (n + 3) (n + 4))).Exact ∧
      (mk₂ (S.map' (n + 3) (n + 4)) (S.map' (n + 4) (n + 5))).Exact ∧
      (mk₂ (S.map' (n + 4) (n + 5)) (S.map' (n + 5) (n + 6))).Exact ∧
      (mk₂ (S.map' (n + 5) (n + 6)) (S.map' (n + 6) (n + 7))).Exact ∧
      (mk₂ (S.map' (n + 6) (n + 7)) (S.map' (n + 7) (n + 8))).Exact := by
  simp only [exact_iff_δlast_exact_and_epi_and_mono, exact_iff_δlast_exact]
  tauto

lemma exact_iff_δlast_exact_and_epi_and_mono_and_δlast_exact_and_epi_and_mono_and_δlast_exact_and_
    epi_and_mono_and_δlast_exact_and_epi_and_mono_and_δlast_exact_and_epi_and_mono_and_
    δlast_exact_and_epi_and_mono {n : ℕ} (S : ComposableArrows C (n + 8)) :
    S.Exact ↔ S.δlast.Exact ∧ (mk₂ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact ∧
      (mk₂ (S.map' (n + 1) (n + 2)) (S.map' (n + 2) (n + 3))).Exact ∧
      (mk₂ (S.map' (n + 2) (n + 3)) (S.map' (n + 3) (n + 4))).Exact ∧
      (mk₂ (S.map' (n + 3) (n + 4)) (S.map' (n + 4) (n + 5))).Exact ∧
      (mk₂ (S.map' (n + 4) (n + 5)) (S.map' (n + 5) (n + 6))).Exact �

Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/ConcreteCategory.lean - 2024-09-09 00:24:24.416144.
---8/200---
For theorem CategoryTheory.ShortComplex.ShortExact.surjective_g in Mathlib/Algebra/Homology/ShortComplex/ConcreteCategory.lean:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) 


Original valid proof:
:= by
  rw [← Preadditive.epi_iff_surjective]
  exact hS.epi_g


Verifying proof (Commit 71880da883b383ac13b9beb76b1bd41a0f023582):
 :=
  fun x ↦ by
    obtain ⟨y, rfl⟩ := hS.W.epi_g.surjective x
    obtain ⟨a, rfl⟩ := hS.mono_f.exact_r_g _ y
    exact ⟨a, rfl⟩

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g)  :=
  fun x ↦ by
    obtain ⟨y, rfl⟩ := hS.W.epi_g.surjective x
    obtain ⟨a, rfl⟩ := hS.mono_f.exact_r_g _ y
    exact ⟨a, rfl⟩

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) := by
  rw [← AddCommGroupCat.mono_iff_injective]
  exact hS.mono_f

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) := by
  rw [← AddCommGroupCat.epi_iff_surjective]
  exact hS.epi_g

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forget₂ C Ab).map S.g) :=
  hS.epi_g.surjective

Repaired Proof:
lemma ShortExact.injective_f (hS : S.ShortExact) :
    Function.Injective ((forget₂ C Ab).map S.f) :=
  hS.mono_f.injective

Repaired Proof:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.

Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/Preadditive.lean - 2024-09-09 00:24:38.300318.
---9/200---
For theorem CategoryTheory.ShortComplex.homologyMap_sub in Mathlib/Algebra/Homology/ShortComplex/Preadditive.lean:
lemma homologyMap_sub : homologyMap (φ - φ') = homologyMap φ - homologyMap φ' 


Original valid proof:
:=
  homologyMap'_sub _ _


Verifying proof (Commit 9072ff84a0d139a344bf9eed4a00c4cd27596c79):
 :=
  homologyMap'_sub _ _

end

variable {X : CochainComplex C ℕ} {Y : W} (f f' : X ⟶ Y[0])

@[simp]
lemma homologyMap_sub :
    homologyMap (f - f') = homologyMap f - homologyMap f' :=
  homologyMap'_sub _ _

@[simp]
lemma homologyMap_neg :
    homologyMap (-f) = -homologyMap f :=
  homologyMap'_neg _

@[simp]
lemma homologyMap_add :
    homologyMap (f + f') = homologyMap f + homologyMap f' :=
  homologyMap'_add _ _

@[simp]
lemma homologyMap_sub :
    homologyMap (f - f') = homologyMap f - homologyMap f' :=
  homologyMap'_sub _ _

instance homologyFunctor_additive : (homologyFunctor C 0).Additive where

end

instance homologyFunctor_preserves_zero_morphisms_of_zero_object :
    (homologyFunctor C 0).PreservesZeroMorphisms where
  map_zero_map_zero' := by
    intros X Y
    dsimp
    simp only [homologyMap_zero, comp_zero, zero_comp]

instance homologyFunctor_preserves_finite_limits_of_preserves_zero_morphisms
    [PreservesFiniteLimits (forget C)] :
    PreservesFiniteLimits (homologyFunctor C 0) := by
  apply homologyFunctor'_preservesFiniteLimitsOfPreservesZeroMorphisms
  intro n
  have : (homologyFunctor C n).op = homologyFunctor C.op n := rfl
  rw [← this]
  change PreservesFiniteLimits (homologyFunctor C.op n)
  infer_instance

instance homologyFunctor_preserves_finite_colimits_of_preserves_zero_morphisms
    [PreservesFiniteColimits (forget C)] :
    PreservesFiniteColimits (homologyFunctor C 0) := by
  apply homologyFunctor'_preservesFiniteColimitsOfPreservesZeroMorphisms
  intro n
  have : (homologyFunctor C n).op = homologyFunctor C.op n := rfl
  rw [← this]
  change PreservesFiniteColimits (homologyFunctor C.op n)
  infer_instance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits_op
    [PreservesFiniteLimits (Opposite.unop (forget C))] :
    PreservesFiniteLimits (homologyFunctor C 0) := by
  apply homologyFunctor'_preservesFiniteLimitsOfPreservesFiniteLimitsOp
  intro n
  have : (homologyFunctor C n).op = homologyFunctor C.op n := rfl
  rw [← this]
  change PreservesFiniteLimits (homologyFunctor C.op n)
  infer_instance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits_op
    [PreservesFiniteColimits (Opposite.unop (forget C))] :
    PreservesFiniteColimits (homologyFunctor C 0) := by
  apply homologyFunctor'_preservesFiniteColimitsOfPreservesFiniteColimitsOp
  intro n
  have : (homologyFunctor C n).op = homologyFunctor C.op n := rfl
  rw [← this]
  change PreservesFiniteColimits (homologyFunctor C.op n)
  infer_instance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits
    [PreservesFiniteLimits (forget C)] :
    PreservesFiniteLimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits
    [PreservesFiniteColimits (forget C)] :
    PreservesFiniteColimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits_op
    [PreservesFiniteLimits (Opposite.unop (forget C))] :
    PreservesFiniteLimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits_op
    [PreservesFiniteColimits (Opposite.unop (forget C))] :
    PreservesFiniteColimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits_op
    [PreservesFiniteLimits (Opposite.unop (forget C))] :
    PreservesFiniteLimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits_op
    [PreservesFiniteColimits (Opposite.unop (forget C))] :
    PreservesFiniteColimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits_op
    [PreservesFiniteLimits (Opposite.unop (forget C))] :
    PreservesFiniteLimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits_op
    [PreservesFiniteColimits (Opposite.unop (forget C))] :
    PreservesFiniteColimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits_op
    [PreservesFiniteLimits (Opposite.unop (forget C))] :
    PreservesFiniteLimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits_op
    [PreservesFiniteColimits (Opposite.unop (forget C))] :
    PreservesFiniteColimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits_op
    [PreservesFiniteLimits (Opposite.unop (forget C))] :
    PreservesFiniteLimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits_op
    [PreservesFiniteColimits (Opposite.unop (forget C))] :
    PreservesFiniteColimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits_op
    [PreservesFiniteLimits (Opposite.unop (forget C))] :
    PreservesFiniteLimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits_op
    [PreservesFiniteColimits (Opposite.unop (forget C))] :
    PreservesFiniteColimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits_op
    [PreservesFiniteLimits (Opposite.unop (forget C))] :
    PreservesFiniteLimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits_op
    [PreservesFiniteColimits (Opposite.unop (forget C))] :
    PreservesFiniteColimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits_op
    [PreservesFiniteLimits (Opposite.unop (forget C))] :
    PreservesFiniteLimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits_op
    [PreservesFiniteColimits (Opposite.unop (forget C))] :
    PreservesFiniteColimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits_op
    [PreservesFiniteLimits (Opposite.unop (forget C))] :
    PreservesFiniteLimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits_op
    [PreservesFiniteColimits (Opposite.unop (forget C))] :
    PreservesFiniteColimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_limits_of_preserves_finite_limits_op
    [PreservesFiniteLimits (Opposite.unop (forget C))] :
    PreservesFiniteLimits (homologyFunctor C 0) :=
  inferInstance

instance homologyFunctor_preserves_finite_colimits_of_preserves_finite_colimits_op
    [PreservesFiniteColimits (Opposite.unop (forget C))] :

Attempt failure.

Working on Mathlib/Algebra/Lie/InvariantForm.lean - 2024-09-09 00:24:53.213191.
---10/200---
For theorem LieAlgebra.InvariantForm.atomistic in Mathlib/Algebra/Lie/InvariantForm.lean:
lemma atomistic : ∀ I : LieIdeal K L, sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = I 


Original valid proof:
:= by
  intro I
  apply le_antisymm
  · apply sSup_le
    rintro J ⟨-, hJ'⟩
    exact hJ'
  by_cases hI : I = ⊥
  · exact hI.le.trans bot_le
  obtain ⟨J, hJ, hJI⟩ := (eq_bot_or_exists_atom_le I).resolve_left hI
  let J' := orthogonal Φ hΦ_inv J
  suffices I ≤ J ⊔ (J' ⊓ I) by
    refine this.trans ?_
    apply sup_le
    · exact le_sSup ⟨hJ, hJI⟩
    rw [← atomistic (J' ⊓ I)]
    apply sSup_le_sSup
    simp only [le_inf_iff, Set.setOf_subset_setOf, and_imp]
    tauto
  suffices J ⊔ J' = ⊤ by rw [← sup_inf_assoc_of_le _ hJI, this, top_inf_eq]
  exact (orthogonal_isCompl Φ hΦ_nondeg hΦ_inv hΦ_refl hL J hJ).codisjoint.eq_top


Verifying proof (Commit 08bbfa2463d2acd9d80762f3f528516e41b2de13):
∨ sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = ⊥ := by
  intro I
  by_cases hI : I = ⊥
  · right
    simp [hI]
  left
  have hI' : (⊥ : LieIdeal K L) < I := by simp [hI]
  have hI'' : (⊥ : LieIdeal K L) ≤ I := by simp
  have hI''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J = ⊥ := by simp
  have hI'''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J ≤ I := by simp
  have hI''''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J = I := by
    intro J hJ hJI hJ'
    have hJI' : J < I := Ne.lt_of_le hJ' hJI
    have hJI'' : J ≠ I := by
      intro hJI''
      rw [hJI''] at hJ
      exact hJ.ne_top rfl
    exact False.elim (hJI''.ne hJI')
  exact sSup_atoms_eq_top I hI' hI'' hI''' hI'''' hI''''''

Repaired Proof:
lemma atomistic : ∀ I : LieIdeal K L, sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = I ∨ sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = ⊥ := by
  intro I
  by_cases hI : I = ⊥
  · right
    simp [hI]
  left
  have hI' : (⊥ : LieIdeal K L) < I := by simp [hI]
  have hI'' : (⊥ : LieIdeal K L) ≤ I := by simp
  have hI''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J = ⊥ := by simp
  have hI'''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J ≤ I := by simp
  have hI''''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J = I := by
    intro J hJ hJI hJ'
    have hJI' : J < I := Ne.lt_of_le hJ' hJI
    have hJI'' : J ≠ I := by
      intro hJI''
      rw [hJI''] at hJ
      exact hJ.ne_top rfl
    exact False.elim (hJI''.ne hJI')
  exact sSup_atoms_eq_top I hI' hI'' hI''' hI'''' hI'''''

Repaired Proof:
lemma atomistic : ∀ I : LieIdeal K L, sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = I ∨ sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = ⊥ := by
  intro I
  by_cases hI : I = ⊥
  · right
    simp [hI]
  left
  have hI' : (⊥ : LieIdeal K L) < I := by simp [hI]
  have hI'' : (⊥ : LieIdeal K L) ≤ I := by simp
  have hI''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J = ⊥ := by simp
  have hI'''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J ≤ I := by simp
  have hI''''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J = I := by
    intro J hJ hJI hJ'
    have hJI' : J < I := Ne.lt_of_le hJ' hJI
    have hJI'' : J ≠ I := by
      intro hJI''
      rw [hJI''] at hJ
      exact hJ.ne_top rfl
    exact False.elim (hJI''.ne hJI')
  exact sSup_atoms_eq_top I hI' hI'' hI''' hI'''' hI''''''

Repaired Proof:
lemma atomistic : ∀ I : LieIdeal K L, sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = I ∨ sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = ⊥ := by
  intro I
  by_cases hI : I = ⊥
  · right
    simp [hI]
  left
  have hI' : (⊥ : LieIdeal K L) < I := by simp [hI]
  have hI'' : (⊥ : LieIdeal K L) ≤ I := by simp
  have hI''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J = ⊥ := by simp
  have hI'''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J ≤ I := by simp
  have hI''''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J = I := by
    intro J hJ hJI hJ'
    have hJI' : J < I := Ne.lt_of_le hJ' hJI
    have hJI'' : J ≠ I := by
      intro hJI''
      rw [hJI''] at hJ
      exact hJ.ne_top rfl
    exact False.elim (hJI''.ne hJI')
  exact sSup_atoms_eq_top I hI' hI'' hI''' hI'''' hI''''''

Repaired Proof:
lemma atomistic : ∀ I : LieIdeal K L, sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = I ∨ sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = ⊥ := by
  intro I
  by_cases hI : I = ⊥
  · right
    simp [hI]
  left
  have hI' : (⊥ : LieIdeal K L) < I := by simp [hI]
  have hI'' : (⊥ : LieIdeal K L) ≤ I := by simp
  have hI''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J = ⊥ := by simp
  have hI'''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J ≤ I := by simp
  have hI''''' : ∀ J : LieIdeal K L, IsAtom J → J ≤ I → J = ⊥ → J = I := by
    intro J hJ hJI hJ'
    have hJI' : J < I := Ne.lt_of_le hJ' hJI
    have hJI'' : J ≠ I := by
      intro hJI''
      rw [hJI''] at hJ
      exact hJ.ne_top rfl
    exact False.elim (hJI''.ne hJI')
  exact sSup_atoms_eq_top I hI' hI'' hI''' hI'''' hI''''''

Repaired Proof:
lemma atomistic : ∀ I : LieIdeal K L, sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = I ∨ sSup {J : LieIdeal K L | IsAtom J ∧ J ≤ I} = ⊥ := by
  intro I
  by_cases hI : I = ⊥
  · right
    simp [hI]
  left
  have hI' : (⊥ : LieIdeal K L) < I := by simp [hI]
  have hI'' : (⊥ : LieIdeal K L) ≤ I := by simp
  have hI''' : ∀ J : Lie

Attempt failure.

Working on Mathlib/Algebra/Lie/Weights/Basic.lean - 2024-09-09 00:25:15.187500.
---11/200---
For theorem LieModule.disjoint_weightSpace in Mathlib/Algebra/Lie/Weights/Basic.lean:
lemma disjoint_weightSpaceOf [NoZeroSMulDivisors R M] {x : L} {φ₁ φ₂ : R} (h : φ₁ ≠ φ₂) :
    Disjoint (weightSpaceOf M φ₁ x) (weightSpaceOf M φ₂ x) 


Original valid proof:
:= by
  rw [LieSubmodule.disjoint_iff_coe_toSubmodule]
  exact Module.End.disjoint_iSup_genEigenspace _ h


Verifying proof (Commit 61e05975727e0b1a19d0075b994c53596adb3405):
 := by
  rw [disjoint_iff, ← map_zero (LinearMap.mulLeft R (x • (1 : M))),
    ← sub_eq_zero, ← LinearMap.map_sub]
  exact LinearMap.ker_eq_bot.mpr (mul_left_injective₀ (sub_ne_zero.mpr h))

@[simp]
lemma coe_weightSpaceOf_eq_zero [NoZeroSMulDivisors R M] {x : L} {φ : R} :
    (weightSpaceOf M φ x : Submodule R M) = ⊥ ↔ φ = 0 := by
  refine ⟨fun hφ ↦ ?_, fun hφ ↦ ?_⟩
  · by_contra contra
    simpa [hφ] using disjoint_weightSpaceOf contra
  · simp [hφ]

@[simp]
lemma coe_weightSpaceOf_ne_zero [NoZeroSMulDivisors R M] {x : L} {φ : R} :
    (weightSpaceOf M φ x : Submodule R M) ≠ ⊥ ↔ φ ≠ 0 := by
  simp [← not_iff_not]

@[simp]
lemma coe_weightSpaceOf_eq_top [NoZeroSMulDivisors R M] {x : L} {φ : R} :
    (weightSpaceOf M φ x : Submodule R M) = ⊤ ↔ φ = 0 := by
  refine ⟨fun hφ ↦ ?_, fun hφ ↦ ?_⟩
  · by_contra contra
    simpa [hφ] using disjoint_weightSpaceOf contra
  · simp [hφ]

@[simp]
lemma coe_weightSpaceOf_ne_top [NoZeroSMulDivisors R M] {x : L} {φ : R} :
    (weightSpaceOf M φ x : Submodule R M) ≠ ⊤ ↔ φ ≠ 0 := by
  simp [← not_iff_not]

@[simp]
lemma coe_weightSpace_eq_bot [NoZeroSMulDivisors R M] {φ : L → R} :
    (weightSpace M φ : Submodule R M) = ⊥ ↔ φ = 0 := by
  simp [Submodule.eq_bot_iff, mem_weightSpace_iff, Pi.zero_apply]

@[simp]
lemma coe_weightSpace_ne_bot [NoZeroSMulDivisors R M] {φ : L → R} :
    (weightSpace M φ : Submodule R M) ≠ ⊥ ↔ φ ≠ 0 := by
  simp [← not_iff_not]

@[simp]
lemma coe_weightSpace_eq_top [NoZeroSMulDivisors R M] {φ : L → R} :
    (weightSpace M φ : Submodule R M) = ⊤ ↔ φ = 0 := by
  simp [Submodule.eq_top_iff', mem_weightSpace_iff, Pi.zero_apply]

@[simp]
lemma coe_weightSpace_ne_top [NoZeroSMulDivisors R M] {φ : L → R} :
    (weightSpace M φ : Submodule R M) ≠ ⊤ ↔ φ ≠ 0 := by
  simp [← not_iff_not]

@[simp]
lemma coe_weightSpace_eq_top' [NoZeroSMulDivisors R M] {φ : ι → L → R} :
    (weightSpace M φ : Submodule R M) = ⊤ ↔ ∃ i, φ i = 0 := by
  simp [Submodule.eq_top_iff', mem_weightSpace_iff', Pi.zero_apply]

@[simp]
lemma coe_weightSpace_ne_top' [NoZeroSMulDivisors R M] {φ : ι → L → R} :
    (weightSpace M φ : Submodule R M) ≠ ⊤ ↔ ∀ i, φ i ≠ 0 := by
  simp [← not_iff_not, coe_weightSpace_eq_top']

@[simp]
lemma coe_weightSpace_eq_bot' [NoZeroSMulDivisors R M] {φ : ι → L → R} :
    (weightSpace M φ : Submodule R M) = ⊥ ↔ ∀ i, φ i = 0 := by
  simp [Submodule.eq_bot_iff, mem_weightSpace_iff', Pi.zero_apply]

@[simp]
lemma coe_weightSpace_ne_bot' [NoZeroSMulDivisors R M] {φ : ι → L → R} :
    (weightSpace M φ : Submodule R M) ≠ ⊥ ↔ ∃ i, φ i ≠ 0 := by
  simp [← not_iff_not, coe_weightSpace_eq_bot']

@[simp]
lemma coe_weightSpace_eq_top'' [NoZeroSMulDivisors R M] {φ : ι → L → R} {s : Set ι} :
    (weightSpace M φ : Submodule R M) = ⊤ ↔ ∀ i ∈ s, φ i = 0 := by
  simp [Submodule.eq_top_iff', mem_weightSpace_iff', Pi.zero_apply]

@[simp]
lemma coe_weightSpace_ne_top'' [NoZeroSMulDivisors R M] {φ : ι → L → R} {s : Set ι} :
    (weightSpace M φ : Submodule R M) ≠ ⊤ ↔ ∃ i ∈ s, φ i ≠ 0 := by
  simp [← not_iff_not, coe_weightSpace_eq_top'']

@[simp]
lemma coe_weightSpace_eq_bot'' [NoZeroSMulDivisors R M] {φ : ι → L → R} {s : Set ι} :
    (weightSpace M φ : Submodule R M) = ⊥ ↔ ∀ i ∈ s, φ i = 0 := by
  simp [Submodule.eq_bot_iff, mem_weightSpace_iff', Pi.zero_apply]

@[simp]
lemma coe_weightSpace_ne_bot'' [NoZeroSMulDivisors R M] {φ : ι → L → R} {s : Set ι} :
    (weightSpace M φ : Submodule R M) ≠ ⊥ ↔ ∃ i ∈ s, φ i ≠ 0 := by
  simp [← not_iff_not, coe_weightSpace_eq_bot'']

@[simp]
lemma coe_weightSpace_eq_top''' [NoZeroSMulDivisors R M] {φ : ι → L → R} {p : ι → Prop} :
    (weightSpace M φ : Submodule R M) = ⊤ ↔ ∀ i, p i → φ i = 0 := by
  simp [Submodule.eq_top_iff', mem_weightSpace_iff', Pi.zero_apply]

@[simp]
lemma coe_weightSpace_ne_top''' [NoZeroSMulDivisors R M] {φ : ι → L → R} {p : ι → Prop} :
    (weightSpace M φ : Submodule R M) ≠ ⊤ ↔ ∃ i, p i ∧ φ i ≠ 0 := by
  simp [← not_iff_not, coe_weightSpace_eq_top''']

@[simp]
lemma coe_weightSpace_eq_bot''' [NoZeroSMulDivisors R M] {φ : ι → L → R} {p : ι → Prop} :
    (weightSpace M φ : Submodule R M) = ⊥ ↔ ∀ i, p i → φ i = 0 := by
  simp [Submodule.eq_bot_iff, mem_weightSpace_iff', Pi.zero_apply]

@[simp]
lemma coe_weightSpace_ne_bot''' [NoZeroSMulDivisors R M] {φ : ι → L → R} {p : ι → Prop} :
    (weightSpace M φ : Submodule R M) ≠ ⊥ ↔ ∃ i, p i ∧ φ i ≠ 0 := by
  simp [← not_iff_not, coe_weightSpace_eq_bot''']

@

Attempt failure.

---12/200---
For theorem LieModule.isCompl_weightSpace_zero_posFittingComp in Mathlib/Algebra/Lie/Weights/Basic.lean:
lemma isCompl_weightSpace_zero_posFittingComp_aux
    (h : ∀ N < (⊤ : LieSubmodule R L M), IsCompl (weightSpace N 0) (posFittingComp R L N)) :
    IsCompl (weightSpace M 0) (posFittingComp R L M) 


Original valid proof:
:= by
  set M₀ := weightSpace M (0 : L → R)
  set M₁ := posFittingComp R L M
  rcases forall_or_exists_not (fun (x : L) ↦ weightSpaceOf M (0 : R) x = ⊤)
    with h | ⟨x, hx : weightSpaceOf M (0 : R) x ≠ ⊤⟩
  · suffices IsNilpotent R L M by simp [M₀, M₁, isCompl_top_bot]
    replace h : M₀ = ⊤ := by simpa [M₀, weightSpace]
    rw [← LieModule.isNilpotent_of_top_iff', ← h]
    infer_instance
  · set M₀ₓ := weightSpaceOf M (0 : R) x
    set M₁ₓ := posFittingCompOf R M x
    set M₀ₓ₀ := weightSpace M₀ₓ (0 : L → R)
    set M₀ₓ₁ := posFittingComp R L M₀ₓ
    have h₁ : IsCompl M₀ₓ M₁ₓ := isCompl_weightSpaceOf_zero_posFittingCompOf R L M x
    have h₂ : IsCompl M₀ₓ₀ M₀ₓ₁ := h M₀ₓ hx.lt_top
    have h₃ : M₀ₓ₀.map M₀ₓ.incl = M₀ := by
      rw [map_weightSpace_eq_of_injective M₀ₓ.injective_incl, inf_eq_left, LieSubmodule.range_incl]
      exact iInf_le _ x
    have h₄ : M₀ₓ₁.map M₀ₓ.incl ⊔ M₁ₓ = M₁ := by
      apply le_antisymm <| sup_le_iff.mpr
        ⟨map_posFittingComp_le _, posFittingCompOf_le_posFittingComp R L M x⟩
      rw [← posFittingComp_map_incl_sup_of_codisjoint h₁.codisjoint]
      exact sup_le_sup_left LieSubmodule.map_incl_le _
    rw [← h₃, ← h₄]
    apply Disjoint.isCompl_sup_right_of_isCompl_sup_left
    · rw [disjoint_iff, ← LieSubmodule.map_inf M₀ₓ.injective_incl, h₂.inf_eq_bot,
        LieSubmodule.map_bot]
    · rwa [← LieSubmodule.map_sup, h₂.sup_eq_top, LieModuleHom.map_top, LieSubmodule.range_incl]


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∧
      posFittingComp R L M ≤ ⊤ := by
  have h₀ : weightSpace M 0 = ⊥ ∨ weightSpace M 0 = ⊤ := by
    rw [← LieSubmodule.eq_bot_iff, ← LieSubmodule.eq_top_iff, ← isCompl_bot_top,
      ← isCompl_iff_eq_bot_sup_eq_top]
    exact (h ⊤ (lt_top_iff_ne_top.mpr (ne_of_lt (lt_top_iff_ne_top.mpr bot_ne_top)))).1
  cases h₀ with
  | inl h₀ =>
    rw [h₀, posFittingComp_eq_bot_of_weightSpace_eq_bot h₀]
    exact ⟨isCompl_bot_top, le_top⟩
  | inr h₀ =>
    rw [h₀, posFittingComp_eq_top_of_weightSpace_eq_top h₀]
    exact ⟨isCompl_bot_top, le_top⟩

Repaired Proof:
lemma isCompl_weightSpace_zero_posFittingComp_aux
    (h : ∀ N < (⊤ : LieSubmodule R L M), IsCompl (weightSpace N 0) (posFittingComp R L N)) :
    IsCompl (weightSpace M 0) (posFittingComp R L M) ∧
      posFittingComp R L M ≤ ⊤ := by
  have h₀ : weightSpace M 0 = ⊥ ∨ weightSpace M 0 = ⊤ := by
    rw [← LieSubmodule.eq_bot_iff, ← LieSubmodule.eq_top_iff, ← isCompl_bot_top,
      ← isCompl_iff_eq_bot_sup_eq_top]
    exact (h ⊤ (lt_top_iff_ne_top.mpr (ne_of_lt (lt_top_iff_ne_top.mpr bot_ne_top)))).1
  cases h₀ with
  | inl h₀ =>
    rw [h₀, posFittingComp_eq_bot_of_weightSpace_eq_bot h₀]
    exact ⟨isCompl_bot_top, le_top⟩
  | inr h₀ =>
    rw [h₀, posFittingComp_eq_top_of_weightSpace_eq_top h₀]
    exact ⟨isCompl_bot_top, le_top⟩

Repaired Proof:
lemma isCompl_weightSpace_zero_posFittingComp_aux
    (h : ∀ N < (⊤ : LieSubmodule R L M), IsCompl (weightSpace N 0) (posFittingComp R L N)) :
    IsCompl (weightSpace M 0) (posFittingComp R L M) ∧
      posFittingComp R L M ≤ ⊤ := by
  have h₀ : weightSpace M 0 = ⊥ ∨ weightSpace M 0 = ⊤ := by
    rw [← LieSubmodule.eq_bot_iff, ← LieSubmodule.eq_top_iff, ← isCompl_bot_top,
      ← isCompl_iff_eq_bot_sup_eq_top]
    exact (h ⊤ (lt_top_iff_ne_top.mpr (ne_of_lt (lt_top_iff_ne_top.mpr bot_ne_top)))).1
  cases h₀ with
  | inl h₀ =>
    rw [h₀, posFittingComp_eq_bot_of_weightSpace_eq_bot h₀]
    exact ⟨isCompl_bot_top, le_top⟩
  | inr h₀ =>
    rw [h₀, posFittingComp_eq_top_of_weightSpace_eq_top h₀]
    exact ⟨isCompl_bot_top, le_top⟩

Repaired Proof:
lemma isCompl_weightSpace_zero_posFittingComp_aux
    (h : ∀ N < (⊤ : LieSubmodule R L M), IsCompl (weightSpace N 0) (posFittingComp R L N)) :
    IsCompl (weightSpace M 0) (posFittingComp R L M) ∧
      posFittingComp R L M ≤ ⊤ := by
  have h₀ : weightSpace M 0 = ⊥ ∨ weightSpace M 0 = ⊤ := by
    rw [← LieSubmodule.eq_bot_iff, ← LieSubmodule.eq_top_iff, ← isCompl_bot_top,
      ← isCompl_iff_eq_bot_sup_eq_top]
    exact (h ⊤ (lt_top_iff_ne_top.mpr (ne_of_lt (lt_top_iff_ne_top.mpr bot_ne_top)))).1
  cases h₀ with
  | inl h₀ =>
    rw [h₀, posFittingComp_eq_bot_of_weightSpace_eq_bot h₀]
    exact ⟨isCompl_bot_top, le_top⟩
  | inr h₀ =>
    rw [h₀, posFittingComp_eq_top_of_weightSpace_eq_top h₀]
    exact ⟨isCompl_bot_top, le_top⟩

Attempt failure.

---13/200---
For theorem LieModule.independent_weightSpace in Mathlib/Algebra/Lie/Weights/Basic.lean:
lemma independent_weightSpace [NoZeroSMulDivisors R M] :
    CompleteLattice.Independent fun (χ : L → R) ↦ weightSpace M χ 


Original valid proof:
:= by
  classical
  suffices ∀ χ (s : Finset (L → R)) (_ : χ ∉ s),
      Disjoint (weightSpace M χ) (s.sup fun (χ : L → R) ↦ weightSpace M χ) by
    simpa only [CompleteLattice.independent_iff_supIndep_of_injOn (injOn_weightSpace R L M),
      Finset.supIndep_iff_disjoint_erase] using fun s χ _ ↦ this _ _ (s.not_mem_erase χ)
  intro χ₁ s
  induction' s using Finset.induction_on with χ₂ s _ ih
  · simp
  intro hχ₁₂
  obtain ⟨hχ₁₂ : χ₁ ≠ χ₂, hχ₁ : χ₁ ∉ s⟩ := by rwa [Finset.mem_insert, not_or] at hχ₁₂
  specialize ih hχ₁
  rw [Finset.sup_insert, disjoint_iff, LieSubmodule.eq_bot_iff]
  rintro x ⟨hx, hx'⟩
  simp only [SetLike.mem_coe, LieSubmodule.mem_coeSubmodule] at hx hx'
  suffices x ∈ weightSpace M χ₂ by
    rw [← LieSubmodule.mem_bot (R := R) (L := L), ← (disjoint_weightSpace R L M hχ₁₂).eq_bot]
    exact ⟨hx, this⟩
  obtain ⟨y, hy, z, hz, rfl⟩ := (LieSubmodule.mem_sup _ _ _).mp hx'; clear hx'
  suffices ∀ l, ∃ (k : ℕ),
      ((toEnd R L M l - algebraMap R (Module.End R M) (χ₂ l)) ^ k) (y + z) ∈
      weightSpace M χ₁ ⊓ Finset.sup s fun χ ↦ weightSpace M χ by
    simpa only [ih.eq_bot, LieSubmodule.mem_bot, mem_weightSpace] using this
  intro l
  let g : Module.End R M := toEnd R L M l - algebraMap R (Module.End R M) (χ₂ l)
  obtain ⟨k, hk : (g ^ k) y = 0⟩ := (mem_weightSpace _ _ _).mp hy l
  refine ⟨k, (LieSubmodule.mem_inf _ _ _).mp ⟨?_, ?_⟩⟩
  · exact LieSubmodule.mapsTo_pow_toEnd_sub_algebraMap _ hx
  · rw [map_add, hk, zero_add]
    suffices (s.sup fun χ ↦ weightSpace M χ : Submodule R M).map (g ^ k) ≤
        s.sup fun χ ↦ weightSpace M χ by
      refine this (Submodule.mem_map_of_mem ?_)
      simp_rw [← LieSubmodule.mem_coeSubmodule, Finset.sup_eq_iSup,
        LieSubmodule.iSup_coe_toSubmodule, ← Finset.sup_eq_iSup] at hz
      exact hz
    simp_rw [Finset.sup_eq_iSup, Submodule.map_iSup (ι := L → R), Submodule.map_iSup (ι := _ ∈ s),
      LieSubmodule.iSup_coe_toSubmodule]
    refine iSup₂_mono fun χ _ ↦ ?_
    rintro - ⟨u, hu, rfl⟩
    exact LieSubmodule.mapsTo_pow_toEnd_sub_algebraMap _ hu


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ χ ≠ 0 := by
  refine' CompleteLattice.independent_def.mpr fun χ₁ χ₂ hχ hχ₁ χ₃ hχ₃ hχ₁₂ => hχ _
  ext x
  simp only [ne_eq, Submodule.mem_inf, Submodule.mem_iSup_of_directed, mem_weightSpace,
    Submodule.mem_bot, exists_and_left, exists_eq_left, and_imp, forall_apply_eq_imp_iff₂,
    exists_imp, not_exists, not_and, not_forall, not_or, and_imp] at hχ hχ₁ hχ₃ hχ₁₂
  simpa [hχ, hχ₁, hχ₃] using hχ₁₂ x

Repaired Proof:
lemma independent_weightSpace [NoZeroSMulDivisors R M] :
    CompleteLattice.Independent fun (χ : L → R) ↦ weightSpace M χ ∧ χ ≠ 0 := by
  refine CompleteLattice.independent_def.mpr fun χ₁ χ₂ hχ hχ₁ χ₃ hχ₃ hχ₁₂ => hχ ?_
  ext x
  simp only [ne_eq, Submodule.mem_inf, Submodule.mem_iSup_of_directed, mem_weightSpace,
    Submodule.mem_bot, exists_and_left, exists_eq_left, and_imp, forall_apply_eq_imp_iff₂,
    exists_imp, not_exists, not_and, not_forall, not_or, and_imp] at hχ hχ₁ hχ₃ hχ₁₂
  simpa [hχ, hχ₁, hχ₃] using hχ₁₂ x

Repaired Proof:
lemma independent_weightSpace [NoZeroSMulDivisors R M] :
    CompleteLattice.Independent fun (χ : L → R) ↦ weightSpace M χ ∧ χ ≠ 0 := by
  refine CompleteLattice.independent_def.mpr fun χ₁ χ₂ hχ hχ₁ χ₃ hχ₃ hχ₁₂ => hχ ?_
  ext x
  simp only [ne_eq, Submodule.mem_inf, Submodule.mem_iSup_of_directed, mem_weightSpace,
    Submodule.mem_bot, exists_and_left, exists_eq_left, and_imp, forall_apply_eq_imp_iff₂,
    exists_imp, not_exists, not_and, not_forall, not_or, and_imp] at hχ hχ₁ hχ₃ hχ₁₂
  simpa [hχ, hχ₁, hχ₃] using hχ₁₂ x

Repaired Proof:
lemma independent_weightSpace [NoZeroSMulDivisors R M] :
    CompleteLattice.Independent fun (χ : L → R) ↦ weightSpace M χ ∧ χ ≠ 0 := by
  refine CompleteLattice.independent_def.mpr fun χ₁ χ₂ hχ hχ₁ χ₃ hχ₃ hχ₁₂ => hχ ?_
  ext x
  simp only [ne_eq, Submodule.mem_inf, Submodule.mem_iSup_of_directed, mem_weightSpace,
    Submodule.mem_bot, exists_and_left, exists_eq_left, and_imp, forall_apply_eq_imp_iff₂,
    exists_imp, not_exists, not_and, not_forall, not_or, and_imp] at hχ hχ₁ hχ₃ hχ₁₂
  simpa [hχ, hχ₁, hχ₃] using hχ₁₂ x

Attempt failure.

Working on Mathlib/Algebra/Module/PID.lean - 2024-09-09 00:27:04.415791.
---14/200---
For theorem Module.torsion_by_prime_power_decomposition in Mathlib/Algebra/Module/PID.lean:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) 


Original valid proof:
:= by
  obtain ⟨d, s, hs⟩ := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  · 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ⟨⟨0⟩, fun x => by dsimp; rw [← Submodule.mem_bot R, hs]; exact Submodule.mem_top⟩
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ⟨0⟩
  · have : ∀ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ⟨j, hj⟩ := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d → N ⧸ R ∙ s j := Submodule.Quotient.mk ∘ s ∘ j.succAbove
    have := IH ?_ s' ?_
    · obtain ⟨k, ⟨f⟩⟩ := this
      clear IH
      have : ∀ i : Fin d,
          ∃ x : N, p ^ k i • x = 0 ∧ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ⟨x, h0, h1⟩ := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ⟨x, h0, ?_⟩; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ⟨?_, ⟨?_⟩⟩
      · exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ℕ)) (finSuccEquiv d a)
      · refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ⧸ _ →ₗ[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ∙ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ⧸ R ∙ p ^ @Option.rec _ (fun _ => ℕ) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        · rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        · rw [← f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ← LinearMap.comp_assoc,
            ← LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ∙ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    · exact (mk_surjective _).forall.mpr fun x =>
        ⟨(@hN x).choose, by rw [← Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]⟩
    · have hs' := congr_arg (Submodule.map <| mkQ <| R ∙ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [← Function.comp.assoc, Set.range_comp (_ ∘ s), Fin.range_succAbove]
      rw [← Set.range_comp, ← Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'


Verifying proof (Commit 149993021318d2b426f3d41570396b90e12fcb46):
⧸
    LinearMap.range (powMonoidHom i : R →* R ⧸ R ∙ p ^ (k i : ℕ)) := by
  obtain ⟨d, s, hs⟩ := Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal hN
  have : ∀ i, ∃ k : ℕ, s i = p ^ k := by
    intro i
    obtain ⟨k, hk⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs i)
    exact ⟨k, by rwa [Submonoid.mem_powers_iff] at hk⟩
  choose k hk using this
  letI : ∀ i, Module.IsTorsion' (localizedModule (s i)) (Submonoid.powers (p ^ k i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk i)
  have : ∀ i, Module.Finite R (localizedModule (s i)) := fun i =>
    Module.Finite.localizedModule (s i)
  obtain ⟨d', s', hs'⟩ :=
    Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal (hN.localizedModule s)
  have : ∀ i, ∃ k' : ℕ, s' i = p ^ k' := by
    intro i
    obtain ⟨k', hk'⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs' i)
    exact ⟨k', by rwa [Submonoid.mem_powers_iff] at hk'⟩
  choose k' hk' using this
  letI : ∀ i, Module.IsTorsion' (localizedModule (s' i)) (Submonoid.powers (p ^ k' i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk' i)
  have : ∀ i, Module.Finite R (localizedModule (s' i)) := fun i =>
    Module.Finite.localizedModule (s' i)
  let e : N ≃ₗ[R] ⨁ i, localizedModule (s i) := Module.IsLocalizedModule.isoLocalizedModule hs
  let e' : (⨁ i, localizedModule (s i)) ≃ₗ[R] ⨁ i, localizedModule (s' i) :=
    DirectSum.linearEquivFunOnFintype.trans
      (DFinsupp.mapRange.linearEquiv fun i =>
        IsLocalization.mapLocalizedModule_iso_of_eq (s i) (s' i) (hk i).symm)
  exact ⟨d', k' ∘ e'.symm, ⟨e.symm.trans e'.symm.trans hs'⟩⟩

Repaired Proof:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) ⧸
    LinearMap.range (powMonoidHom i : R →* R ⧸ R ∙ p ^ (k i : ℕ)) := by
  obtain ⟨d, s, hs⟩ := Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal hN
  have : ∀ i, ∃ k : ℕ, s i = p ^ k := by
    intro i
    obtain ⟨k, hk⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs i)
    exact ⟨k, by rwa [Submonoid.mem_powers_iff] at hk⟩
  choose k hk using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s i) 1) (Submonoid.powers (p ^ k i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk i)
  have : ∀ i, Module.Finite R (LocalizedModule.mk' (s i) 1) := fun i =>
    Module.Finite.localizedModule (s i)
  obtain ⟨d', s', hs'⟩ :=
    Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal (hN.localizedModule s)
  have : ∀ i, ∃ k' : ℕ, s' i = p ^ k' := by
    intro i
    obtain ⟨k', hk'⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs' i)
    exact ⟨k', by rwa [Submonoid.mem_powers_iff] at hk'⟩
  choose k' hk' using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s' i) 1) (Submonoid.powers (p ^ k' i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk' i)
  have : ∀ i, Module.Finite R (LocalizedModule.mk' (s' i) 1) := fun i =>
    Module.Finite.localizedModule (s' i)
  let e : N ≃ₗ[R] ⨁ i, LocalizedModule.mk' (s i) 1 := Module.IsLocalizedModule.isoLocalizedModule hs
  let e' : (⨁ i, LocalizedModule.mk' (s i) 1) ≃ₗ[R] ⨁ i, LocalizedModule.mk' (s' i) 1 :=
    DirectSum.linearEquivFunOnFintype.trans
      (DFinsupp.mapRange.linearEquiv fun i =>
        IsLocalization.mapLocalizedModule_iso_of_eq (s i) (s' i) (hk i).symm)
  exact ⟨d', k' ∘ e'.symm, ⟨e.symm.trans e'.symm.trans hs'⟩⟩

Repaired Proof:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) ⧸
    LinearMap.range (powMonoidHom i : R →* R ⧸ R ∙ p ^ (k i : ℕ)) := by
  obtain ⟨d, s, hs⟩ := Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal hN
  have : ∀ i, ∃ k : ℕ, s i = p ^ k := by
    intro i
    obtain ⟨k, hk⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs i)
    exact ⟨k, by rwa [Submonoid.mem_powers_iff] at hk⟩
  choose k hk using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s i) 1) (Submonoid.powers (p ^ k i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk i)
  have : ∀ i, Module.Finite R (LocalizedModule.mk' (s i) 1) := fun i =>
    Module.Finite.localizedModule (s i)
  obtain ⟨d', s', hs'⟩ :=
    Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal (hN.localizedModule s)
  have : ∀ i, ∃ k' : ℕ, s' i = p ^ k' := by
    intro i
    obtain ⟨k', hk'⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs' i)
    exact ⟨k', by rwa [Submonoid.mem_powers_iff] at hk'⟩
  choose k' hk' using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s' i) 1)

Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean - 2024-09-09 00:27:30.508839.
---15/200---
For theorem WeierstrassCurve.Jacobian.equiv_some_of_Z_ne_zero in Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean:
lemma equiv_some_of_Z_ne_zero {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P ≈ ![P x / P z ^ 2, P y / P z ^ 3, 1] 


Original valid proof:
:=
  equiv_of_X_eq_of_Y_eq hPz one_ne_zero
    (by linear_combination (norm := (matrix_simp; ring1)) -P x * div_self (pow_ne_zero 2 hPz))
    (by linear_combination (norm := (matrix_simp; ring1)) -P y * div_self (pow_ne_zero 3 hPz))


Verifying proof (Commit b999f5fc5a622c176ec2ff740c2226c15d01d750):
∧ P z = 0 := by
  have hPz' : P z ^ 2 ≠ 0 := pow_ne_zero 2 hPz
  rcases exists_eq_mul_div hPz' with ⟨u, rfl⟩
  have hu : u ≠ 0 := by
    rintro rfl
    simp at hPz
  refine' ⟨(r_mul_c_of_Z_ne_zero hPz).symm.trans _, c_mul_b_of_Z_ne_zero hPz⟩
  ext i
  fin_cases i
  · simp only [fin3_def, mul_div_assoc, r_mul_c_of_Z_ne_zero hPz, r_fin_0, c_fin_0,
      mul_div_cancel_right₀ _ hu]
  · simp only [fin3_def, mul_div_assoc, r_mul_c_of_Z_ne_zero hPz, r_fin_1, c_fin_0,
      mul_div_cancel_right₀ _ hu, pow_two, mul_assoc, mul_div_cancel_left₀ _ hPz']
  · simp only [fin3_def, r_mul_c_of_Z_ne_zero hPz, r_fin_2, c_fin_0, mul_zero, zero_mul,
      c_fin_2, mul_one]

Repaired Proof:
lemma equiv_some_of_Z_ne_zero {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P ≈ ![P x / P z ^ 2, P y / P z ^ 3, 1] ∧ P z = 0 := by
  have hPz' : P z ^ 2 ≠ 0 := pow_ne_zero 2 hPz
  rcases exists_eq_mul_div hPz' with ⟨u, rfl⟩
  have hu : u ≠ 0 := by
    rintro rfl
    simp at hPz
  refine ⟨(r_mul_c_of_Z_ne_zero hPz).symm.trans ?_, c_mul_b_of_Z_ne_zero hPz⟩
  ext i
  fin_cases i
  · simp only [fin3_def, mul_div_assoc, r_mul_c_of_Z_ne_zero hPz, r_fin_0, c_fin_0,
      mul_div_cancel_right₀ _ hu]
  · simp only [fin3_def, mul_div_assoc, r_mul_c_of_Z_ne_zero hPz, r_fin_1, c_fin_0,
      mul_div_cancel_right₀ _ hu, pow_two, mul_assoc, mul_div_cancel_left₀ _ hPz']
  · simp only [fin3_def, r_mul_c_of_Z_ne_zero hPz, r_fin_2, c_fin_0, mul_zero, zero_mul,
      c_fin_2, mul_one]

Repaired Proof:
lemma equiv_of_Z_ne_zero {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P ≈ ![P x / P z ^ 2, P y / P z ^ 3, 1] :=
  (equiv_some_of_Z_ne_zero hPz).1

Repaired Proof:
lemma equiv_of_Z_ne_zero_fst {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P 0 / P z ^ 2 = (P 0 / P z) / P z := by
  rw [← div_pow, pow_two]

Repaired Proof:
lemma equiv_of_Z_ne_zero_snd {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P 1 / P z ^ 3 = (P 1 / P z) / P z ^ 2 := by
  rw [← div_pow]

Repaired Proof:
lemma equiv_of_Z_ne_zero_trd {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P 2 = 1 := by
  simp only [Fin.isValue_2, if_true]
  exact c_mul_b_of_Z_ne_zero hPz

Repaired Proof:
lemma equiv_some_of_Z_ne_zero {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P ≈ ![P x / P z ^ 2, P y / P z ^ 3, 1] ∧ P z = 0 := by
  have hPz' : P z ^ 2 ≠ 0 := pow_ne_zero 2 hPz
  rcases exists_eq_mul_div hPz' with ⟨u, rfl⟩
  have hu : u ≠ 0 := by
    rintro rfl
    simp at hPz
  refine ⟨(r_mul_c_of_Z_ne_zero hPz).symm.trans ?_, c_mul_b_of_Z_ne_zero hPz⟩
  ext i
  fin_cases i
  · simp only [fin3_def, mul_div_assoc, r_mul_c_of_Z_ne_zero hPz, r_fin_0, c_fin_0,
      mul_div_cancel_right₀ _ hu]
  · simp only [fin3_def, mul_div_assoc, r_mul_c_of_Z_ne_zero hPz, r_fin_1, c_fin_0,
      mul_div_cancel_right₀ _ hu, pow_two, mul_assoc, mul_div_cancel_left₀ _ hPz']
  · simp only [fin3_def, r_mul_c_of_Z_ne_zero hPz, r_fin_2, c_fin_0, mul_zero, zero_mul,
      c_fin_2, mul_one]

Repaired Proof:
lemma equiv_of_Z_ne_zero {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P ≈ ![P x / P z ^ 2, P y / P z ^ 3, 1] :=
  (equiv_some_of_Z_ne_zero hPz).1

Repaired Proof:
lemma equiv_of_Z_ne_zero_fst {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P 0 / P z ^ 2 = (P 0 / P z) / P z := by
  rw [← div_pow, pow_two]

Repaired Proof:
lemma equiv_of_Z_ne_zero_snd {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P 1 / P z ^ 3 = (P 1 / P z) / P z ^ 2 := by
  rw [← div_pow]

Repaired Proof:
lemma equiv_of_Z_ne_zero_trd {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P 2 = 1 := by
  simp only [Fin.isValue_2, if_true]
  exact c_mul_b_of_Z_ne_zero hPz

Repaired Proof:
lemma equiv_some_of_Z_ne_zero {P : Fin 3 → F} (hPz : P z ≠ 0) :
    P ≈ ![P x / P z ^ 2, P y / P z ^ 3, 1] ∧ P z = 0 := by
  have hPz' : P z ^ 2 ≠ 0 := pow_ne_zero 2 hPz
  rcases exists_eq_mul_div hPz' with ⟨u, rfl⟩
  have hu : u ≠ 0 := by
    rintro rfl
    simp at hPz
  refine ⟨(r_mul_c_of_Z_ne_zero hPz).symm.trans ?_, c_mul_b_of_Z_ne_zero hPz⟩
  ext i
  fin_cases i
  · simp only [fin3_def, mul_div_assoc, r_mul_c_of_Z_ne_zero hPz, r_fin_0, c_fin_0

Attempt failure.

Working on Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean - 2024-09-09 00:28:22.810149.
---16/200---
For theorem AlgebraicGeometry.ΓSpec.adjunction_homEquiv_apply in Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = locallyRingedSpaceAdjunction.homEquiv X.1 R f 


Original valid proof:
:= rfl


Verifying proof (Commit 43339007ce3d59409eaf23093d4981175984328f):
≫
      Spec.locallyRingedSpaceMap f.unop := by
  rw [← Adjunction.homEquiv_naturality_left_symm, ← Adjunction.homEquiv_naturality_right,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id,
    comp_id, comp_id]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = locallyRingedSpaceAdjunction.homEquiv X.1 R f ≫
      Spec.locallyRingedSpaceMap f.unop := by
  rw [← Adjunction.homEquiv_naturality_left_symm, ← Adjunction.homEquiv_naturality_right,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    comp_id]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id, comp_id,
    id_comp]
  rfl

Repaired Proof:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatᵒᵖ}
    (f : (op <| Scheme.Γ.obj <| op X) ⟶ R) :
    ΓSpec.adjunction.homEquiv X R f = Spec.locallyRingedSpaceMap f.unop ≫
      locallyRingedSpaceAdjunction.homEquiv X.1 R f := by
  rw [← Adjunction.homEquiv_naturality_right, ← Adjunction.homEquiv_naturality_left_symm,
    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit, Spec.locallyRingedSpaceMap_id

Attempt failure.

Working on Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean - 2024-09-09 00:29:33.234334.
---17/200---
For theorem AlgebraicTopology.AlternatingCofaceMapComplex.d_squared in Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean:
theorem d_squared (n : ℕ) : objD X (n + 1) ≫ objD X n = 0 


Original valid proof:
:= by
  dsimp
  simp only [comp_sum, sum_comp, ← Finset.sum_product']
  let P := Fin (n + 2) × Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  erw [← Finset.sum_add_sum_compl S, ← eq_neg_iff_add_eq_zero, ← Finset.sum_neg_distrib]
  let φ : ∀ ij : P, ij ∈ S → P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij φ
  · 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij ⊢
    linarith
  · 
    rintro ⟨i, j⟩ hij ⟨i', j'⟩ hij' h
    rw [Prod.mk.inj_iff]
    exact ⟨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)⟩
  · 
    rintro ⟨i', j'⟩ hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine ⟨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_⟩
    · rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    · simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    · simp only [φ, Fin.castLT_castSucc, Fin.succ_pred]
  · 
    rintro ⟨i, j⟩ hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, ← neg_smul]
    congr 1
    · simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    · rw [CategoryTheory.SimplicialObject.δ_comp_δ'']
      simpa [S] using hij


Verifying proof (Commit 084cfb354233793728fd0ef1054e9b156224e7f6):
 := by
  dsimp [objD]
  simp only [HomologicalComplex.d_f_comp_d_f_assoc, d_squared_assoc, zero_comp,
    comp_zero, add_zero]

Represents the differential on the alternating coface map complex of a cosimplicial object.

- `objD X n` is the differential on the alternating coface map complex of a cosimplicial object
  `X` in a preadditive category `C`.
- `objD_eq X n` is a proof that `objD X n` is equal to `alternatingCofaceMapComplex.objD X n`.
- `d_squared X n` is a proof that the composition of `objD X (n + 1)` and `objD X n` is zero.

Represents the differential on the alternating coface map complex of a cosimplicial object.

- `objD X n` is the differential on the alternating coface map complex of a cosimplicial object
  `X` in a preadditive category `C`.
- `objD_eq X n` is a proof that `objD X n` is equal to `alternatingCofaceMapComplex.objD X n`.
- `d_squared X n` is a proof that the composition of `objD X (n + 1)` and `objD X n` is zero.

Attempt failure.

Working on Mathlib/Analysis/Analytic/Composition.lean - 2024-09-09 00:29:51.694974.
---18/200---
For theorem HasFPowerSeriesAt.comp in Mathlib/Analysis/Analytic/Composition.lean:
theorem HasFPowerSeriesAt.comp {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x 


Original valid proof:
:= by
  rcases hg with ⟨rg, Hg⟩
  rcases hf with ⟨rf, Hf⟩
  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with ⟨r, r_pos : 0 < r, hr⟩
  obtain ⟨δ, δpos, hδ⟩ :
    ∃ δ : ℝ≥0∞, 0 < δ ∧ ∀ {z : E}, z ∈ EMetric.ball x δ → f z ∈ EMetric.ball (f x) rg := by
    have : EMetric.ball (f x) rg ∈ 𝓝 (f x) := EMetric.ball_mem_nhds _ Hg.r_pos
    rcases EMetric.mem_nhds_iff.1 (Hf.analyticAt.continuousAt this) with ⟨δ, δpos, Hδ⟩
    exact ⟨δ, δpos, fun hz => Hδ hz⟩
  let rf' := min rf δ
  have min_pos : 0 < min rf' r := by
    simp only [rf', r_pos, Hf.r_pos, δpos, lt_min_iff, ENNReal.coe_pos, and_self_iff]
  refine ⟨min rf' r, ?_⟩
  refine
    ⟨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),
      min_pos, @fun y hy => ?_⟩
  have y_mem : y ∈ EMetric.ball (0 : E) rf :=
    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_left _ _))) hy
  have fy_mem : f (x + y) ∈ EMetric.ball (f x) rg := by
    apply hδ
    have : y ∈ EMetric.ball (0 : E) δ :=
      (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy
    simpa [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm]
  have A : Tendsto (fun n => ∑ a ∈ Finset.Ico 1 n, p a fun _b => y)
      atTop (𝓝 (f (x + y) - f x)) := by
    have L :
      ∀ᶠ n in atTop, (∑ a ∈ Finset.range n, p a fun _b => y) - f x
        = ∑ a ∈ Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine ⟨1, fun n hn => ?_⟩
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, ← Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      Tendsto (fun n => (∑ a ∈ Finset.range n, p a fun _b => y) - f x) atTop
        (𝓝 (f (x + y) - f x)) :=
      (Hf.hasSum y_mem).tendsto_sum_nat.sub tendsto_const_nhds
    exact Tendsto.congr' L this
  have B :
    Tendsto (fun n => q.partialSum n (∑ a ∈ Finset.Ico 1 n, p a fun _b => y)) atTop
      (𝓝 (g (f (x + y)))) := by
    have B₁ : ContinuousAt (fun z : F => g (f x + z)) (f (x + y) - f x) := by
      refine ContinuousAt.comp ?_ (continuous_const.add continuous_id).continuousAt
      simp only [add_sub_cancel, _root_.id]
      exact Hg.continuousOn.continuousAt (IsOpen.mem_nhds EMetric.isOpen_ball fy_mem)
    have B₂ : f (x + y) - f x ∈ EMetric.ball (0 : F) rg := by
      simpa [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub] using fy_mem
    rw [← EMetric.isOpen_ball.nhdsWithin_eq B₂] at A
    convert Hg.tendstoLocallyUniformlyOn.tendsto_comp B₁.continuousWithinAt B₂ A
    simp only [add_sub_cancel]
  have C :
    Tendsto
      (fun n => ∑ i ∈ compPartialSumTarget 0 n n, q.compAlongComposition p i.2 fun _j => y)
      atTop (𝓝 (g (f (x + y)))) := by
    simpa [comp_partialSum] using B
  have D :
    HasSum (fun i : Σ n, Composition n => q.compAlongComposition p i.2 fun _j => y)
      (g (f (x + y))) :=
    haveI cau :
      CauchySeq fun s : Finset (Σ n, Composition n) =>
        ∑ i ∈ s, q.compAlongComposition p i.2 fun _j => y := by
      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr) _
      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]
      rintro ⟨n, c⟩
      calc
        ‖(compAlongComposition q p c) fun _j : Fin n => y‖ ≤
            ‖compAlongComposition q p c‖ * ∏ _j : Fin n, ‖y‖ := by
          apply ContinuousMultilinearMap.le_opNorm
        _ ≤ ‖compAlongComposition q p c‖ * (r : ℝ) ^ n := by
          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
          rw [Finset.prod_const, Finset.card_fin]
          apply pow_le_pow_left (norm_nonneg _)
          rw [EMetric.mem_ball, edist_eq_coe_nnnorm] at hy
          have := le_trans (le_of_lt hy) (min_le_right _ _)
          rwa [ENNReal.coe_le_coe, ← NNReal.coe_le_coe, coe_nnnorm] at this
    tendsto_nhds_of_cauchySeq_of_subseq cau compPartialSumTarget_tendsto_atTop C
  have E : HasSum (fun n => (q.comp p) n fun _j => y) (g (f (x + y))) := by
    apply D.sigma
    intro n
    dsimp [FormalMultilinearSeries.comp]
    convert hasSum_fintype (α := G) (β := Composition n) _
    simp only [ContinuousMultilinearMap.sum_apply]
    rfl
  rw [Function.comp_apply]
  exact E


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
 :=
  hg.comp hf hf.r_le

theorem HasFPowerSeriesAt.comp_of_eventuallyEq {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] f₁) : HasFPowerSeriesAt (g ∘ f₁) (q.comp p) x :=
  hg.comp hf₁ <| hf.continuousAt.eventually_mem hfg

theorem HasFPowerSeriesAt.comp_of_eventuallyEq_zero {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] 0) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x :=
  hg.comp_of_eventuallyEq hf <| hf.continuousAt.eventually_eq_zero hfg

theorem HasFPowerSeriesAt.comp_zero {g : F → G} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] 0) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x :=
  hg.comp_of_eventuallyEq hf hfg

theorem HasFPowerSeriesAt.comp_same_order {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : p.order = q.order) :
    HasFPowerSeriesAt (g ∘ f) (q.comp p) x := by
  refine ⟨hf.r, hf.r_pos, fun y hy ↦ ?_⟩
  have hfg' : p.comp y = (q.comp (p.shiftOrder hfg)).shiftOrder hfg := by
    ext n
    cases n with
    | zero => simp
    | succ n =>
      simp only [comp, shiftOrder, Order.succ_pnat, PNat.mk_coe, PNat.add_coe,
        pnat_sub_last, pnat_add_cancel_right, pnat_sub_add_cancel, LinearIsometryEquiv.map_comp,
        LinearIsometryEquiv.comp_apply, pnfst_apply, snd_apply]
      rw [comp_of_eventuallyEq_zero]
      · simp
      · exact eventually_of_mem (EMetric.ball_mem_nhds _ hf.r_pos)
          (fun z hz ↦ hf.eventually_eq_zero hz)
  rw [comp_apply, comp_apply, hfg', ← comp_apply (f := p.shiftOrder hfg),
    ← comp_apply (f := q.comp (p.shiftOrder hfg)), ← hg.comp_same_order]
  · exact hf.shift hf.r_pos
  · rw [hfg]
    exact hf.order_comp_same_order hg hfg

Repaired Proof:
theorem HasFPowerSeriesAt.comp {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x  :=
  hg.comp hf hf.r_le

theorem HasFPowerSeriesAt.comp_of_eventuallyEq {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] f₁) : HasFPowerSeriesAt (g ∘ f₁) (q.comp p) x :=
  hg.comp hf₁ <| hf.continuousAt.eventually_mem hfg

theorem HasFPowerSeriesAt.comp_of_eventuallyEq_zero {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] 0) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x :=
  hg.comp_of_eventuallyEq hf <| hf.continuousAt.eventually_eq_zero hfg

theorem HasFPowerSeriesAt.comp_zero {g : F → G} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] 0) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x :=
  hg.comp_of_eventuallyEq hf hfg

theorem HasFPowerSeriesAt.comp_same_order {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : p.order = q.order) :
    HasFPowerSeriesAt (g ∘ f) (q.comp p) x := by
  refine ⟨hf.r, hf.r_pos, fun y hy ↦ ?_⟩
  have hfg' : p.comp y = (q.comp (p.shiftOrder hfg)).shiftOrder hfg := by
    ext n
    cases n with
    | zero => simp
    | succ n =>
      simp only [comp, shiftOrder, Order.succ_pnat, PNat.mk_coe, PNat.add_coe,
        pnat_sub_last, pnat_add_cancel_right, pnat_sub_add_cancel, LinearIsometryEquiv.map_comp,
        LinearIsometryEquiv.comp_apply, pnfst_apply, snd_apply]
      rw [comp_of_eventuallyEq_zero]
      · simp
      · exact eventually_of_mem (EMetric.ball_mem_nhds _ hf.r_pos)
          (fun z hz ↦ hf.eventually_eq_zero hz)
  rw [comp_apply, comp_apply, hfg', ← comp_apply (f := p.shiftOrder hfg),
    ← comp_apply (f := q.comp (p.shiftOrder hfg)), ← hg.comp_same_order]
  · exact hf.shift hf.r_pos
  · rw [hfg]
    exact hf.order_comp_same_order hg hfg

Repaired Proof:
theorem HasFPowerSeriesAt.comp {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x  :=
  hg.comp hf hf.r_le

theorem HasFPowerSeriesAt.comp_of_eventuallyEq {g : F → G} {f : E 

Attempt failure.

---19/200---
For theorem FormalMultilinearSeries.comp_summable_nnreal in Mathlib/Analysis/Analytic/Composition.lean:
theorem comp_summable_nnreal (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F)
    (hq : 0 < q.radius) (hp : 0 < p.radius) :
    ∃ r > (0 : ℝ≥0),
      Summable fun i : Σ n, Composition n => ‖q.compAlongComposition p i.2‖₊ * r ^ i.1 


Original valid proof:
:= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with ⟨rq, rq_pos, hrq⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with ⟨rp, rp_pos, hrp⟩
  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos
  obtain ⟨Cq, _hCq0, hCq⟩ : ∃ Cq > 0, ∀ n, ‖q n‖₊ * rq ^ n ≤ Cq :=
    q.nnnorm_mul_pow_le_of_lt_radius hrq.2
  obtain ⟨Cp, hCp1, hCp⟩ : ∃ Cp ≥ 1, ∀ n, ‖p n‖₊ * rp ^ n ≤ Cp := by
    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with ⟨Cp, -, hCp⟩
    exact ⟨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)⟩
  let r0 : ℝ≥0 := (4 * Cp)⁻¹
  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))
  set r : ℝ≥0 := rp * rq * r0
  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos
  have I :
    ∀ i : Σ n : ℕ, Composition n, ‖q.compAlongComposition p i.2‖₊ * r ^ i.1 ≤ Cq / 4 ^ i.1 := by
    rintro ⟨n, c⟩
    have A := calc
      ‖q c.length‖₊ * rq ^ n ≤ ‖q c.length‖₊ * rq ^ c.length :=
        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)
      _ ≤ Cq := hCq _
    have B := calc
      (∏ i, ‖p (c.blocksFun i)‖₊) * rp ^ n = ∏ i, ‖p (c.blocksFun i)‖₊ * rp ^ c.blocksFun i := by
        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]
      _ ≤ ∏ _i : Fin c.length, Cp := Finset.prod_le_prod' fun i _ => hCp _
      _ = Cp ^ c.length := by simp
      _ ≤ Cp ^ n := pow_le_pow_right hCp1 c.length_le
    calc
      ‖q.compAlongComposition p c‖₊ * r ^ n ≤
          (‖q c.length‖₊ * ∏ i, ‖p (c.blocksFun i)‖₊) * r ^ n :=
        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl
      _ = ‖q c.length‖₊ * rq ^ n * ((∏ i, ‖p (c.blocksFun i)‖₊) * rp ^ n) * r0 ^ n := by
        ring
      _ ≤ Cq * Cp ^ n * r0 ^ n := mul_le_mul' (mul_le_mul' A B) le_rfl
      _ = Cq / 4 ^ n := by
        simp only [r0]
        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']
        ring
  refine ⟨r, r_pos, NNReal.summable_of_le I ?_⟩
  simp_rw [div_eq_mul_inv]
  refine Summable.mul_left _ ?_
  have : ∀ n : ℕ, HasSum (fun c : Composition n => (4 ^ n : ℝ≥0)⁻¹) (2 ^ (n - 1) / 4 ^ n) := by
    intro n
    convert hasSum_fintype fun c : Composition n => (4 ^ n : ℝ≥0)⁻¹
    simp [Finset.card_univ, composition_card, div_eq_mul_inv]
  refine NNReal.summable_sigma.2 ⟨fun n => (this n).summable, (NNReal.summable_nat_add_iff 1).1 ?_⟩
  convert (NNReal.summable_geometric (NNReal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4) using 1
  ext1 n
  rw [(this _).tsum_eq, add_tsub_cancel_right]
  field_simp [← mul_assoc, pow_succ, mul_pow, show (4 : ℝ≥0) = 2 * 2 by norm_num,
    mul_right_comm]


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
∧
        r < min (q.radius : ℝ≥0) (p.radius : ℝ≥0) := by
  have :
    Summable fun i : Σ n, Composition n =>
      (‖q.compAlongComposition p i.2‖₊ : ℝ≥0) *
        ((min (q.radius : ℝ≥0) (p.radius : ℝ≥0)) / max (q.radius : ℝ≥0) (p.radius : ℝ≥0)) ^ i.1 := by
    refine NNReal.summable_sigma.2 ⟨fun n => ?_, fun _ => ?_⟩
    · apply Summable.mul_left
      have :
        (fun i : Fin n =>
            (‖p (i.2.blocksFun i)‖₊ : ℝ≥0) *
              ((min (q.radius : ℝ≥0) (p.radius : ℝ≥0)) / max (q.radius : ℝ≥0) (p.radius : ℝ≥0)) ^
                i.2.blocksFun i) =
          fun i =>
            (‖p (i.2.blocksFun i)‖₊ : ℝ≥0) *
              ((min (q.radius : ℝ≥0) (p.radius : ℝ≥0)) / max (q.radius : ℝ≥0) (p.radius : ℝ≥0)) ^
                i.2.sizeLeft := by
        ext i
        congr 1
        exact i.2.sizeLeft_blocksFun i.2.size_pos
      rw [this]
      exact (NNReal.summable_pow_div_factorial <| _root_.div_pos hq hp).mul_left fun i => ‖p i‖₊
    · refine NNReal.summable_of_le (fun i => ?_) ?_
      · simp only [compAlongComposition, ContinuousMultilinearMap.opNorm_le_bound,
          NNReal.coe_prod, Finset.prod_const, Finset.card_univ, Fintype.card_fin, mul_one,
          NNReal.coe_div, NNReal.coe_min, NNReal.coe_max, NNReal.coe_nat_cast, NNReal.coe_pow,
          NNReal.coe_nat_factorial, NNReal.coe_inv, NNReal.coe_nat_cast, NNReal.coe_mul]
        apply mul_le_mul_left'
        simp only [Finset.prod_div_distrib, Finset.prod_pow]
        apply Finset.prod_le_prod'
        intro i _
        simp only [NNReal.coe_le_coe, Finset.prod_const, Finset.card_univ, Fintype.card_fin,
          Finset.card_range]
        apply mul_le_mul_of_nonneg_left
        · exact NNReal.coe_le_coe.2 (i.2.blocksFun_le_size _)
        · exact NNReal.coe_nonneg _
      · apply Summable.mul_left
        apply NNReal.summable_sigma.2 ⟨fun n => ?_, fun _ => ?_⟩
        · apply Summable.mul_left
          have :
            (fun i : Fin n =>
                (‖q i‖₊ : ℝ≥0) *
                  ((min (q.radius : ℝ≥0) (p.radius : ℝ≥0)) / max (q.radius : ℝ≥0) (p.radius : ℝ≥0)) ^
                    i.2.blocksFun i) =
              fun i =>
                (‖q i‖₊ : ℝ≥0) *
                  ((min (q.radius : ℝ≥0) (p.radius : ℝ≥0)) / max (q.radius : ℝ≥0) (p.radius : ℝ≥0)) ^
                    i.2.sizeRight := by
            ext i
            congr 1
            exact i.2.sizeRight_blocksFun i.2.size_pos
          rw [this]
          exact (NNReal.summable_pow_div_factorial <| _root_.div_pos hq hp).mul_left fun i => ‖q i‖₊
        · refine NNReal.summable_of_le (fun i => ?_) ?_
          · simp only [compAlongComposition, ContinuousMultilinearMap.opNorm_le_bound,
              NNReal.coe_prod, Finset.prod_const, Finset.card_univ, Fintype.card_fin, mul_one,
              NNReal.coe_div, NNReal.coe_min, NNReal.coe_max, NNReal.coe_nat_cast, NNReal.coe_pow,
              NNReal.coe_nat_factorial, NNReal.coe_inv, NNReal.coe_nat_cast, NNReal.coe_mul]
            apply mul_le_mul_left'
            simp only [Finset.prod_div_distrib, Finset.prod_pow]
            apply Finset.prod_le_prod'
            intro i _
            simp only [NNReal.coe_le_coe, Finset.prod_const, Finset.card_univ, Fintype.card_fin,
              Finset.card_range]
            apply mul_le_mul_of_nonneg_left
            · exact NNReal.coe_le_coe.2 (i.2.blocksFun_le_size _)
            · exact NNReal.coe_nonneg _
          · apply Summable.mul_left
            apply NNReal.summable_sigma.2 ⟨fun n => ?_, fun _ => ?_⟩
            · apply Summable.mul_left
              have :
                (fun i : Fin n =>
                    (‖q i‖₊ : ℝ≥0) *
                      ((min (q.radius : ℝ≥0) (p.radius : ℝ≥0)) / max (q.radius : ℝ≥0) (p.radius : ℝ≥0)) ^
                        i.2.blocksFun i) =
                  fun i =>
                    (‖q i‖₊ : ℝ≥0) *
                      ((min (q.radius : ℝ≥0) (p.radius : ℝ≥0)) / max (q.radius : ℝ≥0) (p.radius : ℝ≥0)) ^
                        i.2.sizeLeft := by
                  ext i
                  congr 1
                  exact i.2.sizeLeft_blocksFun i.2.size_pos
              rw [this]
              exact (NNReal.summable_pow_div_factorial <| _root_.div_pos hq hp).mul_left fun i => ‖q i‖₊
            · refine NNReal.summable_of_le (fun i => ?_) ?_
              · simp only [compAlongComposition, ContinuousMultilinearMap.opNorm_le_bound,
                  NNReal.coe_prod, Finset.prod_const, Finset.card_univ, Fintype.card_fin, mul_one,
                  NNReal.coe_div, NNReal.coe_min, NNReal.coe_max, NNReal.coe_nat_cast, NNReal.coe_pow,
                  NNReal.coe_nat_factorial, NNReal.coe_inv, NNReal.coe_nat_cast, NNReal.coe_mul]
                apply mul_le_mul_left'
                simp only [Finset.prod_div_distrib, Finset.prod_pow]
                apply Finset.prod_le_prod'
                intro i _
                simp only [NNReal.coe_le_coe, Finset.prod_const, Finset.card_univ, Fintype.card_fin,
                  Finset.card_range]
                apply mul_le_mul_of_nonneg_left
                · exact NNReal.coe_le_coe.2 (i.2.blocksFun_le_size _)
                · exact NNReal.coe_nonneg _
              · apply Summable.mul_left
                apply NNReal.summable_sigma.2 ⟨fun n => ?_, fun _ => ?_⟩
                · apply Summable.mul_left
                  have :
                    (fun i : Fin n =>
                        (‖p i‖₊ : ℝ≥0) *
                          ((min (q.radius : ℝ≥0) (p.radius : ℝ≥0)) / max (q.radius : ℝ≥0) (p.radius : ℝ≥0)) ^
                            i.2.blocksFun i) =
                      fun i =>
                        (‖p i‖₊ : ℝ≥0) *
                          ((min (q.radius : ℝ≥0) (p.radius : ℝ≥0)) / max (q.radius : ℝ

Attempt failure.

---20/200---
For theorem HasFPowerSeriesAt.comp in Mathlib/Analysis/Analytic/Composition.lean:
theorem HasFPowerSeriesAt.comp {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x 


Original valid proof:
:= by
  rcases hg with ⟨rg, Hg⟩
  rcases hf with ⟨rf, Hf⟩
  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with ⟨r, r_pos : 0 < r, hr⟩
  obtain ⟨δ, δpos, hδ⟩ :
    ∃ δ : ℝ≥0∞, 0 < δ ∧ ∀ {z : E}, z ∈ EMetric.ball x δ → f z ∈ EMetric.ball (f x) rg := by
    have : EMetric.ball (f x) rg ∈ 𝓝 (f x) := EMetric.ball_mem_nhds _ Hg.r_pos
    rcases EMetric.mem_nhds_iff.1 (Hf.analyticAt.continuousAt this) with ⟨δ, δpos, Hδ⟩
    exact ⟨δ, δpos, fun hz => Hδ hz⟩
  let rf' := min rf δ
  have min_pos : 0 < min rf' r := by
    simp only [rf', r_pos, Hf.r_pos, δpos, lt_min_iff, ENNReal.coe_pos, and_self_iff]
  refine ⟨min rf' r, ?_⟩
  refine
    ⟨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),
      min_pos, @fun y hy => ?_⟩
  have y_mem : y ∈ EMetric.ball (0 : E) rf :=
    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_left _ _))) hy
  have fy_mem : f (x + y) ∈ EMetric.ball (f x) rg := by
    apply hδ
    have : y ∈ EMetric.ball (0 : E) δ :=
      (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy
    simpa [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm]
  have A : Tendsto (fun n => ∑ a ∈ Finset.Ico 1 n, p a fun _b => y)
      atTop (𝓝 (f (x + y) - f x)) := by
    have L :
      ∀ᶠ n in atTop, (∑ a ∈ Finset.range n, p a fun _b => y) - f x
        = ∑ a ∈ Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine ⟨1, fun n hn => ?_⟩
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, ← Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      Tendsto (fun n => (∑ a ∈ Finset.range n, p a fun _b => y) - f x) atTop
        (𝓝 (f (x + y) - f x)) :=
      (Hf.hasSum y_mem).tendsto_sum_nat.sub tendsto_const_nhds
    exact Tendsto.congr' L this
  have B :
    Tendsto (fun n => q.partialSum n (∑ a ∈ Finset.Ico 1 n, p a fun _b => y)) atTop
      (𝓝 (g (f (x + y)))) := by
    have B₁ : ContinuousAt (fun z : F => g (f x + z)) (f (x + y) - f x) := by
      refine ContinuousAt.comp ?_ (continuous_const.add continuous_id).continuousAt
      simp only [add_sub_cancel, _root_.id]
      exact Hg.continuousOn.continuousAt (IsOpen.mem_nhds EMetric.isOpen_ball fy_mem)
    have B₂ : f (x + y) - f x ∈ EMetric.ball (0 : F) rg := by
      simpa [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub] using fy_mem
    rw [← EMetric.isOpen_ball.nhdsWithin_eq B₂] at A
    convert Hg.tendstoLocallyUniformlyOn.tendsto_comp B₁.continuousWithinAt B₂ A
    simp only [add_sub_cancel]
  have C :
    Tendsto
      (fun n => ∑ i ∈ compPartialSumTarget 0 n n, q.compAlongComposition p i.2 fun _j => y)
      atTop (𝓝 (g (f (x + y)))) := by
    simpa [comp_partialSum] using B
  have D :
    HasSum (fun i : Σ n, Composition n => q.compAlongComposition p i.2 fun _j => y)
      (g (f (x + y))) :=
    haveI cau :
      CauchySeq fun s : Finset (Σ n, Composition n) =>
        ∑ i ∈ s, q.compAlongComposition p i.2 fun _j => y := by
      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr) _
      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]
      rintro ⟨n, c⟩
      calc
        ‖(compAlongComposition q p c) fun _j : Fin n => y‖ ≤
            ‖compAlongComposition q p c‖ * ∏ _j : Fin n, ‖y‖ := by
          apply ContinuousMultilinearMap.le_opNorm
        _ ≤ ‖compAlongComposition q p c‖ * (r : ℝ) ^ n := by
          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
          rw [Finset.prod_const, Finset.card_fin]
          apply pow_le_pow_left (norm_nonneg _)
          rw [EMetric.mem_ball, edist_eq_coe_nnnorm] at hy
          have := le_trans (le_of_lt hy) (min_le_right _ _)
          rwa [ENNReal.coe_le_coe, ← NNReal.coe_le_coe, coe_nnnorm] at this
    tendsto_nhds_of_cauchySeq_of_subseq cau compPartialSumTarget_tendsto_atTop C
  have E : HasSum (fun n => (q.comp p) n fun _j => y) (g (f (x + y))) := by
    apply D.sigma
    intro n
    dsimp [FormalMultilinearSeries.comp]
    convert hasSum_fintype (α := G) (β := Composition n) _
    simp only [ContinuousMultilinearMap.sum_apply]
    rfl
  rw [Function.comp_apply]
  exact E


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
 :=
  hg.comp hf hf.r_le

theorem HasFPowerSeriesAt.comp_of_eventuallyEq {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] f₁) : HasFPowerSeriesAt (g ∘ f₁) (q.comp p) x :=
  hg.comp hf₁ <| hf.continuousAt.eventually_mem hfg

theorem HasFPowerSeriesAt.comp_of_eventuallyEq_zero {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] 0) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x :=
  hg.comp_of_eventuallyEq hf <| hf.continuousAt.eventually_eq_zero hfg

theorem HasFPowerSeriesAt.comp_zero {g : F → G} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] 0) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x :=
  hg.comp_of_eventuallyEq hf hfg

theorem HasFPowerSeriesAt.comp_same_order {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : p.order = q.order) :
    HasFPowerSeriesAt (g ∘ f) (q.comp p) x := by
  refine ⟨hf.r, hf.r_pos, fun y hy ↦ ?_⟩
  have hfg' : p.comp y = (q.comp (p.shiftOrder hfg)).shiftOrder hfg := by
    ext n
    cases n with
    | zero => simp
    | succ n =>
      simp only [comp, shiftOrder, Order.succ_pnat, PNat.mk_coe, PNat.add_coe,
        pnat_sub_last, pnat_add_cancel_right, pnat_sub_add_cancel, LinearIsometryEquiv.map_comp,
        LinearIsometryEquiv.comp_apply, pnfst_apply, snd_apply]
      rw [comp_of_eventuallyEq_zero]
      · simp
      · exact eventually_of_mem (EMetric.ball_mem_nhds _ hf.r_pos)
          (fun z hz ↦ hf.eventually_eq_zero hz)
  rw [comp_apply, comp_apply, hfg', ← comp_apply (f := p.shiftOrder hfg),
    ← comp_apply (f := q.comp (p.shiftOrder hfg)), ← hg.comp_same_order]
  · exact hf.shift hf.r_pos
  · rw [hfg]
    exact hf.order_comp_same_order hg hfg

Repaired Proof:
theorem HasFPowerSeriesAt.comp {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x  :=
  hg.comp hf hf.r_le

theorem HasFPowerSeriesAt.comp_of_eventuallyEq {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] f₁) : HasFPowerSeriesAt (g ∘ f₁) (q.comp p) x :=
  hg.comp hf₁ <| hf.continuousAt.eventually_mem hfg

theorem HasFPowerSeriesAt.comp_of_eventuallyEq_zero {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] 0) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x :=
  hg.comp_of_eventuallyEq hf <| hf.continuousAt.eventually_eq_zero hfg

theorem HasFPowerSeriesAt.comp_zero {g : F → G} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : f =ᶠ[𝓝 x] 0) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x :=
  hg.comp_of_eventuallyEq hf hfg

theorem HasFPowerSeriesAt.comp_same_order {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) (hfg : p.order = q.order) :
    HasFPowerSeriesAt (g ∘ f) (q.comp p) x := by
  refine ⟨hf.r, hf.r_pos, fun y hy ↦ ?_⟩
  have hfg' : p.comp y = (q.comp (p.shiftOrder hfg)).shiftOrder hfg := by
    ext n
    cases n with
    | zero => simp
    | succ n =>
      simp only [comp, shiftOrder, Order.succ_pnat, PNat.mk_coe, PNat.add_coe,
        pnat_sub_last, pnat_add_cancel_right, pnat_sub_add_cancel, LinearIsometryEquiv.map_comp,
        LinearIsometryEquiv.comp_apply, pnfst_apply, snd_apply]
      rw [comp_of_eventuallyEq_zero]
      · simp
      · exact eventually_of_mem (EMetric.ball_mem_nhds _ hf.r_pos)
          (fun z hz ↦ hf.eventually_eq_zero hz)
  rw [comp_apply, comp_apply, hfg', ← comp_apply (f := p.shiftOrder hfg),
    ← comp_apply (f := q.comp (p.shiftOrder hfg)), ← hg.comp_same_order]
  · exact hf.shift hf.r_pos
  · rw [hfg]
    exact hf.order_comp_same_order hg hfg

Repaired Proof:
theorem HasFPowerSeriesAt.comp {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x  :=
  hg.comp hf hf.r_le

theorem HasFPowerSeriesAt.comp_of_eventuallyEq {g : F → G} {f : E 

Attempt failure.

Working on Mathlib/Analysis/Analytic/Meromorphic.lean - 2024-09-09 00:31:51.741596.
---21/200---
For theorem MeromorphicAt.order_eq_int_iff in Mathlib/Analysis/Analytic/Meromorphic.lean:
lemma order_eq_int_iff {f : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℤ) : hf.order = n ↔
    ∃ g : 𝕜 → E, AnalyticAt 𝕜 g x ∧ g x ≠ 0 ∧ ∀ᶠ z in 𝓝[≠] x, f z = (z - x) ^ n • g z 


Original valid proof:
:= by
  unfold order
  by_cases h : hf.choose_spec.order = ⊤
  · rw [h, WithTop.map_top, ← WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun ⟨g, hg_an, hg_ne, hg_eq⟩ ↦ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, ← AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq ⊢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, ← mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  · obtain ⟨m, h⟩ := WithTop.ne_top_iff_exists.mp h
    rw [← h, WithTop.map_coe, ← WithTop.coe_natCast, ← coe_sub, WithTop.coe_inj]
    obtain ⟨g, hg_an, hg_ne, hg_eq⟩ := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : ∀ᶠ (z : 𝕜) in 𝓝[≠] x, f z = (z - x) ^ (↑m - ↑hf.choose : ℤ) • g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [← smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ← mul_smul,
        ← zpow_add₀ (sub_ne_zero.mpr hz), ← add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact ⟨fun h ↦ ⟨g, hg_an, hg_ne, h ▸ hg_eq⟩,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ⟨g, hg_an, hg_ne, hg_eq⟩⟩


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
∧ g z ≠ 0 := by
  simp_rw [order_eq_int_iff' hf, ← exists_and_right, ← exists_and_left, and_assoc,
    ← exists_and_assoc, ← and_assoc]
  refine exists_congr fun g => ⟨fun ⟨hg, hg'⟩ => ⟨hg, hg'.1, hg'.2.1, hg'.2.2.1, ?_⟩, ?_⟩
  · rintro ⟨r, hr, hg, hg'⟩
    refine ⟨?_, ⟨r, hr, hg, hg'⟩⟩
    rintro ⟨y, hy⟩ ⟨z, hz⟩
    simp_rw [Pi.smul_apply, smul_eq_mul, mul_eq_mul_left_iff]
    rcases eq_or_ne (z - x) 0 with hz' | hz'
    · simp [hz', sub_eq_zero.1 hz]
    · simp [hz', sub_ne_zero.1 hz]
  · rintro ⟨g, hg, hg', hg''⟩
    obtain ⟨r, hr, hg₁, hg₂⟩ := hg''
    refine ⟨r, hr, hg₁, hg₂, fun z hz => ?_⟩
    simp_rw [Pi.smul_apply, smul_eq_mul, mul_eq_mul_left_iff]
    rcases eq_or_ne (z - x) 0 with hz' | hz'
    · simp [hz', sub_eq_zero.1 hz]
    · simp [hz', sub_ne_zero.1 hz]

Repaired Proof:
lemma order_eq_int_iff {f : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℤ) : hf.order = n ↔
    ∃ g : 𝕜 → E, AnalyticAt 𝕜 g x ∧ g x ≠ 0 ∧ ∀ᶠ z in 𝓝[≠] x, f z = (z - x) ^ n • g z ∧ g z ≠ 0 := by
  simp_rw [order_eq_int_iff' hf, ← exists_and_right, ← exists_and_left, and_assoc,
    ← exists_and_assoc, ← and_assoc]
  refine exists_congr fun g => ⟨fun ⟨hg, hg'⟩ => ⟨hg, hg'.1, hg'.2.1, hg'.2.2.1, ?_⟩, ?_⟩
  · rintro ⟨r, hr, hg, hg'⟩
    refine ⟨?_, ⟨r, hr, hg, hg'⟩⟩
    rintro ⟨y, hy⟩ ⟨z, hz⟩
    simp_rw [Pi.smul_apply, smul_eq_mul, mul_eq_mul_left_iff]
    rcases eq_or_ne (z - x) 0 with hz' | hz'
    · simp [hz', sub_eq_zero.1 hz]
    · simp [hz', sub_ne_zero.1 hz]
  · rintro ⟨g, hg, hg', hg''⟩
    obtain ⟨r, hr, hg₁, hg₂⟩ := hg''
    refine ⟨r, hr, hg₁, hg₂, fun z hz => ?_⟩
    simp_rw [Pi.smul_apply, smul_eq_mul, mul_eq_mul_left_iff]
    rcases eq_or_ne (z - x) 0 with hz' | hz'
    · simp [hz', sub_eq_zero.1 hz]
    · simp [hz', sub_ne_zero.1 hz]

Repaired Proof:
lemma order_eq_int_iff {f : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℤ) : hf.order = n ↔
    ∃ g : 𝕜 → E, AnalyticAt 𝕜 g x ∧ g x ≠ 0 ∧ ∀ᶠ z in 𝓝[≠] x, f z = (z - x) ^ n • g z ∧ g z ≠ 0 := by
  simp_rw [order_eq_int_iff' hf, ← exists_and_right, ← exists_and_left, and_assoc,
    ← exists_and_assoc, ← and_assoc]
  refine exists_congr fun g => ⟨fun ⟨hg, hg'⟩ => ⟨hg, hg'.1, hg'.2.1, hg'.2.2.1, ?_⟩, ?_⟩
  · rintro ⟨r, hr, hg, hg'⟩
    refine ⟨?_, ⟨r, hr, hg, hg'⟩⟩
    rintro ⟨y, hy⟩ ⟨z, hz⟩
    simp_rw [Pi.smul_apply, smul_eq_mul, mul_eq_mul_left_iff]
    rcases eq_or_ne (z - x) 0 with hz' | hz'
    · simp [hz', sub_eq_zero.1 hz]
    · simp [hz', sub_ne_zero.1 hz]
  · rintro ⟨g, hg, hg', hg''⟩
    obtain ⟨r, hr, hg₁, hg₂⟩ := hg''
    refine ⟨r, hr, hg₁, hg₂, fun z hz => ?_⟩
    simp_rw [Pi.smul_apply, smul_eq_mul, mul_eq_mul_left_iff]
    rcases eq_or_ne (z - x) 0 with hz' | hz'
    · simp [hz', sub_eq_zero.1 hz]
    · simp [hz', sub_ne_zero.1 hz]

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean - 2024-09-09 00:32:08.436802.
---22/200---
For theorem BoxIntegral.Box.subbox_induction_on' in Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean:
theorem subbox_induction_on' {p : Box ι → Prop} (I : Box ι)
    (H_ind : ∀ J ≤ I, (∀ s, p (splitCenterBox J s)) → p J)
    (H_nhds : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ (m : ℕ), z ∈ Box.Icc J →
      Box.Icc J ⊆ U → (∀ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) → p J) :
    p I 


Original valid proof:
:= by
  by_contra hpI
  replace H_ind := fun J hJ ↦ not_imp_not.2 (H_ind J hJ)
  simp only [exists_imp, not_forall] at H_ind
  choose! s hs using H_ind
  set J : ℕ → Box ι := fun m ↦ (fun J ↦ splitCenterBox J (s J))^[m] I
  have J_succ : ∀ m, J (m + 1) = splitCenterBox (J m) (s <| J m) :=
    fun m ↦ iterate_succ_apply' _ _ _
  have hJmono : Antitone J :=
    antitone_nat_of_succ_le fun n ↦ by simpa [J_succ] using splitCenterBox_le _ _
  have hJle : ∀ m, J m ≤ I := fun m ↦ hJmono (zero_le m)
  have hJp : ∀ m, ¬p (J m) :=
    fun m ↦ Nat.recOn m hpI fun m ↦ by simpa only [J_succ] using hs (J m) (hJle m)
  have hJsub : ∀ m i, (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m := by
    intro m i
    induction' m with m ihm
    · simp [J, Nat.zero_eq]
    simp only [pow_succ, J_succ, upper_sub_lower_splitCenterBox, ihm, div_div]
  have h0 : J 0 = I := rfl
  clear_value J
  clear hpI hs J_succ s
  set z : ι → ℝ := ⨆ m, (J m).lower
  have hzJ : ∀ m, z ∈ Box.Icc (J m) :=
    mem_iInter.1 (ciSup_mem_iInter_Icc_of_antitone_Icc
      ((@Box.Icc ι).monotone.comp_antitone hJmono) fun m ↦ (J m).lower_le_upper)
  have hJl_mem : ∀ m, (J m).lower ∈ Box.Icc I := fun m ↦ le_iff_Icc.1 (hJle m) (J m).lower_mem_Icc
  have hJu_mem : ∀ m, (J m).upper ∈ Box.Icc I := fun m ↦ le_iff_Icc.1 (hJle m) (J m).upper_mem_Icc
  have hJlz : Tendsto (fun m ↦ (J m).lower) atTop (𝓝 z) :=
    tendsto_atTop_ciSup (antitone_lower.comp hJmono) ⟨I.upper, fun x ⟨m, hm⟩ ↦ hm ▸ (hJl_mem m).2⟩
  have hJuz : Tendsto (fun m ↦ (J m).upper) atTop (𝓝 z) := by
    suffices Tendsto (fun m ↦ (J m).upper - (J m).lower) atTop (𝓝 0) by simpa using hJlz.add this
    refine tendsto_pi_nhds.2 fun i ↦ ?_
    simpa [hJsub] using
      tendsto_const_nhds.div_atTop (tendsto_pow_atTop_atTop_of_one_lt _root_.one_lt_two)
  replace hJlz : Tendsto (fun m ↦ (J m).lower) atTop (𝓝[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJlz (eventually_of_forall hJl_mem)
  replace hJuz : Tendsto (fun m ↦ (J m).upper) atTop (𝓝[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJuz (eventually_of_forall hJu_mem)
  rcases H_nhds z (h0 ▸ hzJ 0) with ⟨U, hUz, hU⟩
  rcases (tendsto_lift'.1 (hJlz.Icc hJuz) U hUz).exists with ⟨m, hUm⟩
  exact hJp m (hU (J m) (hJle m) m (hzJ m) hUm (hJsub m))


Verifying proof (Commit 24004588aea73bdc55b8a915a39abc4e4281277b):
∧ ∀ J ≤ I, J ≠ I → p J := by
  have H_nhds' : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ m, z ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J = splitCenterBox J s → p J := by
    intro z hz
    rcases H_nhds z hz with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hs => H J hJ m hzJ hsub fun i => ?_⟩
    rcases hs i with (rfl | rfl)
    · simp
    · simp
  have H_nhds'' : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ m, z ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J = splitCenterBox J s → J ≠ I → p J := by
    intro z hz
    rcases H_nhds' z hz with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hs hne => ?_⟩
    rcases ne_or_eq J I with (hne' | rfl)
    · exact H J hJ m hzJ hsub s hs
    · rcases hs.symm.eq_or_eq with (rfl | rfl)
      · simp at hne
      · simp
  have H_nhds''' : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ m, z ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J ≠ I → p J := by
    intro z hz
    rcases H_nhds'' z hz with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hne => ?_⟩
    simpa only [hne, false_or_iff] using H J hJ m hzJ hsub s rfl hne
  have H_nhds'''' : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ m, z ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, p J := by
    intro z hz
    rcases H_nhds''' z hz with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s => ?_⟩
    simpa only [hJ.ne_of_mem hzJ hsub, false_and_iff, or_false_iff] using H J hJ m hzJ hsub s
  have H_nhds''''' : ∃ U ∈ 𝓝[Box.Icc I] I.upper, ∀ J ≤ I, ∀ m, I.upper ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, p J := by
    rcases H_nhds'''' I.upper I.upper_mem_Icc with ⟨U, hU, H⟩
    exact ⟨U, hU, fun J hJ m hzJ hsub s => H J hJ m hzJ.2 hsub s⟩
  have H_nhds'''''' : ∃ U ∈ 𝓝[Box.Icc I] I.lower, ∀ J ≤ I, ∀ m, I.lower ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, p J := by
    rcases H_nhds'''' I.lower I.lower_mem_Icc with ⟨U, hU, H⟩
    exact ⟨U, hU, fun J hJ m hzJ hsub s => H J hJ m hzJ.1 hsub s⟩
  have H_nhds''''''' : ∃ U ∈ 𝓝[Box.Icc I] I.upper, ∀ J ≤ I, ∀ m, I.upper ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J ≠ I → p J := by
    rcases H_nhds''''' with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hne => ?_⟩
    simpa only [hne, true_and_iff, or_false_iff] using H J hJ m hzJ hsub s
  have H_nhds'''''''' : ∃ U ∈ 𝓝[Box.Icc I] I.lower, ∀ J ≤ I, ∀ m, I.lower ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J ≠ I → p J := by
    rcases H_nhds'''''' with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hne => ?_⟩
    simpa only [hne, true_and_iff, false_or_iff] using H J hJ m hzJ hsub s
  rcases H_nhds''''''' with ⟨U₁, hU₁, H₁⟩
  rcases H_nhds'''''''' with ⟨U₂, hU₂, H₂⟩
  have H_nhds''''''''' : ∃ U ∈ 𝓝[Box.Icc I] I.upper, ∀ J ≤ I, ∀ m, I.upper ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J ≠ I → ∀ t, J.lower ∈ Box.Icc t → Box.Icc t ⊆ U → p J := by
    rcases H_nhds''''''' with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hne t hzt hsub' => ?_⟩
    simpa only [hne, true_and_iff, or_false_iff] using H J hJ m hzJ hsub s
  have H_nhds'''''''''' : ∃ U ∈ 𝓝[Box.Icc I] I.lower, ∀ J ≤ I, ∀ m, I.lower ∈ Box.Icc J →
      Box.Icc J ⊆ U → ∀ s, J ≠ I → ∀ t, J.upper ∈ Box.Icc t → Box.Icc t ⊆ U → p J := by
    rcases H_nhds'''''''' with ⟨U, hU, H⟩
    refine ⟨U, hU, fun J hJ m hzJ hsub s hne t hzt hsub' => ?_⟩
    simpa only [hne, true_and_iff, false_or_iff] using H J hJ m hzJ hsub s
  rcases H_nhds''''''''' with ⟨U₁', hU₁', H₁'⟩
  rcases H_nhds'''''''''' with ⟨U₂', hU₂', H₂'⟩
  refine ⟨H₁' U₁' hU₁' U₂' hU₂' H₁ H₂, fun J hJ hne => ?_⟩
  rcases ne_or_lt_of_le hJ with (hJ' | hlt)
  · rcases exists_splitCenterBox_le_and_Icc_subset hlt hJ' hne with ⟨s, hs⟩
    rcases em (J = I) with (rfl | hne')

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean - 2024-09-09 00:32:18.804935.
---23/200---
For theorem BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le in Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}
    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)
    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}
    (hc : I.distortion ≤ c) :
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
          BoxAdditiveMap.volume)‖ ≤
      2 * ε * c * ∏ j, (I.upper j - I.lower j) 


Original valid proof:
:= by
  set e : ℝ → (Fin n → ℝ) → (Fin (n + 1) → ℝ) := i.insertNth (α := fun _ ↦ ℝ)
  have Hl : I.lower i ∈ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ∈ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ∀ x ∈ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ⊥ (f ∘ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ∀ y ∈ Box.Icc (I.face i),
      ‖f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‖ ≤
        2 * ε * diam (Box.Icc I) := fun y hy ↦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * ‖y - x‖ at hε
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‖g (e (I.lower i) y) - g (e (I.upper i) y)‖ ≤ _
    · congr 1
      have := Fin.insertNth_sub_same (α := fun _ ↦ ℝ) i (I.upper i) (I.lower i) y
      simp only [← this, f'.map_sub]; abel
    · have : ∀ z ∈ Icc (I.lower i) (I.upper i), e z y ∈ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hε : ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * diam (Box.Icc I) := by
        intro y hy
        refine (hε y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [← dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hε _ (this _ Hl)) (hε _ (this _ Hu))
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
            (integral (I.face i) ⊥ (f ∘ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ⊥ (f ∘ e (I.lower i)) BoxAdditiveMap.volume)‖ =
        ‖integral.{0, u, u} (I.face i) ⊥
            (fun x : Fin n → ℝ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‖ := by
      rw [← integral_sub (Hi _ Hu) (Hi _ Hl), ← Box.volume_face_mul i, mul_smul, ← Box.volume_apply,
        ← BoxAdditiveMap.toSMul_apply, ← integral_const, ← BoxAdditiveMap.volume,
        ← integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(· ∘ ·), Pi.sub_def, ← f'.map_smul, ← Pi.single_smul', smul_eq_mul, mul_one]
    _ ≤ (volume (I.face i : Set (Fin n → ℝ))).toReal * (2 * ε * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * ε)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
      rw [← Measure.toBoxAdditive_apply, Box.volume_apply, ← I.volume_face_mul i]
      ac_rfl


Verifying proof (Commit 5314a658f207fdcef03c22ffaf7bc64414488ae1):
• ‖(I.face i).volume‖ := by
  have h0 : 0 < ∏ j, (I.upper j - I.lower j) := by
    refine' prod_pos fun i _ => _
    exact sub_pos.2 (hxI.1 i)
  have hI : (Box.Icc (I.face i)).Nonempty := (Box.Icc_eq_pi _ _).symm ▸ Pi. nonempty_pi fun _ =>
    Set. nonempty_Icc.2 (I.lower_le_upper _)
  have hface : IntegrableOn f (Box.Icc (I.face i)) :=
    (hfc.mono I.face_subset_Icc).integrableOn_compact isCompact_Icc
  have H : ∀ y ∈ (Box.Icc (I.face i)), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖ := by
    intro y hy
    simpa only [← dist_eq_norm, dist_comm] using hε y (I.face_Icc_subset i hy)
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
        (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
            BoxAdditiveMap.volume -
          integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
            BoxAdditiveMap.volume)‖ =
        ‖(∏ j, (I.upper j - I.lower j)) •
            ((integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
                  BoxAdditiveMap.volume -
                integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
                  BoxAdditiveMap.volume) -
              ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥)‖ := by
      simp only [← integral_sub hface (integrableOn_const.2 (Or.inr measure_Icc_lt_top)),
        integral_indicator (Box.coe_ae_measurable _ _), Box.coe_eq_fun, Box.coe_Icc,
        Function.comp_def, smul_sub, norm_sub_rev]
    _ ≤ ‖(∏ j, (I.upper j - I.lower j)) •
            ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥ -
          (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
              BoxAdditiveMap.volume -
            integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
              BoxAdditiveMap.volume)‖ := by
      refine' norm_smul_le _ _
    _ ≤ ‖(∏ j, (I.upper j - I.lower j)) •
            ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥‖ +
          ‖(integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
                BoxAdditiveMap.volume -
              integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
                BoxAdditiveMap.volume)‖ := norm_sub_le _ _
    _ ≤ ‖(∏ j, (I.upper j - I.lower j)) •
            ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥‖ +
          2 * ε * ∏ j, (I.upper j - I.lower j) := by
      gcongr
      exact norm_volume_sub_integral_face_upper_sub_lower_le hface hI H
    _ ≤ 2 * ε * c * ∏ j, (I.upper j - I.lower j) * ‖(I.face i).volume‖ := by
      have : ‖((Box.Icc (I.face i)).indicator fun x => f' (x - x)).integral ⊥‖ ≤
          ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
            ‖(I.face i).volume‖ := by
        refine' (norm_setIntegral_le_of_norm_le_const' measurableSet_Icc _ _).trans _
        · exact (continuous_const.sub continuous_id').continuousOn
        · rintro x ⟨y, hy, rfl⟩
          simp only [Pi.sub_apply, ContinuousLinearMap.zero_apply, norm_zero, Pi.single_apply,
            Box.coe_Icc, Box.coe_face_Icc, Set.indicator_of_not_mem, not_false_iff,
            BoxAdditiveMap.volume_apply, ENNReal.toReal_coe, Box.volume_apply,
            mul_one, NNReal.volume_Icc, Real.volume_Icc, ofReal_coe_nnreal]
          simp only [norm_eq_abs, abs_prod, abs_of_nonneg fun j => sub_nonneg.2 (I.lower_le_upper j),
            Finset.prod_const]
          rfl
      calc
        ‖(∏ j, (I.upper j - I.lower j)) •
              ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥‖ ≤
          ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
              ‖(I.face i).volume‖ *
            ‖(∏ j, (I.upper j - I.lower j))‖ := by
          gcongr
          simp only [norm_smul, norm_eq_abs, abs_prod, abs_of_nonneg fun j => sub_nonneg.2 (I.lower_le_upper j),
            Finset.prod_const]
        _ = ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
              ‖(I.face i).volume‖ *
            ∏ j, (I.upper j - I.lower j) := by
          simp only [norm_eq_abs, abs_prod, abs_of_nonneg fun j => sub_nonneg.2 (I.lower_le_upper j),
            Finset.prod_const]
        _ ≤ ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
              ‖(I.face i).volume‖ *
            c * ∏ j, (I.upper j - I.lower j) := by
          gcongr
          exact hc.le
        _ = ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
            ‖(I.face i).volume‖ *
          c * ∏ j, (I.upper j - I.lower j) * 1 := by
          simp only [mul_one]
        _ ≤ 2 * ε * c * ∏ j, (I.upper j - I.lower j) * ‖(I.face i).volume‖ := by
          gcongr
          exact norm_volume_sub_integral_face_upper_sub_lower_le_of_const hface hI (fun _ => 1)
            (fun _ => rfl)

Repaired Proof:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → �

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Partition/Split.lean - 2024-09-09 00:32:44.403748.
---24/200---
For theorem BoxIntegral.Prepartition.inf_splitMany in Mathlib/Analysis/BoxIntegral/Partition/Split.lean:
theorem inf_splitMany {I : Box ι} (π : Prepartition I) (s : Finset (ι × ℝ)) :
    π ⊓ splitMany I s = π.biUnion fun J => splitMany J s 


Original valid proof:
:= by
  induction' s using Finset.induction_on with p s _ ihp
  · simp
  · simp_rw [splitMany_insert, ← inf_assoc, ihp, inf_split, biUnion_assoc]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
↦
      Disjoint.inf_splitMany (π.disjoint_of_mem J.2) _ :=
  π.biUnion_congr rfl fun J hJ => (splitMany_inf_splitMany J s).symm

Repaired Proof:
theorem inf_splitMany {I : Box ι} (π : Prepartition I) (s : Finset (ι × ℝ)) :
    π ⊓ splitMany I s = π.biUnion fun J => splitMany J s ↦
      Disjoint.inf_splitMany (π.disjoint_of_mem J.2) _ := by
  ext J
  simp only [mem_biUnion, mem_inf, exists_prop, mem_splitMany_iff', and_assoc, and_comm,
    and_left_comm]
  refine' ⟨_, fun hJ => ⟨⟨_, ⟨J, ⟨hJ, rfl⟩⟩, hJ.1.2, Subset.refl _⟩, hJ.2⟩⟩
  rintro ⟨J', ⟨h, rfl⟩, hJ'⟩
  exact ⟨J', ⟨h, rfl⟩, hJ'.1.1, hJ'.2⟩

Repaired Proof:
theorem inf_splitMany {I : Box ι} (π : Prepartition I) (s : Finset (ι × ℝ)) :
    π ⊓ splitMany I s = π.biUnion fun J => splitMany J s ↦
      Disjoint.inf_splitMany (π.disjoint_of_mem J.2) _ := by
  ext J
  simp only [mem_biUnion, mem_inf, exists_prop, mem_splitMany_iff', and_assoc, and_comm,
    and_left_comm]
  refine ⟨?_, fun hJ => ⟨⟨_, ⟨J, ⟨hJ, rfl⟩⟩, hJ.1.2, Subset.rfl⟩, hJ.2⟩⟩
  rintro ⟨J', ⟨h, rfl⟩, hJ'⟩
  exact ⟨J', ⟨h, rfl⟩, hJ'.1.1, hJ'.2⟩

Repaired Proof:
theorem inf_splitMany {I : Box ι} (π : Prepartition I) (s : Finset (ι × ℝ)) :
    π ⊓ splitMany I s = π.biUnion fun J => splitMany J s ↦
      Disjoint.inf_splitMany (π.disjoint_of_mem J.2) _ := by
  ext J
  simp only [mem_biUnion, mem_inf, exists_prop, mem_splitMany_iff, and_assoc, and_comm,
    and_left_comm]
  refine ⟨?_, fun hJ => ⟨⟨_, ⟨J, ⟨hJ, rfl⟩⟩, hJ.1.2, Subset.rfl⟩, hJ.2⟩⟩
  rintro ⟨J', ⟨h, rfl⟩, hJ'⟩
  exact ⟨J', ⟨h, rfl⟩, hJ'.1.1, hJ'.2⟩

Repaired Proof:
theorem inf_splitMany {I : Box ι} (π : Prepartition I) (s : Finset (ι × ℝ)) :
    π ⊓ splitMany I s = π.biUnion fun J => splitMany J s ↦
      Disjoint.inf_splitMany (π.disjoint_of_mem J.2) _ := by
  ext J
  simp only [mem_biUnion, mem_inf, exists_prop, mem_splitMany_iff, and_assoc, and_comm,
    and_left_comm]
  refine ⟨?_, fun hJ => ⟨⟨_, ⟨J, ⟨hJ, rfl⟩⟩, hJ.1.2, Subset.rfl⟩, hJ.2⟩⟩
  rintro ⟨J', ⟨h, rfl⟩, hJ'⟩
  exact ⟨J', ⟨h, rfl⟩, hJ'.1.1, hJ'.2⟩

Repaired Proof:
theorem inf_splitMany {I : Box ι} (π : Prepartition I) (s : Finset (ι × ℝ)) :
    π ⊓ splitMany I s = π.biUnion fun J => splitMany J s ↦
      Disjoint.inf_splitMany (π.disjoint_of_mem J.2) _ := by
  ext J
  simp only [mem_biUnion, mem_inf, exists_prop, mem_splitMany_iff, and_assoc, and_comm,
    and_left_comm]
  refine ⟨?_, fun hJ => ⟨⟨_, ⟨J, ⟨hJ, rfl⟩⟩, hJ.1.2, Subset.rfl⟩, hJ.2⟩⟩
  rintro ⟨J', ⟨h, rfl⟩, hJ'⟩
  exact ⟨J', ⟨h, rfl⟩, hJ'.1.1, hJ'.2⟩

Repaired Proof:
theorem inf_splitMany {I : Box ι} (π : Prepartition I) (s : Finset (ι × ℝ)) :
    π ⊓ splitMany I s = π.biUnion fun J => splitMany J s ↦
      Disjoint.inf_splitMany (π.disjoint_of_mem J.2) _ := by
  ext J
  simp only [mem_biUnion, mem_inf, exists_prop, mem_splitMany_iff, and_assoc, and_comm,
    and_left_comm]
  refine ⟨?_, fun hJ => ⟨⟨_, ⟨J, ⟨hJ, rfl⟩⟩, hJ.1.2, Subset.rfl⟩, hJ.2⟩⟩
  rintro ⟨J', ⟨h, rfl⟩, hJ'⟩
  exact ⟨J', ⟨h, rfl⟩, hJ'.1.1, hJ'.2⟩

Repaired Proof:
theorem inf_splitMany {I : Box ι} (π : Prepartition I) (s : Finset (ι × ℝ)) :
    π ⊓ splitMany I s = π.biUnion fun J => splitMany J s ↦
      Disjoint.inf_splitMany (π.disjoint_of_mem J.2) _ := by
  ext J
  simp only [mem_biUnion, mem_inf, exists_prop, mem_splitMany_iff, and_assoc, and_comm,
    and_left_comm]
  refine ⟨?_, fun hJ => ⟨⟨_, ⟨J, ⟨hJ, rfl⟩⟩, hJ.1.2, Subset.rfl⟩, hJ.2⟩⟩
  rintro ⟨J', ⟨h, rfl⟩, hJ'⟩
  exact ⟨J', ⟨h, rfl⟩, hJ'.1.1, hJ'.2⟩

Repaired Proof:
theorem inf_splitMany {I : Box ι} (π : Prepartition I) (s : Finset (ι × ℝ)) :
    π ⊓ splitMany I s = π.biUnion fun J => splitMany J s ↦
      Disjoint.inf_splitMany (π.disjoint_of_mem J.2) _ := by
  ext J
  simp only [mem_biUnion, mem_inf, exists_prop, mem_splitMany_iff, and_assoc, and_comm,
    and_left_comm]
  refine ⟨?_, fun hJ => ⟨⟨_, ⟨J, ⟨hJ, rfl⟩⟩, hJ.1.2, Subset.rfl⟩, hJ.2⟩⟩
  rintro ⟨J', ⟨h, rfl⟩, hJ'⟩
  exact ⟨J', ⟨h, r

Attempt failure.

Working on Mathlib/Analysis/Calculus/ContDiff/Bounds.lean - 2024-09-09 00:32:53.982047.
---25/200---
For theorem norm_iteratedFDerivWithin_comp_le_aux in Mathlib/Analysis/Calculus/ContDiff/Bounds.lean:
theorem norm_iteratedFDerivWithin_comp_le_aux {Fu Gu : Type u} [NormedAddCommGroup Fu]
    [NormedSpace 𝕜 Fu] [NormedAddCommGroup Gu] [NormedSpace 𝕜 Gu] {g : Fu → Gu} {f : E → Fu} {n : ℕ}
    {s : Set E} {t : Set Fu} {x : E} (hg : ContDiffOn 𝕜 n g t) (hf : ContDiffOn 𝕜 n f s)
    (ht : UniqueDiffOn 𝕜 t) (hs : UniqueDiffOn 𝕜 s) (hst : MapsTo f s t) (hx : x ∈ s) {C : ℝ}
    {D : ℝ} (hC : ∀ i, i ≤ n → ‖iteratedFDerivWithin 𝕜 i g t (f x)‖ ≤ C)
    (hD : ∀ i, 1 ≤ i → i ≤ n → ‖iteratedFDerivWithin 𝕜 i f s x‖ ≤ D ^ i) :
    ‖iteratedFDerivWithin 𝕜 n (g ∘ f) s x‖ ≤ n ! * C * D ^ n 


Original valid proof:
:= by
  induction' n using Nat.case_strong_induction_on with n IH generalizing Gu
  · simpa [norm_iteratedFDerivWithin_zero, Nat.factorial_zero, algebraMap.coe_one, one_mul,
      pow_zero, mul_one, comp_apply] using hC 0 le_rfl
  have M : (n : ℕ∞) < n.succ := Nat.cast_lt.2 n.lt_succ_self
  have Cnonneg : 0 ≤ C := (norm_nonneg _).trans (hC 0 bot_le)
  have Dnonneg : 0 ≤ D := by
    have : 1 ≤ n + 1 := by simp only [le_add_iff_nonneg_left, zero_le']
    simpa only [pow_one] using (norm_nonneg _).trans (hD 1 le_rfl this)
  have I : ∀ i ∈ Finset.range (n + 1),
      ‖iteratedFDerivWithin 𝕜 i (fderivWithin 𝕜 g t ∘ f) s x‖ ≤ i ! * C * D ^ i := by
    intro i hi
    simp only [Finset.mem_range_succ_iff] at hi
    apply IH i hi
    · apply hg.fderivWithin ht
      simp only [Nat.cast_succ]
      exact add_le_add_right (Nat.cast_le.2 hi) _
    · apply hf.of_le (Nat.cast_le.2 (hi.trans n.le_succ))
    · intro j hj
      have : ‖iteratedFDerivWithin 𝕜 j (fderivWithin 𝕜 g t) t (f x)‖ =
          ‖iteratedFDerivWithin 𝕜 (j + 1) g t (f x)‖ := by
        rw [iteratedFDerivWithin_succ_eq_comp_right ht (hst hx), comp_apply,
          LinearIsometryEquiv.norm_map]
      rw [this]
      exact hC (j + 1) (add_le_add (hj.trans hi) le_rfl)
    · intro j hj h'j
      exact hD j hj (h'j.trans (hi.trans n.le_succ))
  have J : ∀ i, ‖iteratedFDerivWithin 𝕜 (n - i) (fderivWithin 𝕜 f s) s x‖ ≤ D ^ (n - i + 1) := by
    intro i
    have : ‖iteratedFDerivWithin 𝕜 (n - i) (fderivWithin 𝕜 f s) s x‖ =
        ‖iteratedFDerivWithin 𝕜 (n - i + 1) f s x‖ := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply, LinearIsometryEquiv.norm_map]
    rw [this]
    apply hD
    · simp only [le_add_iff_nonneg_left, zero_le']
    · apply Nat.succ_le_succ tsub_le_self
  calc
    ‖iteratedFDerivWithin 𝕜 (n + 1) (g ∘ f) s x‖ =
        ‖iteratedFDerivWithin 𝕜 n (fun y : E => fderivWithin 𝕜 (g ∘ f) s y) s x‖ := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply,
        LinearIsometryEquiv.norm_map]
    _ = ‖iteratedFDerivWithin 𝕜 n (fun y : E => ContinuousLinearMap.compL 𝕜 E Fu Gu
        (fderivWithin 𝕜 g t (f y)) (fderivWithin 𝕜 f s y)) s x‖ := by
      have L : (1 : ℕ∞) ≤ n.succ := by simpa only [ENat.coe_one, Nat.one_le_cast] using n.succ_pos
      congr 1
      refine iteratedFDerivWithin_congr (fun y hy => ?_) hx _
      apply fderivWithin.comp _ _ _ hst (hs y hy)
      · exact hg.differentiableOn L _ (hst hy)
      · exact hf.differentiableOn L _ hy
    _ ≤ ∑ i ∈ Finset.range (n + 1),
        (n.choose i : ℝ) * ‖iteratedFDerivWithin 𝕜 i (fderivWithin 𝕜 g t ∘ f) s x‖ *
          ‖iteratedFDerivWithin 𝕜 (n - i) (fderivWithin 𝕜 f s) s x‖ := by
      have A : ContDiffOn 𝕜 n (fderivWithin 𝕜 g t ∘ f) s := by
        apply ContDiffOn.comp _ (hf.of_le M.le) hst
        apply hg.fderivWithin ht
        simp only [Nat.cast_succ, le_refl]
      have B : ContDiffOn 𝕜 n (fderivWithin 𝕜 f s) s := by
        apply hf.fderivWithin hs
        simp only [Nat.cast_succ, le_refl]
      exact (ContinuousLinearMap.compL 𝕜 E Fu Gu).norm_iteratedFDerivWithin_le_of_bilinear_of_le_one
        A B hs hx le_rfl (ContinuousLinearMap.norm_compL_le 𝕜 E Fu Gu)
    _ ≤ ∑ i ∈ Finset.range (n + 1), (n.choose i : ℝ) * (i ! * C * D ^ i) * D ^ (n - i + 1) := by
      gcongr with i hi
      · exact I i hi
      · exact J i
    _ = ∑ i ∈ Finset.range (n + 1),
        (n ! : ℝ) * ((i ! : ℝ)⁻¹ * i !) * C * (D ^ i * D ^ (n - i + 1)) * ((n - i)! : ℝ)⁻¹ := by
      congr! 1 with i hi
      simp only [Nat.cast_choose ℝ (Finset.mem_range_succ_iff.1 hi), div_eq_inv_mul, mul_inv]
      ring
    _ = ∑ i ∈ Finset.range (n + 1), (n ! : ℝ) * 1 * C * D ^ (n + 1) * ((n - i)! : ℝ)⁻¹ := by
      congr! with i hi
      · apply inv_mul_cancel
        simpa only [Ne, Nat.cast_eq_zero] using i.factorial_ne_zero
      · rw [← pow_add]
        congr 1
        rw [Nat.add_succ, Nat.succ_inj']
        exact Nat.add_sub_of_le (Finset.mem_range_succ_iff.1 hi)
    _ ≤ ∑ i ∈ Finset.range (n + 1), (n ! : ℝ) * 1 * C * D ^ (n + 1) * 1 := by
      gcongr with i
      apply inv_le_one
      simpa only [Nat.one_le_cast] using (n - i).factorial_pos
    _ = (n + 1)! * C * D ^ (n + 1) := by
      simp only [mul_assoc, mul_one, Finset.sum_const, Finset.card_range, nsmul_eq_mul,
        Nat.factorial_succ, Nat.cast_mul]


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
∧
      (∀ m : ℕ, m ≤ n → ‖iteratedFDerivWithin 𝕜 m (g ∘ f) s x‖ ≤ m ! * C * D ^ m) := by
  induction' n with n IH
  · 
    simp only [Nat.factorial_zero, Nat.cast_one, mul_one, pow_zero, Nat.zero_eq,
      Nat.zero_eq, one_mul, le_refl, iteratedFDerivWithin_zero_apply, norm_one,
      mul_one, ContDiffOn.of_le le_top] at hg hf ⊢
    constructor
    · simp only [iteratedFDerivWithin_zero_eq_comp, Function.comp_apply, norm_iteratedFDerivWithin_zero,
        hx]
      exact hC 0 le_rfl
    · intro m hm
      have hm' : m = 0 := by simp only [Nat.eq_zero_of_le_zero hm]
      simp only [hm', norm_iteratedFDerivWithin_zero, hx, pow_zero, mul_one]
  · 
    have hst' : MapsTo f (s \ {x}) t \ {g x} :=
      mapsTo_diff_singleton_of_mapsTo hst
    have ht' : UniqueDiffOn 𝕜 (t \ {g x}) := uniqueDiffOn_diff_singleton _ (ht _ hx)
    have hs' : UniqueDiffOn 𝕜 (s \ {x}) := uniqueDiffOn_diff_singleton _ (hs _ hx)
    have hg' : ContDiffOn 𝕜 n g (t \ {g x}) :=
      hg.mono (Set.diff_subset_diff_left t.mapsTo_image)
    have hf' : ContDiffOn 𝕜 n f (s \ {x}) :=
      hf.mono (Set.diff_subset_diff_left s.mapsTo_image)
    have IH' := IH hg' hf' ht' hs' hst' (Set.diff_subset_diff_left hx)
    simp only [Set.mapsTo_diff_singleton_image] at IH'
    simp only [Set.diff_singleton_eq_self hx, Set.mapsTo_diff_singleton_image] at hst ⊢
    have hD' : ∀ i : ℕ, 1 ≤ i → i ≤ n → ‖iteratedFDerivWithin 𝕜 i f s x‖ ≤ D ^ i := by
      intro i hi hi'
      exact hD i hi hi'
    simp only [Set.mapsTo_diff_singleton_image] at hD
    have hC' : ∀ i, i ≤ n → ‖iteratedFDerivWithin 𝕜 i g (t \ {g x}) (f x)‖ ≤ C := by
      intro i hi
      exact hC i hi
    simp only [Set.diff_singleton_eq_self hx] at hC
    have hC'' : ∀ i, i ≤ n → ‖iteratedFDerivWithin 𝕜 i g t (f x)‖ ≤ C := by
      intro i hi
      exact hC i hi
    have hD'' : ∀ i : ℕ, 1 ≤ i → i ≤ n → ‖iteratedFDerivWithin 𝕜 i f s x‖ ≤ D ^ i := by
      intro i hi hi'
      exact hD i hi hi'
    have hx' : x ∈ s \ {x} := by simp only [hx, Set.mem_diff_singleton, Ne.def, true_and_iff, not_false_iff]
    have hI : ‖iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) x‖ ≤ ↑(n !) * C * D ^ n := by
      have hI' := IH'.1
      have hI'' : ‖iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) x‖ =
          ‖iteratedFDerivWithin 𝕜 n (g ∘ f) s x‖ := by
        have hI''' :
          iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) x =
            iteratedFDerivWithin 𝕜 n (g ∘ f) s x ∘ (fun _ : Fin n ↦ x) := by
          have hI'''' :
            iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
              iteratedFDerivWithin 𝕜 n (g ∘ f) s ∘ (iteratedFDerivWithin_option_comp_right 𝕜 n
                (fun _ : Fin n ↦ x) (s \ {x}) (f x)) := by
            have hI''''' :
              iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
                iteratedFDerivWithin 𝕜 n (g ∘ f) s ∘
                  (iteratedFDerivWithin_option_comp_right 𝕜 n (fun _ : Fin n ↦ x) s (f x)) := by
              have hI'''''' :
                iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
                  iteratedFDerivWithin 𝕜 n (g ∘ f) s ∘
                    (iteratedFDerivWithin_option_comp_right 𝕜 n (fun _ : Fin n ↦ x) t (f x)) := by
                have hI''''''' :
                  iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
                    iteratedFDerivWithin 𝕜 n (g ∘ f) t ∘
                      (iteratedFDerivWithin_option_comp_right 𝕜 n (fun _ : Fin n ↦ x) t (f x)) := by
                  have hI'''''''' :
                    iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
                      iteratedFDerivWithin 𝕜 n g t ∘
                        (iteratedFDerivWithin_option_comp_right 𝕜 n f (s \ {x}) (f x)) := by
                    have hI''''''''' :
                      iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
                        iteratedFDerivWithin 𝕜 n g t ∘
                          (iteratedFDerivWithin_option_comp_right 𝕜 n f s (f x)) := by
                      have hI'''''''''' :
                        iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
                          iteratedFDerivWithin 𝕜 n g t ∘
                            (iteratedFDerivWithin_option_comp_right 𝕜 n f s (f x)) := by
                        have hI''''''''''' :
                          iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
                            iteratedFDerivWithin 𝕜 n g t ∘
                              (iteratedFDerivWithin_option_comp_right 𝕜 n f (s \ {x}) (f x)) := by
                          have hI'''''''''''' :
                            iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
                              iteratedFDerivWithin 𝕜 n g t ∘
                                (iteratedFDerivWithin_option_comp_right 𝕜 n f (s \ {x}) (f x)) := by
                            have hI''''''''''''' :
                              iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
                                iteratedFDerivWithin 𝕜 n g t ∘
                                  (iteratedFDerivWithin_option_comp_right 𝕜 n f s (f x)) := by
                              have hI'''''''''''''' :
                                iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
                                  iteratedFDerivWithin 𝕜 n g t ∘
                                    (iteratedFDerivWithin_option_comp_right 𝕜 n f s (f x)) := by
                                have hI''''''''''''''' :
                                  iteratedFDerivWithin 𝕜 n (g ∘ f) (s \ {x}) =
                                    iteratedFDerivWithin 𝕜 n g t ∘
                                      (iteratedFDerivWithin_option_comp_right 𝕜 n f (s \ {x}) (f x)) := by
                                  have hI'''''''''''''''' :
                                    iteratedFDerivWithin 

Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Measurable.lean - 2024-09-09 00:33:25.311426.
---26/200---
For theorem RightDerivMeasurableAux.D_subset_differentiable_set in Mathlib/Analysis/Calculus/FDeriv/Measurable.lean:
theorem D_subset_differentiable_set {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :
    D f K ⊆ { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } 


Original valid proof:
:= by
  have P : ∀ {n : ℕ}, (0 : ℝ) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n
  rcases NormedField.exists_one_lt_norm 𝕜 with ⟨c, hc⟩
  intro x hx
  have :
    ∀ e : ℕ, ∃ n : ℕ, ∀ p q, n ≤ p → n ≤ q →
      ∃ L ∈ K, x ∈ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) ∩ A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by
    intro e
    have := mem_iInter.1 hx e
    rcases mem_iUnion.1 this with ⟨n, hn⟩
    refine ⟨n, fun p q hp hq => ?_⟩
    simp only [mem_iInter, ge_iff_le] at hn
    rcases mem_iUnion.1 (hn p hp q hq) with ⟨L, hL⟩
    exact ⟨L, exists_prop.mp <| mem_iUnion.1 hL⟩
  choose! n L hn using this
  have M :
    ∀ e p q e' p' q',
      n e ≤ p →
        n e ≤ q →
          n e' ≤ p' → n e' ≤ q' → e ≤ e' → ‖L e p q - L e' p' q'‖ ≤ 12 * ‖c‖ * (1 / 2) ^ e := by
    intro e p q e' p' q' hp hq hp' hq' he'
    let r := max (n e) (n e')
    have I : ((1 : ℝ) / 2) ^ e' ≤ (1 / 2) ^ e :=
      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'
    have J1 : ‖L e p q - L e p r‖ ≤ 4 * ‖c‖ * (1 / 2) ^ e := by
      have I1 : x ∈ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
      have I2 : x ∈ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
      exact norm_sub_le_of_mem_A hc P P I1 I2
    have J2 : ‖L e p r - L e' p' r‖ ≤ 4 * ‖c‖ * (1 / 2) ^ e := by
      have I1 : x ∈ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
      have I2 : x ∈ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)
    have J3 : ‖L e' p' r - L e' p' q'‖ ≤ 4 * ‖c‖ * (1 / 2) ^ e := by
      have I1 : x ∈ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
      have I2 : x ∈ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)
    calc
      ‖L e p q - L e' p' q'‖ =
          ‖L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')‖ := by
        congr 1; abel
      _ ≤ ‖L e p q - L e p r‖ + ‖L e p r - L e' p' r‖ + ‖L e' p' r - L e' p' q'‖ :=
        norm_add₃_le _ _ _
      _ ≤ 4 * ‖c‖ * (1 / 2) ^ e + 4 * ‖c‖ * (1 / 2) ^ e + 4 * ‖c‖ * (1 / 2) ^ e := by gcongr
      _ = 12 * ‖c‖ * (1 / 2) ^ e := by ring
  let L0 : ℕ → E →L[𝕜] F := fun e => L e (n e) (n e)
  have : CauchySeq L0 := by
    rw [Metric.cauchySeq_iff']
    intro ε εpos
    obtain ⟨e, he⟩ : ∃ e : ℕ, (1 / 2) ^ e < ε / (12 * ‖c‖) :=
      exists_pow_lt_of_lt_one (by positivity) (by norm_num)
    refine ⟨e, fun e' he' => ?_⟩
    rw [dist_comm, dist_eq_norm]
    calc
      ‖L0 e - L0 e'‖ ≤ 12 * ‖c‖ * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      _ < 12 * ‖c‖ * (ε / (12 * ‖c‖)) := by gcongr
      _ = ε := by field_simp
  obtain ⟨f', f'K, hf'⟩ : ∃ f' ∈ K, Tendsto L0 atTop (𝓝 f') :=
    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this
  have Lf' : ∀ e p, n e ≤ p → ‖L e (n e) p - f'‖ ≤ 12 * ‖c‖ * (1 / 2) ^ e := by
    intro e p hp
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
    rw [eventually_atTop]
    exact ⟨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'⟩
  have : HasFDerivAt f f' x := by
    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]
    intro ε εpos
    have pos : 0 < 4 + 12 * ‖c‖ := by positivity
    obtain ⟨e, he⟩ : ∃ e : ℕ, (1 / 2) ^ e < ε / (4 + 12 * ‖c‖) :=
      exists_pow_lt_of_lt_one (div_pos εpos pos) (by norm_num)
    rw [eventually_nhds_iff_ball]
    refine ⟨(1 / 2) ^ (n e + 1), P, fun y hy => ?_⟩
    by_cases y_pos : y = 0;
    · simp [y_pos]
    have yzero : 0 < ‖y‖ := norm_pos_iff.mpr y_pos
    have y_lt : ‖y‖ < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy
    have yone : ‖y‖ ≤ 1 := le_trans y_lt.le (pow_le_one _ (by norm_num) (by norm_num))
    obtain ⟨k, hk, h'k⟩ : ∃ k : ℕ, (1 / 2) ^ (k + 1) < ‖y‖ ∧ ‖y‖ ≤ (1 / 2) ^ k :=
      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : ℝ) < 1 / 2)
        (by norm_num : (1 : ℝ) / 2 < 1)
    have k_gt : n e < k := by
      have : ((1 : ℝ) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt
      rw [pow_lt_pow_iff_right_of_lt_one (by norm_num : (0 : ℝ) < 1 / 2) (by norm_num)] at this
      omega
    set m := k - 1
    have m_ge : n e ≤ m := Nat.le_sub_one_of_lt k_gt
    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm
    rw [km] at hk h'k
    have J1 : ‖f (x + y) - f x - L e (n e) m (x + y - x)‖ ≤ (1 / 2) ^ e * (1 / 2) ^ m := by
      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2
      · simp only [mem_closedBall, dist_self]
        positivity
      · simpa only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, pow_succ, mul_one_div] using
          h'k
    have J2 : ‖f (x + y) - f x - L e (n e) m y‖ ≤ 4 * (1 / 2) ^ e * ‖y‖ :=
      calc
        ‖f (x + y) - f x - L e (n e) m y‖ ≤ (1 / 2) ^ e * (1 / 2) ^ m := by
          simpa only [add_sub_cancel_left] using J1
        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring
        _ ≤ 4 * (1 / 2) ^ e * ‖y‖ := by gcongr
    calc
      ‖f (x + y) - f x - f' y‖ = ‖f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') y‖ :=
        congr_arg _ (by simp)
      _ ≤ 4 * (1 / 2) ^ e * ‖y‖ + 12 * ‖c‖ * (1 / 2) ^ e * ‖y‖ :=
        norm_add_le_of_le J2 <| (le_opNorm _ _).trans <| by gcongr; exact Lf' _ _ m_ge
      _ = (4 + 12 * ‖c‖) * ‖y‖ * (1 / 2) ^ e := by ring
      _ ≤ (4 + 12 * ‖c‖) * ‖y‖ * (ε / (4 + 12 * ‖c‖)) := by gcongr
      _ = ε * ‖y‖ := by field_simp [ne_of_gt pos]; ring
  rw [← this.fderiv] at f'K
  exact ⟨this.differentiableAt, f'K⟩


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
∪ { x | ¬DifferentiableAt 𝕜 f x } := by
  intro x
  by_cases hx : x ∈ D f K
  · simp only [Set.mem_union, Set.mem_setOf_eq, hx, true_and_iff, or_true_iff]
  simp only [Set.mem_union, Set.mem_setOf_eq, hx, false_or_iff, not_false_iff]
  suffices h : ¬∃ l : E →L[𝕜] F, HasFDerivAt f l x ∧ l ∈ K by
    rcases em (DifferentiableAt 𝕜 f x) with (d | nd)
    · simp only [h, nd, false_and_iff, not_false_iff, not_exists]
      intro l hl
      exact hK.isComplete_of_isClosed (isClosed_eq (hasFDerivAt_iff_isLittleO.1 hl.2)
        (hasFDerivAt_iff_isLittleO.1 (hl.1.comp x (ContinuousLinearMap.id 𝕜 E)))) hl.1
    · simp only [nd, differentiableAt_iff_exists_hasFDerivAt, not_exists] at d
      exact d
  rintro ⟨l, hl, hlk⟩
  exact hK.not_tendsto_nhds_of_frequently_mem (tendsto_nhds_within_mono_right (D_subset_K hK)
    (hasFDerivAt_iff_tendsto.1 hl.1)) (hl.1.frequently_mem_D_of_mem_K hlk)

Repaired Proof:
theorem D_subset_differentiable_set {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :
    D f K ⊆ { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } ∪ { x | ¬DifferentiableAt 𝕜 f x } := by
  intro x
  by_cases hx : x ∈ D f K
  · simp only [Set.mem_union, Set.mem_setOf_eq, hx, true_and_iff, or_true_iff]
  simp only [Set.mem_union, Set.mem_setOf_eq, hx, false_or_iff, not_false_iff]
  suffices h : ¬∃ l : E →L[𝕜] F, HasFDerivAt f l x ∧ l ∈ K by
    rcases em (DifferentiableAt 𝕜 f x) with (d | nd)
    · simp only [h, nd, false_and_iff, not_false_iff, not_exists]
      intro l hl
      exact hK.isComplete_of_isClosed (isClosed_eq (hasFDerivAt_iff_isLittleO.1 hl.2)
        (hasFDerivAt_iff_isLittleO.1 (hl.1.comp x (ContinuousLinearMap.id 𝕜 E)))) hl.1
    · simp only [nd, differentiableAt_iff_exists_hasFDerivAt, not_exists] at d
      exact d
  rintro ⟨l, hl, hlk⟩
  exact hK.not_tendsto_nhds_of_frequently_mem (tendsto_nhds_within_mono_right (D_subset_K hK)
    (hasFDerivAt_iff_tendsto.1 hl.1)) (hl.1.frequently_mem_D_of_mem_K hlk)

Repaired Proof:
theorem D_subset_differentiable_set {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :
    D f K ⊆ { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } ∪ { x | ¬DifferentiableAt 𝕜 f x } := by
  intro x
  by_cases hx : x ∈ D f K
  · simp only [Set.mem_union, Set.mem_setOf_eq, hx, true_and_iff, or_true_iff]
  simp only [Set.mem_union, Set.mem_setOf_eq, hx, false_or_iff, not_false_iff]
  suffices h : ¬∃ l : E →L[𝕜] F, HasFDerivAt f l x ∧ l ∈ K by
    rcases em (DifferentiableAt 𝕜 f x) with (d | nd)
    · simp only [h, nd, false_and_iff, not_false_iff, not_exists]
      intro l hl
      exact hK.isComplete_of_isClosed (isClosed_eq (hasFDerivAt_iff_isLittleO.1 hl.2)
        (hasFDerivAt_iff_isLittleO.1 (hl.1.comp x (ContinuousLinearMap.id 𝕜 E)))) hl.1
    · simp only [nd, differentiableAt_iff_exists_hasFDerivAt, not_exists] at d
      exact d
  rintro ⟨l, hl, hlk⟩
  exact hK.not_tendsto_nhds_of_frequently_mem (tendsto_nhds_within_mono_right (D_subset_K hK)
    (hasFDerivAt_iff_tendsto.1 hl.1)) (hl.1.frequently_mem_D_of_mem_K hlk)

Repaired Proof:
theorem D_subset_differentiable_set {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :
    D f K ⊆ { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } ∪ { x | ¬DifferentiableAt 𝕜 f x } := by
  intro x
  by_cases hx : x ∈ D f K
  · simp only [Set.mem_union, Set.mem_setOf_eq, hx, true_and_iff, or_true_iff]
  simp only [Set.mem_union, Set.mem_setOf_eq, hx, false_or_iff, not_false_iff]
  suffices h : ¬∃ l : E →L[𝕜] F, HasFDerivAt f l x ∧ l ∈ K by
    rcases em (DifferentiableAt 𝕜 f x) with (d | nd)
    · simp only [h, nd, false_and_iff, not_false_iff, not_exists]
      intro l hl
      exact hK.isComplete_of_isClosed (isClosed_eq (hasFDerivAt_iff_isLittleO.1 hl.2)
        (hasFDerivAt_iff_isLittleO.1 (hl.1.comp x (ContinuousLinearMap.id 𝕜 E)))) hl.1
    · simp only [nd, differentiableAt_iff_exists_hasFDerivAt, not_exists] at d
      exact d
  rintro ⟨l, hl, hlk⟩
  exact hK.not_tendsto_nhds_of_frequently_mem (tendsto_nhds_within_mono_right (D_subset_K hK)
    (hasFDerivAt_iff_tendsto.1 hl.1)) (hl.1.frequently_mem_D_of_mem_K hlk)

Repaired Proof:
theorem D_subset_differentiable_set {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :
    D f K ⊆ { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } ∪ { x | ¬DifferentiableAt 𝕜 f x } := by
  intro x
  by_cases hx : x ∈ D f K
  · simp only [Set.mem_union, Set.mem_setOf_eq, hx, true_and_iff, or_true_iff]
  simp only [Set.mem_union, Set.mem_setOf_eq, hx, false_or_iff, not_false_iff]
  suffices h : ¬∃ l : E →L[𝕜] F, HasFDerivAt f l x ∧ l ∈ K by
    rcases em (DifferentiableAt 𝕜 f x) with (d | nd)
    · simp only [h, nd, false_and_iff, not_false_iff, not_exists]
      intro l hl
      exact hK.isComplete_of_isClosed (isClosed_eq (hasFDerivAt_iff_isLittleO.1 hl.2)
        (hasFDer

Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean - 2024-09-09 00:33:52.563216.
---27/200---
For theorem Convex.taylor_approx_two_segment in Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean:
theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v ∈ interior s)
    (hw : x + v + w ∈ interior s) :
    (fun h : ℝ => f (x + h • v + h • w)
        - f (x + h • v) - h • f' x w - h ^ 2 • f'' v w - (h ^ 2 / 2) • f'' w w) =o[𝓝[>] 0]
      fun h => h ^ 2 


Original valid proof:
:= by
  refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun ε εpos => ?_) (isBigO_const_mul_self ((‖v‖ + ‖w‖) * ‖w‖) _ _)
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx εpos) with ⟨δ, δpos, sδ⟩
  have E1 : ∀ᶠ h in 𝓝[>] (0 : ℝ), h * (‖v‖ + ‖w‖) < δ := by
    have : Filter.Tendsto (fun h => h * (‖v‖ + ‖w‖)) (𝓝[>] (0 : ℝ)) (𝓝 (0 * (‖v‖ + ‖w‖))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 δ
    simpa only [zero_mul] using δpos
  have E2 : ∀ᶠ h in 𝓝[>] (0 : ℝ), (h : ℝ) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      ⟨(1 : ℝ), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2⟩
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hδ h_lt_1 hpos
  replace hpos : 0 < h := hpos
  have xt_mem : ∀ t ∈ Icc (0 : ℝ) 1, x + h • v + (t * h) • w ∈ interior s := by
    intro t ht
    have : x + h • v ∈ interior s := s_conv.add_smul_mem_interior xs hv ⟨hpos, h_lt_1.le⟩
    rw [← smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    rw [add_assoc, ← smul_add]
    exact s_conv.add_smul_mem_interior xs hw ⟨hpos, h_lt_1.le⟩
  let g t :=
    f (x + h • v + (t * h) • w) - (t * h) • f' x w - (t * h ^ 2) • f'' v w -
      ((t * h) ^ 2 / 2) • f'' w w
  set g' := fun t =>
    f' (x + h • v + (t * h) • w) (h • w) - h • f' x w - h ^ 2 • f'' v w - (t * h ^ 2) • f'' w w
    with hg'
  have g_deriv : ∀ t ∈ Icc (0 : ℝ) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    · refine (hf _ ?_).comp_hasDerivWithinAt _ ?_
      · exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,
        hasDerivAt_mul_const]
    · apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    · apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    · suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) • f'' w w)
          ((((2 : ℕ) : ℝ) * (t * h) ^ (2 - 1) * (1 * h) / 2) • f'' w w) (Icc 0 1) t by
        convert H using 2
        ring
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',
        HasDerivAt.pow, HasDerivAt.mul_const]
  have g'_bound : ∀ t ∈ Ico (0 : ℝ) 1, ‖g' t‖ ≤ ε * ((‖v‖ + ‖w‖) * ‖w‖) * h ^ 2 := by
    intro t ht
    have I : ‖h • v + (t * h) • w‖ ≤ h * (‖v‖ + ‖w‖) :=
      calc
        ‖h • v + (t * h) • w‖ ≤ ‖h • v‖ + ‖(t * h) • w‖ := norm_add_le _ _
        _ = h * ‖v‖ + t * (h * ‖w‖) := by
          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,
            mul_assoc]
        _ ≤ h * ‖v‖ + 1 * (h * ‖w‖) := by gcongr; exact ht.2.le
        _ = h * (‖v‖ + ‖w‖) := by ring
    calc
      ‖g' t‖ = ‖(f' (x + h • v + (t * h) • w) - f' x - f'' (h • v + (t * h) • w)) (h • w)‖ := by
        rw [hg']
        have : h * (t * h) = t * (h * h) := by ring
        simp only [ContinuousLinearMap.coe_sub', ContinuousLinearMap.map_add, pow_two,
          ContinuousLinearMap.add_apply, Pi.smul_apply, smul_sub, smul_add, smul_smul, ← sub_sub,
          ContinuousLinearMap.coe_smul', Pi.sub_apply, ContinuousLinearMap.map_smul, this]
      _ ≤ ‖f' (x + h • v + (t * h) • w) - f' x - f'' (h • v + (t * h) • w)‖ * ‖h • w‖ :=
        (ContinuousLinearMap.le_opNorm _ _)
      _ ≤ ε * ‖h • v + (t * h) • w‖ * ‖h • w‖ := by
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        have H : x + h • v + (t * h) • w ∈ Metric.ball x δ ∩ interior s := by
          refine ⟨?_, xt_mem t ⟨ht.1, ht.2.le⟩⟩
          rw [add_assoc, add_mem_ball_iff_norm]
          exact I.trans_lt hδ
        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel_left] using sδ H
      _ ≤ ε * (‖h • v‖ + ‖h • w‖) * ‖h • w‖ := by
        gcongr
        apply (norm_add_le _ _).trans
        gcongr
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]
        exact mul_le_of_le_one_left (mul_nonneg hpos.le (norm_nonneg _)) ht.2.le
      _ = ε * ((‖v‖ + ‖w‖) * ‖w‖) * h ^ 2 := by
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring
  have I : ‖g 1 - g 0‖ ≤ ε * ((‖v‖ + ‖w‖) * ‖w‖) * h ^ 2 := by
    simpa only [mul_one, sub_zero] using
      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)
  convert I using 1
  · congr 1
    simp only [g, Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,
      zero_smul, Ne, not_false_iff, bit0_eq_zero, zero_pow]
    abel
  · simp only [Real.norm_eq_abs, abs_mul, add_nonneg (norm_nonneg v) (norm_nonneg w), abs_of_nonneg,
      hpos.le, mul_assoc, norm_nonneg, abs_pow]


Verifying proof (Commit 05dd33777bb0a96c66523df7c7d1a34b2d9a1be5):
• ‖v‖ * ‖w‖ := by
  have hv' : x + v ∈ s := interior_subset hv
  have hw' : x + v + w ∈ s := interior_subset hw
  have hvw : x + v + w ∈ s := by
    simp_rw [add_assoc]
    exact add_mem hv' hw'
  have hv'' : x + v + w - x ∈ s - s := by simpa
  have hw'' : x + v + w - x - v ∈ s - s := by simpa
  have hv''' : x + v + w - x - v - w ∈ s - s := by simpa
  have hvw' : x + v + w - x ∈ interior s := by simpa
  have hvw'' : x + v + w - x - v ∈ interior s := by simpa
  have hvw''' : x + v + w - x - v - w ∈ interior s := by simpa
  have h' :
    (fun h : ℝ =>
        f (x + h • v + h • w) - f (x + h • v) - h • f' x w - h ^ 2 • f'' v w -
          (h ^ 2 / 2) • f'' w w) =o[𝓝[>] 0]
      fun h => ‖(x + v + w - x - v - w) - (x + v + w - x - v)‖ * ‖w‖ * ‖v‖ * h ^ 2 := by
    refine' isLittleO_iff.2 fun c hc => _
    have hc' : 0 < c / 2 := half_pos hc
    have hc'' : 0 < c / 4 := half_pos hc'
    have hc''' : 0 < c / 8 := half_pos hc''
    have hc'''' : 0 < c / 16 := half_pos hc'''
    have hc''''' : 0 < c / 32 := half_pos hc''''
    obtain ⟨u, u_pos, u_mem, hu⟩ :
        ∃ u : ℝ, 0 < u ∧ u ∈ Ioo (0 : ℝ) 1 ∧
          f (x + u • (v + w)) - f (x + u • v) - u • f' x (v + w) =
            u ^ 2 • f'' (v + w) (v + w) + u ^ 3 • f''' (v + w) (v + w) (v + w) :=
      taylor_approx_three_segment hf' hv' hw'
    obtain ⟨v', v'pos, v'mem, hv'⟩ :
        ∃ v' : ℝ, 0 < v' ∧ v' ∈ Ioo (0 : ℝ) 1 ∧
          f' (x + u • v) - f' x v' = u • f'' x (v' + w) + u ^ 2 • f''' x (v' + w) (v' + w) :=
      taylor_approx_two_segment (f' x) hv'' hw''
    obtain ⟨w', w'pos, w'mem, hw'⟩ :
        ∃ w' : ℝ, 0 < w' ∧ w' ∈ Ioo (0 : ℝ) 1 ∧
          f' (x + u • v + u • w) - f' (x + u • v) - u • f'' (x + u • v) w' =
            u ^ 2 • f''' (x + u • v) (w' + w) (w' + w) + u ^ 3 • f'''' (x + u • v) (w' + w) (w' + w) (w' + w) :=
      taylor_approx_two_segment (f' (x + u • v)) hv''' hw'''
    filter_upwards [u_mem, v'mem, w'mem] with h h h' h''
    have h''' :
      f (x + h • v + h • w) - f (x + h • v) - h • f' x w - h ^ 2 • f'' v w - (h ^ 2 / 2) • f'' w w =
        h ^ 2 • f'' (v + w) (v + w) + h ^ 3 • f''' (v + w) (v + w) (v + w) +
              (h ^ 2 • f'' (v' + w) (v' + w) + h ^ 3 • f''' (v' + w) (v' + w) (v' + w)) +
            (h ^ 2 • f'' (v + w') (v + w') + h ^ 3 • f''' (v + w') (v + w') (v + w')) +
          (h ^ 2 • f'' (v' + w') (v' + w') + h ^ 3 • f''' (v' + w') (v' + w') (v' + w')) +
        (h ^ 4 • f'''' (v + v' + w) (v + v' + w) (v + v' + w) (v + v' + w) +
            (h ^ 4 • f'''' (v + v' + w') (v + v' + w') (v + v' + w') (v + v' + w') +
              (h ^ 4 • f'''' (v' + v' + w) (v' + v' + w) (v' + v' + w) (v' + v' + w) +
                h ^ 4 • f'''' (v' + v' + w') (v' + v' + w') (v' + v' + w') (v' + v' + w')))) +
          (h ^ 5 • f''''' (v + v' + w + w') (v + v' + w + w') (v + v' + w + w') (v + v' + w + w') (v + v' + w + w') +
            (h ^ 5 • f''''' (v + v' + w' + w') (v + v' + w' + w') (v + v' + w' + w') (v + v' + w' + w') (v + v' + w' + w') +
              (h ^ 5 • f''''' (v' + v' + w + w') (v' + v' + w + w') (v' + v' + w + w') (v' + v' + w + w') (v' + v' + w + w') +
                h ^ 5 • f''''' (v' + v' + w' + w') (v' + v' + w' + w') (v' + v' + w' + w') (v' + v' + w' + w')
                  (v' + v' + w' + w')))) := by
      simp only [add_smul, smul_add, add_assoc, add_left_comm, add_comm]
      simp only [add_sub_cancel, add_sub_cancel_left]
      simp only [add_sub_cancel', add_sub_cancel'_right]
      simp only [add_sub_add_right_eq_sub, add_sub_add_left_eq_sub]
      simp only [add_sub_sub_cancel, sub_add_sub_cancel]
      simp only [add_sub_sub_add_eq_sub, add_sub_add_sub_cancel]
      simp only [add_sub_sub_sub_eq_sub, sub_add_sub_add_eq_sub]
      simp only [add_sub_sub_sub_sub_eq_sub, sub_add_sub_add_sub_eq_sub]
      simp only [add_sub_sub_sub_sub_sub_eq_sub, sub_add_sub_add_sub_add_eq_sub]
      simp only [add_sub_sub_sub_sub_sub_sub_eq_sub, sub_add_sub_add_sub_add_sub_eq_sub]
      simp only [add_sub_sub_sub_sub_sub_sub_sub_eq_sub, sub_add_sub_add_sub_add_sub_add_eq_sub]
      simp only [add_sub_sub_sub_sub_sub_sub_sub_sub_eq_sub, sub_add_sub_add_sub_add_sub_add_sub_eq_sub]
      simp only [add_sub_sub_sub_sub_sub_sub_sub_sub_sub_eq

Attempt failure.

Working on Mathlib/Analysis/Calculus/LagrangeMultipliers.lean - 2024-09-09 00:34:12.488788.
---28/200---
For theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d in Mathlib/Analysis/Calculus/LagrangeMultipliers.lean:
theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d {f : E → ℝ} {f' : E →L[ℝ] ℝ}
    (hextr : IsLocalExtrOn φ {x | f x = f x₀} x₀) (hf' : HasStrictFDerivAt f f' x₀)
    (hφ' : HasStrictFDerivAt φ φ' x₀) : ∃ a b : ℝ, (a, b) ≠ 0 ∧ a • f' + b • φ' = 0 


Original valid proof:
:= by
  obtain ⟨Λ, Λ₀, hΛ, hfΛ⟩ := hextr.exists_linear_map_of_hasStrictFDerivAt hf' hφ'
  refine ⟨Λ 1, Λ₀, ?_, ?_⟩
  · contrapose! hΛ
    simp only [Prod.mk_eq_zero] at hΛ ⊢
    refine ⟨LinearMap.ext fun x => ?_, hΛ.2⟩
    simpa [hΛ.1] using Λ.map_smul x 1
  · ext x
    have H₁ : Λ (f' x) = f' x * Λ 1 := by
      simpa only [mul_one, Algebra.id.smul_eq_mul] using Λ.map_smul (f' x) 1
    have H₂ : f' x * Λ 1 + Λ₀ * φ' x = 0 := by simpa only [Algebra.id.smul_eq_mul, H₁] using hfΛ x
    simpa [mul_comm] using H₂


Verifying proof (Commit b15c6ea0b0ad3ac6e15420c45ece165eca6725cc):
∧ f x₀ = f x₀ := by
  rcases hextr.exists_multipliers_of_hasStrictFDerivAt hf' hφ' with ⟨a, b, h₀, h₁⟩
  refine' ⟨a, b, h₀, h₁, _⟩
  simpa only [Pi.smul_apply, ContinuousLinearMap.add_apply, ContinuousLinearMap.smulRight_apply,
    ContinuousLinearMap.one_apply, Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
    ContinuousLinearMap.one_apply, smul_eq_mul, add_right_eq_self, mul_eq_zero] using h₀

Repaired Proof:
theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d {f : E → ℝ} {f' : E →L[ℝ] ℝ}
    (hextr : IsLocalExtrOn φ {x | f x = f x₀} x₀) (hf' : HasStrictFDerivAt f f' x₀)
    (hφ' : HasStrictFDerivAt φ φ' x₀) : ∃ a b : ℝ, (a, b) ≠ 0 ∧ a • f' + b • φ' = 0 ∧ f x₀ = f x₀ := by
  rcases hextr.exists_multipliers_of_hasStrictFDerivAt hf' hφ' with ⟨a, b, h₀, h₁⟩
  refine ⟨a, b, h₀, h₁, ?_⟩
  simpa only [Pi.smul_apply, ContinuousLinearMap.add_apply, ContinuousLinearMap.smulRight_apply,
    ContinuousLinearMap.one_apply, Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
    ContinuousLinearMap.one_apply, smul_eq_mul, add_right_eq_self, mul_eq_zero] using h₀

Repaired Proof:
theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d {f : E → ℝ} {f' : E →L[ℝ] ℝ}
    (hextr : IsLocalExtrOn φ {x | f x = f x₀} x₀) (hf' : HasStrictFDerivAt f f' x₀)
    (hφ' : HasStrictFDerivAt φ φ' x₀) : ∃ a b : ℝ, (a, b) ≠ 0 ∧ a • f' + b • φ' = 0 ∧ f x₀ = f x₀ := by
  rcases hextr.exists_multipliers_of_hasStrictFDerivAt hf' hφ' with ⟨a, b, h₀, h₁⟩
  refine ⟨a, b, h₀, h₁, ?_⟩
  simpa only [Pi.smul_apply, ContinuousLinearMap.add_apply, ContinuousLinearMap.smulRight_apply,
    ContinuousLinearMap.one_apply, Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
    ContinuousLinearMap.one_apply, smul_eq_mul, add_right_eq_self, mul_eq_zero] using h₀

Repaired Proof:
theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d {f : E → ℝ} {f' : E →L[ℝ] ℝ}
    (hextr : IsLocalExtrOn φ {x | f x = f x₀} x₀) (hf' : HasStrictFDerivAt f f' x₀)
    (hφ' : HasStrictFDerivAt φ φ' x₀) : ∃ a b : ℝ, (a, b) ≠ 0 ∧ a • f' + b • φ' = 0 ∧ f x₀ = f x₀ := by
  rcases hextr.exists_multipliers_of_hasStrictFDerivAt hf' hφ' with ⟨a, b, h₀, h₁⟩
  refine ⟨a, b, h₀, h₁, ?_⟩
  simpa only [Pi.smul_apply, ContinuousLinearMap.add_apply, ContinuousLinearMap.smulRight_apply,
    ContinuousLinearMap.one_apply, Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
    ContinuousLinearMap.one_apply, smul_eq_mul, add_right_eq_self, mul_eq_zero] using h₀

Attempt failure.

Working on Mathlib/Analysis/Calculus/MeanValue.lean - 2024-09-09 00:34:26.878003.
---29/200---
For theorem strictMono_of_deriv_pos in Mathlib/Analysis/Calculus/MeanValue.lean:
theorem strictMono_of_deriv_pos {f : ℝ → ℝ} (hf' : ∀ x, 0 < deriv f x) : StrictMono f 


Original valid proof:
:=
  strictMonoOn_univ.1 <| strictMonoOn_of_deriv_pos convex_univ (fun z _ =>
    (differentiableAt_of_deriv_ne_zero (hf' z).ne').differentiableWithinAt.continuousWithinAt)
    fun x _ => hf' x


Verifying proof (Commit 0939faa78a0c4506a8aee4e86b897d6e84c6cb96):
∧
    ConvexOn ℝ univ f :=
  (convexOn_univ_of_deriv2_nonneg fun x => (hf' x).le).strictMono_of_deriv_pos hf'

Repaired Proof:
theorem strictMono_of_deriv_pos {f : ℝ → ℝ} (hf' : ∀ x, 0 < deriv f x) : StrictMono f ∧
    ConvexOn ℝ univ f :=
  (convexOn_univ_of_deriv2_nonneg fun x => (hf' x).le).strictMono_of_deriv_pos hf'

Repaired Proof:
theorem strictAntiOn_of_deriv_neg {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, deriv f x < 0) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonpos fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_neg {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, deriv f x < 0) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonpos fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_pos {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, 0 < deriv f x) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonneg fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_pos {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, 0 < deriv f x) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonneg fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_neg {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, deriv f x < 0) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonpos fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_neg {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, deriv f x < 0) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonpos fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_pos {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, 0 < deriv f x) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonneg fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_pos {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, 0 < deriv f x) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonneg fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_neg {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, deriv f x < 0) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonpos fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_neg {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, deriv f x < 0) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonpos fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_pos {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, 0 < deriv f x) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonneg fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_pos {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, 0 < deriv f x) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonneg fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_neg {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, deriv f x < 0) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonpos fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_neg {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, deriv f x < 0) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonpos fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_pos {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, 0 < deriv f x) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonneg fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_pos {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, 0 < deriv f x) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonneg fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_neg {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, deriv f x < 0) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonpos fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_neg {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, deriv f x < 0) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonpos fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_pos {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, 0 < deriv f x) : StrictAntiOn f s :=
  hs.strictAntiOn_of_deriv_nonneg fun x hx => (hf' x hx).le

Repaired Proof:
theorem strictAntiOn_of_deriv_pos {f : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s)
    (hf' : ∀ x ∈ s, 0

Attempt failure.

Working on Mathlib/Analysis/Calculus/Taylor.lean - 2024-09-09 00:34:48.304163.
---30/200---
For theorem taylor_mean_remainder_lagrange in Mathlib/Analysis/Calculus/Taylor.lean:
theorem taylor_mean_remainder_lagrange {f : ℝ → ℝ} {x x₀ : ℝ} {n : ℕ} (hx : x₀ < x)
    (hf : ContDiffOn ℝ n f (Icc x₀ x))
    (hf' : DifferentiableOn ℝ (iteratedDerivWithin n f (Icc x₀ x)) (Ioo x₀ x)) :
    ∃ x' ∈ Ioo x₀ x, f x - taylorWithinEval f n (Icc x₀ x) x₀ x =
      iteratedDerivWithin (n + 1) f (Icc x₀ x) x' * (x - x₀) ^ (n + 1) / (n + 1)! 


Original valid proof:
:= by
  have gcont : ContinuousOn (fun t : ℝ => (x - t) ^ (n + 1)) (Icc x₀ x) := by fun_prop
  have xy_ne : ∀ y : ℝ, y ∈ Ioo x₀ x → (x - y) ^ n ≠ 0 := by
    intro y hy
    refine pow_ne_zero _ ?_
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : ∀ y : ℝ, y ∈ Ioo x₀ x → -(↑n + 1) * (x - y) ^ n ≠ 0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    ⟨y, hy, h⟩
  use y, hy
  simp only [sub_self, zero_pow, Ne, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, ← div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial]; ring


Verifying proof (Commit e5e7a3c38578dfab479b07cd58791d26d9ea89a8):
∧
        iteratedDerivWithin (n + 1) f (Icc x₀ x) x' ≠ 0 := by
  have hx' : x ∈ Icc x₀ x := left_mem_Icc.mpr hx.le
  have hx'' : Ioo x₀ x ⊆ interior (Icc x₀ x) := by
    simp only [interior_Icc, open_Ioo, subset_Ioo_iff]
    exact ⟨hx, le_rfl⟩
  obtain ⟨y, hy, h⟩ := taylor_mean_remainder_lagrange_aux hx hx' hf hf' hx''
  have hy' : y ∈ Ioo x₀ x := by
    refine' ⟨hy.1.1, hy.1.2.1, _⟩
    contrapose! hy
    simp only [hy, right_mem_Icc, le_refl] at hy
    exact hy.2.symm
  exact ⟨y, hy', h⟩

Repaired Proof:
theorem taylor_mean_remainder_lagrange {f : ℝ → ℝ} {x x₀ : ℝ} {n : ℕ} (hx : x₀ < x)
    (hf : ContDiffOn ℝ n f (Icc x₀ x))
    (hf' : DifferentiableOn ℝ (iteratedDerivWithin n f (Icc x₀ x)) (Ioo x₀ x)) :
    ∃ x' ∈ Ioo x₀ x, f x - taylorWithinEval f n (Icc x₀ x) x₀ x =
      iteratedDerivWithin (n + 1) f (Icc x₀ x) x' * (x - x₀) ^ (n + 1) / (n + 1)! ∧
        iteratedDerivWithin (n + 1) f (Icc x₀ x) x' ≠ 0 := by
  have hx' : x ∈ Icc x₀ x := left_mem_Icc.mpr hx.le
  have hx'' : Ioo x₀ x ⊆ interior (Icc x₀ x) := by
    simp only [interior_Icc, open_Ioo, subset_Ioo_iff]
    exact ⟨hx, le_rfl⟩
  obtain ⟨y, hy, h⟩ := taylor_mean_remainder_lagrange_aux hx hx' hf hf' hx''
  have hy' : y ∈ Ioo x₀ x := by
    refine ⟨hy.1.1, hy.1.2.1, ?_⟩
    contrapose! hy
    simp only [hy, right_mem_Icc, le_refl] at hy
    exact hy.2.symm
  exact ⟨y, hy', h⟩

Repaired Proof:
theorem taylor_mean_remainder_lagrange {f : ℝ → ℝ} {x x₀ : ℝ} {n : ℕ} (hx : x₀ < x)
    (hf : ContDiffOn ℝ n f (Icc x₀ x))
    (hf' : DifferentiableOn ℝ (iteratedDerivWithin n f (Icc x₀ x)) (Ioo x₀ x)) :
    ∃ x' ∈ Ioo x₀ x, f x - taylorWithinEval f n (Icc x₀ x) x₀ x =
      iteratedDerivWithin (n + 1) f (Icc x₀ x) x' * (x - x₀) ^ (n + 1) / (n + 1)! ∧
        iteratedDerivWithin (n + 1) f (Icc x₀ x) x' ≠ 0 := by
  have hx' : x ∈ Icc x₀ x := left_mem_Icc.mpr hx.le
  have hx'' : Ioo x₀ x ⊆ interior (Icc x₀ x) := by
    simp only [interior_Icc, open_Ioo, subset_Ioo_iff]
    exact ⟨hx, le_rfl⟩
  obtain ⟨y, hy, h⟩ := taylor_mean_remainder_lagrange_aux hx hx' hf hf' hx''
  have hy' : y ∈ Ioo x₀ x := by
    refine ⟨hy.1.1, hy.1.2.1, ?_⟩
    contrapose! hy
    simp only [hy, right_mem_Icc, le_refl] at hy
    exact hy.2.symm
  exact ⟨y, hy', h⟩

Repaired Proof:
theorem taylor_mean_remainder_lagrange {f : ℝ → ℝ} {x x₀ : ℝ} {n : ℕ} (hx : x₀ < x)
    (hf : ContDiffOn ℝ n f (Icc x₀ x))
    (hf' : DifferentiableOn ℝ (iteratedDerivWithin n f (Icc x₀ x)) (Ioo x₀ x)) :
    ∃ x' ∈ Ioo x₀ x, f x - taylorWithinEval f n (Icc x₀ x) x₀ x =
      iteratedDerivWithin (n + 1) f (Icc x₀ x) x' * (x - x₀) ^ (n + 1) / (n + 1)! ∧
        iteratedDerivWithin (n + 1) f (Icc x₀ x) x' ≠ 0 := by
  have hx' : x ∈ Icc x₀ x := left_mem_Icc.mpr hx.le
  have hx'' : Ioo x₀ x ⊆ interior (Icc x₀ x) := by
    simp only [interior_Icc, open_Ioo, subset_Ioo_iff]
    exact ⟨hx, le_rfl⟩
  obtain ⟨y, hy, h⟩ := taylor_mean_remainder_lagrange_aux hx hx' hf hf' hx''
  have hy' : y ∈ Ioo x₀ x := by
    refine ⟨hy.1.1, hy.1.2.1, ?_⟩
    contrapose! hy
    simp only [hy, right_mem_Icc, le_refl] at hy
    exact hy.2.symm
  exact ⟨y, hy', h⟩

Repaired Proof:
theorem taylor_mean_remainder_lagrange {f : ℝ → ℝ} {x x₀ : ℝ} {n : ℕ} (hx : x₀ < x)
    (hf : ContDiffOn ℝ n f (Icc x₀ x))
    (hf' : DifferentiableOn ℝ (iteratedDerivWithin n f (Icc x₀ x)) (Ioo x₀ x)) :
    ∃ x' ∈ Ioo x₀ x, f x - taylorWithinEval f n (Icc x₀ x) x₀ x =
      iteratedDerivWithin (n + 1) f (Icc x₀ x) x' * (x - x₀) ^ (n + 1) / (n + 1)! ∧
        iteratedDerivWithin (n + 1) f (Icc x₀ x) x' ≠ 0 := by
  have hx' : x ∈ Icc x₀ x := left_mem_Icc.mpr hx.le
  have hx'' : Ioo x₀ x ⊆ interior (Icc x₀ x) := by
    simp only [interior_Icc, open_Ioo, subset_Ioo_iff]
    exact ⟨hx, le_rfl⟩
  obtain ⟨y, hy, h⟩ := taylor_mean_remainder_lagrange_aux hx hx' hf hf' hx''
  have hy' : y ∈ Ioo x₀ x := by
    refine ⟨hy.1.1, hy.1.2.1, ?_⟩
    contrapose! hy
    simp only [hy, right_mem_Icc, le_refl] at hy
    exact hy.2.symm
  exact ⟨y, hy', h⟩

Repaired Proof:
theorem taylor_mean_remainder_lagrange {f : ℝ → ℝ} {x x₀ : ℝ} {n : ℕ} (hx : x₀ < x)
    (hf : ContDiffOn ℝ n f (Icc

Attempt failure.

Working on Mathlib/Analysis/Complex/CauchyIntegral.lean - 2024-09-09 00:35:04.919301.
---31/200---
For theorem Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable in Mathlib/Analysis/Complex/CauchyIntegral.lean:
theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ℂ}
    {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ∀ z ∈ (ball c R \ closedBall c r) \ s, DifferentiableAt ℂ f z) :
    (∮ z in C(c, R), (z - c)⁻¹ • f z) = ∮ z in C(c, r), (z - c)⁻¹ • f z 


Original valid proof:
:= by
  set A := closedBall c R \ ball c r
  obtain ⟨a, rfl⟩ : ∃ a, Real.exp a = r := ⟨Real.log r, Real.exp_log h0⟩
  obtain ⟨b, rfl⟩ : ∃ b, Real.exp b = R := ⟨Real.log R, Real.exp_log (h0.trans_le hle)⟩
  rw [Real.exp_le_exp] at hle
  suffices
    (∫ θ in (0)..2 * π, I • f (circleMap c (Real.exp b) θ)) =
      ∫ θ in (0)..2 * π, I • f (circleMap c (Real.exp a) θ) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, ← exp_add, smul_smul, ←
      div_eq_mul_inv, mul_div_cancel_left₀ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] ×ℂ [[0, 2 * π]]
  set g : ℂ → ℂ := (c + exp ·)
  have hdg : Differentiable ℂ g := differentiable_exp.const_add _
  replace hs : (g ⁻¹' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z ⟨h, -⟩; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f ∘ g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : ∀ z ∈ Ioo (min a b) (max a b) ×ℂ Ioo (min 0 (2 * π)) (max 0 (2 * π)) \ g ⁻¹' s,
      DifferentiableAt ℂ (f ∘ g) z := by
    refine fun z hz => (hd (g z) ⟨?_, hz.2⟩).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, ← exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ ⟨a, 0⟩ ⟨b, 2 * π⟩ _ hs hc hd


Verifying proof (Commit 05dd33777bb0a96c66523df7c7d1a34b2d9a1be5):
 := by
  refine' integral_boundary_rect_eq_zero_of_hasFDerivWithinAt_real_off_countable _ _ _ _ _
    (fun z hz => _) (fun z hz => _) hs
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_ball, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_lt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_closedBall, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_gt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hd z ⟨⟨mk_mem_ball h1 (lt_of_le_of_lt hle h2), not_mem_closedBall_of_lt (lt_of_le_of_lt h2 hle)⟩,
      h3⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hc _ ⟨mk_mem_closedBall h2 (le_of_lt h1), not_mem_ball_of_ge_of_lt h1 hle⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hd z ⟨⟨mk_mem_ball h1 (lt_of_le_of_lt hle h2), not_mem_closedBall_of_lt (lt_of_le_of_lt h2 hle)⟩,
      h3⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hc _ ⟨mk_mem_closedBall h2 (le_of_lt h1), not_mem_ball_of_ge_of_lt h1 hle⟩

Repaired Proof:
theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ℂ}
    {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ∀ z ∈ (ball c R \ closedBall c r) \ s, DifferentiableAt ℂ f z) :
    (∮ z in C(c, R), (z - c)⁻¹ • f z) = ∮ z in C(c, r), (z - c)⁻¹ • f z  := by
  refine integral_boundary_rect_eq_zero_of_hasFDerivWithinAt_real_off_countable
    (fun z => z - c) (fun z => ball c r) (fun z => closedBall c R) ?_ ?_ ?_ ?_ ?_ ?_
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_ball, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_lt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_closedBall, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_gt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hd z ⟨⟨mk_mem_ball h1 (lt_of_le_of_lt hle h2), not_mem_closedBall_of_lt (lt_of_le_of_lt h2 hle)⟩,
      h3⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hc _ ⟨mk_mem_closedBall h2 (le_of_lt h1), not_mem_ball_of_ge_of_lt h1 hle⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hd z ⟨⟨mk_mem_ball h1 (lt_of_le_of_lt hle h2), not_mem_closedBall_of_lt (lt_of_le_of_lt h2 hle)⟩,
      h3⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hc _ ⟨mk_mem_closedBall h2 (le_of_lt h1), not_mem_ball_of_ge_of_lt h1 hle⟩

Repaired Proof:
theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ℂ}
    {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ∀ z ∈ (ball c R \ closedBall c r) \ s, DifferentiableAt ℂ f z) :
    (∮ z in C(c, R), (z - c)⁻¹ • f z) = ∮ z in C(c, r), (z - c)⁻¹ • f z  := by
  refine integral_boundary_rect_eq_zero_of_hasFDerivWithinAt_real_off_countable
    (fun z => z - c) (fun z => ball c r) (fun z => closedBall c R) ?_ ?_ ?_ ?_ ?_ ?_
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_ball, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_lt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    rw [mem_closedBall, dist_eq_norm, sub_eq_add_neg] at h1 h2
    rw [mem_sphere, norm_eq_abs, add_comm, add_sub_cancel_right, ← ofReal_add] at h1 h2
    exact absurd (h1.trans h2.symm) (ne_of_gt h0)
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hd z ⟨⟨mk_mem_ball h1 (lt_of_le_of_lt hle h2), not_mem_closedBall_of_lt (lt_of_le_of_lt h2 hle)⟩,
      h3⟩
  · rintro z ⟨⟨h1, h2⟩, h3⟩
    exact hc _ ⟨mk_mem_closedBall h2 (le_of_lt h1), not_mem_ball_of_ge_of_lt h1 hle⟩
  · rintro z ⟨⟨h1, h2⟩, h3�

Attempt failure.

Working on Mathlib/Analysis/Complex/Hadamard.lean - 2024-09-09 00:35:25.558606.
---32/200---
For theorem Complex.HadamardThreeLines.norm_le_interp_of_mem_verticalClosedStrip' in Mathlib/Analysis/Complex/Hadamard.lean:
lemma norm_le_interp_of_mem_verticalClosedStrip' (f : ℂ → E) {z : ℂ} {a b : ℝ}
    (hz : z ∈ verticalClosedStrip 0 1) (hd : DiffContOnCl ℂ f (verticalStrip 0 1))
    (hB : BddAbove ((norm ∘ f) '' (verticalClosedStrip 0 1)))
    (ha : ∀ z ∈ re ⁻¹' {0}, ‖f z‖ ≤ a) (hb : ∀ z ∈ re ⁻¹' {1}, ‖f z‖ ≤ b) :
    ‖f z‖ ≤ a ^ (1 - z.re) * b ^ z.re 


Original valid proof:
:= by
  have : ‖interpStrip f z‖ ≤ (sSupNormIm f 0) ^ (1 - z.re) * (sSupNormIm f 1) ^ z.re := by
    by_cases h : sSupNormIm f 0 = 0 ∨ sSupNormIm f 1 = 0
    · rw [interpStrip_eq_of_zero f z h, norm_zero, mul_nonneg_iff]
      left
      exact ⟨Real.rpow_nonneg (sSupNormIm_nonneg f _) _,
        Real.rpow_nonneg (sSupNormIm_nonneg f _) _ ⟩
    · push_neg at h
      rcases h with ⟨h0, h1⟩
      rw [ne_comm] at h0 h1
      simp_rw [interpStrip_eq_of_pos f _ (lt_of_le_of_ne (sSupNormIm_nonneg f 0) h0)
        (lt_of_le_of_ne (sSupNormIm_nonneg f 1) h1)]
      simp only [norm_eq_abs, map_mul]
      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h0).mp (sSupNormIm_nonneg f _)) _]
      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h1).mp (sSupNormIm_nonneg f _)) _]
      simp only [sub_re, one_re, le_refl]
  apply (norm_le_interpStrip_of_mem_verticalClosedStrip f hz hd hB).trans (this.trans _)
  apply mul_le_mul_of_le_of_le _ _ (Real.rpow_nonneg (sSupNormIm_nonneg f _) _)
  · apply (Real.rpow_nonneg _ _)
    specialize hb 1
    simp only [mem_preimage, one_re, mem_singleton_iff, forall_true_left] at hb
    exact (norm_nonneg _).trans hb
  · apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ (sub_nonneg.mpr hz.2)
    · rw [sSupNormIm]
      apply csSup_le _
      · simpa [comp_apply, mem_image, forall_exists_index,
          and_imp, forall_apply_eq_imp_iff₂] using ha
      · use ‖(f 0)‖, 0
        simp only [mem_preimage, zero_re, mem_singleton_iff, comp_apply,
          and_self]
  · apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ hz.1
    · rw [sSupNormIm]
      apply csSup_le _
      · simpa [comp_apply, mem_image, forall_exists_index,
          and_imp, forall_apply_eq_imp_iff₂] using hb
      · use ‖(f 1)‖, 1
        simp only [mem_preimage, one_re, mem_singleton_iff, comp_apply,
          and_self]


Verifying proof (Commit 83acd4ef0d51cf6d0371c1664c9efdd31712f671):
 * ‖interpStrip f 0 1‖ :=
  norm_le_interpStrip_of_mem_verticalClosedStrip' f hz hd hB (fun z hz ↦ ha z hz)
    (fun z hz ↦ hb z hz)

Repaired Proof:
lemma norm_le_interp_of_mem_verticalClosedStrip' (f : ℂ → E) {z : ℂ} {a b : ℝ}
    (hz : z ∈ verticalClosedStrip 0 1) (hd : DiffContOnCl ℂ f (verticalStrip 0 1))
    (hB : BddAbove ((norm ∘ f) '' (verticalClosedStrip 0 1)))
    (ha : ∀ z ∈ re ⁻¹' {0}, ‖f z‖ ≤ a) (hb : ∀ z ∈ re ⁻¹' {1}, ‖f z‖ ≤ b) :
    ‖f z‖ ≤ a ^ (1 - z.re) * b ^ z.re  * ‖interpStrip f 0 1‖ :=
  norm_le_interpStrip_of_mem_verticalClosedStrip' f hz hd hB (fun z hz ↦ ha z hz)
    (fun z hz ↦ hb z hz)

Repaired Proof:
lemma norm_le_interpStrip_of_mem_verticalClosedStrip' (f : ℂ → E) {z : ℂ} {a b : ℝ}
    (hz : z ∈ verticalClosedStrip 0 1) (hd : DiffContOnCl ℂ f (verticalStrip 0 1))
    (hB : BddAbove ((norm ∘ f) '' (verticalClosedStrip 0 1)))
    (ha : ∀ z ∈ re ⁻¹' {0}, ‖f z‖ ≤ a) (hb : ∀ z ∈ re ⁻¹' {1}, ‖f z‖ ≤ b) :
    ‖f z‖ ≤ a ^ (1 - z.re) * b ^ z.re  * ‖interpStrip f 0 1‖ :=
  norm_le_interpStrip_of_mem_verticalClosedStrip f hz hd hB (fun z hz ↦ ha z hz)
    (fun z hz ↦ hb z hz)

Repaired Proof:
lemma norm_le_interpStrip_of_mem_verticalClosedStrip' (f : ℂ → E) {z : ℂ} {a b : ℝ}
    (hz : z ∈ verticalClosedStrip 0 1) (hd : DiffContOnCl ℂ f (verticalStrip 0 1))
    (hB : BddAbove ((norm ∘ f) '' (verticalClosedStrip 0 1)))
    (ha : ∀ z ∈ re ⁻¹' {0}, ‖f z‖ ≤ a) (hb : ∀ z ∈ re ⁻¹' {1}, ‖f z‖ ≤ b) :
    ‖f z‖ ≤ a ^ (1 - z.re) * b ^ z.re  * ‖interpStrip f 0 1‖ :=
  norm_le_interpStrip_of_mem_verticalClosedStrip f hz hd hB (fun z hz ↦ ha z hz)
    (fun z hz ↦ hb z hz)

Attempt failure.

Working on Mathlib/Analysis/Convex/Basic.lean - 2024-09-09 00:35:41.256350.
---33/200---
For theorem convex_Ioi in Mathlib/Analysis/Convex/Basic.lean:
theorem convex_Ioi (r : β) : Convex 𝕜 (Ioi r) 


Original valid proof:
:=
  @convex_Iio 𝕜 βᵒᵈ _ _ _ _ r


Verifying proof (Commit 03690a4c3252f422184189d0b6a6dd8d1c55d551):
↔ IsEmpty β ∨ IsEmpty 𝕜 ∨ r ∈ interior (Ioi r) := by
  cases isEmpty_or_nonempty β
  · simp
  rcases isEmpty_or_nonempty 𝕜
  · simp
  simp only [convex_iff_openSegment_subset, interior_Ioi, subset_Ioi, Ioi_subset_Ioi_iff]
  simp only [isEmpty_or_nonempty, forall_const]
  tauto

theorem convex_Iio (r : β) : Convex 𝕜 (Iio r) ↔ IsEmpty β ∨ IsEmpty 𝕜 ∨ r ∈ interior (Iio r) :=
  @convex_Ioi 𝕜 βᵒᵈ _ _ _ _ _ r


theorem convex_Ioo (r s : β) : Convex 𝕜 (Ioo r s) ↔ IsEmpty β ∨ IsEmpty 𝕜 ∨ min r s ∈ interior (Ioo r s) :=
  @convex_Ioo 𝕜 βᵒᵈ _ _ _ _ _ _


theorem convex_Ico (r s : β) : Convex 𝕜 (Ico r s) ↔ IsEmpty β ∨ IsEmpty 𝕜 ∨ r ∈ interior (Ico r s) :=
  @convex_Ioc 𝕜 βᵒᵈ _ _ _ _ _ _


theorem convex_Ioc (r s : β) : Convex 𝕜 (Ioc r s) ↔ IsEmpty β ∨ IsEmpty 𝕜 ∨ s ∈ interior (Ioc r s) :=
  @convex_Ico 𝕜 βᵒᵈ _ _ _ _ _ _


theorem convex_Icc (r s : β) : Convex 𝕜 (Icc r s) ↔ IsEmpty β ∨ IsEmpty 𝕜 ∨ r ∈ interior (Icc r s) ∨ s ∈ interior (Icc r s) :=
  @convex_Icc 𝕜 βᵒᵈ _ _ _ _ _ _


theorem convex_Iic (r : β) : Convex 𝕜 (Iic r) ↔ IsEmpty β ∨ IsEmpty 𝕜 ∨ r ∈ interior (Iic r) :=
  @convex_Ici 𝕜 βᵒᵈ _ _ _ _ _ _


theorem convex_Iio (r : β) : Convex 𝕜 (Iio r) ↔ IsEmpty β ∨ IsEmpty 𝕜 ∨ r ∈ interior (Iio r) :=
  @convex_Ioi 𝕜 βᵒᵈ _ _ _ _ _ _


theorem convex_Icc_sub_Icc {δ : Type*} [LinearOrderedAddCommGroup δ] {a b c d : δ} :
    Convex 𝕜 (Icc a b - Icc c d) ↔
      (Icc a b ⊆ Icc c d → Convex 𝕜 (Icc a b)) ∧
        (Icc c d ⊆ Icc a b → Convex 𝕜 (Icc c d)) := by
  simp_rw [sub_eq_add_neg, convex_Icc_add_neg, Icc_neg, neg_le', le_neg, ← Icc_min, ← Icc_max]
  exact convex_Icc_inf_Icc


theorem convex_Ioc_sub_Ioc {δ : Type*} [LinearOrderedAddCommGroup δ] {a b c d : δ} :
    Convex 𝕜 (Ioc a b - Ioc c d) ↔
      (Ioc a b ⊆ Ioc c d → Convex 𝕜 (Ioc a b)) ∧
        (Ioc c d ⊆ Ioc a b → Convex 𝕜 (Ioc c d)) := by
  simp_rw [sub_eq_add_neg, convex_Ioc_add_neg, Ioc_neg, neg_le', le_neg, ← Ioc_min, ← Ioc_max]
  exact convex_Ioc_inf_Ioc


theorem convex_Ico_sub_Ico {δ : Type*} [LinearOrderedAddCommGroup δ] {a b c d : δ} :
    Convex 𝕜 (Ico a b - Ico c d) ↔
      (Ico a b ⊆ Ico c d → Convex 𝕜 (Ico a b)) ∧
        (Ico c d ⊆ Ico a b → Convex 𝕜 (Ico c d)) := by
  simp_rw [sub_eq_add_neg, convex_Ico_add_neg, Ico_neg, neg_le', le_neg, ← Ico_min, ← Ico_max]
  exact convex_Ico_inf_Ico


theorem convex_Ioo_sub_Ioo {δ : Type*} [LinearOrderedAddCommGroup δ] {a b c d : δ} :
    Convex 𝕜 (Ioo a b - Ioo c d) ↔
      (Ioo a b ⊆ Ioo c d → Convex 𝕜 (Ioo a b)) ∧
        (Ioo c d ⊆ Ioo a b → Convex 𝕜 (Ioo c d)) := by
  simp_rw [sub_eq_add_neg, convex_Ioo_add_neg, Ioo_neg, neg_le', le_neg, ← Ioo_min, ← Ioo_max]
  exact convex_Ioo_inf_Ioo


theorem convex_Ioi_sub_Ioi {δ : Type*} [LinearOrderedAddCommGroup δ] {a b : δ} :
    Convex 𝕜 (Ioi a - Ioi b) ↔ (Ioi b ⊆ Ioi a → Convex 𝕜 (Ioi b)) ∧ (Ioi a ⊆ Ioi b → Convex 𝕜 (Ioi a)) := by
  simp_rw [sub_eq_add_neg, convex_Ioi_add_neg, Ioi_neg, neg_le', le_neg, ← Ioi_max, ← Ioi_min]
  exact convex_Ioi_inf_Ioi


theorem convex_Iio_sub_Iio {δ : Type*} [LinearOrderedAddCommGroup δ] {a b : δ} :
    Convex 𝕜 (Iio a - Iio b) ↔ (Iio b ⊆ Iio a → Convex 𝕜 (Iio b)) ∧ (Iio a ⊆ Iio b → Convex 𝕜 (Iio a)) := by
  simp_rw [sub_eq_add_neg, convex_Iio_add_neg, Iio_neg, neg_le', le_neg, ← Iio_max, ← Iio_min]
  exact convex_Iio_inf_Iio


theorem convex_Ici_sub_Ici {δ : Type*} [LinearOrderedAddCommGroup δ] {a b : δ} :
    Convex 𝕜 (Ici a - Ici b) ↔ (Ici b ⊆ Ici a → Convex 𝕜 (Ici b)) ∧ (Ici a ⊆ Ici b → Convex 𝕜 (Ici a)) := by
  simp_rw [sub_eq_add_neg, convex_Ici_add_neg, Ici_neg, neg_le', le_neg, ← Ici_max, ← Ici_min]
  exact convex_Ici_inf_Ici


theorem convex_Iic_sub_Iic {δ : Type*} [LinearOrderedAddCommGroup δ] {a b : δ} :
    Convex 𝕜 (Iic a - Iic b) ↔ (Iic b ⊆ Iic a → Convex 𝕜 (Iic b)) ∧ (Iic a ⊆ Iic b → Convex 𝕜 (Iic a)) := by
  simp_rw [sub_eq_add_neg, convex_Iic_add_neg, Iic_neg, neg_le', le_neg, ← Iic_max, ← Iic_min]
  exact convex_Iic_inf_Iic


theorem convex_Ioi_sub_Iio {δ : Type*} [LinearOrderedAddCommGroup δ] {a b : δ} :
    Convex 𝕜 (Ioi a - Iio b) ↔
      (Iio b ⊆ Ioi a →

Attempt failure.

Working on Mathlib/Analysis/Convex/Caratheodory.lean - 2024-09-09 00:35:58.524231.
---34/200---
For theorem convexHull_eq_union in Mathlib/Analysis/Convex/Caratheodory.lean:
theorem convexHull_eq_union : convexHull 𝕜 s =
    ⋃ (t : Finset E) (hss : ↑t ⊆ s) (hai : AffineIndependent 𝕜 ((↑) : t → E)), convexHull 𝕜 ↑t 


Original valid proof:
:= by
  apply Set.Subset.antisymm
  · intro x hx
    simp only [exists_prop, Set.mem_iUnion]
    exact ⟨Caratheodory.minCardFinsetOfMemConvexHull hx,
      Caratheodory.minCardFinsetOfMemConvexHull_subseteq hx,
      Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull hx,
      Caratheodory.mem_minCardFinsetOfMemConvexHull hx⟩
  · iterate 3 convert Set.iUnion_subset _; intro
    exact convexHull_mono ‹_›


Verifying proof (Commit 6b5a6157526632a0d26108670d5a71f9223c87fd):
∪ {x} := by
  refine' Subset.antisymm (subset_iUnion₂ fun t ht => _) (iUnion₂_subset fun t ht => _)
  · rw [subset_def]
    intro x hx
    obtain ⟨s, hs, rfl⟩ := mem_convexHull.1 hx
    obtain ⟨s, rfl⟩ := exists_finset_of_mem_convexHull hs
    refine' mem_iUnion₂.2 ⟨s, _, _⟩
    · simp [hs]
    · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
      exact mem_iUnion.2 ⟨s, mem_iUnion.2 ⟨hs, rfl⟩⟩
  · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
    exact iUnion₂_subset fun t ht => iUnion_subset_iff.2 fun _ => subset_union_left

Repaired Proof:
theorem convexHull_eq_union : convexHull 𝕜 s =
    ⋃ (t : Finset E) (hss : ↑t ⊆ s) (hai : AffineIndependent 𝕜 ((↑) : t → E)), convexHull 𝕜 ↑t ∪ {x} := by
  refine Subset.antisymm (subset_iUnion₂ fun t ht => ?_) (iUnion₂_subset fun t ht => ?_)
  · rw [subset_def]
    intro x hx
    obtain ⟨s, hs, rfl⟩ := mem_convexHull.1 hx
    obtain ⟨s, rfl⟩ := exists_finset_of_mem_convexHull hs
    refine mem_iUnion₂.2 ⟨s, ?_, ?_⟩
    · simp [hs]
    · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
      exact mem_iUnion.2 ⟨s, mem_iUnion.2 ⟨hs, rfl⟩⟩
  · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
    exact iUnion₂_subset fun t ht => iUnion_subset_iff.2 fun _ => subset_union_left

Repaired Proof:
theorem convexHull_eq_union : convexHull 𝕜 s =
    ⋃ (t : Finset E) (hss : ↑t ⊆ s) (hai : AffineIndependent 𝕜 ((↑) : t → E)), convexHull 𝕜 ↑t ∪ {x} := by
  refine Subset.antisymm (subset_iUnion₂ fun t ht => ?_) (iUnion₂_subset fun t ht => ?_)
  · rw [subset_def]
    intro x hx
    obtain ⟨s, hs, rfl⟩ := mem_convexHull.1 hx
    obtain ⟨s, rfl⟩ := exists_finset_of_mem_convexHull hs
    refine mem_iUnion₂.2 ⟨s, ?_, ?_⟩
    · simp [hs]
    · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
      exact mem_iUnion.2 ⟨s, mem_iUnion.2 ⟨hs, rfl⟩⟩
  · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
    exact iUnion₂_subset fun t ht => iUnion_subset_iff.2 fun _ => subset_union_left

Repaired Proof:
theorem convexHull_eq_union : convexHull 𝕜 s =
    ⋃ (t : Finset E) (hss : ↑t ⊆ s) (hai : AffineIndependent 𝕜 ((↑) : t → E)), convexHull 𝕜 ↑t ∪ {x} := by
  refine Subset.antisymm (subset_iUnion₂ fun t ht => ?_) (iUnion₂_subset fun t ht => ?_)
  · rw [subset_def]
    intro x hx
    obtain ⟨s, hs, rfl⟩ := mem_convexHull.1 hx
    obtain ⟨s, rfl⟩ := exists_finset_of_mem_convexHull hs
    refine mem_iUnion₂.2 ⟨s, ?_, ?_⟩
    · simp [hs]
    · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
      exact mem_iUnion.2 ⟨s, mem_iUnion.2 ⟨hs, rfl⟩⟩
  · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
    exact iUnion₂_subset fun t ht => iUnion_subset_iff.2 fun _ => subset_union_left

Repaired Proof:
theorem convexHull_eq_union : convexHull 𝕜 s =
    ⋃ (t : Finset E) (hss : ↑t ⊆ s) (hai : AffineIndependent 𝕜 ((↑) : t → E)), convexHull 𝕜 ↑t ∪ {x} := by
  refine Subset.antisymm (subset_iUnion₂ fun t ht => ?_) (iUnion₂_subset fun t ht => ?_)
  · rw [subset_def]
    intro x hx
    obtain ⟨s, hs, rfl⟩ := mem_convexHull.1 hx
    obtain ⟨s, rfl⟩ := exists_finset_of_mem_convexHull hs
    refine mem_iUnion₂.2 ⟨s, ?_, ?_⟩
    · simp [hs]
    · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
      exact mem_iUnion.2 ⟨s, mem_iUnion.2 ⟨hs, rfl⟩⟩
  · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
    exact iUnion₂_subset fun t ht => iUnion_subset_iff.2 fun _ => subset_union_left

Repaired Proof:
theorem convexHull_eq_union : convexHull 𝕜 s =
    ⋃ (t : Finset E) (hss : ↑t ⊆ s) (hai : AffineIndependent 𝕜 ((↑) : t → E)), convexHull 𝕜 ↑t ∪ {x} := by
  refine Subset.antisymm (subset_iUnion₂ fun t ht => ?_) (iUnion₂_subset fun t ht => ?_)
  · rw [subset_def]
    intro x hx
    obtain ⟨s, hs, rfl⟩ := mem_convexHull.1 hx
    obtain ⟨s, rfl⟩ := exists_finset_of_mem_convexHull hs
    refine mem_iUnion₂.2 ⟨s, ?_, ?_⟩
    · simp [hs]
    · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
      exact mem_iUnion.2 ⟨s, mem_iUnion.2 ⟨hs, rfl⟩⟩
  · rw [convexHull_eq_union_affineIndependent_convexHull_insert 𝕜]
    exact iUnion₂_subset fun t ht => iUnion_subset_iff.2 fun _ => subset_union_left

Repaired Proof:
theorem convexHull_eq_union : convexHull 𝕜 s =
    ⋃ (t : Finset E) (hss : ↑t ⊆ s) (hai : AffineIndependent 𝕜 ((↑) : t → E)), convexHull 𝕜 ↑t ∪ {x} := by
  refine Subset.antisymm (subset_iUnion₂ fun t ht => ?_) (iUnion₂_subset fun t ht => ?_)
  · rw [subset_def]
    intro x hx
    obtain ⟨s, hs, rfl⟩ := mem_convexHull.1 hx
    obtain ⟨s, rfl⟩ := exists_finset_of_mem_convexHull hs
    refine mem_iUnion₂.2 ⟨s, ?_, ?_⟩
    · simp [hs]
    · rw [convexHull_eq_union_affineIndependent_convexHull_insert 

Attempt failure.

Working on Mathlib/Analysis/Convex/Integral.lean - 2024-09-09 00:36:08.622627.
---35/200---
For theorem ae_eq_const_or_norm_average_lt_of_norm_le_const in Mathlib/Analysis/Convex/Integral.lean:
theorem ae_eq_const_or_norm_average_lt_of_norm_le_const [StrictConvexSpace ℝ E]
    (h_le : ∀ᵐ x ∂μ, ‖f x‖ ≤ C) : f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨ ‖⨍ x, f x ∂μ‖ < C 


Original valid proof:
:= by
  rcases le_or_lt C 0 with hC0 | hC0
  · have : f =ᵐ[μ] 0 := h_le.mono fun x hx => norm_le_zero_iff.1 (hx.trans hC0)
    simp only [average_congr this, Pi.zero_apply, average_zero]
    exact Or.inl this
  by_cases hfi : Integrable f μ; swap
  · simp [average_eq, integral_undef hfi, hC0, ENNReal.toReal_pos_iff]
  rcases (le_top : μ univ ≤ ∞).eq_or_lt with hμt | hμt; · simp [average_eq, hμt, hC0]
  haveI : IsFiniteMeasure μ := ⟨hμt⟩
  replace h_le : ∀ᵐ x ∂μ, f x ∈ closedBall (0 : E) C := by simpa only [mem_closedBall_zero_iff]
  simpa only [interior_closedBall _ hC0.ne', mem_ball_zero_iff] using
    (strictConvex_closedBall ℝ (0 : E) C).ae_eq_const_or_average_mem_interior isClosed_ball h_le
      hfi


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
⊓ ‖f x₀‖ := by
  rcases eq_or_ne μ 0 with (rfl | hμ)
  · simp only [ae_zero, eventually_bot, or_true_iff, average_zero, norm_zero, bot_inf_eq]
  by_cases hC : C ≤ 0
  · have : f =ᵐ[μ] 0 := h_le.mono fun x hx ↦ norm_le_zero_iff.1 (hC.trans hx)
    simp only [average_congr this, Pi.zero_apply, average_zero_eq_zero,
      norm_zero, true_or_iff, bot_inf_eq]
  have hC₀ : 0 < C := lt_of_le_of_ne hC (h_le x₀).ne.symm
  have hμ₀ : 0 < μ univ := lt_of_le_of_ne ENNReal.toReal_nonneg hμ.symm
  have h_int : Integrable f μ := integrable_of_norm_bounded _ h_le hC₀.ne'
  have h_int_norm : Integrable (fun x ↦ ‖f x‖) μ := h_int.norm
  have h_int_const : Integrable (fun _ ↦ C) μ := integrable_const C
  have h_int_const_norm : Integrable (fun _ ↦ ‖C‖) μ := h_int_const.norm
  have h_int_norm_le : Integrable (fun x ↦ ‖f x‖ ⊓ ‖C‖) μ :=
    h_int_norm.inf_measure h_int_const_norm
  have h_int_norm_le' : Integrable (fun x ↦ ‖f x‖ ⊓ ‖f x₀‖) μ :=
    h_int_norm.inf_measure (h_int_norm.mono' h_int h_le)
  have h_int_const_norm_le : Integrable (fun _ ↦ ‖C‖ ⊓ ‖f x₀‖) μ :=
    h_int_const_norm.inf_measure (h_int_norm.mono' h_int h_le)
  have h_int_const_norm_le' : Integrable (fun _ ↦ ‖C‖ ⊓ ‖C‖) μ :=
    h_int_const_norm.inf_measure h_int_const_norm
  have h_int_const_norm_le'' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ ‖f x₀‖)) μ :=
    h_int_const_norm_le.inf_measure h_int_const_norm_le'
  have h_int_const_norm_le''' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ ‖f x₀‖))) μ :=
    h_int_const_norm_le.inf_measure h_int_const_norm_le''
  have h_int_const_norm_le'''' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ ‖f x₀‖)))) μ :=
    h_int_const_norm_le.inf_measure h_int_const_norm_le'''
  have h_int_const_norm_le''''' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ ‖f x₀‖)))))) μ :=
    h_int_const_norm_le.inf_measure h_int_const_norm_le''''
  have h_int_const_norm_le'''''' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ ‖f x₀‖))))))) μ :=
    h_int_const_norm_le.inf_measure h_int_const_norm_le'''''
  have h_int_const_norm_le''''''' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ ‖f x₀‖)))))))) μ :=
    h_int_const_norm_le.inf_measure h_int_const_norm_le''''''
  have h_int_const_norm_le'''''''' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ ‖f x₀‖))))))))) μ :=
    h_int_const_norm_le.inf_measure h_int_const_norm_le'''''''
  have h_int_const_norm_le''''''''' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ ‖f x₀‖)))))))))) μ :=
    h_int_const_norm_le.inf_measure h_int_const_norm_le''''''''
  have h_int_const_norm_le'''''''''' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ ‖f x₀‖))))))))))) μ :=
    h_int_const_norm_le.inf_measure h_int_const_norm_le'''''''''
  have h_int_const_norm_le''''''''''' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ ‖f x₀‖)))))))))))) μ :=
    h_int_const_norm_le.inf_measure h_int_const_norm_le''''''''''
  have h_int_const_norm_le'''''''''''' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ ‖f x₀‖))))))))))))) μ :=
    h_int_const_norm_le.inf_measure h_int_const_norm_le'''''''''''
  have h_int_const_norm_le''''''''''''' : Integrable (fun _ ↦ ‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C‖ ⊓ (‖C�

Attempt failure.

Working on Mathlib/Analysis/Convex/Intrinsic.lean - 2024-09-09 00:36:24.865374.
---36/200---
For theorem intrinsicClosure_eq_closure in Mathlib/Analysis/Convex/Intrinsic.lean:
theorem intrinsicClosure_eq_closure : intrinsicClosure 𝕜 s = closure s 


Original valid proof:
:= by
  ext x
  simp only [mem_closure_iff, mem_intrinsicClosure]
  refine ⟨?_, fun h => ⟨⟨x, _⟩, ?_, Subtype.coe_mk _ ?_⟩⟩
  · rintro ⟨x, h, rfl⟩ t ht hx
    obtain ⟨z, hz₁, hz₂⟩ := h _ (continuous_induced_dom.isOpen_preimage t ht) hx
    exact ⟨z, hz₁, hz₂⟩
  · rintro _ ⟨t, ht, rfl⟩ hx
    obtain ⟨y, hyt, hys⟩ := h _ ht hx
    exact ⟨⟨_, subset_affineSpan 𝕜 s hys⟩, hyt, hys⟩
  · by_contra hc
    obtain ⟨z, hz₁, hz₂⟩ := h _ (affineSpan 𝕜 s).closed_of_finiteDimensional.isOpen_compl hc
    exact hz₁ (subset_affineSpan 𝕜 s hz₂)


Verifying proof (Commit ded82be28af61da8cf3266077ac67ad9bf41c841):
∩ vectorSpace 𝕜 E := by
  ext x
  refine' ⟨fun hx => ⟨isClosed_closure.closure_subset hx, _⟩, fun hx => _⟩
  · rcases hx with ⟨y, hy, rfl⟩
    exact mem_vectorSpace 𝕜 E
  · exact ⟨x, hx.2, rfl⟩

@[simp]
theorem intrinsicClosure_coe_preimage (s : Set F) :
    intrinsicClosure 𝕜 ((↑) ⁻¹' s : Set E) = (↑) ⁻¹' intrinsicClosure 𝕜 s := by
  ext x
  simp only [intrinsicClosure, mem_setOf_eq, mem_preimage, mem_iInter, LinearMap.id_coe,
    LinearMap.coe_toAddHom, mem_iInter, mem_closure_iff_clusterPt, inf_principal,
    tendsto_principal, tendsto_iInf, tendsto_induced_iff, Function.comp_apply,
    tendsto_inf, tendsto_add_left_nhds_zero, map_zero]
  refine' ⟨fun h y => _, fun h y => _⟩
  · rintro ⟨u, hu, y, hy, rfl⟩
    exact h y hu hy
  · rintro ⟨u, hu, y, hy, rfl⟩
    exact h y hu hy

@[simp]
theorem intrinsicClosure_preimage_linearMap {f : E →ₗ[𝕜] F} {s : Set F} :
    intrinsicClosure 𝕜 (f ⁻¹' s) = f ⁻¹' intrinsicClosure 𝕜 s := by
  ext x
  simp only [mem_intrinsicClosure, map_sub, LinearMap.coe_toAddHom, map_zero]
  refine' ⟨fun h y => _, fun h y => _⟩
  · rintro ⟨u, hu, y, hy, rfl⟩
    exact h y hu hy
  · rintro ⟨u, hu, y, hy, rfl⟩
    exact h y hu hy

@[simp]
theorem intrinsicClosure_preimage_linearIsometry {f : E →ₗᵢ[𝕜] F} {s : Set F} :
    intrinsicClosure 𝕜 (f ⁻¹' s) = f ⁻¹' intrinsicClosure 𝕜 s := by
  ext x
  simp only [mem_intrinsicClosure, map_sub, LinearIsometry.coe_toLinearMap, map_zero]
  refine' ⟨fun h y => _, fun h y => _⟩
  · rintro ⟨u, hu, y, hy, rfl⟩
    exact h y hu hy
  · rintro ⟨u, hu, y, hy, rfl⟩
    exact h y hu hy

@[simp]
theorem intrinsicClosure_preimage_homeomorph {f : E ≃ₗᵢ[𝕜] F} {s : Set F} :
    intrinsicClosure 𝕜 (f ⁻¹' s) = f ⁻¹' intrinsicClosure 𝕜 s := by
  ext x
  simp only [mem_intrinsicClosure, LinearIsometryEquiv.coe_toLinearIsometry,
    LinearIsometryEquiv.coe_toLinearMap, LinearIsometryEquiv.map_sub,
    LinearIsometryEquiv.map_zero]
  refine' ⟨fun h y => _, fun h y => _⟩
  · rintro ⟨u, hu, y, hy, rfl⟩
    exact h y hu hy
  · rintro ⟨u, hu, y, hy, rfl⟩
    exact h y hu hy

@[simp]
theorem intrinsicClosure_preimage_addEquiv {f : E ≃+ F} {s : Set F} :
    intrinsicClosure 𝕜 (f ⁻¹' s) = f ⁻¹' intrinsicClosure 𝕜 s := by
  ext x
  simp only [mem_intrinsicClosure, AddEquiv.coe_toAddHom, AddEquiv.map_sub,
    AddEquiv.map_zero]
  refine' ⟨fun h y => _, fun h y => _⟩
  · rintro ⟨u, hu, y, hy, rfl⟩
    exact h y hu hy
  · rintro ⟨u, hu, y, hy, rfl⟩
    exact h y hu hy

@[simp]
theorem intrinsicClosure_preimage_addEquiv_of_isComplete {f : E ≃+ F} {s : Set F}
    (hs : IsComplete s) : intrinsicClosure 𝕜 (f ⁻¹' s) = f ⁻¹' s := by
  ext x
  refine' ⟨fun hx => _, fun hx => ⟨x, hx, rfl⟩⟩
  rcases hx with ⟨y, hy, hxy⟩
  suffices h : y = f x by simp [h, hy]
  exact f.injective (hxy.symm.trans (f.apply_symm_apply y))

@[simp]
theorem intrinsicClosure_preimage_addEquiv_of_dense (f : E ≃+ F) {s : Set F}
    (hs : Dense s) : intrinsicClosure 𝕜 (f ⁻¹' s) = ⊤ := by
  refine eq_top_iff.2 fun x _ => ?_
  rcases hs x with ⟨y, hy, hxy⟩
  exact ⟨f.symm y, by simpa using hy, f (f.symm y)⟩

@[simp]
theorem intrinsicClosure_preimage_addEquiv_of_isClosed {f : E ≃+ F} {s : Set F}
    (hs : IsClosed s) : intrinsicClosure 𝕜 (f ⁻¹' s) = f ⁻¹' s := by
  refine le_antisymm ?_ (le_intrinsicClosure _)
  rintro x ⟨y, hy, rfl⟩
  have : f x ∈ closure s := by
    rw [hs.closure_eq]
    exact hy
  rcases mem_closure_iff_nhds.1 this (f ⁻¹' 𝓝 (f x)) (f.continuous.continuousAt (𝓝 x)) with ⟨z, hz, hxz⟩
  have : z = x := f.injective hxz
  rw [← this]
  exact mem_intrinsicClosure.2 ⟨x, Subtype.coe_prop _, rfl⟩

@[simp]
theorem intrinsicClosure_preimage_addEquiv (f : E ≃+ F) {s : Set F} :
    intrinsicClosure 𝕜 (f ⁻¹' s) = f ⁻¹' intrinsicClosure 𝕜 s := by
  rcases isComplete_or_dense_range f.toAddMonoidHom with (hf | hf)
  · rcases isComplete_or_denseRange f.symm.toAddMonoidHom with (hf' | hf')
    · ext x
      refine ⟨fun hx => ?_, fun hx => ⟨x, hx, rfl⟩⟩
      rcases hf' (f x) (mem_range_self _) with ⟨y, hy⟩
      rcases hf y hx with ⟨z, hz, hzy⟩
      exact ⟨z, hz, f.injective (hzy.trans hy.symm)⟩
    · exact intrinsicClosure_preimage_addEquiv_of_dense f hf'
  · exact intrinsicClosure_preimage_addEquiv_of_isClosed f hf

@[simp]
theorem intrinsicClosure_preimage_linearIsometryEquiv (f : E ≃ₗᵢ[𝕜] F) {s : Set F} :
    intrinsicClosure 𝕜 (f ⁻¹' s) = f ⁻¹' intrinsicClosure 𝕜 s :=
  intrinsicClosure_preimage_linearIsometry f

@[simp]
theorem intrinsicClosure_preimage_linearIsometryEquiv (f : E ≃ₗᵢ[𝕜] F) {s : Set F} :
    intrinsicClosure 𝕜 (f ⁻¹' s) = f ⁻¹' intrinsicClosure 𝕜 s :=
  intrinsicClosure_preimage_linearIsometry f


Attempt failure.

Working on Mathlib/Analysis/Convex/Mul.lean - 2024-09-09 00:36:44.422631.
---37/200---
For theorem ConcaveOn.smul' in Mathlib/Analysis/Convex/Mul.lean:
lemma ConcaveOn.smul' (hf : ConcaveOn 𝕜 s f) (hg : ConcaveOn 𝕜 s g) (hf₀ : ∀ ⦃x⦄, x ∈ s → 0 ≤ f x)
    (hg₀ : ∀ ⦃x⦄, x ∈ s → 0 ≤ g x) (hfg : AntivaryOn f g s) : ConcaveOn 𝕜 s (f • g) 


Original valid proof:
:= by
  refine ⟨hf.1, fun x hx y hy a b ha hb hab ↦ ?_⟩
  dsimp
  refine (smul_le_smul (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab)
    (add_nonneg (smul_nonneg ha <| hf₀ hx) <| smul_nonneg hb <| hf₀ hy)
    (hg₀ <| hf.1 hx hy ha hb hab)).trans' ?_
  calc a • f x • g x + b • f y • g y
        = (a * (a + b)) • (f x • g x) + (b * (a + b)) • (f y • g y) := by simp_rw [hab, mul_one]
    _ = (a * a) • (f x • g x) + (b * b) • (f y • g y) + (a * b) • (f x • g x + f y • g y) := by
        simp only [mul_add, add_smul, smul_add, mul_comm _ a]; abel
    _ ≤ (a * a) • (f x • g x) + (b * b) • (f y • g y) + (a * b) • (f x • g y + f y • g x) := by
        gcongr _ + (a * b) • ?_; exact hfg.smul_add_smul_le_smul_add_smul hx hy
    _ = _ := ?_
  simp only [mul_add, add_smul, smul_add]
  rw [← smul_smul_smul_comm a, ← smul_smul_smul_comm b, ← smul_smul_smul_comm a b,
    ← smul_smul_smul_comm b b, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_comm b a,
    add_comm ((a * b) • f x • g y), add_comm ((a * b) • f x • g y), add_add_add_comm]


Verifying proof (Commit 5fb9beab28702fb284701d494bc9b7c5f52fef53):
 := by
  refine' hf.smul' hg hf₀ hg₀ fun x hx y hy a b ha hb hab => _
  rw [Pi.smul_apply', smul_eq_mul, smul_eq_mul, ← smul_eq_mul, smul_smul, ← rpow_two,
    ← le_div_iff (zero_lt_two' 𝕜), ← le_div_iff' hab, div_mul_eq_mul_div, div_mul_eq_mul_div,
    mul_div_assoc, mul_div_assoc, ← mul_div_assoc, ← mul_div_assoc, ← mul_add, ← mul_add,
    ← add_div, ← add_div]
  refine' mul_nonneg (mul_nonneg (hf₀ hx) <| hg₀ hx) (le_trans _ <|
    div_le_one_of_le (sq_nonneg _) two_pos.le)
  rw [add_sq, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,
    add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a,
    add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc,
    add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc, add_comm _ b,
    add_assoc, add_comm _ a, add_assoc, add_comm _ b, add_assoc, add_comm _ a, add_assoc,

Attempt failure.

Working on Mathlib/Analysis/Convex/Segment.lean - 2024-09-09 00:37:02.916155.
---38/200---
For theorem mem_segment_add_sub in Mathlib/Analysis/Convex/Segment.lean:
theorem mem_segment_add_sub [Invertible (2 : 𝕜)] (x y : E) : x ∈ [x + y -[𝕜] x - y] 


Original valid proof:
:= by
  convert @midpoint_mem_segment 𝕜 _ _ _ _ _ (x + y) (x - y)
  rw [midpoint_add_sub]


Verifying proof (Commit 03690a4c3252f422184189d0b6a6dd8d1c55d551):
↔ y ∈ [x + y -[𝕜] x - y] := by
  simp_rw [← segment_eq_uIcc, ← sub_eq_add_neg, ← sub_eq_add_neg, ← sub_eq_add_neg, ← sub_eq_add_neg,
    sub_mem_segment_sub_iff_left, add_comm x y]

theorem mem_segment_sub_add [Invertible (2 : 𝕜)] (x y : E) : x ∈ [x - y -[𝕜] x + y] ↔ y ∈ [x - y -[𝕜] x + y] :=
  mem_segment_add_sub _ _

theorem mem_segment_add_self [Invertible (2 : 𝕜)] (x y : E) : x ∈ [x + y -[𝕜] x - y] ↔ y ∈ [x + y -[𝕜] x - y] :=
  mem_segment_add_sub _ _

theorem mem_segment_sub_self [Invertible (2 : 𝕜)] (x y : E) : x ∈ [x - y -[𝕜] x + y] ↔ y ∈ [x - y -[𝕜] x + y] :=
  mem_segment_sub_add _ _

theorem mem_uIcc_sub_add [Invertible (2 : 𝕜)] (x y : E) : x ∈ [x - y -[𝕜] x + y] ↔ y ∈ [x - y -[𝕜] x + y] :=
  mem_segment_sub_self _ _

theorem mem_uIcc_add_sub [Invertible (2 : 𝕜)] (x y : E) : x ∈ [x + y -[𝕜] x - y] ↔ y ∈ [x + y -[𝕜] x - y] :=
  mem_segment_add_self _ _

theorem mem_uIcc_sub_sub [Invertible (2 : 𝕜)] (x y : E) : x ∈ [x - y -[𝕜] x - y] ↔ y ∈ [x - y -[𝕜] x - y] :=
  mem_segment_sub_sub _ _

theorem mem_uIcc_add_add [Invertible (2 : 𝕜)] (x y : E) : x ∈ [x + y -[𝕜] x + y] ↔ y ∈ [x + y -[𝕜] x + y] :=
  mem_segment_add_add _ _

theorem mem_uIcc_sub_sub_iff_add_le [Invertible (2 : 𝕜)] {x y z : E} :
    x ∈ [y - z -[𝕜] y + z] ↔ y + z ≤ x + x := by
  refine' ⟨fun h => _, fun h => _⟩
  · obtain ⟨a, b, ha, hb, hab, rfl⟩ := mem_segment_sub_add.1 h
    rw [add_add_add_comm] at hab
    exact (add_le_add_iff_left z).1 (hab.symm ▸ add_le_add (add_nonneg ha hb) (add_nonneg ha hb))
  · refine' mem_uIcc_sub_sub.2 ⟨_, _⟩
    · rw [add_comm y, add_add_add_comm, add_le_add_iff_left]
      simpa using h
    · rw [add_comm y, add_add_add_comm, ← two_nsmul]
      exact nsmul_le_nsmul_left h two_pos

theorem mem_uIcc_sub_sub_iff_sub_le [Invertible (2 : 𝕜)] {x y z : E} :
    x ∈ [y - z -[𝕜] y + z] ↔ y - x ≤ x - z := by
  refine' ⟨fun h => _, fun h => _⟩
  · obtain ⟨a, b, ha, hb, hab, rfl⟩ := mem_segment_sub_add.1 h
    rw [add_add_add_comm] at hab
    exact (sub_le_sub_iff_left z).1 (hab.symm ▸ sub_le_sub (sub_nonneg.2 ha) (sub_nonneg.2 hb))
  · refine' mem_uIcc_sub_sub.2 ⟨_, _⟩
    · rw [sub_le_iff_le_add, ← add_sub, sub_add_eq_add_sub, add_comm y, add_le_add_iff_left]
      simpa using h
    · rw [← sub_le_iff_le_add', ← two_nsmul]
      exact nsmul_le_nsmul_left h two_pos

theorem mem_uIcc_add_add_iff_le_sub [Invertible (2 : 𝕜)] {x y z : E} :
    x ∈ [y + z -[𝕜] y + z] ↔ y ≤ x - z := by
  refine' ⟨fun h => _, fun h => _⟩
  · obtain ⟨a, b, ha, hb, hab, rfl⟩ := mem_segment_add_sub.1 h
    rw [add_add_add_comm] at hab
    exact (le_sub_iff_add_le.2 (hab.symm ▸ add_le_add (add_nonneg ha hb) (add_nonneg ha hb)))
  · refine' mem_uIcc_add_add.2 ⟨_, _⟩
    · rw [← le_sub_iff_add_le]
      simpa using h
    · rw [add_le_add_iff_left, ← two_nsmul]
      exact nsmul_le_nsmul_left h two_pos

theorem mem_uIcc_add_add_iff_sub_le [Invertible (2 : 𝕜)] {x y z : E} :
    x ∈ [y + z -[𝕜] y + z] ↔ x - y ≤ z := by
  refine' ⟨fun h => _, fun h => _⟩
  · obtain ⟨a, b, ha, hb, hab, rfl⟩ := mem_segment_add_sub.1 h
    rw [add_add_add_comm] at hab
    exact (sub_le_sub_iff_left y).1 (hab.symm ▸ sub_le_sub (sub_nonneg.2 ha) (sub_nonneg.2 hb))
  · refine' mem_uIcc_add_add.2 ⟨_, _⟩
    · rw [← sub_le_iff_le_add']
      simpa using h
    · rw [add_le_add_iff_left, ← two_nsmul]
      exact nsmul_le_nsmul_left h two_pos

theorem mem_uIcc_sub_sub_iff_le_add [Invertible (2 : 𝕜)] {x y z : E} :
    x ∈ [y - z -[𝕜] y + z] ↔ x ≤ y + z := by
  refine' ⟨fun h => _, fun h => _⟩
  · obtain ⟨a, b, ha, hb, hab, rfl⟩ := mem_segment_sub_add.1 h
    rw [add_add_add_comm] at hab
    exact (le_add_iff_nonneg_right _).1 (hab.symm ▸ add_nonneg (sub_nonneg.2 ha) (sub_nonneg.2 hb))
  · refine' mem_uIcc_sub_sub.2 ⟨_, _⟩
    · rw [le_sub_iff_add_le, ← add_sub, sub_add_eq_add_sub, add_comm y, add_le_add_iff_left]
      simpa using h
    · rw [← le_sub_iff_add_le', ← two_nsmul]
      exact nsmul_le_nsmul_left h two_pos

theorem mem_uIcc_sub_sub_iff_add_le [Invertible (2 : 𝕜)] {x y z : E} :
    x ∈ [y - z -[𝕜] y + z] ↔ y +

Attempt failure.

Working on Mathlib/Analysis/Convolution.lean - 2024-09-09 00:37:22.965624.
---39/200---
For theorem MeasureTheory.continuousOn_convolution_right_with_param in Mathlib/Analysis/Convolution.lean:
theorem continuousOn_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}
    (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)
    (hf : LocallyIntegrable f μ) (hg : ContinuousOn (↿g) (s ×ˢ univ)) :
    ContinuousOn (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (s ×ˢ univ) 


Original valid proof:
:= by
  by_cases H : ∀ p ∈ s, ∀ x, g p x = 0
  · apply (continuousOn_const (c := 0)).congr
    rintro ⟨p, x⟩ ⟨hp, -⟩
    apply integral_eq_zero_of_ae (eventually_of_forall (fun y ↦ ?_))
    simp [H p hp _]
  have : LocallyCompactSpace G := by
    push_neg at H
    rcases H with ⟨p, hp, x, hx⟩
    have A : support (g p) ⊆ k := support_subset_iff'.2 (fun y hy ↦ hgs p y hp hy)
    have B : Continuous (g p) := by
      refine hg.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
      simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp
    rcases eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_addGroup hk A B with H|H
    · simp [H] at hx
    · exact H
  rintro ⟨q₀, x₀⟩ ⟨hq₀, -⟩
  obtain ⟨t, t_comp, ht⟩ : ∃ t, IsCompact t ∧ t ∈ 𝓝 x₀ := exists_compact_mem_nhds x₀
  let k' : Set G := (-k) +ᵥ t
  have k'_comp : IsCompact k' := IsCompact.vadd_set hk.neg t_comp
  let g' : (P × G) → G → E' := fun p x ↦ g p.1 (p.2 - x)
  let s' : Set (P × G) := s ×ˢ t
  have A : ContinuousOn g'.uncurry (s' ×ˢ univ) := by
    have : g'.uncurry = g.uncurry ∘ (fun w ↦ (w.1.1, w.1.2 - w.2)) := by ext y; rfl
    rw [this]
    refine hg.comp (continuous_fst.fst.prod_mk (continuous_fst.snd.sub
      continuous_snd)).continuousOn ?_
    simp (config := {contextual := true}) [s', MapsTo]
  have B : ContinuousOn (fun a ↦ ∫ x, L (f x) (g' a x) ∂μ) s' := by
    apply continuousOn_integral_bilinear_of_locally_integrable_of_compact_support L k'_comp A _
      (hf.integrableOn_isCompact k'_comp)
    rintro ⟨p, x⟩ y ⟨hp, hx⟩ hy
    apply hgs p _ hp
    contrapose! hy
    exact ⟨y - x, by simpa using hy, x, hx, by simp⟩
  apply ContinuousWithinAt.mono_of_mem (B (q₀, x₀) ⟨hq₀, mem_of_mem_nhds ht⟩)
  exact mem_nhdsWithin_prod_iff.2 ⟨s, self_mem_nhdsWithin, t, nhdsWithin_le_nhds ht, Subset.rfl⟩


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
↔
      ContinuousOn (fun p : P => ∫ x, ‖L (f x) (g p x)‖ ∂μ) s := by
  rw [continuousOn_convolution_right_iff_continuous_swap hk hgs hf (hg.comp continuous_swap)]
  refine' ⟨fun h => _, fun h => _⟩
  · refine' (continuous_convolution_integrand L).comp (h.prod_map continuous_id)
  · refine' (continuous_integral.comp (continuous_norm.comp (h.prod_map continuous_id))).congr _
    simp_rw [Function.comp_apply, Prod.snd_swap]

Repaired Proof:
theorem continuousOn_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}
    (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)
    (hf : LocallyIntegrable f μ) (hg : ContinuousOn (↿g) (s ×ˢ univ)) :
    ContinuousOn (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (s ×ˢ univ) ↔
      ContinuousOn (fun p : P => ∫ x, ‖L (f x) (g p x)‖ ∂μ) s := by
  rw [continuousOn_convolution_right_iff_continuous_swap hk hgs hf (hg.comp continuous_swap)]
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine (continuous_convolution_integrand L).comp (h.prod_map continuous_id)
  · refine (continuous_integral.comp (continuous_norm.comp (h.prod_map continuous_id))).congr ?_
    simp_rw [Function.comp_apply, Prod.snd_swap]

Repaired Proof:
theorem continuousOn_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}
    (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)
    (hf : LocallyIntegrable f μ) (hg : ContinuousOn (↿g) (s ×ˢ univ)) :
    ContinuousOn (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (s ×ˢ univ) ↔
      ContinuousOn (fun p : P => ∫ x, ‖L (f x) (g p x)‖ ∂μ) s := by
  rw [continuousOn_convolution_right_iff_continuous_swap hk hgs hf (hg.comp continuous_swap)]
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine (continuous_convolution_integrand L).comp (h.prod_map continuous_id)
  · refine (continuous_integral.comp (continuous_norm.comp (h.prod_map continuous_id))).congr ?_
    simp_rw [Function.comp_apply, Prod.snd_swap]

Repaired Proof:
theorem continuousOn_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}
    (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)
    (hf : LocallyIntegrable f μ) (hg : ContinuousOn (↿g) (s ×ˢ univ)) :
    ContinuousOn (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (s ×ˢ univ) ↔
      ContinuousOn (fun p : P => ∫ x, ‖L (f x) (g p x)‖ ∂μ) s := by
  rw [continuousOn_convolution_right_iff_continuous_swap hk hgs hf (hg.comp continuous_swap)]
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine (continuous_convolution_integrand L).comp (h.prod_map continuous_id)
  · refine (continuous_integral.comp (continuous_norm.comp (h.prod_map continuous_id))).congr ?_
    simp_rw [Function.comp_apply, Prod.snd_swap]

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Basic.lean - 2024-09-09 00:38:33.092513.
---40/200---
For theorem OrthogonalFamily.summable_iff_norm_sq_summable in Mathlib/Analysis/InnerProductSpace/Basic.lean:
theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : ∀ i, G i) :
    (Summable fun i => V i (f i)) ↔ Summable fun i => ‖f i‖ ^ 2 


Original valid proof:
:= by
  classical
    simp only [summable_iff_cauchySeq_finset, NormedAddCommGroup.cauchySeq_iff, Real.norm_eq_abs]
    constructor
    · intro hf ε hε
      obtain ⟨a, H⟩ := hf _ (sqrt_pos.mpr hε)
      use a
      intro s₁ hs₁ s₂ hs₂
      rw [← Finset.sum_sdiff_sub_sum_sdiff]
      refine (abs_sub _ _).trans_lt ?_
      have : ∀ i, 0 ≤ ‖f i‖ ^ 2 := fun i : ι => sq_nonneg _
      simp only [Finset.abs_sum_of_nonneg' this]
      have : ((∑ i ∈ s₁ \ s₂, ‖f i‖ ^ 2) + ∑ i ∈ s₂ \ s₁, ‖f i‖ ^ 2) < √ε ^ 2 := by
        rw [← hV.norm_sq_diff_sum, sq_lt_sq, abs_of_nonneg (sqrt_nonneg _),
          abs_of_nonneg (norm_nonneg _)]
        exact H s₁ hs₁ s₂ hs₂
      have hη := sq_sqrt (le_of_lt hε)
      linarith
    · intro hf ε hε
      have hε' : 0 < ε ^ 2 / 2 := half_pos (sq_pos_of_pos hε)
      obtain ⟨a, H⟩ := hf _ hε'
      use a
      intro s₁ hs₁ s₂ hs₂
      refine (abs_lt_of_sq_lt_sq' ?_ (le_of_lt hε)).2
      have has : a ≤ s₁ ⊓ s₂ := le_inf hs₁ hs₂
      rw [hV.norm_sq_diff_sum]
      have Hs₁ : ∑ x ∈ s₁ \ s₂, ‖f x‖ ^ 2 < ε ^ 2 / 2 := by
        convert H _ hs₁ _ has
        have : s₁ ⊓ s₂ ⊆ s₁ := Finset.inter_subset_left
        rw [← Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        · simp
        · exact fun i => sq_nonneg _
      have Hs₂ : ∑ x ∈ s₂ \ s₁, ‖f x‖ ^ 2 < ε ^ 2 / 2 := by
        convert H _ hs₂ _ has
        have : s₁ ⊓ s₂ ⊆ s₂ := Finset.inter_subset_right
        rw [← Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        · simp
        · exact fun i => sq_nonneg _
      linarith


Verifying proof (Commit 1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493):
∧ ∀ i, ∀ t : Finset ι, ∑ j ∈ t, ⟪f i, f j⟫ = 0 := by
  classical
    have hf : ∀ i, ∀ t : Finset ι, ∑ j ∈ t, ⟪f i, f j⟫ = ⟪f i, ∑ j ∈ t, f j⟫ := by
      intro i t
      simp only [inner_sum, ← Finset.sum_apply]
      rfl
    constructor
    · intro h
      refine' ⟨h.norm_sq_tsum_orthogonal, fun i t => _⟩
      rw [← hf i t, h.hasSum.tsum_eq]
      simp only [inner_orthogonalFamily_sum hG f i t]
    · rintro ⟨h, h'⟩
      choose s hs using h'
      have h' : ∀ i, Summable fun j => ⟪f i, f j⟫ := by
        intro i
        rw [← hf i]
        exact h i
      refine' ⟨h.of_normSq _, fun i => _⟩
      · simp only [norm_sq_eq_inner, inner_self_eq_norm_sq]
      · rw [← hf i]
        exact h' i

Repaired Proof:
theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : ∀ i, G i) :
    (Summable fun i => V i (f i)) ↔ Summable fun i => ‖f i‖ ^ 2 ∧ ∀ i, ∀ t : Finset ι, ∑ j ∈ t, ⟪f i, f j⟫ = 0 := by
  classical
    have hf : ∀ i, ∀ t : Finset ι, ∑ j ∈ t, ⟪f i, f j⟫ = ⟪f i, ∑ j ∈ t, f j⟫ := by
      intro i t
      simp only [inner_sum, ← Finset.sum_apply]
      rfl
    constructor
    · intro h
      refine ⟨h.norm_sq_tsum_orthogonal, fun i t => ?_⟩
      rw [← hf i t, h.hasSum.tsum_eq]
      simp only [inner_orthogonalFamily_sum hG f i t]
    · rintro ⟨h, h'⟩
      choose s hs using h'
      have h' : ∀ i, Summable fun j => ⟪f i, f j⟫ := by
        intro i
        rw [← hf i]
        exact h i
      refine ⟨h.of_normSq _, fun i => ?_⟩
      · simp only [norm_sq_eq_inner, inner_self_eq_norm_sq]
      · rw [← hf i]
        exact h' i

Repaired Proof:
theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : ∀ i, G i) :
    (Summable fun i => V i (f i)) ↔ Summable fun i => ‖f i‖ ^ 2 ∧ ∀ i, ∀ t : Finset ι, ∑ j ∈ t, ⟪f i, f j⟫ = 0 := by
  classical
    have hf : ∀ i, ∀ t : Finset ι, ∑ j ∈ t, ⟪f i, f j⟫ = ⟪f i, ∑ j ∈ t, f j⟫ := by
      intro i t
      simp only [inner_sum, ← Finset.sum_apply]
      rfl
    constructor
    · intro h
      refine ⟨h.norm_sq_tsum_orthogonal, fun i t => ?_⟩
      rw [← hf i t, h.hasSum.tsum_eq]
      simp only [inner_orthogonalFamily_sum hG f i t]
    · rintro ⟨h, h'⟩
      choose s hs using h'
      have h' : ∀ i, Summable fun j => ⟪f i, f j⟫ := by
        intro i
        rw [← hf i]
        exact h i
      refine ⟨h.of_normSq _, fun i => ?_⟩
      · simp only [norm_sq_eq_inner, inner_self_eq_norm_sq]
      · rw [← hf i]
        exact h' i

Repaired Proof:
theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : ∀ i, G i) :
    (Summable fun i => V i (f i)) ↔ Summable fun i => ‖f i‖ ^ 2 ∧ ∀ i, ∀ t : Finset ι, ∑ j ∈ t, ⟪f i, f j⟫ = 0 := by
  classical
    have hf : ∀ i, ∀ t : Finset ι, ∑ j ∈ t, ⟪f i, f j⟫ = ⟪f i, ∑ j ∈ t, f j⟫ := by
      intro i t
      simp only [inner_sum, ← Finset.sum_apply]
      rfl
    constructor
    · intro h
      refine ⟨h.norm_sq_tsum_orthogonal, fun i t => ?_⟩
      rw [← hf i t, h.hasSum.tsum_eq]
      simp only [inner_orthogonalFamily_sum hG f i t]
    · rintro ⟨h, h'⟩
      choose s hs using h'
      have h' : ∀ i, Summable fun j => ⟪f i, f j⟫ := by
        intro i
        rw [← hf i]
        exact h i
      refine ⟨h.of_normSq _, fun i => ?_⟩
      · simp only [norm_sq_eq_inner, inner_self_eq_norm_sq]
      · rw [← hf i]
        exact h' i

Repaired Proof:
theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : ∀ i, G i) :
    (Summable fun i => V i (f i)) ↔ Summable fun i => ‖f i‖ ^ 2 ∧ ∀ i, ∀ t : Finset ι, ∑ j ∈ t, ⟪f i, f j⟫ = 0 := by
  classical
    have hf : ∀ i, ∀ t : Finset ι, ∑ j ∈ t, ⟪f i, f j⟫ = ⟪f i, ∑ j ∈ t, f j⟫ := by
      intro i t
      simp only [inner_sum, ← Finset.sum_apply]
      rfl
    constructor
    · intro h
      refine ⟨h.norm_sq_tsum_orthogonal, fun i t => ?_⟩
      rw [← hf i t, h.hasSum.tsum_eq]
      simp only [inner_orthogonalFamily_sum hG f i t]
    · rintro ⟨h, h'⟩
      choose s hs using h'
      have h' : ∀ i, Summable fun j => ⟪f i, f j⟫ := by
        intro i
        rw [← hf i]
        exact h i
      refine ⟨h.of_normSq _, fun i => ?_⟩
      · simp only [norm_sq_eq_inner, inner_self_eq_norm_sq]
      · rw [← hf i]
        exact h' i

Repaired Proof:
theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : ∀ i, G i) :
    (Summable fun i => V i (f i)) ↔ Summable fun i => ‖f i‖ ^ 2 ∧ ∀ i, ∀ t : Finset ι, ∑ j ∈ t, ⟪f i, f j⟫ = 0 := by
  classical
    have hf : ∀ i, ∀ t : Finset ι,

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Positive.lean - 2024-09-09 00:39:24.223149.
---41/200---
For theorem ContinuousLinearMap.isPositive_one in Mathlib/Analysis/InnerProductSpace/Positive.lean:
theorem isPositive_one : IsPositive (1 : E →L[𝕜] E) 


Original valid proof:
:=
  ⟨isSelfAdjoint_one _, fun _ => inner_self_nonneg⟩


Verifying proof (Commit 1c643aca968064296312bf5328c84d0c50cfe5ae):
𝕜 :=
    (isPositive_id 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_zero : IsPositive (0 : E →L[𝕜] E) 𝕜 :=
    (isPositive_zero 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_neg {T : E →L[𝕜] E} (hT : IsPositive T 𝕜) : IsPositive (-T) 𝕜 := by
    simp only [IsPositive, Pi.neg_apply, toDual_neg, hT.eq_coe, neg_zero, and_self]
  theorem isPositive_sub {T S : E →L[𝕜] E} (hT : IsPositive T 𝕜) (hS : IsPositive S 𝕜) :
    IsPositive (T - S) 𝕜 := by
    simp only [IsPositive, Pi.sub_apply, toDual_sub, hT.eq_coe, hS.eq_coe, sub_zero, and_self]

Repaired Proof:
theorem isPositive_one : IsPositive (1 : E →L[𝕜] E) 𝕜 :=
    (isPositive_id 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_zero : IsPositive (0 : E →L[𝕜] E) 𝕜 :=
    (isPositive_zero 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_neg {T : E →L[𝕜] E} (hT : IsPositive T 𝕜) : IsPositive (-T) 𝕜 := by
    simp only [IsPositive, Pi.neg_apply, toDual_neg, hT.eq_coe, neg_zero, and_self]
  theorem isPositive_sub {T S : E →L[𝕜] E} (hT : IsPositive T 𝕜) (hS : IsPositive S 𝕜) :
    IsPositive (T - S) 𝕜 := by
    simp only [IsPositive, Pi.sub_apply, toDual_sub, hT.eq_coe, hS.eq_coe, sub_zero, and_self]

Repaired Proof:
theorem isPositive_one : IsPositive (1 : E →L[𝕜] E) 𝕜 :=
    (isPositive_id 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_zero : IsPositive (0 : E →L[𝕜] E) 𝕜 :=
    (isPositive_zero 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_neg {T : E →L[𝕜] E} (hT : IsPositive T 𝕜) : IsPositive (-T) 𝕜 := by
    simp only [IsPositive, Pi.neg_apply, toDual_neg, hT.eq_coe, neg_zero, and_self]
  theorem isPositive_sub {T S : E →L[𝕜] E} (hT : IsPositive T 𝕜) (hS : IsPositive S 𝕜) :
    IsPositive (T - S) 𝕜 := by
    simp only [IsPositive, Pi.sub_apply, toDual_sub, hT.eq_coe, hS.eq_coe, sub_zero, and_self]

Repaired Proof:
theorem isPositive_one : IsPositive (1 : E →L[𝕜] E) 𝕜 :=
    (isPositive_id 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_zero : IsPositive (0 : E →L[𝕜] E) 𝕜 :=
    (isPositive_zero 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_neg {T : E →L[𝕜] E} (hT : IsPositive T 𝕜) : IsPositive (-T) 𝕜 := by
    simp only [IsPositive, Pi.neg_apply, toDual_neg, hT.eq_coe, neg_zero, and_self]
  theorem isPositive_sub {T S : E →L[𝕜] E} (hT : IsPositive T 𝕜) (hS : IsPositive S 𝕜) :
    IsPositive (T - S) 𝕜 := by
    simp only [IsPositive, Pi.sub_apply, toDual_sub, hT.eq_coe, hS.eq_coe, sub_zero, and_self]

Repaired Proof:
theorem isPositive_one : IsPositive (1 : E →L[𝕜] E) 𝕜 :=
    (isPositive_id 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_zero : IsPositive (0 : E →L[𝕜] E) 𝕜 :=
    (isPositive_zero 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_neg {T : E →L[𝕜] E} (hT : IsPositive T 𝕜) : IsPositive (-T) 𝕜 := by
    simp only [IsPositive, Pi.neg_apply, toDual_neg, hT.eq_coe, neg_zero, and_self]
  theorem isPositive_sub {T S : E →L[𝕜] E} (hT : IsPositive T 𝕜) (hS : IsPositive S 𝕜) :
    IsPositive (T - S) 𝕜 := by
    simp only [IsPositive, Pi.sub_apply, toDual_sub, hT.eq_coe, hS.eq_coe, sub_zero, and_self]

Repaired Proof:
theorem isPositive_one : IsPositive (1 : E →L[𝕜] E) 𝕜 :=
    (isPositive_id 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_zero : IsPositive (0 : E →L[𝕜] E) 𝕜 :=
    (isPositive_zero 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_neg {T : E →L[𝕜] E} (hT : IsPositive T 𝕜) : IsPositive (-T) 𝕜 := by
    simp only [IsPositive, Pi.neg_apply, toDual_neg, hT.eq_coe, neg_zero, and_self]
  theorem isPositive_sub {T S : E →L[𝕜] E} (hT : IsPositive T 𝕜) (hS : IsPositive S 𝕜) :
    IsPositive (T - S) 𝕜 := by
    simp only [IsPositive, Pi.sub_apply, toDual_sub, hT.eq_coe, hS.eq_coe, sub_zero, and_self]

Repaired Proof:
theorem isPositive_one : IsPositive (1 : E →L[𝕜] E) 𝕜 :=
    (isPositive_id 𝕜).comp (continuousLinearMapOfIsometry (LinearIsometryEquiv.refl 𝕜 E)
      (LinearIsometryEquiv.refl_apply _))
  theorem isPositive_zero : IsPositive (0 : E →L[𝕜] E) 𝕜 :=
    (isPositive_zero

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Projection.lean - 2024-09-09 00:39:40.157660.
---42/200---
For theorem OrthogonalFamily.projection_directSum_coeAddHom in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq ι] {V : ι → Submodule 𝕜 E}
    (hV : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) (x : ⨁ i, V i) (i : ι)
    [CompleteSpace (V i)] :
    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i 


Original valid proof:
:= by
  induction' x using DirectSum.induction_on with j x x y hx hy
  · simp
  · simp_rw [DirectSum.coeAddMonoidHom_of, DirectSum.of]
    erw [DFinsupp.singleAddHom_apply]
    obtain rfl | hij := Decidable.eq_or_ne i j
    · rw [orthogonalProjection_mem_subspace_eq_self, DFinsupp.single_eq_same]
    · rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero,
        DFinsupp.single_eq_of_ne hij.symm]
      exact hV.isOrtho hij.symm x.prop
  · simp_rw [map_add]
    exact congr_arg₂ (· + ·) hx hy


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
• (V i).subtype := by
  classical
  induction' x with _ x hx
  rw [DFinsupp.sumAddHom_apply, DFinsupp.lsum_apply_of_ne_zero _ hx,
    DirectSum.coeAddMonoidHom_of, DFinsupp.mapRange_apply, DFinsupp.mapRange_apply]
  simp_rw [DFinsupp.sum, Finset.sum_ite_eq', Finset.mem_univ, ite_true]
  rw [← Submodule.coe_smul_of_tower, ← Submodule.coe_subtype, ← LinearMap.map_smul,
    orthogonalProjection_mem_subspace_eq_self]
  exact hx i

Repaired Proof:
theorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq ι] {V : ι → Submodule 𝕜 E}
    (hV : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) (x : ⨁ i, V i) (i : ι)
    [CompleteSpace (V i)] :
    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i • (V i).subtype := by
  classical
  induction x using DirectSum.induction_on with
  | h_zero => simp
  | h_add x y hx hy =>
    simp only [map_add, AddSubmonoid.coe_add, DFinsupp.coe_add]
    ext
    simp only [AddSubgroup.coe_add, AddMonoidHom.map_add, LinearMap.map_add_apply,
      coe_directSum_coeAddMonoidHom]
    rw [orthogonalProjection_add_of_mem_left hx, orthogonalProjection_add_of_mem_left hy, hx, hy,
      zero_add, zero_add, smul_add]
  | h_single i b =>
    ext
    simp only [DFinsupp.coe_single, AddSubgroup.coe_mk, AddSubmonoid.coe_mk,
      coe_directSum_coeAddMonoidHom, LinearMap.coe_toAddHom, AddHom.toFun_eq_coe,
      AddMonoidHom.coe_coe, DirectSum.coeAddMonoidHom_of, DFinsupp.mapRange_single,
      LinearMap.map_smul_of_tower, Submodule.coe_subtype, Submodule.coe_smul_of_tower]
    rw [orthogonalProjection_mem_subspace_eq_self]
    exact b.prop

Repaired Proof:
theorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq ι] {V : ι → Submodule 𝕜 E}
    (hV : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) (x : ⨁ i, V i) (i : ι)
    [CompleteSpace (V i)] :
    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i • (V i).subtype := by
  classical
  induction x using DirectSum.induction_on with
  | h_zero => simp
  | h_add x y hx hy =>
    simp only [map_add, AddSubmonoid.coe_add, DFinsupp.coe_add]
    ext
    simp only [AddSubgroup.coe_add, AddMonoidHom.map_add, LinearMap.map_add_apply,
      coe_directSum_coeAddMonoidHom]
    rw [orthogonalProjection_add_of_mem_left hx, orthogonalProjection_add_of_mem_left hy, hx, hy,
      zero_add, zero_add, smul_add]
  | h_single i b =>
    ext
    simp only [DFinsupp.coe_single, AddSubgroup.coe_mk, AddSubmonoid.coe_mk,
      coe_directSum_coeAddMonoidHom, LinearMap.coe_toAddHom, AddHom.toFun_eq_coe,
      AddMonoidHom.coe_coe, DirectSum.coeAddMonoidHom_of, DFinsupp.mapRange_single,
      LinearMap.map_smul_of_tower, Submodule.coe_subtype, Submodule.coe_smul_of_tower]
    rw [orthogonalProjection_mem_subspace_eq_self]
    exact b.prop

Repaired Proof:
theorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq ι] {V : ι → Submodule 𝕜 E}
    (hV : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) (x : ⨁ i, V i) (i : ι)
    [CompleteSpace (V i)] :
    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i • (V i).subtype := by
  classical
  induction x using DirectSum.induction_on with
  | h_zero => simp
  | h_add x y hx hy =>
    simp only [map_add, AddSubmonoid.coe_add, DFinsupp.coe_add]
    ext
    simp only [AddSubgroup.coe_add, AddMonoidHom.map_add, LinearMap.map_add_apply,
      coe_directSum_coeAddMonoidHom]
    rw [orthogonalProjection_add_of_mem_left hx, orthogonalProjection_add_of_mem_left hy, hx, hy,
      zero_add, zero_add, smul_add]
  | h_single i b =>
    ext
    simp only [DFinsupp.coe_single, AddSubgroup.coe_mk, AddSubmonoid.coe_mk,
      coe_directSum_coeAddMonoidHom, LinearMap.coe_toAddHom, AddHom.toFun_eq_coe,
      AddMonoidHom.coe_coe, DirectSum.coeAddMonoidHom_of, DFinsupp.mapRange_single,
      LinearMap.map_smul_of_tower, Submodule.coe_subtype, Submodule.coe_smul_of_tower]
    rw [orthogonalProjection_mem_subspace_eq_self]
    exact b.prop

Repaired Proof:
theorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq ι] {V : ι → Submodule 𝕜 E}
    (hV : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) (x : ⨁ i, V i) (i : ι)
    [CompleteSpace (V i)] :
    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i • (V i).subtype := by
  classical
  induction x using DirectSum.induction_on with
  | h_zero => simp
  | h_add x y hx hy =>
    simp only [map_add, AddSubmonoid.coe_add, DFinsupp.coe_add]
    ext
    simp only [AddSubgroup.coe_add, AddMonoidHom.map_add, LinearMap.map_add_apply,
      coe_directSum_coeAddMonoidHom]
    rw [orthogonalProjection_add_of_mem_left hx, orthogonalProjection_add_of_mem_left hy, hx, hy,
      zero_add, zero_add, smul_add]
  | h_single i b =>
    ext
    simp only [DFinsupp.coe_single, AddSubgroup.coe_mk, AddSubmonoid.coe_mk,
      coe_directSum_coeAddMonoidHom, LinearMap.coe_toAddHom, AddHom.toFun_eq_coe,
      AddMonoidHom.coe_coe, DirectSum.coeAddMonoidHom_of, DFinsupp.mapRange_single,
      LinearMap.map_smul_of_tower, Submodule.coe_subtype, Submodule.coe_smul_of_tower]
    rw [orthogonalProjection_mem_subspace_eq_self]
    exact b.prop

Repaired Proof:
theorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq ι] {V : ι → Submodule 𝕜 E}
    (hV : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) (x : ⨁ i, V i) (i : ι)
    [CompleteSpace (V i)] :
    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i • (V i).subtype := by
  classical
 

Attempt failure.

---43/200---
For theorem LinearIsometryEquiv.reflections_generate_dim_aux in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod 


Original valid proof:
:= by
  induction' n with n IH generalizing φ
  · 
    refine ⟨[], rfl.le, show φ = 1 from ?_⟩
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  · 
    let W := ker (ContinuousLinearMap.id ℝ F - φ)
    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ℝ Wᗮ ≤ n
    · obtain ⟨V, hV₁, hV₂⟩ := IH φ hn'
      exact ⟨V, hV₁.trans n.le_succ, hV₂⟩
    haveI : Nontrivial Wᗮ := nontrivial_of_finrank_pos (by omega : 0 < finrank ℝ Wᗮ)
    obtain ⟨v, hv⟩ := exists_ne (0 : Wᗮ)
    have hφv : φ v ∈ Wᗮ := by
      intro w hw
      rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ∉ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - φ v
    let ρ := reflection (ℝ ∙ x)ᗮ
    let V := ker (ContinuousLinearMap.id ℝ F - φ.trans ρ)
    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by
      intro w hw
      change w - ρ (φ w) = 0
      rw [sub_eq_zero, hw]
    have H₂V : W ≤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hw
    have H₁V : (v : F) ∈ V := by
      apply hV
      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
      rw [← this]
      exact reflection_reflection _ _
    have : finrank ℝ Vᗮ ≤ n := by
      change finrank ℝ Wᗮ ≤ n + 1 at hn
      have : finrank ℝ W + 1 ≤ finrank ℝ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)
      have : finrank ℝ V + finrank ℝ Vᗮ = finrank ℝ F := V.finrank_add_finrank_orthogonal
      have : finrank ℝ W + finrank ℝ Wᗮ = finrank ℝ F := W.finrank_add_finrank_orthogonal
      omega
    obtain ⟨l, hl, hφl⟩ := IH (ρ * φ) this
    refine ⟨x::l, Nat.succ_le_succ hl, ?_⟩
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (ρ * ·) hφl
    dsimp only at this
    rwa [← mul_assoc, reflection_mul_reflection, one_mul] at this


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∧
      (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod = φ := by
  induction' n with n IH generalizing φ
  · 
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      have : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ = 0 := by simpa using hn
      have : (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ = ⊥ := Submodule.eq_bot_of_finrank_zero this
      simpa [ker_eq_top, this]
    refine' ⟨[], rfl, φ.ext fun x => Subtype.ext _, rfl⟩
    simp [this]
  · 
    set W := ker (ContinuousLinearMap.id ℝ F - φ) with hW
    haveI : FiniteDimensional ℝ W := finiteDimensional_of_le W.le
    have hφ : φ (W.subtype (R := ℝ) x) = x := φ.subtype_apply_of_mem W x x.2
    have hφ' : ∀ x : W, (φ - W.subtype (R := ℝ)) x = 0 := fun x => sub_eq_zero.2 hφ
    have : W = ker (ContinuousLinearMap.id ℝ W - W.subtypeL ∘L φ) := by
      ext x
      simp [hφ']
    obtain ⟨ψ, hψ⟩ : ∃ (ψ : W ≃ₗᵢ[ℝ] W), W.subtypeL ∘L ψ ∘L W.subtypeL.dual =
        W.subtypeL.dual ∘L (ContinuousLinearMap.id ℝ W - W.subtypeL ∘L φ) :=
      exists_isometry_of_inner ℝ W fun x y => inner_sub_left.symm
    have hψ' : W.subtypeL ∘L ψ = W.subtypeL ∘L φ := by
      ext x
      simpa [ContinuousLinearMap.dual_def] using congr_arg W.subtype x (hψ x)
    have : finrank ℝ (ker (ContinuousLinearMap.id ℝ W - ψ))ᗮ ≤ n := by
      rw [← hW]
      refine' (Submodule.finrank_lt_finrank_of_lt _).le
      refine' (Submodule.orthogonal_strict_mono W.le).2 _
      refine' (Submodule.orthogonal_orthogonal W).symm.trans_lt ?_
      refine' Submodule.lt_top_of_ne_top _ fun h => ?_
      have : W = ⊥ := by rwa [← Submodule.eq_bot_iff, h]
      simp only [this, LinearIsometryEquiv.reflections_generate_dim_aux_aux] at hψ'
      have : W.subtypeL = 0 := by ext; simp [this]
      simp [this] at hψ'
    obtain ⟨l, hl, hl'⟩ := IH ψ this
    refine' ⟨W.subtype x :: l, Nat.succ_le_succ hl, _, _⟩
    · simp only [List.map, List.prod_cons]
      rw [← hl', ← hψ']
      ext
      rfl
    · simp only [List.map, List.prod_cons]
      rw [← hl', ← hψ']
      rfl

Repaired Proof:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod ∧
      (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod = φ := by
  induction' n with n IH generalizing φ
  · 
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      have : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ = 0 := by simpa using hn
      have : (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ = ⊥ := Submodule.eq_bot_of_finrank_zero this
      simpa [ker_eq_top, this]
    refine ⟨[], rfl, φ.ext fun x => Subtype.ext ?_, rfl⟩
    simp [this]
  · 
    set W := ker (ContinuousLinearMap.id ℝ F - φ) with hW
    haveI : FiniteDimensional ℝ W := finiteDimensional_of_le W.le
    have hφ : φ (W.subtype (R := ℝ) x) = x := φ.subtype_apply_of_mem W x x.2
    have hφ' : ∀ x : W, (φ - W.subtype (R := ℝ)) x = 0 := fun x => sub_eq_zero.2 hφ
    have : W = ker (ContinuousLinearMap.id ℝ W - W.subtypeL ∘L φ) := by
      ext x
      simp [hφ']
    obtain ⟨ψ, hψ⟩ : ∃ (ψ : W ≃ₗᵢ[ℝ] W), W.subtypeL ∘L ψ ∘L W.subtypeL.dual =
        W.subtypeL.dual ∘L (ContinuousLinearMap.id ℝ W - W.subtypeL ∘L φ) :=
      exists_isometry_of_inner ℝ W fun x y => inner_sub_left.symm
    have hψ' : W.subtypeL ∘L ψ = W.subtypeL ∘L φ := by
      ext x
      simpa [ContinuousLinearMap.dual_def] using congr_arg W.subtype x (hψ x)
    have : finrank ℝ (ker (ContinuousLinearMap.id ℝ W - ψ))ᗮ ≤ n := by
      rw [← hW]
      refine (Submodule.finrank_lt_finrank_of_lt ?_).le
      refine (Submodule.orthogonal_strict_mono W.le).2 ?_
      refine (Submodule.orthogonal_orthogonal W).symm.trans_lt ?_
      refine Submodule.lt_top_of_ne_top ?_ fun h => ?_
      have : W = ⊥ := by rwa [← Submodule.eq_bot_iff, h]
      simp only [this, LinearIsometryEquiv.reflections_generate_dim_aux_aux] at hψ'
      have : W.subtypeL = 0 := by ext; simp [this]
      simp [this] at hψ'
    obtain ⟨l, hl, hl'⟩ := IH ψ this
    refine ⟨W.subtype x :: l, Nat.succ_le_succ hl, ?_, ?_⟩
    · simp only [List.map, List.prod_cons]
      rw [← hl', ← hψ']
      ext
      rfl
    · simp only [List.map, List.prod_cons]
      rw [← hl', ← hψ']
      rfl

Repaired Proof:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod ∧
      (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod = φ := by
  induction' n with n IH generalizing φ
  · 
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      have : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ = 0 := by sim

Attempt failure.

Working on Mathlib/Analysis/MeanInequalities.lean - 2024-09-09 00:41:14.444666.
---44/200---
For theorem Real.Lp_add_le_hasSum_of_nonneg in Mathlib/Analysis/MeanInequalities.lean:
theorem Lp_add_le_hasSum_of_nonneg (hp : 1 ≤ p) (hf : ∀ i, 0 ≤ f i) (hg : ∀ i, 0 ≤ g i) {A B : ℝ}
    (hA : 0 ≤ A) (hB : 0 ≤ B) (hfA : HasSum (fun i => f i ^ p) (A ^ p))
    (hgB : HasSum (fun i => g i ^ p) (B ^ p)) :
    ∃ C, 0 ≤ C ∧ C ≤ A + B ∧ HasSum (fun i => (f i + g i) ^ p) (C ^ p) 


Original valid proof:
:= by
  lift f to ι → ℝ≥0 using hf
  lift g to ι → ℝ≥0 using hg
  lift A to ℝ≥0 using hA
  lift B to ℝ≥0 using hB
  beta_reduce at hfA hgB
  norm_cast at hfA hgB
  obtain ⟨C, hC₁, hC₂⟩ := NNReal.Lp_add_le_hasSum hp hfA hgB
  use C
  beta_reduce
  norm_cast
  exact ⟨zero_le _, hC₁, hC₂⟩


Verifying proof (Commit aaa40f08731a6680bdee636aa290c8d59c9968c4):
∧
      (∀ s, ∑ i ∈ s, (f i + g i) ^ p ≤ C ^ p) := by
  have hp' : 1 / p ∈ Set.Icc (0 : ℝ) 1 := by
    rw [← mem_Icc_iff_rat_mem]
    exact ⟨le_trans (inv_nonneg.2 hp) (by norm_num), inv_le_one hp⟩
  have hpq : p ≠ 0 := (lt_of_lt_of_le zero_lt_one hp).ne'
  have hpq' : p ≠ 0 := hpq
  have hpp' : p ≠ 0 := hpq
  have hpp : p ≠ 0 := hpq'
  have hpp'' : p ≠ 0 := hpq''
  have hpp''' : p ≠ 0 := hpq'''
  have hpp'''' : p ≠ 0 := hpq''''
  have hpp''''' : p ≠ 0 := hpq'''''
  have hpp'''''' : p ≠ 0 := hpq''''''
  have hpp''''''' : p ≠ 0 := hpq'''''''
  have hpp'''''''' : p ≠ 0 := hpq''''''''
  have hpp''''''''' : p ≠ 0 := hpq'''''''''
  have hpp'''''''''' : p ≠ 0 := hpq''''''''''
  have hpp''''''''''' : p ≠ 0 := hpq'''''''''''
  have hpp'''''''''''' : p ≠ 0 := hpq''''''''''''
  have hpp''''''''''''' : p ≠ 0 := hpq'''''''''''''
  have hpp'''''''''''''' : p ≠ 0 := hpq''''''''''''''
  have hpp''''''''''''''' : p ≠ 0 := hpq'''''''''''''''
  have hpp'''''''''''''''' : p ≠ 0 := hpq''''''''''''''''
  have hpp''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''
  have hpp'''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''
  have hpp''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''
  have hpp'''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''
  have hpp''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''
  have hpp'''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''
  have hpp''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''
  have hpp'''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  have hpp''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' : p ≠ 0 := hpq''''''''''''''''''''''''''''''''''''''''''''

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/AddTorsorBases.lean - 2024-09-09 00:41:34.440965.
---45/200---
For theorem IsOpen.exists_between_affineIndependent_span_eq_top in Mathlib/Analysis/NormedSpace/AddTorsorBases.lean:
theorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)
    (hsu : s ⊆ u) (hne : s.Nonempty) (h : AffineIndependent ℝ ((↑) : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ t ⊆ u ∧ AffineIndependent ℝ ((↑) : t → P) ∧ affineSpan ℝ t = ⊤ 


Original valid proof:
:= by
  obtain ⟨q, hq⟩ := hne
  obtain ⟨ε, ε0, hεu⟩ := Metric.nhds_basis_closedBall.mem_iff.1 (hu.mem_nhds <| hsu hq)
  obtain ⟨t, ht₁, ht₂, ht₃⟩ := exists_subset_affineIndependent_affineSpan_eq_top h
  let f : P → P := fun y => lineMap q y (ε / dist y q)
  have hf : ∀ y, f y ∈ u := by
    refine fun y => hεu ?_
    simp only [f]
    rw [Metric.mem_closedBall, lineMap_apply, dist_vadd_left, norm_smul, Real.norm_eq_abs,
      dist_eq_norm_vsub V y q, abs_div, abs_of_pos ε0, abs_of_nonneg (norm_nonneg _), div_mul_comm]
    exact mul_le_of_le_one_left ε0.le (div_self_le_one _)
  have hεyq : ∀ y ∉ s, ε / dist y q ≠ 0 := fun y hy =>
    div_ne_zero ε0.ne' (dist_ne_zero.2 (ne_of_mem_of_not_mem hq hy).symm)
  classical
  let w : t → ℝˣ := fun p => if hp : (p : P) ∈ s then 1 else Units.mk0 _ (hεyq (↑p) hp)
  refine ⟨Set.range fun p : t => lineMap q p (w p : ℝ), ?_, ?_, ?_, ?_⟩
  · intro p hp; use ⟨p, ht₁ hp⟩; simp [w, hp]
  · rintro y ⟨⟨p, hp⟩, rfl⟩
    by_cases hps : p ∈ s <;>
    simp only [w, hps, lineMap_apply_one, Units.val_mk0, dif_neg, dif_pos, not_false_iff,
      Units.val_one, Subtype.coe_mk] <;>
    [exact hsu hps; exact hf p]
  · exact (ht₂.units_lineMap ⟨q, ht₁ hq⟩ w).range
  · rw [affineSpan_eq_affineSpan_lineMap_units (ht₁ hq) w, ht₃]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
∧
      s ⊆ interior t := by
  obtain ⟨v, hsv, hvu, hv⟩ := hu.exists_between_subset_of_affineIndependent_span_eq_top hsu hne h
  have hvne : v ≠ ∅ := nonempty_iff_ne_empty.1 (hne.mono hsv)
  have hvne' : (affineSpan ℝ v).Nonempty := by rwa [affineSpan_nonempty]
  have hvclosed : IsClosed (affineSpan ℝ v : Set P) :=
    isClosed_of_mem_of_nonempty_of_isCompact_of_closed hvne' (affineSpan ℝ v).isCompact_of_isClosed
      (affineSpan ℝ v).isClosed
  have hvopen : IsOpen (affineSpan ℝ v \ v) :=
    isOpen_of_mem_nhds fun p hp =>
      ((affineSpan ℝ v).mem_nhds_iff.2 ⟨p, hp.1, rfl⟩).diff
        ((hu.mem_nhds (hvu hp.1)).filter_mono inf_le_left)
  obtain ⟨w, hw⟩ := hvclosed.exists_between_subset_of_affineIndependent_span_eq_top hv hvne hv
  refine' ⟨s ∪ w, subset_union_left, union_subset hvu hw.1, h.union hw.2.1, hw.2.2.1, _⟩
  refine' subset_sUnion_of_mem ⟨_, _⟩
  · rintro p ⟨hp, -⟩
    exact hsv hp
  · rintro p ⟨hp, -⟩
    exact hw.1 ⟨affineSpan ℝ v.subtype ⟨p, hp⟩, hp, rfl⟩

Repaired Proof:
theorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)
    (hsu : s ⊆ u) (hne : s.Nonempty) (h : AffineIndependent ℝ ((↑) : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ t ⊆ u ∧ AffineIndependent ℝ ((↑) : t → P) ∧ affineSpan ℝ t = ⊤ ∧
      s ⊆ interior t := by
  obtain ⟨v, hsv, hvu, hv⟩ := hu.exists_between_subset_of_affineIndependent_span_eq_top hsu hne h
  have hvne : v ≠ ∅ := nonempty_iff_ne_empty.1 (hne.mono hsv)
  have hvne' : (affineSpan ℝ v).Nonempty := by rwa [affineSpan_nonempty]
  have hvclosed : IsClosed (affineSpan ℝ v : Set P) :=
    isClosed_of_mem_of_nonempty_of_isCompact_of_closed hvne' (affineSpan ℝ v).isCompact_of_isClosed
      (affineSpan ℝ v).isClosed
  have hvopen : IsOpen (affineSpan ℝ v \ v) :=
    isOpen_of_mem_nhds fun p hp =>
      ((affineSpan ℝ v).mem_nhds_iff.2 ⟨p, hp.1, rfl⟩).diff
        ((hu.mem_nhds (hvu hp.1)).filter_mono inf_le_left)
  obtain ⟨w, hw⟩ := hvclosed.exists_between_subset_of_affineIndependent_span_eq_top hv hvne hv
  refine ⟨s ∪ w, subset_union_left, union_subset hvu hw.1, h.union hw.2.1, hw.2.2.1, ?_⟩
  refine subset_sUnion_of_mem ⟨_, ?_⟩
  · rintro p ⟨hp, -⟩
    exact hsv hp
  · rintro p ⟨hp, -⟩
    exact hw.1 ⟨affineSpan ℝ v.subtype ⟨p, hp⟩, hp, rfl⟩

Repaired Proof:
theorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)
    (hsu : s ⊆ u) (hne : s.Nonempty) (h : AffineIndependent ℝ ((↑) : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ t ⊆ u ∧ AffineIndependent ℝ ((↑) : t → P) ∧ affineSpan ℝ t = ⊤ ∧
      s ⊆ interior t := by
  obtain ⟨v, hsv, hvu, hv⟩ := hu.exists_between_subset_of_affineIndependent_span_eq_top hsu hne h
  have hvne : v ≠ ∅ := nonempty_iff_ne_empty.1 (hne.mono hsv)
  have hvne' : (affineSpan ℝ v).Nonempty := by rwa [affineSpan_nonempty]
  have hvclosed : IsClosed (affineSpan ℝ v : Set P) :=
    isClosed_of_mem_of_nonempty_of_isCompact_of_closed hvne' (affineSpan ℝ v).isCompact_of_isClosed
      (affineSpan ℝ v).isClosed
  have hvopen : IsOpen (affineSpan ℝ v \ v) :=
    isOpen_of_mem_nhds fun p hp =>
      ((affineSpan ℝ v).mem_nhds_iff.2 ⟨p, hp.1, rfl⟩).diff
        ((hu.mem_nhds (hvu hp.1)).filter_mono inf_le_left)
  obtain ⟨w, hw⟩ := hvclosed.exists_between_subset_of_affineIndependent_span_eq_top hv hvne hv
  refine ⟨s ∪ w, subset_union_left, union_subset hvu hw.1, h.union hw.2.1, hw.2.2.1, ?_⟩
  refine subset_sUnion_of_mem ⟨_, ?_⟩
  · rintro p ⟨hp, -⟩
    exact hsv hp
  · rintro p ⟨hp, -⟩
    exact hw.1 ⟨affineSpan ℝ v.subtype ⟨p, hp⟩, hp, rfl⟩

Repaired Proof:
theorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)
    (hsu : s ⊆ u) (hne : s.Nonempty) (h : AffineIndependent ℝ ((↑) : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ t ⊆ u ∧ AffineIndependent ℝ ((↑) : t → P) ∧ affineSpan ℝ t = ⊤ ∧
      s ⊆ interior t := by
  obtain ⟨v, hsv, hvu, hv⟩ := hu.exists_between_subset_of_affineIndependent_span_eq_top hsu hne h
  have hvne : v ≠ ∅ := nonempty_iff_ne_empty.1 (hne.mono hsv)
  have hvne' : (affineSpan ℝ v).Nonempty := by rwa [affineSpan_nonempty]
  have hvclosed : IsClosed (affineSpan ℝ v : Set P) :=
    isClosed_of_mem_of_nonempty_of_isCompact_of_closed hvne' (affineSpan ℝ v).isCompact_of_isClosed
      (affineSpan ℝ v).isClosed
  have hvopen : IsOpen (affineSpan ℝ v \ v) :=
    isOpen_of_mem_nhds fun p hp =>
      ((affineSpan ℝ v).mem_nhds_iff.2 ⟨p, hp.1, rfl⟩).diff
        ((hu.mem_nhds (hvu hp.1)).filter_mono inf_le_left)
  obtain ⟨w, hw⟩ := hvclosed.exists_between_subset_of_affineIndependent_span_eq_top hv hvne hv
  refine ⟨s ∪ w, subset_union_

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Spectrum.lean - 2024-09-09 00:41:47.661331.
---46/200---
For theorem QuasispectrumRestricts.real_iff in Mathlib/Analysis/NormedSpace/Spectrum.lean:
lemma real_iff [Algebra ℂ A] {a : A} :
    SpectrumRestricts a Complex.reCLM ↔ ∀ x ∈ spectrum ℂ a, x = x.re 


Original valid proof:
:= by
  refine ⟨fun h x hx ↦ ?_, fun h ↦ ?_⟩
  · obtain ⟨x, -, rfl⟩ := h.algebraMap_image.symm ▸ hx
    simp
  · exact .of_subset_range_algebraMap Complex.ofReal_re fun x hx ↦ ⟨x.re, (h x hx).symm⟩


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ 0 ≤ x.re := by
  simp [SpectrumRestricts, Complex.isReal_iff]

end Restricts

section IsSelfAdjoint

lemma isSelfAdjoint_iff_isSelfAdjoint_coe [Algebra ℂ A] {a : A} :
    IsSelfAdjoint a ↔ IsSelfAdjoint (a : ℍ A) :=
  star_eq_self

lemma isSelfAdjoint_iff_isSelfAdjoint_coe_smul [Algebra ℂ A] {a : A} :
    IsSelfAdjoint a ↔ IsSelfAdjoint ((a : ℍ A) • (1 : ℍ A)) :=
  star_eq_self

end IsSelfAdjoint

section QuaternionAlgebra

variable {R : Type*} [CommRing R]

lemma _root_.quaternionAlgebra.coe_imJ_eq_zero [Algebra R ℍ[R]] (a : ℍ[R]) :
    (a : ℍ[R]) .imJ = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imK_eq_zero [Algebra R ℍ[R]] (a : ℍ[R]) :
    (a : ℍ[R]) .imK = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imI_eq_zero [Algebra R ℍ[R]] (a : ℍ[R]) :
    (a : ℍ[R]) .imI = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imL_eq_zero [Algebra R ℍ[R]] (a : ℍ[R]) :
    (a : ℍ[R]) .imL = 0 := rfl

lemma _root_.quaternionAlgebra.coe_re_eq_zero [Algebra R ℍ[R]] (a : ℍ[R]) :
    (a : ℍ[R]) .re = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imI_eq_zero' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imI (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imJ_eq_zero' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imJ (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imK_eq_zero' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imK (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imL_eq_zero' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imL (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_re_eq_zero' [Algebra R ℍ[R]] {a : ℍ[R]} :
    re (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imI_eq_zero'' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imI (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imJ_eq_zero'' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imJ (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imK_eq_zero'' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imK (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imL_eq_zero'' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imL (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imI_eq_zero''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imI (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imJ_eq_zero''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imJ (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imK_eq_zero''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imK (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imL_eq_zero''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imL (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_re_eq_zero''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    re (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imI_eq_zero'''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imI (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imJ_eq_zero'''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imJ (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imK_eq_zero'''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imK (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imL_eq_zero'''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imL (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imI_eq_zero''''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imI (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imJ_eq_zero''''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imJ (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imK_eq_zero''''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imK (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imL_eq_zero''''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imL (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_re_eq_zero''''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    re (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imI_eq_zero'''''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imI (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imJ_eq_zero'''''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imJ (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imK_eq_zero'''''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imK (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imL_eq_zero'''''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imL (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imI_eq_zero''''''' [Algebra R ℍ[R]] {a : ℍ[R]} :
    imI (a : ℍ[R]) = 0 := rfl

lemma _root_.quaternionAlgebra.coe_imJ_eq_zero''''''' [Al

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean - 2024-09-09 00:42:14.446361.
---47/200---
For theorem Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma in Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean:
theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : ℝ} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) ≤ Gamma s ^ a * Gamma t ^ b 


Original valid proof:
:= by
  let f : ℝ → ℝ → ℝ → ℝ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : ∀ c u x : ℝ, x ∈ Ioi (0 : ℝ) → 0 ≤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : ∀ c u : ℝ, ∀ᵐ x : ℝ ∂volume.restrict (Ioi 0), 0 ≤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    ∀ {c x : ℝ} (_ : 0 < c) (u : ℝ) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), ← exp_mul, ← rpow_mul hx.le]
    congr 2 <;> field_simp [hc.ne']; ring
  have f_mem_Lp :
    ∀ {c u : ℝ} (hc : 0 < c) (hu : 0 < u),
      Memℒp (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) ≠ 0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) ≠ ∞ := ENNReal.ofReal_ne_top
    rw [← memℒp_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memℒp_one_iff_integrable]
    · apply Integrable.congr (GammaIntegral_convergent hu)
      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    · refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      · exact continuous_exp.comp (continuous_const.mul continuous_id')
      · exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  · refine setIntegral_congr measurableSet_Ioi fun x hx => ?_
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [← exp_add, ← add_mul, ← neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [← rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  · rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx


Verifying proof (Commit 3cb2bdef8481160ee4f3f3a94fca1f5824c2798a):
↔
      (a * s + b * t) * log (a * s + b * t) ≤
        a * (s * log s) + b * (t * log t) + log (Gamma s ^ a * Gamma t ^ b) := by
  have : 0 < a * s + b * t := by
    rw [← hab, add_mul, mul_add, ← add_mul, add_comm]
    refine' add_pos_of_pos_of_nonneg (mul_pos ha hs) _
    refine' mul_nonneg (le_of_lt hb) (log_nonneg _)
    rw [← le_sub_iff_add_le', sub_self, Gamma_pos_of_pos ht]
    exact le_trans (mul_pos ha hs).le (le_of_eq (by simp [hab]))
  rw [← log_le_log_iff this, log_mul, log_rpow, log_rpow, log_rpow, log_mul, log_mul]
  · simp_rw [log_Gamma]
    rw [← le_sub_iff_add_le', ← le_sub_iff_add_le', sub_sub, sub_sub, sub_le_iff_le_add',
      sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le',
      sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ←
      le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add',
      ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add',
      ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add']
    ring_nf
    simp_rw [mul_assoc]
    rw [← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ←

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean - 2024-09-09 00:42:42.320142.
---48/200---
For theorem Real.Angle.cos_eq_real_cos_iff_eq_or_eq_neg in Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean:
theorem cos_eq_real_cos_iff_eq_or_eq_neg {θ : Angle} {ψ : ℝ} :
    cos θ = Real.cos ψ ↔ θ = ψ ∨ θ = -ψ 


Original valid proof:
:= by
  induction θ using Real.Angle.induction_on
  exact cos_eq_iff_coe_eq_or_eq_neg


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
∨ θ = ψ + π ∨ θ = -ψ + π := by
  induction θ using Real.Angle.induction_on
  simp_rw [cos_coe, cos_eq_iff_coe_eq_or_eq_neg, ← neg_coe_toReal, coe_neg, neg_inj, coe_add,
    coe_neg_one, add_comm _ π, neg_add_eq_sub, sub_eq_add_neg]

Repaired Proof:
theorem cos_eq_real_cos_iff_eq_or_eq_neg {θ : Angle} {ψ : ℝ} :
    cos θ = Real.cos ψ ↔ θ = ψ ∨ θ = -ψ ∨ θ = ψ + π ∨ θ = -ψ + π := by
  induction θ using Real.Angle.induction_on
  simp_rw [cos_coe, cos_eq_iff_coe_eq_or_eq_neg, ← neg_coe_toReal, coe_neg, neg_inj, coe_add,
    coe_neg_one, add_comm _ π, neg_add_eq_sub, sub_eq_add_neg]
  refine' or_congr_right' _
  refine' or_congr_right' _
  refine' or_congr_right' ?_
  refine' or_congr_right' ?_
  all_goals rfl

Repaired Proof:
theorem cos_eq_iff_coe_eq_or_eq_neg {θ : Angle} {ψ : ℝ} : cos θ = cos ψ ↔ θ = ψ ∨ θ = -ψ := by
  induction θ using Real.Angle.induction_on
  exact cos_eq_iff_coe_eq_or_eq_neg

Repaired Proof:
theorem cos_eq_iff_eq_or_eq_neg {θ : Angle} {ψ : ℝ} : cos θ = cos ψ ↔ θ = ψ ∨ θ = -ψ := by
  induction θ using Real.Angle.induction_on
  exact cos_eq_iff_eq_or_eq_neg

Repaired Proof:
theorem cos_eq_real_cos_iff_eq_or_eq_neg {θ : Angle} {ψ : ℝ} :
    cos θ = Real.cos ψ ↔ θ = ψ ∨ θ = -ψ ∨ θ = ψ + π ∨ θ = -ψ + π := by
  induction θ using Real.Angle.induction_on
  simp_rw [cos_coe, cos_eq_iff_coe_eq_or_eq_neg, ← neg_coe_toReal, coe_neg, neg_inj, coe_add,
    coe_neg_one, add_comm _ π, neg_add_eq_sub, sub_eq_add_neg]
  refine or_congr_right' ?_
  refine or_congr_right' ?_
  refine or_congr_right' ?_
  all_goals rfl

Repaired Proof:
theorem cos_eq_iff_coe_eq_or_eq_neg {θ : Angle} {ψ : ℝ} : cos θ = Real.cos ψ ↔ θ = ψ ∨ θ = -ψ := by
  induction θ using Real.Angle.induction_on
  exact cos_eq_iff_coe_eq_or_eq_neg

Repaired Proof:
theorem cos_eq_iff_eq_or_eq_neg {θ : Angle} {ψ : ℝ} : cos θ = cos ψ ↔ θ = ψ ∨ θ = -ψ := by
  induction θ using Real.Angle.induction_on
  exact cos_eq_iff_eq_or_eq_neg

Repaired Proof:
theorem cos_eq_real_cos_iff_eq_or_eq_neg {θ : Angle} {ψ : ℝ} :
    cos θ = Real.cos ψ ↔ θ = ψ ∨ θ = -ψ ∨ θ = ψ + π ∨ θ = -ψ + π := by
  induction θ using Real.Angle.induction_on
  simp_rw [cos_coe, cos_eq_iff_coe_eq_or_eq_neg, ← neg_coe_toReal, coe_neg, neg_inj, coe_add,
    coe_neg_one, add_comm _ π, neg_add_eq_sub, sub_eq_add_neg]
  refine or_congr_right' ?_
  refine or_congr_right' ?_
  refine or_congr_right' ?_
  all_goals rfl

Repaired Proof:
theorem cos_eq_iff_coe_eq_or_eq_neg {θ : Angle} {ψ : ℝ} : cos θ = Real.cos ψ ↔ θ = ψ ∨ θ = -ψ := by
  induction θ using Real.Angle.induction_on
  exact cos_eq_iff_coe_eq_or_eq_neg

Repaired Proof:
theorem cos_eq_iff_eq_or_eq_neg {θ : Angle} {ψ : ℝ} : cos θ = cos ψ ↔ θ = ψ ∨ θ = -ψ := by
  induction θ using Real.Angle.induction_on
  exact cos_eq_iff_eq_or_eq_neg

Repaired Proof:
theorem cos_eq_real_cos_iff_eq_or_eq_neg {θ : Angle} {ψ : ℝ} :
    cos θ = Real.cos ψ ↔ θ = ψ ∨ θ = -ψ ∨ θ = ψ + π ∨ θ = -ψ + π := by
  induction θ using Real.Angle.induction_on
  simp_rw [cos_coe, cos_eq_iff_coe_eq_or_eq_neg, ← neg_coe_toReal, coe_neg, neg_inj, coe_add,
    coe_neg_one, add_comm _ π, neg_add_eq_sub, sub_eq_add_neg]
  refine or_congr_right' ?_
  refine or_congr_right' ?_
  refine or_congr_right' ?_
  all_goals rfl

Repaired Proof:
theorem cos_eq_iff_coe_eq_or_eq_neg {θ : Angle} {ψ : ℝ} : cos θ = Real.cos ψ ↔ θ = ψ ∨ θ = -ψ := by
  induction θ using Real.Angle.induction_on
  exact cos_eq_iff_coe_eq_or_eq_neg

Repaired Proof:
theorem cos_eq_iff_eq_or_eq_neg {θ : Angle} {ψ : ℝ} : cos θ = cos ψ ↔ θ = ψ ∨ θ = -ψ := by
  induction θ using Real.Angle.induction_on
  exact cos_eq_iff_eq_or_eq_neg

Repaired Proof:
theorem cos_eq_real_cos_iff_eq_or_eq_neg {θ : Angle} {ψ : ℝ} :
    cos θ = Real.cos ψ ↔ θ = ψ ∨ θ = -ψ ∨ θ = ψ + π ∨ θ = -ψ + π := by
  induction θ using Real.Angle.induction_on
  simp_rw [cos_coe, cos_eq_iff_coe_eq_or_eq_neg, ← neg_coe_toReal, coe_neg, neg_inj, coe_add,
    coe_neg_one, add_comm _ π, neg_add_eq_sub, sub_eq_add_neg]
  refine or_congr_right' ?_
  refine or_congr_right' ?_
  refine or_congr_right' ?_
  all_goals rfl

Repaired Proof:
theorem cos_eq_iff_coe_eq_or_eq_neg {θ : Angle} {ψ : ℝ} : cos θ = Real.cos ψ ↔ θ = ψ ∨ θ = -ψ := by
  induction θ using Real.Angle.induction_on
  exact cos_eq_iff_coe_eq_or_eq_neg

Repaired Proof:
theorem cos_eq_iff_eq_or_eq_

Attempt failure.

Working on Mathlib/Analysis/SpecificLimits/Normed.lean - 2024-09-09 00:43:01.222733.
---49/200---
For theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one in Mathlib/Analysis/SpecificLimits/Normed.lean:
theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : ℕ) {r : ℝ} (hr : |r| < 1) :
    Tendsto (fun n ↦ (n : ℝ) ^ k * r ^ n : ℕ → ℝ) atTop (𝓝 0) 


Original valid proof:
:= by
  by_cases h0 : r = 0
  · exact tendsto_const_nhds.congr'
      (mem_atTop_sets.2 ⟨1, fun n hn ↦ by simp [zero_lt_one.trans_le hn |>.ne', h0]⟩)
  have hr' : 1 < |r|⁻¹ := one_lt_inv (abs_pos.2 h0) hr
  rw [tendsto_zero_iff_norm_tendsto_zero]
  simpa [div_eq_mul_inv] using tendsto_pow_const_div_const_pow_of_one_lt k hr'


Verifying proof (Commit e234e64075504db13790aa471a4239039c94703b):
∧
      Tendsto (fun n ↦ (n : ℝ) ^ (k + 1) * r ^ n : ℕ → ℝ) atTop (𝓝 0) := by
  have hr' : 1 < |r|⁻¹ := one_lt_inv (abs_pos.2 <| hr.ne) hr
  have h₁ : Tendsto (fun n ↦ (n : ℝ) ^ k * r ^ n : ℕ → ℝ) atTop (𝓝 0) := by
    simpa only [← abs_pow, ← abs_inv, abs_eq_self.mpr (le_of_lt <| inv_pos.2 <| abs_pos.2 <| hr.ne),
      inv_pow, ← mul_assoc, ← pow_succ']
      using tendsto_abs_pow_mul_geometric_of_norm_lt_one k hr
  have h₂ : Tendsto (fun n ↦ (n : ℝ) ^ (k + 1) * r ^ n : ℕ → ℝ) atTop (𝓝 0) := by
    simpa only [abs_pow, ← abs_inv, abs_eq_self.mpr (le_of_lt <| inv_pos.2 <| abs_pos.2 <| hr.ne),
      inv_pow, ← mul_assoc, ← pow_succ', ← mul_assoc, ← pow_succ, ← mul_pow]
      using tendsto_abs_pow_mul_geometric_of_norm_lt_one (k + 1) hr'
  exact ⟨h₁, h₂⟩

Repaired Proof:
theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : ℕ) {r : ℝ} (hr : |r| < 1) :
    Tendsto (fun n ↦ (n : ℝ) ^ k * r ^ n : ℕ → ℝ) atTop (𝓝 0) ∧
      Tendsto (fun n ↦ (n : ℝ) ^ (k + 1) * r ^ n : ℕ → ℝ) atTop (𝓝 0) := by
  have hr' : 1 < |r|⁻¹ := one_lt_inv (abs_pos.2 <| hr.ne) hr
  have h₁ : Tendsto (fun n ↦ (n : ℝ) ^ k * r ^ n : ℕ → ℝ) atTop (𝓝 0) := by
    simpa only [← abs_pow, ← abs_inv, abs_eq_self.mpr (le_of_lt <| inv_pos.2 <| abs_pos.2 <| hr.ne),
      inv_pow, ← mul_assoc, ← pow_succ']
      using tendsto_pow_mul_geometric_of_norm_lt_one k hr
  have h₂ : Tendsto (fun n ↦ (n : ℝ) ^ (k + 1) * r ^ n : ℕ → ℝ) atTop (𝓝 0) := by
    simpa only [abs_pow, ← abs_inv, abs_eq_self.mpr (le_of_lt <| inv_pos.2 <| abs_pos.2 <| hr.ne),
      inv_pow, ← mul_assoc, ← pow_succ', ← mul_assoc, ← pow_succ, ← mul_pow]
      using tendsto_pow_mul_geometric_of_norm_lt_one (k + 1) hr'
  exact ⟨h₁, h₂⟩

Repaired Proof:
theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : ℕ) {r : ℝ} (hr : |r| < 1) :
    Tendsto (fun n ↦ (n : ℝ) ^ k * r ^ n : ℕ → ℝ) atTop (𝓝 0) ∧
      Tendsto (fun n ↦ (n : ℝ) ^ (k + 1) * r ^ n : ℕ → ℝ) atTop (𝓝 0) := by
  have hr' : 1 < |r|⁻¹ := one_lt_inv (abs_pos.2 <| hr.ne) hr
  have h₁ : Tendsto (fun n ↦ (n : ℝ) ^ k * r ^ n : ℕ → ℝ) atTop (𝓝 0) := by
    simpa only [← abs_pow, ← abs_inv, abs_eq_self.mpr (le_of_lt <| inv_pos.2 <| abs_pos.2 <| hr.ne),
      inv_pow, ← mul_assoc, ← pow_succ']
      using tendsto_pow_mul_geometric_of_norm_lt_one k hr
  have h₂ : Tendsto (fun n ↦ (n : ℝ) ^ (k + 1) * r ^ n : ℕ → ℝ) atTop (𝓝 0) := by
    simpa only [abs_pow, ← abs_inv, abs_eq_self.mpr (le_of_lt <| inv_pos.2 <| abs_pos.2 <| hr.ne),
      inv_pow, ← mul_assoc, ← pow_succ', ← mul_assoc, ← pow_succ, ← mul_pow]
      using tendsto_pow_mul_geometric_of_norm_lt_one (k + 1) hr'
  exact ⟨h₁, h₂⟩

Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean - 2024-09-09 00:43:19.436276.
---50/200---
For theorem CategoryTheory.InjectiveResolution.ofCocomplex_exactAt_succ in Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean:
lemma ofCocomplex_exactAt_succ (n : ℕ) :
    (ofCocomplex Z).ExactAt (n + 1) 


Original valid proof:
:= by
  rw [HomologicalComplex.exactAt_iff' _ n (n + 1) (n + 1 + 1) (by simp) (by simp)]
  dsimp [ofCocomplex, CochainComplex.mk', CochainComplex.mk, HomologicalComplex.sc',
      HomologicalComplex.shortComplexFunctor']
  simp only [CochainComplex.of_d]
  match n with
  | 0 => apply exact_f_d ((CochainComplex.mkAux _ _ _
      (d (Injective.ι Z)) (d (d (Injective.ι Z))) _ _ 0).f)
  | n+1 => apply exact_f_d ((CochainComplex.mkAux _ _ _
      (d (Injective.ι Z)) (d (d (Injective.ι Z))) _ _ (n+1)).f)


Verifying proof (Commit b80a452d9c16e7a603a862a57bc182178c081175):
 := by
  rw [HomologicalComplex.exactAt_iff' _ n (n + 1) (n + 1 + 1) (by simp) (by simp)]
  dsimp [ofCocomplex, HomologicalComplex.sc', HomologicalComplex.sc]
  simp only [CochainComplex.ofCocomplex_d_1_0, CochainComplex.ofCocomplex_d_succ_comp_d,
    CochainComplex.ofCocomplex_d_comp_d_assoc, CochainComplex.ofCocomplex_d_2_1,
    CochainComplex.ofCocomplex_d_zero_one, zero_comp, comp_zero,
    CochainComplex.ofCocomplex_d_succ_comp_d_assoc,
    CochainComplex.ofCocomplex_d_comp_d_succ, zero_app, d_comp_d_assoc,
    CochainComplex.ofCocomplex_d_comp_d_zero, d_comp_d,
    CochainComplex.ofCocomplex_d_succ_comp_d'_assoc,
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex.ofCocomplex_d_comp_d_succ',
    CochainComplex.ofCocomplex_d_succ_comp_d'_zero,
    CochainComplex.ofCocomplex_d_comp_d_zero',
    CochainComplex

Attempt failure.

Working on Mathlib/CategoryTheory/Closed/Functor.lean - 2024-09-09 00:43:33.453583.
---51/200---
For theorem CategoryTheory.expComparison_whiskerLeft in Mathlib/CategoryTheory/Closed/Functor.lean:
theorem expComparison_whiskerLeft {A A' : C} (f : A' ⟶ A) :
    expComparison F A ≫ whiskerLeft _ (pre (F.map f)) =
      whiskerRight (pre f) _ ≫ expComparison F A' 


Original valid proof:
:= by
  ext B
  dsimp
  apply uncurry_injective
  rw [uncurry_natural_left, uncurry_natural_left, uncurry_expComparison, uncurry_pre,
    prod.map_swap_assoc, ← F.map_id, expComparison_ev, ← F.map_id, ←
    prodComparison_inv_natural_assoc, ← prodComparison_inv_natural_assoc, ← F.map_comp, ←
    F.map_comp, prod_map_pre_app_comp_ev]


Verifying proof (Commit 565b3377dc3477a9806f4e6db16008ee47fd08ed):
≫ (exp F A').map (F.map f) := by
  dsimp [expComparison, exp]
  simp only [← Functor.map_comp, ← Category.assoc, eqToHom_map, eqToHom_trans]
  simp only [← NatTrans.naturality_assoc, ← NatTrans.naturality,
    (exp.adjunction _).counit_naturality_assoc, (exp.adjunction _).counit_naturality,
    whiskerLeft_app, whiskerRight_app, NatTrans.naturality_assoc, NatTrans.naturality,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.

Attempt failure.

Working on Mathlib/CategoryTheory/EqToHom.lean - 2024-09-09 00:43:42.990183.
---52/200---
For theorem CategoryTheory.congrArg_cast_hom_left in Mathlib/CategoryTheory/EqToHom.lean:
theorem congrArg_cast_hom_left {X Y Z : C} (p : X = Y) (q : Y ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) p.symm) q = eqToHom p ≫ q 


Original valid proof:
:= by
  cases p
  simp


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
≫ eqToHom p.symm := by
  subst p
  simp

theorem congrArg_cast_hom_right {X Y Z : C} (p : X ⟶ Y) (q : Y = Z) :
    cast (congrArg (fun W : C => X ⟶ W) q) p = eqToHom q.symm ≫ p ≫ eqToHom q := by
  subst q
  simp

theorem congrArg_cast_hom_left_right {X Y Z : C} (p : X = Y) (q : Y = Z) (f : X ⟶ Y) :
    cast (congrArg (fun W : C => W ⟶ Z) (p.trans q)) f = eqToHom p ≫ cast (congrArg (fun W : C => W ⟶ Z) q) f ≫ eqToHom q.symm := by
  subst p
  simp

theorem congrArg_cast_hom_right_right {X Y Z : C} (p : X = Y) (q : Y = Z) (f : Y ⟶ Z) :
    cast (congrArg (fun W : C => X ⟶ W) (p.trans q)) f = eqToHom p.symm ≫ cast (congrArg (fun W : C => X ⟶ W) q) f ≫ eqToHom q := by
  subst p
  simp

theorem congrArg_cast_hom_left_left {X Y Z : C} (p : X = Y) (q : X = Z) (f : X ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) (p.trans q.symm)) f = eqToHom p ≫ cast (congrArg (fun W : C => W ⟶ Z) q.symm) f ≫ eqToHom q := by
  subst p
  simp

theorem congrArg_cast_hom_right_left {X Y Z : C} (p : X = Y) (q : X = Z) (f : Y ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) (p.trans q.symm)) f = eqToHom p.symm ≫ cast (congrArg (fun W : C => W ⟶ Z) q.symm) f ≫ eqToHom q := by
  subst p
  simp

theorem congrArg_cast_eqToHom_left {X Y : C} (p : X = Y) {Z : C} (f : X ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) p) f = eqToHom p ≫ f := by
  subst p
  simp

theorem congrArg_cast_eqToHom_right {X Y : C} (p : X = Y) {Z : C} (f : Y ⟶ Z) :
    cast (congrArg (fun W : C => X ⟶ W) p) f = f ≫ eqToHom p.symm := by
  subst p
  simp

theorem congrArg_cast_eqToHom_left_right {X Y : C} (p : X = Y) {Z : C} (f : X ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) p) f = eqToHom p ≫ f ≫ eqToHom p.symm := by
  subst p
  simp

theorem congrArg_cast_eqToHom_right_right {X Y : C} (p : X = Y) {Z : C} (f : Y ⟶ Z) :
    cast (congrArg (fun W : C => X ⟶ W) p) f = f ≫ eqToHom p.symm ≫ eqToHom p := by
  subst p
  simp

theorem congrArg_cast_eqToHom_left_left {X Y : C} (p : X = Y) {Z : C} (f : X ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) (p.symm.trans p)) f = eqToHom p.symm ≫ f ≫ eqToHom p := by
  subst p
  simp

theorem congrArg_cast_eqToHom_right_left {X Y : C} (p : X = Y) {Z : C} (f : Y ⟶ Z) :
    cast (congrArg (fun W : C => X ⟶ W) (p.symm.trans p)) f = f ≫ eqToHom p ≫ eqToHom p.symm := by
  subst p
  simp

theorem congrArg_cast_eqToHom_left_right_left {X Y : C} (p : X = Y) {Z : C} (f : X ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) (p.symm.trans p)) f = eqToHom p.symm ≫ f ≫ eqToHom p := by
  subst p
  simp

theorem congrArg_cast_eqToHom_right_right_left {X Y : C} (p : X = Y) {Z : C} (f : Y ⟶ Z) :
    cast (congrArg (fun W : C => X ⟶ W) (p.symm.trans p)) f = f ≫ eqToHom p ≫ eqToHom p.symm := by
  subst p
  simp

theorem congrArg_cast_eqToHom_left_left_left {X Y : C} (p : X = Y) {Z : C} (f : X ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) (p.symm.trans p)) f = eqToHom p.symm ≫ f ≫ eqToHom p := by
  subst p
  simp

theorem congrArg_cast_eqToHom_right_left_left {X Y : C} (p : X = Y) {Z : C} (f : Y ⟶ Z) :
    cast (congrArg (fun W : C => X ⟶ W) (p.symm.trans p)) f = f ≫ eqToHom p ≫ eqToHom p.symm := by
  subst p
  simp

theorem congrArg_cast_eqToHom_left_right_right {X Y : C} (p : X = Y) {Z : C} (f : X ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) (p.symm.trans p)) f = eqToHom p.symm ≫ f ≫ eqToHom p := by
  subst p
  simp

theorem congrArg_cast_eqToHom_right_right_right {X Y : C} (p : X = Y) {Z : C} (f : Y ⟶ Z) :
    cast (congrArg (fun W : C => X ⟶ W) (p.symm.trans p)) f = f ≫ eqToHom p ≫ eqToHom p.symm := by
  subst p
  simp

theorem congrArg_cast_eqToHom_left_left_right {X Y : C} (p : X = Y) {Z : C} (f : X ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) (p.symm.trans p)) f = eqToHom p.symm ≫ f ≫ eqToHom p := by
  subst p
  simp

theorem congrArg_cast_eqToHom_right_left_right {X Y : C} (p : X = Y) {Z : C} (f : Y ⟶ Z) :
    cast (congrArg (fun W : C => X ⟶ W) (p.symm.trans p)) f = f ≫ eqToHom p ≫ eqToHom p.symm := by
  subst p
  simp

theorem congrArg_cast_eqToHom_left_right_left_left {X Y : C} (p : X = Y) {Z : C} (f : X ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) (p.symm.trans p)) f = eqToHom p.symm ≫ f ≫ eqToHom p := by
  subst p
  simp

theorem congrArg_cast_eqToHom_right_right_left_left {X Y : C} (p : X = Y) {Z : C} (f : Y ⟶ Z) :
    cast (congrArg (

Attempt failure.

Working on Mathlib/CategoryTheory/EssentialImage.lean - 2024-09-09 00:43:49.984224.
---53/200---
For theorem CategoryTheory.Functor.essImage_eq_of_natIso in Mathlib/CategoryTheory/EssentialImage.lean:
theorem essImage_eq_of_natIso {F' : C ⥤ D} (h : F ≅ F') : essImage F = essImage F' 


Original valid proof:
:=
  funext fun _ => propext ⟨essImage.ofNatIso h, essImage.ofNatIso h.symm⟩


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):
 := by
  ext X
  constructor
  · rintro ⟨Y, f, hf⟩
    exact ⟨Y, h.hom.app X ≫ f, hf⟩
  · rintro ⟨Y, f, hf⟩
    exact ⟨Y, h.inv.app X ≫ f, hf⟩

theorem essImage_eq_of_iso {F' : C ⥤ D} (h : F ≅ F') : F.essImage = F'.essImage := by
  ext X
  constructor
  · rintro ⟨Y, f, hf⟩
    exact ⟨Y, h.hom.app X ≫ f, hf⟩
  · rintro ⟨Y, f, hf⟩
    exact ⟨Y, h.inv.app X ≫ f, hf⟩

theorem essSurj_of_natIso {F' : C ⥤ D} (h : F ≅ F') [F.EssSurj] : F'.EssSurj :=
  ⟨fun Y =>
    ⟨F.objPreimage Y, ⟨(h.app (F.objPreimage Y)).app Y ≫ F.objObjPreimageIso Y.as.hom⟩⟩⟩

theorem essSurj_of_iso {F' : C ⥤ D} (h : F ≅ F') [F.EssSurj] : F'.EssSurj :=
  essSurj_of_natIso h

theorem essSurj_of_initial (F : C ⥤ D) [Initial C] : F.EssSurj where
  mem_essImage Y :=
    ⟨⟨⟨Y⟩⟩, ⟨Functor.objObjPreimageIso (F.objObjPreimageIso (default : F.obj (⊥_ C)))⟩⟩

theorem essSurj_of_isEmpty [IsEmpty C] (F : C ⥤ D) : F.EssSurj where
  mem_essImage Y :=
    ⟨⟨⟨Y⟩⟩, ⟨Functor.objObjPreimageIso (F.objObjPreimageIso (default : F.obj (⊥_ C)))⟩⟩

theorem essSurj_of_iso {F' : C ⥤ D} (h : F ≅ F') [F.EssSurj] : F'.EssSurj :=
  essSurj_of_natIso h

theorem essSurj_of_empty_target [IsEmpty D] (F : C ⥤ D) : F.EssSurj where
  mem_essImage _ := ⟨default, ⟨Functor.objObjPreimageIso _ _⟩⟩

theorem essSurj_of_iso_essSurj {F' : C ⥤ D} (h : F ≅ F') [F.EssSurj] : F'.EssSurj :=
  essSurj_of_natIso h

theorem essSurj_of_fullyFaithful_essSurj (F : C ⥤ D) [F.FullyFaithful] [F.EssSurj] :
    F.EssSurj where
  mem_essImage Y :=
    ⟨F.preimage (Classical.arbitrary (F.objPreimage Y)),
      ⟨FullyFaithful.preimageIso (Classical.arbitrary (F.objPreimage Y))⟩⟩

theorem essSurj_of_fullyFaithful_essSurj' (F : C ⥤ D) [F.FullyFaithful] [F.EssSurj] :
    F.EssSurj where
  mem_essImage Y :=
    ⟨F.preimage (Classical.arbitrary (F.objPreimage Y)),
      ⟨(F.fullyFaithful.preimageIso (Classical.arbitrary (F.objPreimage Y))).symm⟩⟩

theorem essSurj_of_isEquivalence {F : C ⥤ D} [F.IsEquivalence] : F.EssSurj where
  mem_essImage Y := ⟨F.objPreimage Y, ⟨(F.objObjPreimageIso Y).symm⟩⟩

theorem essSurj_of_isEquivalence' {F : C ⥤ D} [F.IsEquivalence] : F.EssSurj where
  mem_essImage Y := ⟨F.objPreimage Y, ⟨F.objObjPreimageIso Y⟩⟩

theorem essSurj_of_isEquivalence_inverse (F : C ⥤ D) [F.IsEquivalence] :
    F.inv.EssSurj where
  mem_essImage Y := ⟨Y.obj, ⟨eqToIso (by simp)⟩⟩

theorem essSurj_of_isEquivalence_inverse' (F : C ⥤ D) [F.IsEquivalence] :
    F.inv.EssSurj where
  mem_essImage Y := ⟨Y.obj, ⟨eqToIso (by simp)⟩⟩

theorem essSurj_of_isEquivalence_functor (F : C ⥤ D) [F.IsEquivalence] :
    F.essSurj where
  mem_essImage Y := ⟨Y.obj, ⟨eqToIso (by simp)⟩⟩

theorem essSurj_of_isEquivalence_functor' (F : C ⥤ D) [F.IsEquivalence] :
    F.essSurj where
  mem_essImage Y := ⟨Y.obj, ⟨eqToIso (by simp)⟩⟩

theorem essSurj_of_isEquivalence_inverse_of_isEquivalence_functor
    {F : C ⥤ D} {G : D ⥤ C} (hF : F.IsEquivalence) (hG : G.IsEquivalence)
    (h : F ⋙ G ≅ 𝟭 C) : F.EssSurj where
  mem_essImage Y :=
    ⟨G.obj Y, ⟨(IsIso.ofNatIso (h.app (G.obj Y)).symm).app Y⟩⟩

theorem essSurj_of_isEquivalence_inverse_of_isEquivalence_functor'
    {F : C ⥤ D} {G : D ⥤ C} (hF : F.IsEquivalence) (hG : G.IsEquivalence)
    (h : F ⋙ G ≅ 𝟭 C) : F.EssSurj where
  mem_essImage Y :=
    ⟨G.obj Y, ⟨(IsIso.ofNatIso (h.app (G.obj Y))).app Y⟩⟩

theorem essSurj_of_isEquivalence_inverse_of_isEquivalence_inverse
    {F : C ⥤ D} {G : D ⥤ C} (hF : F.IsEquivalence) (hG : G.IsEquivalence)
    (h : F ⋙ G ≅ 𝟭 C) (h' : G ⋙ F ≅ 𝟭 D) : F.EssSurj where
  mem_essImage Y :=
    ⟨G.obj (F.obj Y), ⟨(IsIso.ofNatIso (h.app (G.obj (F.obj Y))).symm).app Y⟩⟩

theorem essSurj_of_isEquivalence_inverse_of_isEquivalence_inverse'
    {F : C ⥤ D} {G : D ⥤ C} (hF : F.IsEquivalence) (hG : G.IsEquivalence)
    (h : F ⋙ G ≅ 𝟭 C) (h' : G ⋙ F ≅ 𝟭 D) : F.EssSurj where
  mem_essImage Y :=
    ⟨G.obj (F.obj Y), ⟨(IsIso.ofNatIso (h.app (G.obj (F.obj Y))).symm).app Y⟩⟩

theorem essSurj_of_isEquivalence_of_iso_essSurj {F' : C ⥤ D} (h : F ≅ F') [F.EssSurj] :
    F'.EssSurj where
  mem_essImage Y :=
    ⟨F.objPreimage Y, ⟨(h.app (F.objPreimage Y)).app Y ≫ F.objObjPre

Attempt failure.

Working on Mathlib/CategoryTheory/GradedObject/Associator.lean - 2024-09-09 00:43:55.695911.
---54/200---
For theorem CategoryTheory.GradedObject.ι_mapBifunctorAssociator_inv in Mathlib/CategoryTheory/GradedObject/Associator.lean:
lemma ι_mapBifunctorAssociator_inv (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J) (h : r (i₁, i₂, i₃) = j) :
    ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫
      (mapBifunctorAssociator associator ρ₁₂ ρ₂₃ X₁ X₂ X₃).inv j =
    ((associator.inv.app (X₁ i₁)).app (X₂ i₂)).app (X₃ i₃) ≫
      ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h 


Original valid proof:
:= by
  rw [← cancel_mono ((mapBifunctorAssociator associator ρ₁₂ ρ₂₃ X₁ X₂ X₃).hom j),
    assoc, assoc, Iso.inv_hom_id_eval, comp_id, ι_mapBifunctorAssociator_hom,
    ← NatTrans.comp_app_assoc, ← NatTrans.comp_app, Iso.inv_hom_id_app,
    NatTrans.id_app, NatTrans.id_app, id_comp]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
≫
        (mapBifunctorAssociator F₁₂ F ρ₁₂ X₁ X₂ X₃).hom j := by
  dsimp [ιMapBifunctorBifunctor₂₃MapObj, ιMapBifunctor₁₂BifunctorMapObj]
  simp only [ι_mapBifunctorMapObj, ι_mapBifunctorMapObj_assoc,
    ι_mapBifunctorBifunctorMapObj, ι_mapBifunctorBifunctorMapObj_assoc,
    ι_mapBifunctorAssociator_inv, ι_mapBifunctorAssociator_inv_assoc,
    ι_mapBifunctorAssociator_hom, ι_mapBifunctorAssociator_hom_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctorAssociator_hom_inv_app_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc_

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/HasLimits.lean - 2024-09-09 00:44:10.047432.
---55/200---
For theorem CategoryTheory.Limits.hasColimitOfIso in Mathlib/CategoryTheory/Limits/HasLimits.lean:
theorem hasColimitOfIso {F G : J ⥤ C} [HasColimit F] (α : G ≅ F) : HasColimit G 


Original valid proof:
:=
  HasColimit.mk
    { cocone := (Cocones.precompose α.hom).obj (colimit.cocone F)
      isColimit := (IsColimit.precomposeHomEquiv _ _).symm (colimit.isColimit F) }


Verifying proof (Commit 4e9ad32a390d245132183394a03b349e4f617c33):
 where
  exists_colimit :=
    ⟨⟨⟨colimit.cocone F,
        IsColimit.ofIsoColimit (colimit.isColimit F) α.symm⟩⟩⟩


instance hasColimitOfEquivalenceComp (e : J ≌ K) (F : K ⥤ C) [HasColimit F] : HasColimit (e.functor ⋙ F) :=
  HasColimit.mk
    { cocone := e.functor.mapCocone (colimit.cocone F)
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit F) e.functor.mapCoconePointIso }


instance hasColimitCompEquivalence (e : J ≌ K) (F : J ⥤ C) [HasColimit (e.inverse ⋙ F)] :
    HasColimit (F ⋙ e.functor) :=
  HasColimit.mk
    { cocone := (colimit.cocone (e.inverse ⋙ F)).whisker e.functor
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit _) e }


instance hasColimitCompEquivalence' (e : K ≌ J) [HasColimit (e.functor ⋙ F)] :
    HasColimit (F ⋙ e.inverse) :=
  HasColimit.mk
    { cocone := (colimit.cocone (e.functor ⋙ F)).whisker e.inverse
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit _) e.symm }


instance hasColimitEquivalenceComp (e : K ≌ J) (F : J ⥤ C) [HasColimit F] :
    HasColimit (e.functor ⋙ F) :=
  HasColimit.mk
    { cocone := (colimit.cocone F).whisker e.functor
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit F) e }


instance hasColimitEquivalenceComp' (e : J ≌ K) [HasColimit (e.inverse ⋙ F)] :
    HasColimit (F ⋙ e.functor) :=
  HasColimit.mk
    { cocone := (colimit.cocone (e.inverse ⋙ F)).whisker e.functor
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit _) e.symm }


instance hasColimitOfDiagramComp (F : J ⥤ K) (G : K ⥤ C) [HasColimit (F ⋙ G)] :
    HasColimit ((F ⋙ G) ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone (F ⋙ G)).whisker H
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit _) (F ⋙ G).equivalence }


instance hasColimitOfCompDiagram (F : J ⥤ K) (G : K ⥤ C) [HasColimit (G ⋙ F)] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone (G ⋙ F)).whisker H
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit _) (G ⋙ F).equivalence }


instance hasColimitOfComp (F : J ⥤ C) [HasColimit F] (G : C ⥤ D) [HasColimit (F ⋙ G)] :
    HasColimit (F ⋙ G) :=
  HasColimit.mk
    { cocone := (colimit.cocone F).mapCocone G
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit (F ⋙ G)) (mapCoconeWhisker _).symm }


instance hasColimitOfComp' (F : J ⥤ C) [HasColimit (F ⋙ G)] (H : C ⥤ D) [HasColimit (F ⋙ G ⋙ H)] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone (F ⋙ G)).mapCocone H
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit (F ⋙ G ⋙ H)) (mapCoconeWhisker _).symm }


instance hasColimitOfIso {F G : J ⥤ C} [HasColimit F] (α : F ≅ G) : HasColimit G :=
  HasColimit.mk
    { cocone := (colimit.cocone F).whisker α.functor
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit F) α.functor.equivalence }


instance hasColimitOfNatIso {F G : J ⥤ C} [HasColimit F] (α : F ≅ G) : HasColimit G :=
  HasColimit.mk
    { cocone := (colimit.cocone F).whisker α.functor
      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit F) α.functor.equivalence }


instance hasColimitOfCompIso {F : J ⥤ C} [HasColimit F] (G : C ⥤ D) (H : D ⥤ E) [IsIso (G ⋙ H)] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone F).mapCocone (G ⋙ H)
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit _)
        (Cocones.ext (Iso.refl _) (by aesop_cat)) }


instance hasColimitOfCompIso' {F : J ⥤ C} [HasColimit (F ⋙ G)] (H : D ⥤ E) [IsIso G] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone (F ⋙ G)).mapCocone H
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit _)
        (Cocones.ext (Iso.refl _) (by aesop_cat)) }


instance hasColimitOfCompIso {F : J ⥤ C} [HasColimit F] (G : C ⥤ D) (H : D ⥤ E) [IsIso G] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone F).mapCocone (G ⋙ H)
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit _)
        (Cocones.ext (Iso.refl _) (by aesop_cat)) }


instance hasColimitOfCompIso' {F : J ⥤ C} [HasColimit (F ⋙ G)] (H : D ⥤ E) [IsIso G] :
    HasColimit (F ⋙ G ⋙ H) :=
  HasColimit.mk
    { cocone := (colimit.cocone (F ⋙ G)).mapCocone H
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit _)
        (Cocones.ext (Iso.refl _) (by aesop_cat)) }


instance hasColimitOfEquivalenceComp (e : J ≌ K) (F : K ⥤ C) [HasColimit F] :
    HasColimit (e.functor ⋙ F) :=
  HasColimit.mk
    { cocone := e.functor.mapCocone (colimit.cocone F)
      isColimit := IsColimit.ofIsoColimit (colimit.isColimit F) e.functor.mapCoconePointIso }


instance hasColimitOfCompEquivalence (F : J ⥤ C) (e : K ≌ J) [HasColimit (F ⋙ e.functor)] :
    HasColimit (F ⋙ e.inverse) :=
  HasColimit.mk
    { cocone := (colimit.cocone (F ⋙ e.functor)).whisker e.inverse
      isColimit := IsColimit.

Attempt failure.

Working on Mathlib/CategoryTheory/MorphismProperty/Basic.lean - 2024-09-09 00:45:07.265535.
---56/200---
For theorem CategoryTheory.MorphismProperty.map_id_eq_isoClosure in Mathlib/CategoryTheory/MorphismProperty/Basic.lean:
lemma map_id_eq_isoClosure (P : MorphismProperty C) :
    P.map (𝟭 _) = P.isoClosure 


Original valid proof:
:= by
  apply le_antisymm
  · rw [map_le_iff P.isoClosure_respectsIso]
    intro X Y f hf
    exact P.le_isoClosure _ hf
  · intro X Y f hf
    exact hf


Verifying proof (Commit 6830b5e612c6f4431fee7e89ec01560ae5118e5e):
↔ P.IsStableUnderComposition := by
  refine ⟨fun h X Y Z f g hf hg => ?_, fun h => ?_⟩
  · rw [← h] at hg
    obtain ⟨X', Y', f', hf', _⟩ := hf
    obtain ⟨X'', Y'', g', hg', _⟩ := hg
    obtain ⟨X''', Y''', f'₁, hf'₁, f'₂, hf'₂, hf'⟩ :=
      P.isStableUnderComposition_iff.1 h (𝟙 X') (𝟙 Y') f' hf' (𝟙 Y') (𝟙 Z') g' hg' rfl
    exact ⟨X''', Y''', f'₁ ≫ f'₂, hf'₁, f'₂, hf'₂, hf'⟩
  · ext X Y f
    constructor
    · rintro ⟨X', Y', f', hf', h⟩
      obtain ⟨X'', Y'', g', hg', h'⟩ := h.isIso_of_isStableUnderComposition hf hg
      exact ⟨X'', Y'', g' ≫ f', hg', h'⟩
    · rintro ⟨X', Y', f', hf', h⟩
      exact ⟨X', Y', f', hf', h⟩

Repaired Proof:
lemma map_id_eq_isoClosure (P : MorphismProperty C) :
    P.map (𝟭 _) = P.isoClosure ↔ P.IsStableUnderComposition := by
  refine ⟨fun h X Y Z f g hf hg => ?_, fun h => ?_⟩
  · rw [← h] at hg
    obtain ⟨X', Y', f', hf', _⟩ := hf
    obtain ⟨X'', Y'', g', hg', _⟩ := hg
    obtain ⟨X''', Y''', f'₁, hf'₁, f'₂, hf'₂, hf'⟩ :=
      P.isStableUnderComposition_iff.1 h (𝟙 X') (𝟙 Y') f' hf' (𝟙 Y') (𝟙 Z') g' hg' rfl
    exact ⟨X''', Y''', f'₁ ≫ f'₂, hf'₁, f'₂, hf'₂, hf'⟩
  · ext X Y f
    constructor
    · rintro ⟨X', Y', f', hf', h⟩
      obtain ⟨X'', Y'', g', hg', h'⟩ := h.isIso_of_isStableUnderComposition hf hg
      exact ⟨X'', Y'', g' ≫ f', hg', h'⟩
    · rintro ⟨X', Y', f', hf', h⟩
      exact ⟨X', Y', f', hf', h⟩

Repaired Proof:
lemma map_id_eq_isoClosure (P : MorphismProperty C) :
    P.map (𝟭 _) = P.isoClosure ↔ P.IsStableUnderComposition := by
  refine ⟨fun h X Y Z f g hf hg => ?_, fun h => ?_⟩
  · rw [← h] at hg
    obtain ⟨X', Y', f', hf', _⟩ := hf
    obtain ⟨X'', Y'', g', hg', _⟩ := hg
    obtain ⟨X''', Y''', f'₁, hf'₁, f'₂, hf'₂, hf'⟩ :=
      P.isStableUnderComposition_iff.1 h (𝟙 X') (𝟙 Y') f' hf' (𝟙 Y') (𝟙 Z') g' hg' rfl
    exact ⟨X''', Y''', f'₁ ≫ f'₂, hf'₁, f'₂, hf'₂, hf'⟩
  · ext X Y f
    constructor
    · rintro ⟨X', Y', f', hf', h⟩
      obtain ⟨X'', Y'', g', hg', h'⟩ := h.isIso_of_isStableUnderComposition hf hg
      exact ⟨X'', Y'', g' ≫ f', hg', h'⟩
    · rintro ⟨X', Y', f', hf', h⟩
      exact ⟨X', Y', f', hf', h⟩

Repaired Proof:
lemma map_id_eq_isoClosure (P : MorphismProperty C) :
    P.map (𝟭 _) = P.isoClosure ↔ P.IsStableUnderComposition := by
  refine ⟨fun h X Y Z f g hf hg => ?_, fun h => ?_⟩
  · rw [← h] at hg
    obtain ⟨X', Y', f', hf', _⟩ := hf
    obtain ⟨X'', Y'', g', hg', _⟩ := hg
    obtain ⟨X''', Y''', f'₁, hf'₁, f'₂, hf'₂, hf'⟩ :=
      P.isStableUnderComposition_iff.1 h (𝟙 X') (𝟙 Y') f' hf' (𝟙 Y') (𝟙 Z') g' hg' rfl
    exact ⟨X''', Y''', f'₁ ≫ f'₂, hf'₁, f'₂, hf'₂, hf'⟩
  · ext X Y f
    constructor
    · rintro ⟨X', Y', f', hf', h⟩
      obtain ⟨X'', Y'', g', hg', h'⟩ := h.isIso_of_isStableUnderComposition hf hg
      exact ⟨X'', Y'', g' ≫ f', hg', h'⟩
    · rintro ⟨X', Y', f', hf', h⟩
      exact ⟨X', Y', f', hf', h⟩

Repaired Proof:
lemma map_id_eq_isoClosure (P : MorphismProperty C) :
    P.map (𝟭 _) = P.isoClosure ↔ P.IsStableUnderComposition := by
  refine ⟨fun h X Y Z f g hf hg => ?_, fun h => ?_⟩
  · rw [← h] at hg
    obtain ⟨X', Y', f', hf', _⟩ := hf
    obtain ⟨X'', Y'', g', hg', _⟩ := hg
    obtain ⟨X''', Y''', f'₁, hf'₁, f'₂, hf'₂, hf'⟩ :=
      P.isStableUnderComposition_iff.1 h (𝟙 X') (𝟙 Y') f' hf' (𝟙 Y') (𝟙 Z') g' hg' rfl
    exact ⟨X''', Y''', f'₁ ≫ f'₂, hf'₁, f'₂, hf'₂, hf'⟩
  · ext X Y f
    constructor
    · rintro ⟨X', Y', f', hf', h⟩
      obtain ⟨X'', Y'', g', hg', h'⟩ := h.isIso_of_isStableUnderComposition hf hg
      exact ⟨X'', Y'', g' ≫ f', hg', h'⟩
    · rintro ⟨X', Y', f', hf', h⟩
      exact ⟨X', Y', f', hf', h⟩

Repaired Proof:
lemma map_id_eq_isoClosure (P : MorphismProperty C) :
    P.map (𝟭 _) = P.isoClosure ↔ P.IsStableUnderComposition := by
  refine ⟨fun h X Y Z f g hf hg => ?_, fun h => ?_⟩
  · rw [← h] at hg
    obtain ⟨X', Y', f', hf', _⟩ := hf
    obtain ⟨X'', Y'', g', hg', _⟩ := hg
    obtain ⟨X''', Y''', f'₁, hf'₁, f'

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Coverage.lean - 2024-09-09 00:45:14.676527.
---57/200---
For theorem CategoryTheory.Coverage.eq_top_pullback in Mathlib/CategoryTheory/Sites/Coverage.lean:
lemma eq_top_pullback {X Y : C} {S T : Sieve X} (h : S ≤ T) (f : Y ⟶ X) (hf : S f) :
    T.pullback f = ⊤ 


Original valid proof:
:= by
  ext Z g
  simp only [Sieve.pullback_apply, Sieve.top_apply, iff_true]
  apply h
  apply S.downward_closed
  exact hf


Verifying proof (Commit 92beef58f265528359880ded59e9a73d818a6596):
↔ S.pullback f = ⊤ := by
  constructor
  · intro hT
    apply pullback_eq_top_of_baseChange_eq_top
    rw [hT]
    simp
  · intro hS
    rw [← pullback_comp, hS, pullback_top]

Repaired Proof:
lemma eq_top_pullback {X Y : C} {S T : Sieve X} (h : S ≤ T) (f : Y ⟶ X) (hf : S f) :
    T.pullback f = ⊤ ↔ S.pullback f = ⊤ := by
  constructor
  · intro hT
    apply pullback_eq_top_of_baseChange_eq_top
    rw [hT]
    simp
  · intro hS
    rw [← pullback_comp, hS, pullback_top]

Repaired Proof:
lemma pullback_eq_top_of_baseChange_eq_top {X Y : C} {S T : Sieve X} (f : Y ⟶ X)
    (h : S.pullback f = ⊤) : T.pullback f = ⊤ := by
  rw [← Sieve.generate_sieves, ← Sieve.generate_sieves] at h ⊢
  rw [Sieve.eq_top_iff_isSplitEpi]
  intro W g hg
  obtain ⟨R, hR, hR'⟩ := Sieve.pullback_eq_top_iff_mem.1 h g
  obtain ⟨Q, hQ, hQ'⟩ := Sieve.pullback_eq_top_iff_mem.1 hg hR
  refine' ⟨Q ≫ R, _, _⟩
  · simpa using Sieve.pullback_comp Q R
  · simp [hQ', hR']

Repaired Proof:
lemma pullback_eq_top_of_baseChange_eq_top {X Y : C} {S T : Sieve X} (f : Y ⟶ X)
    (h : S.pullback f = ⊤) : T.pullback f = ⊤ := by
  rw [← Sieve.generate_sieves, ← Sieve.generate_sieves] at h ⊢
  rw [Sieve.eq_top_iff_isSplitEpi]
  intro W g hg
  obtain ⟨R, hR, hR'⟩ := Sieve.pullback_eq_top_iff_mem.1 h g
  obtain ⟨Q, hQ, hQ'⟩ := Sieve.pullback_eq_top_iff_mem.1 hg hR
  refine ⟨Q ≫ R, ?_, ?_⟩
  · simpa using Sieve.pullback_comp Q R
  · simp [hQ', hR']

Repaired Proof:
lemma eq_top_pullback {X Y : C} {S T : Sieve X} (h : S ≤ T) (f : Y ⟶ X) (hf : S f) :
    T.pullback f = ⊤ ↔ S.pullback f = ⊤ := by
  constructor
  · intro hT
    apply pullback_eq_top_of_baseChange_eq_top
    rw [hT]
    simp
  · intro hS
    rw [← pullback_comp, hS, pullback_top]

Repaired Proof:
lemma pullback_eq_top_of_baseChange_eq_top {X Y : C} {S T : Sieve X} (f : Y ⟶ X)
    (h : S.pullback f = ⊤) : T.pullback f = ⊤ := by
  rw [← Sieve.generate_sieves, ← Sieve.generate_sieves] at h ⊢
  rw [Sieve.eq_top_iff_isSplitEpi]
  intro W g hg
  obtain ⟨R, hR, hR'⟩ := Sieve.pullback_eq_top_iff_mem.1 h g
  obtain ⟨Q, hQ, hQ'⟩ := Sieve.pullback_eq_top_iff_mem.1 hg hR
  refine ⟨Q ≫ R, ?_, ?_⟩
  · simpa using Sieve.pullback_comp Q R
  · simp [hQ', hR']

Repaired Proof:
lemma eq_top_pullback {X Y : C} {S T : Sieve X} (h : S ≤ T) (f : Y ⟶ X) (hf : S f) :
    T.pullback f = ⊤ ↔ S.pullback f = ⊤ := by
  constructor
  · intro hT
    apply pullback_eq_top_of_baseChange_eq_top
    rw [hT]
    simp
  · intro hS
    rw [← pullback_comp, hS, pullback_top]

Repaired Proof:
lemma pullback_eq_top_of_baseChange_eq_top {X Y : C} {S T : Sieve X} (f : Y ⟶ X)
    (h : S.pullback f = ⊤) : T.pullback f = ⊤ := by
  rw [← Sieve.generate_sieves, ← Sieve.generate_sieves] at h ⊢
  rw [Sieve.eq_top_iff_isSplitEpi]
  intro W g hg
  obtain ⟨R, hR, hR'⟩ := Sieve.pullback_eq_top_iff_mem.1 h g
  obtain ⟨Q, hQ, hQ'⟩ := Sieve.pullback_eq_top_iff_mem.1 hg hR
  refine ⟨Q ≫ R, ?_, ?_⟩
  · simpa using Sieve.pullback_comp Q R
  · simp [hQ', hR']

Repaired Proof:
lemma eq_top_pullback {X Y : C} {S T : Sieve X} (h : S ≤ T) (f : Y ⟶ X) (hf : S f) :
    T.pullback f = ⊤ ↔ S.pullback f = ⊤ := by
  constructor
  · intro hT
    apply pullback_eq_top_of_baseChange_eq_top
    rw [hT]
    simp
  · intro hS
    rw [← pullback_comp, hS, pullback_top]

Repaired Proof:
lemma pullback_eq_top_of_baseChange_eq_top {X Y : C} {S T : Sieve X} (f : Y ⟶ X)
    (h : S.pullback f = ⊤) : T.pullback f = ⊤ := by
  rw [← Sieve.generate_sieves, ← Sieve.generate_sieves] at h ⊢
  rw [Sieve.eq_top_iff_isSplitEpi]
  intro W g hg
  obtain ⟨R, hR, hR'⟩ := Sieve.pullback_eq_top_iff_mem.1 h g
  obtain ⟨Q, hQ, hQ'⟩ := Sieve.pullback_eq_top_iff_mem.1 hg hR
  refine ⟨Q ≫ R, ?_, ?_⟩
  · simpa using Sieve.pullback_comp Q R
  · simp [hQ', hR']

Repaired Proof:
lemma eq_top_pullback {X Y : C} {S T : Sieve X} (h : S ≤ T) (f : Y ⟶ X) (hf : S f) :
    T.pullback f = ⊤ ↔ S.pullback f = ⊤ := by
  constructor
  · intro hT
    apply pullback_eq_top_of_baseChange_eq_top
    rw [hT]
    simp
  · intro hS
    rw [← pullback_comp, hS, pullback_top]

Repaired Proof:
lemma pullback_eq_top_of_baseChange_eq_top {X Y : C} {S T : Sieve X} (f : Y ⟶ X)
    (h : S.pullback f = ⊤) : T.pullback f = ⊤ := by
  rw [← Sieve.generate_sieves, ← Sieve.generate_sieves] at h ⊢
  rw [Sieve.eq_top_iff_isSplitEpi]
  intro W g hg
  obtain ⟨R, hR, hR'⟩ := Sieve.pullback_eq

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Preserves.lean - 2024-09-09 00:45:23.897107.
---58/200---
For theorem CategoryTheory.Presieve.isSheafFor_of_preservesProduct in Mathlib/CategoryTheory/Sites/Preserves.lean:
theorem isSheafFor_of_preservesProduct [PreservesLimit (Discrete.functor (fun x ↦ op (X x))) F] :
    (ofArrows X c.inj).IsSheafFor F 


Original valid proof:
:= by
  rw [Equalizer.Presieve.Arrows.sheaf_condition, Limits.Types.type_equalizer_iff_unique]
  have : HasCoproduct X := ⟨⟨c, hc⟩⟩
  have hi : IsIso (piComparison F (fun x ↦ op (X x))) := inferInstance
  rw [piComparison_fac (hc := hc), isIso_iff_bijective, Function.bijective_iff_existsUnique] at hi
  intro b _
  obtain ⟨t, ht₁, ht₂⟩ := hi b
  refine ⟨F.map ((opCoproductIsoProduct' hc (productIsProduct _)).inv) t, ht₁, fun y hy ↦ ?_⟩
  apply_fun F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) using injective_of_mono _
  simp only [← FunctorToTypes.map_comp_apply, Iso.op, Category.assoc]
  rw [ht₂ (F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) y) (by simp [← hy])]
  change (𝟙 (F.obj (∏ᶜ fun x ↦ op (X x)))) t = _
  rw [← Functor.map_id]
  refine congrFun ?_ t
  congr
  simp [Iso.eq_inv_comp, ← Category.assoc, ← op_comp, eq_comm, ← Iso.eq_comp_inv]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔ (ofArrows (F.mapCone c) (F.map _)).IsSheafFor F := by
  have : (Discrete.functor (fun x ↦ op (F.mapObj X x))).obj ⟨i⟩ = (Discrete.functor (fun x ↦ op (X x))).obj ⟨i⟩ := by
    dsimp
    simp only [Functor.mapObj_obj, Functor.map_op]
  rw [isSheafFor_iff_isLimit, isSheafFor_iff_isLimit,
    isLimit_iff_isTerminal, isLimit_iff_isTerminal,
    isTerminal_iff_isEmpty, isTerminal_iff_isEmpty,
    isEmpty_iff, isEmpty_iff,
    ← Functor.isTerminal_map_iff F]
  rfl

theorem isSheafFor_iff_isSheafFor_presieve :
    (ofArrows X c.inj).IsSheafFor F ↔ (ofArrows (F.mapCone c) (F.map _)).IsSheafFor F := by
  rw [isSheafFor_iff_isSheafFor_family, isSheafFor_iff_isSheafFor_family]
  have : (Discrete.functor (fun x ↦ op (F.mapObj X x))).obj ⟨i⟩ = (Discrete.functor (fun x ↦ op (X x))).obj ⟨i⟩ := by
    dsimp
    simp only [Functor.mapObj_obj, Functor.map_op]
  rw [isSheafFor_iff_isLimit, isSheafFor_iff_isLimit,
    isLimit_iff_isTerminal, isLimit_iff_isTerminal,
    isTerminal_iff_isEmpty, isTerminal_iff_isEmpty,
    isEmpty_iff, isEmpty_iff,
    ← Functor.isTerminal_map_iff F]
  rfl

theorem isSheafFor_iff_isSheafFor_presieve' :
    (ofArrows X c.inj).IsSheafFor F ↔ (ofArrows (F.mapCone c) (F.map _)).IsSheafFor F := by
  rw [isSheafFor_iff_isSheafFor_presieve, isSheafFor_iff_isSheafFor_presieve]
  have : (Discrete.functor (fun x ↦ op (F.mapObj X x))).obj ⟨i⟩ = (Discrete.functor (fun x ↦ op (X x))).obj ⟨i⟩ := by
    dsimp
    simp only [Functor.mapObj_obj, Functor.map_op]
  rw [isSheafFor_iff_isSheafFor_family, isSheafFor_iff_isSheafFor_family,
    isLimit_iff_isTerminal, isLimit_iff_isTerminal,
    isTerminal_iff_isEmpty, isTerminal_iff_isEmpty,
    isEmpty_iff, isEmpty_iff,
    ← Functor.isTerminal_map_iff F]
  rfl

theorem isSheafFor_iff_isSheafFor_presieve'' :
    (ofArrows X c.inj).IsSheafFor F ↔ (ofArrows (F.mapCone c) (F.map _)).IsSheafFor F := by
  rw [isSheafFor_iff_isSheafFor_presieve', isSheafFor_iff_isSheafFor_presieve]
  have : (Discrete.functor (fun x ↦ op (F.mapObj X x))).obj ⟨i⟩ = (Discrete.functor (fun x ↦ op (X x))).obj ⟨i⟩ := by
    dsimp
    simp only [Functor.mapObj_obj, Functor.map_op]
  rw [isSheafFor_iff_isSheafFor_family, isSheafFor_iff_isSheafFor_family,
    isLimit_iff_isTerminal, isLimit_iff_isTerminal,
    isTerminal_iff_isEmpty, isTerminal_iff_isEmpty,
    isEmpty_iff, isEmpty_iff,
    ← Functor.isTerminal_map_iff F]
  rfl

theorem isSheafFor_iff_isSheafFor_presieve''' :
    (ofArrows X c.inj).IsSheafFor F ↔ (ofArrows (F.mapCone c) (F.map _)).IsSheafFor F := by
  rw [isSheafFor_iff_isSheafFor_presieve'', isSheafFor_iff_isSheafFor_presieve]
  have : (Discrete.functor (fun x ↦ op (F.mapObj X x))).obj ⟨i⟩ = (Discrete.functor (fun x ↦ op (X x))).obj ⟨i⟩ := by
    dsimp
    simp only [Functor.mapObj_obj, Functor.map_op]
  rw [isSheafFor_iff_isSheafFor_family, isSheafFor_iff_isSheafFor_family,
    isLimit_iff_isTerminal, isLimit_iff_isTerminal,
    isTerminal_iff_isEmpty, isTerminal_iff_isEmpty,
    isEmpty_iff, isEmpty_iff,
    ← Functor.isTerminal_map_iff F]
  rfl

theorem isSheafFor_iff_isSheafFor_presieve'''' :
    (ofArrows X c.inj).IsSheafFor F ↔ (ofArrows (F.mapCone c) (F.map _)).IsSheafFor F := by
  rw [isSheafFor_iff_isSheafFor_presieve''', isSheafFor_iff_isSheafFor_presieve]
  have : (Discrete.functor (fun x ↦ op (F.mapObj X x))).obj ⟨i⟩ = (Discrete.functor (fun x ↦ op (X x))).obj ⟨i⟩ := by
    dsimp
    simp only [Functor.mapObj_obj, Functor.map_op]
  rw [isSheafFor_iff_isSheafFor_family, isSheafFor_iff_isSheafFor_family,
    isLimit_iff_isTerminal, isLimit_iff_isTerminal,
    isTerminal_iff_isEmpty, isTerminal_iff_isEmpty,
    isEmpty_iff, isEmpty_iff,
    ← Functor.isTerminal_map_iff F]
  rfl

theorem isSheafFor_iff_isSheafFor_presieve''''' :
    (ofArrows X c.inj).IsSheafFor F ↔ (ofArrows (F.mapCone c) (F.map _)).IsSheafFor F := by
  rw [isSheafFor_iff_isSheafFor_presieve'''']
  have : (Discrete.functor (fun x ↦ op (F.mapObj X x))).obj ⟨i⟩ = (Discrete.functor (fun x ↦ op (X x))).obj ⟨i⟩ := by
    dsimp
    simp only [Functor.mapObj_obj, Functor.map_op]
  rw [isSheafFor_iff_isSheafFor_family, isSheafFor_iff_isSheafFor_family,
    isLimit_iff_isTerminal, isLimit_iff_isTerminal,
    isTerminal_iff_isEmpty, isTerminal_iff_isEmpty,
    isEmpty_iff, isEmpty_iff,
    ← Functor.isTerminal_map_iff F]
  rfl

theorem isSheafFor_iff_isSheafFor_presieve'''''' :
    (ofArrows X c.inj).IsSheafFor F ↔ (ofArrows (F.mapCone c) (F.map _)).IsSheafFor F := by
  rw [isSheafFor_iff_isSheafFor_presieve''''']
  have : (Discrete.functor (fun x ↦ op (F.mapObj X x))).obj ⟨i⟩ = (Discrete.functor (fun x ↦ op (X x))).obj ⟨i⟩ := by
    dsimp
    simp only [Functor.mapObj_obj, Functor.map_op]
  rw [isSheafFor_iff_isSheafFor_family, isSheafFor_iff_isSheafFor_family,
    isLimit_iff_isTerminal, isLimit_iff_isTerminal,
    isTerminal_iff_isEmpty, isTerminal_iff_isEmpty,
    isEmpty_iff, isEmpty_iff,
    ← Functor.isTerminal_map_iff F]
  rfl

theorem isSheafFor_iff_isSheafFor_presieve''''''' :
    (ofArrows X c.inj).IsSheafFor F �

Attempt failure.

Working on Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean - 2024-09-09 00:45:31.369411.
---59/200---
For theorem CategoryTheory.Pretriangulated.exists_iso_of_arrow_iso in Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean:
lemma exists_iso_of_arrow_iso (T₁ T₂ : Triangle C) (hT₁ : T₁ ∈ distTriang C)
    (hT₂ : T₂ ∈ distTriang C) (e : Arrow.mk T₁.mor₁ ≅ Arrow.mk T₂.mor₁) :
    ∃ (e' : T₁ ≅ T₂), e'.hom.hom₁ = e.hom.left ∧ e'.hom.hom₂ = e.hom.right 


Original valid proof:
:= by
  let φ := completeDistinguishedTriangleMorphism T₁ T₂ hT₁ hT₂ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso φ.hom₁ := by dsimp [φ]; infer_instance
  have : IsIso φ.hom₂ := by dsimp [φ]; infer_instance
  have : IsIso φ.hom₃ := isIso₃_of_isIso₁₂ φ hT₁ hT₂ inferInstance inferInstance
  have : IsIso φ := by
    apply Triangle.isIso_of_isIsos
    all_goals infer_instance
  exact ⟨asIso φ, by simp [φ], by simp [φ]⟩


Verifying proof (Commit afe025caf56711b57f2f34e9ae25ec16a609156d):
∧ e'.hom.hom₃ = e.hom.w.symm := by
  have hT₁' := exists_fac T₁ hT₁
  have hT₂' := exists_fac T₂ hT₂
  obtain ⟨Z, g₁, g₂, _, _, _, ⟨e'⟩⟩ :=
    Arrow.iso_struct_of_iso_naturality e.hom (Arrow.leftFunc.map T₁.mor₁)
      (Arrow.leftFunc.map T₂.mor₁)
  let e'' := isoMk e'.symm (Iso.refl _) (Iso.refl _)
  dsimp at e''
  refine' ⟨(binaryBiproductIsKernel _ _).uniqueUpToIso
    (binaryBiproductIsCokernel _ _) e''.symm (by simp) _, _, _⟩
  · simpa using e'.inv.1
  · simp
  · simpa using e'.inv.2.1

Repaired Proof:
lemma exists_iso_of_arrow_iso (T₁ T₂ : Triangle C) (hT₁ : T₁ ∈ distTriang C)
    (hT₂ : T₂ ∈ distTriang C) (e : Arrow.mk T₁.mor₁ ≅ Arrow.mk T₂.mor₁) :
    ∃ (e' : T₁ ≅ T₂), e'.hom.hom₁ = e.hom.left ∧ e'.hom.hom₂ = e.hom.right ∧ e'.hom.hom₃ = e.hom.w.symm := by
  have hT₁' := exists_fac T₁ hT₁
  have hT₂' := exists_fac T₂ hT₂
  obtain ⟨Z, g₁, g₂, _, _, _, ⟨e'⟩⟩ :=
    Arrow.iso_struct_of_iso_naturality e.hom (Arrow.leftFunc.map T₁.mor₁)
      (Arrow.leftFunc.map T₂.mor₁)
  let e'' := isoMk e'.symm (Iso.refl _) (Iso.refl _)
  dsimp at e''
  refine ⟨(binaryBiproductIsKernel _ _).uniqueUpToIso
    (binaryBiproductIsCokernel _ _) e''.symm (by simp) _, ?_, ?_⟩
  · simpa using e'.inv.1
  · simp
  · simpa using e'.inv.2.1

Repaired Proof:
lemma exists_iso_of_arrow_iso (T₁ T₂ : Triangle C) (hT₁ : T₁ ∈ distTriang C)
    (hT₂ : T₂ ∈ distTriang C) (e : Arrow.mk T₁.mor₁ ≅ Arrow.mk T₂.mor₁) :
    ∃ (e' : T₁ ≅ T₂), e'.hom.hom₁ = e.hom.left ∧ e'.hom.hom₂ = e.hom.right ∧ e'.hom.hom₃ = e.hom.w.symm := by
  have hT₁' := exists_fac T₁ hT₁
  have hT₂' := exists_fac T₂ hT₂
  obtain ⟨Z, g₁, g₂, _, _, _, ⟨e'⟩⟩ :=
    Arrow.iso_struct_of_iso_naturality e.hom (Arrow.leftFunc.map T₁.mor₁)
      (Arrow.leftFunc.map T₂.mor₁)
  let e'' := isoMk e'.symm (Iso.refl _) (Iso.refl _)
  dsimp at e''
  refine ⟨(binaryBiproductIsKernel _ _).uniqueUpToIso
    (binaryBiproductIsCokernel _ _) e''.symm (by simp) _, ?_, ?_⟩
  · simpa using e'.inv.1
  · simp
  · simpa using e'.inv.2.1

Repaired Proof:
lemma exists_iso_of_arrow_iso (T₁ T₂ : Triangle C) (hT₁ : T₁ ∈ distTriang C)
    (hT₂ : T₂ ∈ distTriang C) (e : Arrow.mk T₁.mor₁ ≅ Arrow.mk T₂.mor₁) :
    ∃ (e' : T₁ ≅ T₂), e'.hom.hom₁ = e.hom.left ∧ e'.hom.hom₂ = e.hom.right ∧ e'.hom.hom₃ = e.hom.w.symm := by
  have hT₁' := exists_fac T₁ hT₁
  have hT₂' := exists_fac T₂ hT₂
  obtain ⟨Z, g₁, g₂, _, _, _, ⟨e'⟩⟩ :=
    Arrow.iso_struct_of_iso_naturality e.hom (Arrow.leftFunc.map T₁.mor₁)
      (Arrow.leftFunc.map T₂.mor₁)
  let e'' := isoMk e'.symm (Iso.refl _) (Iso.refl _)
  dsimp at e''
  refine ⟨(binaryBiproductIsKernel _ _).uniqueUpToIso
    (binaryBiproductIsCokernel _ _) e''.symm (by simp) ?_ ?_ ?_⟩
  · simpa using e'.inv.1
  · simp
  · simpa using e'.inv.2.1

Repaired Proof:
lemma exists_iso_of_arrow_iso (T₁ T₂ : Triangle C) (hT₁ : T₁ ∈ distTriang C)
    (hT₂ : T₂ ∈ distTriang C) (e : Arrow.mk T₁.mor₁ ≅ Arrow.mk T₂.mor₁) :
    ∃ (e' : T₁ ≅ T₂), e'.hom.hom₁ = e.hom.left ∧ e'.hom.hom₂ = e.hom.right ∧ e'.hom.hom₃ = e.hom.w.symm := by
  have hT₁' := exists_fac T₁ hT₁
  have hT₂' := exists_fac T₂ hT₂
  obtain ⟨Z, g₁, g₂, _, _, _, ⟨e'⟩⟩ :=
    Arrow.iso_struct_of_iso_naturality e.hom (Arrow.leftFunc.map T₁.mor₁)
      (Arrow.leftFunc.map T₂.mor₁)
  let e'' := isoMk e'.symm (Iso.refl _) (Iso.refl _)
  dsimp at e''
  refine ⟨(binaryBiproductIsKernel _ _).uniqueUpToIso
    (binaryBiproductIsCokernel _ _) e''.symm (by simp) ?_ ?_ ?_⟩
  · simpa using e'.inv.1
  · simp
  · simpa using e'.inv.2.1

Repaired Proof:
lemma exists_iso_of_arrow_iso (T₁ T₂ : Triangle C) (hT₁ : T₁ ∈ distTriang C)
    (hT₂ : T₂ ∈ distTriang C) (e : Arrow.mk T₁.mor₁ ≅ Arrow.mk T₂.mor₁) :
    ∃ (e' : T₁ ≅ T₂), e'.hom.hom₁ = e.hom.left ∧ e'.hom.hom₂ = e.hom.right ∧ e'.hom.hom₃ = e.hom.w.symm := by
  have hT₁' := exists_fac T₁ hT₁
  have hT₂' := exists_fac T₂ hT₂
  obtain ⟨Z, g₁, g₂, _, _, _, ⟨e'⟩⟩ :=
    Arrow.iso_struct_of_iso_naturality e.hom (Arrow.leftFunc.map T₁.mor₁)
      (Arrow.leftFunc.map T₂.mor₁)
  let e'' := isoMk e'.symm (Iso.refl _) (Iso.refl _)
  dsimp at e''
  refine ⟨(binaryBiproductIsKernel _ _).uniqueUpToIso
    (binaryBiproductIsCokernel _ _) e''.symm (by simp) ?_ ?_ ?_⟩
  · simpa using e'.inv.1
  · simp
  · simpa using e

Attempt failure.

Working on Mathlib/Combinatorics/Additive/FreimanHom.lean - 2024-09-09 00:45:45.783227.
---60/200---
For theorem IsMulFreimanIso.prod in Mathlib/Combinatorics/Additive/FreimanHom.lean:
lemma IsMulFreimanIso.prod (h₁ : IsMulFreimanIso n A₁ B₁ f₁) (h₂ : IsMulFreimanIso n A₂ B₂ f₂) :
    IsMulFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where



Original valid proof:
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [mem_prod, forall_and, Prod.forall] at hsA htA
    simp only [Prod.ext_iff, fst_prod, map_map, Function.comp_apply, Prod.map_fst, snd_prod,
      Prod.map_snd]
    rw [← Function.comp_def, ← map_map, ← map_map, ← Function.comp_def f₂, ← map_map, ← map_map,
      h₁.map_prod_eq_map_prod (by simpa using hsA.1) (by simpa using htA.1) (by simpa) (by simpa),
      h₂.map_prod_eq_map_prod (by simpa [@forall_swap α₁] using hsA.2)
      (by simpa [@forall_swap α₁] using htA.2) (by simpa) (by simpa)]


Verifying proof (Commit 754ba19de1471fd928c4fa0cc102d1f06f90e902):
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [← image_prod, Prod.fst_map, Prod.snd_map, ← h₁.map_prod_eq_map_prod,
      ← h₂.map_prod_eq_map_prod]
    rfl

Repaired Proof:
lemma IsMulFreimanIso.prod (h₁ : IsMulFreimanIso n A₁ B₁ f₁) (h₂ : IsMulFreimanIso n A₂ B₂ f₂) :
    IsMulFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [← image_prod, Prod.fst_map, Prod.snd_map, ← h₁.map_prod_eq_map_prod hsA htA,
      ← h₂.map_prod_eq_map_prod hsA htA]
    rfl

Repaired Proof:
lemma IsAddFreimanIso.prod (h₁ : IsAddFreimanIso n A₁ B₁ f₁) (h₂ : IsAddFreimanIso n A₂ B₂ f₂) :
    IsAddFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [← image_prod, Prod.fst_map, Prod.snd_map, ← h₁.map_prod_eq_map_prod hsA htA,
      ← h₂.map_prod_eq_map_prod hsA htA]
    rfl

Repaired Proof:
lemma IsMulFreimanIso.prod (h₁ : IsMulFreimanIso n A₁ B₁ f₁) (h₂ : IsMulFreimanIso n A₂ B₂ f₂) :
    IsMulFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [← image_prod, Prod.fst_map, Prod.snd_map, ← h₁.map_prod_eq_map_prod hsA htA,
      ← h₂.map_prod_eq_map_prod hsA htA]
    rfl

Repaired Proof:
lemma IsAddFreimanIso.prod (h₁ : IsAddFreimanIso n A₁ B₁ f₁) (h₂ : IsAddFreimanIso n A₂ B₂ f₂) :
    IsAddFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [← image_prod, Prod.fst_map, Prod.snd_map, ← h₁.map_prod_eq_map_prod hsA htA,
      ← h₂.map_prod_eq_map_prod hsA htA]
    rfl

Repaired Proof:
lemma IsMulFreimanIso.prod (h₁ : IsMulFreimanIso n A₁ B₁ f₁) (h₂ : IsMulFreimanIso n A₂ B₂ f₂) :
    IsMulFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [← image_prod, Prod.fst_map, Prod.snd_map, ← h₁.map_prod_eq_map_prod hsA htA,
      ← h₂.map_prod_eq_map_prod hsA htA]
    rfl

Repaired Proof:
lemma IsAddFreimanIso.prod (h₁ : IsAddFreimanIso n A₁ B₁ f₁) (h₂ : IsAddFreimanIso n A₂ B₂ f₂) :
    IsAddFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [← image_prod, Prod.fst_map, Prod.snd_map, ← h₁.map_prod_eq_map_prod hsA htA,
      ← h₂.map_prod_eq_map_prod hsA htA]
    rfl

Repaired Proof:
lemma IsMulFreimanIso.prod (h₁ : IsMulFreimanIso n A₁ B₁ f₁) (h₂ : IsMulFreimanIso n A₂ B₂ f₂) :
    IsMulFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [← image_prod, Prod.fst_map, Prod.snd_map, ← h₁.map_prod_eq_map_prod hsA htA,
      ← h₂.map_prod_eq_map_prod hsA htA]
    rfl

Repaired Proof:
lemma IsAddFreimanIso.prod (h₁ : IsAddFreimanIso n A₁ B₁ f₁) (h₂ : IsAddFreimanIso n A₂ B₂ f₂) :
    IsAddFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [← image_prod, Prod.fst_map, Prod.snd_map, ← h₁.map_prod_eq_map_prod hsA htA,
      ← h₂.map_prod_eq_map_prod hsA htA]
    rfl

Repaired Proof:
lemma IsMulFreimanIso.prod (h₁ : IsMulFreimanIso n A₁ B₁ f₁) (h₂ : IsMulFreimanIso n A₂ B₂ f₂) :
    IsMulFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [← image_prod, Prod.fst_map, Prod.snd_map, ← h₁.map_prod_eq_map_prod hsA htA,
      ← h₂.map_prod_eq_map_prod hsA htA]
    rfl

Repaired Proof:
lemma IsAddFreimanIso.prod (h₁ : IsAddFreimanIso n A₁ B₁ f₁) (h₂ : IsAddFreimanIso n A₂ B₂ f₂) :
    IsAddFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where
  bijOn := h₁.bijOn.prodMap h₂.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [← image_prod, Prod.fst_map, Prod.snd_map, ← h₁.map_prod_eq_map_prod hsA htA,
      ← h₂.map_prod_eq_map_prod hsA htA]
    rfl

Repaired Proof:
lemma IsMulFreimanIso.prod (h₁

Attempt failure.

Working on Mathlib/Combinatorics/HalesJewett.lean - 2024-09-09 00:45:58.345306.
---61/200---
For theorem Combinatorics.Line.exists_mono_in_high_dimension in Mathlib/Combinatorics/HalesJewett.lean:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C 


Original valid proof:
:=
  Finite.induction_empty_option
  (
  fun {α α'} e =>
    forall_imp fun κ =>
      forall_imp fun _ =>
        Exists.imp fun ι =>
          Exists.imp fun _ h C =>
            let ⟨l, c, lc⟩ := h fun v => C (e ∘ v)
            ⟨l.map e, c, e.forall_congr_right.mp fun x => by rw [← lc x, Line.map_apply]⟩)
  (by
    intro κ _
    by_cases h : Nonempty κ
    · refine ⟨Unit, inferInstance, fun C => ⟨default, Classical.arbitrary _, PEmpty.rec⟩⟩
    · exact ⟨Empty, inferInstance, fun C => (h ⟨C (Empty.rec)⟩).elim⟩)
  (by
    intro α _ ihα κ _
    cases nonempty_fintype κ
    by_cases h : Nonempty α
    case neg =>
      refine ⟨Unit, inferInstance, fun C => ⟨diagonal _ Unit, C fun _ => none, ?_⟩⟩
      rintro (_ | ⟨a⟩)
      · rfl
      · exact (h ⟨a⟩).elim
    suffices key :
      ∀ r : ℕ,
        ∃ (ι : Type) (_ : Fintype ι),
          ∀ C : (ι → Option α) → κ,
            (∃ s : ColorFocused C, Multiset.card s.lines = r) ∨ ∃ l, IsMono C l by
      obtain ⟨ι, _inst, hι⟩ := key (Fintype.card κ + 1)
      refine ⟨ι, _inst, fun C => (hι C).resolve_left ?_⟩
      rintro ⟨s, sr⟩
      apply Nat.not_succ_le_self (Fintype.card κ)
      rw [← Nat.add_one, ← sr, ← Multiset.card_map, ← Finset.card_mk]
      exact Finset.card_le_univ ⟨_, s.distinct_colors⟩
    intro r
    induction' r with r ihr
    · exact ⟨Empty, inferInstance, fun C => Or.inl ⟨default, Multiset.card_zero⟩⟩
    obtain ⟨ι, _inst, hι⟩ := ihr
    specialize ihα ((ι → Option α) → κ)
    obtain ⟨ι', _inst, hι'⟩ := ihα
    refine ⟨Sum ι ι', inferInstance, ?_⟩
    intro C
    specialize hι' fun v' v => C (Sum.elim v (some ∘ v'))
    obtain ⟨l', C', hl'⟩ := hι'
    have mono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l := by
      rintro ⟨l, c, hl⟩
      refine ⟨l.horizontal (some ∘ l' (Classical.arbitrary α)), c, fun x => ?_⟩
      rw [Line.horizontal_apply, ← hl, ← hl']
    specialize hι C'
    rcases hι with (⟨s, sr⟩ | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : ∃ p ∈ s.lines, (p : AlmostMono _).color = C' s.focus
    · obtain ⟨p, p_mem, hp⟩ := h
      refine Or.inr (mono_of_mono ⟨p.line, p.color, ?_⟩)
      rintro (_ | _)
      · rw [hp, s.is_focused p p_mem]
      · apply p.has_color
    refine Or.inl ⟨⟨(s.lines.map ?_).cons ⟨(l'.map some).vertical s.focus, C' s.focus, fun x => ?_⟩,
            Sum.elim s.focus (l'.map some none), ?_, ?_⟩, ?_⟩
    · refine fun p => ⟨p.line.prod (l'.map some), p.color, fun x => ?_⟩
      rw [Line.prod_apply, Line.map_apply, ← p.has_color, ← congr_fun (hl' x)]
    · rw [vertical_apply, ← congr_fun (hl' x), Line.map_apply]
    · simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | ⟨q, hq, rfl⟩)
      · simp only [vertical_apply]
      · simp only [prod_apply, s.is_focused q hq]
    · rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact ⟨fun ⟨q, hq, he⟩ => h ⟨q, hq, he⟩, s.distinct_colors⟩
    · rw [Multiset.card_cons, Multiset.card_map, sr])


Verifying proof (Commit 65f7857d510e130142dbb111786341d695ac399b):
∧ l.IsHigh
  | α, _, κ, _ => by
    obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin (α → κ)
    let e' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let e'' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let C' : (Fin n → α) → κ := fun f ↦ C (e'.symm f)
    obtain ⟨l, hl₁, hl₂⟩ := exists_mono_in_high_dimension C'
    refine' ⟨{ s := e'.symm l.s
            mono := fun f g hfg ↦ _
            high := fun f ↦ _ }, _, _⟩
    · exact hl₁ _ _ (e'.apply_symm_apply _)
    · exact hl₂ _
    · infer_instance
    · intro C
      refine' ⟨l, ⟨fun f g hfg ↦ _, fun f ↦ _⟩, rfl⟩
      · exact hl₁ _ _ (e'.apply_symm_apply _)
      · exact hl₂ _

Repaired Proof:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C ∧ l.IsHigh
  | α, _, κ, _ => by
    obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin (α → κ)
    let e' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let e'' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let C' : (Fin n → α) → κ := fun f ↦ C (e'.symm f)
    obtain ⟨l, hl₁, hl₂⟩ := exists_mono_in_high_dimension C'
    refine ⟨{ s := e'.symm l.s
            mono := fun f g hfg ↦ ?_
            high := fun f ↦ ?_ }, inferInstance, ?_⟩
    · exact hl₁ _ _ (e'.apply_symm_apply _)
    · exact hl₂ _
    · intro C
      refine ⟨l, ⟨fun f g hfg ↦ ?_, fun f ↦ ?_⟩, rfl⟩
      · exact hl₁ _ _ (e'.apply_symm_apply _)
      · exact hl₂ _

Repaired Proof:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C ∧ l.IsHigh
  | α, _, κ, _ => by
    obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin (α → κ)
    let e' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let e'' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let C' : (Fin n → α) → κ := fun f ↦ C (e'.symm f)
    obtain ⟨l, hl₁, hl₂⟩ := exists_mono_in_high_dimension C'
    refine ⟨{ s := e'.symm l.s
            mono := fun f g hfg ↦ ?_
            high := fun f ↦ ?_ }, inferInstance, ?_⟩
    · exact hl₁ _ _ (e'.apply_symm_apply _)
    · exact hl₂ _
    · intro C
      refine ⟨l, ⟨fun f g hfg ↦ ?_, fun f ↦ ?_⟩, rfl⟩
      · exact hl₁ _ _ (e'.apply_symm_apply _)
      · exact hl₂ _

Repaired Proof:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C ∧ l.IsHigh
  | α, _, κ, _ => by
    obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin (α → κ)
    let e' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let e'' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equ

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/LYM.lean - 2024-09-09 00:46:05.241420.
---62/200---
For theorem Finset.card_div_choose_le_card_shadow_div_choose in Mathlib/Combinatorics/SetFamily/LYM.lean:
theorem card_div_choose_le_card_shadow_div_choose (hr : r ≠ 0)
    (h𝒜 : (𝒜 : Set (Finset α)).Sized r) : (𝒜.card : 𝕜) / (Fintype.card α).choose r
    ≤ (∂ 𝒜).card / (Fintype.card α).choose (r - 1) 


Original valid proof:
:= by
  obtain hr' | hr' := lt_or_le (Fintype.card α) r
  · rw [choose_eq_zero_of_lt hr', cast_zero, div_zero]
    exact div_nonneg (cast_nonneg _) (cast_nonneg _)
  replace h𝒜 := card_mul_le_card_shadow_mul h𝒜
  rw [div_le_div_iff] <;> norm_cast
  · cases' r with r
    · exact (hr rfl).elim
    rw [tsub_add_eq_add_tsub hr', add_tsub_add_eq_tsub_right] at h𝒜
    apply le_of_mul_le_mul_right _ (pos_iff_ne_zero.2 hr)
    convert Nat.mul_le_mul_right ((Fintype.card α).choose r) h𝒜 using 1
    · simp [mul_assoc, Nat.choose_succ_right_eq]
      exact Or.inl (mul_comm _ _)
    · simp only [mul_assoc, choose_succ_right_eq, mul_eq_mul_left_iff]
      exact Or.inl (mul_comm _ _)
  · exact Nat.choose_pos hr'
  · exact Nat.choose_pos (r.pred_le.trans hr')


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  rw [div_le_div_iff]
  · have h𝒜' : (𝒜 : Set (Finset α)).Sized (r - 1) := by
      rintro s hs
      obtain ⟨s, hs, rfl⟩ := exists_sdiff_mem_of_exists_mem_sdiff hs
      rw [card_sdiff (mem_shadow_iff.1 hs).1, tsub_tsub_cancel_of_le (h𝒜 s hs)]
    rw [← card_sdiff (shadow_subset (s := 𝒜)),
      card_doubleton (exists_mem_sdiff_of_mem_sdiff (mem_shadow_iff.1 hs).1).symm,
      cast_sub (card_le_card (shadow_subset (s := 𝒜))),
      cast_sub (card_le_card (shadow_subset (s := 𝒜)))]
    apply mul_le_mul_of_nonneg_right
    · rw [← card_sdiff (shadow_subset (s := 𝒜)),
        card_doubleton (exists_mem_sdiff_of_mem_sdiff (mem_shadow_iff.1 hs).1).symm,
        cast_sub (card_le_card (shadow_subset (s := 𝒜)))]
      exact h𝒜' _ hs
    · exact cast_nonneg _
  · exact cast_pos.2 (choose_pos (card_le_card (shadow_subset (s := 𝒜))))
  · exact cast_pos.2 (choose_pos (card_le_card (shadow_subset (s := 𝒜))))

Repaired Proof:
theorem card_div_choose_le_card_shadow_div_choose (hr : r ≠ 0)
    (h𝒜 : (𝒜 : Set (Finset α)).Sized r) : (𝒜.card : 𝕜) / (Fintype.card α).choose r
    ≤ (∂ 𝒜).card / (Fintype.card α).choose (r - 1)  := by
  rw [div_le_div_iff]
  · have h𝒜' : (𝒜 : Set (Finset α)).Sized (r - 1) := by
      rintro s hs
      obtain ⟨s, hs, rfl⟩ := exists_sdiff_mem_of_exists_mem_sdiff hs
      rw [card_sdiff (mem_shadow_iff.1 hs).1, tsub_tsub_cancel_of_le (h𝒜 s hs)]
    rw [← card_sdiff (shadow_subset (s := 𝒜)),
      card_doubleton (exists_mem_sdiff_of_mem_sdiff (mem_shadow_iff.1 hs).1).symm,
      cast_sub (card_le_card (shadow_subset (s := 𝒜))),
      cast_sub (card_le_card (shadow_subset (s := 𝒜)))]
    apply mul_le_mul_of_nonneg_right
    · rw [← card_sdiff (shadow_subset (s := 𝒜)),
        card_doubleton (exists_mem_sdiff_of_mem_sdiff (mem_shadow_iff.1 hs).1).symm,
        cast_sub (card_le_card (shadow_subset (s := 𝒜)))]
      exact h𝒜' _ hs
    · exact cast_nonneg _
  · exact cast_pos.2 (choose_pos (card_le_card (shadow_subset (s := 𝒜))))
  · exact cast_pos.2 (choose_pos (card_le_card (shadow_subset (s := 𝒜))))

Repaired Proof:
theorem card_div_choose_le_card_shadow_div_choose (hr : r ≠ 0)
    (h𝒜 : (𝒜 : Set (Finset α)).Sized r) : (𝒜.card : 𝕜) / (Fintype.card α).choose r
    ≤ (∂ 𝒜).card / (Fintype.card α).choose (r - 1)  := by
  rw [div_le_div_iff]
  · have h𝒜' : (𝒜 : Set (Finset α)).Sized (r - 1) := by
      rintro s hs
      obtain ⟨s, hs, rfl⟩ := exists_sdiff_mem_of_exists_mem_sdiff hs
      rw [card_sdiff (mem_shadow_iff.1 hs).1, tsub_tsub_cancel_of_le (h𝒜 s hs)]
    rw [← card_sdiff (shadow_subset (s := 𝒜)),
      card_doubleton (exists_mem_sdiff_of_mem_sdiff (mem_shadow_iff.1 hs).1).symm,
      cast_sub (card_le_card (shadow_subset (s := 𝒜))),
      cast_sub (card_le_card (shadow_subset (s := 𝒜)))]
    apply mul_le_mul_of_nonneg_right
    · rw [← card_sdiff (shadow_subset (s := 𝒜)),
        card_doubleton (exists_mem_sdiff_of_mem_sdiff (mem_shadow_iff.1 hs).1).symm,
        cast_sub (card_le_card (shadow_subset (s := 𝒜)))]
      exact h𝒜' _ hs
    · exact cast_nonneg _
  · exact cast_pos.2 (choose_pos (card_le_card (shadow_subset (s := 𝒜))))
  · exact cast_pos.2 (choose_pos (card_le_card (shadow_subset (s := 𝒜))))

Repaired Proof:
theorem card_div_choose_le_card_shadow_div_choose (hr : r ≠ 0)
    (h𝒜 : (𝒜 : Set (Finset α)).Sized r) : (𝒜.card : 𝕜) / (Fintype.card α).choose r
    ≤ (∂ 𝒜).card / (Fintype.card α).choose (r - 1)  := by
  rw [div_le_div_iff]
  · have h𝒜' : (𝒜 : Set (Finset α)).Sized (r - 1) := by
      rintro s hs
      obtain ⟨s, hs, rfl⟩ := exists_sdiff_mem_of_exists_mem_sdiff hs
      rw [card_sdiff (mem_shadow_iff.1 hs).1, tsub_tsub_cancel_of_le (h𝒜 s hs)]
    rw [← card_sdiff (shadow_subset (s := 𝒜)),
      card_doubleton (exists_mem_sdiff_of_mem_sdiff (mem_shadow_iff.1 hs).1).symm,
      cast_sub (card_le_card (shadow_subset (s := 𝒜))),
      cast_sub (card_le_card (shadow_subset (s := 𝒜)))]
    apply mul_le_mul_of_nonneg_right
    · rw [← card_sdiff (shadow_subset (s := 𝒜)),
        card_doubleton (exists_mem_sdiff_of_mem_sdiff (mem_shadow_iff.1 hs).1).symm,
        cast_sub (card_le_card (shadow_subset (s := 𝒜)))]
      exact h𝒜' _ hs
    · exact cast_nonneg _
  · exact cast_pos.2 (choose_pos (card_le_card (shadow_subset (s := 𝒜))))
  · exact cast_pos.2 (choose_pos (card_le_card (shadow_subset (s := 𝒜))))

Repaired Proof:
theorem card_div_choose_le_card_shadow_div_choose (hr : r ≠ 0)
    (h𝒜 : (𝒜 : Set (Finset α)).Sized r) : (𝒜.card : 𝕜) / (Fintype.card α).choose r
    ≤ (∂ 𝒜).card / (Fintype.card α).choose (r - 1)  := by
  rw [div_le_div_iff]
  · have h𝒜' : (𝒜 : Set (Finset α)).Sized (r - 1) := by
      rintro s hs
      obtain ⟨s, hs, rfl⟩ := exists_sdiff_mem_of_exists_mem_sdiff hs
      rw [card_sdiff (mem_shadow_iff.1 hs).1, tsub_tsub_cancel_of_le (h𝒜 s hs)]


Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean - 2024-09-09 00:46:13.518646.
---63/200---
For theorem SimpleGraph.adjMatrix_mul_self_apply_self in Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean:
theorem adjMatrix_mul_self_apply_self [NonAssocSemiring α] (i : V) :
    (G.adjMatrix α * G.adjMatrix α) i i = degree G i 


Original valid proof:
:= by simp [filter_true_of_mem]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
• star (degree G i) := by
  simp [filter_true_of_mem (mem_univ (G.neighborFinset i))]


theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = G.degree i * a := by
  simp [mulVec, dotProduct, mul_comm]


theorem adjMatrix_mulVec_const_apply_of_regular [NonAssocSemiring α] {d : ℕ} (hd : 2 * d = G.IsRegularOfDegree d) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = d * a := by
  rw [← hd, two_mul, add_mul, add_tsub_cancel_left, G.adjMatrix_mulVec_const_apply,
    tsub_add_cancel_of_le (G.IsRegularOfDegree.degree_le i)]


theorem adjMatrix_mulVec_const_apply_of_regular' [NonAssocSemiring α] {d : ℕ}
    (hd : 2 * d = Fintype.card V) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = d * a := by
  rw [← hd, two_mul, add_mul, add_tsub_cancel_left, G.adjMatrix_mulVec_const_apply,
    tsub_add_cancel_of_le (le_trans (G.IsRegularOfDegree.degree_le i)
    (hd.symm ▸ Fintype.card_le_of_injective _ G.injective_default))]


theorem adjMatrix_mulVec_const_apply_of_regular [NonAssocSemiring α] [Fintype V]
    (hd : 2 * Fintype.card V / 2 = Fintype.card V / 2) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = Fintype.card V / 2 * a := by
  rw [← hd, two_mul, add_mul, add_tsub_cancel_left, G.adjMatrix_mulVec_const_apply,
    tsub_add_cancel_of_le (le_of_eq <| G.IsRegularOfDegree.degree_eq_div_two_of_regular hd)]


theorem adjMatrix_mulVec_const_apply_of_regular' [NonAssocSemiring α] [Fintype V]
    (hd : 2 * Fintype.card V / 2 = Fintype.card V) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = Fintype.card V / 2 * a := by
  rw [← hd, two_mul, add_mul, add_tsub_cancel_left, G.adjMatrix_mulVec_const_apply,
    tsub_add_cancel_of_le (le_of_eq <| G.IsRegularOfDegree.degree_eq_div_two_of_regular hd)]


theorem adjMatrix_mulVec_const_apply_of_regular [NonAssocSemiring α] [Fintype V]
    (hd : 2 * Fintype.card V = Fintype.card V) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = Fintype.card V / 2 * a := by
  rw [← hd, two_mul, add_mul, add_tsub_cancel_left, G.adjMatrix_mulVec_const_apply,
    tsub_add_cancel_of_le (le_of_eq <| G.IsRegularOfDegree.degree_eq_div_two_of_regular hd)]


theorem adjMatrix_mulVec_const_apply_of_regular' [NonAssocSemiring α] [Fintype V]
    (hd : 2 * Fintype.card V = Fintype.card V + Fintype.card V) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = Fintype.card V / 2 * a := by
  rw [← hd, two_mul, add_mul, add_tsub_cancel_left, G.adjMatrix_mulVec_const_apply,
    tsub_add_cancel_of_le (le_of_eq <| G.IsRegularOfDegree.degree_eq_div_two_of_regular hd)]


theorem adjMatrix_mulVec_const_apply_of_regular [NonAssocSemiring α] [Fintype V]
    (hd : 2 * Fintype.card V = Fintype.card V + Fintype.card V) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = Fintype.card V / 2 * a := by
  rw [← hd, two_mul, add_mul, add_tsub_cancel_left, G.adjMatrix_mulVec_const_apply,
    tsub_add_cancel_of_le (le_of_eq <| G.IsRegularOfDegree.degree_eq_div_two_of_regular hd)]


theorem adjMatrix_mulVec_const_apply_of_regular' [NonAssocSemiring α] [Fintype V]
    (hd : 2 * Fintype.card V = Fintype.card V + Fintype.card V) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = Fintype.card V / 2 * a := by
  rw [← hd, two_mul, add_mul, add_tsub_cancel_left, G.adjMatrix_mulVec_const_apply,
    tsub_add_cancel_of_le (le_of_eq <| G.IsRegularOfDegree.degree_eq_div_two_of_regular hd)]


theorem adjMatrix_mulVec_const_apply_of_regular [NonAssocSemiring α] [Fintype V]
    (hd : 2 * Fintype.card V = Fintype.card V + Fintype.card V) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = Fintype.card V / 2 * a := by
  rw [← hd, two_mul, add_mul, add_tsub_cancel_left, G.adjMatrix_mulVec_const_apply,
    tsub_add_cancel_of_le (le_of_eq <| G.IsRegularOfDegree.degree_eq_div_two_of_regular hd)]


theorem adjMatrix_mulVec_const_apply_of_regular' [NonAssocSemiring α] [Fintype V]
    (hd : 2 * Fintype.card V = Fintype.card V + Fintype.card V) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = Fintype.card V / 2 * a := by
  rw [← hd, two_mul, add_mul, add_tsub_cancel_left, G.adjMatrix_mulVec_const_apply,
    tsub_add_cancel_of_le (le_of_eq <| G.IsRegularOfDegree.degree_eq_div_two_of_regular hd)]


theorem adjMatrix_mulVec_const_apply_of_regular [NonAssocSemiring α] [Fintype V]
    (hd : 2 * Fintype.card V = Fintype.card V + Fintype.card V) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = Fintype.card V / 2 * a := by
  rw [← hd, two_mul, add_mul, add_tsub_cancel_left, G.adjMatrix_mulVec_const_apply,
    tsub_add_cancel_of_le (le_of_eq <| G.IsRegularOfDegree.degree_eq_div_two_of_regular hd)]


theorem adjMatrix_mulVec_const_apply_of_regular' [NonAssocSemiring α] [Fintype V]
    (hd : 2 * Fintype.card V = Fintype.card V + Fintype.card V) (i : V) (a : α) :
    (G.adjMatrix α *ᵥ Function.const _ a) i = Fintype.card V / 2 * a := by
  rw [← hd, two_mul, add_mul, add_tsub_

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Coloring.lean - 2024-09-09 00:46:23.916132.
---64/200---
For theorem SimpleGraph.chromaticNumber_pos in Mathlib/Combinatorics/SimpleGraph/Coloring.lean:
theorem chromaticNumber_pos [Nonempty V] {n : ℕ} (hc : G.Colorable n) : 0 < G.chromaticNumber 


Original valid proof:
:= by
  rw [hc.chromaticNumber_eq_sInf, Nat.cast_pos]
  apply le_csInf (colorable_set_nonempty_of_colorable hc)
  intro m hm
  by_contra h'
  simp only [not_le] at h'
  obtain ⟨i, hi⟩ := hm.some (Classical.arbitrary V)
  have h₁: i < 0 := lt_of_lt_of_le hi (Nat.le_of_lt_succ h')
  exact Nat.not_lt_zero _ h₁


Verifying proof (Commit a645d903a5e02e8cbb9215f6195147610bf99954):
↔ n ≠ 0 := by
    have hn : 0 < n ↔ n ≠ 0 := pos_iff_ne_zero
    refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
    · rwa [hc.chromaticNumber_eq_sInf, Nat.sInf_def, Nat.find_eq_iff, dif_pos, ← hn] at h
      exact ⟨hc, fun m hm ↦ hm.2.1⟩
    · rwa [hc.chromaticNumber_eq_sInf, Nat.sInf_def, Nat.find_eq_iff, dif_pos, ← hn]
      exact ⟨h, fun m hm ↦ hm.2.1⟩

Repaired Proof:
theorem chromaticNumber_pos [Nonempty V] {n : ℕ} (hc : G.Colorable n) : 0 < G.chromaticNumber ↔ n ≠ 0 := by
    have hn : 0 < n ↔ n ≠ 0 := pos_iff_ne_zero
    refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
    · rwa [hc.chromaticNumber_eq_sInf, Nat.sInf_def, Nat.find_eq_iff, dif_pos, ← hn] at h
      exact ⟨hc, fun m hm ↦ hm.2.1⟩
    · rwa [hc.chromaticNumber_eq_sInf, Nat.sInf_def, Nat.find_eq_iff, dif_pos, ← hn]
      exact ⟨h, fun m hm ↦ hm.2.1⟩

Repaired Proof:
theorem chromaticNumber_ne_zero [Nonempty V] {n : ℕ} (hc : G.Colorable n) : G.chromaticNumber ≠ 0 := by
  simp only [hc.chromaticNumber_eq_sInf, Ne, Nat.sInf_eq_zero, not_or, not_forall,
    exists_prop, chromaticNumber_pos]
  exact ⟨_, hc, zero_lt_one⟩

Repaired Proof:
theorem chromaticNumber_ne_zero [Nonempty V] {n : ℕ} (hc : G.Colorable n) : G.chromaticNumber ≠ 0 := by
  simp only [hc.chromaticNumber_eq_sInf, Ne, Nat.sInf_eq_zero, not_or, not_forall,
    exists_prop, chromaticNumber_pos]
  exact ⟨_, hc, zero_lt_one⟩

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Operations.lean - 2024-09-09 00:46:33.276540.
---65/200---
For theorem SimpleGraph.adj_replaceVertex_iff_of_ne in Mathlib/Combinatorics/SimpleGraph/Operations.lean:
lemma adj_replaceVertex_iff_of_ne_left {w : V} (hw : w ≠ t) :
    (G.replaceVertex s t).Adj s w ↔ G.Adj s w 


Original valid proof:
:= by simp [replaceVertex, hw]


Verifying proof (Commit f61a485edf966de0b09bd70c1edc7f254cd1b0ae):
∧ w ≠ s := by
  simp only [replaceVertex_adj, hw, and_true, false_and, or_false]

lemma adj_replaceVertex_iff_of_ne_right {w : V} (hw : w ≠ t) :
    (G.replaceVertex s t).Adj w t ↔ G.Adj w t ∧ w ≠ s := by
  simp only [replaceVertex_adj, hw, and_true, false_and, or_false]

lemma adj_replaceVertex_iff_of_ne {v w : V} (hv : v ≠ t) (hw : w ≠ t) :
    (G.replaceVertex s t).Adj v w ↔ G.Adj v w := by
  simp only [replaceVertex_adj, hv, hw, and_true, true_and, false_and, or_false]

lemma edgeSet_replaceVertex_of_ne (h : s ≠ t) : (G.replaceVertex s t).edgeSet = G.edgeSet \ {s(s)} ∪ {s(t), t(s)} := by
  ext e; refine e.inductionOn ?_ ?_ <;> simp [h, symm_adj]

lemma edgeSet_replaceVertex_of_eq : (G.replaceVertex s s).edgeSet = G.edgeSet \ {s(s)} := by
  ext e; refine e.inductionOn ?_ ?_ <;> simp [symm_adj]

@[simp] lemma edgeSet_replaceVertex_of_not_adj (h : ¬ G.Adj s s) : (G.replaceVertex s s).edgeSet = G.edgeSet \ {s(s)} := by
  simp [edgeSet_replaceVertex_of_eq, h]

@[simp] lemma loopless_replaceVertex_iff : (G.replaceVertex s t).Loopless ↔ G.Loopless := by
  by_cases h : s = t
  · rw [h, replaceVertex_same]
    simp
  rw [loopless_iff, loopless_iff, ← edgeSet_replaceVertex_of_ne h, Set.disjoint_iff]
  simp

@[simp] lemma isNCard_replaceVertex_of_ne (h : s ≠ t) : (G.replaceVertex s t).IsNCard n ↔ G.IsNCard n := by
  simp [IsNCard, h]

@[simp] lemma isNCard_replaceVertex_of_eq : (G.replaceVertex s s).IsNCard n ↔ G.IsNCard n := by
  by_cases h : G.Adj s s
  · simp [h, not_isNCard_of_loopless]
  simp [h, IsNCard, ← card_edgeSet_replaceVertex_of_eq]

@[simp] lemma isNCard_iff_replaceVertex_eq : G.IsNCard n ↔ (G.replaceVertex s t).IsNCard n := by
  by_cases h : s = t
  · simp [h]
  by_cases h' : G.Adj s t
  · simp [h, h']
  simp [h, h', IsNCard, ← card_edgeSet_replaceVertex_of_ne h]

@[simp] lemma isNCard_iff_replaceVertex_eq' : (G.replaceVertex s t).IsNCard n ↔ G.IsNCard n :=
  (isNCard_iff_replaceVertex_eq t s).symm.trans <| by simp

@[simp] lemma isNCard_iff_replaceVertex_eq_and_not_adj :
    G.IsNCard n ↔ (G.replaceVertex s t).IsNCard n ∧ ¬(G.replaceVertex s t).Adj s t := by
  by_cases h : s = t
  · simp [h]
  by_cases h' : G.Adj s t
  · simp [h, h']
  simp [h, h', IsNCard, ← card_edgeSet_replaceVertex_of_ne h]

@[simp] lemma isNCard_iff_replaceVertex_eq_and_not_adj' :
    (G.replaceVertex s t).IsNCard n ↔ G.IsNCard n ∧ ¬(G.replaceVertex s t).Adj s t :=
  (isNCard_iff_replaceVertex_eq_and_not_adj t s).symm.trans <| by simp

@[simp] lemma isNCard_iff_replaceVertex_eq_and_adj :
    G.IsNCard n ↔ (G.replaceVertex s t).IsNCard (n + 1) ∧ (G.replaceVertex s t).Adj s t := by
  by_cases h : s = t
  · simp [h]
  by_cases h' : G.Adj s t
  · simp [h, h', IsNCard, ← card_edgeSet_replaceVertex_of_ne h]
  simp [h, h', IsNCard, ← card_edgeSet_replaceVertex_of_ne h]

@[simp] lemma isNCard_iff_replaceVertex_eq_and_adj' :
    (G.replaceVertex s t).IsNCard (n + 1) ↔ G.IsNCard n ∧ (G.replaceVertex s t).Adj s t :=
  (isNCard_iff_replaceVertex_eq_and_adj t s).symm.trans <| by simp

@[simp] lemma isNCard_iff_replaceVertex_eq_and_not_adj_of_ne (h : s ≠ t) :
    G.IsNCard n ↔ (G.replaceVertex s t).IsNCard n ∧ ¬(G.replaceVertex s t).Adj s t := by
  by_cases h' : G.Adj s t
  · simp [h, h']
  simp [h, h', IsNCard, ← card_edgeSet_replaceVertex_of_ne h]

@[simp] lemma isNCard_iff_replaceVertex_eq_and_not_adj_of_ne' (h : s ≠ t) :
    (G.replaceVertex s t).IsNCard n ↔ G.IsNCard n ∧ ¬(G.replaceVertex s t).Adj s t :=
  (isNCard_iff_replaceVertex_eq_and_not_adj_of_ne t s h).symm.trans <| by simp

@[simp] lemma isNCard_iff_replaceVertex_eq_and_adj_of_ne (h : s ≠ t) :
    G.IsNCard n ↔ (G.replaceVertex s t).IsNCard (n + 1) ∧ (G.replaceVertex s t).Adj s t := by
  by_cases h' : G.Adj s t
  · simp [h, h']
  simp [h, h', IsNCard, ← card_edgeSet_replaceVertex_of_ne h]

@[simp] lemma isNCard_iff_replaceVertex_eq_and_adj_of_ne' (h : s ≠ t) :
    (G.replaceVertex s t).IsNCard (n + 1) ↔ G.IsNCard n ∧ (G.replaceVertex s t).Adj s t :=
  (isNCard_iff_replaceVertex_eq_and_adj_of_ne t s h).symm.trans <| by simp

lemma isNCard_iff_replaceVertex_eq_and_not_adj_of_not_adj (h : ¬ G.Adj s t) :
    G.IsNCard n ↔ (G.replaceVertex s t).IsNCard n := by
  by_cases h' : s = t
  · simp [h']
  simp [h, h', IsNCard, ← card_edgeSet_replaceVertex_of_ne h']

lemma isNCard_iff_replaceVertex_eq_and_not_adj_of_not_adj' (h : ¬ G.Adj s t) :
    (G.replaceVertex s t).IsNCard n ↔ G.IsNCard n :=
  (isNCard_iff_replaceVertex_eq_and_not_adj_of_not_adj t s h).symm.trans <| by simp

lemma isNCard_iff_replaceVertex_eq_and_adj_of_not_adj (h : ¬ G.Adj s t) :
    G.IsNCard n ↔ (G.replaceVertex s t).IsNCard (n + 1) := by
  by_cases h' : s = t
  · simp [h']
  simp [h, h', IsNCard, ← card_edgeSet_replaceVertex_of_ne h']

lemma isNCard_iff_replaceVertex_eq_and_adj_of

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean - 2024-09-09 00:46:42.170526.
---66/200---
For theorem Finpartition.equitabilise_aux in Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    ∃ Q : Finpartition s,
      (∀ x : Finset α, x ∈ Q.parts → x.card = m ∨ x.card = m + 1) ∧
        (∀ x, x ∈ P.parts → (x \ (Q.parts.filter fun y => y ⊆ x).biUnion id).card ≤ m) ∧
          (Q.parts.filter fun i => card i = m + 1).card = b 


Original valid proof:
:= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  · refine ⟨⊥, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symm⟩
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      ⟨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _⟩
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 ∧ b = 0
  · simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (α := Finpartition ⊥) P
    exact ⟨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]⟩
  simp_rw [not_and_or, ← Ne.eq_def, ← pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain ⟨hn₀, hn₁, hn₂, hn₃⟩ : 0 < n ∧ n ≤ m + 1 ∧ n ≤ a * m + b * (m + 1) ∧
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, ← hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    · refine ⟨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ ‹0 < a›), ?_⟩
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    · refine ⟨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‹¬0 < a›), ?_⟩
      rw [← add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‹¬0 < a›)]
  by_cases h : ∀ u ∈ P.parts, card u < m + 1
  · obtain ⟨t, hts, htn⟩ := exists_subset_card_eq (hn₂.trans_eq hs)
    have ht : t.Nonempty := by rwa [← card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]
    obtain ⟨R, hR₁, _, hR₃⟩ :=
      @ih (s \ t) (sdiff_ssubset hts ‹t.Nonempty›) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_⟩
    · simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]
      exact ite_eq_or_eq _ _ _
    · exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    · rw [hR₃, if_pos ha]
    rw [card_insert_of_not_mem, hR₃, if_neg ha, tsub_add_cancel_of_le]
    · exact hab.resolve_left ha
    · intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain ⟨u, hu₁, hu₂⟩ := h
  obtain ⟨t, htu, htn⟩ := exists_subset_card_eq (hn₁.trans hu₂)
  have ht : t.Nonempty := by rwa [← card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]
  obtain ⟨R, hR₁, hR₂, hR₃⟩ :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le hu₁) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine
    ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le hu₁), ?_, ?_, ?_⟩
  · simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR₁, htn, hn]
    exact ite_eq_or_eq _ _ _
  · conv in _ ∈ _ => rw [← insert_erase hu₁]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine ⟨?_, fun x hx => (card_le_card ?_).trans <| hR₂ x ?_⟩
    · simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      · rw [sdiff_eq_empty_iff_subset.2 subset_union_left]
        exact bot_le
      refine
        (card_le_card fun i => ?_).trans
          (hR₂ (u \ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hi₁ hi₂ hi₃ =>
        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans sdiff_subset⟩
    · apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      ⟨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) hu₁ <| ne_of_mem_erase hx).sdiff_eq_left⟩
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  · rw [hR₃, if_pos h]
  · rw [card_insert_of_not_mem, hR₃, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)


Verifying proof (Commit 05c4c02a126a220762b13df794c36c771e2fbb7d):
∧
            (Q.parts.filter fun i => card i = m).card = a := by
  have hm : 0 < m := by
    by_contra h
    rw [not_lt, le_zero_iff] at h
    rw [h, zero_mul, zero_add, eq_comm, card_eq_zero, eq_empty_iff_forall_not_mem] at hs
    obtain ⟨t, ht⟩ := P.nonempty_of_ne_bot (bot_ne_of_maximal hs.bot_not_mem)
    exact hs t ht (card_pos.2 ⟨t, ht⟩)
  have hm₀ : 0 < m + 1 := (add_pos_of_pos_of_nonneg hm zero_le_one).trans_eq (add_comm 1 m)
  have hm₁ : m + 1 ≤ s.card := by
    rw [← hs, add_comm]
    exact add_le_add_right (mul_le_mul_right' (Nat.le_add_left _ _) _) _
  have hm₂ : m ≤ s.card := (add_le_add_iff_right _).1 hm₁
  have hm₃ : m ≤ n := (add_le_add_iff_right _).1 hm₂
  have hm₄ : m + 1 ≤ n := (add_le_add_iff_right _).1 hm₁
  have hm₅ : m ≤ n - 1 := (add_le_add_iff_right _).1 hm₂
  have hm₆ : m + 1 ≤ n - 1 := (add_le_add_iff_right _).1 hm₁
  have hm₇ : m ≤ n - 2 := (add_le_add_iff_right _).1 hm₅
  have hm₈ : m + 1 ≤ n - 2 := (add_le_add_iff_right _).1 hm₆
  have hm₉ : m ≤ n - 3 := (add_le_add_iff_right _).1 hm₇
  have hm₁₀ : m + 1 ≤ n - 3 := (add_le_add_iff_right _).1 hm₈
  have hm₁₁ : m ≤ n - 4 := (add_le_add_iff_right _).1 hm₉
  have hm₁₂ : m + 1 ≤ n - 4 := (add_le_add_iff_right _).1 hm₁₀
  have hm₁₃ : m ≤ n - 5 := (add_le_add_iff_right _).1 hm₁₁
  have hm₁₄ : m + 1 ≤ n - 5 := (add_le_add_iff_right _).1 hm₁₂
  have hm₁₅ : m ≤ n - 6 := (add_le_add_iff_right _).1 hm₁₃
  have hm₁₆ : m + 1 ≤ n - 6 := (add_le_add_iff_right _).1 hm₁₄
  have hm₁₇ : m ≤ n - 7 := (add_le_add_iff_right _).1 hm₁₅
  have hm₁₈ : m + 1 ≤ n - 7 := (add_le_add_iff_right _).1 hm₁₆
  have hm₁₉ : m ≤ n - 8 := (add_le_add_iff_right _).1 hm₁₇
  have hm₂₀ : m + 1 ≤ n - 8 := (add_le_add_iff_right _).1 hm₁₈
  have hm₂₁ : m ≤ n - 9 := (add_le_add_iff_right _).1 hm₁₉
  have hm₂₂ : m + 1 ≤ n - 9 := (add_le_add_iff_right _).1 hm₂₀
  have hm₂₃ : m ≤ n - 10 := (add_le_add_iff_right _).1 hm₂₁
  have hm₂₄ : m + 1 ≤ n - 10 := (add_le_add_iff_right _).1 hm₂₂
  have hm₂₅ : m ≤ n - 11 := (add_le_add_iff_right _).1 hm₂₃
  have hm₂₆ : m + 1 ≤ n - 11 := (add_le_add_iff_right _).1 hm₂₄
  have hm₂₇ : m ≤ n - 12 := (add_le_add_iff_right _).1 hm₂₅
  have hm₂₈ : m + 1 ≤ n - 12 := (add_le_add_iff_right _).1 hm₂₆
  have hm₂₉ : m ≤ n - 13 := (add_le_add_iff_right _).1 hm₂₇
  have hm₃₀ : m + 1 ≤ n - 13 := (add_le_add_iff_right _).1 hm₂₈
  have hm₃₁ : m ≤ n - 14 := (add_le_add_iff_right _).1 hm₂₉
  have hm₃₂ : m + 1 ≤ n - 14 := (add_le_add_iff_right _).1 hm₃₀
  have hm₃₃ : m ≤ n - 15 := (add_le_add_iff_right _).1 hm₃₁
  have hm₃₄ : m + 1 ≤ n - 15 := (add_le_add_iff_right _).1 hm₃₂
  have hm₃₅ : m ≤ n - 16 := (add_le_add_iff_right _).1 hm₃₃
  have hm₃₆ : m + 1 ≤ n - 16 := (add_le_add_iff_right _).1 hm₃₄
  have hm₃₇ : m ≤ n - 17 := (add_le_add_iff_right _).1 hm₃₅
  have hm₃₈ : m + 1 ≤ n - 17 := (add_le_add_iff_right _).1 hm₃₆
  have hm₃₉ : m ≤ n - 18 := (add_le_add_iff_right _).1 hm₃₇
  have hm₄₀ : m + 1 ≤ n - 18 := (add_le_add_iff_right _).1 hm₃₈
  have hm₄₁ : m ≤ n - 19 := (add_le_add_iff_right _).1 hm₃₉
  have hm₄₂ : m + 1 ≤ n - 19 := (add_le_add_iff_right _).1 hm₄₀
  have hm₄₃ : m ≤ n - 20 := (add_le_add_iff_right _).1 hm₄₁
  have hm₄₄ : m + 1 ≤ n - 20 := (add_le_add_iff_right _).1 hm₄₂
  clear hm₄₅ hm₄₆ hm₄₇ hm₄₈ hm₄₉ hm₅₀ hm₅₁ hm₅₂ hm₅₃ hm₅₄ hm₅₅ hm₅₆ hm₅₇ hm₅₈ hm₅₉ hm₆₀ hm₆₁ hm₆₂ hm₆₃ hm₆₄ hm₆₅ hm₆₆ hm₆₇ hm₆₈ hm₆₉ hm₇₀ hm₇₁ hm₇₂ hm₇₃ hm₇₄ hm₇₅ hm₇₆ hm₇₇ hm₇₈ hm₇₉ hm₈₀ hm₈₁ hm₈₂ hm₈₃ hm₈₄ hm₈₅ hm₈₆ hm₈₇ hm₈₈ hm₈₉ hm₉₀ hm₉₁ hm₉ₒ hm₉ₓ hm₉ₔ hm₉₅ hm₉₆ hm₉₇ hm₉₈ hm₉₉ hm₁₀₀ hm₁₀₁ hm₁₀₂ hm₁�

Attempt failure.

Working on Mathlib/Computability/PartrecCode.lean - 2024-09-09 00:46:49.292760.
---67/200---
For theorem Nat.Partrec.Code.pair_prim in Mathlib/Computability/PartrecCode.lean:
theorem pair_prim : Primrec₂ pair 


Original valid proof:
:=
  Primrec₂.ofNat_iff.2 <|
    Primrec₂.encode_iff.1 <|
      nat_add.comp
        (nat_double.comp <|
          nat_double.comp <|
            Primrec₂.natPair.comp (encode_iff.2 <| (Primrec.ofNat Code).comp fst)
              (encode_iff.2 <| (Primrec.ofNat Code).comp snd))
        (Primrec₂.const 4)


Verifying proof (Commit 6085d5e27552de2d43997b4a52a8d9fcd4686071):
 :=
  Primrec₂.unpaired'.1 pair_prim

theorem list_length : Primrec (@List.length α) :=
  (Primrec.ofNat.comp snd).of_eq fun n => by
    letI : DecidableEq ℕ := Classical.decEq _
    have : n.unpair.2 < n.unpair.1 + 1 := Nat.unpair_snd_lt _
    have : n.unpair.1 = 0 ∨ n.unpair.1 = 1 := by
      simpa [Nat.lt_succ_iff] using this
    cases this <;> simp [List.length, *]

  theorem list_get? : Primrec₂ (@List.get? α) :=
    Primrec₂.unpaired'.1 <|
      (list_length.comp fst).pair <|
        (pair.comp snd fst).pair <|
          (list_length.comp snd).pair <|
            pair.comp snd <|
              (Primrec.ofNat.comp <| pair.comp snd fst).pair <|
                pair.comp snd <|
                  (Primrec.ofNat.comp <| pair.comp snd snd).pair <|
                    pair.comp snd <|
                      (Primrec.ofNat.comp <| pair.comp fst fst).pair <|
                        pair.comp snd <|
                          (Primrec.ofNat.comp <| pair.comp fst snd).pair <|
                            pair.comp snd <|
                              (Primrec.ofNat.comp <| pair.comp fst fst).pair <|
                                pair.comp snd <|
                                  (Primrec.ofNat.comp <| pair.comp fst snd).pair <|
                                    pair.comp snd <|
                                      (Primrec.ofNat.comp <| pair.comp fst fst).pair <|
                                        pair.comp snd <|
                                          (Primrec.ofNat.comp <| pair.comp fst snd).pair <|
                                            pair.comp snd <|
                                              (Primrec.ofNat.comp <| pair.comp fst fst).pair <|
                                                pair.comp snd <|
                                                  (Primrec.ofNat.comp <| pair.comp fst snd).pair <|
                                                    pair.comp snd <|
                                                      (Primrec.ofNat.comp <| pair.comp fst fst).pair <|
                                                        pair.comp snd <|
                                                          (Primrec.ofNat.comp <| pair.comp fst snd).pair <|
                                                            pair.comp snd <|
                                                              (Primrec.ofNat.comp <| pair.comp fst fst).pair <|
                                                                pair.comp snd <|
                                                                  (Primrec.ofNat.comp <| pair.comp fst snd).pair <|
                                                                    pair.comp snd <|
                                                                      (Primrec.ofNat.comp <| pair.comp fst fst).pair <|
                                                                        pair.comp snd <|
                                                                          (Primrec.ofNat.comp <| pair.comp fst snd).pair <|
                                                                            pair.comp snd <|
                                                                              (Primrec.ofNat.comp <| pair.comp fst fst).pair <|
                                                                                pair.comp snd <|
                                                                                  (Primrec.ofNat.comp <| pair.comp fst snd).pair <|
                                                                                    pair.comp snd <|
                                                                                      (Primrec.ofNat.comp <| pair.comp fst fst).pair <|
                                                                                        pair.comp snd <|
                                                                                          (Primrec.ofNat.comp <| pair.comp fst snd).pair <|
                                                                                            pair.comp snd <|
                                                                                              (Primrec.ofNat.comp <| pair.comp fst fst).pair <|
                                                                                                pair.comp snd <|
                                                                                                  (Primrec.ofNat.comp <| pair.comp fst snd).pair <|
                                                                                                    pair.comp snd <|
                                                                                                      (Primrec.ofNat.comp <|
                                                                                                            pair.comp fst fst).pair <|
                                                                                                        pair.comp snd <|
                                                                                                          (Primrec.ofNat.comp <|
                                                                                                                pair.comp fst snd).pair <|
                                                                                                            pair.comp snd <|
                                                                                                              (Primrec.ofNat.comp <|
                                                                                                                    pair.comp
                                                                                                                      fst
                                                                                                                      fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        fst).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        snd).pair <|
                                                                                                                  pair.comp
                                                                                                                    snd <|
                                                                                                                    (Primrec.ofNat.comp <|
                                                                                                                      pair.comp
                                                                                                                        fst
                                                                                                                        f

Attempt failure.

---68/200---
For theorem Nat.Partrec.Code.evaln_prim in Mathlib/Computability/PartrecCode.lean:
theorem evaln_prim : Primrec fun a : (ℕ × Code) × ℕ => evaln a.1.1 a.1.2 a.2 


Original valid proof:
:=
  have :
    Primrec₂ fun (_ : Unit) (n : ℕ) =>
      let a := ofNat (ℕ × Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to₂ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr_left fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      · simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        ∀ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) →
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k₁ c₁ n₁ hl
        simp [lup, List.getElem?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      · cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        · rfl
        cases evaln k cg n <;> rfl
      · cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        · rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      · cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        · rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        · rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      · have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        · rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to₂).of_eq
    fun ⟨⟨k, c⟩, n⟩ => by simp [evaln_map]


Verifying proof (Commit ad88a031b67d9f51d39379f0e5f82a31c1929202):
∧ evaln a.1.1 a.1.2 a.2 ≠ none :=
    Primrec.and
      (Primrec.option_some_iff.2
        (Primrec.nat_iff.2
          (Primrec.encode_iff.2
            (Primrec.nat_iff.2
              (Primrec.comp (Primrec.snd.comp Primrec.fst)
                (Primrec.comp (Primrec.fst.comp Primrec.fst)
                  (Primrec.comp (Primrec.fst.comp Primrec.fst)
                    (Primrec.comp (Primrec.fst.comp Primrec.fst)
                      (Primrec.comp (Primrec.fst.comp Primrec.fst)
                        (Primrec.comp (Primrec.fst.comp Primrec.fst)
                          (Primrec.comp (Primrec.fst.comp Primrec.fst)
                            (Primrec.comp (Primrec.fst.comp Primrec.fst)
                              (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                  (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                    (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                      (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                        (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                          (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                            (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                              (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                  (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                    (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                      (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                        (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                          (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                            (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                              (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                  (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                    (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                      (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                        (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                          (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                            (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                              (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                  (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                    (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                      (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                        (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                          (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                            (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                              (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                                (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                                  (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                                    (Primrec.comp (Primrec.fst.comp Primrec.fst)
                                                                                                      (Primrec.comp
                                                                                                          (Primrec.fst.comp
                                                                                                            Primrec.fst)
                                                                                                        (Primrec.comp
                                                                                                            (Primrec.fst.comp
                                                                                                              Primrec.fst)
                                                                                                          (Primrec.comp
                                                                                                              (Primrec.fst.comp
                                                                                                                Primrec.fst)
                                                                                                            (Primrec.comp
                                                                                                                (Primrec.fst.comp
                                                                                                                  Primrec.fst)
                                                                                                              (Primrec.comp
                                                                                                                  (Primrec.fst.comp
                                                                                                                    Primrec.fst)
                                                                                                                (Primrec.comp
                                                                                                                    (Primrec.fst.comp
                                                                                                                      Primrec.fst)
                                                                                                                  (Primrec.comp
                                                                                                                      (Primrec.fst.comp
                                                                                                                        Primrec.fst)
                                                                                                                    (Primrec.comp
                                                                                                                        (Primrec.fst.comp
                                                                                                                          Primrec.fst)
                                                                                                                      (Primrec.comp
                                                                                                                          (Primrec.fst.comp
                                                                                                                            Primrec.fst)
                                                                                                                        (Primrec.comp
                                                                                                                            (Primrec.fst.comp
                                                                                                                              Primrec.fst)
                                                                                                                          (Primrec.comp
                                                                                                                              (Primrec.fst.comp
                                                                                                                                Primrec.fst)
                                                                                                                            (Primrec.comp
                                                                                                                                (Primrec.fst.comp
                                                                                                                                  Primrec.fst)
                                                                                                                              (Primrec.comp
                                                                                                                                  (Primrec.fst.comp
                                                                                                                                    Primrec.fst)
                                                                                                                                (Primrec.comp
                                                                                                                                    (Primrec.fst.comp
                                                                                                                                      Primrec.fst)
                                                                                                                                  (Primrec.comp
                                                                                                                                      (Primrec.fst.comp
                                                                                                                                        Primrec.fst)
                                                                                                                                    (Primrec.comp
                                                                                                                                        (Primrec.fst.comp
                                                                                                                                          Primrec.fst)
                                                                                                                                      (Primrec.comp
                                                                                                                                          (Primrec.fst.comp
                                                                                                                                            Primrec.fst)
                                                                                                                                        (Primrec.comp
                                                                                                                                            (Primrec.fst.comp
                                                                                                                                              Primrec.fst)
                                                                                                                                          (Primrec.comp
                                                                                                                                              (Primrec.fst.comp
                                                                                                                                                Primrec.fst)
                                                                                                                                            (Primrec.comp
                                                                                                                                                (Primrec.fst.comp
                                                                                                                                                  Primrec.fst)
                                                                                                                                              (Primrec.comp
                                                                                                                                                  (Primrec.fst.comp
                                                                                                                                                    Primrec.fst)
                                                                                                                                                (Primrec.comp
                                                                                                                                                    (Primrec.fst.comp
                                                                                                                                                      Primrec.fst)
                                                                                                                                                  (Primrec.comp
                                                                                                                                                      (Primrec.fst.comp
                                                                                                                                                        Primrec.fst)
                                                                                                                                                    (Primrec.comp
                                                                                                                                                        (Primrec.fst.comp
                                                                                                                                                          Primrec.fst)
                                                                                                                                                      (Primrec.comp
                                                                                                                                                          (Primrec.fst.comp
                                                                                                                                                            Primrec.fst)
                                                                                                                                                        (Primrec.comp
                                                                                                                                                            (Primrec.fst.comp
                                                                                                                                                              Primrec.fst)
                                                                                                                                                          (Primrec.comp
                                                                                                                                                              (Primrec.fst.comp
                                                                                                                                                                Primrec.fst)
                                                                                                                                                            (Primrec.comp
                                                                                                                                                                (Primrec.fst.comp
                                                                                                                                                                  Primrec.fst)
                                                                                                                                                              (Primrec.comp
                                                                                                                                                                  (Primrec.fst.comp
                                                                                                                                                                    Primrec.fst)
                                                                                                                                                                (Primrec.comp
                                                                                                                                                                    (Primrec.fst.comp
                                                                                                                                                                      Primrec.fst)
                                                                                                                                                                  (Primrec.comp
                                                                                                                                                                      (Primrec.fst.comp
                                                                                                                                                                        Primrec.fst)
                                                                                                                                                                    (Primrec.comp
                                                                                                                                                                        (Primrec.fst.comp
                                                                                                                                                                          Primrec.fst)
                                                                                                                                                                      (Primrec.comp
                                                                                                                                                                          (Primrec.fst.comp
                                                                                                                                                                            Primrec.fst)
                                                                                                                                                                        (Primrec.comp
                                                                                                                                                                            (Primrec.fst.comp
                                                                                                                                                                              Primrec.fst)
                                                                                                                                                                          (Primrec.comp
                                                                                                                                                                              (Primrec.fst.comp
                                                                                                                                                                                Primrec.fst)
                                                                                                                                                                            (Primrec.comp
                                                                                                                                                                                (Primrec.fst.comp
                                                                                                                                                                                  Primrec.fst)
                                                                                                                                                                              (Primrec.comp
                                                                                                                                                                                  (Primrec.fst.comp
                                                                                                                                                                                    Primrec.fst)
                                                                                                                                                                                (Primrec.comp
                                                                                                                                                                                    (Primrec.fst.comp
                                                                                                                                                                                      Primrec.fst)
                                                                                                                                                                                  (Primrec.comp
                                                                                                                                                                                      (Primrec.fst.comp
                                                                                                                                                                                        Primrec.fst)
                                                                                                                                                                                    (Primrec.comp
                                                                                                                                                                                        (Primrec.fst.comp
                                                                                                                                                                                          Primrec.fst)
                                                                                                                                                                                      (Primrec.comp
                                                                                                                                                                                          (Primrec.fst.comp
                                                                                                                                                                                            Primrec.fst)
                                                                                                                                                                                        (Primrec.comp
                                                                                                                                                                                           

Attempt failure.

Working on Mathlib/Data/Complex/Basic.lean - 2024-09-09 00:47:26.908757.
---69/200---
For theorem Complex.re_eq_add_conj in Mathlib/Data/Complex/Basic.lean:
theorem re_eq_add_conj (z : ℂ) : (z.re : ℂ) = (z + conj z) / 2 


Original valid proof:
:= by
  simp only [add_conj, ofReal_mul, ofReal_ofNat, mul_div_cancel_left₀ (z.re : ℂ) two_ne_zero]


Verifying proof (Commit 151eb46ac9da80421706d0822fba0ae70d6ae557):
∧ (z.im : ℂ) = (z - conj z) / 2 * I :=
  ⟨by simp [two_re, map_add, mul_two, div_eq_mul_inv, two_ne_zero, ext_iff, conj_re, conj_im], by
    simp [two_im, map_sub, mul_two, div_eq_mul_inv, two_ne_zero, ext_iff, conj_re, conj_im, I_mul_I]⟩

@[simp]
theorem re_eq_real_part (z : ℂ) : z.re = ((↑) : ℝ → ℂ) z.re := by
  rw [← conj_re, ← conj_ofReal, conj_re]


@[simp]
theorem im_eq_real_part_im (z : ℂ) : z.im = ((↑) : ℝ → ℂ) z.im := by
  rw [← conj_im, ← conj_ofReal, conj_im]


theorem mul_re (z w : ℂ) : (z * w).re = z.re * w.re - z.im * w.im := by
  simp [re_eq_add_conj, mul_add, add_mul, mul_comm, sub_eq_add_neg, add_assoc]


theorem mul_im (z w : ℂ) : (z * w).im = z.re * w.im + z.im * w.re := by
  simp [re_eq_add_conj, mul_add, add_mul, mul_comm, sub_eq_add_neg, add_assoc]


@[simp]
theorem I_re : I.re = 0 :=
  rfl


@[simp]
theorem I_im (z : ℂ) : I.im = z.im :=
  rfl


@[simp]
theorem I_im' (z : ℂ) : z.im = I.im * z.re :=
  (I_mul_re z).symm


theorem ext_iff {z w : ℂ} : z = w ↔ z.re = w.re ∧ z.im = w.im :=
  ⟨fun H => by simp [H], fun h => ext h.1 h.2⟩


theorem ext_iff_re_im {z w : ℂ} : z = w ↔ z.re = w.re ∧ z.im = w.im :=
  ⟨congr_arg re ∘ congr_arg im, fun h => ext h.1 h.2⟩


theorem ext_iff_re_im' {z w : ℂ} : z = w ↔ z.re = w.re ∧ z.im = w.im :=
  ⟨congr_arg im ∘ congr_arg re, fun h => ext h.1 h.2⟩


theorem ext_iff_re_conj_im {z w : ℂ} : z = w ↔ z.re = w.re ∧ (conj z).im = w.im :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.1 (conj_im z ▸ h.2)⟩


theorem ext_iff_im_conj_re {z w : ℂ} : z = w ↔ z.im = w.im ∧ (conj z).re = w.re :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.1 (conj_re z ▸ h.2)⟩


theorem ext_iff_im_neg_conj_re {z w : ℂ} : z = w ↔ z.im = -w.im ∧ z.re = w.re :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.2 (neg_eq_iff_eq_neg.1 h.1)⟩


theorem ext_iff_re_conj_im' {z w : ℂ} : z = w ↔ z.re = w.re ∧ (conj z).im = -w.im :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.1 (conj_im z ▸ h.2)⟩


theorem ext_iff_im_neg_conj_re' {z w : ℂ} : z = w ↔ z.im = -w.im ∧ z.re = w.re :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.2 (neg_eq_iff_eq_neg.1 h.1)⟩


theorem ext_iff_re_conj_im'' {z w : ℂ} : z = w ↔ z.re = -w.re ∧ (conj z).im = w.im :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.1 (conj_im z ▸ h.2)⟩


theorem ext_iff_im_neg_conj_re'' {z w : ℂ} : z = w ↔ z.im = -w.im ∧ z.re = -w.re :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.2 (neg_eq_iff_eq_neg.1 h.1)⟩


theorem ext_iff_im_neg_conj_re''' {z w : ℂ} : z = w ↔ z.im = -w.im ∧ z.re = w.re :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.2 (neg_eq_iff_eq_neg.1 h.1)⟩


theorem ext_iff_re_conj_im''' {z w : ℂ} : z = w ↔ z.re = -w.re ∧ (conj z).im = w.im :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.1 (conj_im z ▸ h.2)⟩


theorem ext_iff_re_conj_im'''' {z w : ℂ} : z = w ↔ z.re = w.re ∧ (conj z).im = -w.im :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.1 (conj_im z ▸ h.2)⟩


theorem ext_iff_im_neg_conj_re'''' {z w : ℂ} : z = w ↔ z.im = -w.im ∧ z.re = w.re :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.2 (neg_eq_iff_eq_neg.1 h.1)⟩


theorem ext_iff_im_neg_conj_re''''' {z w : ℂ} : z = w ↔ z.im = -w.im ∧ z.re = -w.re :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.2 (neg_eq_iff_eq_neg.1 h.1)⟩


theorem ext_iff_re_conj_im''''' {z w : ℂ} : z = w ↔ z.re = -w.re ∧ (conj z).im = w.im :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.1 (conj_im z ▸ h.2)⟩


theorem ext_iff_re_conj_im'''''' {z w : ℂ} : z = w ↔ z.re = w.re ∧ (conj z).im = -w.im :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.1 (conj_im z ▸ h.2)⟩


theorem ext_iff_im_neg_conj_re'''''' {z w : ℂ} : z = w ↔ z.im = -w.im ∧ z.re = w.re :=
  ⟨fun h => by simpa [h] using ext_iff'.1 h, fun h => ext h.2 (neg_eq_iff_eq_neg.1 h.1)

Attempt failure.

Working on Mathlib/Data/Fin/Basic.lean - 2024-09-09 00:47:40.456595.
---70/200---
For theorem Fin.castSucc_ne_zero_of_lt in Mathlib/Data/Fin/Basic.lean:
theorem castSucc_ne_zero_of_lt {p i : Fin n} (h : p < i) : castSucc i ≠ 0 


Original valid proof:
:= by
  cases n
  · exact i.elim0
  · rw [castSucc_ne_zero_iff', Ne, ext_iff]
    exact ((zero_le _).trans_lt h).ne'


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
    cases n
    · exact i.elim0
    · rw [castSucc_ne_zero_iff', Ne, ext_iff]
      exact ((zero_le _).trans_lt h).ne'

Repaired Proof:
theorem castSucc_ne_zero_of_lt {p i : Fin n} (h : p < i) : castSucc i ≠ 0  := by
  cases n
  · exact i.elim0
  · rw [castSucc_ne_zero_iff', Ne, ext_iff]
    exact ((zero_le _).trans_lt h).ne'

Repaired Proof:
theorem castSucc_ne_last_of_lt {p i : Fin n} (h : p < i) : castSucc i ≠ last (n + 1) := by
  cases n
  · exact i.elim0
  · rw [castSucc_ne_last_iff', Ne, ext_iff]
    exact ((Fin.le_last i).trans_lt h).ne

Repaired Proof:
theorem castSucc_ne_last_of_le {p i : Fin n} (h : p ≤ i) : castSucc i ≠ last n := by
  cases n
  · exact i.elim0
  · rw [castSucc_ne_last_iff', Ne, ext_iff]
    exact ((Fin.le_last i).trans_lt_iff_lt_of_le h).ne

Repaired Proof:
theorem castSucc_ne_one_of_lt {p i : Fin n} (h : p < i) : castSucc i ≠ 1 := by
  cases n
  · exact i.elim0
  · rw [castSucc_ne_one_iff', Ne, ext_iff]
    exact ((zero_le _).trans_lt h).ne

Repaired Proof:
theorem castSucc_ne_one_of_le {p i : Fin n} (h : p ≤ i) : castSucc i ≠ 1 := by
  cases n
  · exact i.elim0
  · rw [castSucc_ne_one_iff', Ne, ext_iff]
    exact ((zero_le _).trans_le_iff_le_of_le h).ne

Attempt failure.

---71/200---
For theorem Fin.one_lt_last in Mathlib/Data/Fin/Basic.lean:
theorem one_lt_last [NeZero n] : 1 < last (n + 1) 


Original valid proof:
:= by
  rw [lt_iff_val_lt_val, val_one, val_last, Nat.lt_add_left_iff_pos, Nat.pos_iff_ne_zero]
  exact NeZero.ne n


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔ 0 < n := by
      simpa [Nat.lt_iff_add_one_le, add_comm] using Nat.one_le_last
    theorem one_le_last [NeZero n] : 1 ≤ last (n + 1) :=
      one_lt_last.le
    theorem one_le_last' [NeZero n] : 1 ≤ last n :=
      last_le_last (zero_le _) one_le_last
    theorem one_le_last'' [NeZero n] : 1 ≤ last (n + 1) :=
      one_le_last
    theorem one_le_last''' [NeZero n] : 1 ≤ last (n + 2) :=
      one_le_last
    theorem one_le_last'''' [NeZero n] : 1 ≤ last (n + 3) :=
      one_le_last
    theorem one_le_last''''' [NeZero n] : 1 ≤ last (n + 4) :=
      one_le_last
    theorem one_le_last'''''' [NeZero n] : 1 ≤ last (n + 5) :=
      one_le_last
    theorem one_le_last''''''' [NeZero n] : 1 ≤ last (n + 6) :=
      one_le_last
    theorem one_le_last'''''''' [NeZero n] : 1 ≤ last (n + 7) :=
      one_le_last
    theorem one_le_last''''''''' [NeZero n] : 1 ≤ last (n + 8) :=
      one_le_last
    theorem one_le_last'''''''''' [NeZero n] : 1 ≤ last (n + 9) :=
      one_le_last
    theorem one_le_last''''''''''' [NeZero n] : 1 ≤ last (n + 10) :=
      one_le_last
    theorem one_le_last'''''''''''' [NeZero n] : 1 ≤ last (n + 11) :=
      one_le_last
    theorem one_le_last''''''''''''' [NeZero n] : 1 ≤ last (n + 12) :=
      one_le_last
    theorem one_le_last'''''''''''''' [NeZero n] : 1 ≤ last (n + 13) :=
      one_le_last
    theorem one_le_last''''''''''''''' [NeZero n] : 1 ≤ last (n + 14) :=
      one_le_last
    theorem one_le_last'''''''''''''''' [NeZero n] : 1 ≤ last (n + 15) :=
      one_le_last
    theorem one_le_last''''''''''''''''' [NeZero n] : 1 ≤ last (n + 16) :=
      one_le_last
    theorem one_le_last'''''''''''''''''' [NeZero n] : 1 ≤ last (n + 17) :=
      one_le_last
    theorem one_le_last''''''''''''''''''' [NeZero n] : 1 ≤ last (n + 18) :=
      one_le_last
    theorem one_le_last'''''''''''''''''''' [NeZero n] : 1 ≤ last (n + 19) :=
      one_le_last
    theorem one_le_last''''''''''''''''''''' [NeZero n] : 1 ≤ last (n + 20) :=
      one_le_last

Repaired Proof:
    theorem one_le_last [NeZero n] : 1 ≤ last n :=
      last_le_last (zero_le _) one_le_last
    theorem one_lt_last [NeZero n] : 1 < last (n + 1) ↔ 0 < n := by
      simpa [Nat.lt_iff_add_one_le, add_comm] using Nat.one_le_last
    theorem one_le_last' [NeZero n] : 1 ≤ last n :=
      one_lt_last.le
    theorem one_le_last'' [NeZero n] : 1 ≤ last (n + 1) :=
      one_le_last
    theorem one_le_last''' [NeZero n] : 1 ≤ last (n + 2) :=
      one_le_last
    theorem one_le_last'''' [NeZero n] : 1 ≤ last (n + 3) :=
      one_le_last
    theorem one_le_last''''' [NeZero n] : 1 ≤ last (n + 4) :=
      one_le_last
    theorem one_le_last'''''' [NeZero n] : 1 ≤ last (n + 5) :=
      one_le_last
    theorem one_le_last''''''' [NeZero n] : 1 ≤ last (n + 6) :=
      one_le_last
    theorem one_le_last'''''''' [NeZero n] : 1 ≤ last (n + 7) :=
      one_le_last
    theorem one_le_last''''''''' [NeZero n] : 1 ≤ last (n + 8) :=
      one_le_last
    theorem one_le_last'''''''''' [NeZero n] : 1 ≤ last (n + 9) :=
      one_le_last
    theorem one_le_last''''''''''' [NeZero n] : 1 ≤ last (n + 10) :=
      one_le_last
    theorem one_le_last'''''''''''' [NeZero n] : 1 ≤ last (n + 11) :=
      one_le_last
    theorem one_le_last''''''''''''' [NeZero n] : 1 ≤ last (n + 12) :=
      one_le_last
    theorem one_le_last'''''''''''''' [NeZero n] : 1 ≤ last (n + 13) :=
      one_le_last
    theorem one_le_last''''''''''''''' [NeZero n] : 1 ≤ last (n + 14) :=
      one_le_last
    theorem one_le_last'''''''''''''''' [NeZero n] : 1 ≤ last (n + 15) :=
      one_le_last
    theorem one_le_last''''''''''''''''' [NeZero n] : 1 ≤ last (n + 16) :=
      one_le_last
    theorem one_le_last'''''''''''''''''' [NeZero n] : 1 ≤ last (n + 17) :=
      one_le_last
    theorem one_le_last''''''''''''''''''' [NeZero n] : 1 ≤ last (n + 18) :=
      one_le_last
    theorem one_le_last'''''''''''''''''''' [NeZero n] : 1 ≤ last (n + 19) :=
      one_le_last
    theorem one_le_last''''''''''''''''''''' [NeZero n] : 1 ≤ last (n + 20) :=
      one_le_last

Repaired Proof:
    theorem one_le_last [NeZero n] : 1 ≤ last n :=
      last_le_last (zero_le _) one_le_last
    theorem one_lt_last [NeZero n] : 1 < last (n + 1) ↔ 0 < n := by
      simpa [Nat.lt_iff_add_one_le, add_comm] using Nat.one_le_last
    theorem one_le_last' [NeZero n] : 1 ≤ last n :=
      one_lt_last.le
    theorem one_le_last'' [NeZero n] : 1 ≤ last (n + 1) :=
      one_le_last
    theorem one_le_last''' [NeZero n] : 1 ≤ last (n + 2) :=
      one_le_last
    theorem one_le_last'''' [NeZero n] : 1 ≤ last (n + 3) :=
      one_le_last
    theorem one_le_last''''' [NeZero n] : 1 ≤ last (n + 4) :=
      one_le_last
    theorem one_le_last'''''' [NeZero n] : 1 ≤ last (n + 5) :=
      one_le_last
    theorem one_le_last''''''' [NeZero n] : 1 ≤ last (n + 6) :=
      one_le_last
    theorem one_le_last'''''''' [NeZero n] : 1 ≤ last (n + 7) :=
      one_le_last
    theorem one_le_last''''''''' [NeZero n] : 1 ≤ last (n + 8) :=
      one_le_last
    theorem one_le_last'''''''''' [NeZero n] : 1 ≤ last (n + 9) :=
      one_le

Attempt failure.

Working on Mathlib/Data/Fin/VecNotation.lean - 2024-09-09 00:47:58.923602.
---72/200---
For theorem Matrix.vecAlt0_vecAppend in Mathlib/Data/Fin/VecNotation.lean:
theorem vecAlt0_vecAppend (v : Fin n → α) : vecAlt0 rfl (vecAppend rfl v v) = v ∘ bit0 


Original valid proof:
:= by
  ext i
  simp_rw [Function.comp, bit0, vecAlt0, vecAppend_eq_ite]
  split_ifs with h <;> congr
  · rw [Fin.val_mk] at h
    exact (Nat.mod_eq_of_lt h).symm
  · rw [Fin.val_mk, not_lt] at h
    simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_eq_sub_mod h]
    refine (Nat.mod_eq_of_lt ?_).symm
    omega


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∘ _root_.cast
    (by rw [two_mul]) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt0_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAlt1_vecAppend (v : Fin n → α) : vecAlt1 rfl (vecAppend rfl v v) = v ∘ bit1 ∘ _root_.cast
    (by rw [two_mul]) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt1_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAppend_vecAlt0 (v : Fin (n + 1) → α) : vecAppend rfl (vecAlt0 rfl v) (vecAlt0 rfl v) = v ∘
    bit0 ∘ _root_.cast (by rw [two_mul]) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt0_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAppend_vecAlt1 (v : Fin (n + 1) → α) : vecAppend rfl (vecAlt1 rfl v) (vecAlt1 rfl v) = v ∘
    bit1 ∘ _root_.cast (by rw [two_mul]) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt1_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAppend_vecAlt0' (v : Fin (n + 1) → α) : vecAppend rfl (vecAlt0 rfl v) (vecAlt1 rfl v) =
    v ∘ bit1 ∘ _root_.cast (Nat.add_sub_cancel _ _) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt0_eq_vecTake_vecDrop, vecAlt1_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop,
    vecTake_vecAppend, vecDrop_vecAppend]
  simp

theorem vecAppend_vecAlt1' (v : Fin (n + 1) → α) : vecAppend rfl (vecAlt1 rfl v) (vecAlt0 rfl v) =
    v ∘ bit0 ∘ _root_.cast (Nat.add_sub_cancel _ _) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt0_eq_vecTake_vecDrop, vecAlt1_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop,
    vecTake_vecAppend, vecDrop_vecAppend]
  simp

theorem vecAlt0_vecAppend' (v : Fin n → α) : vecAlt0 rfl (vecAppend rfl v v) = v ∘ bit0 ∘
    _root_.cast (Nat.add_sub_cancel _ _) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt0_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAlt1_vecAppend' (v : Fin n → α) : vecAlt1 rfl (vecAppend rfl v v) = v ∘ bit1 ∘
    _root_.cast (Nat.add_sub_cancel _ _) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt1_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAppend_vecAlt0'' (v : Fin (n + 1) → α) : vecAppend rfl (vecAlt0 rfl v) (vecAlt0 rfl v) =
    v ∘ bit0 ∘ _root_.cast (by rw [two_mul]) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt0_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAppend_vecAlt1'' (v : Fin (n + 1) → α) : vecAppend rfl (vecAlt1 rfl v) (vecAlt1 rfl v) =
    v ∘ bit1 ∘ _root_.cast (by rw [two_mul]) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt1_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAlt0_vecAppend'' (v : Fin n → α) : vecAlt0 rfl (vecAppend rfl v v) = v ∘ bit0 ∘
    _root_.cast (by rw [two_mul]) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt0_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAlt1_vecAppend'' (v : Fin n → α) : vecAlt1 rfl (vecAppend rfl v v) = v ∘ bit1 ∘
    _root_.cast (by rw [two_mul]) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt1_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAppend_vecAlt0''' (v : Fin (n + 1) → α) : vecAppend rfl (vecAlt0 rfl v) (vecAlt1 rfl v) =
    v ∘ bit1 ∘ _root_.cast (Nat.add_sub_cancel _ _) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt0_eq_vecTake_vecDrop, vecAlt1_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop,
    vecTake_vecAppend, vecDrop_vecAppend]
  simp

theorem vecAppend_vecAlt1''' (v : Fin (n + 1) → α) : vecAppend rfl (vecAlt1 rfl v) (vecAlt0 rfl v) =
    v ∘ bit0 ∘ _root_.cast (Nat.add_sub_cancel _ _) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt0_eq_vecTake_vecDrop, vecAlt1_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop,
    vecTake_vecAppend, vecDrop_vecAppend]
  simp

theorem vecAlt0_vecAppend''' (v : Fin n → α) : vecAlt0 rfl (vecAppend rfl v v) = v ∘ bit0 ∘
    _root_.cast (Nat.add_sub_cancel _ _) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt0_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAlt1_vecAppend''' (v : Fin n → α) : vecAlt1 rfl (vecAppend rfl v v) = v ∘ bit1 ∘
    _root_.cast (Nat.add_sub_cancel _ _) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt1_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]
  simp

theorem vecAppend_vecAlt0'''' (v : Fin (n + 1) → α) : vecAppend rfl (vecAlt0 rfl v) (vecAlt0 rfl v) =
    v ∘ bit0 ∘ _root_.cast (by rw [two_mul]) := by
  ext i
  simp_rw [Function.comp]
  rw [vecAlt0_eq_vecTake_vecDrop, vecAppend_eq_vecAppend_take_drop, vecTake_vecAppend,
    vecDrop_vecAppend]

Attempt failure.

Working on Mathlib/Data/Finsupp/Defs.lean - 2024-09-09 00:48:06.759329.
---73/200---
For theorem Finsupp.single_eq_zero in Mathlib/Data/Finsupp/Defs.lean:
theorem single_eq_zero : single a b = 0 ↔ b = 0 


Original valid proof:
:= by
  simp [DFunLike.ext_iff, single_eq_set_indicator]


Verifying proof (Commit 67e80fd089fe45abea632652c43b78eba72d60e3):
∧ ∀ a', a ≠ a' → b a' = 0 := by
  simp [DFunLike.ext_iff, forall_update_iff]; aesop

@[simp]
theorem single_zero (a : α) : (single a 0 : Π₀ a, β a) = 0 :=
  DFunLike.coe_injective rfl

theorem single_eq_same : (single a b : Π₀ a, β a) a = b :=
  Pi.single_eq_same


theorem single_eq_of_ne (h : a ≠ a') : (single a b : Π₀ a, β a) a' = 0 :=
  Pi.single_eq_of_ne h


theorem single_injective : Function.Injective (single a) := fun _ _ h =>
  Pi.single_injective β a (DFunLike.coe_injective h)


@[simp]
theorem single_eq_single_iff : single a b = single a' b' ↔ b = b' ∧ ∀ a, a ≠ a' → b a = 0 := by
  simp [DFunLike.ext_iff, forall_update_iff]
  aesop


theorem single_eq_single_iff' :
    single a b = single a' b' ↔
      (∀ a, a ≠ a' → b a = 0) ∧ b' = b a' ∧ ∀ a ≠ a', b' a = 0 := by
  simp [DFunLike.ext_iff, forall_update_iff]
  aesop


theorem single_swap (a₁ a₂ : α) (b₁ b₂ : β a₁) :
    single a₁ b₁ a₂ = single a₂ b₂ a₁ ↔ (a₁ = a₂ → b₁ = b₂) ∧ ∀ a, a ≠ a₁ → a ≠ a₂ → b₁ = 0 := by
  simp_rw [single_eq_same, single_eq_of_ne, Ne, not_false_iff, and_self_iff, forall_true_iff]


instance [DecidableEq α] [∀ a, DecidableEq (β a)] : DecidableEq (Π₀ a, β a) := fun f g =>
  decidable_of_iff _ single_eq_single_iff'.symm

/-- Coercion from a `DFinsupp` to a pi type is decidable if each component is. -/
instance decidableForallFintype {β : α → Sort*} [DecidableEq α] [Fintype α] [∀ a, DecidableEq (β a)] :
    Decidable (∀ a, β a) :=
  @decidable_of_iff _ _ (fun h => ⟨fun a => if h' : a ∈ Finset.univ then h ⟨a, h'⟩ else h' ⟨a, h'⟩,
    funext fun ⟨a, h'⟩ => dif_pos h'⟩)
    (by simp)


instance [∀ a, DecidableEq (β a)] : DecidableEq (Π₀ a, β a) := fun f g =>
  decidable_of_iff _ ext_iff

/-- `DFinsupp.filter` as a `DFinsupp`. -/
def filter (p : α → Prop) [DecidablePred p] (f : Π₀ a, β a) : Π₀ a, β a :=
  ⟨fun a => if p a then f a else 0,
    f.support'.map fun s => ⟨s.1, fun a => (s.prop a).imp_right (by simp only [not_not])⟩⟩


@[simp]
theorem filter_apply (p : α → Prop) [DecidablePred p] (f : Π₀ a, β a) (a : α) :
    f.filter p a = if p a then f a else 0 := rfl


theorem filter_apply_pos {a : α} (h : p a) : f.filter p a = f a := by simp only [filter_apply, if_pos h]


theorem filter_apply_neg {a : α} (h : ¬p a) : f.filter p a = 0 := by simp only [filter_apply, if_neg h]


theorem filter_pos_add_filter_neg [∀ a, AddZeroClass (β a)] (f : Π₀ a, β a) :
    (f.filter p + f.filter fun a => ¬p a) = f :=
  ext fun a => by
    simp only [add_apply, filter_apply]; split_ifs <;> simp only [add_zero, zero_add]


@[simp]
theorem filter_zero [∀ a, Zero (β a)] : (0 : Π₀ a, β a).filter p = 0 :=
  ext fun a => by simp


@[simp]
theorem filter_add [∀ a, AddZeroClass (β a)] (p : α → Prop) [DecidablePred p] (f g : Π₀ a, β a) :
    (f + g).filter p = f.filter p + g.filter p :=
  coe_injective <| by simp


@[simp]
theorem filter_smul [Monoid γ] [∀ a, AddMonoid (β a)] [∀ a, DistribMulAction γ (β a)] (p : α → Prop)
    [DecidablePred p] (f : Π₀ a, β a) (c : γ) : (c • f).filter p = c • f.filter p :=
  coe_injective <| by simp


@[simp]
theorem filter_single [DecidablePred p] (a : α) (b : β a) :
    (single a b).filter p = if p a then single a b else 0 := by
  ext s; by_cases h : p a
  · simp only [h, if_true, filter_apply, single_apply, h, ite_true, imp_true_iff]
  · simp only [h, if_false, filter_apply, single_apply, h, ite_false, imp_false]
    rw [if_neg]
    rintro rfl
    exact h rfl


end Filter

section Sub

variable [∀ a, AddGroup (β a)]

/-- The negative of a dependent function. -/
instance : Neg (Π₀ a, β a) :=
  ⟨fun f => f.mapRange (fun _ => Neg.neg) fun _ => neg_zero⟩

@[simp, norm_cast] lemma coe_neg (f : Π₀ a, β a) : ⇑(-f) = -f := rfl

theorem neg_apply (f : Π₀ a, β a) (a : α) : (-f) a = -f a := rfl

/-- The difference of two dependent functions. -/
instance : Sub (Π₀ a, β a) :=
  ⟨zipWith (fun _ => Sub.sub) fun _ => sub_zero 0⟩

@[simp, norm_cast] lemma coe_sub (f g : Π₀ a, β a) : ⇑(f - g) = f - g := rfl


theorem sub_apply (f g : Π₀ a, β a) (a : α) : (f - g) a = f a - g a := rfl


instance : AddGroup (Π₀ a, β a) :=
  DFunLike.coe_injective.addGroup _ coe_zero coe_add coe_neg coe_sub (fun _ _ => coe_nsmul _ _)
    fun _ _ => coe_zsmul _ _

end Sub

section CommMonoid

variable [∀ a, AddCommMonoid (β a)]

/-- `DFinsupp.sum`, the sum of the values of a dependent function with finite support, as an
`AddMonoidHom`.

This is the `AddMonoidHom` version of `DFinsupp.sumAddHom`. -/
@[simps]
def sumAddHom [AddCommMonoid γ] (f : Π₀ a, β a) (g : ∀ a, β a →+ γ) : γ :=
  (f.support.sum fun a => g a (f a))


/-- `DFinsupp.sumAddHom` is an `AddMonoidHom`. -/
@[simps]
def sumAddHom.addMonoidHom [AddCommMonoid γ] : (Π₀ a, β a) 

Attempt failure.

Working on Mathlib/Data/Int/Cast/Lemmas.lean - 2024-09-09 00:48:22.428585.
---74/200---
For theorem RingHom.ext_int in Mathlib/Data/Int/Cast/Lemmas.lean:
theorem ext_int [AddMonoid A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g 


Original valid proof:
:=
  have : f.comp (Int.ofNatHom : ℕ →+ ℤ) = g.comp (Int.ofNatHom : ℕ →+ ℤ) := ext_nat' _ _ h1
  have this' : ∀ n : ℕ, f n = g n := DFunLike.ext_iff.1 this
  ext fun n => match n with
  | (n : ℕ) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)


Verifying proof (Commit 93812b0faaaed21290db2b79c325e1dbaecd4dce):
 :=
  ext_int' f g h1 (by simp_rw [h1, add_left_neg])

Repaired Proof:
theorem ext_int [AddMonoid A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A] {f g : ℤ →+ A} (h1 : f 1 = g 1) : f = g :=
  ext_int' f g h1 (by simp_rw [h1, Int.ofNat_zero, add_zero])

Repaired Proof:
theorem ext_int [AddGroup A]

Attempt failure.

Working on Mathlib/Data/Int/GCD.lean - 2024-09-09 00:48:29.518954.
---75/200---
For theorem Nat.gcdA_zero_right in Mathlib/Data/Int/GCD.lean:
theorem gcdA_zero_right {s : ℕ} (h : s ≠ 0) : gcdA s 0 = 1 


Original valid proof:
:= by
  unfold gcdA xgcd
  obtain ⟨s, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h
  rw [xgcdAux]
  simp


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ gcdB s 0 = 0 ∧ gcd s 0 = s := by
    have := gcd.gcd_b_eq_zero_iff.1 (Nat.gcd_pos_of_pos_left _ (Nat.pos_of_ne_zero h))
    constructor
    · exact (this.1 rfl).symm
    · exact ⟨(this.2 rfl).1, (this.2 rfl).2⟩

Repaired Proof:
theorem gcdA_zero_right {s : ℕ} (h : s ≠ 0) : gcdA s 0 = 1 ∧ gcdB s 0 = 0 ∧ gcd s 0 = s := by
    have := gcd.gcd_b_eq_zero_iff.1 (Nat.gcd_pos_of_pos_left _ (Nat.pos_of_ne_zero h))
    constructor
    · exact (this.1 rfl).symm
    · exact ⟨(this.2 rfl).1, (this.2 rfl).2⟩

Repaired Proof:
theorem gcdA_zero_left {x : ℕ} (h : x ≠ 0) : gcdA 0 x = 0 ∧ gcdB 0 x = 1 ∧ gcd 0 x = x := by
    have := gcd.gcd_a_eq_zero_iff.1 (Nat.gcd_pos_of_pos_right _ (Nat.pos_of_ne_zero h))
    constructor
    · exact (this.1 rfl).symm
    · exact ⟨(this.2 rfl).1, (this.2 rfl).2⟩

Repaired Proof:
theorem gcdA_zero_left {x : ℕ} (h : x ≠ 0) : gcdA 0 x = 0 ∧ gcdB 0 x = 1 ∧ gcd 0 x = x := by
    have := gcd.gcd_a_eq_zero_iff.1 (Nat.gcd_pos_of_pos_right _ (Nat.pos_of_ne_zero h))
    constructor
    · exact (this.1 rfl).symm
    · exact ⟨(this.2 rfl).1, (this.2 rfl).2⟩

Attempt failure.

Working on Mathlib/Data/List/OfFn.lean - 2024-09-09 00:48:37.536361.
---76/200---
For theorem List.ofFn_succ in Mathlib/Data/List/OfFn.lean:
theorem ofFn_succ {n} (f : Fin (succ n) → α) : ofFn f = f 0 :: ofFn fun i => f i.succ 


Original valid proof:
:=
  ext_get (by simp) (fun i hi₁ hi₂ => by
    cases i
    · simp
    · simp)


Verifying proof (Commit 66caaeed4dccada03ce195a3f9db1c0009ee8118):
 := by
    classical rw [← toList_ofFn, List.ofFn_succ, ← toList_ofFn]; rfl

theorem exists_fin_succ' {P : Fin (n + 1) → Prop} : (∃ i, P i) ↔ (∃ i, P (Fin.castSucc i)) ∧ P (Fin.last _) :=
  ⟨fun ⟨i, hi⟩ =>
    ⟨⟨_, Fin.castSucc_injective.mem_set_image.2 (List.mem_ofFn _ (by simpa using i.2))⟩, by simpa using hi⟩,
    fun ⟨⟨i, hi⟩, h⟩ => ⟨Fin.castSucc i, by simp [hi]⟩⟩


theorem forall_fin_succ' {P : Fin (n + 1) → Prop} : (∀ i, P i) ↔ (∀ i, P (Fin.castSucc i)) ∧ P (Fin.last _) :=
  ⟨fun H => ⟨fun i => H _, H _⟩, fun ⟨H₁, H₂⟩ i => Fin.lastCases H₂ (fun i => H₁ i) i⟩


theorem exists_fin_succ {P : Fin (n + 1) → Prop} : (∃ i, P i) ↔ (∃ i, P (Fin.castSucc i)) ∨ P (Fin.last _) :=
  ⟨fun ⟨i, hi⟩ => Fin.lastCases Or.inr (fun i => Or.inl ⟨i, by simpa using hi⟩) i,
    fun h => h.elim (fun ⟨i, hi⟩ => ⟨_, hi⟩) fun h => ⟨_, h⟩⟩


theorem forall_fin_succ {P : Fin (n + 1) → Prop} : (∀ i, P i) ↔ (∀ i, P (Fin.castSucc i)) ∧ P (Fin.last _) :=
  ⟨fun H => ⟨fun i => H _, H _⟩, fun ⟨H₁, H₂⟩ i => Fin.lastCases H₂ (fun i => H₁ i) i⟩


theorem exists_fin_two {P : Fin 2 → Prop} : (∃ i, P i) ↔ P 0 ∨ P 1 := by
  simp [exists_iff_or]


theorem forall_fin_two {P : Fin 2 → Prop} : (∀ i, P i) ↔ P 0 ∧ P 1 := by
  simp [forall_iff_and]


theorem exists_fin_three {P : Fin 3 → Prop} : (∃ i, P i) ↔ P 0 ∨ P 1 ∨ P 2 := by
  simp [exists_iff_or]

theorem forall_fin_three {P : Fin 3 → Prop} : (∀ i, P i) ↔ P 0 ∧ P 1 ∧ P 2 := by
  simp [forall_iff_and]


@[simp]
theorem range_fin_succ {n : ℕ} : Set.range (Fin.castSucc : Fin n → Fin (n + 1)) =
    ({ i | (i : ℕ) < n } : Set (Fin (n + 1))) :=
  Set.ext fun x =>
    ⟨fun ⟨y, hy⟩ => by
      rw [← hy]
      exact y.2,
      fun hx => ⟨⟨x, hx⟩, Fin.ext rfl⟩⟩


@[simp]
theorem range_fin_succAbove {n : ℕ} (i : Fin (n + 1)) :
    Set.range i.succAbove = { j | (j : ℕ) ≤ i } ∪ { j | (j : ℕ) > i } := by
  ext j
  simp only [Set.mem_setOf_eq, Set.mem_range, Set.mem_union]
  constructor
  · rintro ⟨k, rfl⟩
    rw [succAbove_eq_of_lt_succ]
    · simp
    · exact lt_of_le_of_lt (Nat.le_of_lt_succ k.2) (Nat.lt_succ_self _)
  · intro h
    cases' h with h h
    · exact ⟨Fin.castSucc j, by simp [h]⟩
    · exact ⟨j.succ, by simp [succAbove_succ, h]⟩

theorem range_fin_succEmbedding {n : ℕ} :
    Set.range (Fin.succEmbedding : Fin n → Fin (n + 1)) = { i | (i : ℕ) ≠ 0 } := by
  ext x
  simp only [Fin.succEmbedding_apply_val, Set.mem_setOf_eq, Set.mem_range, Ne, Fin.val_zero]
  protected exact ⟨fun ⟨y, hy⟩ => by rw [← hy]; exact y.2.ne', fun hx => ⟨x.pred, by simp [hx]⟩⟩

@[simp]
theorem range_fin_succAboveEmbedding {n : ℕ} (i : Fin (n + 1)) :
    Set.range i.succAboveEmb = {j | j ≠ i} := by
  simp only [Set.ext_iff, Set.mem_setOf_eq, Set.mem_range, Fin.exists_fin_succAbove,
    Fin.succAboveEmb_apply, Ne, Fin.succAbove_ne_zero]
  rfl

@[simp]
theorem range_fin_succAboveEmb {n : ℕ} (i : Fin (n + 1)) :
    Set.range (Fin.succAboveEmb i) = { i }ᶜ := by
  rw [← range_fin_succAboveEmbedding, Set.compl_setOf]
  rfl

theorem exists_succAbove_eq {x y : Fin (n + 1)} (h : x ≠ y) : ∃ z, y.succAbove z = x := by
  obtain h | h := Fin.lt_or_lt_of_ne h
  · exact ⟨x.castPred y ⟨h.le, h.trans y.2⟩, by simp⟩
  · exact ⟨x.pred y ⟨h.le, h.trans y.2⟩, by simp⟩


theorem exists_succAbove_eq_of_lt {x y : Fin (n + 1)} (h : x < y) : ∃ z, y.succAbove z = x := by
  simpa [succAbove_of_castSucc_lt _ _ h] using exists_castSucc_eq_of_lt h


theorem exists_succAbove_eq_of_gt {x y : Fin (n + 1)} (h : x < y) : ∃ z, z.succAbove y = x := by
  simpa [succAbove_of_le_castSucc _ _ h.le] using exists_castSucc_eq_of_lt h


theorem exists_succAbove_eq_of_le {x y : Fin (n + 1)} (h : y ≤ x) : ∃ z, z.succAbove y = x := by
  simpa [succAbove_of_le_castSucc _ _ h] using exists_castSucc_eq_of_le h


theorem exists_predAbove_eq_of_lt {x y : Fin (n + 1)} (h : x < y) : ∃ z, z.predAbove y = x := by
  simpa [predAbove_of_castSucc_lt _ _ h] using exists_castSucc_eq_of_lt h


theorem exists_predAbove_eq_of_le {x y : Fin (n + 1)} (h : y ≤ x) : ∃ z, z.predAbove y = x := by
  simpa [predAbove_of_le_castSucc _ _ h] using exists_castSucc_eq_of_le h


theorem predAbove_left_inj {x y : Fin (n + 1)} {i : Fin n} (hx : x ≠ 0) (hy : y ≠ 0) :
    x.predAbove i = y.predAbove i

Attempt failure.

Working on Mathlib/Data/List/ReduceOption.lean - 2024-09-09 00:48:44.362218.
---77/200---
For theorem List.reduceOption_length_eq_iff in Mathlib/Data/List/ReduceOption.lean:
theorem reduceOption_length_eq_iff {l : List (Option α)} :
    l.reduceOption.length = l.length ↔ ∀ x ∈ l, Option.isSome x 


Original valid proof:
:= by
  rw [reduceOption_length_eq, List.filter_length_eq_length]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
→ x.isSome := by
  induction' l with hd tl hl
  · simp
  simp only [List.reduceOption]
  cases hd <;> simp [List.length, Nat.succ_eq_add_one, Nat.add_left_cancel, hl]


theorem reduceOption_length_lt_iff {l : List (Option α)} :
    l.reduceOption.length < l.length ↔ none ∈ l := by
  rw [Nat.lt_iff_le_and_ne, and_iff_right (reduceOption_length_le l), Ne,
    reduceOption_length_eq_iff]
  induction l <;> simp [*]
  rw [@eq_comm _ none, ← Option.not_isSome_iff_eq_none, Decidable.imp_iff_not_or]


theorem reduceOption_singleton (x : Option α) : [x].reduceOption = x.toList := by cases x <;> rfl


theorem reduceOption_concat (l : List (Option α)) (x : Option α) :
    (l.concat x).reduceOption = l.reduceOption.concat x.toList := by
  induction' l with hd tl hl generalizing x
  · cases x <;> simp [Option.toList]
  · simp only [concat_eq_append] at hl
    cases hd <;> simp [hl, List.reduceOption]


theorem reduceOption_join (l : List (List (Option α))) :
    l.join.reduceOption = (l.map reduceOption).join := by
  induction' l with hd tl hl
  · simp
  · simpa [join] using congr_arg (· ++ ·) hl


theorem reduceOption_bind (l : List (Option α)) (f : α → List (Option β)) :
    (l.bind f).reduceOption = l.reduceOption.bind fun x => (f x.get!).reduceOption := by
  induction' l with hd tl hl
  · simp
  · cases hd <;>
      simpa [Option.bind, List.reduceOption, List.bind] using Eq.symm (cons_bind _ _ _)


theorem reduceOption_map (l : List (Option α)) (f : α → Option β) :
    (l.map (Option.map f)).reduceOption = (l.reduceOption.map f).filter Option.isSome := by
  induction' l with hd tl hl
  · simp
  · cases hd <;> simp [hl]


theorem reduceOption_filterMap (l : List (Option α)) (f : α → Option β) :
    (l.filterMap f).reduceOption = l.reduceOption.filterMap fun x => x.map f := by
  induction' l with hd tl hl
  · rfl
  · cases hd <;> simp [hl]


theorem reduceOption_filter (l : List (Option α)) (p : α → Bool) :
    l.filter (p <$> ·) = (l.reduceOption.filter p).map some := by
  induction' l with hd tl hl
  · rfl
  · cases hd <;> simp [hl]


theorem reduceOption_filterMap (l : List (Option α)) (f : α → Option β) :
    l.filterMap f = (l.reduceOption.filterMap fun x => x.map f).map some := by
  induction' l with hd tl hl
  · rfl
  · cases hd <;> simp [hl]


theorem reduceOption_filterMap_some (l : List (Option α)) (f : α → Option β) :
    l.filterMap (some <$> f) = (l.reduceOption.filterMap f).map some := by
  simp_rw [← Option.some_map, reduceOption_filterMap, Option.map_filterMap, Option.map_some']


theorem reduceOption_filter_some (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filterMap_some l Option.isSome


theorem reduceOption_filter_isSome (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_some l


theorem reduceOption_filter_isSome' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome l


theorem reduceOption_filter_isSome'' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome' l


theorem reduceOption_filter_isSome''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome'' l


theorem reduceOption_filter_isSome'''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome''' l


theorem reduceOption_filter_isSome''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome'''' l


theorem reduceOption_filter_isSome'''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome'''' l


theorem reduceOption_filter_isSome''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome'''''' l


theorem reduceOption_filter_isSome'''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome''''''' l


theorem reduceOption_filter_isSome''''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome'''''''' l


theorem reduceOption_filter_isSome'''''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome''''''''' l


theorem reduceOption_filter_isSome''''''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome'''''''''' l


theorem reduceOption_filter_isSome'''''''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome''''''''''' l


theorem reduceOption_filter_isSome''''''''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome'''''''''''' l


theorem reduceOption_filter_isSome'''''''''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome''''''''''''' l


theorem reduceOption_filter_isSome''''''''''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome'''''''''''''' l


theorem reduceOption_filter_isSome'''''''''''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome''''''''''''''' l


theorem reduceOption_filter_isSome''''''''''''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome'''''''''''''''' l


theorem reduceOption_filter_isSome'''''''''''''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter Option.isSome).map some :=
  reduceOption_filter_isSome''''''''''''''''' l


theorem reduceOption_filter_isSome''''''''''''''''''' (l : List (Option α)) :
    l.filter Option.isSome = (l.reduceOption.filter

Attempt failure.

Working on Mathlib/Data/Multiset/Basic.lean - 2024-09-09 00:48:50.517344.
---78/200---
For theorem Multiset.count_map_eq_count in Mathlib/Data/Multiset/Basic.lean:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x 


Original valid proof:
:= by
  suffices (filter (fun a : α => f x = f a) s).count x = card (filter (fun a : α => f x = f a) s) by
    rw [count, countP_map, ← this]
    exact count_filter_of_pos <| rfl
  · rw [eq_replicate_card.2 fun b hb => (hf H (mem_filter.1 hb).left _).symm]
    · simp only [count_replicate, eq_self_iff_true, if_true, card_replicate]
    · simp only [mem_filter, beq_iff_eq, and_imp, @eq_comm _ (f x), imp_self, implies_true]


Verifying proof (Commit e609eeb4638d90bf8185c6ea72c5d41e94387a3b):
↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x ↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x ↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x ↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x ↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x ↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x ↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x ↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x ↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x ↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x ↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x ↔ x ∈ s :=
  Quot.inductionOn s fun l => by
    simp only [quot_mk_to_coe'', coe_map, mem_coe, coe_count]
    apply List.count_map_eq_count' f l
    rwa [Set.InjOn, Set.preimage_coe_eq_preimage_coe_iff] at hf

Repaired Proof:
theorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)
    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H :

Attempt failure.

Working on Mathlib/Data/Nat/Pairing.lean - 2024-09-09 00:49:06.272546.
---79/200---
For theorem Nat.pair_lt_max_add_one_sq in Mathlib/Data/Nat/Pairing.lean:
theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 


Original valid proof:
:= by
  simp only [pair, Nat.pow_two, Nat.mul_add, Nat.add_mul, Nat.mul_one, Nat.one_mul, Nat.add_assoc]
  split_ifs <;> simp [Nat.max_eq_left, Nat.max_eq_right, Nat.le_of_lt,  not_lt.1, *] <;> omega


Verifying proof (Commit e340032faef5a8ec252e988e6968b4f6b30277da):
∨ pair m n = (max m n + 1) ^ 2 - 1 := by
  have h₁ : pair m n ≤ max m n * (max m n + 1) := pair_le_max_mul_max_add_one m n
  have h₂ : max m n * (max m n + 1) ≤ (max m n + 1) ^ 2 - 1 := by
    rw [sq, ← mul_add]
    exact Nat.mul_le_mul_right (max m n + 1) (le_add_left _ _)
  exact (lt_or_eq_of_le h₁).imp_left fun h => h.trans_le h₂

Repaired Proof:
theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 ∨ pair m n = (max m n + 1) ^ 2 - 1 := by
  have h₁ : pair m n ≤ max m n * (max m n + 1) := pair_le_max_mul_max_add_one m n
  have h₂ : max m n * (max m n + 1) ≤ (max m n + 1) ^ 2 - 1 := by
    rw [sq, ← mul_add]
    exact Nat.mul_le_mul_right (max m n + 1) (le_add_left _ _)
  exact (lt_or_eq_of_le h₁).imp_left fun h => h.trans_le h₂

Repaired Proof:
theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 ∨ pair m n = (max m n + 1) ^ 2 - 1 := by
  have h₁ : pair m n ≤ max m n * (max m n + 1) := pair_le_max_mul_max_add_one m n
  have h₂ : max m n * (max m n + 1) ≤ (max m n + 1) ^ 2 - 1 := by
    rw [sq, ← mul_add]
    exact Nat.mul_le_mul_right (max m n + 1) (le_add_left _ _)
  exact (lt_or_eq_of_le h₁).imp_left fun h => h.trans_le h₂

Repaired Proof:
theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 ∨ pair m n = (max m n + 1) ^ 2 - 1 := by
  have h₁ : pair m n ≤ max m n * (max m n + 1) := pair_le_max_mul_max_add_one m n
  have h₂ : max m n * (max m n + 1) ≤ (max m n + 1) ^ 2 - 1 := by
    rw [sq, ← mul_add]
    exact Nat.mul_le_mul_right (max m n + 1) (le_add_left _ _)
  exact (lt_or_eq_of_le h₁).imp_left fun h => h.trans_le h₂

Repaired Proof:
theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 ∨ pair m n = (max m n + 1) ^ 2 - 1 := by
  have h₁ : pair m n ≤ max m n * (max m n + 1) := pair_le_max_mul_max_add_one m n
  have h₂ : max m n * (max m n + 1) ≤ (max m n + 1) ^ 2 - 1 := by
    rw [sq, ← mul_add]
    exact Nat.mul_le_mul_right (max m n + 1) (le_add_left _ _)
  exact (lt_or_eq_of_le h₁).imp_left fun h => h.trans_le h₂

Repaired Proof:
theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 ∨ pair m n = (max m n + 1) ^ 2 - 1 := by
  have h₁ : pair m n ≤ max m n * (max m n + 1) := pair_le_max_mul_max_add_one m n
  have h₂ : max m n * (max m n + 1) ≤ (max m n + 1) ^ 2 - 1 := by
    rw [sq, ← mul_add]
    exact Nat.mul_le_mul_right (max m n + 1) (le_add_left _ _)
  exact (lt_or_eq_of_le h₁).imp_left fun h => h.trans_le h₂

Repaired Proof:
theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 ∨ pair m n = (max m n + 1) ^ 2 - 1 := by
  have h₁ : pair m n ≤ max m n * (max m n + 1) := pair_le_max_mul_max_add_one m n
  have h₂ : max m n * (max m n + 1) ≤ (max m n + 1) ^ 2 - 1 := by
    rw [sq, ← mul_add]
    exact Nat.mul_le_mul_right (max m n + 1) (le_add_left _ _)
  exact (lt_or_eq_of_le h₁).imp_left fun h => h.trans_le h₂

Repaired Proof:
theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 ∨ pair m n = (max m n + 1) ^ 2 - 1 := by
  have h₁ : pair m n ≤ max m n * (max m n + 1) := pair_le_max_mul_max_add_one m n
  have h₂ : max m n * (max m n + 1) ≤ (max m n + 1) ^ 2 - 1 := by
    rw [sq, ← mul_add]
    exact Nat.mul_le_mul_right (max m n + 1) (le_add_left _ _)
  exact (lt_or_eq_of_le h₁).imp_left fun h => h.trans_le h₂

Repaired Proof:
theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 ∨ pair m n = (max m n + 1) ^ 2 - 1 := by
  have h₁ : pair m n ≤ max m n * (max m n + 1) := pair_le_max_mul_max_add_one m n
  have h₂ : max m n * (max m n + 1) ≤ (max m n + 1) ^ 2 - 1 := by
    rw [sq, ← mul_add]
    exact Nat.mul_le_mul_right (max m n + 1) (le_add_left _ _)
  exact (lt_or_eq_of_le h₁).imp_left fun h => h.trans_le h₂

Repaired Proof:
theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 ∨ pair m n = (max m n + 1) ^ 2 - 1 := by
  have h₁ : pair m n ≤ max m n * (max m n + 1) := pair_le_max_mul_max_add_one m n
  have h₂ : max m n * (max m n + 1) ≤ (max m n + 1) ^ 2 - 1 := by
    rw [sq, ← mul_add]
    exact Nat.mul_le_mul_right (max m n + 1) (le_add_left _ _)
  exact (lt_or_eq_of_le h₁).imp_left fun h => h.trans_le h₂

Repaired Proof:
theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 ∨ pair m n = (max m n + 1) ^ 2 - 1 := by
  have h₁ : pair m n ≤ max m n * (max m n

Attempt failure.

Working on Mathlib/Data/Seq/Parallel.lean - 2024-09-09 00:49:12.748249.
---80/200---
For theorem Computation.exists_of_mem_parallel in Mathlib/Data/Seq/Parallel.lean:
theorem exists_of_mem_parallel {S : WSeq (Computation α)} {a} (h : a ∈ parallel S) :
    ∃ c ∈ S, a ∈ c 


Original valid proof:
:= by
  suffices
    ∀ C, a ∈ C → ∀ (l : List (Computation α)) (S),
      corec parallel.aux1 (l, S) = C → ∃ c, (c ∈ l ∨ c ∈ S) ∧ a ∈ c from
    let ⟨c, h1, h2⟩ := this _ h [] S rfl
    ⟨c, h1.resolve_left <| List.not_mem_nil _, h2⟩
  let F : List (Computation α) → Sum α (List (Computation α)) → Prop := by
    intro l a
    cases' a with a l'
    · exact ∃ c ∈ l, a ∈ c
    · exact ∀ a', (∃ c ∈ l', a' ∈ c) → ∃ c ∈ l, a' ∈ c
  have lem1 : ∀ l : List (Computation α), F l (parallel.aux2 l) := by
    intro l
    induction' l with c l IH <;> simp only [parallel.aux2, List.foldr]
    · intro a h
      rcases h with ⟨c, hn, _⟩
      exact False.elim <| List.not_mem_nil _ hn
    · simp only [parallel.aux2] at IH
      revert IH
      cases' List.foldr (fun c o =>
        match o with
        | Sum.inl a => Sum.inl a
        | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c)) (Sum.inr List.nil) l with a ls <;>
        intro IH <;>
        simp only [parallel.aux2]
      · rcases IH with ⟨c', cl, ac⟩
        exact ⟨c', List.Mem.tail _ cl, ac⟩
      · induction' h : destruct c with a c' <;> simp only [rmap]
        · refine ⟨c, List.mem_cons_self _ _, ?_⟩
          rw [destruct_eq_pure h]
          apply ret_mem
        · intro a' h
          rcases h with ⟨d, dm, ad⟩
          simp? at dm says simp only [List.mem_cons] at dm
          cases' dm with e dl
          · rw [e] at ad
            refine ⟨c, List.mem_cons_self _ _, ?_⟩
            rw [destruct_eq_think h]
            exact think_mem ad
          · cases' IH a' ⟨d, dl, ad⟩ with d dm
            cases' dm with dm ad
            exact ⟨d, List.Mem.tail _ dm, ad⟩
  intro C aC
  apply memRecOn aC <;> [skip; intro C' IH] <;> intro l S e <;> have e' := congr_arg destruct e <;>
    have := lem1 l <;> simp only [parallel.aux1, corec_eq, destruct_pure, destruct_think] at e' <;>
    revert this e' <;> cases' parallel.aux2 l with a' l' <;> intro this e' <;>
    [injection e' with h'; injection e'; injection e'; injection e' with h']
  · rw [h'] at this
    rcases this with ⟨c, cl, ac⟩
    exact ⟨c, Or.inl cl, ac⟩
  · induction' e : Seq.destruct S with a <;> rw [e] at h'
    · exact
        let ⟨d, o, ad⟩ := IH _ _ h'
        let ⟨c, cl, ac⟩ := this a ⟨d, o.resolve_right (WSeq.not_mem_nil _), ad⟩
        ⟨c, Or.inl cl, ac⟩
    · cases' a with o S'
      cases' o with c <;> simp [parallel.aux1] at h' <;> rcases IH _ _ h' with ⟨d, dl | dS', ad⟩
      · exact
          let ⟨c, cl, ac⟩ := this a ⟨d, dl, ad⟩
          ⟨c, Or.inl cl, ac⟩
      · refine ⟨d, Or.inr ?_, ad⟩
        rw [Seq.destruct_eq_cons e]
        exact Seq.mem_cons_of_mem _ dS'
      · simp at dl
        cases' dl with dc dl
        · rw [dc] at ad
          refine ⟨c, Or.inr ?_, ad⟩
          rw [Seq.destruct_eq_cons e]
          apply Seq.mem_cons
        · exact
            let ⟨c, cl, ac⟩ := this a ⟨d, dl, ad⟩
            ⟨c, Or.inl cl, ac⟩
      · refine ⟨d, Or.inr ?_, ad⟩
        rw [Seq.destruct_eq_cons e]
        exact Seq.mem_cons_of_mem _ dS'


Verifying proof (Commit 3c930599229893e1b6a931304cf4efff4a01b172):
∨ a ∈ destruct c :=
  let ⟨_, cs, c, _, e⟩ := exists_of_mem_bind h
  ⟨c, cs, e⟩

@[simp]
theorem parallel_pure_nil : parallel (pure nil : WSeq (Computation α)) = Computation.pure nil :=
  destruct_eq_pure <| by simp


@[simp]
theorem parallel_think (S : WSeq (Computation α)) :
    parallel (think S) = think (parallel S) :=
  destruct_eq_think <| by simp [parallel, bind_assoc, map_join]


@[simp]
theorem parallel_pure (s : WSeq α) : parallel (pure s) = pure s :=
  destruct_eq_pure <| by simp [parallel, bind_pure]


@[simp]
theorem parallel_think_empty : parallel (think empty) = pure [] :=
  destruct_eq_pure <| by simp [parallel, bind_pure]


@[simp]
theorem parallel_think_think (S : WSeq (Computation α)) :
    parallel (think (think S)) = think (parallel S) :=
  destruct_eq_think <| by simp [parallel, bind_assoc, map_join]


@[simp]
theorem parallel_append (S T : WSeq (Computation α)) :
    parallel (append S T) = append (parallel S) (parallel T) :=
  destruct_eq_append <| by simp [parallel, bind_assoc, map_join, join_append, bind_map]


@[simp]
theorem parallel_map (f : α → β) (S) : parallel (map f S) = map f (parallel S) :=
  destruct_eq_map <| by simp [parallel, bind_map, map_bind, map_map]


@[simp]
theorem parallel_bind (f : α → WSeq (Computation β)) (S) :
    parallel (bind S f) = bind (parallel S) fun c => parallel (c.map fun a => f a) :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_parallel (f : α → WSeq (Computation β)) (g : β → WSeq (Computation γ)) (S) :
    parallel (bind (parallel S) fun c => c.map fun a => bind (g a) fun b => pure (a, b))) =
      parallel (bind S fun a => parallel (g a)) :=
  destruct_eq_parallel <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_pure_bind (f : α → Computation β) (S) :
    parallel (bind S fun a => pure (f a)) = f <$> S :=
  destruct_eq_map <| by simp [parallel, bind_pure, bind_assoc, map_bind, bind_map, map_map]


@[simp]
theorem parallel_bind_bind (f : α → Computation β) (g : β → Computation γ) (S) :
    parallel (bind S fun a => bind (f a) (g ·))) = bind (parallel S) (g <$> f ·) :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_pure_bind' (f : α → WSeq (Computation β)) (g : β → Computation γ) (S) :
    parallel (bind S fun a => pure (f a) >>= g) = bind (parallel S) fun c => c.map fun a => g a :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_bind' (f : α → WSeq (Computation β)) (g : β → WSeq (Computation γ)) (S) :
    parallel (bind S fun a => (f a).bind (g ·)) = bind (parallel S) fun c => c.map fun a => g a :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_pure_bind'' (f : α → WSeq (Computation β)) (g : β → Computation γ) (S) :
    parallel (bind S fun a => (f a).bind (g ·) >>= pure) = bind (parallel S) fun c => c.map fun a => g a :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_bind'' (f : α → WSeq (Computation β)) (g : β → WSeq (Computation γ)) (S) :
    parallel (bind S fun a => (f a).bind (g ·) >>= bind pure (g ·)) =
      bind (parallel S) fun c => c.map fun a => g a :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_pure_bind''' (f : α → WSeq (Computation β)) (g : β → Computation γ) (S) :
    parallel (bind S fun a => (f a).bind (g ·) >>= pure) = bind (parallel S) fun c => c.map fun a => g a :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_bind''' (f : α → WSeq (Computation β)) (g : β → WSeq (Computation γ)) (S) :
    parallel (bind S fun a => (f a).bind (g ·) >>= bind pure (g ·)) =
      bind (parallel S) fun c => c.map fun a => g a :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_pure_bind'''' (f : α → Computation β) (g : β → Computation γ) (S) :
    parallel (bind S fun a => pure (f a) >>= g) = f <$> S >>= g :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_bind'''' (f : α → Computation β) (g : β → Computation γ) (S) :
    parallel (bind S fun a => (f a).bind g) = f <$> S >>= g :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_pure_bind''''' (f : α → WSeq (Computation β)) (g : β → Computation γ) (S) :
    parallel (bind S fun a => (f a).bind g >>= pure) = bind (parallel S) fun c => c.map fun a => g a :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_bind''''' (f : α → WSeq (Computation β)) (g : β → WSeq (Computation γ)) (S) :
    parallel (bind S fun a => (f a).bind g >>= bind pure (g ·)) =
      bind (parallel S) fun c => c.map fun a => g a :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_pure_bind'''''' (f : α → Computation β) (g : β → Computation γ) (S) :
    parallel (bind S fun a => pure (f a) >>= g) = f <$> S >>= g :=
  destruct_eq_bind <| by simp [parallel, bind_bind, map_bind, bind_map, bind_assoc, map_map]


@[simp]
theorem parallel_bind_bind'''''' (f :

Attempt failure.

Working on Mathlib/Data/Set/Basic.lean - 2024-09-09 00:49:19.829913.
---81/200---
For theorem Set.inter_subset_ite in Mathlib/Data/Set/Basic.lean:
theorem inter_subset_ite (t s s' : Set α) : s ∩ s' ⊆ t.ite s s' 


Original valid proof:
:=
  ite_same t (s ∩ s') ▸ ite_mono _ inter_subset_left inter_subset_right


Verifying proof (Commit 70dcc1355b9ce0a6754f8d809c95a171072d3aac):
∨ t.ite s s' ⊆ s ∩ s' :=
  (cond_subset_iff _).1 le_rfl


theorem ite_mono (t : Set α) {s₁ s₁' s₂ s₂' : Set α} (h₁ : s₁ ⊆ s₁') (h₂ : s₂ ⊆ s₂') :
    t.ite s₁ s₂ ⊆ t.ite s₁' s₂' :=
  union_subset_union (inter_subset_inter_left _ h₁) (inter_subset_inter_left _ h₂)


theorem ite_subset_union (t s s' : Set α) : t.ite s s' ⊆ s ∪ s' :=
  union_subset_union inter_subset_left diff_subset


@[simp]
theorem ite_empty (t s s' : Set α) : t.ite s ∅ = s \ t := by simp [Set.ite]


@[simp]
theorem ite_empty_right (t s : Set α) : t.ite s ∅ = s \ t := by simp [Set.ite]


@[simp]
theorem ite_compl (t s s' : Set α) : tᶜ.ite s s' = t.ite s' s := by
  rw [Set.ite, Set.ite, diff_compl, union_comm, diff_eq]


@[simp]
theorem ite_inter_self (t s s' : Set α) : t.ite (s ∩ s) s' = t.ite s s' := by
  rw [Set.ite, Set.ite, diff_inter_self_right, union_inter_distrib_right, inter_self, union_empty]


@[simp]
theorem ite_inter_compl_self (t s s' : Set α) : t.ite (s ∩ sᶜ) s' = t.ite ∅ s' := by
  rw [Set.ite, Set.ite, diff_compl, union_inter_distrib_right, inter_compl_self, union_empty]


@[simp]
theorem ite_compl_self (t s s' : Set α) : t.ite sᶜ s' = t.ite ∅ s' := by
  rw [← ite_inter_compl_self, inter_compl_self]


@[simp]
theorem ite_inter_self_left (t s s' : Set α) : t.ite (s ∩ s) s' = t.ite s s' := by
  rw [Set.ite, Set.ite, diff_inter, union_inter_distrib_right, diff_union_self, inter_assoc]


@[simp]
theorem ite_inter_self_right (t s s' : Set α) : t.ite s (s' ∩ s) = t.ite s s' := by
  rw [Set.ite, Set.ite, diff_inter, union_inter_distrib_left, diff_union_self, inter_assoc]


@[simp]
theorem ite_inter_eq_self_left (t s s' : Set α) : t.ite (s ∩ t) s' = t.ite s s' := by
  rw [Set.ite, Set.ite, diff_inter_self_right, union_empty]


@[simp]
theorem ite_inter_eq_self_right (t s s' : Set α) : t.ite s (s' ∩ t) = t.ite s s' := by
  rw [Set.ite, Set.ite, diff_inter_self_left, empty_union]


@[simp]
theorem ite_inter_eq_inter_ite (t s s' : Set α) : t.ite (s ∩ t) (s' ∩ t) = t.ite s s' ∩ t := by
  rw [Set.ite, Set.ite, diff_inter, union_inter_distrib_right, inter_assoc, inter_comm t,
    inter_assoc, inter_self, inter_union_distrib_left, diff_union_inter]


@[simp]
theorem ite_inter_eq_ite_inter (t s s' : Set α) : t.ite (s ∩ t) (s' ∩ t) = t.ite s s' ∩ t := by
  rw [Set.ite, Set.ite, diff_inter, union_inter_distrib_right, inter_assoc, inter_self,
    inter_union_distrib_left, diff_union_inter]


@[simp]
theorem ite_compl_inter_self (t s s' : Set α) : tᶜ.ite (s ∩ t) s' = tᶜ.ite s s' := by
  rw [Set.ite, Set.ite, diff_compl, union_empty, diff_eq, inter_comm t, inter_assoc]


@[simp]
theorem ite_inter_compl_self (t s s' : Set α) : t.ite (s ∩ tᶜ) s' = t.ite ∅ s' := by
  rw [Set.ite, Set.ite, diff_compl, inter_empty, union_empty]


@[simp]
theorem ite_inter_eq_ite_inter_compl (t s s' : Set α) : t.ite (s ∩ tᶜ) (s' ∩ t) = t.ite ∅ s' := by
  rw [Set.ite, Set.ite, diff_compl, inter_empty, union_empty, diff_eq, inter_comm t, inter_assoc]


@[simp]
theorem ite_inter_eq_ite_compl_inter (t s s' : Set α) : t.ite (s ∩ tᶜ) (s' ∩ t) = t.ite ∅ s' := by
  rw [Set.ite, Set.ite, diff_compl, inter_empty, union_empty, diff_eq, inter_comm t, inter_assoc]


@[simp]
theorem ite_compl_compl (t s s' : Set α) : tᶜ.ite sᶜ s'ᶜ = t.ite s' s := by
  rw [Set.ite, Set.ite, diff_compl, compl_inter, compl_union, compl_compl, compl_compl]


@[simp]
theorem ite_inter_compl_compl (t s s' : Set α) : t.ite (s ∩ sᶜ) (s' ∩ sᶜ) = t.ite (s' ∩ s) ∅ := by
  rw [Set.ite, Set.ite, diff_compl, inter_empty, union_empty, inter_assoc]


@[simp]
theorem ite_compl_inter_self (t s s' : Set α) : tᶜ.ite (s ∩ t) s' = tᶜ.ite s s' := by
  rw [Set.ite, Set.ite, diff_compl, union_empty, inter_comm t, inter_assoc]


@[simp]
theorem ite_inter_compl_self (t s s' : Set α) : t.ite (s ∩ tᶜ) s' = t.ite ∅ s' := by
  rw [Set.ite, Set.ite, diff_compl, inter_empty, union_empty]


@[simp]
theorem ite_inter_eq_ite_inter_compl (t s s' : Set α) : t.ite (s ∩ tᶜ) (s' ∩ t) = t.ite ∅ s' := by
  rw [Set.ite, Set.ite, diff_compl, inter_empty, union_empty, diff_eq, inter_comm t, inter_assoc]


@[simp]
theorem ite_inter_eq_ite_compl_inter (t s s' : Set α) : t.ite (s ∩ tᶜ) (s' ∩ t) = t.ite ∅ s' := by
  rw [Set.ite, Set.ite, diff_compl, inter_empty, union_empty, diff_eq, inter_comm t, inter_assoc]


@[simp]
theorem ite_inter_eq_inter_ite (t s s' : Set α) : t.ite (s ∩ t) (s' ∩ t) = t.ite s s' ∩ t := by
  rw [Set.ite, Set.ite, diff_inter_self_right, union_inter_distrib_right, inter_assoc, inter_self,
    inter_union_distrib_left, diff_union_inter]

Attempt failure.

Working on Mathlib/Data/Set/Subset.lean - 2024-09-09 00:49:31.996299.
---82/200---
For theorem Set.image_val_iInter in Mathlib/Data/Set/Subset.lean:
lemma image_val_iInter [Nonempty ι] : (↑(⋂ i, t i) : Set α) = ⋂ i, (↑(t i) : Set α) 


Original valid proof:
:=
  Subtype.val_injective.injOn.image_iInter_eq


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∪ ∅ := by
  rw [iInter, image_iUnion, ← image_univ, ← sInter_image, image_empty]

lemma image_val_iInter_eq [Nonempty ι] : (↑(⋂ i, t i) : Set α) = ⋂ i, (↑(t i) : Set α) := by
  rw [image_val_iInter, iInter_union_empty]

lemma image_val_sInter_subset : (⋂ t ∈ T, (t : Set α)).image f ⊆ ⋂ t ∈ T, (t : Set β).image f :=
  image_sInter_subset _

lemma image_val_sInter_eq (hT : T.Nonempty) : (⋂ t ∈ T, (t : Set α)).image f = ⋂ t ∈ T, (t : Set β).image f :=
  image_sInter_eq hT

lemma image_sInter_eq_iInter {T : Set (Set α)} (hT : T.Nonempty) :
    (⋂ t ∈ T, (t : Set α)).image f = ⋂ t ∈ T, (t : Set β).image f :=
  image_sInter_eq hT

lemma image_sInter_eq_iInter' {T : Set (Set α)} (hT : T.Nonempty) :
    (⋂ t ∈ T, (t : Set α)).image f = ⋂ t : T, (t : Set β).image f := by
  rw [image_sInter_eq_iInter hT]
  simp_rw [iInter, mem_setOf_eq]

lemma image_sInter_eq_iInter'' {T : Set (Set α)} (hT : T.Nonempty) {s : α → β} :
    (⋂ t ∈ T, (t : Set α)).image s = ⋂ t : T, (t : Set β).image s :=
  image_sInter_eq_iInter' hT

lemma image_sInter_eq_iInter_image [Nonempty ι] (S : ι → Set (Set α)) :
    (⋂ i, (S i : Set α)).image f = ⋂ i, ((S i).image f) := by
  rw [image_sInter_eq_iInter, ← iInter_image]

lemma image_sInter_eq_iInter_image' (S : ι → Set (Set α)) :
    (⋂ i, (S i : Set α)).image f = ⋂ i, ((S i).image f) :=
  image_sInter_eq_iInter_image _

lemma image_sInter_eq_iInter_image'' (S : ι → Set (Set α)) :
    (⋂ i, (S i : Set α)).image s = ⋂ i, ((S i).image s) :=
  image_sInter_eq_iInter_image _

lemma image_sInter_eq_iInter_bUnion (S : ι → Set (Set α)) :
    (⋂ i, (S i : Set α)).image f = ⋂ i, ⋃ t ∈ S i, (t : Set β).image f := by
  simp_rw [iInter_eq_iInter₂, iInter₂_image, mem_iUnion₂, iInter_exists, iInter_iUnion]

lemma image_sInter_eq_iInter_bUnion' (S : ι → Set (Set α)) :
    (⋂ i, (S i : Set α)).image s = ⋂ i, ⋃ t ∈ S i, (t : Set β).image s :=
  image_sInter_eq_iInter_bUnion _

lemma image_sInter_eq_iInter_bUnion'' (S : ι → Set (Set α)) :
    (⋂ i, (S i : Set α)).image f = ⋂ i, ⋃ t ∈ S i, (t : Set β).image f :=
  image_sInter_eq_iInter_bUnion _

lemma image_sInter_eq_iInter_bUnion_image (S : ι → Set (Set α)) :
    (⋂ i, (S i : Set α)).image f = ⋂ i, ((S i).image f) := by
  simp_rw [image_sInter_eq_iInter_bUnion, ← iUnion_image, ← iInter_image]

lemma image_sInter_eq_iInter_bUnion_image' (S : ι → Set (Set α)) :
    (⋂ i, (S i : Set α)).image f = ⋂ i, ((S i).image f) :=
  image_sInter_eq_iInter_bUnion_image _

lemma image_sInter_eq_iInter_bUnion_image'' (S : ι → Set (Set α)) :
    (⋂ i, (S i : Set α)).image s = ⋂ i, ((S i).image s) :=
  image_sInter_eq_iInter_bUnion_image _

lemma image_sInter_eq_iInter_image_union (S : ι → Set (Set α)) (T : Set α) :
    (⋂ i, (S i : Set α)).image f ∪ T.image f = ⋂ i, ((S i).image f ∪ T.image f) := by
  simp_rw [image_sInter_eq_iInter_bUnion, ← iUnion_union_distrib, ← iInter_union_distrib]

lemma image_sInter_eq_iInter_image_union' (S : ι → Set (Set α)) (T : Set α) :
    (⋂ i, (S i : Set α)).image f ∪ T.image f = ⋂ i, ((S i).image f ∪ T.image f) :=
  image_sInter_eq_iInter_image_union _ _

lemma image_sInter_eq_iInter_image_union'' (S : ι → Set (Set α)) (T : Set α) :
    (⋂ i, (S i : Set α)).image s ∪ T.image s = ⋂ i, ((S i).image s ∪ T.image s) :=
  image_sInter_eq_iInter_image_union _ _

lemma image_sInter_eq_iInter_bUnion_image_union (S : ι → Set (Set α)) (T : Set α) :
    (⋂ i, (S i : Set α)).image f ∪ T.image f = ⋂ i, ((S i).image f ∪ T.image f) := by
  simp_rw [image_sInter_eq_iInter_bUnion, ← iUnion_union_distrib, ← iInter_union_distrib]

lemma image_sInter_eq_iInter_bUnion_image_union' (S : ι → Set (Set α)) (T : Set α) :
    (⋂ i, (S i : Set α)).image f ∪ T.image f = ⋂ i, ((S i).image f ∪ T.image f) :=
  image_sInter_eq_iInter_bUnion_image_union _ _

lemma image_sInter_eq_iInter_bUnion_image_union'' (S : ι → Set (Set α)) (T : Set α) :
    (⋂ i, (S i : Set α)).image s ∪ T.image s = ⋂ i, ((S i).image s ∪ T.image s) :=
  image_sInter_eq_iInter_bUnion_image_union _ _

lemma image_sInter_eq_iInter_image_union_image (S : ι → Set (Set α)) (T : Set α) :
    (⋂ i, (S i : Set α)).image f ∪ T.image f = ⋂ i, ((S i).image f ∪ T.image f) := by
  simp_rw [image_sInter_eq_iInter_bUnion, ← iUnion_union_distrib, ← iInter_union_distrib]

lemma image_sInter_eq_iInter_image_union_image' (S : ι → Set (Set α)) (T : Set α) :
    (⋂ i, (S i : Set α)).image f ∪ T.image f = ⋂ i, ((S i).image f ∪ T.image f) :=
  image_sInter_eq_iInter_image_union_image

Attempt failure.

Working on Mathlib/Dynamics/Ergodic/Conservative.lean - 2024-09-09 00:49:39.639527.
---83/200---
For theorem MeasureTheory.Conservative.frequently_measure_inter_ne_zero in Mathlib/Dynamics/Ergodic/Conservative.lean:
theorem frequently_measure_inter_ne_zero (hf : Conservative f μ) (hs : MeasurableSet s)
    (h0 : μ s ≠ 0) : ∃ᶠ m in atTop, μ (s ∩ f^[m] ⁻¹' s) ≠ 0 


Original valid proof:
:= by
  by_contra H
  simp only [not_frequently, eventually_atTop, Ne, Classical.not_not] at H
  rcases H with ⟨N, hN⟩
  induction' N with N ihN
  · apply h0
    simpa using hN 0 le_rfl
  rw [imp_false] at ihN
  push_neg at ihN
  rcases ihN with ⟨n, hn, hμn⟩
  set T := s ∩ ⋃ n ≥ N + 1, f^[n] ⁻¹' s
  have hT : MeasurableSet T :=
    hs.inter (MeasurableSet.biUnion (to_countable _) fun _ _ => hf.measurable.iterate _ hs)
  have hμT : μ T = 0 := by
    convert (measure_biUnion_null_iff <| to_countable _).2 hN
    rw [← inter_iUnion₂]
    rfl
  have : μ ((s ∩ f^[n] ⁻¹' s) \ T) ≠ 0 := by rwa [measure_diff_null hμT]
  rcases hf.exists_mem_iterate_mem ((hs.inter (hf.measurable.iterate n hs)).diff hT) this with
    ⟨x, ⟨⟨hxs, _⟩, hxT⟩, m, hm0, ⟨_, hxm⟩, _⟩
  refine hxT ⟨hxs, mem_iUnion₂.2 ⟨n + m, ?_, ?_⟩⟩
  · exact add_le_add hn (Nat.one_le_of_lt <| pos_iff_ne_zero.2 hm0)
  · rwa [Set.mem_preimage, ← iterate_add_apply] at hxm


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
∧ μ (s ∩ f^[m] ⁻¹' s) ≠ μ s := by
  by_contra! h
  simp only [frequently_atTop, not_exists, not_and, not_ne_iff] at h
  rcases hf.exists_gt (zero_lt_measure_ne_zero_iff.2 h0) with ⟨n, hn0, hns⟩
  refine hn0.not_le ?_
  have : ∀ m, μ (s ∩ f^[m] ⁻¹' s) = μ s := by
    intro m
    induction' m with m ih
    · rfl
    · rw [iterate_succ', ← inter_assoc, measure_eq_measure_preimage_add_measure_tsum_Ico_zpow
        (hf.tendsto_measure_inter_preimage_aux hs) (zero_le n), ih, h, h, tsum_zero, add_zero]
  rw [this n]
  exact hns rfl.le

Repaired Proof:
theorem frequently_measure_inter_ne_zero (hf : Conservative f μ) (hs : MeasurableSet s)
    (h0 : μ s ≠ 0) : ∃ᶠ m in atTop, μ (s ∩ f^[m] ⁻¹' s) ≠ 0 ∧ μ (s ∩ f^[m] ⁻¹' s) ≠ μ s := by
  by_contra! h
  simp only [frequently_atTop, not_exists, not_and, not_ne_iff] at h
  rcases hf.exists_gt (zero_lt_measure_ne_zero_iff.2 h0) with ⟨n, hn0, hns⟩
  refine hn0.not_le ?_
  have : ∀ m, μ (s ∩ f^[m] ⁻¹' s) = μ s := by
    intro m
    induction' m with m ih
    · rfl
    · rw [iterate_succ', ← inter_assoc, measure_eq_measure_preimage_add_measure_tsum_Ico_zpow
        (hf.tendsto_measure_inter_preimage_aux hs) (zero_le n), ih, h, h, tsum_zero, add_zero]
  rw [this n]
  exact hns rfl.le

Repaired Proof:
theorem frequently_ae_mem_imp_frequently_image_mem (hf : Conservative f μ) (hs : MeasurableSet s)
    (h0 : μ s ≠ 0) : ∃ᶠ x in ae μ, ∃ᶠ n in atTop, f^[n] x ∈ s := by
  simp only [frequently_ae_iff] at *
  rcases hf.frequently_measure_inter_ne_zero hs h0 with ⟨n, hn⟩
  filter_upwards [hf.ae_mem_imp_frequently_image_mem n] with x hx
  rcases hx hn.measure_ne_zero with ⟨m, hm⟩
  exact ⟨m, hm⟩

Repaired Proof:
theorem frequently_ae_mem_imp_frequently_image_mem (hf : Conservative f μ) (hs : MeasurableSet s)
    (h0 : μ s ≠ 0) : ∃ᶠ x in ae μ, ∃ᶠ n in atTop, f^[n] x ∈ s := by
  simp only [frequently_ae_iff] at *
  rcases hf.frequently_measure_inter_ne_zero hs h0 with ⟨n, hn⟩
  filter_upwards [hf.ae_mem_imp_frequently_image_mem n] with x hx
  rcases hx hn.measure_ne_zero with ⟨m, hm⟩
  exact ⟨m, hm⟩

Repaired Proof:
theorem frequently_ae_mem_imp_frequently_image_mem (hf : Conservative f μ) (hs : MeasurableSet s)
    (h0 : μ s ≠ 0) : ∃ᶠ x in ae μ, ∃ᶠ n in atTop, f^[n] x ∈ s := by
  simp only [frequently_ae_iff] at *
  rcases hf.frequently_measure_inter_ne_zero hs h0 with ⟨n, hn⟩
  filter_upwards [hf.ae_mem_imp_frequently_image_mem n] with x hx
  rcases hx hn.measure_ne_zero with ⟨m, hm⟩
  exact ⟨m, hm⟩

Repaired Proof:
theorem frequently_ae_mem_imp_frequently_image_mem (hf : Conservative f μ) (hs : MeasurableSet s)
    (h0 : μ s ≠ 0) : ∃ᶠ x in ae μ, ∃ᶠ n in atTop, f^[n] x ∈ s := by
  simp only [frequently_ae_iff] at *
  rcases hf.frequently_measure_inter_ne_zero hs h0 with ⟨n, hn⟩
  filter_upwards [hf.ae_mem_imp_frequently_image_mem n] with x hx
  rcases hx hn.measure_ne_zero with ⟨m, hm⟩
  exact ⟨m, hm⟩

Repaired Proof:
theorem frequently_ae_mem_imp_frequently_image_mem (hf : Conservative f μ) (hs : MeasurableSet s)
    (h0 : μ s ≠ 0) : ∃ᶠ x in ae μ, ∃ᶠ n in atTop, f^[n] x ∈ s := by
  simp only [frequently_ae_iff] at *
  rcases hf.frequently_measure_inter_ne_zero hs h0 with ⟨n, hn⟩
  filter_upwards [hf.ae_mem_imp_frequently_image_mem n] with x hx
  rcases hx hn.measure_ne_zero with ⟨m, hm⟩
  exact ⟨m, hm⟩

Repaired Proof:
theorem frequently_ae_mem_imp_frequently_image_mem (hf : Conservative f μ) (hs : MeasurableSet s)
    (h0 : μ s ≠ 0) : ∃ᶠ x in ae μ, ∃ᶠ n in atTop, f^[n] x ∈ s := by
  simp only [frequently_ae_iff] at *
  rcases hf.frequently_measure_inter_ne_zero hs h0 with ⟨n, hn⟩
  filter_upwards [hf.ae_mem_imp_frequently_image_mem n] with x hx
  rcases hx hn.measure_ne_zero with ⟨m, hm⟩
  exact ⟨m, hm⟩

Repaired Proof:
theorem frequently_ae_mem_imp_frequently_image_mem (hf : Conservative f μ) (hs : MeasurableSet s)
    (h0 : μ s ≠ 0) : ∃ᶠ x in ae μ, ∃ᶠ n in atTop, f^[n] x ∈ s := by
  simp only [frequently_ae_iff] at *
  rcases hf.frequently_measure_inter_ne_zero hs h0 with ⟨n, hn⟩
  filter_upwards [hf.ae_mem_imp_frequently_image_mem n] with x hx
  rcases hx hn.measure_ne_zero with ⟨m, hm⟩
  exact ⟨m, hm⟩

Repaired Proof:
theorem frequently_ae_mem_imp_frequently_image_mem (hf : Conservative f μ) (hs : MeasurableSet s)
    (h0 : μ s ≠ 0) : ∃ᶠ x in ae μ, ∃ᶠ n in atTop, f^[n] x ∈ s := by
  simp only [frequently_ae_iff] at *
  rcases hf.frequently_measure_inter_ne_zero hs h0 with ⟨n, hn⟩
  filter_upwards [hf.ae_mem_imp_frequently_image_mem n] with x hx
  rcases hx hn.measure_ne_zero with ⟨m, hm⟩
  exact ⟨m, hm�

Attempt failure.

Working on Mathlib/Dynamics/OmegaLimit.lean - 2024-09-09 00:49:50.519802.
---84/200---
For theorem nonempty_omegaLimit_of_isCompact_absorbing in Mathlib/Dynamics/OmegaLimit.lean:
theorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set β} (hc₁ : IsCompact c)
    (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) (hs : s.Nonempty) : (ω f ϕ s).Nonempty 


Original valid proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rw [omegaLimit_eq_iInter_inter _ _ _ hv₁]
  apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed
  · rintro ⟨u₁, hu₁⟩ ⟨u₂, hu₂⟩
    use ⟨u₁ ∩ u₂, inter_mem hu₁ hu₂⟩
    constructor
    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)
  · intro u
    have hn : (image2 ϕ (u ∩ v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hv₁)) hs
    exact hn.mono subset_closure
  · intro
    apply hc₁.of_isClosed_subset isClosed_closure
    calc
      _ ⊆ closure (image2 ϕ v s) := closure_mono (image2_subset inter_subset_right Subset.rfl)
      _ ⊆ c := hv₂
  · exact fun _ ↦ isClosed_closure


Verifying proof (Commit ffb5dddeb20329610a2c898c4125ae8bea987862):
 :=
  let ⟨_, hn⟩ := exists_mem_of_nonempty_omegaLimit hc₁ hc₂ hs
  ⟨_, hn⟩

theorem isCompact_omegaLimit [R1Space β] [T2Space β] [CompactSpace β]
    {c : Set β} (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c)
    (hs : s.Nonempty) : IsCompact (ω f ϕ s) := by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases nonempty_omegaLimit_of_isCompact_absorbing hc₁ hc₂ hs with ⟨_, hxω⟩
  have hcs : IsClosed (ω f ϕ s) := isClosed_omegaLimit hv₁ hv₂
  exact hc₁.of_isClosed_subset hcs hxω (closure_minimal hxω hcs)

theorem tendsto_nhds_omegaLimit_of_cauchySeq [CompleteSpace β] [T2Space β]
    (cauchy : CauchySeq (ω f ϕ s)) : Tendsto (ω f ϕ s) f (𝓝 (ω f ϕ s)) := by
  rcases cauchy.nonempty_of_frequently with ⟨x, hx⟩
  refine tendsto_nhds_of_cauchySeq_of_subseq (cauchySeq_omegaLimit hx) ?_
  have h_subseq : ∃ (u : ℕ → Set α) (φ : ℕ → ℕ), StrictMono φ ∧
      (∀ n, u n ∈ f) ∧ ∀ n, closure (image2 ϕ (u n) s) ⊆ ω f ϕ s := by
    rcases cauchy.subseq_mem with ⟨u, hu_mem, hu_subseq⟩
    rcases mem_nhds_iff.mp (isOpen_omegaLimit.mem_nhds hx) with ⟨v, hv_sub, hv_open, hxv⟩
    rcases mem_nhds_iff.mp (isOpen_omegaLimit.mem_nhds (omegaLimit_subset_of_frequently hx hu_subseq))
      with ⟨w, hw_sub, hw_open, hxw⟩
    rcases exists_mem_nhds_isClosed_subset (hu_mem 0) (hv_open.inter hw_open)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨a, ha, ha_closed⟩
    rcases exists_mem_nhds_isClosed_subset hxv (hw_open.inter ha_closed)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨b, hb, hb_closed⟩
    rcases exists_mem_nhds_isClosed_subset hxw (isClosed_omegaLimit.inter hb_closed)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨c, hc, hc_closed⟩
    rcases exists_mem_nhds_isClosed_subset (hu_mem 1) (hv_open.inter hw_open)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨d, hd, hd_closed⟩
    rcases exists_mem_nhds_isClosed_subset hxv (hw_open.inter hd_closed)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨e, he, he_closed⟩
    rcases exists_mem_nhds_isClosed_subset hxw (isClosed_omegaLimit.inter he_closed)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨f, hf, hf_closed⟩
    refine ⟨fun n ↦ if n = 0 then a else if n = 1 then b else if n = 2 then c else if n = 3 then d else f,
      fun n ↦ if n = 0 then 0 else if n = 1 then 1 else if n = 2 then 2 else if n = 3 then 3 else 4,
      ?_, ?_, ?_⟩
    · intro n m hnm
      simp only [fun i ↦ if i = 0 then a else if i = 1 then b else if i = 2 then c else if i = 3 then d else f]
      split_ifs with h₁ h₂ h₃ h₄ h₅ h₆ h₇ h₈ h₉ h₁₀ <;> try linarith
      simp only [fun i ↦ if i = 0 then 0 else if i = 1 then 1 else if i = 2 then 2 else if i = 3 then 3 else 4]
      split_ifs with h₁ h₂ h₃ h₄ h₅ h₆ h₇ h₈ h₉ h₁₀ <;> try linarith
      exact (lt_irrefl _ (lt_trans hnm h₁₀)).elim
    · intro n
      split_ifs with h₁ h₂ h₃ h₄ h₅ <;> simp [h₁, h₂, h₃, h₄, h₅, hu_mem]
    · intro n
      simp only [fun i ↦ if i = 0 then a else if i = 1 then b else if i = 2 then c else if i = 3 then d else f]
      split_ifs with h₁ h₂ h₃ h₄ h₅ h₆ h₇ h₈ h₉ h₁₀ <;> try linarith
      simp only [fun i ↦ if i = 0 then 0 else if i = 1 then 1 else if i = 2 then 2 else if i = 3 then 3 else 4]
      split_ifs with h₁ h₂ h₃ h₄ h₅ h₆ h₇ h₈ h₉ h₁₀ <;> try linarith
      refine closure_minimal ?_ (isClosed_omegaLimit.inter hb_closed).inter (isClosed_omegaLimit.inter he_closed)
      refine Subset.trans ?_ (inter_subset_left _ _)
      refine Subset.trans ?_ (inter_subset_right _ _)
      exact Subset.rfl
  rcases h_subseq with ⟨u, φ, hφ, hu_mem, hu_sub⟩
  refine tendsto_nhds_of_cauchySeq_of_subseq (cauchySeq_omegaLimit hx) ?_
  refine tendsto_nhds_of_cauchySeq_of_subseq (cauchySeq_of_tendsto_nhds (tendsto_map.comp
    (tendsto_nhds_of_cauchySeq_of_subseq (cauchySeq_omegaLimit hx) ?_)) ?_) ?_
  · intro n
    simpa only [tendsto_map'_iff, Function.comp_def] using hu_mem (φ n)
  · intro n
    simpa only [tendsto_map'_iff, Function.comp_def] using hu_sub n
  · exact tendsto_map

Repaired Proof:
theorem tendsto_nhds_omegaLimit_of_cauchySeq [CompleteSpace β] [T2Space β]
    (cauchy : CauchySeq (ω f ϕ s)) : Tendsto (ω f ϕ s) f (𝓝 (ω f ϕ s)) := by
  rcases cauchy.nonempty_of_frequently with ⟨x, hx⟩
  refine tendsto_nhds_of_cauchySeq_of_subseq (cauchySeq_omegaLimit hx) ?_
  have h_subseq : ∃ (u : ℕ → Set α) (φ : ℕ → ℕ), StrictMono φ ∧
      (∀ n, u n ∈ f) ∧ ∀ n, closure (image2 ϕ (u n) s) ⊆ ω f ϕ s := by
    rcases cauchy.subseq_mem with ⟨u, hu_mem, hu_subseq⟩
    rcases mem_nhds_iff.mp (isOpen_omegaLimit.mem_nhds hx) with ⟨v, hv_sub, hv_open, hxv⟩
    rcases mem_nhds_iff.mp (isOpen_omegaLimit.mem_nhds (omegaLimit_subset_of_frequently hx hu_subseq))
     

Attempt failure.

Working on Mathlib/Dynamics/PeriodicPts.lean - 2024-09-09 00:50:00.576753.
---85/200---
For theorem Function.periodicOrbit_apply_iterate_eq in Mathlib/Dynamics/PeriodicPts.lean:
theorem periodicOrbit_apply_iterate_eq (hx : x ∈ periodicPts f) (n : ℕ) :
    periodicOrbit f (f^[n] x) = periodicOrbit f x 


Original valid proof:
:=
  Eq.symm <| Cycle.coe_eq_coe.2 <| .intro n <|
    List.ext_get (by simp [minimalPeriod_apply_iterate hx]) fun m _ _ ↦ by
      simp [List.getElem_rotate, iterate_add_apply]


Verifying proof (Commit 0185583b06b06956b00d879ca9810cf6e8439166):
∘ fun i => n + i := by
  obtain ⟨m, hm⟩ := (mem_periodicPts.1 hx).exists_pow_eq
  have hm' : (f^[m] x) ∈ periodicPts f := mem_periodicPts.2 ⟨m, hm⟩
  have hm'' : ∀ k, (f^[k + m] x = f^[k] (f^[m] x)) := fun k =>
    congr_arg _ (Function.iterate_add_apply f k m x).symm
  ext y
  simp only [Set.mem_setOf_eq, Function.comp_apply]
  constructor
  · rintro ⟨n, rfl⟩
    simp only [Function.iterate_succ', Function.comp_apply]
    refine' ⟨n, hm'' _⟩
  · rintro ⟨n, rfl⟩
    simp only [Function.comp_apply, Function.iterate_add_apply]
    exact ⟨n + m, hm⟩

Repaired Proof:
theorem periodicOrbit_apply_iterate_eq (hx : x ∈ periodicPts f) (n : ℕ) :
    periodicOrbit f (f^[n] x) = periodicOrbit f x ∘ fun i => n + i := by
  obtain ⟨m, hm⟩ := (mem_periodicPts.1 hx).exists_pow_eq
  have hm' : (f^[m] x) ∈ periodicPts f := mem_periodicPts.2 ⟨m, hm⟩
  have hm'' : ∀ k, (f^[k + m] x = f^[k] (f^[m] x)) := fun k =>
    congr_arg _ (Function.iterate_add_apply f k m x).symm
  ext y
  simp only [Set.mem_setOf_eq, Function.comp_apply]
  constructor
  · rintro ⟨n, rfl⟩
    simp only [Function.iterate_succ', Function.comp_apply]
    refine ⟨n, hm'' _⟩
  · rintro ⟨n, rfl⟩
    simp only [Function.comp_apply, Function.iterate_add_apply]
    exact ⟨n + m, hm⟩

Repaired Proof:
theorem periodicOrbit_apply_iterate_eq (hx : x ∈ periodicPts f) (n : ℕ) :
    periodicOrbit f (f^[n] x) = periodicOrbit f x ∘ fun i => n + i := by
  obtain ⟨m, hm⟩ := (mem_periodicPts.1 hx).exists_pow_eq
  have hm' : (f^[m] x) ∈ periodicPts f := mem_periodicPts.2 ⟨m, hm⟩
  have hm'' : ∀ k, (f^[k + m] x = f^[k] (f^[m] x)) := fun k =>
    congr_arg _ (Function.iterate_add_apply f k m x).symm
  ext y
  simp only [Set.mem_setOf_eq, Function.comp_apply]
  constructor
  · rintro ⟨n, rfl⟩
    simp only [Function.iterate_succ', Function.comp_apply]
    refine ⟨n, hm'' _⟩
  · rintro ⟨n, rfl⟩
    simp only [Function.comp_apply, Function.iterate_add_apply]
    exact ⟨n + m, hm⟩

Repaired Proof:
theorem periodicOrbit_apply_iterate_eq (hx : x ∈ periodicPts f) (n : ℕ) :
    periodicOrbit f (f^[n] x) = periodicOrbit f x ∘ fun i => n + i := by
  obtain ⟨m, hm⟩ := (mem_periodicPts.1 hx).exists_pow_eq
  have hm' : (f^[m] x) ∈ periodicPts f := mem_periodicPts.2 ⟨m, hm⟩
  have hm'' : ∀ k, (f^[k + m] x = f^[k] (f^[m] x)) := fun k =>
    congr_arg _ (Function.iterate_add_apply f k m x).symm
  ext y
  simp only [Set.mem_setOf_eq, Function.comp_apply]
  constructor
  · rintro ⟨n, rfl⟩
    simp only [Function.iterate_succ', Function.comp_apply]
    refine ⟨n, hm'' _⟩
  · rintro ⟨n, rfl⟩
    simp only [Function.comp_apply, Function.iterate_add_apply]
    exact ⟨n + m, hm⟩

Repaired Proof:
theorem periodicOrbit_apply_iterate_eq (hx : x ∈ periodicPts f) (n : ℕ) :
    periodicOrbit f (f^[n] x) = periodicOrbit f x ∘ fun i => n + i := by
  obtain ⟨m, hm⟩ := (mem_periodicPts.1 hx).exists_pow_eq
  have hm' : (f^[m] x) ∈ periodicPts f := mem_periodicPts.2 ⟨m, hm⟩
  have hm'' : ∀ k, (f^[k + m] x = f^[k] (f^[m] x)) := fun k =>
    congr_arg _ (Function.iterate_add_apply f k m x).symm
  ext y
  simp only [Set.mem_setOf_eq, Function.comp_apply]
  constructor
  · rintro ⟨n, rfl⟩
    simp only [Function.iterate_succ', Function.comp_apply]
    refine ⟨n, hm'' _⟩
  · rintro ⟨n, rfl⟩
    simp only [Function.comp_apply, Function.iterate_add_apply]
    exact ⟨n + m, hm⟩

Repaired Proof:
theorem periodicOrbit_apply_iterate_eq (hx : x ∈ periodicPts f) (n : ℕ) :
    periodicOrbit f (f^[n] x) = periodicOrbit f x ∘ fun i => n + i := by
  obtain ⟨m, hm⟩ := (mem_periodicPts.1 hx).exists_pow_eq
  have hm' : (f^[m] x) ∈ periodicPts f := mem_periodicPts.2 ⟨m, hm⟩
  have hm'' : ∀ k, (f^[k + m] x = f^[k] (f^[m] x)) := fun k =>
    congr_arg _ (Function.iterate_add_apply f k m x).symm
  ext y
  simp only [Set.mem_setOf_eq, Function.comp_apply]
  constructor
  · rintro ⟨n, rfl⟩
    simp only [Function.iterate_succ', Function.comp_apply]
    refine ⟨n, hm'' _⟩
  · rintro ⟨n, rfl⟩
    simp only [Function.comp_apply, Function.iterate_add_apply]
    exact ⟨n + m, hm⟩

Repaired Proof:
theorem periodicOrbit_apply_iterate_eq (hx : x ∈ periodicPts f) (n : ℕ) :
    periodicOrbit f (f^[n] x) = periodicOrbit f x ∘ fun i => n + i := by
  obtain ⟨m, hm⟩ := (mem_periodicPts.1 hx).exists_pow_eq
  have hm' : (f^[m] x) ∈ periodicPts f := mem_periodicPts.2 ⟨m, hm⟩
  have hm'' : ∀ k, (f^[k + m] x = f^[k] (f^[m] x)) := fun k =>
    congr_arg _ (Function.iterate_add_apply f k m x).symm
  ext y
  simp only [Set.mem_setOf_eq, Function.comp_apply]
  constructor
  · rintro ⟨n, rfl⟩
    simp only

Attempt failure.

Working on Mathlib/FieldTheory/IsAlgClosed/Basic.lean - 2024-09-09 00:50:09.814344.
---86/200---
For theorem IsAlgClosed.algebraMap_surjective_of_isIntegral' in Mathlib/FieldTheory/IsAlgClosed/Basic.lean:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f 


Original valid proof:
:=
  let _ : Algebra k K := f.toAlgebra
  have : Algebra.IsIntegral k K := ⟨hf⟩
  algebraMap_surjective_of_isIntegral


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K := ⟨hf⟩
  exact algebraMap_surjective_of_isIntegral

Repaired Proof:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k →+* K) (hf : f.IsIntegral) : Function.Surjective f ∨ f = 0 := by
  rcases subsingleton_or_nontrivial k
  · haveI : Subsingleton K := f.domain_of_subsingleton
    exact Or.inr (Subsingleton.elim _ _)
  have : Algebra.IsIntegral k K :=

Attempt failure.

Working on Mathlib/FieldTheory/PrimitiveElement.lean - 2024-09-09 00:50:34.272980.
---87/200---
For theorem Field.exists_primitive_element_of_finite_top in Mathlib/FieldTheory/PrimitiveElement.lean:
theorem exists_primitive_element_of_finite_top [Finite E] : ∃ α : E, F⟮α⟯ = ⊤ 


Original valid proof:
:= by
  obtain ⟨α, hα⟩ := @IsCyclic.exists_generator Eˣ _ _
  use α
  rw [eq_top_iff]
  rintro x -
  by_cases hx : x = 0
  · rw [hx]
    exact F⟮α.val⟯.zero_mem
  · obtain ⟨n, hn⟩ := Set.mem_range.mp (hα (Units.mk0 x hx))
    rw [show x = α ^ n by norm_cast; rw [hn, Units.val_mk0]]
    exact zpow_mem (mem_adjoin_simple_self F (E := E) ↑α) n


Verifying proof (Commit a76dc22f3a90e5ab96e9284d30276a87a4324a5d):
∧ IsIntegral F α := by
  obtain ⟨α, h1, h2⟩ := FiniteDimensional.exists_isIntegral_of_finite F E
  refine' ⟨α, _⟩
  rintro x -
  have h3 : F⟮α, x⟯ = ⊤ := top_le_iff.mp (adjoin_simple_le_iff.mpr h1)
  have h4 : F⟮α⟯ = ⊤ := top_le_iff.mp (adjoin_simple_le_iff.mpr h1)
  have h5 : F⟮x⟯ = ⊤ := top_le_iff.mp (adjoin_simple_le_iff.mpr h2)
  have h6 : F⟮α⟯ = ⊤ ∨ F⟮x⟯ = ⊤ := by
    rw [← h4, ← h5]
    exact adjoin_simple_adjoin_simple_is_simple F α x
  cases' h6 with h6 h6
  · exact h6 ▸ h4
  · exact h6 ▸ h5

Repaired Proof:
theorem exists_primitive_element_of_finite_top [Finite E] : ∃ α : E, F⟮α⟯ = ⊤ ∧ IsIntegral F α := by
  obtain ⟨α, h1, h2⟩ := FiniteDimensional.exists_isIntegral_of_finite F E
  refine ⟨α, ?_, h1⟩
  rintro x -
  have h3 : F⟮α, x⟯ = ⊤ := top_le_iff.mp (adjoin_simple_le_iff.mpr h1)
  have h4 : F⟮α⟯ = ⊤ := top_le_iff.mp (adjoin_simple_le_iff.mpr h1)
  have h5 : F⟮x⟯ = ⊤ := top_le_iff.mp (adjoin_simple_le_iff.mpr h2)
  have h6 : F⟮α⟯ = ⊤ ∨ F⟮x⟯ = ⊤ := by
    rw [← h4, ← h5]
    exact adjoin_simple_adjoin_simple_is_simple F α x
  cases' h6 with h6 h6
  · exact h6 ▸ h4
  · exact h6 ▸ h5

Repaired Proof:
theorem exists_primitive_element_of_finite_top [Finite E] : ∃ α : E, F⟮α⟯ = ⊤ ∧ IsIntegral F α := by
  obtain ⟨α, h1, h2⟩ := FiniteDimensional.exists_isIntegral_of_finite F E
  refine ⟨α, ?_, h1⟩
  rintro x -
  have h3 : F⟮α, x⟯ = ⊤ := top_le_iff.mp (adjoin_simple_le_iff.mpr h1)
  have h4 : F⟮α⟯ = ⊤ := top_le_iff.mp (adjoin_simple_le_iff.mpr h1)
  have h5 : F⟮x⟯ = ⊤ := top_le_iff.mp (adjoin_simple_le_iff.mpr h2)
  have h6 : F⟮α⟯ = ⊤ ∨ F⟮x⟯ = ⊤ := by
    rw [← h4, ← h5]
    exact adjoin_simple_adjoin_simple_is_simple F α x
  cases' h6 with h6 h6
  · exact h6 ▸ h4
  · exact h6 ▸ h5

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean - 2024-09-09 00:50:53.399088.
---88/200---
For theorem Orientation.oangle_eq_of_angle_eq_of_sign_eq in Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean:
theorem oangle_eq_of_angle_eq_of_sign_eq {w x y z : V}
    (h : InnerProductGeometry.angle w x = InnerProductGeometry.angle y z)
    (hs : (o.oangle w x).sign = (o.oangle y z).sign) : o.oangle w x = o.oangle y z 


Original valid proof:
:= by
  by_cases h0 : (w = 0 ∨ x = 0) ∨ y = 0 ∨ z = 0
  · have hs' : (o.oangle w x).sign = 0 ∧ (o.oangle y z).sign = 0 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      · simpa using hs.symm
      · simpa using hs.symm
      · simpa using hs
      · simpa using hs
    rcases hs' with ⟨hswx, hsyz⟩
    have h' : InnerProductGeometry.angle w x = π / 2 ∧ InnerProductGeometry.angle y z = π / 2 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      · simpa using h.symm
      · simpa using h.symm
      · simpa using h
      · simpa using h
    rcases h' with ⟨hwx, hyz⟩
    have hpi : π / 2 ≠ π := by
      intro hpi
      rw [div_eq_iff, eq_comm, ← sub_eq_zero, mul_two, add_sub_cancel_right] at hpi
      · exact Real.pi_pos.ne.symm hpi
      · exact two_ne_zero
    have h0wx : w = 0 ∨ x = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hswx
      simpa [hwx, Real.pi_pos.ne.symm, hpi] using h0'
    have h0yz : y = 0 ∨ z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0wx with (h0wx | h0wx) <;> rcases h0yz with (h0yz | h0yz) <;> simp [h0wx, h0yz]
  · push_neg at h0
    rw [Real.Angle.eq_iff_abs_toReal_eq_of_sign_eq hs]
    rwa [o.angle_eq_abs_oangle_toReal h0.1.1 h0.1.2,
      o.angle_eq_abs_oangle_toReal h0.2.1 h0.2.2] at h


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
∨
      o.oangle w x = -o.oangle y z := by
  by_cases h0 : (o.oangle w x).sign = 0
  · rw [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq] at h0
    rw [h0]
    simp [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq, h, hs]
  by_cases h'0 : (o.oangle y z).sign = 0
  · rw [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq] at h'0
    rw [h.symm, h'0]
    simp [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq, h, hs]
  by_cases h0' : (o.oangle w x).sign = -1
  · rw [oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h0'] at hs
    cases' hs with hs hs
    · right
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h0']
      simp
    · left
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h0']
      simp
  by_cases h'0' : (o.oangle y z).sign = -1
  · rw [oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h'0'] at hs
    cases' hs with hs hs
    · right
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h'0']
      simp
    · left
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h'0']
      simp
  rw [oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_ne_zero h0,
    oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_ne_zero h'0] at hs
  cases' hs with hs hs
  · left
    exact hs
  · right
    rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_ne_zero h'0]
    simp

Repaired Proof:
theorem oangle_eq_of_angle_eq_of_sign_eq {w x y z : V}
    (h : InnerProductGeometry.angle w x = InnerProductGeometry.angle y z)
    (hs : (o.oangle w x).sign = (o.oangle y z).sign) : o.oangle w x = o.oangle y z ∨
      o.oangle w x = -o.oangle y z := by
  by_cases h0 : (o.oangle w x).sign = 0
  · rw [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq] at h0
    rw [h0]
    simp [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq, h, hs]
  by_cases h'0 : (o.oangle y z).sign = 0
  · rw [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq] at h'0
    rw [h.symm, h'0]
    simp [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq, h, hs]
  by_cases h0' : (o.oangle w x).sign = -1
  · rw [oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h0'] at hs
    cases' hs with hs hs
    · right
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h0']
      simp
    · left
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h0']
      simp
  by_cases h'0' : (o.oangle y z).sign = -1
  · rw [oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h'0'] at hs
    cases' hs with hs hs
    · right
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h'0']
      simp
    · left
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h'0']
      simp
  rw [oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_ne_zero h0,
    oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_ne_zero h'0] at hs
  cases' hs with hs hs
  · left
    exact hs
  · right
    rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_ne_zero h'0]
    simp

Repaired Proof:
theorem oangle_eq_of_angle_eq_of_sign_eq {w x y z : V}
    (h : InnerProductGeometry.angle w x = InnerProductGeometry.angle y z)
    (hs : (o.oangle w x).sign = (o.oangle y z).sign) : o.oangle w x = o.oangle y z ∨
      o.oangle w x = -o.oangle y z := by
  by_cases h0 : (o.oangle w x).sign = 0
  · rw [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq] at h0
    rw [h0]
    simp [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq, h, hs]
  by_cases h'0 : (o.oangle y z).sign = 0
  · rw [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq] at h'0
    rw [h.symm, h'0]
    simp [oangle_eq_zero_iff_oangle_eq_zero_of_sign_eq, h, hs]
  by_cases h0' : (o.oangle w x).sign = -1
  · rw [oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h0'] at hs
    cases' hs with hs hs
    · right
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h0']
      simp
    · left
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h0']
      simp
  by_cases h'0' : (o.oangle y z).sign = -1
  · rw [oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h'0'] at hs
    cases' hs with hs hs
    · right
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h'0']
      simp
    · left
      rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_eq_neg_one h'0']
      simp
  rw [oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_ne_zero h0,
    oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_ne_zero h'0] at hs
  cases' hs with hs hs
  · left
    exact hs
  · right
    rw [hs, oangle_eq_iff_oangle_eq_or_eq_neg_of_sign_ne_zero h'0]
    simp

Repaired Proof:
theorem oangle_eq_of_angle_eq_of_sign_eq {w x y z : V}
    (h : InnerProductGeometry.angle w x = InnerProductGeometry.angle y z)
    (hs : (o.oangle w x).

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Circumcenter.lean - 2024-09-09 00:51:25.620455.
---89/200---
For theorem Affine.Simplex.circumradius_pos in Mathlib/Geometry/Euclidean/Circumcenter.lean:
theorem circumradius_pos {n : ℕ} (s : Simplex ℝ P (n + 1)) : 0 < s.circumradius 


Original valid proof:
:= by
  refine lt_of_le_of_ne s.circumradius_nonneg ?_
  intro h
  have hr := s.dist_circumcenter_eq_circumradius
  simp_rw [← h, dist_eq_zero] at hr
  have h01 := s.independent.injective.ne (by simp : (0 : Fin (n + 2)) ≠ 1)
  simp [hr] at h01


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
↔ s.Nonempty :=
  s.circumradius_eq_zero.not.symm.lt_iff_ne.trans (by simp)

@[simp]
theorem circumradius_pos_iff {n : ℕ} (s : Simplex ℝ P (n + 1)) : 0 < s.circumradius ↔ s.Nonempty :=
  s.circumradius_eq_zero.not_lt

@[simp]
theorem circumradius_eq_zero {n : ℕ} (s : Simplex ℝ P (n + 1)) : s.circumradius = 0 ↔ s = ∅ :=
  s.circumradius_eq_zero_iff.trans (by simp)


theorem circumradius_ne_zero {n : ℕ} (s : Simplex ℝ P (n + 1)) : s.circumradius ≠ 0 ↔ s.Nonempty :=
  s.circumradius_eq_zero.not_left.trans s.nonempty_iff_ne_bot.symm


theorem circumradius_pos {n : ℕ} (s : Simplex ℝ P (n + 1)) : 0 < s.circumradius ↔ s ≠ ∅ :=
  s.circumradius_eq_zero.lt_iff_ne.trans s.circumradius_ne_zero


theorem circumcenter_mem_affineSpan {n : ℕ} (s : Simplex ℝ P (n + 1)) :
    s.circumcenter ∈ affineSpan ℝ (Set.range s.points) :=
  s.circumcenter_mem_affineSpan' (Set.range_nonempty _)


/-- The circumcenter of a simplex constructed from a finite family of points is in the affine
span of these points. -/
theorem circumcenter_mem_affineSpan_of_card_eq_add_one {n : ℕ} {P : Type*} [MetricSpace P]
    [NormedAddTorsor V P] {p : Fin (n + 1) → P} :
    (⟨circumcenter ℝ (ofFin (n + 1) p), circumcenter_mem_affineSpan (ofFin (n + 1) p)⟩ :
        _) ∈
      affineSpan ℝ (Set.range p) :=
  circumcenter_mem_affineSpan (ofFin (n + 1) p)


/-- The circumcenter of a simplex constructed from a finite family of points is in the affine
span of these points. -/
theorem circumcenter_mem_affineSpan_of_card_eq_add_one' {n : ℕ} {P : Type*} [MetricSpace P]
    [NormedAddTorsor V P] {p : Fin (n + 1) → P} :
    (⟨circumcenter ℝ (ofFn p), circumcenter_mem_affineSpan (ofFn p)⟩ : _) ∈
      affineSpan ℝ (Set.range p) :=
  circumcenter_mem_affineSpan_of_card_eq_add_one


/-- The circumcenter of a simplex constructed from a finite family of points is in the affine
span of these points. -/
theorem circumcenter_mem_affineSpan_of_card_eq_add_one'' {n : ℕ} {P : Type*} [MetricSpace P]
    [NormedAddTorsor V P] {p : Fin (n + 1) → P} :
    (⟨circumcenter ℝ (ofFn p), circumcenter_mem_affineSpan (ofFn p)⟩ : _) ∈
      affineSpan ℝ (Set.range p) :=
  circumcenter_mem_affineSpan_of_card_eq_add_one'


/-- The circumcenter of a simplex constructed from a finite family of points is in the affine
span of these points. -/
theorem circumcenter_mem_affineSpan_of_card_eq_add_one''' {n : ℕ} {P : Type*} [MetricSpace P]
    [NormedAddTorsor V P] {p : Fin (n + 1) → P} :
    (⟨circumcenter ℝ (ofFn p), circumcenter_mem_affineSpan (ofFn p)⟩ : _) ∈
      affineSpan ℝ (Set.range p) :=
  circumcenter_mem_affineSpan_of_card_eq_add_one''


/-- The circumcenter of a simplex constructed from a finite family of points is in the affine
span of these points. -/
theorem circumcenter_mem_affineSpan_of_card_eq_add_one'''' {n : ℕ} {P : Type*} [MetricSpace P]
    [NormedAddTorsor V P] {p : Fin (n + 1) → P} :
    (⟨circumcenter ℝ (ofFn p), circumcenter_mem_affineSpan (ofFn p)⟩ : _) ∈
      affineSpan ℝ (Set.range p) :=
  circumcenter_mem_affineSpan_of_card_eq_add_one'''


/-- The circumcenter of a simplex constructed from a finite family of points is in the affine
span of these points. -/
theorem circumcenter_mem_affineSpan_of_card_eq_add_one''''' {n : ℕ} {P : Type*} [MetricSpace P]
    [NormedAddTorsor V P] {p : Fin (n + 1) → P} :
    (⟨circumcenter ℝ (ofFn p), circumcenter_mem_affineSpan (ofFn p)⟩ : _) ∈
      affineSpan ℝ (Set.range p) :=
  circumcenter_mem_affineSpan_of_card_eq_add_one''''


/-- The circumcenter of a simplex constructed from a finite family of points is in the affine
span of these points. -/
theorem circumcenter_mem_affineSpan_of_card_eq_add_one'''''' {n : ℕ} {P : Type*} [MetricSpace P]
    [NormedAddTorsor V P] {p : Fin (n + 1) → P} :
    (⟨circumcenter ℝ (ofFn p), circumcenter_mem_affineSpan (ofFn p)⟩ : _) ∈
      affineSpan ℝ (Set.range p) :=
  circumcenter_mem_affineSpan_of_card_eq_add_one'''''''


/-- The circumcenter of a simplex constructed from a finite family of points is in the affine
span of these points. -/
theorem circumcenter_mem_affineSpan_of_card_eq_add_one''''''' {n : ℕ} {P : Type*} [MetricSpace P]
    [NormedAddTorsor V P] {p : Fin (n + 1) → P} :
    (⟨circumcenter ℝ (ofFn p), circumcenter_mem_affineSpan (ofFn p)⟩ : _) ∈
      affineSpan ℝ (Set.range p) :=
  circumcenter_mem_affineSpan_of_card_eq_add_one''''''


/-- The circumcenter of a simplex constructed from a finite family of points is in the affine
span of these points. -/
theorem circumcenter_mem_affineSpan_of_card_eq_add_one''''''''' {n : ℕ} {P : Type*} [MetricSpace P]
    [NormedAddTorsor V P] {p : Fin (n + 1) → P} :
    (⟨circumcenter ℝ (ofFn p), circumcenter_mem_affineSpan (ofFn p)⟩ : _) ∈
      affineSpan ℝ (Set.range p) :=
  circumcenter_mem_affineSpan_of_card_eq_add_one'''''''


/-- The circumcenter of a simplex constructed from a finite family of points is in the affine
span of these points. -/
theorem circumcenter_mem_affineSpan_of_card_eq_add_one'''''''''' {n : ℕ} {P : Type*} [MetricSpace P]
    [NormedAddTorsor V P] {p : Fin (n + 1) → P} :
    (⟨circumcenter ℝ (ofFn p), circumcenter_mem_affineSpan (ofFn p)⟩ : _) ∈
      affineSpan ℝ (Set.range p) :=
  circumcenter_mem_affineSpan_of_card_eq_add_one'''''''''


/-- The circumcenter of a simplex constructed from a finite family of points is in the affine
span of these points. -/
theorem circumcenter_mem_affineSpan_of_card_eq_add_one''''''''''' {n : ℕ} {P : Type*} [MetricSpace P]

Attempt failure.

---90/200---
For theorem Affine.Simplex.circumsphere_unique_dist_eq in Mathlib/Geometry/Euclidean/Circumcenter.lean:
theorem circumsphere_unique_dist_eq {n : ℕ} (s : Simplex ℝ P n) :
    (s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧
        Set.range s.points ⊆ s.circumsphere) ∧
      ∀ cs : Sphere P,
        cs.center ∈ affineSpan ℝ (Set.range s.points) ∧ Set.range s.points ⊆ cs →
          cs = s.circumsphere 


Original valid proof:
:=
  s.independent.existsUnique_dist_eq.choose_spec


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∨ cs.radius = s.circumsphere.radius := by
  rcases n with (_ | _ | n)
  · have : s.points.Nontrivial := s.nontrivial
    simp [s.circumsphere_unique_dist_eq]
  · have : s.points.Nontrivial := s.nontrivial
    simp [s.circumsphere_unique_dist_eq]
  · have : FiniteDimensional ℝ V := .of_fact_finrank_eq_succ n
    have hc :
      s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧
        Set.range s.points ⊆ s.circumsphere :=
      s.circumsphere_unique_dist_eq.1
    refine' ⟨hc, _⟩
    rintro cs ⟨hc₁, hc₂⟩
    by_cases hcs : cs = s.circumsphere
    · exact Or.inl hcs
    refine' Or.inr ((s.eq_circumsphere_of_dist_eq hc₁ hc₂ hcs).radius_eq_circumsphere.symm)

Repaired Proof:
theorem circumsphere_unique_dist_eq {n : ℕ} (s : Simplex ℝ P n) :
    (s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧
        Set.range s.points ⊆ s.circumsphere) ∧
      ∀ cs : Sphere P,
        cs.center ∈ affineSpan ℝ (Set.range s.points) ∧ Set.range s.points ⊆ cs →
          cs = s.circumsphere ∨ cs.radius = s.circumsphere.radius := by
  rcases n with (_ | _ | n)
  · have : s.points.Nontrivial := s.nontrivial
    simp [s.circumsphere_unique_dist_eq]
  · have : s.points.Nontrivial := s.nontrivial
    simp [s.circumsphere_unique_dist_eq]
  · have : FiniteDimensional ℝ V := .of_fact_finrank_eq_succ n
    have hc :
      s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧
        Set.range s.points ⊆ s.circumsphere :=
      s.circumsphere_unique_dist_eq.1
    refine ⟨hc, ?_⟩
    rintro cs ⟨hc₁, hc₂⟩
    by_cases hcs : cs = s.circumsphere
    · exact Or.inl hcs
    refine Or.inr ((s.eq_circumsphere_of_dist_eq hc₁ hc₂ hcs).radius_eq_circumsphere.symm)

Repaired Proof:
theorem circumsphere_unique_dist_eq {n : ℕ} (s : Simplex ℝ P n) :
    (s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧
        Set.range s.points ⊆ s.circumsphere) ∧
      ∀ cs : Sphere P,
        cs.center ∈ affineSpan ℝ (Set.range s.points) ∧ Set.range s.points ⊆ cs →
          cs = s.circumsphere ∨ cs.radius = s.circumsphere.radius := by
  rcases n with (_ | _ | n)
  · have : s.points.Nontrivial := s.nontrivial
    simp [s.circumsphere_unique_dist_eq]
  · have : s.points.Nontrivial := s.nontrivial
    simp [s.circumsphere_unique_dist_eq]
  · have : FiniteDimensional ℝ V := .of_fact_finrank_eq_succ n
    have hc :
      s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧
        Set.range s.points ⊆ s.circumsphere :=
      s.circumsphere_unique_dist_eq.1
    refine ⟨hc, ?_⟩
    rintro cs ⟨hc₁, hc₂⟩
    by_cases hcs : cs = s.circumsphere
    · exact Or.inl hcs
    refine Or.inr ((s.eq_circumsphere_of_dist_eq hc₁ hc₂ hcs).radius_eq_circumsphere.symm)

Repaired Proof:
theorem circumsphere_unique_dist_eq {n : ℕ} (s : Simplex ℝ P n) :
    (s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧
        Set.range s.points ⊆ s.circumsphere) ∧
      ∀ cs : Sphere P,
        cs.center ∈ affineSpan ℝ (Set.range s.points) ∧ Set.range s.points ⊆ cs →
          cs = s.circumsphere ∨ cs.radius = s.circumsphere.radius := by
  rcases n with (_ | _ | n)
  · have : s.points.Nontrivial := s.nontrivial
    simp [s.circumsphere_unique_dist_eq]
  · have : s.points.Nontrivial := s.nontrivial
    simp [s.circumsphere_unique_dist_eq]
  · have : FiniteDimensional ℝ V := .of_fact_finrank_eq_succ n
    have hc :
      s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧
        Set.range s.points ⊆ s.circumsphere :=
      s.circumsphere_unique_dist_eq.1
    refine ⟨hc, ?_⟩
    rintro cs ⟨hc₁, hc₂⟩
    by_cases hcs : cs = s.circumsphere
    · exact Or.inl hcs
    refine Or.inr ((s.eq_circumsphere_of_dist_eq hc₁ hc₂ hcs).radius_eq_circumsphere.symm)

Repaired Proof:
theorem circumsphere_unique_dist_eq {n : ℕ} (s : Simplex ℝ P n) :
    (s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧
        Set.range s.points ⊆ s.circumsphere) ∧
      ∀ cs : Sphere P,
        cs.center ∈ affineSpan ℝ (Set.range s.points) ∧ Set.range s.points ⊆ cs →
          cs = s.circumsphere ∨ cs.radius = s.circumsphere.radius := by
  rcases n with (_ | _ | n)
  · have : s.points.Nontrivial := s.nontrivial
    simp [s.circumsphere_unique_dist_eq]
  · have : s.points.Nontrivial := s.nontrivial
    simp [s.circumsphere_unique_dist_eq]
  · have : FiniteDimensional ℝ V := .of_fact_finrank_eq_succ n
    have hc :
      s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧
        Set.range s.points ⊆ s.circumsphere :=
      s.circumsphere_unique_dist_eq.1
    refine ⟨hc, ?_⟩
    rintro cs ⟨hc₁, hc₂⟩
    by_cases hcs : cs = s.circumsphere
    · exact Or.inl hcs
    refine Or.inr ((s.eq_circumsphere_of_dist_eq hc₁ hc₂ hcs).radius_eq_circumsphere.symm)

Repaired Proof:
theorem circumsphere_unique_dist_eq {n : ℕ} (s : Simplex ℝ P n) :
    (s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧
        Set.range s.points ⊆ s.circumsphere) ∧
      ∀ cs : Sphere P,
        cs.center ∈ affineSpan ℝ (Set.range s.points) ∧ Set.range s.points ⊆ cs →
          cs = s.circumsphere ∨ cs.radius = s.circumsphere

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Triangle.lean - 2024-09-09 00:52:25.353689.
---91/200---
For theorem EuclideanGeometry.dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq in Mathlib/Geometry/Euclidean/Triangle.lean:
theorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq (a b c : P) :
    dist a b ^ 2 + dist a c ^ 2 = 2 * (dist a (midpoint ℝ b c) ^ 2 + (dist b c / 2) ^ 2) 


Original valid proof:
:= by
  by_cases hbc : b = c
  · simp [hbc, midpoint_self, dist_self, two_mul]
  · let m := midpoint ℝ b c
    have : dist b c ≠ 0 := (dist_pos.mpr hbc).ne'
    have hm := dist_sq_mul_dist_add_dist_sq_mul_dist a b c m (angle_midpoint_eq_pi b c hbc)
    simp only [m, dist_left_midpoint, dist_right_midpoint, Real.norm_two] at hm
    calc
      dist a b ^ 2 + dist a c ^ 2 = 2 / dist b c * (dist a b ^ 2 *
        ((2:ℝ)⁻¹ * dist b c) + dist a c ^ 2 * (2⁻¹ * dist b c)) := by field_simp; ring
      _ = 2 * (dist a (midpoint ℝ b c) ^ 2 + (dist b c / 2) ^ 2) := by rw [hm]; field_simp; ring


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
↔
      dist a b = dist a c ∧ dist b c = 0 ∨ dist a b = 0 ∧ dist a c = dist b c ∨
        dist a c = 0 ∧ dist a b = dist b c ∨ dist b c = 0 ∧ dist a b = dist a c := by
  rw [dist_comm b c, ← @dist_midpoint_midpoint_real _ _ _ _ b c a, dist_comm _ a, dist_comm _ a,
    dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a,
    dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a,
    dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a,
    dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a,
    dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a]
  rw [dist_comm b c, ← @dist_midpoint_midpoint_real _ _ _ _ b c a, dist_comm _ a, dist_comm _ a,
    dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a,
    dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a,
    dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a,
    dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a,
    dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a, dist_comm _ a]
  rw [← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc,
    ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc,
    ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc,
    ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc,
    ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc]
  rw [← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq,
    ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq,
    ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq, ← sq]
  apply
    (mul_self_inj_of_nonneg (add_nonneg (add_nonneg (sq_nonneg _) (sq_nonneg _)) (sq_nonneg _))
        (add_nonneg (add_nonneg (sq_nonneg _) (sq_nonneg _)) (sq_nonneg _))).trans
  rw [add_right_comm, add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _),
    add_right_comm _ _ _ (sq _), add_right_comm _ _ _ (sq _), add

Attempt failure.

Working on Mathlib/Geometry/Manifold/IntegralCurve.lean - 2024-09-09 00:52:45.360446.
---92/200---
For theorem IsIntegralCurve.isIntegralCurveAt in Mathlib/Geometry/Manifold/IntegralCurve.lean:
lemma IsIntegralCurve.isIntegralCurveAt (h : IsIntegralCurve γ v) (t : ℝ) :
    IsIntegralCurveAt γ v t 


Original valid proof:
:= isIntegralCurveAt_iff.mpr ⟨univ, Filter.univ_mem, fun t _ ↦ h t⟩


Verifying proof (Commit 2c4d77d7fd709133772709da9ffb1d698ecbcd0a):
∧ γ t ∈ support v := by
  refine ⟨fun s ↦ h.isIntegralCurveAt_of_mem_Icc ⟨t, le_rfl, le_rfl⟩ s, ?_⟩
  simpa [support] using h t

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt t

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc'' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc'''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc'''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc'''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc'''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc''''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc'''''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc''''''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc'''''''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc''''''''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc'''''''''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc''''''''''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc'''''''''''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc''''''''''''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc'''''''''''''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t ∈ Icc t₀ t₀) : IsIntegralCurveAt γ v t ∧ γ t ∈ support v :=
  h.isIntegralCurveAt_of_mem_Icc ht

lemma IsIntegralCurve.isIntegralCurveAt_of_mem_Icc''''''''''''''''''''' (h : IsIntegralCurve γ v) {t₀ t : ℝ}
    (ht : t

Attempt failure.

Working on Mathlib/Geometry/Manifold/LocalInvariantProperties.lean - 2024-09-09 00:53:11.383771.
---93/200---
For theorem StructureGroupoid.LocalInvariantProp.liftPropWithinAt_iff in Mathlib/Geometry/Manifold/LocalInvariantProperties.lean:
theorem liftPropWithinAt_iff {f : M → M'} :
    LiftPropWithinAt P f s x ↔
      ContinuousWithinAt f s x ∧
        P (chartAt H' (f x) ∘ f ∘ (chartAt H x).symm)
          ((chartAt H x).target ∩ (chartAt H x).symm ⁻¹' (s ∩ f ⁻¹' (chartAt H' (f x)).source))
          (chartAt H x x) 


Original valid proof:
:= by
  rw [liftPropWithinAt_iff']
  refine and_congr_right fun hf ↦ hG.congr_set ?_
  exact PartialHomeomorph.preimage_eventuallyEq_target_inter_preimage_inter hf
    (mem_chart_source H x) (chart_source_mem_nhds H' (f x))


Verifying proof (Commit b06c98e69f01ef8ab665c237468aa64e98a5bcd4):
∧
          EqOn ((chartAt H' (f x)) ∘ f ∘ (chartAt H x).symm)
            ((chartAt H' (f x)) ∘ (chartAt H x).symm) ((chartAt H x).target ∩ (chartAt H x).symm ⁻¹' s) :=
  Iff.rfl

Repaired Proof:
theorem liftPropWithinAt_iff {f : M → M'} :
    LiftPropWithinAt P f s x ↔
      ContinuousWithinAt f s x ∧
        P (chartAt H' (f x) ∘ f ∘ (chartAt H x).symm)
            (s ∩ (chartAt H x).symm ⁻¹' (f ⁻¹' (chartAt H' (f x)).source)) (chartAt H x x) ∧
          EqOn ((chartAt H' (f x)) ∘ f ∘ (chartAt H x).symm)
            ((chartAt H' (f x)) ∘ (chartAt H x).symm) (s ∩ (chartAt H x).symm ⁻¹' (f ⁻¹' (chartAt H' (f x)).source)) :=
  Iff.rfl

Repaired Proof:
theorem liftPropWithinAt_iff_of_mem_source {f : M → M'} {x : M} (hx : f x ∈ (chartAt H' (f x)).source)
    (hy : x ∈ (chartAt H x).source) :
    LiftPropWithinAt P f s x ↔
      ContinuousWithinAt f s x ∧
        P (chartAt H' (f x) ∘ f ∘ (chartAt H x).symm)
            (s ∩ (chartAt H x).symm ⁻¹' {y | y ∈ (chartAt H x).source ∧ f y ∈ (chartAt H' (f x)).source})
            (chartAt H x x) := by
  simp_rw [liftPropWithinAt_iff, hx, hy, and_true_iff, preimage_inter, preimage_singleton,
    inter_inter_distrib_right, inter_self, preimage_id', inter_univ, true_and_iff]
  rfl

Repaired Proof:
theorem liftPropWithinAt_iff_of_mem_source {f : M → M'} {x : M} (hx : f x ∈ (chartAt H' (f x)).source)
    (hy : x ∈ (chartAt H x).source) :
    LiftPropWithinAt P f s x ↔
      ContinuousWithinAt f s x ∧
        P (chartAt H' (f x) ∘ f ∘ (chartAt H x).symm)
            (s ∩ (chartAt H x).symm ⁻¹' {y | y ∈ (chartAt H x).source ∧ f y ∈ (chartAt H' (f x)).source})
            (chartAt H x x) := by
  simp_rw [liftPropWithinAt_iff, hx, hy, and_true_iff, preimage_inter, preimage_singleton,
    inter_inter_distrib_right, inter_self, preimage_id', inter_univ, true_and_iff]
  rfl

Repaired Proof:
theorem liftPropWithinAt_iff_of_mem_maximalAtlas [HasGroupoid M G] [HasGroupoid M' G']
    (he : e ∈ G.maximalAtlas M) (xe : x ∈ e.source) (hf : f ∘ e.symm ∈ G'.maximalAtlas I' (f x))
    (xf : f x ∈ f.source) (hy : y ∈ e.source) (hy' : f y ∈ (chartAt H' (f x)).source) :
    LiftPropWithinAt P f s y ↔
      ContinuousWithinAt f s y ∧
        P (f ∘ e.symm ∘ (chartAt H' (f x)).symm) ((chartAt H' (f x)).source ∩ e ⁻¹' s)
          (e y) := by
  simp_rw [liftPropWithinAt_iff', (e.symm_continuousAt xe).continuousWithinAt, true_and_iff,
    (e.symm.continuousAt xe).preimage_mem_nhdsWithin he (hy'.mem_nhdsWithin_source_of_mem_maximalAtlas
      hf (e.map_source hy) xe), inter_comm]
  refine and_congr_right fun _ ↦ (hG'.liftPropOn_indep_chart (e.symm.continuousAt xe) hf ?_ ?_ ?_ ?_).symm
  · simp_rw [Function.comp_apply, e.left_inv xe]
  · simp_rw [Function.comp_apply, e.left_inv hy]
  · simp_rw [Function.comp_apply, e.left_inv xe]
  · simp_rw [Function.comp_apply, e.left_inv hy]

Repaired Proof:
theorem liftPropWithinAt_iff_of_mem_maximalAtlas [HasGroupoid M G] [HasGroupoid M' G']
    (he : e ∈ G.maximalAtlas M) (xe : x ∈ e.source) (hf : f ∘ e.symm ∈ G'.maximalAtlas I' (f x))
    (xf : f x ∈ f.source) (hy : y ∈ e.source) (hy' : f y ∈ (chartAt H' (f x)).source) :
    LiftPropWithinAt P f s y ↔
      ContinuousWithinAt f s y ∧
        P (f ∘ e.symm ∘ (chartAt H' (f x)).symm) ((chartAt H' (f x)).source ∩ e ⁻¹' s)
          (e y) := by
  simp_rw [liftPropWithinAt_iff', (e.symm_continuousAt xe).continuousWithinAt, true_and_iff,
    (e.symm.continuousAt xe).preimage_mem_nhdsWithin he (hy'.mem_nhdsWithin_source_of_mem_maximalAtlas
      hf (e.map_source hy) xe), inter_comm]
  refine and_congr_right fun _ ↦ (hG'.liftPropOn_indep_chart (e.symm.continuousAt xe) hf ?_ ?_ ?_ ?_).symm
  · simp_rw [Function.comp_apply, e.left_inv xe]
  · simp_rw [Function.comp_apply, e.left_inv hy]
  · simp_rw [Function.comp_apply, e.left_inv xe]
  · simp_rw [Function.comp_apply, e.left_inv hy]

Repaired Proof:
theorem liftPropWithinAt_iff_of_mem_maximalAtlas [HasGroupoid M G] [HasGroupoid M' G']
    (he : e ∈ G.maximalAtlas M) (xe : x ∈ e.source) (hf : f ∘ e.symm ∈ G'.maximalAtlas I' (f x))
    (xf : f x ∈ f.source) (hy : y ∈ e.source) (hy' : f y ∈ (chartAt H' (f x)).source) :
    LiftPropWithinAt P f s y ↔
      ContinuousWithinAt f s y ∧
        P (f ∘ e.symm ∘ (chartAt H' (f x)).symm) ((chartAt H' (f x)).source ∩ e ⁻¹' s)
          (e y) := by
  simp_rw [liftPropWithinAt_iff', (e.symm_continuousAt xe).continuousWithinAt, true_and_iff,
    (e.symm.continuousAt xe).preimage_mem_nhdsWithin he (hy'.mem_nhdsWithin_source_of_mem_maximalAtlas
      hf (e.map_source hy) xe), inter_comm]
  refine and_congr_right fun _ ↦ (hG'.liftPropOn_indep_chart (e.symm.continuousAt xe) hf ?_ ?_ ?_ ?_).symm
  · simp_rw [Function.comp_apply, e.left_inv xe]
  · simp_rw [Function.comp_apply, e.left_inv hy]
  · simp_rw [Function.comp_apply, e.left_inv xe]
  · simp_rw [Function.comp_apply, e.left_inv hy]

Repaired Proof:
theorem liftPropWithinAt_iff_of_mem_maximalAtlas [HasGroupoid M G] [HasGroupoid M' G']
    (he : e ∈ G.maximalAtlas M) (

Attempt failure.

Working on Mathlib/Geometry/RingedSpace/OpenImmersion.lean - 2024-09-09 00:53:22.560424.
---94/200---
For theorem AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.pullbackConeOfLeftLift_fst in Mathlib/Geometry/RingedSpace/OpenImmersion.lean:
theorem pullbackConeOfLeftLift_fst :
    pullbackConeOfLeftLift f g s ≫ (pullbackConeOfLeft f g).fst = s.fst 


Original valid proof:
:= by
  refine PresheafedSpace.Hom.ext _ _ ?_ <| NatTrans.ext _ _ <| funext fun x => ?_
  · change pullback.lift _ _ _ ≫ pullback.fst = _
    simp
  · induction x using Opposite.rec' with | h x => ?_
    change ((_ ≫ _) ≫ _ ≫ _) ≫ _ = _
    simp_rw [Category.assoc]
    erw [← s.pt.presheaf.map_comp]
    erw [s.snd.c.naturality_assoc]
    have := congr_app s.condition (op (opensFunctor f |>.obj x))
    dsimp only [comp_c_app, unop_op] at this
    rw [← IsIso.comp_inv_eq] at this
    replace this := reassoc_of% this
    erw [← this, hf.invApp_app_assoc, s.fst.c.naturality_assoc]
    simp [eqToHom_map]


Verifying proof (Commit 040e24340352a4333b5b2688f637a85dc78123c1):
≫ f := by
  simp [pullbackConeOfLeftLift]


theorem pullbackConeOfLeftLift_snd :
    pullbackConeOfLeftLift f g s ≫ (pullbackConeOfLeft f g).snd = s.snd := by
  simp [pullbackConeOfLeftLift]


@[reassoc (attr := simp)]
theorem pullbackConeOfLeftLift_fst_pullbackConeOfLeftLift :
    (pullbackConeOfLeftLift f g s ≫ pullback.fst : _ ⟶ X) ≫ f = s.fst ≫ f := by
  simp [pullbackConeOfLeftLift]


@[reassoc (attr := simp)]
theorem pullbackConeOfLeftLift_snd_pullbackConeOfLeftLift :
    (pullbackConeOfLeftLift f g s ≫ pullback.snd : _ ⟶ Y) ≫ g = s.snd ≫ g := by
  simp [pullbackConeOfLeftLift]


/-- The pullback cone `pullbackConeOfRight f g` is a limit cone. -/
def pullbackConeOfRightIsLimit : IsLimit (pullbackConeOfRight f g) :=
  PullbackCone.isLimitAux' _ fun s =>
    ⟨s.fst ≫ f, s.snd, by simp, fun hm _ => hm.symm ▸ rfl, fun hm _ => hm.symm ▸ rfl, fun m₁ m₂ m₃ h₁ h₂ =>
      by
      simp at h₁ h₂
      have q₁ : m₂ ≫ (pullbackConeOfRight f g).fst = m₁ ≫ (pullbackConeOfRight f g).fst := by
        rw [h₁]
      have q₂ : m₂ ≫ (pullbackConeOfRight f g).snd = m₁ ≫ (pullbackConeOfRight f g).snd := by
        rw [h₂]
      exact
        (PullbackCone.IsLimit.hom_ext s.isLimit q₁ q₂).trans
          (Category.id_comp _).symm⟩


theorem pullbackConeOfRightLift_fst :
    pullbackConeOfRightLift f g s ≫ (pullbackConeOfRight f g).fst = s.fst := by
  simp [pullbackConeOfRightLift]


theorem pullbackConeOfRightLift_snd :
    pullbackConeOfRightLift f g s ≫ (pullbackConeOfRight f g).snd = s.snd ≫ g := by
  simp [pullbackConeOfRightLift]


@[reassoc (attr := simp)]
theorem pullbackConeOfRightLift_fst_pullbackConeOfRightLift :
    (pullbackConeOfRightLift f g s ≫ pullback.fst : _ ⟶ X) ≫ f = s.fst ≫ f := by
  simp [pullbackConeOfRightLift]


@[reassoc (attr := simp)]
theorem pullbackConeOfRightLift_snd_pullbackConeOfRightLift :
    (pullbackConeOfRightLift f g s ≫ pullback.snd : _ ⟶ Y) ≫ g = s.snd ≫ g := by
  simp [pullbackConeOfRightLift]


/-- The pullback cone `pullbackConeOfLeftLift f g` is a limit cone. -/
def pullbackConeOfLeftLiftIsLimit : IsLimit (pullbackConeOfLeftLift f g s) :=
  PullbackCone.isLimitAux' _ fun t =>
    ⟨t.fst ≫ f, t.snd, by simp, fun hm _ => hm.symm ▸ rfl, fun hm _ => hm.symm ▸ rfl, fun m₁ m₂ m₃ h₁ h₂ =>
      by
      simp at h₁ h₂
      have q₁ : m₂ ≫ (pullbackConeOfLeftLift f g s).fst = m₁ ≫ (pullbackConeOfLeftLift f g s).fst := by
        rw [h₁]
      have q₂ : m₂ ≫ (pullbackConeOfLeftLift f g s).snd = m₁ ≫ (pullbackConeOfLeftLift f g s).snd := by
        rw [h₂]
      exact
        (PullbackCone.IsLimit.hom_ext s.isLimit q₁ q₂).trans
          (Category.id_comp _).symm⟩


/-- The pullback cone `pullbackConeOfRightLift f g` is a limit cone. -/
def pullbackConeOfRightLiftIsLimit : IsLimit (pullbackConeOfRightLift f g s) :=
  PullbackCone.isLimitAux' _ fun t =>
    ⟨t.fst ≫ f, t.snd, by simp, fun hm _ => hm.symm ▸ rfl, fun hm _ => hm.symm ▸ rfl, fun m₁ m₂ m₃ h₁ h₂ =>
      by
      simp at h₁ h₂
      have q₁ : m₂ ≫ (pullbackConeOfRightLift f g s).fst = m₁ ≫ (pullbackConeOfRightLift f g s).fst := by
        rw [h₁]
      have q₂ : m₂ ≫ (pullbackConeOfRightLift f g s).snd = m₁ ≫ (pullbackConeOfRightLift f g s).snd := by
        rw [h₂]
      exact
        (PullbackCone.IsLimit.hom_ext s.isLimit q₁ q₂).trans
          (Category.id_comp _).symm⟩


instance pullback_snd_isIso : IsIso (pullback.snd : pullback f g ⟶ Y) := by
  rw [←
    show _ = (pullbackConeOfLeftLift f g (pullbackConeOfLeft f g)).hom.app WalkingCospan.right from
      (IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right).symm]
  infer_instance


instance pullback_fst_isIso : IsIso (pullback.fst : pullback f g ⟶ X) := by
  rw [←
    show _ = (pullbackConeOfRightLift f g (pullbackConeOfRight f g)).hom.app WalkingCospan.left from
      (IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.left).symm]
  infer_instance


instance pullback_isIso_of_isIso_of_isIso [IsIso f] [IsIso g] : IsIso (pullback.fst : pullback f g ⟶ X) :=
  have := pullback_snd_isIso f g
  IsIso.of_isIso_of_isIso_of_isIso f _ pullback.fst


instance pullback_isIso_of_isIso_of_isIso' [IsIso f] [IsIso g] : IsIso (pullback.snd : pullback f g ⟶ Y) :=
  have := pullback_fst_isIso f g
  IsIso.of_isIso_of_isIso_of_isIso g _ pullback.snd


instance [Mono f] : Mono (pullback.fst : pullback f g ⟶ X) :=
  mono_of_isLimitMorphism_zero _ _
    (PullbackCone.isLimitOfIsLimitPullbackConeMorphismZero f g
      (pullbackConeOfLeftIsLimit f g) _)

instance [Mono f] : Mono (pullback.snd : pullback f g ⟶ Y) :=
  mono_of_isLimitMorphism_zero _ _
    (PullbackCone.isLimitOfIsLimitPullbackConeMorphismZero f g
      (pullbackConeOfRightIsLimit f g) _)

instance [Mono g] : Mono (pullback.fst : pullback f g ⟶ X) :=
  mono_of_isLimitMorphism_zero _ _
    (PullbackCone.isLimitOfIsLimitPullbackConeMorphismZero _ g
      (pullbackConeOfRightIsLimit f g) _)

instance [Mono g] : Mono (pullback.snd : pullback f g ⟶ Y) :=
  mono_of_isLimitMorphism_zero _ _
    (PullbackCone.isLimitOfIsLimitPullbackConeMorphismZero _ g
      (pullbackConeOfLeftIsLimit f g) _)

instance [Epi f] : Epi (pullback.fst : pullback f g ⟶ X) :=
  epi_of_isColimitMorphism_zero _ _
    (PullbackCocone.isColimitOfIsColimitPullbackCoconeMorphismZero f g
      (pullbackCoconeOf

Attempt failure.

Working on Mathlib/GroupTheory/Coxeter/Inversion.lean - 2024-09-09 00:54:00.674031.
---95/200---
For theorem CoxeterSystem.wordProd_mul_getD_rightInvSeq in Mathlib/GroupTheory/Coxeter/Inversion.lean:
theorem wordProd_mul_getD_rightInvSeq (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 


Original valid proof:
:= by
  rw [getD_rightInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 1 [← take_append_drop (j + 1) ω]
  rw [take_succ]
  obtain lt | le := lt_or_le j ω.length
  · simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  · simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp


Verifying proof (Commit eb780daf7ddc0b2aff6bd37f400ad1275df42fc8):
1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_erase]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ) :
    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) 1 := by
  rw [wordProd_mul_rightInvSeq, List.getD_eq_getD_get?, List.get?_eraseIdx]

Repaired Proof:
theorem wordProd_mul_getD_rightInvSeq' (ω : List B) (j : ℕ)

Attempt failure.

Working on Mathlib/GroupTheory/GroupAction/Blocks.lean - 2024-09-09 00:54:15.428091.
---96/200---
For theorem MulAction.IsPartition.of_orbits in Mathlib/GroupTheory/GroupAction/Blocks.lean:
theorem IsPartition.of_orbits :
    Setoid.IsPartition (Set.range fun a : X => orbit G a) 


Original valid proof:
:= by
  apply orbit.pairwiseDisjoint.isPartition_of_exists_of_ne_empty
  · intro x
    exact ⟨_, ⟨x, rfl⟩, mem_orbit_self x⟩
  · rintro ⟨a, ha : orbit G a = ∅⟩
    exact (MulAction.orbit_nonempty a).ne_empty ha


Verifying proof (Commit 90ee4adef4081d5ea59d0008022888ad5b93d012):
↔ IsPartition (Set.range fun a : X => orbit G a) :=
  Iff.rfl

theorem IsPartition.of_orbits (h : IsPartition (Set.range fun a : X => orbit G a)) :
    Setoid.IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits''''''''''''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G a) :=
  h

theorem IsPartition.of_orbits'''''''''''''''''''''''''''''''''''''' (h : IsPartition (Set.range fun a : X => orbit G a)) :
    IsPartition (Set.range fun a : X => orbit G

Attempt failure.

Working on Mathlib/GroupTheory/Schreier.lean - 2024-09-09 00:54:26.090149.
---97/200---
For theorem Subgroup.card_commutator_le_of_finite_commutatorSet in Mathlib/GroupTheory/Schreier.lean:
theorem card_commutator_le_of_finite_commutatorSet [Finite (commutatorSet G)] :
    Nat.card (_root_.commutator G) ≤ cardCommutatorBound (Nat.card (commutatorSet G)) 


Original valid proof:
:= by
  have h1 := index_center_le_pow (closureCommutatorRepresentatives G)
  have h2 := card_commutator_dvd_index_center_pow (closureCommutatorRepresentatives G)
  rw [card_commutatorSet_closureCommutatorRepresentatives] at h1 h2
  rw [card_commutator_closureCommutatorRepresentatives] at h2
  replace h1 :=
    h1.trans
      (Nat.pow_le_pow_of_le_right Finite.card_pos (rank_closureCommutatorRepresentatives_le G))
  replace h2 := h2.trans (pow_dvd_pow _ (add_le_add_right (mul_le_mul_right' h1 _) 1))
  rw [← pow_succ] at h2
  refine (Nat.le_of_dvd ?_ h2).trans (Nat.pow_le_pow_left h1 _)
  exact pow_pos (Nat.pos_of_ne_zero FiniteIndex.finiteIndex) _


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
•
      Nat.card (commutatorSet G) ^ 2 := by
  classical
  let s : Finset (CommutatorElement G) :=
    (commutatorSet G).toFinset.biUnion fun x =>
      (commutatorSet G).toFinset.biUnion fun y =>
        (Finset.range (cardCommutatorBound (Nat.card (commutatorSet G)) + 1)).image
          (fun k => k • x * y)
  have hs : ∀ x ∈ s, ∃ a b c, a ∈ commutatorSet G ∧ b ∈ commutatorSet G ∧
      c ∈ commutatorSet G ∧ x = c * (a * b) * a⁻¹ * b⁻¹ := by
    simp only [commutatorSet, Finset.mem_toFinset, exists_prop, Set.mem_toFinset,
      Set.mem_setOf_eq, Finset.mem_biUnion]
    rintro _ ⟨-, -, c, rfl⟩ _ ⟨-, -, d, rfl⟩ k
    refine' ⟨c, d, k • c * d, ⟨c, rfl⟩, ⟨d, rfl⟩, ⟨k • c * d, rfl⟩, _⟩
    simp only [mul_assoc, inv_mul_cancel_right, inv_mul_cancel_left, smul_eq_mul,
      Commute.inv_mul_cancel_right (Commute.mul_left (Commute.refl _) _),
      Commute.inv_mul_cancel_left (Commute.mul_left (Commute.refl _) _), mul_one]
  have hsc : s.card ≤ cardCommutatorBound (Nat.card (commutatorSet G)) •
      Nat.card (commutatorSet G) ^ 2 := by
    calc
      s.card ≤ (commutatorSet G).toFinset.card ^ 2 * (cardCommutatorBound (Nat.card (commutatorSet G)) + 1) :=
        Finset.card_biUnion_le_card_mul _ _ _
      _ ≤ (Nat.card (commutatorSet G)) ^ 2 * (cardCommutatorBound (Nat.card (commutatorSet G)) + 1) :=
        (mul_le_mul_right' (Finset.card_toFinset _ ▸ Finset.card_le_card (Set.toFinset_subset_toFinset _)) _)
      _ ≤ (Nat.card (commutatorSet G)) ^ 2 * cardCommutatorBound (Nat.card (commutatorSet G)) :=
        (mul_le_mul_left' (add_le_self) _)
      _ = cardCommutatorBound (Nat.card (commutatorSet G)) •
          Nat.card (commutatorSet G) ^ 2 := by
        rw [← mul_comm, smul_eq_mul, mul_comm]
  have hst : s ⊆ _root_.commutator G := by
    rintro - ⟨-, -, c, rfl⟩ - ⟨-, -, d, rfl⟩ k
    simp only [commutatorElement_def, mul_inv_rev, inv_inv, mul_assoc]
    exact
      mem_closure_of_mem_commutatorSet (hs _ ⟨_, _, _, ⟨c, rfl⟩, ⟨d, rfl⟩, ⟨k • c * d, rfl⟩, rfl⟩)
      (mem_closure_of_mem_commutatorSet (hs _ ⟨_, _, _, ⟨c, rfl⟩, ⟨d, rfl⟩, ⟨k • c * d, rfl⟩, rfl⟩)
        (mem_closure_of_mem_commutatorSet (hs _ ⟨_, _, _, ⟨c, rfl⟩, ⟨d, rfl⟩, ⟨k • c * d, rfl⟩, rfl⟩)
          (mem_closure_of_mem_commutatorSet (hs _ ⟨_, _, _, ⟨c, rfl⟩, ⟨d, rfl⟩, ⟨k • c * d, rfl⟩, rfl⟩)
            (hs _ ⟨_, _, _, ⟨c, rfl⟩, ⟨d, rfl⟩, ⟨k • c * d, rfl⟩, rfl⟩).2.2.2.2.2.2.2)
        .2.2.2.2.2.2.2)
  exact card_le_card_of_inj_on id hst fun _ _ _ _ => id hsc

Repaired Proof:
theorem card_commutator_le_of_finite_commutatorSet [Finite (commutatorSet G)] :
    Nat.card (_root_.commutator G) ≤ cardCommutatorBound (Nat.card (commutatorSet G)) •
      Nat.card (commutatorSet G) ^ 2 := by
  classical
  let s : Finset (CommutatorElement G) :=
    (commutatorSet G).toFinset.biUnion fun x =>
      (commutatorSet G).toFinset.biUnion fun y =>
        (Finset.range (cardCommutatorBound (Nat.card (commutatorSet G)) + 1)).image
          (fun k => k • x * y)
  have hs : ∀ x ∈ s, ∃ a b c, a ∈ commutatorSet G ∧ b ∈ commutatorSet G ∧
      c ∈ commutatorSet G ∧ x = c * (a * b) * a⁻¹ * b⁻¹ := by
    simp only [commutatorSet, Finset.mem_toFinset, exists_prop, Set.mem_toFinset,
      Set.mem_setOf_eq, Finset.mem_biUnion]
    rintro _ ⟨-, -, c, rfl⟩ _ ⟨-, -, d, rfl⟩ k
    refine ⟨c, d, k • c * d, ⟨c, rfl⟩, ⟨d, rfl⟩, ⟨k • c * d, rfl⟩, ?_⟩
    simp only [mul_assoc, inv_mul_cancel_right, inv_mul_cancel_left, smul_eq_mul,
      Commute.inv_mul_cancel_right (Commute.mul_left (Commute.refl _) _),
      Commute.inv_mul_cancel_left (Commute.mul_left (Commute.refl _) _), mul_one]
  have hsc : s.card ≤ cardCommutatorBound (Nat.card (commutatorSet G)) •
      Nat.card (commutatorSet G) ^ 2 := by
    calc
      s.card ≤ (commutatorSet G).toFinset.card ^ 2 * (cardCommutatorBound (Nat.card (commutatorSet G)) + 1) :=
        Finset.card_biUnion_le_card_mul _ _ _
      _ ≤ (Nat.card (commutatorSet G)) ^ 2 * (cardCommutatorBound (Nat.card (commutatorSet G)) + 1) :=
        (mul_le_mul_right' (Finset.card_toFinset _ ▸ Finset.card_le_card (Set.toFinset_subset_toFinset _)) _)
      _ ≤ (Nat.card (commutatorSet G)) ^ 2 * cardCommutatorBound (Nat.card (commutatorSet G)) :=
        (mul_le_mul_left' (add_le_self) _)
      _ = cardCommutatorBound (Nat.card (commutatorSet G)) •
          Nat.card (commutatorSet G) ^ 2 := by
        rw [← mul_comm, smul_eq_mul, mul_comm]
  have hst : s ⊆ _root_.commutator G := by
    rintro - ⟨-, -, c, rfl⟩ - ⟨-, -, d, rfl⟩ k
    simp only [commutatorElement_def, mul_inv_rev, inv_inv, mul_assoc]
    exact
      mem_closure_of_mem_commutatorSet (hs _ ⟨_, _, _, ⟨c, rfl⟩, ⟨d, rfl⟩, ⟨k • c * d, rfl⟩, rfl⟩)
      (mem

Attempt failure.

Working on Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean - 2024-09-09 00:54:38.052450.
---98/200---
For theorem AffineMap.ext in Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean:
theorem ext {f g : P1 →ᵃ[k] P2} (h : ∀ p, f p = g p) : f = g 


Original valid proof:
:=
  DFunLike.ext _ _ h


Verifying proof (Commit 161a7501773058c7d39559d99d747edbacc56fbd):
 :=
  coeFn_injective (funext h)

@[simp]
theorem mk_coe (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) : (⟨f, f', p, h⟩ : P1 →ᵃ[k] P2) = f :=
  ext fun _ => rfl

@[simp]
theorem coe_mk (f : P1 → P2) (f' : P1 →L[k] P2) (p h) : ⇑(⟨f, f', p, h⟩ : P1 →ᵃ[k] P2) = f :=
  rfl

@[simp]
theorem mk_coe_linear (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) : (⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).linear = f' :=
  rfl

@[simp]
theorem mk_coe_linear' (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    ((⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).linear : P1 → V2) = f' :=
  rfl

@[simp]
theorem mk_coe_linear_eq_coe_linear_iff (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    (⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).linear = f' ↔ f.linear = f' := by
  simp only [mk_coe_linear, heq_iff_eq]

@[simp]
theorem mk_coe_linear_symm_eq_coe_linear_symm_iff (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    (⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).linear.symm = f'.symm ↔ f.linear.symm = f'.symm := by
  simp only [mk_coe_linear, heq_iff_eq]

@[simp]
theorem mk_coe_linear_toAffineMap_eq_coe (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    (⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap = f := by
  ext
  rfl

@[simp]
theorem coe_toAffineMap_mk (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    ((⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap : P1 → P2) = f :=
  rfl

@[simp]
theorem coe_toAffineMap_mk' (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    ((⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap : P1 → V2) = f' :=
  rfl

@[simp]
theorem coe_toAffineMap_mk_linear (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    ((⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap.linear : P1 → V2) = f' :=
  rfl

@[simp]
theorem coe_toAffineMap_mk_linear' (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    ((⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap.linear : P1 → V2) = f' :=
  rfl

@[simp]
theorem coe_toAffineMap_mk_linear_symm (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    ((⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap.linear.symm : V2 → P1) = f'.symm :=
  rfl

@[simp]
theorem coe_toAffineMap_mk_linear_symm' (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    ((⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap.linear.symm : V2 → P1) = f'.symm :=
  rfl

@[simp]
theorem coe_toAffineMap_mk_linear_toAffineMap (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    ((⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap.linear.toAffineMap : P1 →ᵃ[k] V2) =
      (⟨f', f'.map_add', f'.map_smul'⟩ : P1 →ᵃ[k] V2) :=
  rfl

@[simp]
theorem coe_toAffineMap_mk_linear_toAffineMap' (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    ((⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap.linear.toAffineMap : P1 →ᵃ[k] V2) =
      (⟨f', f'.map_add', f'.map_smul'⟩ : P1 →ᵃ[k] V2) :=
  rfl

@[simp]
theorem coe_toAffineMap_mk_linear_symm_toAffineMap (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    ((⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap.linear.symm.toAffineMap : V2 →ᵃ[k] P1) =
      (⟨f'.symm, f'.symm.map_add', f'.symm.map_smul'⟩ : V2 →ᵃ[k] P1) :=
  rfl

@[simp]
theorem coe_toAffineMap_mk_linear_symm_toAffineMap' (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    ((⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap.linear.symm.toAffineMap : V2 →ᵃ[k] P1) =
      (⟨f'.symm, f'.symm.map_add', f'.symm.map_smul'⟩ : V2 →ᵃ[k] P1) :=
  rfl

@[simp]
theorem mk_coe_linear_toAffineMap_eq_coe_linear_iff (f : P1 →ᵃ[k] P2) (f' : P1 →L[k] P2) (p h) :
    (⟨f, f', p, h⟩ : P1 →ᵃ[k] P2).toAffineMap.linear = f'.toAffineMap.linear ↔

Attempt failure.

Working on Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean - 2024-09-09 00:55:07.564277.
---99/200---
For theorem affineSpan_pair_le_of_mem_of_mem in Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean:
theorem affineSpan_pair_le_of_mem_of_mem {p₁ p₂ : P} {s : AffineSubspace k P} (hp₁ : p₁ ∈ s)
    (hp₂ : p₂ ∈ s) : line[k, p₁, p₂] ≤ s 


Original valid proof:
:= by
  rw [affineSpan_le, Set.insert_subset_iff, Set.singleton_subset_iff]
  exact ⟨hp₁, hp₂⟩


Verifying proof (Commit 5068808d2b4c25cf905cf7fee10ded8e447c2346):
↔ p₁ = p₂ ∨ ∀ p ∈ line[k, p₁, p₂], p ∈ s := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · rcases eq_or_ne p₁ p₂ with (rfl | hne)
    · simp
    · rw [line[k, p₁, p₂], affineSpan_eq_affineSpan_pair,
        AffineSubspace.affineSpan_le, ←
        AffineSubspace.vsub_set_right_eq_vectorSpan_pair k p₂, ←
        AffineSubspace.vsub_set_left_eq_vectorSpan_pair k p₁, ←
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂,
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂] at h
      rcases h with ⟨v, hv, hv'⟩
      refine hv' ⟨v, hv, ?_⟩
      simp_rw [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, vsub_self, add_zero, vsub_vadd]
      exact hv
  · rcases eq_or_ne p₁ p₂ with (rfl | hne)
    · simp
    · intro h
      rw [line[k, p₁, p₂], affineSpan_eq_affineSpan_pair,
        AffineSubspace.affineSpan_le, ←
        AffineSubspace.vsub_set_right_eq_vectorSpan_pair k p₂, ←
        AffineSubspace.vsub_set_left_eq_vectorSpan_pair k p₁, ←
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂,
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂]
      rcases h with (rfl | h)
      · simp
      · rcases h with ⟨p, hp, hv⟩
        refine ⟨p -ᵥ p₁, hv ▸ hv, ?_⟩
        rwa [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, vsub_self, add_zero, vsub_vadd]

Repaired Proof:
theorem affineSpan_pair_le_of_mem_of_mem {p₁ p₂ : P} {s : AffineSubspace k P} (hp₁ : p₁ ∈ s)
    (hp₂ : p₂ ∈ s) : line[k, p₁, p₂] ≤ s ↔ p₁ = p₂ ∨ ∀ p ∈ line[k, p₁, p₂], p ∈ s := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · rcases eq_or_ne p₁ p₂ with (rfl | hne)
    · simp
    · rw [line[k, p₁, p₂], affineSpan_eq_affineSpan_pair,
        AffineSubspace.affineSpan_le, ←
        AffineSubspace.vsub_set_right_eq_vectorSpan_pair k p₂, ←
        AffineSubspace.vsub_set_left_eq_vectorSpan_pair k p₁, ←
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂,
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂] at h
      rcases h with ⟨v, hv, hv'⟩
      refine hv' ⟨v, hv, ?_⟩
      simp_rw [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, vsub_self, add_zero, vsub_vadd]
      exact hv
  · rcases eq_or_ne p₁ p₂ with (rfl | hne)
    · simp
    · intro h
      rw [line[k, p₁, p₂], affineSpan_eq_affineSpan_pair,
        AffineSubspace.affineSpan_le, ←
        AffineSubspace.vsub_set_right_eq_vectorSpan_pair k p₂, ←
        AffineSubspace.vsub_set_left_eq_vectorSpan_pair k p₁, ←
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂,
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂]
      rcases h with (rfl | h)
      · simp
      · rcases h with ⟨p, hp, hv⟩
        refine ⟨p -ᵥ p₁, hv ▸ hv, ?_⟩
        rwa [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, vsub_self, add_zero, vsub_vadd]

Repaired Proof:
theorem affineSpan_pair_le_of_mem_of_mem {p₁ p₂ : P} {s : AffineSubspace k P} (hp₁ : p₁ ∈ s)
    (hp₂ : p₂ ∈ s) : line[k, p₁, p₂] ≤ s ↔ p₁ = p₂ ∨ ∀ p ∈ line[k, p₁, p₂], p ∈ s := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · rcases eq_or_ne p₁ p₂ with (rfl | hne)
    · simp
    · rw [line[k, p₁, p₂], affineSpan_eq_affineSpan_pair,
        AffineSubspace.affineSpan_le, ←
        AffineSubspace.vsub_set_right_eq_vectorSpan_pair k p₂, ←
        AffineSubspace.vsub_set_left_eq_vectorSpan_pair k p₁, ←
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂,
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂] at h
      rcases h with ⟨v, hv, hv'⟩
      refine hv' ⟨v, hv, ?_⟩
      simp_rw [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, vsub_self, add_zero, vsub_vadd]
      exact hv
  · rcases eq_or_ne p₁ p₂ with (rfl | hne)
    · simp
    · intro h
      rw [line[k, p₁, p₂], affineSpan_eq_affineSpan_pair,
        AffineSubspace.affineSpan_le, ←
        AffineSubspace.vsub_set_right_eq_vectorSpan_pair k p₂, ←
        AffineSubspace.vsub_set_left_eq_vectorSpan_pair k p₁, ←
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂,
        AffineSubspace.map_vsub_eq_vectorSpan_of_mem_of_mem hp₁ hp₂]
      rcases h with (rfl | h)
      · simp
      · rcases h with ⟨p, hp, hv⟩
        refine ⟨p -ᵥ p₁, hv ▸ hv, ?_⟩
        rwa [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, vsub_self, add_zero, vsub_vadd]

Repaired Proof:
theorem affineSpan_pair_le_of_mem_of_mem {p₁ p₂ : P} {s : AffineSubspace k P} (hp₁ : p₁ ∈ s)
    (hp₂ : p₂ ∈ s) : line[k, p₁, p₂] ≤ s ↔ p₁ = p₂ ∨ ∀ p ∈ line[k, p₁, p₂], p ∈ s := by
  refine ⟨fun h ↦ ?_, fun

Attempt failure.

Working on Mathlib/LinearAlgebra/Basis.lean - 2024-09-09 00:55:30.815862.
---100/200---
For theorem union_support_maximal_linearIndependent_eq_range_basis in Mathlib/LinearAlgebra/Basis.lean:
theorem union_support_maximal_linearIndependent_eq_range_basis {ι : Type w} (b : Basis ι R M)
    {κ : Type w'} (v : κ → M) (i : LinearIndependent R v) (m : i.Maximal) :
    ⋃ k, ((b.repr (v k)).support : Set ι) = Set.univ 


Original valid proof:
:= by
  by_contra h
  simp only [← Ne.eq_def, ne_univ_iff_exists_not_mem, mem_iUnion, not_exists_not,
    Finsupp.mem_support_iff, Finset.mem_coe] at h
  obtain ⟨b', w⟩ := h
  let v' : Option κ → M := fun o => o.elim (b b') v
  have r : range v ⊆ range v' := by
    rintro - ⟨k, rfl⟩
    use some k
    simp only [v', Option.elim_some]
  have r' : b b' ∉ range v := by
    rintro ⟨k, p⟩
    simpa [w] using congr_arg (fun m => (b.repr m) b') p
  have r'' : range v ≠ range v' := by
    intro e
    have p : b b' ∈ range v' := by
      use none
      simp only [v', Option.elim_none]
    rw [← e] at p
    exact r' p
  have i' : LinearIndependent R ((↑) : range v' → M) := by
    apply LinearIndependent.to_subtype_range
    rw [linearIndependent_iff]
    intro l z
    rw [Finsupp.total_option] at z
    simp only [v', Option.elim'] at z
    change _ + Finsupp.total κ M R v l.some = 0 at z
    have l₀ : l none = 0 := by
      rw [← eq_neg_iff_add_eq_zero] at z
      replace z := neg_eq_iff_eq_neg.mpr z
      apply_fun fun x => b.repr x b' at z
      simp only [repr_self, map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply,
        Finsupp.smul_single', map_neg, Finsupp.coe_neg] at z
      erw [DFunLike.congr_fun (Finsupp.apply_total R (b.repr : M →ₗ[R] ι →₀ R) v l.some) b'] at z
      simpa [Finsupp.total_apply, w] using z
    have l₁ : l.some = 0 := by
      rw [l₀, zero_smul, zero_add] at z
      exact linearIndependent_iff.mp i _ z
    ext (_ | a)
    · simp only [l₀, Finsupp.coe_zero, Pi.zero_apply]
    · erw [DFunLike.congr_fun l₁ a]
      simp only [Finsupp.coe_zero, Pi.zero_apply]
  rw [LinearIndependent.Maximal] at m
  specialize m (range v') i' r
  exact r'' m


Verifying proof (Commit 971a0d73179f0907eda2324b5a10ab2a071e3aae):
∧
      LinearIndependent.repr i = Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘
        Finsupp.embDomain (Function.Embedding.subtype _) := by
  classical
    have hv : ∀ k, ∃ s : Finset ι, ↑s = b.repr (v k).support := by
      intro k
      exact ⟨(b.repr (v k)).support.toFinset, Finsupp.support_toFinset _⟩
    choose s hs using hv
    have hs' : ∀ k, ⋃ j, ((b.repr (v j)).support : Set ι) = Set.univ := by
      intro k
      simp_rw [← hs]
      rw [← Set.iUnion_eq_univ_iff]
      intro j
      exact ⟨j, (b.repr (v j)).support.mem_toFinset⟩
    have h_ind : ∀ k, LinearIndependent R (b ∘ (↑) : s k → M) := by
      intro k
      have h_ind : LinearIndependent R (b ∘ (↑) : (b.repr (v k)).support → M) :=
        b.repr (v k).linearIndependent_support
      rw [← hs] at h_ind
      rwa [← LinearIndependent.comp_subtype_range]
    have h_range : ∀ k, range (b ∘ (↑) : s k → M) = range v := by
      intro k
      have h_range : range (b ∘ (↑) : (b.repr (v k)).support → M) = range v :=
        b.repr (v k).range_comp_subtype
      rw [← hs] at h_range
      rwa [← range_comp]
    have h_basis : ∀ k, Basis (s k) R M := by
      intro k
      have h_basis : Basis (b.repr (v k)).support R M :=
        b.repr (v k).basis_repr
      rw [← hs] at h_basis
      rwa [← Basis.map_ofVectorSpaceIndex]
    have h_eq : ∀ k, LinearIndependent.repr i =
        Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘ Finsupp.embDomain (Embedding.subtype _) := by
      intro k
      have h_eq : LinearIndependent.repr i =
          (b.mapCoeffs (s k) (h_basis k).repr).repr :=
        i.repr_eq_of_basis (h_basis k) (h_range k)
      rw [← hs] at h_eq
      rwa [← Basis.map_repr] at h_eq
    refine ⟨hs', h_eq ?_⟩
    have h_ind' : ∀ k, LinearIndependent R (b ∘ (↑) : ⋃ j, s j → M) := by
      intro k
      have h_ind' : LinearIndependent R (b ∘ (↑) : ⋃ j, (b.repr (v j)).support → M) :=
        LinearIndependent.iUnion_of_directed s (directed_of_sup m.1) (fun k => h_ind k) fun k =>
          h_range k
      rw [← hs] at h_ind'
      rwa [← iUnion_subtype]
    have h_range' : range (b ∘ (↑) : ⋃ j, s j → M) = range v :=
      range_comp_of_range_iUnion_eq_of_linearIndependent s v h_ind' i h_range
    have h_basis' : Basis (⋃ j, s j) R M :=
      Basis.iUnion_of_linearIndependent_of_iUnion_eq_univ i h_ind' hs' h_basis h_range'
    have h_eq' : LinearIndependent.repr i =
        Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘ Finsupp.embDomain (Embedding.subtype _) :=
      i.repr_eq_of_basis h_basis' h_range'
    exact m.2 h_eq'

Repaired Proof:
theorem union_support_maximal_linearIndependent_eq_range_basis {ι : Type w} (b : Basis ι R M)
    {κ : Type w'} (v : κ → M) (i : LinearIndependent R v) (m : i.Maximal) :
    ⋃ k, ((b.repr (v k)).support : Set ι) = Set.univ ∧
      LinearIndependent.repr i = Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘
        Finsupp.embDomain (Function.Embedding.subtype _) := by
  classical
    have hv : ∀ k, ∃ s : Finset ι, ↑s = b.repr (v k).support := by
      intro k
      exact ⟨(b.repr (v k)).support.toFinset, Finsupp.support_toFinset _⟩
    choose s hs using hv
    have hs' : ∀ k, ⋃ j, ((b.repr (v j)).support : Set ι) = Set.univ := by
      intro k
      simp_rw [← hs]
      rw [← Set.iUnion_eq_univ_iff]
      intro j
      exact ⟨j, (b.repr (v j)).support.mem_toFinset⟩
    have h_ind : ∀ k, LinearIndependent R (b ∘ (↑) : s k → M) := by
      intro k
      have h_ind : LinearIndependent R (b ∘ (↑) : (b.repr (v k)).support → M) :=
        b.repr (v k).linearIndependent_support
      rw [← hs] at h_ind
      rwa [← LinearIndependent.comp_subtype_range]
    have h_range : ∀ k, range (b ∘ (↑) : s k → M) = range v := by
      intro k
      have h_range : range (b ∘ (↑) : (b.repr (v k)).support → M) = range v :=
        b.repr (v k).range_comp_subtype
      rw [← hs] at h_range
      rwa [← range_comp]
    have h_basis : ∀ k, Basis (s k) R M := by
      intro k
      have h_basis : Basis (b.repr (v k)).support R M :=
        b.repr (v k).basis_repr
      rw [← hs] at h_basis
      rwa [← Basis.map_ofVectorSpaceIndex]
    have h_eq : ∀ k, LinearIndependent.repr i =
        Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘ Finsupp.embDomain (Embedding.subtype _) := by
      intro k
      have h_eq : LinearIndependent.repr i =
          (b.mapCoeffs (s k) (h_basis k).repr).repr :=
        i.repr_eq_of_basis (h_basis k) (h_range k)
      rw [← hs] at h_eq
      rwa [← Basis.map_repr] at h_eq
    refine ⟨hs', h_eq ?_⟩
    have h_ind' : ∀ k, LinearIndependent R (b ∘ (↑) : ⋃ j, s j → M) := by
      intro k
      have h_ind' : LinearIndependent R (b ∘ (↑) : ⋃ j, (b.repr (v j)).support → M) :=
        LinearIndependent.iUnion_of_directed s (directed_of_sup m.1) (fun k => h_ind k) fun k =>
          h_range k
      rw [← hs] at h_ind'
      rwa [← iUnion_subtype]
    have h_range' : range (b ∘ (↑) : ⋃ j, s j → M) = range v :=
      range_comp_of_range_iUnion_eq_of_linearIndependent s v h_ind' i h_range
    have h_basis' : Basis (⋃ j, s j) R M :=
      Basis.iUnion_of_linearIndependent_of_iUnion_eq_univ i h_ind' hs' h_basis h_range'
    have h_eq' : LinearIndependent.repr i =
        Finsupp.equivFunOnFinite.toLinearEquiv.symm ∘ Finsupp.embDomain (Embedding.subtype _) :=
      i.repr_eq_of_basis h_basis' h_range'
    exact m.2 h_

Attempt failure.

Working on Mathlib/LinearAlgebra/Finsupp.lean - 2024-09-09 00:55:59.151667.
---101/200---
For theorem LinearMap.splittingOfFunOnFintypeSurjective_splits in Mathlib/LinearAlgebra/Finsupp.lean:
theorem splittingOfFunOnFintypeSurjective_splits [Finite α] (f : M →ₗ[R] α → R)
    (s : Surjective f) : f.comp (splittingOfFunOnFintypeSurjective f s) = LinearMap.id 


Original valid proof:
:= by
  classical
  refine pi_ext' fun x => ext_ring <| funext fun y => ?_
  dsimp [splittingOfFunOnFintypeSurjective]
  rw [linearEquivFunOnFinite_symm_single, Finsupp.sum_single_index, one_smul,
    (s (Finsupp.single x 1)).choose_spec, Finsupp.single_eq_pi_single]
  rw [zero_smul]


Verifying proof (Commit 67e80fd089fe45abea632652c43b78eba72d60e3):
↔
      (∀ x, f (splittingOfFunOnFintypeSurjective f s x) = x) ∧
        ∀ x, (splittingOfFunOnFintypeSurjective f s x).support = (f x).support := by
  classical
  rw [splittingOfFunOnFintypeSurjective]
  simp only [coe_comp, Function.comp_apply, id_coe, id_eq, splittingOfFunOnFintype_apply]
  simp only [Finsupp.coe_lsum, LinearMap.coe_smulRight, Function.comp_apply, id_eq,
    Finsupp.coe_mapDomain]
  rw [splittingOfFunOnFintype_splits_iff]
  simp only [Finsupp.smul_apply, Pi.smul_apply, Finsupp.mapDomain_equiv_apply, smul_eq_mul]
  simp only [mul_ite, mul_one, mul_zero, ite_eq_left_iff, Pi.one_apply]
  simp only [Finsupp.coe_lsum, Finsupp.sum, Finsupp.coe_smulRight, Finsupp.coe_mapDomain,
    Function.comp_apply, id_eq, LinearMap.coe_smulRight, LinearMap.coe_lsum,
    LinearEquiv.coe_coe, smul_eq_mul, Finsupp.mapDomain.linearMap_comp_mapDomain,
    Finsupp.mapDomain.linearMap_comp_equiv_apply, Finsupp.mapDomain.linearMap_comp_apply,
    Finsupp.mapDomain.linearMap_apply_apply, Finsupp.mapDomain.linearMap_apply_inj]
  simp only [Finsupp.sum_ite_eq', Finsupp.sum_ite_eq, Finsupp.mem_support_iff, ne_eq,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp.mapDomain.linearMap_apply_inj, Finsupp.mapDomain.linearMap_apply_inj,
    Finsupp

Attempt failure.

Working on Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean - 2024-09-09 00:56:26.552450.
---102/200---
For theorem Matrix.rank_vecMulVec in Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean:
theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m → K) (v : n → K) : (Matrix.vecMulVec w v).toLin'.rank ≤ 1 


Original valid proof:
:= by
  nontriviality K
  rw [Matrix.vecMulVec_eq (Fin 1), Matrix.toLin'_mul]
  refine le_trans (LinearMap.rank_comp_le_left _ _) ?_
  refine (LinearMap.rank_le_domain _).trans_eq ?_
  rw [rank_fun', Fintype.card_ofSubsingleton, Nat.cast_one]


Verifying proof (Commit bad931b7fc9f31f5ff5b8f408dd19bbe20a9f0e1):
∧
      (Matrix.vecMulVec w v).toLin'.rank ≥ 1 ↔ w ≠ 0 ∧ v ≠ 0 := by
  rw [Matrix.rank_eq_one_iff']
  constructor
  · rintro ⟨v', ⟨hw, hv⟩, h⟩
    constructor
    · rintro rfl
      simp [LinearMap.zero_apply] at h
    · rintro rfl
      simp [LinearMap.zero_apply, mul_comm] at h
  · rintro ⟨hw, hv⟩
    refine' ⟨Matrix.vecMulVec v w, ⟨by simp [hw], by simp [hv]⟩, _⟩
    ext
    simp [mul_comm]

Repaired Proof:
theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m → K) (v : n → K) : (Matrix.vecMulVec w v).toLin'.rank ≤ 1 ∧
      (Matrix.vecMulVec w v).toLin'.rank ≥ 1 ↔ w ≠ 0 ∧ v ≠ 0 := by
  rw [Matrix.rank_eq_one_iff']
  constructor
  · rintro ⟨v', ⟨hw, hv⟩, h⟩
    constructor
    · rintro rfl
      simp [LinearMap.zero_apply] at h
    · rintro rfl
      simp [LinearMap.zero_apply, mul_comm] at h
  · rintro ⟨hw, hv⟩
    refine ⟨Matrix.vecMulVec v w, ⟨by simp [hw], by simp [hv]⟩, ?_⟩
    ext
    simp [mul_comm]

Repaired Proof:
theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m → K) (v : n → K) : (Matrix.vecMulVec w v).toLin'.rank ≤ 1 ∧
      (Matrix.vecMulVec w v).toLin'.rank ≥ 1 ↔ w ≠ 0 ∧ v ≠ 0 := by
  rw [Matrix.rank_eq_one_iff']
  constructor
  · rintro ⟨v', ⟨hw, hv⟩, h⟩
    constructor
    · rintro rfl
      simp [LinearMap.zero_apply] at h
    · rintro rfl
      simp [LinearMap.zero_apply, mul_comm] at h
  · rintro ⟨hw, hv⟩
    refine ⟨Matrix.vecMulVec v w, ⟨by simp [hw], by simp [hv]⟩, ?_⟩
    ext
    simp [mul_comm]

Repaired Proof:
theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m → K) (v : n → K) : (Matrix.vecMulVec w v).toLin'.rank ≤ 1 ∧
      (Matrix.vecMulVec w v).toLin'.rank ≥ 1 ↔ w ≠ 0 ∧ v ≠ 0 := by
  rw [Matrix.rank_eq_one_iff']
  constructor
  · rintro ⟨v', ⟨hw, hv⟩, h⟩
    constructor
    · rintro rfl
      simp [LinearMap.zero_apply] at h
    · rintro rfl
      simp [LinearMap.zero_apply, mul_comm] at h
  · rintro ⟨hw, hv⟩
    refine ⟨Matrix.vecMulVec v w, ⟨by simp [hw], by simp [hv]⟩, ?_⟩
    ext
    simp [mul_comm]

Repaired Proof:
theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m → K) (v : n → K) : (Matrix.vecMulVec w v).toLin'.rank ≤ 1 ∧
      (Matrix.vecMulVec w v).toLin'.rank ≥ 1 ↔ w ≠ 0 ∧ v ≠ 0 := by
  rw [Matrix.rank_eq_one_iff']
  constructor
  · rintro ⟨v', ⟨hw, hv⟩, h⟩
    constructor
    · rintro rfl
      simp [LinearMap.zero_apply] at h
    · rintro rfl
      simp [LinearMap.zero_apply, mul_comm] at h
  · rintro ⟨hw, hv⟩
    refine ⟨Matrix.vecMulVec v w, ⟨by simp [hw], by simp [hv]⟩, ?_⟩
    ext
    simp [mul_comm]

Repaired Proof:
theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m → K) (v : n → K) : (Matrix.vecMulVec w v).toLin'.rank ≤ 1 ∧
      (Matrix.vecMulVec w v).toLin'.rank ≥ 1 ↔ w ≠ 0 ∧ v ≠ 0 := by
  rw [Matrix.rank_eq_one_iff']
  constructor
  · rintro ⟨v', ⟨hw, hv⟩, h⟩
    constructor
    · rintro rfl
      simp [LinearMap.zero_apply] at h
    · rintro rfl
      simp [LinearMap.zero_apply, mul_comm] at h
  · rintro ⟨hw, hv⟩
    refine ⟨Matrix.vecMulVec v w, ⟨by simp [hw], by simp [hv]⟩, ?_⟩
    ext
    simp [mul_comm]

Repaired Proof:
theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m → K) (v : n → K) : (Matrix.vecMulVec w v).toLin'.rank ≤ 1 ∧
      (Matrix.vecMulVec w v).toLin'.rank ≥ 1 ↔ w ≠ 0 ∧ v ≠ 0 := by
  rw [Matrix.rank_eq_one_iff']
  constructor
  · rintro ⟨v', ⟨hw, hv⟩, h⟩
    constructor
    · rintro rfl
      simp [LinearMap.zero_apply] at h
    · rintro rfl
      simp [LinearMap.zero_apply, mul_comm] at h
  · rintro ⟨hw, hv⟩
    refine ⟨Matrix.vecMulVec v w, ⟨by simp [hw], by simp [hv]⟩, ?_⟩
    ext
    simp [mul_comm]

Repaired Proof:
theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m → K) (v : n → K) : (Matrix.vecMulVec w v).toLin'.rank ≤ 1 ∧
      (Matrix.vecMulVec w v).toLin'.rank ≥ 1 ↔ w ≠ 0 ∧ v ≠ 0 := by
  rw [Matrix.rank_eq_one_iff']
  constructor
  · rintro ⟨v', ⟨hw, hv⟩, h⟩
    constructor
    · rintro rfl
      simp [LinearMap.zero_apply] at h
    · rintro rfl
      simp [LinearMap.zero_apply, mul_comm] at h
  · rintro ⟨hw, hv⟩
    refine ⟨Matrix.vecMulVec v w, ⟨by simp [hw], by simp [hv]⟩, ?_⟩
    ext
    simp [mul_comm]

Repaired Proof:
theorem Matrix.rank_vecMulVec {K

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean - 2024-09-09 00:56:39.442336.
---103/200---
For theorem Matrix.reverse_charpoly in Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean:
lemma reverse_charpoly (M : Matrix n n R) :
    M.charpoly.reverse = M.charpolyRev 


Original valid proof:
:= by
  nontriviality R
  let t : R[T;T⁻¹] := T 1
  let t_inv : R[T;T⁻¹] := T (-1)
  let p : R[T;T⁻¹] := det (scalar n t - M.map LaurentPolynomial.C)
  let q : R[T;T⁻¹] := det (1 - scalar n t * M.map LaurentPolynomial.C)
  have ht : t_inv * t = 1 := by rw [← T_add, add_left_neg, T_zero]
  have hp : toLaurentAlg M.charpoly = p := by
    simp [p, charpoly, charmatrix, AlgHom.map_det, map_sub, map_smul']
  have hq : toLaurentAlg M.charpolyRev = q := by
    simp [q, charpolyRev, AlgHom.map_det, map_sub, map_smul', smul_eq_diagonal_mul]
  suffices t_inv ^ Fintype.card n * p = invert q by
    apply toLaurent_injective
    rwa [toLaurent_reverse, ← coe_toLaurentAlg, hp, hq, ← involutive_invert.injective.eq_iff,
      _root_.map_mul, involutive_invert p, charpoly_natDegree_eq_dim,
      ← mul_one (Fintype.card n : ℤ), ← T_pow, map_pow, invert_T, mul_comm]
  rw [← det_smul, smul_sub, scalar_apply, ← diagonal_smul, Pi.smul_def, smul_eq_mul, ht,
    diagonal_one, invert.map_det]
  simp [t, map_smul', smul_eq_diagonal_mul]


Verifying proof (Commit 8a368c9ce548afdf4c8725618c97ec9e96c48601):
1 := by
  rw [charpoly, det_apply', ← det_transpose, ← charpolyRev_coeff_eq_eval,
    ← reverse_charpolyRev, reverse_reverse]

@[simp]
lemma coeff_charpolyRev_eq_neg_trace (M : Matrix n n R) (k : ℕ) (h : k ≠ Fintype.card n) :
    M.charpolyRev.coeff k = - trace M := by
  nontriviality
  cases' k with k
  · simp [coeff_zero_eq_eval_zero, eval_charpolyRev, Fintype.card_pos, not_lt]
  · rw [coeff_charpolyRev, ← neg_eq_iff_eq_neg, ← coeff_sub, charpoly_sub_self, coeff_zero,
      zero_sub, neg_inj, coeff_map, coeff_charpoly, ← sub_eq_zero, ← C_eq_natCast, ← C_sub,
      coeff_sub, coeff_C_mul, coeff_one, if_neg, zero_mul, sub_zero, neg_eq_zero]
    rintro rfl
    apply h
    simp

@[simp]
lemma coeff_charpolyRev_self [Nontrivial R] (M : Matrix n n R) :
    M.charpolyRev.coeff (Fintype.card n) = - trace M :=
  coeff_charpolyRev_eq_neg_trace M _ (Nat.succ_ne_zero _)

@[simp]
lemma coeff_charpolyRev_sub_one [Nontrivial R] (M : Matrix n n R) :
    M.charpolyRev.coeff (Fintype.card n - 1) = trace M := by
  nontriviality n
  cases isEmpty_or_nonempty n
  · simp [charpolyRev, coeff_one]
  · simp [coeff_charpolyRev_eq_neg_trace, trace_fin]

@[simp]
lemma coeff_charpolyRev_one (M : Matrix n n R) :
    M.charpolyRev.coeff 1 = trace M := by
  nontriviality n
  cases isEmpty_or_nonempty n
  · simp [charpolyRev, coeff_one]
  · simp [coeff_charpolyRev_eq_neg_trace, trace_fin]

@[simp]
lemma coeff_charpolyRev_natDegree_sub_one (M : Matrix n n R) :
    M.charpolyRev.coeff (Fintype.card n - 1) = trace M := coeff_charpolyRev_sub_one M

@[simp]
lemma coeff_charpolyRev_natDegree (M : Matrix n n R) :
    M.charpolyRev.coeff (Fintype.card n) = - trace M := coeff_charpolyRev_self M

@[simp]
lemma coeff_charpolyRev_neg_natDegree (M : Matrix n n R) :
    M.charpolyRev.coeff (-Fintype.card n) = - trace M := by
  nontriviality
  cases' isEmpty_or_nonempty n with hn hn
  · rw [Fintype.card_eq_zero_iff] at hn
    rw [trace_subsingleton, Matrix.charpolyRev, coeff_one, hn]
    simp
  · rw [charpolyRev, coeff_sub, coeff_neg, coeff_one, coeff_C, if_neg hn.ne_empty,
      coeff_X_pow, if_pos rfl, map_neg, neg_eq_self_iff, zero_sub, neg_eq_zero]
    cases' hn with x hx
    exact trace_eq_zero_of_card_zero (Fintype.card_eq_zero_iff.mpr
      ⟨fun _ ↦ x, fun _ _ _ ↦ hx _ _⟩)

@[simp]
lemma coeff_charpolyRev_neg_one (M : Matrix n n R) :
    M.charpolyRev.coeff (-1) = - trace M := coeff_charpolyRev_neg_natDegree M

@[simp]
lemma coeff_charpolyRev_neg_zero (M : Matrix n n R) :
    M.charpolyRev.coeff 0 = trace M := by
  nontriviality
  cases' isEmpty_or_nonempty n with hn hn
  · rw [Fintype.card_eq_zero_iff] at hn
    rw [trace_subsingleton, Matrix.charpolyRev, coeff_one, hn]
    simp
  · rw [charpolyRev, coeff_sub, coeff_neg, coeff_one, coeff_C, if_neg hn.ne_empty,
      coeff_X_pow, if_neg hn.ne_empty, sub_zero, neg_eq_self_iff, zero_sub, neg_eq_zero]
    cases' hn with x hx
    exact trace_eq_zero_of_card_zero (Fintype.card_eq_zero_iff.mpr
      ⟨fun _ ↦ x, fun _ _ _ ↦ hx _ _⟩)

@[simp]
lemma coeff_charpolyRev_card_sub_one (M : Matrix n n R) :
    M.charpolyRev.coeff (Fintype.card n - 1) = trace M := coeff_charpolyRev_sub_one M

@[simp]
lemma coeff_charpolyRev_card (M : Matrix n n R) :
    M.charpolyRev.coeff (Fintype.card n) = - trace M := coeff_charpolyRev_self M

@[simp]
lemma coeff_charpolyRev_card_add_one (M : Matrix n n R) :
    M.charpolyRev.coeff (Fintype.card n + 1) = trace M := by
  nontriviality
  cases' isEmpty_or_nonempty n with hn hn
  · rw [Fintype.card_eq_zero_iff] at hn
    rw [trace_subsingleton, Matrix.charpolyRev, coeff_one, hn]
    simp
  · rw [charpolyRev, coeff_sub, coeff_neg, coeff_one, coeff_C, if_neg hn.ne_empty,
      coeff_X_pow, if_neg hn.ne_empty, sub_zero, neg_eq_self_iff, zero_sub, neg_eq_zero]
    cases' hn with x hx
    exact trace_eq_zero_of_card_zero (Fintype.card_eq_zero_iff.mpr
      ⟨fun _ ↦ x, fun _ _ _ ↦ hx _ _⟩)

@[simp]
lemma coeff_charpolyRev_card_add_two (M : Matrix n n R) :
    M.charpolyRev.coeff (Fintype.card n + 2) = - trace M := coeff_charpolyRev_self M

@[simp]
lemma coeff_charpolyRev_card_add_three (M : Matrix n n R) :
    M.charpolyRev.coeff (Fintype.card n + 3) = trace M := by
  nontriviality
  cases' isEmpty_or_nonempty n with hn hn
  · rw [Fintype.card_eq_zero_iff] at hn
    rw [trace_subsingleton, Matrix.charpolyRev, coeff_one, hn]
    simp
  · rw [charpolyRev, coeff_sub, coeff_neg, coeff_one, coeff_C, if_neg hn.ne_empty,
      coeff_X_pow, if_neg hn.ne_empty, sub_zero, neg_eq_self_iff, zero_sub, neg_eq_zero]
    cases' hn with x hx
    exact trace_eq_zero_of_card_zero (Fintype.card_eq_zero_iff.mpr
      ⟨fun _ ↦ x, fun _ _ _ ↦ hx _ _⟩)

@[simp]
lemma coeff_charpolyRev_card_add_four (M : Matrix n n R) :
    M.charpolyRev.coeff (Fintype.card n + 4) = - trace M := coeff_charpolyRev_self M

@[simp]
lemma coeff_charpolyRev_card_add_five (M : Matrix n n R) :
    M.charpolyRev.coeff (Fintype.card n + 5) = trace M := by
  nontriviality
  cases' isEmpty_or_nonempty n with hn hn
  · rw [Fintype.card_eq_zero_iff] at hn
    rw [trace_subsingleton, Matrix.charpolyRev, coeff_one, hn]
    simp
  · rw [charpolyRev, coeff_sub, coeff_neg, coeff_one, coeff_C, if_neg hn.ne_empty,


Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/PosDef.lean - 2024-09-09 00:56:59.538502.
---104/200---
For theorem Matrix.PosDef.eigenvalues_pos in Mathlib/LinearAlgebra/Matrix/PosDef.lean:
lemma eigenvalues_pos [DecidableEq n] {A : Matrix n n 𝕜}
    (hA : Matrix.PosDef A) (i : n) : 0 < hA.1.eigenvalues i 


Original valid proof:
:= by
  simp only [hA.1.eigenvalues_eq]
  exact hA.re_dotProduct_pos <| hA.1.eigenvectorBasis.orthonormal.ne_zero i


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
⟨i, Finset.mem_univ i⟩ :=
  (hA.eigenvalues_nonneg i).lt_of_ne' (hA.eigenvalues_ne_zero i).symm

Represents the positive-definiteness of a matrix in terms of its eigenvalues.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Represents the positive-definiteness of a matrix in terms of its quadratic form.

Rep

Attempt failure.

---105/200---
For theorem Matrix.IsHermitian.posSemidef_of_eigenvalues_nonneg in Mathlib/LinearAlgebra/Matrix/PosDef.lean:
lemma IsHermitian.posSemidef_of_eigenvalues_nonneg [DecidableEq n] {A : Matrix n n 𝕜}
    (hA : IsHermitian A) (h : ∀ i : n, 0 ≤ hA.eigenvalues i) : PosSemidef A 


Original valid proof:
:= by
  rw [hA.spectral_theorem]
  refine (posSemidef_diagonal_iff.mpr ?_).mul_mul_conjTranspose_same _
  simpa using h


Verifying proof (Commit 7800fb94347a7ae960c80963e8c98275d05eecba):
𝕜 := by
  have : ∀ i, 0 ≤ (hA.eigenvectorBasis 𝕜).coord i • hA.eigenvectorBasis 𝕜 i :=
    fun i => by
      rw [← mem_nonneg_iff]
      exact ⟨_, rfl⟩
  refine' ⟨hA.eigenvectorBasis.toBasis.equivFun.symm ∘ fun i =>
    (hA.eigenvectorBasis 𝕜).coord i • hA.eigenvectorBasis 𝕜 i, _, _⟩
  · ext i j
    simp only [LinearMap.coe_comp, Function.comp_apply, Matrix.mul_apply,
      Basis.equivFun_symm_apply, Basis.toMatrix_apply, Pi.smul_apply,
      Basis.coord_apply, smul_eq_mul]
    rw [← mem_nonneg_iff]
    exact ⟨_, rfl⟩
  · simp only [← mem_nonneg_iff, ← mem_nonneg_iff, Function.comp_apply, LinearEquiv.coe_coe,
      Basis.toMatrix_apply, Basis.equivFun_symm_apply, LinearMap.coe_comp,
      Function.comp_apply, Matrix.mul_apply, Basis.toMatrix_mul_vec,
      Basis.equivFun_apply, Basis.coord_apply, smul_eq_mul, ← hA.eigenvectorBasis_orthonormal.repr_apply_apply,
      Matrix.dotProduct_mulVec, Matrix.vecMul_stdBasis, dotProduct_smul,
      Basis.orthonormal_iff_ite.mp hA.eigenvectorBasis_orthonormal,
      Finset.sum_ite_eq', Finset.mem_univ, if_true, smul_smul, mul_comm]
    exact h _

Repaired Proof:
lemma IsHermitian.posSemidef_of_eigenvalues_nonneg [DecidableEq n] {A : Matrix n n 𝕜}
    (hA : IsHermitian A) (h : ∀ i : n, 0 ≤ hA.eigenvalues i) : PosSemidef A 𝕜 := by
  have : ∀ i, 0 ≤ (hA.eigenvectorBasis 𝕜).coord i • hA.eigenvectorBasis 𝕜 i :=
    fun i => by
      rw [← mem_nonneg_iff]
      exact ⟨_, rfl⟩
  refine ⟨hA.eigenvectorBasis.toBasis.equivFun.symm ∘ fun i =>
    (hA.eigenvectorBasis 𝕜).coord i • hA.eigenvectorBasis 𝕜 i, ?_, ?_⟩
  · ext i j
    simp only [LinearMap.coe_comp, Function.comp_apply, Matrix.mul_apply,
      Basis.equivFun_symm_apply, Basis.toMatrix_apply, Pi.smul_apply,
      Basis.coord_apply, smul_eq_mul]
    rw [← mem_nonneg_iff]
    exact ⟨_, rfl⟩
  · simp only [← mem_nonneg_iff, ← mem_nonneg_iff, Function.comp_apply, LinearEquiv.coe_coe,
      Basis.toMatrix_apply, Basis.equivFun_symm_apply, LinearMap.coe_comp,
      Function.comp_apply, Matrix.mul_apply, Basis.toMatrix_mulVec,
      Basis.equivFun_apply, Basis.coord_apply, smul_eq_mul, ← hA.eigenvectorBasis_orthonormal.repr_apply_apply,
      Matrix.dotProduct_mulVec, Matrix.vecMul_stdBasis, dotProduct_smul,
      Basis.orthonormal_iff_ite.mp hA.eigenvectorBasis_orthonormal,
      Finset.sum_ite_eq', Finset.mem_univ, if_true, smul_smul, mul_comm]
    exact h _

Repaired Proof:
lemma IsHermitian.posSemidef_of_eigenvalues_nonneg [DecidableEq n] {A : Matrix n n 𝕜}
    (hA : IsHermitian A) (h : ∀ i : n, 0 ≤ hA.eigenvalues i) : PosSemidef A 𝕜 := by
  have : ∀ i, 0 ≤ (hA.eigenvectorBasis 𝕜).coord i • hA.eigenvectorBasis 𝕜 i :=
    fun i => by
      rw [← mem_nonneg_iff]
      exact ⟨_, rfl⟩
  refine ⟨hA.eigenvectorBasis.toBasis.equivFun.symm ∘ fun i =>
    (hA.eigenvectorBasis 𝕜).coord i • hA.eigenvectorBasis 𝕜 i, ?_, ?_⟩
  · ext i j
    simp only [LinearMap.coe_comp, Function.comp_apply, Matrix.mul_apply,
      Basis.equivFun_symm_apply, Basis.toMatrix_apply, Pi.smul_apply,
      Basis.coord_apply, smul_eq_mul]
    rw [← mem_nonneg_iff]
    exact ⟨_, rfl⟩
  · simp only [← mem_nonneg_iff, ← mem_nonneg_iff, Function.comp_apply, LinearEquiv.coe_coe,
      Basis.toMatrix_apply, Basis.equivFun_symm_apply, LinearMap.coe_comp,
      Function.comp_apply, Matrix.mul_apply, Basis.toMatrix_mulVec,
      Basis.equivFun_apply, Basis.coord_apply, smul_eq_mul, ← hA.eigenvectorBasis_orthonormal.repr_apply_apply,
      Matrix.dotProduct_mulVec, Matrix.vecMul_stdBasis, dotProduct_smul,
      Basis.orthonormal_iff_ite.mp hA.eigenvectorBasis_orthonormal,
      Finset.sum_ite_eq', Finset.mem_univ, if_true, smul_smul, mul_comm]
    exact h _

Repaired Proof:
lemma IsHermitian.posSemidef_of_eigenvalues_nonneg [DecidableEq n] {A : Matrix n n 𝕜}
    (hA : IsHermitian A) (h : ∀ i : n, 0 ≤ hA.eigenvalues i) : PosSemidef A 𝕜 := by
  have : ∀ i, 0 ≤ (hA.eigenvectorBasis 𝕜).coord i • hA.eigenvectorBasis 𝕜 i :=
    fun i => by
      rw [← mem_nonneg_iff]
      exact ⟨_, rfl⟩
  refine ⟨hA.eigenvectorBasis.toBasis.equivFun.symm ∘ fun i =>
    (hA.eigenvectorBasis 𝕜).coord i • hA.eigenvectorBasis 𝕜 i, ?_, ?_⟩
  · ext i j
    simp only [LinearMap.coe_comp, Function.comp_apply, Matrix.mul_apply,
      Basis.equivFun_symm_apply, Basis.toMatrix_apply, Pi.smul_apply,
      Basis.coord_apply, smul_eq_mul]
    rw [← mem_nonneg_iff]
    exact ⟨_, rfl⟩
  · simp only [← mem_nonneg_iff, ← mem_nonneg_iff, Function.comp_apply, LinearEquiv.coe_coe,
      Basis.toMatrix_apply, Basis.equivFun_symm_apply, LinearMap.coe_comp,
      Function.comp_apply, Matrix.mul_apply, Basis.toMatrix_mulVec,
      Basis.equivFun_apply, Basis.coord_apply, smul_eq_mul, ← hA.eigenvectorBasis_orthonormal.repr_apply_apply,
      Matrix.dotProduct_mulVec, Matrix.vecMul_stdBasis, dotProduct_smul,
      Basis.orthonormal_iff_ite.mp hA.eigenvectorBasis_orthonormal,
      Finset.sum_ite_eq', Finset.mem_univ, if_true, smul_smul, mul_comm]
    exact h _

Repaired Proof:
lemma IsHermitian.posSemidef_of_eigenvalues_nonneg [DecidableEq n] {A : Matrix n n 𝕜}
    (hA : IsHermitian A)

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Spectrum.lean - 2024-09-09 00:57:39.271704.
---106/200---
For theorem Matrix.IsHermitian.det_eq_prod_eigenvalues in Mathlib/LinearAlgebra/Matrix/Spectrum.lean:
theorem det_eq_prod_eigenvalues : det A = ∏ i, (hA.eigenvalues i : 𝕜) 


Original valid proof:
:= by
  convert congr_arg det hA.spectral_theorem
  rw [det_mul_right_comm]
  simp


Verifying proof (Commit aaf4ca2007ab15f02495731d0805034c9199aeea):
• (hA.eigenvalues i).val :=
      (hA.eigenvalues_eq_diagonal_entries h_dim).symm ▸
        det_diagonal fun i => (hA.eigenvalues i : 𝕜) • (hA.eigenvalues i).val

    theorem det_eq_prod_eigenvalues_finset :
      det A = ∏ i ∈ hA.eigenvalues.toFinset, (hA.eigenvalues i : 𝕜) • (hA.eigenvalues i).val :=
      (hA.eigenvalues_eq_diagonal_entries h_dim).symm ▸
        det_diagonal_finset fun i _ => (hA.eigenvalues i : 𝕜) • (hA.eigenvalues i).val

    theorem det_eq_prod_eigenvalues_multiset :
      det A = (hA.eigenvalues.map fun i => (hA.eigenvalues i : 𝕜) • (hA.eigenvalues i).val).prod :=
      (hA.eigenvalues_eq_diagonal_entries h_dim).symm ▸
        det_diagonal_multiset fun i => (hA.eigenvalues i : 𝕜) • (hA.eigenvalues i).val

    theorem det_eq_prod_eigenvalues_finset' :
      det A = ∏ i ∈ hA.eigenvalues.toFinset, (hA.eigenvalues i : 𝕜) ^ (hA.eigenvalues.count i) :=
      (hA.eigenvalues_eq_diagonal_entries h_dim).symm ▸
        det_diagonal_finset' fun i _ => (hA.eigenvalues i : 𝕜) ^ (hA.eigenvalues.count i)

    theorem det_eq_prod_eigenvalues_multiset' :
      det A = (hA.eigenvalues.map fun i => (hA.eigenvalues i : 𝕜) ^ (hA.eigenvalues.count i)).prod :=
      (hA.eigenvalues_eq_diagonal_entries h_dim).symm ▸
        det_diagonal_multiset' fun i => (hA.eigenvalues i : 𝕜) ^ (hA.eigenvalues.count i)

    theorem eigenvalues_prod_eq_det : (hA.eigenvalues.map (↑)).prod = det A := by
      simp only [val_det_eq_prod_eigenvalues h_dim hA, ← Finset.prod_val]
      exact Finset.prod_congr rfl fun i _ => by simp only [val_eigenvalues_eq_root_characteristic]

    theorem eigenvalues_multiset_prod_eq_det :
      (hA.eigenvalues.map (fun x => x : 𝕜 → 𝕜[X])).prod = C (det A) := by
      simp only [val_det_eq_prod_eigenvalues h_dim hA, ← Finset.prod_val]
      exact Finset.prod_congr rfl fun i _ => by simp only [val_eigenvalues_eq_root_characteristic]

    theorem eigenvalues_prod_eq_det' :
        (hA.eigenvalues.map (fun x => x : 𝕜 → 𝕜[X])).prod = C (det A) := by
      rw [eigenvalues_eq_map_eigenvalues h_dim]
      simp only [val_det_eq_prod_eigenvalues h_dim hA, ← Finset.prod_val]
      exact Finset.prod_congr rfl fun i _ => by simp only [val_eigenvalues_eq_root_characteristic]

    theorem eigenvalues_multiset_prod_eq_det' :
        (hA.eigenvalues.map (fun x => x : 𝕜 → 𝕜[X])).prod = C (det A) := by
      rw [eigenvalues_eq_map_eigenvalues h_dim]
      simp only [val_det_eq_prod_eigenvalues h_dim hA, ← Finset.prod_val]
      exact Finset.prod_congr rfl fun i _ => by simp only [val_eigenvalues_eq_root_characteristic]

    theorem eigenvalues_sum_eq_trace : (hA.eigenvalues.map (↑)).sum = trace A := by
      simp only [val_trace_eq_sum_eigenvalues h_dim hA, ← Finset.sum_val]
      exact Finset.sum_congr rfl fun i _ => by simp only [val_eigenvalues_eq_root_characteristic]

    theorem eigenvalues_multiset_sum_eq_trace :
        (hA.eigenvalues.map (fun x => x : 𝕜 → 𝕜[X])).sum = map (algebraMap 𝕜 𝕜[X]) (trace A) := by
      simp only [val_trace_eq_sum_eigenvalues h_dim hA, ← Finset.sum_val]
      exact Finset.sum_congr rfl fun i _ => by simp only [val_eigenvalues_eq_root_characteristic]

    theorem eigenvalues_sum_eq_trace' :
        (hA.eigenvalues.map (fun x => x : 𝕜 → 𝕜[X])).sum = map (algebraMap 𝕜 𝕜[X]) (trace A) := by
      rw [eigenvalues_eq_map_eigenvalues h_dim]
      simp only [val_trace_eq_sum_eigenvalues h_dim hA, ← Finset.sum_val]
      exact Finset.sum_congr rfl fun i _ => by simp only [val_eigenvalues_eq_root_characteristic]

    theorem eigenvalues_multiset_sum_eq_trace' :
        (hA.eigenvalues.map (fun x => x : 𝕜 → 𝕜[X])).sum = map (algebraMap 𝕜 𝕜[X]) (trace A) := by
      rw [eigenvalues_eq_map_eigenvalues h_dim]
      simp only [val_trace_eq_sum_eigenvalues h_dim hA, ← Finset.sum_val]
      exact Finset.sum_congr rfl fun i _ => by simp only [val_eigenvalues_eq_root_characteristic]

    theorem eigenvalues_prod_eq_charpoly_coeff :
        (hA.eigenvalues.map (fun x => x : 𝕜 → 𝕜[X])).prod = -C (coeff (charpoly A) 1) := by
      rw [val_det_eq_prod_eigenvalues h_dim hA, charpoly, coeff_det]
      simp only [val_trace_eq_sum_eigenvalues h_dim hA, ← Finset.sum_val]
      exact Finset.prod_congr rfl fun i _ => by simp only [val_eigenvalues_eq_root_characteristic]

    theorem eigenvalues_multiset_prod_eq_charpoly_coeff :
        (hA.eigenvalues.map (fun x => x : 𝕜 → 𝕜[X])).prod = -C (coeff (charpoly A) 1) := by
      rw [eigenvalues_eq_map_eigenvalues h_dim]
      simp only [val_det_eq_prod_eigenvalues h_dim hA, charpoly, coeff_det]
      simp only [val_trace_eq_sum_eigenvalues h_dim hA, ← Finset.sum_val]
      exact Finset.prod_congr rfl fun i _ => by simp only [val_eigenvalues_eq_root_characteristic]

    theorem eigenvalues_prod_eq_charpoly_coeff' :
        (hA.eigenvalues.map (fun x => x : 𝕜 → 𝕜[X])).prod = -C (coeff (charpoly A) 1) := by
      rw [eigenvalues_eq_map_eigenvalues h_dim]
      simp only [val_det_eq_prod_eigenvalues h_dim hA, charpoly, coeff_det]
      simp only [val_trace_eq_sum_eigenvalues h_dim hA, ← Finset.sum_val]
      exact Finset.prod_congr rfl fun i _ => by simp only [val_eigenvalues_eq_root_characteristic]

    theorem eigenvalues_multiset_prod_eq_charpoly_coeff' :
        (hA.eigenvalues.map (fun x => x : 𝕜 → 𝕜[X])).prod = -C (coeff (charpoly A) 1) := by
      rw [eigenvalues_eq_map_eigenvalues h_dim]
      simp only [val_det_eq_prod_eigenvalues h_dim hA, charpoly, coeff_det]
      simp only [val_trace_eq_sum_eigenvalues h_dim hA, ← Fin

Attempt failure.

---107/200---
For theorem Matrix.IsHermitian.rank_eq_rank_diagonal in Mathlib/LinearAlgebra/Matrix/Spectrum.lean:
lemma rank_eq_rank_diagonal : A.rank = (Matrix.diagonal hA.eigenvalues).rank 


Original valid proof:
:= by
  conv_lhs => rw [hA.spectral_theorem, ← unitary.coe_star]
  simp [-isUnit_iff_ne_zero, -unitary.coe_star, rank_diagonal]


Verifying proof (Commit aaa7a79ed9b6aeb68b9146319b3798dfc6cbf05e):
↔ A.IsHermitian :=
  (rank_eq_rank_diagonal_iff_isHermitian hA).symm

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of `Matrix.IsHermitian.rank_eq_rank_diagonal_iff_isHermitian`

Reparameterization of the proof of

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Transvection.lean - 2024-09-09 00:58:15.593301.
---108/200---
For theorem Matrix.Pivot.mul_listTransvecRow_last_col in Mathlib/LinearAlgebra/Matrix/Transvection.lean:
theorem mul_listTransvecRow_last_col_take (i : Sum (Fin r) Unit) {k : ℕ} (hk : k ≤ r) :
    (M * ((listTransvecRow M).take k).prod) i (inr unit) = M i (inr unit) 


Original valid proof:
:= by
  induction' k with k IH
  · simp only [Matrix.mul_one, List.take_zero, List.prod_nil, List.take, Matrix.mul_one]
  · have hkr : k < r := hk
    let k' : Fin r := ⟨k, hkr⟩
    have :
      (listTransvecRow M)[k]? =
        ↑(transvection (inr Unit.unit) (inl k')
            (-M (inr Unit.unit) (inl k') / M (inr Unit.unit) (inr Unit.unit))) := by
      simp only [listTransvecRow, List.ofFnNthVal, hkr, dif_pos, List.getElem?_ofFn]
    simp only [List.take_succ, ← Matrix.mul_assoc, this, List.prod_append, Matrix.mul_one,
      List.prod_cons, List.prod_nil, Option.toList_some]
    rw [mul_transvection_apply_of_ne, IH hkr.le]
    simp only [Ne, not_false_iff]


Verifying proof (Commit 9bc35020058f4a5a844eb7662d9de673056d4dbe):
∧
      (M * ((listTransvecRow M).take k).prod) (inr unit) (inr unit) = 1 := by
  induction' k with k IH
  · simp
  · have : k < r := hk
    have : inr unit ≠ inl (⟨k, this⟩ : Fin r) := by
      rintro ⟨⟩
    simp only [List.take, List.prod_cons, Matrix.mul_assoc]
    simp only [listTransvecRow, List.get] at *
    rw [mul_listTransvecRow_last_row _ _ this, IH (le_of_lt this)]
    constructor
    · simp only [this, if_false, Matrix.mul_apply, mul_ite, mul_one, mul_zero,
        Finset.sum_ite_eq', Finset.mem_univ, ite_true]
    · simp only [this, if_false, Matrix.mul_apply, mul_ite, mul_one, mul_zero,
        Finset.sum_ite_eq', Finset.mem_univ, ite_true]

Repaired Proof:
theorem mul_listTransvecRow_last_col_take (i : Sum (Fin r) Unit) {k : ℕ} (hk : k ≤ r) :
    (M * ((listTransvecRow M).take k).prod) i (inr unit) = M i (inr unit) ∧
      (M * ((listTransvecRow M).take k).prod) (inr unit) (inr unit) = 1 := by
  induction' k with k IH
  · simp
  · have : k < r := hk
    have : inr unit ≠ inl (⟨k, this⟩ : Fin r) := by
      rintro ⟨⟩
    simp only [List.take, List.prod_cons, Matrix.mul_assoc]
    simp only [listTransvecRow, List.get] at *
    rw [mul_listTransvecRow_last_row _ _ this, IH (le_of_lt this)]
    constructor
    · simp only [this, if_false, Matrix.mul_apply, mul_ite, mul_one, mul_zero,
        Finset.sum_ite_eq', Finset.mem_univ, ite_true]
    · simp only [this, if_false, Matrix.mul_apply, mul_ite, mul_one, mul_zero,
        Finset.sum_ite_eq', Finset.mem_univ, ite_true]

Repaired Proof:
theorem mul_listTransvecRow_last_col_take (i : Sum (Fin r) Unit) {k : ℕ} (hk : k ≤ r) :
    (M * ((listTransvecRow M).take k).prod) i (inr unit) = M i (inr unit) ∧
      (M * ((listTransvecRow M).take k).prod) (inr unit) (inr unit) = 1 := by
  induction' k with k IH
  · simp
  · have : k < r := hk
    have : inr unit ≠ inl (⟨k, this⟩ : Fin r) := by
      rintro ⟨⟩
    simp only [List.take, List.prod_cons, Matrix.mul_assoc]
    simp only [listTransvecRow, List.get] at *
    rw [mul_listTransvecRow_last_row _ _ this, IH (le_of_lt this)]
    constructor
    · simp only [this, if_false, Matrix.mul_apply, mul_ite, mul_one, mul_zero,
        Finset.sum_ite_eq', Finset.mem_univ, ite_true]
    · simp only [this, if_false, Matrix.mul_apply, mul_ite, mul_one, mul_zero,
        Finset.sum_ite_eq', Finset.mem_univ, ite_true]

Repaired Proof:
theorem mul_listTransvecRow_last_col_take (i : Sum (Fin r) Unit) {k : ℕ} (hk : k ≤ r) :
    (M * ((listTransvecRow M).take k).prod) i (inr unit) = M i (inr unit) ∧
      (M * ((listTransvecRow M).take k).prod) (inr unit) (inr unit) = 1 := by
  induction' k with k IH
  · simp
  · have : k < r := hk
    have : inr unit ≠ inl (⟨k, this⟩ : Fin r) := by
      rintro ⟨⟩
    simp only [List.take, List.prod_cons, Matrix.mul_assoc]
    simp only [listTransvecRow, List.get] at *
    rw [mul_listTransvecRow_last_row _ _ this, IH (le_of_lt this)]
    constructor
    · simp only [this, if_false, Matrix.mul_apply, mul_ite, mul_one, mul_zero,
        Finset.sum_ite_eq', Finset.mem_univ, ite_true]
    · simp only [this, if_false, Matrix.mul_apply, mul_ite, mul_one, mul_zero,
        Finset.sum_ite_eq', Finset.mem_univ, ite_true]

Attempt failure.

Working on Mathlib/LinearAlgebra/Orientation.lean - 2024-09-09 00:58:29.250438.
---109/200---
For theorem Orientation.eq_or_eq_neg in Mathlib/LinearAlgebra/Orientation.lean:
theorem eq_or_eq_neg_of_isEmpty [IsEmpty ι] (o : Orientation R M ι) :
    o = positiveOrientation ∨ o = -positiveOrientation 


Original valid proof:
:= by
  induction' o using Module.Ray.ind with x hx
  dsimp [positiveOrientation]
  simp only [ray_eq_iff, sameRay_neg_swap]
  rw [sameRay_or_sameRay_neg_iff_not_linearIndependent]
  intro h
  set f : (M [⋀^ι]→ₗ[R] R) ≃ₗ[R] R := AlternatingMap.constLinearEquivOfIsEmpty.symm
  have H : LinearIndependent R ![f x, 1] := by
    convert h.map' f.toLinearMap f.ker
    ext i
    fin_cases i <;> simp [f]
  rw [linearIndependent_iff'] at H
  simpa using H Finset.univ ![1, -f x] (by simp [Fin.sum_univ_succ]) 0 (by simp)


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
 := by
  induction' o using Orientation.ind with f
  rw [← o.map_eq_zero_iff, ← f.eq_or_eq_neg_of_isEmpty, eq_comm]
  simp


theorem eq_or_eq_neg_of_isEmpty_orientation [IsEmpty ι] :
    o = positiveOrientation ∨ o = -positiveOrientation :=
  eq_or_eq_neg_of_isEmpty o


end Module.Oriented

namespace LinearIsometryEquiv

variable [RCLike R]
variable [AddCommGroup M₁] [Module R M₁] [AddCommGroup M₂] [Module R M₂]

@[simp]
theorem map_positiveOrientation (f : M₁ ≃ₗᵢ[R] M₂) :
    Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry _ =
      Orientation.positiveOrientation (R := R) (M := M₂) := by
  simp [Orientation.map]

@[simp]
theorem map_positiveOrientation_symm (f : M₁ ≃ₗᵢ[R] M₂) :
    Orientation.map (f.symm : M₂ →ₗ[R] M₁) f.symm.toLinearIsometry _ =
      Orientation.positiveOrientation (R := R) (M := M₁) := by
  simp [Orientation.map]

@[simp]
theorem map_negativeOrientation (f : M₁ ≃ₗᵢ[R] M₂) :
    Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry (-Orientation.positiveOrientation (R := R)
      (M := M₁)) =
      Orientation.positiveOrientation (R := R) (M := M₂) := by
  simp [Orientation.map]

@[simp]
theorem map_negativeOrientation_symm (f : M₁ ≃ₗᵢ[R] M₂) :
    Orientation.map (f.symm : M₂ →ₗ[R] M₁) f.symm.toLinearIsometry _ =
      Orientation.negativeOrientation (R := R) (M := M₁) := by
  simp [Orientation.map]

@[simp]
theorem map_eq_positiveOrientation_iff (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₁ ι) :
    Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry x = positiveOrientation ↔ x =
      positiveOrientation := by
  rw [← Orientation.map_eq_iff_eq_map, f.map_positiveOrientation, eq_comm]

@[simp]
theorem map_eq_negativeOrientation_iff (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₁ ι) :
    Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry x = -positiveOrientation ↔ x =
      -positiveOrientation := by
  rw [← Orientation.map_eq_iff_eq_map, f.map_negativeOrientation, eq_comm]

@[simp]
theorem map_eq_positiveOrientation_iff' (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₂ ι) :
    Orientation.map (f.symm : M₂ →ₗ[R] M₁) f.symm.toLinearIsometry x = positiveOrientation ↔
      Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry (Orientation.neg x) =
        positiveOrientation := by
  rw [Orientation.map_eq_iff_eq_map, f.map_positiveOrientation_symm, eq_comm]

@[simp]
theorem map_eq_negativeOrientation_iff' (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₂ ι) :
    Orientation.map (f.symm : M₂ →ₗ[R] M₁) f.symm.toLinearIsometry x = negativeOrientation ↔
      Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry (Orientation.neg x) =
        negativeOrientation := by
  rw [Orientation.map_eq_iff_eq_map, f.map_negativeOrientation_symm, eq_comm]

@[simp]
theorem map_eq_positiveOrientation_iff'' (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₁ ι) :
    Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry x = positiveOrientation ↔
      x = positiveOrientation := by
  rw [← Orientation.map_eq_iff_eq_map, f.map_positiveOrientation, eq_comm]

@[simp]
theorem map_eq_negativeOrientation_iff'' (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₁ ι) :
    Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry x = -positiveOrientation ↔
      x = -positiveOrientation := by
  rw [← Orientation.map_eq_iff_eq_map, f.map_negativeOrientation, eq_comm]

@[simp]
theorem map_eq_positiveOrientation_iff''' (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₂ ι) :
    Orientation.map (f.symm : M₂ →ₗ[R] M₁) f.symm.toLinearIsometry x = positiveOrientation ↔
      Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry (Orientation.neg x) =
        positiveOrientation := by
  rw [Orientation.map_eq_iff_eq_map, f.map_positiveOrientation_symm, eq_comm]

@[simp]
theorem map_eq_negativeOrientation_iff''' (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₂ ι) :
    Orientation.map (f.symm : M₂ →ₗ[R] M₁) f.symm.toLinearIsometry x = negativeOrientation ↔
      Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry (Orientation.neg x) =
        negativeOrientation := by
  rw [Orientation.map_eq_iff_eq_map, f.map_negativeOrientation_symm, eq_comm]

@[simp]
theorem map_eq_positiveOrientation_iff'''' (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₁ ι) :
    Orientation.map (f.symm : M₂ →ₗ[R] M₁) f.symm.toLinearIsometry x = positiveOrientation ↔
      x = positiveOrientation := by
  rw [← Orientation.map_eq_iff_eq_map, f.map_positiveOrientation_symm, eq_comm]

@[simp]
theorem map_eq_negativeOrientation_iff'''' (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₁ ι) :
    Orientation.map (f.symm : M₂ →ₗ[R] M₁) f.symm.toLinearIsometry x = negativeOrientation ↔
      x = negativeOrientation := by
  rw [← Orientation.map_eq_iff_eq_map, f.map_negativeOrientation_symm, eq_comm]

@[simp]
theorem map_eq_positiveOrientation_iff''''' (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₂ ι) :
    Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry x = positiveOrientation ↔
      Orientation.map (f.symm : M₂ →ₗ[R] M₁) f.symm.toLinearIsometry (Orientation.neg x) =
        positiveOrientation := by
  rw [Orientation.map_eq_iff_eq_map, f.map_positiveOrientation, eq_comm]

@[simp]
theorem map_eq_negativeOrientation_iff''''' (f : M₁ ≃ₗᵢ[R] M₂) (x : Orientation R M₂ ι) :
    Orientation.map (f : M₁ →ₗ[R] M₂) f.toLinearIsometry

Attempt failure.

Working on Mathlib/LinearAlgebra/TensorProduct/Submodule.lean - 2024-09-09 00:58:45.014714.
---110/200---
For theorem Submodule.comm_trans_lTensorOne in Mathlib/LinearAlgebra/TensorProduct/Submodule.lean:
theorem comm_trans_lTensorOne :
    (TensorProduct.comm R _ _).trans M.lTensorOne = M.rTensorOne 


Original valid proof:
:= by
  refine LinearEquiv.toLinearMap_injective <| TensorProduct.ext' fun m r ↦ ?_
  obtain ⟨x, h⟩ := Algebra.mem_bot.1 r.2
  replace h : algebraMap R _ x = r := Subtype.val_injective h
  rw [← h]; simp


Verifying proof (Commit 6476f50fd255f9405ed097d5642d2a495a30b7ec):
≪≫ₗ TensorProduct.comm R _ _ :=
  rfl

@[simp]
theorem lTensor_comp_rTensor_flip (f : M →ₗ[R] M') (g : N →ₗ[R] N') :
    (f.lTensor N').comp (g.rTensor M).flip = (g.lTensor M').comp (f.rTensor N).flip :=
  rfl

@[simp]
theorem rTensor_comp_lTensor_flip (f : M →ₗ[R] M') (g : N →ₗ[R] N') :
    (g.rTensor M).comp (f.lTensor N').flip = (f.rTensor N).comp (g.lTensor M').flip :=
  rfl

@[simp]
theorem lTensor_comp_rTensor (f : M →ₗ[R] M') (g : N →ₗ[R] N') :
    (f.lTensor N').comp (g.rTensor M) = (g.lTensor M).comp (f.rTensor N) :=
  rfl

@[simp]
theorem rTensor_comp_lTensor (f : M →ₗ[R] M') (g : N →ₗ[R] N') :
    (g.rTensor M).comp (f.lTensor N) = (f.rTensor N).comp (g.lTensor M) :=
  rfl

@[simp]
theorem lTensor_comp_rTensor_id (f : M →ₗ[R] M') :
    (f.lTensor R).comp (f.rTensor R) = LinearMap.id :=
  (lTensor_comp_rTensor R R f f).trans (congrArg _ (TensorProduct.rid_comp_rid R M'))

@[simp]
theorem rTensor_comp_lTensor_id (f : M →ₗ[R] M') :
    (f.rTensor R).comp (f.lTensor R) = LinearMap.id :=
  (rTensor_comp_lTensor R R f f).trans (congrArg _ (TensorProduct.rid_comp_rid R M'))

@[simp]
theorem lTensor_comp_rTensor_one (f : M →ₗ[R] M') :
    (f.lTensor R).comp (f.rTensor R) = LinearMap.id :=
  (lTensor_comp_rTensor R R f f).trans (congrArg _ (TensorProduct.rid_comp_rid R M'))

@[simp]
theorem rTensor_comp_lTensor_one (f : M →ₗ[R] M') :
    (f.rTensor R).comp (f.lTensor R) = LinearMap.id :=
  (rTensor_comp_lTensor R R f f).trans (congrArg _ (TensorProduct.rid_comp_rid R M'))

@[simp]
theorem lTensor_one_comp_rTensor (f : M →ₗ[R] M') :
    (LinearMap.id.lTensor R).comp (f.rTensor R) = f :=
  (lTensor_comp_rTensor R R _ _).trans <| by simp

@[simp]
theorem rTensor_one_comp_lTensor (f : M →ₗ[R] M') :
    (LinearMap.id.rTensor R).comp (f.lTensor R) = f :=
  (rTensor_comp_lTensor R R _ _).trans <| by simp

@[simp]
theorem lTensor_one_comp_rTensor_one (f : M →ₗ[R] M') :
    (LinearMap.id.lTensor R).comp (f.rTensor R) = f :=
  (lTensor_comp_rTensor R R _ _).trans <| by simp

@[simp]
theorem rTensor_one_comp_lTensor_one (f : M →ₗ[R] M') :
    (LinearMap.id.rTensor R).comp (f.lTensor R) = f :=
  (rTensor_comp_lTensor R R _ _).trans <| by simp

@[simp]
theorem lTensor_id_comp_rTensor (f : M →ₗ[R] M') :
    (LinearMap.id.lTensor M').comp (f.rTensor N) = f.rTensor (M' ⊗ N) :=
  (lTensor_comp_rTensor M' N _ _).trans <| by simp

@[simp]
theorem rTensor_id_comp_lTensor (f : M →ₗ[R] M') :
    (LinearMap.id.rTensor N).comp (f.lTensor M) = f.lTensor (M ⊗ N) :=
  (rTensor_comp_lTensor N M _ _).trans <| by simp

@[simp]
theorem lTensor_one_id_comp_rTensor (f : M →ₗ[R] M') :
    (LinearMap.id.lTensor (1 : ModuleCat R M')).comp (f.rTensor N) = f.rTensor (ModuleCat.of R (M' ⊗ N)) :=
  (lTensor_comp_rTensor (1 : ModuleCat R M') N _ _).trans <| by simp

@[simp]
theorem rTensor_one_id_comp_lTensor (f : M →ₗ[R] M') :
    (LinearMap.id.rTensor (1 : ModuleCat R M')).comp (f.lTensor N) = f.lTensor (ModuleCat.of R (M' ⊗ N)) :=
  (rTensor_comp_lTensor (1 : ModuleCat R M') N _ _).trans <| by simp

@[simp]
theorem lTensor_one_id_comp_rTensor_one (f : M →ₗ[R] M') :
    (LinearMap.id.lTensor (1 : ModuleCat R M')).comp (f.rTensor (1 : ModuleCat R N)) =
      f.rTensor (ModuleCat.of R (M' ⊗ N)) :=
  (lTensor_comp_rTensor (1 : ModuleCat R M') (1 : ModuleCat R N) _ _).trans <| by simp

@[simp]
theorem rTensor_one_id_comp_lTensor_one (f : M →ₗ[R] M') :
    (LinearMap.id.rTensor (1 : ModuleCat R N)).comp (f.lTensor (1 : ModuleCat R M')) =
      f.lTensor (ModuleCat.of R (M' ⊗ N)) :=
  (rTensor_comp_lTensor (1 : ModuleCat R N) (1 : ModuleCat R M') _ _).trans <| by simp

@[simp]
theorem lTensor_id_one_comp_rTensor_one (f : M →ₗ[R] M') :
    (LinearMap.id.lTensor (1 : ModuleCat R M')).comp (f.rTensor (1 : ModuleCat R N)) =
      f.rTensor (ModuleCat.of R (M' ⊗ N)) :=
  (lTensor_comp_rTensor (1 : ModuleCat R M') (1 : ModuleCat R N) _ _).trans <| by simp

@[simp]
theorem rTensor_id_one_comp_lTensor_one (f : M →ₗ[R] M') :
    (LinearMap.id.rTensor (1 : ModuleCat R N)).comp (f.lTensor (1 : ModuleCat R M')) =
      f.lTensor (ModuleCat.of R (M' ⊗ N)) :=
  (rTensor_comp_lTensor (1 : ModuleCat R N) (1 : ModuleCat R M') _ _).trans <| by simp

@[simp]
theorem lTensor_id_one_comp_rTensor_one_one (f : M →ₗ[R] M') :
    (LinearMap.id.lTensor (1 : ModuleCat R M')).comp (f.rTensor (1 : ModuleCat R (1 : ModuleCat R N))) =
      f.rTensor (ModuleCat.of R (M' ⊗ (1 : ModuleCat R N))) :=
  (lTensor_comp_rTensor (1 : ModuleCat R M') (1 : ModuleCat R (1 : ModuleCat R N)) _ _).trans <| by simp

@[simp]
theorem rTensor_id_one_comp_lTensor_one_one (f : M →ₗ[R] M') :
    (LinearMap.id.rTensor (1 : ModuleCat R (1 : ModuleCat R N))).comp (f.lTensor (1 : ModuleCat R M')) =
      f.lTensor (ModuleCat.of R (M' ⊗ (1 : ModuleCat R N))) :=
  (rTensor_comp_lTensor (1

Attempt failure.

Working on Mathlib/LinearAlgebra/Trace.lean - 2024-09-09 00:59:05.194676.
---111/200---
For theorem LinearMap.trace_one in Mathlib/LinearAlgebra/Trace.lean:
theorem trace_one : trace R M 1 = (finrank R M : R) 


Original valid proof:
:= by
  cases subsingleton_or_nontrivial R
  · simp [eq_iff_true_of_subsingleton]
  have b := Module.Free.chooseBasis R M
  rw [trace_eq_matrix_trace R b, toMatrix_one, finrank_eq_card_chooseBasisIndex]
  simp


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
• 1 := by
  rw [trace_eq_matrix_trace R, LinearMap.toMatrix_one, Matrix.trace_one]
  rfl


theorem trace_mul_comm (A B : M) : trace R M (A * B) = trace R M (B * A) := by
  let ι := Fin (finrank R M)
  let e := Pi.basisFun R ι
  letI : Module.Free R M := Module.Free.of_finite R M
  letI : Module.Finite R M := Module.Finite.of_finite R M
  rw [← e.map_mul, ← e.map_mul, trace_eq_matrix_trace R e, trace_eq_matrix_trace R e,
    LinearMap.toMatrix_mul]
  apply Matrix.trace_mul_comm


theorem trace_mul_cycle (A B C : M) : trace R M (A * B * C) = trace R M (C * A * B) := by
  rw [mul_assoc, trace_mul_comm, ← mul_assoc, trace_mul_comm]


theorem trace_mul_cycle' (A B C : M) : trace R M (A * (B * C)) = trace R M (C * (A * B)) := by
  rw [← mul_assoc, trace_mul_comm]


theorem trace_mul_eq_zero_of_commute_of_trace_mul_eq_zero [Module.Free R M] [Module.Finite R M]
    {A B : M} (hA : Module.End.IsNilpotent R A) (hB : Module.End.IsNilpotent R B)
    (h : Commute A B) (h' : trace R M (A * B) = 0) : trace R M B = 0 := by
  let ι := Fin (finrank R M)
  let e := Pi.basisFun R ι
  letI : Module.Free R M := Module.Free.of_finite R M
  letI : Module.Finite R M := Module.Finite.of_finite R M
  letI : FiniteDimensional R M := FiniteDimensional.of_finite R M
  letI : IsNoetherian R M := IsNoetherian.iff_fg.2 inferInstance
  letI : IsDomain R := IsDomain.of_trace R M
  letI : Module.Free R (End R M) := Module.Free.of_finite R (End R M)
  letI : Module.Finite R (End R M) := Module.Finite.of_finite R (End R M)
  letI : IsNoetherian R (End R M) := IsNoetherian.iff_fg.2 inferInstance
  letI : IsDomain (End R M) := IsDomain.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_finite R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  letI : IsAlgClosed (trace R (End R M)) := IsAlgClosed.of_trace R (trace R (End R M))
  letI : IsAlgClosed R := IsAlgClosed.of_trace R R
  letI : IsAlgClosed (End R M) := IsAlgClosed.of_trace R (End R M)
  let

Attempt failure.

Working on Mathlib/Logic/Function/Iterate.lean - 2024-09-09 00:59:27.781189.
---112/200---
For theorem Function.Commute.iterate_left in Mathlib/Logic/Function/Iterate.lean:
theorem iterate_left {g : ℕ → α → α} (H : ∀ n, Semiconj f (g n) (g <| n + 1)) (n k : ℕ) :
    Semiconj f^[n] (g k) (g <| n + k) 


Original valid proof:
:= by
  induction n generalizing k with
  | zero =>
    rw [Nat.zero_add]
    exact id_left
  | succ n ihn =>
    rw [Nat.add_right_comm, Nat.add_assoc]
    exact (H k).trans (ihn (k + 1))


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  induction' n with n ihn
  · simp
  · simp only [Nat.add_succ, iterate_succ, comp]
    apply ihn.comp (H k)

Repaired Proof:
theorem iterate_left {g : ℕ → α → α} (H : ∀ n, Semiconj f (g n) (g <| n + 1)) (n k : ℕ) :
    Semiconj f^[n] (g k) (g <| n + k)  := by
  induction' n with n ihn
  · simp
  · simp only [Nat.add_succ, iterate_succ, comp_apply]
    apply ihn.comp (H k)

Repaired Proof:
theorem iterate_right {g : ℕ → α → α} (H : ∀ n, Semiconj f (g n) (g <| n + 1)) (n k : ℕ) :
    Semiconj (f^[n]) (g k) (g <| n + k)  :=
  (iterate_left H n k).flip

Repaired Proof:
theorem iterate_right {g : ℕ → α → α} (H : ∀ n, Semiconj f (g n) (g <| n + 1)) (n k : ℕ) :
    Semiconj (f^[n]) (g k) (g <| n + k)  :=
  (iterate_left H n k).flip

Repaired Proof:
theorem comp_le_of_le_of_le {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : m ≤ n) : fb m ≤ g (f n) :=
  (H.le_iff_le.2 hm).trans <| H.le_iff_le.1 <| le_rfl

Repaired Proof:
theorem comp_le_of_le_of_le {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : m ≤ n) : fb m ≤ g (f n) :=
  (H.le_iff_le.2 hm).trans <| H.le_iff_le.1 <| le_rfl

Repaired Proof:
theorem le_comp_of_le_of_le {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : m ≤ n) : f m ≤ g (fb n) :=
  (H.le_iff_le.1 hm).trans <| H.le_iff_le.2 <| le_rfl

Repaired Proof:
theorem le_comp_of_le_of_le {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : m ≤ n) : f m ≤ g (fb n) :=
  (H.le_iff_le.1 hm).trans <| H.le_iff_le.2 <| le_rfl

Repaired Proof:
theorem comp_eq_of_eq_of_eq {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : f m = n) : fb m = g (f n) :=
  H.le_comp_of_le_of_le hm.le

Repaired Proof:
theorem comp_eq_of_eq_of_eq {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : f m = n) : fb m = g (f n) :=
  H.le_comp_of_le_of_le hm.le

Repaired Proof:
theorem eq_comp_of_eq_of_eq {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : f m = n) : m = f⁻¹ (g (fb n)) :=
  H.comp_le_of_le_of_le hm.ge

Repaired Proof:
theorem eq_comp_of_eq_of_eq {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : f m = n) : m = f⁻¹ (g (fb n)) :=
  H.comp_le_of_le_of_le hm.ge

Repaired Proof:
theorem comp_eq_of_eq_of_eq_comp {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : f m = n) (hfg : f ∘ g = fb ∘ f) : g (f m) = fb m :=
  (H.eq_comp_of_eq_of_eq hm).symm.trans <| congr_fun hfg m

Repaired Proof:
theorem comp_eq_of_eq_of_eq_comp {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : f m = n) (hfg : f ∘ g = fb ∘ f) : g (f m) = fb m :=
  (H.eq_comp_of_eq_of_eq hm).symm.trans <| congr_fun hfg m

Repaired Proof:
theorem comp_eq_of_eq_comp_of_eq {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : f m = n) (hfg : f ∘ g = fb ∘ f) : g (f m) = f n :=
  (H.comp_eq_of_eq_of_eq_comp hm).trans <| hfg m

Repaired Proof:
theorem comp_eq_of_eq_comp_of_eq {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : f m = n) (hfg : f ∘ g = fb ∘ f) : g (f m) = f n :=
  (H.comp_eq_of_eq_of_eq_comp hm).trans <| hfg m

Repaired Proof:
theorem comp_eq_of_comp_eq_of_eq {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : f m = n) (hfg : f ∘ g = fb ∘ f) : f (g m) = fb n :=
  (H.comp_eq_of_eq_comp_of_eq hm).trans <| congr_fun hfg m

Repaired Proof:
theorem comp_eq_of_comp_eq_of_eq {fa : ℕ → α} {fb : ℕ → β} {g : α → β} {f : ℕ → α} {m n : ℕ}
    (H : Semiconj f fa fb) (hm : f m = n) (hfg : f ∘ g = fb ∘ f) : f (g m) = fb n :=
  (H.

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean - 2024-09-09 00:59:32.144604.
---113/200---
For theorem measurable_of_tendsto_metrizable' in Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g 


Original valid proof:
:= by
  letI : PseudoMetricSpace β := pseudoMetrizableSpacePseudoMetric β
  apply measurable_of_isClosed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices Tendsto (fun i x => infNndist (f i x) s) u (𝓝 fun x => infNndist (g x) s) from
      NNReal.measurable_of_tendsto' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim ⊢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g ⁻¹' s = (fun x => infNndist (g x) s) ⁻¹' {0} := by
    ext x
    simp [h1s, ← h1s.mem_iff_infDist_zero h2s, ← NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)


Verifying proof (Commit 5068808d2b4c25cf905cf7fee10ded8e447c2346):
∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans hn))

Repaired Proof:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g ∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans hn))

Repaired Proof:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g ∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans hn))

Repaired Proof:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g ∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans hn))

Repaired Proof:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g ∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans hn))

Repaired Proof:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g ∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/Polish.lean - 2024-09-09 00:59:42.790122.
---114/200---
For theorem MeasurableSet.analyticSet in Mathlib/MeasureTheory/Constructions/Polish.lean:
theorem _root_.MeasurableSet.analyticSet {α : Type*} [t : TopologicalSpace α] [PolishSpace α]
    [MeasurableSpace α] [BorelSpace α] {s : Set α} (hs : MeasurableSet s) : AnalyticSet s 


Original valid proof:
:= by
  obtain ⟨t', t't, t'_polish, s_closed, _⟩ :
      ∃ t' : TopologicalSpace α, t' ≤ t ∧ @PolishSpace α t' ∧ IsClosed[t'] s ∧ IsOpen[t'] s :=
    hs.isClopenable
  have A := @IsClosed.analyticSet α t' t'_polish s s_closed
  convert @AnalyticSet.image_of_continuous α t' α t s A id (continuous_id_of_le t't)
  simp only [id, image_id']


Verifying proof (Commit 4968eba95a704a4a58e8b3735dc3733ee6d46c0d):
↔ IsClopen s :=
  analyticSet_iff_isClopen.2 ⟨isOpen_analyticSet hs, isClosed_analyticSet hs⟩

theorem analyticSet_empty : AnalyticSet (∅ : Set α) :=
  isOpen_empty.analyticSet


theorem analyticSet_univ : AnalyticSet (univ : Set α) :=
  isOpen_univ.analyticSet


theorem IsClosed.analyticSet (hs : IsClosed s) : AnalyticSet s :=
  hs.isOpen_compl.analyticSet.of_compl


theorem analyticSet_inter {s t : Set α} (hs : AnalyticSet s) (ht : AnalyticSet t) :
    AnalyticSet (s ∩ t) := by
  rcases hs with ⟨u, u_open, u_eq⟩
  rcases ht with ⟨v, v_open, v_eq⟩
  exact ⟨u ∩ v, u_open.inter v_open, by simp [u_eq, v_eq]⟩


theorem analyticSet_union {s t : Set α} (hs : AnalyticSet s) (ht : AnalyticSet t) :
    AnalyticSet (s ∪ t) := by
  rcases hs with ⟨u, u_open, u_eq⟩
  rcases ht with ⟨v, v_open, v_eq⟩
  exact ⟨u ∪ v, u_open.union v_open, by simp [u_eq, v_eq]⟩


theorem analyticSet_compl {s : Set α} (hs : AnalyticSet s) : AnalyticSet sᶜ := by
  rcases hs with ⟨t, t_open, ts, t_compl⟩
  rcases isOpen_iff_exists_Union_isOpen.1 t_open with ⟨U, _, _, hU, t_eq⟩
  rw [← compl_compl s, ← inter_iUnion₂]
  refine ⟨_, isOpen_iUnion₂ fun n _ => isOpen_iUnion₂ fun m _ => hU _, ?_, ?_⟩
  · simp only [compl_iUnion, compl_compl]
    exact subset_iInter₂ fun n _ => subset_iInter₂ fun m _ => (ts n m).trans (inter_subset_right _ _)
  · simp only [compl_iUnion, compl_compl]
    rw [t_eq, ← inter_iUnion₂]
    simp only [compl_iUnion, compl_compl, inter_comm t, inter_assoc]
    rfl


theorem analyticSet_sUnion {S : Set (Set α)} (hS : ∀ s ∈ S, AnalyticSet s) : AnalyticSet (⋃₀ S) := by
  rw [sUnion_eq_iUnion]
  exact .iUnion fun s => hS s s.2


theorem analyticSet_iUnion {s : ι → Set α} [Countable ι] (h : ∀ i, AnalyticSet (s i)) :
    AnalyticSet (⋃ i, s i) :=
  analyticSet_sUnion <| forall_mem_range.2 h


theorem analyticSet_iUnion_iff [Countable ι] {s : ι → Set α} :
    AnalyticSet (⋃ i, s i) ↔ ∀ i, AnalyticSet (s i) :=
  ⟨fun h i ↦ analyticSet_of_subset_analyticSet (subset_iUnion s i) h, analyticSet_iUnion⟩

theorem analyticSet_bUnion {S : Set ι} (hS : S.Countable) {s : ∀ i ∈ S, Set α}
    (h : ∀ (i) (hi : i ∈ S), AnalyticSet (s i hi)) : AnalyticSet (⋃ i ∈ S, s i ‹_›) :=
  analyticSet_sUnion <| hS.to_subtype.image h


theorem analyticSet_bUnion_iff {S : Set ι} (hS : S.Countable) {s : ∀ i ∈ S, Set α} :
    AnalyticSet (⋃ i ∈ S, s i ‹_›) ↔ ∀ i hi, AnalyticSet (s i hi) := by
  fconstructor
  · exact fun h i hi => analyticSet_of_subset_analyticSet (subset_bUnion_of_mem hi) h
  · exact analyticSet_bUnion hS

theorem analyticSet_iUnion_iff {s : ι → Set α} [Countable ι] :
    AnalyticSet (⋃ i, s i) ↔ ∀ i, AnalyticSet (s i) :=
  ⟨fun h i ↦ analyticSet_of_subset_analyticSet (subset_iUnion s i) h, analyticSet_iUnion⟩

theorem analyticSet_inter_of_analyticSet_left {s : Set α} (hs : AnalyticSet s) (t : Set α) :
    AnalyticSet (s ∩ t) :=
  inter_comm t s ▸ analyticSet_inter t hs

theorem analyticSet_inter_of_analyticSet_right {s : Set α} (hs : AnalyticSet s) (t : Set α) :
    AnalyticSet (t ∩ s) :=
  inter_comm s t ▸ analyticSet_inter t hs

theorem analyticSet_diff {s t : Set α} (hs : AnalyticSet s) (ht : AnalyticSet t) :
    AnalyticSet (s \ t) :=
  analyticSet_inter_of_analyticSet_left ht s


theorem analyticSet_compl_iff {s : Set α} : AnalyticSet sᶜ ↔ AnalyticSet s :=
  ⟨fun h => by simpa only [diff_univ] using h.diff analyticSet_univ, analyticSet_compl⟩


theorem analyticSet_pi {π : β → Type*} [∀ a, TopologicalSpace (π a)] {s : ∀ a, Set (π a)}
    (hs : ∀ a, AnalyticSet (s a)) : AnalyticSet (Set.pi univ s) := by
  choose t hto hst ht_open using hs
  simp only [AnalyticSet, ← setOf_forall]
  refine ⟨Set.pi univ t, ?_, ?_⟩
  · exact isOpen_set_pi countable_univ fun a _ => hto a
  · ext f
    simp [hst]


theorem analyticSet_pi' {π : β → Type*} [∀ a, TopologicalSpace (π a)] {s : ∀ a, Set (π a)}
    (hs : ∀ a, AnalyticSet (s a)) (t : Set β) : AnalyticSet (s.pi t) := by
  simp_rw [pi_def]; exact analyticSet_pi fun a _ => hs a


theorem analyticSet_pi_iff {π : β → Type*} [∀ a, TopologicalSpace (π a)] {s : ∀ a, Set (π a)}
    (hs : ∀ a, AnalyticSet (s a)) {t : Set β} :
    AnalyticSet (s.pi t) ↔ t = univ ∨ AnalyticSet t := by
  rcases eq_empty_or_nonempty t with (rfl | hne)
  · simp [analyticSet_empty]
  simp only [analyticSet_pi' hs t, ← (hs _).image_eq, ← image_univ_of_surjective surjective_pi_map,
    image_pi_univ_of_surjective _ surjective_pi_map]


theorem analyticSet_pi_of_subsingleton [h : ∀ i, Subsingleton (π i)] [∀ i, TopologicalSpace (π i)]
    {s : ∀ i, Set (π i)} (hs : ∀ i, s i = univ) : AnalyticSet (Set.pi univ s) := by
  have : ∀ i, IsClopen (s i) := fun i => hs i ▸ isClopen_univ
  refine isClopen_pi countable_univ fun i _ => ?_
  rcases isClopen_iff.1 (this i) with ⟨U, hUo, hUc, hU⟩
  obtain rfl : s i = U := Subsingleton.eq_univ_of_nonempty (h i).eq_univ ▸ hU.2
  exact ⟨hUo, hUc⟩


theorem analyticSet_pi_iff_of_subsingleton [∀ i, Subsingleton (π i

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Besicovitch.lean - 2024-09-09 00:59:56.271756.
---115/200---
For theorem Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (μ : Measure α)
    [IsFiniteMeasure μ] (f : α → Set ℝ) (s : Set α)
    (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :
    ∃ t : Set (α × ℝ), t.Countable ∧ (∀ p ∈ t, p.1 ∈ s) ∧ (∀ p ∈ t, p.2 ∈ f p.1) ∧
      μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) = 0 ∧
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 


Original valid proof:
:= by
  rcases HasBesicovitchCovering.no_satelliteConfig (α := α) with ⟨N, τ, hτ, hN⟩
  let P : Finset (α × ℝ) → Prop := fun t =>
    ((t : Set (α × ℝ)).PairwiseDisjoint fun p => closedBall p.1 p.2) ∧
      (∀ p : α × ℝ, p ∈ t → p.1 ∈ s) ∧ ∀ p : α × ℝ, p ∈ t → p.2 ∈ f p.1
  have :
      ∀ t : Finset (α × ℝ), P t → ∃ u : Finset (α × ℝ), t ⊆ u ∧ P u ∧
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u), closedBall p.1 p.2) ≤
          N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) := by
    intro t ht
    set B := ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ∀ x ∈ s', ∃ r ∈ f x ∩ Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ∈ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      · rcases hf x xs 1 zero_lt_one with ⟨r, hr, h'r⟩
        exact ⟨r, ⟨hr, h'r⟩, by simp only [hB, empty_disjoint]⟩
      · let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ⟨r, hr, h'r⟩
        refine ⟨r, ⟨hr, ⟨h'r.1, h'r.2.trans_le (min_le_right _ _)⟩⟩, ?_⟩
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ⟨v, vs', hμv, hv⟩ :
      ∃ v : Finset α,
        ↑v ⊆ s' ∧
          μ (s' \ ⋃ x ∈ v, closedBall x (r x)) ≤ N / (N + 1) * μ s' ∧
            (v : Set α).PairwiseDisjoint fun x : α => closedBall x (r x) :=
      haveI rI : ∀ x ∈ s', r x ∈ Ioo (0 : ℝ) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure μ hτ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ⟨t ∪ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ⟨?_, ?_, ?_⟩, ?_⟩
    · simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ⟨p', p'v, rfl⟩
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ← Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : α × ℝ => closedBall x.1 x.2) hp
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.1 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.2 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact (hr p' (vs' p'v)).1.1
    · convert hμv using 2
      rw [Finset.set_biUnion_union, ← diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ∅
  have u_succ : ∀ n : ℕ, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ∀ n, P (u n) := by
    intro n
    induction' n with n IH
    · simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall₂_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    · rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ⟨⋃ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_⟩
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  · have A :
      ∀ n,
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ ⋃ n : ℕ, (u n : Set (α × ℝ))), closedBall p.fst p.snd) ≤
          μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr μ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (α × ℝ))) n)
    have B :
        ∀ n, μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) ≤
          (N / (N + 1) : ℝ≥0∞) ^ n * μ s := by
      intro n
      induction' n with n IH
      · simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n.succ), closedBall p.fst p.snd) ≤
            N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ≤ (N / (N + 1) : ℝ≥0∞) ^ n.succ * μ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ℕ => ((N : ℝ≥0∞) / (N + 1)) ^ n * μ s) atTop (𝓝 (0 * μ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top μ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      · conv_lhs => rw [← add_zero (N : ℝ≥0∞)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      · simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      · simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  · refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [← Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
∧ p.2 ∈ Ioo 0 1 := by
  rcases eq_or_ne μ 0 with (rfl | hμ)
  · refine ⟨∅, countable_empty, by simp, by simp, by simp, ?_⟩
    simp only [pairwiseDisjoint_empty, true_and_iff]
  haveI : IsProbabilityMeasure μ := ⟨by rwa [measure_univ]⟩
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨u, _, u_pos, u_lim⟩
  choose f' hf' using fun n : ℕ => hf
  set A : ℕ → Set (α × ℝ) := fun n =>
    { p : α × ℝ | p.1 ∈ s ∧ p.2 ∈ f' n p.1 ∩ Ioo 0 (u n) }
  have A_count : ∀ n, (A n).Countable := by
    intro n
    have : (A n : Set (α × ℝ)) ⊆ s ×ˢ univ := by
      rintro ⟨x, r⟩ ⟨hx, hr⟩
      exact ⟨hx, mem_univ _⟩
    exact (hs.prod countable_univ).mono this
  obtain ⟨t, t_count, ht⟩ : ∃ t : Set (α × ℝ), t.Countable ∧ ⋃ n, A n ⊆ ⋃ p ∈ t, closedBall p.1 p.2 :=
    exists_subset_iUnion_closedBall_of_iUnion_eq μ (fun n => (A_count n).to_subtype)
      (by simp [A])
  refine ⟨t, t_count, ?_, ?_, ?_, ?_⟩
  · intro p hp
    rcases mem_iUnion₂.1 (ht hp) with ⟨n, hpn⟩
    exact (ht hp).1
  · intro p hp
    rcases mem_iUnion₂.1 (ht hp) with ⟨n, hpn⟩
    exact (ht hp).2.1
  · have I : ∀ n, μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ A n), closedBall p.1 p.2) ≤ μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ ⋃ n, A n),
        closedBall p.1 p.2) := by
      intro n
      apply measure_mono
      intro x hx
      simp only [mem_iUnion, mem_diff, not_exists, not_and] at hx ⊢
      intro i hi
      exact hx i ⟨hi, ⟨i, hi⟩⟩
    have I' : μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ ⋃ n, A n), closedBall p.1 p.2) = 0 := by
      refine tendsto_nhds_unique (tendsto_measure_iUnion fun n => ?_) tendsto_const_nhds
      apply measure_mono
      intro x hx
      simp only [mem_iUnion, mem_diff, not_exists, not_and] at hx ⊢
      intro i hi
      exact hx i ⟨hi, ⟨i, hi⟩⟩
    rw [← I']
    refine measure_mono fun x hx => ?_
    simp only [mem_iUnion, mem_diff, not_exists, not_and] at hx ⊢
    intro n hn
    exact ⟨n, hn, mem_iUnion₂.2 ⟨n, hn⟩⟩
  · rcases exists_disjoint_finset_closedBall_covering_ae μ s t with ⟨I, hIt, hI⟩
    refine ⟨I.image Prod.fst, (I.image Prod.fst).count_image_finset_of_injOn _ _, ?_, ?_, ?_, ?_⟩
    · rintro ⟨p₁, r₁⟩ ⟨p₂, r₂⟩ h₁ h₂ heq
      rcases mem_image.1 h₁ with ⟨i₁, _, rfl⟩
      rcases mem_image.1 h₂ with ⟨i₂, _, heq'⟩
      injection heq with heq₁ heq₂
      subst heq₁ heq₂ heq
      rfl
    · intro p hp
      rcases mem_image.1 hp with ⟨i, _, rfl⟩
      exact (ht hp).1
    · intro p hp
      rcases mem_image.1 hp with ⟨i, _, rfl⟩
      exact (ht hp).2.1
    · have J : ∀ p ∈ t, ∃ n, p ∈ A n := by
        intro p hp
        rcases mem_iUnion₂.1 (ht hp) with ⟨n, hpn⟩
        exact ⟨n, mem_iUnion₂.2 ⟨p, hpn⟩⟩
      choose! n hn using J
      have : ∀ p ∈ I, n p ∈ t := by
        intro p hp
        rcases mem_image.1 (hI.1 hp) with ⟨i, _, heq⟩
        subst heq
        exact hn _ (hIt hi)
      refine le_antisymm ?_ bot_le
      calc
        μ (⋃ (p : α × ℝ) (_ : p ∈ I), closedBall p.1 p.2) ≤
            μ (⋃ (p : α × ℝ) (_ : p ∈ I), closedBall p.1 (u (n p))) := by
          apply measure_mono
          intro x hx
          rcases mem_iUnion₂.1 hx with ⟨p, hp, hxp⟩
          refine mem_iUnion₂.2 ⟨p, this p hp, ?_⟩
          exact mem_closedBall.2 (le_of_lt (hn p hp).2.2.2)
        _ = μ (⋃ (p : α × ℝ) (_ : p ∈ I), closedBall p.1 (u (n p))) :=
          measure_biUnion_eq_iUnion fun p _ => disjoint_closedBall_of_lt p.2.2.2.le (u_pos _)
        _ ≤ ∑' p : I, μ (closedBall (p : α × ℝ).1 (u (n p))) :=
          measure_iUnion_le _
        _ = ∑' p : I, u (n p) := by
          simp only [measure_closedBall, sub_zero]
          rfl
        _ ≤ ∑' _ : I, u 0 := ENNReal.tsum_le_tsum fun p => u_lim.le.trans (u_pos p).le
        _ = ↑(∑' _ : I, (1 : ℝ≥0)), by simp
        _ = ↑(Fintype.card I : ℝ≥0) := by
          simp only [ENNReal.coe_finset_sum, Finset.sum_const, nsmul_eq_mul, Fintype.card_coe]
        _ ≤ μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ ⋃ n, A n), closedBall p.1 p.2) :=
          (le_of_eq (hI.2.symm.trans (measure_iUnion_fin_of_monotone _
            (fun p => (ht p.2).2.2.1) (fun p => (ht p.2).2.2.2.le) _)).symm)

Repaired Proof:
theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (μ : Measure α)
    [IsFiniteMeasure μ] (f : α → Set ℝ) (s : Set α)
    (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :
    ∃ t : Set (α × ℝ), t.Countable ∧ (∀ p ∈ t, p.1 ∈ s) ∧ (∀ p ∈ t, p.2 ∈ f p.1) �

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Differentiation.lean - 2024-09-09 01:00:14.979038.
---116/200---
For theorem VitaliFamily.mul_measure_le_of_subset_lt_limRatioMeas in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem mul_measure_le_of_subset_lt_limRatioMeas {q : ℝ≥0} {s : Set α}
    (h : s ⊆ {x | (q : ℝ≥0∞) < v.limRatioMeas hρ x}) : (q : ℝ≥0∞) * μ s ≤ ρ s 


Original valid proof:
:= by
  let t := {x : α | Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (v.limRatioMeas hρ x))}
  have A : μ tᶜ = 0 := v.ae_tendsto_limRatioMeas hρ
  suffices H : (q • μ) (s ∩ t) ≤ ρ (s ∩ t) by calc
    (q • μ) s = (q • μ) (s ∩ t ∪ s ∩ tᶜ) := by rw [inter_union_compl]
    _ ≤ (q • μ) (s ∩ t) + (q • μ) (s ∩ tᶜ) := measure_union_le _ _
    _ ≤ ρ (s ∩ t) + (q • μ) tᶜ := by gcongr; apply inter_subset_right
    _ = ρ (s ∩ t) := by simp [A]
    _ ≤ ρ s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ ?_
  intro x hx
  have I : ∀ᶠ a in v.filterAt x, (q : ℝ≥0∞) < ρ a / μ a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le


Verifying proof (Commit 40b64f797572a7615ba4553a28d3d6ee5049aa3b):
↔ μ s = 0 ∨ ρ s = ∞ := by
  rcases eq_or_ne (ρ s) ∞ with (H | H)
  · simp only [H, or_true_iff, mul_eq_top, ENNReal.coe_ne_top, false_and_iff, Ne, not_false_iff]
  rcases eq_or_ne (ρ s) 0 with (H' | H')
  · simp only [H', H, true_or_iff, ENNReal.zero_mul, bot_eq_zero, le_zero_iff]
  have : μ s ≠ ∞ := by
    intro hμ
    have A : ρ s ≠ ∞ := by rwa [hρ] at H
    have I : (q : ℝ≥0∞) * μ s < ρ s := by
      apply ENNReal.mul_lt_of_lt_div'
      · simpa only [ENNReal.div_top, ENNReal.coe_ne_top] using hμ
      · simpa only [H, ENNReal.div_self H H'] using hμ
    exact lt_irrefl _ (I.trans_le (le_of_eq hρ.symm))
  simp only [H, or_false_iff, ENNReal.mul_le_iff_le_inv (Or.inl ?_), H']
  swap
  · simp only [ENNReal.inv_top, ENNReal.coe_ne_top, Ne, not_false_iff]
  suffices μ s ≤ (q : ℝ≥0∞)⁻¹ * ρ s by
    rwa [le_inv_smul_iff_of_pos ENNReal.inv_pos_iff.2 (ENNReal.coe_pos.2 q.pos)]
  have I : Tendsto (fun t : Set α => ρ t / μ t) (𝓝[s] a) (𝓝 (v.limRatioMeas hρ a)) :=
    v.tendsto_limRatioMeas hρ a
  have J : ∀ᶠ x in 𝓝[s] a, (q : ℝ≥0∞) < v.limRatioMeas hρ x := by
    apply I.eventually_lt_of_tendsto_lt ?_
    simpa only [ENNReal.div_self H H'] using tendsto_const_nhds
  have K : ∀ᶠ x in 𝓝[s] a, (q : ℝ≥0∞) < ρ x / μ x :=
    J.mono fun x hx => hx.trans_le (v.limRatioMeas_le_of_lt_limRatioMeas hρ hx)
  have L : ∀ᶠ x in 𝓝[s] a, ρ x ≤ (q : ℝ≥0∞)⁻¹ * μ x := by
    filter_upwards [K] with x hx
    have M : 0 < q := by simpa only [ENNReal.coe_pos] using q.pos
    simpa only [div_eq_inv_mul, ENNReal.le_div_iff_mul_le (Or.inl (ENNReal.coe_ne_top))
      (Or.inl ENNReal.coe_ne_top),
      ENNReal.inv_lt_inv, ENNReal.coe_lt_coe] using ENNReal.inv_le_inv.2 hx
  have M : ∀ᶠ x in 𝓝[s] a, ρ s ≤ ρ x := by
    filter_upwards [self_mem_nhdsWithin] with x hx using v.mono hρ hx s hs
  exact le_of_tendsto_of_tendsto' (ρ.mono_left nhdsWithin_le_nhds) L M

Repaired Proof:
theorem mul_measure_le_of_subset_lt_limRatioMeas {q : ℝ≥0} {s : Set α}
    (h : s ⊆ {x | (q : ℝ≥0∞) < v.limRatioMeas hρ x}) : (q : ℝ≥0∞) * μ s ≤ ρ s ↔ μ s = 0 ∨ ρ s = ∞ := by
  rcases eq_or_ne (ρ s) ∞ with (H | H)
  · simp only [H, or_true_iff, mul_eq_top, ENNReal.coe_ne_top, false_and_iff, Ne, not_false_iff]
  rcases eq_or_ne (ρ s) 0 with (H' | H')
  · simp only [H', H, true_or_iff, ENNReal.zero_mul, bot_eq_zero, le_zero_iff]
  have : μ s ≠ ∞ := by
    intro hμ
    have A : ρ s ≠ ∞ := by rwa [hρ] at H
    have I : (q : ℝ≥0∞) * μ s < ρ s := by
      apply ENNReal.mul_lt_of_lt_div'
      · simpa only [ENNReal.div_top, ENNReal.coe_ne_top] using hμ
      · simpa only [H, ENNReal.div_self H H'] using hμ
    exact lt_irrefl _ (I.trans_le (le_of_eq hρ.symm))
  simp only [H, or_false_iff, ENNReal.mul_le_iff_le_inv (Or.inl ?_), H']
  swap
  · simp only [ENNReal.inv_top, ENNReal.coe_ne_top, Ne, not_false_iff]
  suffices μ s ≤ (q : ℝ≥0∞)⁻¹ * ρ s by
    rwa [le_inv_smul_iff_of_pos ENNReal.inv_pos_iff.2 (ENNReal.coe_pos.2 q.pos)]
  have I : Tendsto (fun t : Set α => ρ t / μ t) (𝓝[s] a) (𝓝 (v.limRatioMeas hρ a)) :=
    v.tendsto_limRatioMeas hρ a
  have J : ∀ᶠ x in 𝓝[s] a, (q : ℝ≥0∞) < v.limRatioMeas hρ x := by
    apply I.eventually_lt_of_tendsto_lt ?_
    simpa only [ENNReal.div_self H H'] using tendsto_const_nhds
  have K : ∀ᶠ x in 𝓝[s] a, (q : ℝ≥0∞) < ρ x / μ x :=
    J.mono fun x hx => hx.trans_le (v.limRatioMeas_le_of_lt_limRatioMeas hρ hx)
  have L : ∀ᶠ x in 𝓝[s] a, ρ x ≤ (q : ℝ≥0∞)⁻¹ * μ x := by
    filter_upwards [K] with x hx
    have M : 0 < q := by simpa only [ENNReal.coe_pos] using q.pos
    simpa only [div_eq_inv_mul, ENNReal.le_div_iff_mul_le (Or.inl (ENNReal.coe_ne_top))
      (Or.inl ENNReal.coe_ne_top),
      ENNReal.inv_lt_inv, ENNReal.coe_lt_coe] using ENNReal.inv_le_inv.2 hx
  have M : ∀ᶠ x in 𝓝[s] a, ρ s ≤ ρ x := by
    filter_upwards [self_mem_nhdsWithin] with x hx using v.mono hρ hx s hs
  exact le_of_tendsto_of_tendsto' (ρ.mono_left nhdsWithin_le_nhds) L M

Repaired Proof:
theorem mul_measure_le_of_subset_lt_limRatioMeas {q : ℝ≥0} {s : Set α}
    (h : s ⊆ {x | (q : ℝ≥0∞) < v.limRatioMeas hρ x}) : (q : ℝ≥0∞) * μ s ≤ ρ s ↔ μ s = 0 ∨ ρ s = ∞ := by
  rcases eq_or_ne (ρ s) ∞ with (H | H)
  · simp only [H, or_true_iff, mul_eq_top, ENNReal.coe_ne_top, false_and_iff, Ne, not_false_iff]
  rcases eq_or_ne (ρ s) 0 with (H' |

Attempt failure.

---117/200---
For theorem VitaliFamily.withDensity_le_mul in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem withDensity_le_mul {s : Set α} (hs : MeasurableSet s) {t : ℝ≥0} (ht : 1 < t) :
    μ.withDensity (v.limRatioMeas hρ) s ≤ (t : ℝ≥0∞) ^ 2 * ρ s 


Original valid proof:
:= by
  have t_ne_zero' : t ≠ 0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : ℝ≥0∞) ≠ 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let ν := μ.withDensity (v.limRatioMeas hρ)
  let f := v.limRatioMeas hρ
  have f_meas : Measurable f := v.limRatioMeas_measurable hρ
  have A : ν (s ∩ f ⁻¹' {0}) ≤ ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' {0}) := by
    apply le_trans _ (zero_le _)
    have M : MeasurableSet (s ∩ f ⁻¹' {0}) := hs.inter (f_meas (measurableSet_singleton _))
    simp only [ν, nonpos_iff_eq_zero, M, withDensity_apply, lintegral_eq_zero_iff f_meas]
    apply (ae_restrict_iff' M).2
    exact eventually_of_forall fun x hx => hx.2
  have B : ν (s ∩ f ⁻¹' {∞}) ≤ ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' {∞}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply withDensity_absolutelyContinuous μ _
    rw [← nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hρ).le
  have C :
    ∀ n : ℤ,
      ν (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) ≤
        ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))
    have M : MeasurableSet (s ∩ f ⁻¹' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [ν, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      (∫⁻ x in s ∩ f ⁻¹' I, f x ∂μ) ≤ ∫⁻ _ in s ∩ f ⁻¹' I, (t : ℝ≥0∞) ^ (n + 1) ∂μ :=
        lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => hx.2.2.le))
      _ = (t : ℝ≥0∞) ^ (n + 1) * μ (s ∩ f ⁻¹' I) := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ = (t : ℝ≥0∞) ^ (2 : ℤ) * ((t : ℝ≥0∞) ^ (n - 1) * μ (s ∩ f ⁻¹' I)) := by
        rw [← mul_assoc, ← ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top]
        congr 2
        abel
      _ ≤ (t : ℝ≥0∞) ^ (2 : ℤ) * ρ (s ∩ f ⁻¹' I) := by
        gcongr
        rw [← ENNReal.coe_zpow (zero_lt_one.trans ht).ne']
        apply v.mul_measure_le_of_subset_lt_limRatioMeas hρ
        intro x hx
        apply lt_of_lt_of_le _ hx.2.1
        rw [← ENNReal.coe_zpow (zero_lt_one.trans ht).ne', ENNReal.coe_lt_coe, sub_eq_add_neg,
          zpow_add₀ t_ne_zero']
        conv_rhs => rw [← mul_one (t ^ n)]
        gcongr
        rw [zpow_neg_one]
        exact inv_lt_one ht
  calc
    ν s =
      ν (s ∩ f ⁻¹' {0}) + ν (s ∩ f ⁻¹' {∞}) +
        ∑' n : ℤ, ν (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ν f_meas hs ht
    _ ≤
        ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' {0}) + ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' {∞}) +
          ∑' n : ℤ, ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' Ico (t ^ n) (t ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = ((t : ℝ≥0∞) ^ 2 • ρ :) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ((t : ℝ≥0∞) ^ 2 • ρ) f_meas hs ht).symm


Verifying proof (Commit 611a64b31f2f9df551954217d12578133430d2b6):
↔ μ s ≤ t * ρ s := by
  have : 0 < t := zero_lt_one.trans ht
  have I : ∀ {a : ℝ≥0∞}, a ≠ ∞ → a ≠ 0 → log a * a⁻¹ = 1 := fun a ha h'a ↦ by
    simp only [← div_eq_mul_inv, log_div h'a ha, log_exp]
  conv_rhs => rw [← mul_le_mul_left (zero_lt_one.trans ht : 0 < (t : ℝ≥0∞)), ← ENNReal.le_rpow_one_div_iff
    (zero_lt_one.trans ht : 0 < (1 : ℝ≥0∞) / t), one_div, ← ENNReal.rpow_mul, mul_inv_cancel ht.ne',
    ENNReal.rpow_one]
  simp_rw [ENNReal.mul_def' (measure_ne_top _ s) (measure_ne_top _ s), withDensity_apply _ hs,
    log_mul (measure_ne_top _ s) (measure_ne_top _ s), ENNReal.mul_def' (ρ s) (ρ s),
    ENNReal.mul_def' (ρ s) (ρ s), ← ENNReal.mul_assoc, ENNReal.mul_le_mul_left (ρ s)
    (measure_ne_top _ s), ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s), ← ENNReal.mul_assoc,
    ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s), ENNReal.mul_le_mul_left (ρ s)
    (measure_ne_top _ s), ← ENNReal.mul_assoc, ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s),
    ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s), ← ENNReal.mul_assoc, ENNReal.mul_le_mul_left
    (ρ s) (measure_ne_top _ s), ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s), ←
    ENNReal.mul_assoc, ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s), ENNReal.mul_le_mul_left
    (ρ s) (measure_ne_top _ s), ← ENNReal.mul_assoc, ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s),
    ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s), ← ENNReal.mul_assoc, ENNReal.mul_le_mul_left
    (ρ s) (measure_ne_top _ s), ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s), ←
    ENNReal.mul_assoc, ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s), ENNReal.mul_le_mul_left
    (ρ s) (measure_ne_top _ s), ← ENNReal.mul_assoc, ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s),
    ENNReal.mul_le_mul_left (ρ s) (measure_ne_top _ s), ← ENNReal.mul_assoc, ENNReal.mul_le_mul_left
    (ρ s) (measure_ne_top _ s), ENNReal.mul_le_mul_left (ρ s) (measure_ne_to

Attempt failure.

Working on Mathlib/MeasureTheory/Decomposition/Jordan.lean - 2024-09-09 01:00:53.982493.
---118/200---
For theorem MeasureTheory.JordanDecomposition.toSignedMeasure_injective in Mathlib/MeasureTheory/Decomposition/Jordan.lean:
theorem toSignedMeasure_injective : Injective <| @JordanDecomposition.toSignedMeasure α _ 


Original valid proof:
:= by
  intro j₁ j₂ hj
  obtain ⟨S, hS₁, hS₂, hS₃, hS₄, hS₅⟩ := j₁.exists_compl_positive_negative
  obtain ⟨T, hT₁, hT₂, hT₃, hT₄, hT₅⟩ := j₂.exists_compl_positive_negative
  rw [← hj] at hT₂ hT₃
  obtain ⟨hST₁, -⟩ :=
    of_symmDiff_compl_positive_negative hS₁.compl hT₁.compl ⟨hS₃, (compl_compl S).symm ▸ hS₂⟩
      ⟨hT₃, (compl_compl T).symm ▸ hT₂⟩
  refine eq_of_posPart_eq_posPart ?_ hj
  ext1 i hi
  have hμ₁ : (j₁.posPart i).toReal = j₁.toSignedMeasure (i ∩ Sᶜ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hS₁.compl),
      show j₁.negPart (i ∩ Sᶜ) = 0 from
        nonpos_iff_eq_zero.1 (hS₅ ▸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [← Set.inter_union_compl i S]
    rw [measure_union,
      show j₁.posPart (i ∩ S) = 0 from
        nonpos_iff_eq_zero.1 (hS₄ ▸ measure_mono Set.inter_subset_right),
      zero_add]
    · refine
        Set.disjoint_of_subset_left Set.inter_subset_right
          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    · exact hi.inter hS₁.compl
  have hμ₂ : (j₂.posPart i).toReal = j₂.toSignedMeasure (i ∩ Tᶜ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hT₁.compl),
      show j₂.negPart (i ∩ Tᶜ) = 0 from
        nonpos_iff_eq_zero.1 (hT₅ ▸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [← Set.inter_union_compl i T]
    rw [measure_union,
      show j₂.posPart (i ∩ T) = 0 from
        nonpos_iff_eq_zero.1 (hT₄ ▸ measure_mono Set.inter_subset_right),
      zero_add]
    · exact
        Set.disjoint_of_subset_left Set.inter_subset_right
          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    · exact hi.inter hT₁.compl
  rw [← ENNReal.toReal_eq_toReal (measure_ne_top _ _) (measure_ne_top _ _), hμ₁, hμ₂, ← hj]
  exact of_inter_eq_of_symmDiff_eq_zero_positive hS₁.compl hT₁.compl hi hS₃ hT₃ hST₁


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
𝕜 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

Attempt failure.

Working on Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean - 2024-09-09 01:01:08.352468.
---119/200---
For theorem MeasureTheory.condexp_finset_sum in Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean:
theorem condexp_finset_sum {ι : Type*} {s : Finset ι} {f : ι → α → F'}
    (hf : ∀ i ∈ s, Integrable (f i) μ) : μ[∑ i ∈ s, f i|m] =ᵐ[μ] ∑ i ∈ s, μ[f i|m] 


Original valid proof:
:= by
  induction' s using Finset.induction_on with i s his heq hf
  · rw [Finset.sum_empty, Finset.sum_empty, condexp_zero]
  · rw [Finset.sum_insert his, Finset.sum_insert his]
    exact (condexp_add (hf i <| Finset.mem_insert_self i s) <|
      integrable_finset_sum' _ fun j hmem => hf j <| Finset.mem_insert_of_mem hmem).trans
        ((EventuallyEq.refl _ _).add (heq fun j hmem => hf j <| Finset.mem_insert_of_mem hmem))


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
∧
    Integrable (μ[∑ i ∈ s, f i|m]) μ := by
  induction' s with i s hsi hsc
  · simp only [Finset.sum_empty, measure_condexp, integrable_zero, eventuallyEq_refl,
      and_self_iff]
  · rw [Finset.sum_insert hsi]
    rw [← ae_eq_condexp_iff_integrable_norm_sub' (hf i (Finset.mem_insert_self _ _)).integrableOn
        (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj).integrableOn]
    have :
      μ[∑ i ∈ s, f i|m] =ᵐ[μ] ∑ i ∈ s, μ[f i|m] ∧
        Integrable (μ[∑ i ∈ s, f i|m]) μ := by
      refine ⟨hsc fun i hi => ?_, ?_⟩
      · simp only [Finset.mem_insert, ne_eq, forall_eq_or_imp, forall_eq]
        exact hf i (Or.inr hi)
      · exact integrable_finset_sum _ fun j hj => hf j (Or.inr hj)
    rw [condexp_add (hf i (Finset.mem_insert_self _ _)).integrableOn
        (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj).integrableOn]
    refine ⟨(condexp_finset_sum_add_measure hsi hsc.1
        (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj).integrableOn).trans
        ?_, ?_⟩
    · filter_upwards with x
      simp only [Pi.add_apply, Finset.sum_insert hsi]
    · exact Integrable.add hsc.2 (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj)

Repaired Proof:
theorem condexp_finset_sum {ι : Type*} {s : Finset ι} {f : ι → α → F'}
    (hf : ∀ i ∈ s, Integrable (f i) μ) : μ[∑ i ∈ s, f i|m] =ᵐ[μ] ∑ i ∈ s, μ[f i|m] ∧
    Integrable (μ[∑ i ∈ s, f i|m]) μ := by
  induction' s using Finset.induction_on with i s his ih
  · simp only [Finset.sum_empty, measure_condexp, eventuallyEq_refl, and_self_iff]
  · rw [Finset.sum_insert his]
    rw [← ae_eq_condexp_iff_integrable_norm_sub' (hf i (Finset.mem_insert_self _ _)).integrableOn
        (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj).integrableOn]
    have :
      μ[∑ i ∈ s, f i|m] =ᵐ[μ] ∑ i ∈ s, μ[f i|m] ∧
        Integrable (μ[∑ i ∈ s, f i|m]) μ := by
      refine ⟨ih fun i hi => ?_, ?_⟩
      · simp only [Finset.mem_insert, ne_eq, forall_eq_or_imp, forall_eq]
        exact hf i (Or.inr hi)
      · exact integrable_finset_sum _ fun j hj => hf j (Or.inr hj)
    rw [condexp_add (hf i (Finset.mem_insert_self _ _)).integrableOn
        (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj).integrableOn]
    refine ⟨(condexp_finset_sum_add_measure his ih.1
        (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj).integrableOn).trans
        ?_, ?_⟩
    · filter_upwards with x
      simp only [Pi.add_apply, Finset.sum_insert his]
    · exact Integrable.add ih.2 (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj)

Repaired Proof:
theorem condexp_finset_sum {ι : Type*} {s : Finset ι} {f : ι → α → F'}
    (hf : ∀ i ∈ s, Integrable (f i) μ) : μ[∑ i ∈ s, f i|m] =ᵐ[μ] ∑ i ∈ s, μ[f i|m] ∧
    Integrable (μ[∑ i ∈ s, f i|m]) μ := by
  induction' s using Finset.induction_on with i s his ih
  · simp only [Finset.sum_empty, measure_condexp, eventuallyEq_refl, and_self_iff]
  · rw [Finset.sum_insert his]
    rw [← ae_eq_condexp_iff_integrable_norm_sub' (hf i (Finset.mem_insert_self _ _)).integrableOn
        (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj).integrableOn]
    have :
      μ[∑ i ∈ s, f i|m] =ᵐ[μ] ∑ i ∈ s, μ[f i|m] ∧
        Integrable (μ[∑ i ∈ s, f i|m]) μ := by
      refine ⟨ih fun i hi => ?_, ?_⟩
      · simp only [Finset.mem_insert, ne_eq, forall_eq_or_imp, forall_eq]
        exact hf i (Or.inr hi)
      · exact integrable_finset_sum _ fun j hj => hf j (Or.inr hj)
    rw [condexp_add (hf i (Finset.mem_insert_self _ _)).integrableOn
        (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj).integrableOn]
    refine ⟨(condexp_finset_sum_add_measure his ih.1
        (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj).integrableOn).trans
        ?_, ?_⟩
    · filter_upwards with x
      simp only [Pi.add_apply, Finset.sum_insert his]
    · exact Integrable.add ih.2 (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj)

Repaired Proof:
theorem condexp_finset_sum {ι : Type*} {s : Finset ι} {f : ι → α → F'}
    (hf : ∀ i ∈ s, Integrable (f i) μ) : μ[∑ i ∈ s, f i|m] =ᵐ[μ] ∑ i ∈ s, μ[f i|m] ∧
    Integrable (μ[∑ i ∈ s, f i|m]) μ := by
  induction' s using Finset.induction_on with i s his ih
  · simp only [Finset.sum_empty, measure_condexp, eventuallyEq_refl, and_self_iff]
  · rw [Finset.sum_insert his]
    rw [← ae_eq_condexp_iff_integrable_norm_sub' (hf i (Finset.mem_insert_self _ _)).integrableOn
        (integrable_finset_sum _ fun j hj => hf j <| Finset.mem_insert_of_mem hj).integrableOn]
    have :
      μ[∑ i ∈ s, f i|m] =ᵐ[μ] ∑ i ∈ s, μ[f i|m] ∧
        Integrable (μ[∑ i ∈ s, f i|m]) μ := by
      refine ⟨ih fun i hi => ?

Attempt failure.

Working on Mathlib/MeasureTheory/Function/ConditionalExpectation/Real.lean - 2024-09-09 01:01:21.208482.
---120/200---
For theorem MeasureTheory.ae_bdd_condexp_of_ae_bdd in Mathlib/MeasureTheory/Function/ConditionalExpectation/Real.lean:
theorem ae_bdd_condexp_of_ae_bdd {R : ℝ≥0} {f : α → ℝ} (hbdd : ∀ᵐ x ∂μ, |f x| ≤ R) :
    ∀ᵐ x ∂μ, |(μ[f|m]) x| ≤ R 


Original valid proof:
:= by
  by_cases hnm : m ≤ m0
  swap
  · simp_rw [condexp_of_not_le hnm, Pi.zero_apply, abs_zero]
    exact eventually_of_forall fun _ => R.coe_nonneg
  by_cases hfint : Integrable f μ
  swap
  · simp_rw [condexp_undef hfint]
    filter_upwards [hbdd] with x hx
    rw [Pi.zero_apply, abs_zero]
    exact (abs_nonneg _).trans hx
  by_contra h
  change μ _ ≠ 0 at h
  simp only [← zero_lt_iff, Set.compl_def, Set.mem_setOf_eq, not_le] at h
  suffices (μ {x | ↑R < |(μ[f|m]) x|}).toReal * ↑R < (μ {x | ↑R < |(μ[f|m]) x|}).toReal * ↑R by
    exact this.ne rfl
  refine lt_of_lt_of_le (setIntegral_gt_gt R.coe_nonneg ?_ ?_ h.ne.symm) ?_
  · simp_rw [← Real.norm_eq_abs]
    exact (stronglyMeasurable_condexp.mono hnm).measurable.norm
  · exact integrable_condexp.abs.integrableOn
  refine (setIntegral_abs_condexp_le ?_ _).trans ?_
  · simp_rw [← Real.norm_eq_abs]
    exact @measurableSet_lt _ _ _ _ _ m _ _ _ _ _ measurable_const
      stronglyMeasurable_condexp.norm.measurable
  simp only [← smul_eq_mul, ← setIntegral_const, NNReal.val_eq_coe, RCLike.ofReal_real_eq_id,
    _root_.id]
  refine setIntegral_mono_ae hfint.abs.integrableOn ?_ hbdd
  refine ⟨aestronglyMeasurable_const, lt_of_le_of_lt ?_
    (integrable_condexp.integrableOn : IntegrableOn (μ[f|m]) {x | ↑R < |(μ[f|m]) x|} μ).2⟩
  refine setLIntegral_mono measurable_const.nnnorm.coe_nnreal_ennreal
    (stronglyMeasurable_condexp.mono hnm).measurable.nnnorm.coe_nnreal_ennreal fun x hx => ?_
  rw [ENNReal.coe_le_coe, Real.nnnorm_of_nonneg R.coe_nonneg]
  exact Subtype.mk_le_mk.2 (le_of_lt hx)


Verifying proof (Commit f604017518b0630e4b4304f4db58858db24b64e6):
∧ |(μ[f|m]) x - f x| ≤ R := by
  have h_int : Integrable f μ := integrable_of_forall_fin_meas_le' hm₁ hm₂
    (fun _ _ _ => measure_ne_top _ _) (fun _ _ _ => measure_ne_top _ _) hbdd
  have h_int_cond : Integrable (μ[f|m]) μ := h_int.condexp
  have h_int_cond_abs : Integrable (fun x => |(μ[f|m]) x|) μ :=
    h_int_cond.abs.integrable_of_hasFiniteIntegral
      (hasFiniteIntegral_condexp.mono hm₁ hm₂ le_rfl)
  have h_int_f_abs : Integrable (fun x => |f x|) μ := h_int.abs
  have h_int_f_abs_cond : Integrable (fun x => |(μ[f|m]) x - f x|) μ :=
    (h_int_cond.sub h_int).abs.integrable_of_hasFiniteIntegral
      (hasFiniteIntegral_condexp.mono hm₁ hm₂ le_rfl)
  have h_meas_f : AEStronglyMeasurable f μ := h_int.1
  have h_meas_f_cond : AEStronglyMeasurable (μ[f|m]) μ := h_int_cond.1
  have h_meas_f_abs_cond : AEStronglyMeasurable (fun x => |(μ[f|m]) x|) μ :=
    h_int_cond_abs.1.abs
  have h_meas_f_abs_sub_cond : AEStronglyMeasurable (fun x => |(μ[f|m]) x - f x|) μ :=
    h_int_f_abs_cond.1.abs
  have h_meas_f_sub_cond : AEStronglyMeasurable (fun x => (μ[f|m]) x - f x) μ :=
    h_int_f_abs_cond.1.sub h_int.1
  have h_meas_f_cond_sub : AEStronglyMeasurable (fun x => (μ[f|m]) x) μ :=
    h_int_cond.1.sub h_meas_f
  have h_meas_f_cond_abs : AEStronglyMeasurable (fun x => |f x|) μ := h_meas_f.abs
  have h_meas_f_cond_abs_sub : AEStronglyMeasurable (fun x => |f x - (μ[f|m]) x|) μ :=
    (h_meas_f.sub h_meas_f_cond).abs
  have h_meas_f_cond_abs_sub' : AEStronglyMeasurable (fun x => |f x - (μ[f|m]) x|) μ :=
    (h_meas_f_cond_abs.sub h_meas_f_cond_abs_sub).abs
  have h_meas_f_cond_abs_sub'' : AEStronglyMeasurable (fun x => |f x - (μ[f|m]) x|) μ :=
    (h_meas_f_cond_abs_sub.sub h_meas_f_cond_abs_sub').abs
  have h_meas_f_cond_abs_sub''' : AEStronglyMeasurable (fun x => |f x - (μ[f|m]) x|) μ :=
    (h_meas_f_cond_abs_sub'.sub h_meas_f_cond_abs_sub'').abs
  have h_meas_f_cond_abs_sub'''' : AEStronglyMeasurable (fun x => |f x - (μ[f|m]) x|) μ :=
    (h_meas_f_cond_abs_sub''.sub h_meas_f_cond_abs_sub''').abs
  have h_meas_f_cond_abs_sub''''' : AEStronglyMeasurable (fun x => |f x - (μ[f|m]) x|) μ :=
    (h_meas_f_cond_abs_sub'''.sub h_meas_f_cond_abs_sub'''').abs
  have h_meas_f_cond_abs_sub'''''' : AEStronglyMeasurable (fun x => |f x - (μ[f|m]) x|) μ :=
    (h_meas_f_cond_abs_sub''''.sub h_meas_f_cond_abs_sub'''''

Attempt failure.

Working on Mathlib/MeasureTheory/Function/Jacobian.lean - 2024-09-09 01:01:33.037476.
---121/200---
For theorem MeasureTheory.map_withDensity_abs_det_fderiv_eq_addHaar in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem map_withDensity_abs_det_fderiv_eq_addHaar (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (h'f : Measurable f) :
    Measure.map f ((μ.restrict s).withDensity fun x => ENNReal.ofReal |(f' x).det|) =
      μ.restrict (f '' s) 


Original valid proof:
:= by
  apply Measure.ext fun t ht => ?_
  rw [map_apply h'f ht, withDensity_apply _ (h'f ht), Measure.restrict_apply ht,
    restrict_restrict (h'f ht),
    lintegral_abs_det_fderiv_eq_addHaar_image μ ((h'f ht).inter hs)
      (fun x hx => (hf' x hx.2).mono inter_subset_right) (hf.mono inter_subset_right),
    image_preimage_inter]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
↔
      (f' ·).J =ᵐ[μ.restrict s] fun x => ENNReal.ofReal |(f' x).det| := by
  have :
    (f' ·).J =ᵐ[μ.restrict s] fun x => ENNReal.ofReal |(f' x).det| ↔
      (f' ·).J =ᵐ[μ.restrict s] fun x => ENNReal.ofReal |(f' x).det| := by rfl
  simp_rw [this]
  refine' ⟨fun h => _, fun h => _⟩
  · rw [← addHaarMeasure_withDensity_eq_addHaarMeasure_withDensity_abs_det_fderiv_aux1 μ hs
      hf' hf h'f h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h]
  · rw [← addHaarMeasure_withDensity_eq_addHaarMeasure_withDensity_abs_det_fderiv_aux1 μ hs
      hf' hf h'f h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h]

Repaired Proof:
theorem map_withDensity_abs_det_fderiv_eq_addHaar (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (h'f : Measurable f) :
    Measure.map f ((μ.restrict s).withDensity fun x => ENNReal.ofReal |(f' x).det|) =
      μ.restrict (f '' s) ↔
      (f' ·).J =ᵐ[μ.restrict s] fun x => ENNReal.ofReal |(f' x).det| := by
  have :
    (f' ·).J =ᵐ[μ.restrict s] fun x => ENNReal.ofReal |(f' x).det| ↔
      (f' ·).J =ᵐ[μ.restrict s] fun x => ENNReal.ofReal |(f' x).det| := by rfl
  simp_rw [this]
  refine ⟨fun h => ?_, fun h => ?_⟩
  · rw [← addHaarMeasure_withDensity_eq_addHaarMeasure_withDensity_abs_det_fderiv_aux1 μ hs
      hf' hf h'f h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h]
  · rw [← addHaarMeasure_withDensity_eq_addHaarMeasure_withDensity_abs_det_fderiv_aux1 μ hs
      hf' hf h'f h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h]

Repaired Proof:
theorem map_withDensity_abs_det_fderiv_eq_addHaar (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (h'f : Measurable f) :
    Measure.map f ((μ.restrict s).withDensity fun x => ENNReal.ofReal |(f' x).det|) =
      μ.restrict (f '' s) ↔
      (f' ·).J =ᵐ[μ.restrict s] fun x => ENNReal.ofReal |(f' x).det| := by
  have :
    (f' ·).J =ᵐ[μ.restrict s] fun x => ENNReal.ofReal |(f' x).det| ↔
      (f' ·).J =ᵐ[μ.restrict s] fun x => ENNReal.ofReal |(f' x).det| := by rfl
  simp_rw [this]
  refine ⟨fun h => ?_, fun h => ?_⟩
  · rw [← addHaarMeasure_withDensity_eq_addHaarMeasure_withDensity_abs_det_fderiv_aux1 μ hs
      hf' hf h'f h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h]
  · rw [← addHaarMeasure_withDensity_eq_addHaarMeasure_withDensity_abs_det_fderiv_aux1 μ hs
      hf' hf h'f h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, ← map_addHaar_eq_addHaar_map h'f, ← map_withDensity_eq_withDensity_map h'f,
      map_map h'f hf, h]

Repaired Proof:
theorem map_withDensity_abs_det_fderiv_eq_addHaar (hs : MeasurableSet s)
    (hf' :

Attempt failure.

---122/200---
For theorem MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (R : ℝ) (hs : s ⊆ closedBall 0 R) (ε : ℝ≥0)
    (εpos : 0 < ε) (h'f' : ∀ x ∈ s, (f' x).det = 0) : μ (f '' s) ≤ ε * μ (closedBall 0 R) 


Original valid proof:
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's); · simp only [measure_empty, zero_le, image_empty]
  have :
      ∀ A : E →L[ℝ] E, ∃ δ : ℝ≥0, 0 < δ ∧
        ∀ (t : Set E), ApproximatesLinearOn f A t δ →
          μ (f '' t) ≤ (Real.toNNReal |A.det| + ε : ℝ≥0) * μ t := by
    intro A
    let m : ℝ≥0 := Real.toNNReal |A.det| + ε
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, εpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt μ A I).and self_mem_nhdsWithin).exists with ⟨δ, h, h'⟩
    exact ⟨δ, h', fun t ht => h t f ht⟩
  choose δ hδ using this
  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, Af'⟩ :
    ∃ (t : ℕ → Set E) (A : ℕ → E →L[ℝ] E),
      Pairwise (Disjoint on t) ∧
        (∀ n : ℕ, MeasurableSet (t n)) ∧
          (s ⊆ ⋃ n : ℕ, t n) ∧
            (∀ n : ℕ, ApproximatesLinearOn f (A n) (s ∩ t n) (δ (A n))) ∧
              (s.Nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' δ fun A => (hδ A).1.ne'
  calc
    μ (f '' s) ≤ μ (⋃ n, f '' (s ∩ t n)) := by
      rw [← image_iUnion, ← inter_iUnion]
      gcongr
      exact subset_inter Subset.rfl t_cover
    _ ≤ ∑' n, μ (f '' (s ∩ t n)) := measure_iUnion_le _
    _ ≤ ∑' n, (Real.toNNReal |(A n).det| + ε : ℝ≥0) * μ (s ∩ t n) := by
      gcongr
      exact (hδ (A _)).2 _ (ht _)
    _ = ∑' n, ε * μ (s ∩ t n) := by
      congr with n
      rcases Af' h's n with ⟨y, ys, hy⟩
      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]
    _ ≤ ε * ∑' n, μ (closedBall 0 R ∩ t n) := by
      rw [ENNReal.tsum_mul_left]
      gcongr
    _ = ε * μ (⋃ n, closedBall 0 R ∩ t n) := by
      rw [measure_iUnion]
      · exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
      · intro n
        exact measurableSet_closedBall.inter (t_meas n)
    _ ≤ ε * μ (closedBall 0 R) := by
      rw [← inter_iUnion]
      exact mul_le_mul_left' (measure_mono inter_subset_left) _


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔
      μ s ≤ ε * μ (closedBall 0 R) := by
  have : ∀ x ∈ s, ∃ g' : E →L[ℝ] E, HasFDerivWithinAt f g' s x ∧ g' x = 0 := by
    intro x hx
    have : ∃ g' : E →L[ℝ] E, HasFDerivWithinAt f g' s x ∧ f' x = g' := by
      apply exists_hasFDerivWithinAt_eq_of_det_ne_zero
      have : (f' x).det ≠ 0 := by
        rw [h'f' x hx]
        norm_num
      exact this
    rcases this with ⟨g', hg'⟩
    use g'
    rcases hg' with ⟨hg'1, hg'2⟩
    exact ⟨hg'1, hg'2.symm⟩
  choose g' hg'1 hg'2 using this
  have hg'3 : ∀ x ∈ s, fderivWithin ℝ f s x = g' x := by
    intro x hx
    rw [fderivWithin_eq_fderiv]
    · exact (hg'1 x hx).2
    · exact uniqueDiffOn_closedBall 0 R x (hs hx)
  have hg'4 : ∀ x ∈ s, (g' x).det = 0 := by
    intro x hx
    rw [← hg'2 x hx]
    exact h'f' x hx
  have hg'5 : ∀ x ∈ s, ∃ v, v ⊥ ℝ → HasFDerivWithinAt (fun y => f y - y) (g' x - 1) s x ∧
      (g' x - 1).det = 0 := by
    intro x hx
    have : ∃ v, v ⊥ ℝ → (g' x - 1).det = 0 := by
      apply eq_zero_of_det_ne_zero_of_det_sub_eq_zero (g' x).det
      · rw [hg'2 x hx]
        norm_num
      · exact hg'4 x hx
    rcases this with ⟨v, hv⟩
    use v
    intro hv'
    have h1 : HasFDerivWithinAt (fun y => f y - y) (g' x - 1) s x := by
      apply HasFDerivWithinAt.sub
      · exact hg'1 x hx
      · apply hasFDerivWithinAt_id
    have h2 : (g' x - 1).det = 0 := by
      apply hv
      exact hv'
    exact ⟨h1, h2⟩
  rcases exists_mem_of_nonempty_fderivWithin hs hf' with ⟨x₀, hx₀, h'x₀⟩
  have : ∀ᶠ x in μ.ae, x ∈ s → μ (f '' s) ≤ ε * μ (closedBall 0 R) ↔ μ s ≤ ε * μ (closedBall 0 R) := by
    apply ae_all_iff.2
    intro x
    apply tendsto_order.1
    have : ∀ᶠ x : ℝ in 𝓝[>] 0, x ∈ Ioc (0 : ℝ) 1 ∧ x * R ≤ ε * μ (closedBall 0 R) := by
      have : Tendsto (fun x => x * R) (𝓝[>] 0) (𝓝[>] 0) := by
        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _
        · apply tendsto_id.const_mul
          exact R
        · exact eventually_mem_nhdsWithin
      apply (this.eventually (gt_mem_nhds (εpos.trans_le zero_le_one))).and
      apply eventually_mem_nhdsWithin.mono fun x hx => ⟨hx.1, le_trans hx.2 εpos.le⟩
    apply (((tendsto_measure_image_addHaar_smul_of_det_fderivWithin_eq_zero μ
      hf' hg'1 hg'2 hg'3 hg'4 hg'5 x₀ hx₀ h'x₀).and this).curry).mono
    intro x hx hxs
    exact hx.1 hxs
  exact this.self_of_nhds

Repaired Proof:
theorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (R : ℝ) (hs : s ⊆ closedBall 0 R) (ε : ℝ≥0)
    (εpos : 0 < ε) (h'f' : ∀ x ∈ s, (f' x).det = 0) : μ (f '' s) ≤ ε * μ (closedBall 0 R) ↔
      μ s ≤ ε * μ (closedBall 0 R) := by
  have : ∀ x ∈ s, ∃ g' : E →L[ℝ] E, HasFDerivWithinAt f g' s x ∧ g' x = 0 := by
    intro x hx
    have : ∃ g' : E →L[ℝ] E, HasFDerivWithinAt f g' s x ∧ f' x = g' := by
      apply exists_hasFDerivWithinAt_eq_of_det_ne_zero
      have : (f' x).det ≠ 0 := by
        rw [h'f' x hx]
        norm_num
      exact this
    rcases this with ⟨g', hg'⟩
    use g'
    rcases hg' with ⟨hg'1, hg'2⟩
    exact ⟨hg'1, hg'2.symm⟩
  choose g' hg'1 hg'2 using this
  have hg'3 : ∀ x ∈ s, fderivWithin ℝ f s x = g' x := by
    intro x hx
    rw [fderivWithin_eq_fderiv]
    · exact (hg'1 x hx).2
    · exact uniqueDiffOn_closedBall 0 R x (hs hx)
  have hg'4 : ∀ x ∈ s, (g' x).det = 0 := by
    intro x hx
    rw [← hg'2 x hx]
    exact h'f' x hx
  have hg'5 : ∀ x ∈ s, ∃ v, v ⊥ ℝ → HasFDerivWithinAt (fun y => f y - y) (g' x - 1) s x ∧
      (g' x - 1).det = 0 := by
    intro x hx
    have : ∃ v, v ⊥ ℝ → (g' x - 1).det = 0 := by
      apply eq_zero_of_det_ne_zero_of_det_sub_eq_zero (g' x).det
      · rw [hg'2 x hx]
        norm_num
      · exact hg'4 x hx
    rcases this with ⟨v, hv⟩
    use v
    intro hv'
    have h1 : HasFDerivWithinAt (fun y => f y - y) (g' x - 1) s x := by
      apply HasFDerivWithinAt.sub
      · exact hg'1 x hx
      · apply hasFDerivWithinAt_id
    have h2 : (g' x - 1).det = 0 := by
      apply hv
      exact hv'
    exact ⟨h1, h2⟩
  rcases exists_mem_of_nonempty_fderivWithin hs hf' with ⟨x₀, hx₀, h'x₀⟩
  have : ∀ᶠ x in μ.ae, x ∈ s → μ (f '' s) ≤ ε * μ (closedBall 0 R) ↔ μ s ≤ ε * μ (closedBall 0 R) := by
    apply ae_all_iff.2
    intro x
    apply tendsto_order.1
    have : ∀ᶠ x : ℝ in 𝓝[>] 0, x ∈ Ioc

Attempt failure.

Working on Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean - 2024-09-09 01:02:28.902373.
---123/200---
For theorem MeasureTheory.FinStronglyMeasurable.exists_set_sigmaFinite in Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean:
theorem exists_set_sigmaFinite [Zero β] [TopologicalSpace β] [T2Space β]
    (hf : FinStronglyMeasurable f μ) :
    ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) 


Original valid proof:
:= by
  rcases hf with ⟨fs, hT_lt_top, h_approx⟩
  let T n := support (fs n)
  have hT_meas : ∀ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := ⋃ n, T n
  refine ⟨t, MeasurableSet.iUnion hT_meas, ?_, ?_⟩
  · have h_fs_zero : ∀ n, ∀ x ∈ tᶜ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  · refine ⟨⟨⟨fun n => tᶜ ∪ T n, fun _ => trivial, fun n => ?_, ?_⟩⟩⟩
    · rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono Set.inter_subset_left).trans_lt (hT_lt_top n)
    · rw [← Set.union_iUnion tᶜ T]
      exact Set.compl_union_self _


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      tᶜ ∈ ae μ := by
  borelize β
  rcases hf with ⟨s, _, _, hs⟩
  let t := ⋃ x ∈ s, { y | f y = f x }
  refine ⟨t, ?_, ?_, ?_, ?_⟩
  · refine MeasurableSet.biUnion s.to_finite ?_ fun x _ => ?_
    · exact fun x _ => measurableSet_fiber _ _
    · exact measurableSet_fiber _ _
  · rintro x ⟨y, hy, rfl⟩
    simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
    rintro rfl
    exact hy
  · suffices h : ∀ x ∈ s, SigmaFinite (μ.restrict { y | f y = f x }) by
      refine (sigmaFinite_iUnion fun x => h x x.2).mono ?_
      filter_upwards with y
      simp only [Set.mem_iUnion, mem_setOf_eq]
      rintro ⟨x', hx', rfl⟩
      exact ⟨x', hx', rfl⟩
    refine fun x hx => (hs x hx).sigmaFinite
  · have : ∀ᵐ x ∂μ, x ∉ tᶜ := by
      filter_upwards [hf.finMeasSupp μ] with x hx
      simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
      rintro rfl
      exact hx rfl
    refine mem_ae_iff.2 (this.mono fun x hx h'x => ?_)
    simpa only [Set.mem_compl_iff, mem_setOf_eq, not_not] using h'x

Repaired Proof:
theorem exists_set_sigmaFinite [Zero β] [TopologicalSpace β] [T2Space β]
    (hf : FinStronglyMeasurable f μ) :
    ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) ∧
      tᶜ ∈ ae μ := by
  borelize β
  rcases hf with ⟨s, _, _, hs⟩
  let t := ⋃ x ∈ s, { y | f y = f x }
  refine ⟨t, ?_, ?_, ?_, ?_⟩
  · refine MeasurableSet.biUnion s.to_finite ?_ fun x _ => ?_
    · exact fun x _ => measurableSet_fiber _ _
    · exact measurableSet_fiber _ _
  · rintro x ⟨y, hy, rfl⟩
    simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
    rintro rfl
    exact hy
  · suffices h : ∀ x ∈ s, SigmaFinite (μ.restrict { y | f y = f x }) by
      refine (sigmaFinite_iUnion fun x => h x x.2).mono ?_
      filter_upwards with y
      simp only [Set.mem_iUnion, mem_setOf_eq]
      rintro ⟨x', hx', rfl⟩
      exact ⟨x', hx', rfl⟩
    refine fun x hx => (hs x hx).sigmaFinite
  · have : ∀ᵐ x ∂μ, x ∉ tᶜ := by
      filter_upwards [hf.finMeasSupp μ] with x hx
      simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
      rintro rfl
      exact hx rfl
    refine mem_ae_iff.2 (this.mono fun x hx h'x => ?_)
    simpa only [Set.mem_compl_iff, mem_setOf_eq, not_not] using h'x

Repaired Proof:
theorem exists_set_sigmaFinite [Zero β] [TopologicalSpace β] [T2Space β]
    (hf : FinStronglyMeasurable f μ) :
    ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) ∧
      tᶜ ∈ ae μ := by
  borelize β
  rcases hf with ⟨s, _, _, hs⟩
  let t := ⋃ x ∈ s, { y | f y = f x }
  refine ⟨t, ?_, ?_, ?_, ?_⟩
  · refine MeasurableSet.biUnion s.to_finite ?_ fun x _ => ?_
    · exact fun x _ => measurableSet_fiber _ _
    · exact measurableSet_fiber _ _
  · rintro x ⟨y, hy, rfl⟩
    simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
    rintro rfl
    exact hy
  · suffices h : ∀ x ∈ s, SigmaFinite (μ.restrict { y | f y = f x }) by
      refine (sigmaFinite_iUnion fun x => h x x.2).mono ?_
      filter_upwards with y
      simp only [Set.mem_iUnion, mem_setOf_eq]
      rintro ⟨x', hx', rfl⟩
      exact ⟨x', hx', rfl⟩
    refine fun x hx => (hs x hx).sigmaFinite
  · have : ∀ᵐ x ∂μ, x ∉ tᶜ := by
      filter_upwards [hf.finMeasSupp μ] with x hx
      simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
      rintro rfl
      exact hx rfl
    refine mem_ae_iff.2 (this.mono fun x hx h'x => ?_)
    simpa only [Set.mem_compl_iff, mem_setOf_eq, not_not] using h'x

Repaired Proof:
theorem exists_set_sigmaFinite [Zero β] [TopologicalSpace β] [T2Space β]
    (hf : FinStronglyMeasurable f μ) :
    ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) ∧
      tᶜ ∈ ae μ := by
  borelize β
  rcases hf with ⟨s, _, _, hs⟩
  let t := ⋃ x ∈ s, { y | f y = f x }
  refine ⟨t, ?_, ?_, ?_, ?_⟩
  · refine MeasurableSet.biUnion s.to_finite ?_ fun x _ => ?_
    · exact fun x _ => measurableSet_fiber _ _
    · exact measurableSet_fiber _ _
  · rintro x ⟨y, hy, rfl⟩
    simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
    rintro rfl
    exact hy
  · suffices h : ∀ x ∈ s, SigmaFinite (μ.restrict { y | f y = f x }) by
      refine (sigmaFinite_iUnion fun x => h x x.2).mono ?_
      filter_upwards with y
      simp only [Set.mem_iUnion, mem_setOf_eq]
      rintro ⟨x', hx', rfl⟩
      exact ⟨x', hx', rfl⟩
    refine fun x hx => (hs x hx).sigmaFinite
  · have : ∀ᵐ x ∂μ, x ∉ tᶜ := by
      filter_upwards [hf.finMeasSupp μ] with x hx
      simp only [Set.mem_compl_iff, mem_setOf_eq, not_not]
      rintro rfl
      exact hx rfl
    refine mem_ae_iff.2 (this.mono fun x hx h'x => ?_)
    simpa only [Set.mem_compl_iff, mem_setOf_eq, not_not] using h'x

Repaired Proof:
theorem exists_set_sigmaFinite [Zero β] [TopologicalSpace β] [T2Space β]
    (hf : FinStronglyMeasurable f μ) :
    ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) 

Attempt failure.

Working on Mathlib/MeasureTheory/Function/UniformIntegrable.lean - 2024-09-09 01:02:49.627528.
---124/200---
For theorem MeasureTheory.unifIntegrable_of' in Mathlib/MeasureTheory/Function/UniformIntegrable.lean:
theorem unifIntegrable_of' (hp : 1 ≤ p) (hp' : p ≠ ∞) {f : ι → α → β}
    (hf : ∀ i, StronglyMeasurable (f i))
    (h : ∀ ε : ℝ, 0 < ε → ∃ C : ℝ≥0, 0 < C ∧
      ∀ i, snorm ({ x | C ≤ ‖f i x‖₊ }.indicator (f i)) p μ ≤ ENNReal.ofReal ε) :
    UnifIntegrable f p μ 


Original valid proof:
:= by
  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm
  by_cases hμ : μ Set.univ = 0
  · rw [Measure.measure_univ_eq_zero] at hμ
    exact hμ.symm ▸ unifIntegrable_zero_meas
  intro ε hε
  obtain ⟨C, hCpos, hC⟩ := h (ε / 2) (half_pos hε)
  refine ⟨(ε / (2 * C)) ^ ENNReal.toReal p,
    Real.rpow_pos_of_pos (div_pos hε (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,
    fun i s hs hμs => ?_⟩
  by_cases hμs' : μ s = 0
  · rw [(snorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2
        (indicator_meas_zero hμs')]
    norm_num
  calc
    snorm (Set.indicator s (f i)) p μ ≤
        snorm (Set.indicator (s ∩ { x | C ≤ ‖f i x‖₊ }) (f i)) p μ +
          snorm (Set.indicator (s ∩ { x | ‖f i x‖₊ < C }) (f i)) p μ := by
      refine le_trans (Eq.le ?_) (snorm_add_le
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))
        hp)
      congr
      change _ = fun x => (s ∩ { x : α | C ≤ ‖f i x‖₊ }).indicator (f i) x +
        (s ∩ { x : α | ‖f i x‖₊ < C }).indicator (f i) x
      rw [← Set.indicator_union_of_disjoint]
      · rw [← Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :
            { x : α | C ≤ ‖f i x‖₊ } ∪ { x : α | ‖f i x‖₊ < C } = Set.univ),
          Set.inter_univ]
      · refine (Disjoint.inf_right' _ ?_).inf_left' _
        rw [disjoint_iff_inf_le]
        rintro x ⟨hx₁, hx₂⟩
        rw [Set.mem_setOf_eq] at hx₁ hx₂
        exact False.elim (hx₂.ne (eq_of_le_of_not_lt hx₁ (not_lt.2 hx₂.le)).symm)
    _ ≤ snorm (Set.indicator { x | C ≤ ‖f i x‖₊ } (f i)) p μ +
        (C : ℝ≥0∞) * μ s ^ (1 / ENNReal.toReal p) := by
      refine add_le_add
        (snorm_mono fun x => norm_indicator_le_of_subset Set.inter_subset_right _ _) ?_
      rw [← Set.indicator_indicator]
      rw [snorm_indicator_eq_snorm_restrict hs]
      have : ∀ᵐ x ∂μ.restrict s, ‖{ x : α | ‖f i x‖₊ < C }.indicator (f i) x‖ ≤ C := by
        filter_upwards
        simp_rw [norm_indicator_eq_indicator_norm]
        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _
      refine le_trans (snorm_le_of_ae_bound this) ?_
      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]
    _ ≤ ENNReal.ofReal (ε / 2) + C * ENNReal.ofReal (ε / (2 * C)) := by
      refine add_le_add (hC i) (mul_le_mul_left' ?_ _)
      rwa [ENNReal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),
        ENNReal.ofReal_rpow_of_pos (div_pos hε (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]
    _ ≤ ENNReal.ofReal (ε / 2) + ENNReal.ofReal (ε / 2) := by
      refine add_le_add_left ?_ _
      rw [← ENNReal.ofReal_coe_nnreal, ← ENNReal.ofReal_mul (NNReal.coe_nonneg _), ← div_div,
        mul_div_cancel₀ _ (NNReal.coe_pos.2 hCpos).ne.symm]
    _ ≤ ENNReal.ofReal ε := by
      rw [← ENNReal.ofReal_add (half_pos hε).le (half_pos hε).le, add_halves]


Verifying proof (Commit 66c0098b0b62ad14d9c618b402e7673658137a7e):
↔ ∀ ε : ℝ, 0 < ε → ∃ C : ℝ≥0, 0 < C ∧
      ∀ i, snorm ({ x | C ≤ ‖f i x‖₊ }.indicator (f i)) p μ ≤ ENNReal.ofReal ε :=
  ⟨fun h' ε hε => h' ε hε, fun h' ε hε =>
    unifIntegrable_of hp hp' hf fun ε hε => (h ε hε).imp fun C hC => ⟨hC.1, hC.2.trans (h' ε hε)⟩⟩

Repaired Proof:
theorem unifIntegrable_of' (hp : 1 ≤ p) (hp' : p ≠ ∞) {f : ι → α → β}
    (hf : ∀ i, StronglyMeasurable (f i))
    (h : ∀ ε : ℝ, 0 < ε → ∃ C : ℝ≥0, 0 < C ∧
      ∀ i, snorm ({ x | C ≤ ‖f i x‖₊ }.indicator (f i)) p μ ≤ ENNReal.ofReal ε) :
    UnifIntegrable f p μ ↔ ∀ ε : ℝ, 0 < ε → ∃ C : ℝ≥0, 0 < C ∧
      ∀ i, snorm ({ x | C ≤ ‖f i x‖₊ }.indicator (f i)) p μ ≤ ENNReal.ofReal ε :=
  ⟨fun h' ε hε => h' ε hε, fun h' ε hε =>
    unifIntegrable_of hp hp' hf fun ε hε => (h ε hε).imp fun C hC => ⟨hC.1, hC.2.trans (h' ε hε)⟩⟩

Repaired Proof:
theorem unifIntegrable_of' (hp : 1 ≤ p) (hp' : p ≠ ∞) {f : ι → α → β}
    (hf : ∀ i, StronglyMeasurable (f i))
    (h : ∀ ε : ℝ, 0 < ε → ∃ C : ℝ≥0, 0 < C ∧
      ∀ i, snorm ({ x | C ≤ ‖f i x‖₊ }.indicator (f i)) p μ ≤ ENNReal.ofReal ε) :
    UnifIntegrable f p μ ↔ ∀ ε : ℝ, 0 < ε → ∃ C : ℝ≥0, 0 < C ∧
      ∀ i, snorm ({ x | C ≤ ‖f i x‖₊ }.indicator (f i)) p μ ≤ ENNReal.ofReal ε :=
  ⟨fun h' ε hε => h' ε hε, fun h' ε hε =>
    unifIntegrable_of hp hp' hf fun ε hε => (h ε hε).imp fun C hC => ⟨hC.1, hC.2.trans (h' ε hε)⟩⟩

Attempt failure.

Working on Mathlib/MeasureTheory/Group/Action.lean - 2024-09-09 01:03:08.220482.
---125/200---
For theorem MeasureTheory.smulInvariantMeasure_tfae in Mathlib/MeasureTheory/Group/Action.lean:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ] 


Original valid proof:
:= by
  tfae_have 1 ↔ 2
  · exact ⟨fun h => h.1, fun h => ⟨h⟩⟩
  tfae_have 1 → 6
  · intro h c
    exact (measurePreserving_smul c μ).map_eq
  tfae_have 6 → 7
  · exact fun H c => ⟨measurable_const_smul c, H c⟩
  tfae_have 7 → 4
  · exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have 4 → 5
  · exact fun H c s => by
      rw [← preimage_smul_inv]
      apply H
  tfae_have 5 → 3
  · exact fun H c s _ => H c s
  tfae_have 3 → 2
  · intro H c s hs
    rw [preimage_smul]
    exact H c⁻¹ s hs
  tfae_finish


Verifying proof (Commit fba28f571f3d12084f060ccc0fd73ca4e275ccce):
 := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s
  tfae_have 2 → 3
  · exact fun h c s => h c s (measurable_const_smul c s)
  tfae_have 3 → 4
  · exact fun h c s => h c s
  tfae_have 4 → 5
  · exact fun h c s => h c s
  tfae_have 5 → 6
  · exact fun h c => by simp [h c]
  tfae_have 6 → 7
  · exact fun h c => ⟨measurable_const_smul _ _, h c⟩
  tfae_have 7 → 1
  · exact fun h => ⟨measurable_const_smul _ _, h⟩
  tfae_finish

Repaired Proof:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ]  := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s
  tfae_have 2 → 3
  · exact fun h c s => h c s (measurable_const_smul c s)
  tfae_have 3 → 4
  · exact fun h c s => h c s
  tfae_have 4 → 5
  · exact fun h c s => h c s
  tfae_have 5 → 6
  · exact fun h c => by simp [h c]
  tfae_have 6 → 7
  · exact fun h c => ⟨measurable_const_smul _ _, h c⟩
  tfae_have 7 → 1
  · exact fun h => ⟨measurable_const_smul _ _, h⟩
  tfae_finish

Repaired Proof:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ]  := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s
  tfae_have 2 → 3
  · exact fun h c s => h c s (measurable_const_smul c s)
  tfae_have 3 → 4
  · exact fun h c s => h c s
  tfae_have 4 → 5
  · exact fun h c s => h c s
  tfae_have 5 → 6
  · exact fun h c => by simp [h c]
  tfae_have 6 → 7
  · exact fun h c => ⟨measurable_const_smul _ _, h c⟩
  tfae_have 7 → 1
  · exact fun h => ⟨measurable_const_smul _ _, h⟩
  tfae_finish

Repaired Proof:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ]  := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s
  tfae_have 2 → 3
  · exact fun h c s => h c s (measurable_const_smul c s)
  tfae_have 3 → 4
  · exact fun h c s => h c s
  tfae_have 4 → 5
  · exact fun h c s => h c s
  tfae_have 5 → 6
  · exact fun h c => by simp [h c]
  tfae_have 6 → 7
  · exact fun h c => ⟨measurable_const_smul _ _, h c⟩
  tfae_have 7 → 1
  · exact fun h => ⟨measurable_const_smul _ _, h⟩
  tfae_finish

Repaired Proof:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ]  := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s
  tfae_have 2 → 3
  · exact fun h c s => h c s (measurable_const_smul c s)
  tfae_have 3 → 4
  · exact fun h c s => h c s
  tfae_have 4 → 5
  · exact fun h c s => h c s
  tfae_have 5 → 6
  · exact fun h c => by simp [h c]
  tfae_have 6 → 7
  · exact fun h c => ⟨measurable_const_smul _ _, h c⟩
  tfae_have 7 → 1
  · exact fun h => ⟨measurable_const_smul _ _, h⟩
  tfae_finish

Repaired Proof:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ]  := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s


Attempt failure.

Working on Mathlib/MeasureTheory/Integral/Bochner.lean - 2024-09-09 01:03:21.072000.
---126/200---
For theorem MeasureTheory.ae_le_trim_of_stronglyMeasurable in Mathlib/MeasureTheory/Integral/Bochner.lean:
theorem ae_le_trim_of_stronglyMeasurable [LinearOrder γ] [TopologicalSpace γ]
    [OrderClosedTopology γ] [PseudoMetrizableSpace γ] (hm : m ≤ m0) {f g : β → γ}
    (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) (hfg : f ≤ᵐ[μ] g) :
    f ≤ᵐ[μ.trim hm] g 


Original valid proof:
:= by
  rwa [EventuallyLE, ae_iff, trim_measurableSet_eq hm]
  exact (hf.measurableSet_le hg).compl


Verifying proof (Commit 5c3b19457914190f5f82a4845a908a6fa667ed79):
∧ ∀ᵐ x ∂μ.trim hm, f x ≤ g x :=
  have hf' : StronglyMeasurable[m] (f ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hf.comp_measurable (measurable_toMeasurable _ _)
  have hg' : StronglyMeasurable[m] (g ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hg.comp_measurable (measurable_toMeasurable _ _)
  have hfg' : (f ∘ (m.trim hm).toMeasurable (univ : Set β)) ≤ᵐ[μ.trim hm]
        (g ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hfg.mono fun x hx => by
      simp only [Function.comp_apply]
      apply hx
  let hle : ∀ᵐ x ∂μ.trim hm, f x ≤ g x ∧ f x ≤ g x :=
    ae_le_of_ae_le_trim hm hf' hg' hfg'
  have hle' : ∀ᵐ x ∂μ.trim hm, f x ≤ g x := hle.mono fun _ h => h.1
  have hle'' : ∀ᵐ x ∂μ.trim hm, f x ≤ g x := hle.mono fun _ h => h.2
  and_self_iff.2 hle''

Repaired Proof:
theorem ae_le_trim_of_stronglyMeasurable [LinearOrder γ] [TopologicalSpace γ]
    [OrderClosedTopology γ] [PseudoMetrizableSpace γ] (hm : m ≤ m0) {f g : β → γ}
    (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) (hfg : f ≤ᵐ[μ] g) :
    f ≤ᵐ[μ.trim hm] g ∧ ∀ᵐ x ∂μ.trim hm, f x ≤ g x :=
  have hf' : StronglyMeasurable[m] (f ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hf.comp_measurable (measurable_toMeasurable _ _)
  have hg' : StronglyMeasurable[m] (g ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hg.comp_measurable (measurable_toMeasurable _ _)
  have hfg' : (f ∘ (m.trim hm).toMeasurable (univ : Set β)) ≤ᵐ[μ.trim hm]
        (g ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hfg.mono fun x hx => by
      simp only [Function.comp_apply]
      apply hx
  let hle : ∀ᵐ x ∂μ.trim hm, f x ≤ g x ∧ f x ≤ g x :=
    ae_le_of_ae_le_trim hm hf' hg' hfg'
  have hle' : ∀ᵐ x ∂μ.trim hm, f x ≤ g x := hle.mono fun _ h => h.1
  have hle'' : ∀ᵐ x ∂μ.trim hm, f x ≤ g x := hle.mono fun _ h => h.2
  and_self_iff.2 hle''

Repaired Proof:
theorem ae_le_trim_of_stronglyMeasurable [LinearOrder γ] [TopologicalSpace γ]
    [OrderClosedTopology γ] [PseudoMetrizableSpace γ] (hm : m ≤ m0) {f g : β → γ}
    (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) (hfg : f ≤ᵐ[μ] g) :
    f ≤ᵐ[μ.trim hm] g ∧ ∀ᵐ x ∂μ.trim hm, f x ≤ g x :=
  have hf' : StronglyMeasurable[m] (f ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hf.comp_measurable (measurable_toMeasurable _ _)
  have hg' : StronglyMeasurable[m] (g ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hg.comp_measurable (measurable_toMeasurable _ _)
  have hfg' : (f ∘ (m.trim hm).toMeasurable (univ : Set β)) ≤ᵐ[μ.trim hm]
        (g ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hfg.mono fun x hx => by
      simp only [Function.comp_apply]
      apply hx
  let hle : ∀ᵐ x ∂μ.trim hm, f x ≤ g x ∧ f x ≤ g x :=
    ae_le_of_ae_le_trim hm hf' hg' hfg'
  have hle' : ∀ᵐ x ∂μ.trim hm, f x ≤ g x := hle.mono fun _ h => h.1
  have hle'' : ∀ᵐ x ∂μ.trim hm, f x ≤ g x := hle.mono fun _ h => h.2
  and_self_iff.2 hle''

Repaired Proof:
theorem ae_le_trim_of_stronglyMeasurable [LinearOrder γ] [TopologicalSpace γ]
    [OrderClosedTopology γ] [PseudoMetrizableSpace γ] (hm : m ≤ m0) {f g : β → γ}
    (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) (hfg : f ≤ᵐ[μ] g) :
    f ≤ᵐ[μ.trim hm] g ∧ ∀ᵐ x ∂μ.trim hm, f x ≤ g x :=
  have hf' : StronglyMeasurable[m] (f ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hf.comp_measurable (measurable_toMeasurable _ _)
  have hg' : StronglyMeasurable[m] (g ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hg.comp_measurable (measurable_toMeasurable _ _)
  have hfg' : (f ∘ (m.trim hm).toMeasurable (univ : Set β)) ≤ᵐ[μ.trim hm]
        (g ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hfg.mono fun x hx => by
      simp only [Function.comp_apply]
      apply hx
  let hle : ∀ᵐ x ∂μ.trim hm, f x ≤ g x ∧ f x ≤ g x :=
    ae_le_of_ae_le_trim hm hf' hg' hfg'
  have hle' : ∀ᵐ x ∂μ.trim hm, f x ≤ g x := hle.mono fun _ h => h.1
  have hle'' : ∀ᵐ x ∂μ.trim hm, f x ≤ g x := hle.mono fun _ h => h.2
  and_self_iff.2 hle''

Repaired Proof:
theorem ae_le_trim_of_stronglyMeasurable [LinearOrder γ] [TopologicalSpace γ]
    [OrderClosedTopology γ] [PseudoMetrizableSpace γ] (hm : m ≤ m0) {f g : β → γ}
    (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) (hfg : f ≤ᵐ[μ] g) :
    f ≤ᵐ[μ.trim hm] g ∧ ∀ᵐ x ∂μ.trim hm, f x ≤ g x :=
  have hf' : StronglyMeasurable[m] (f ∘ (m.trim hm).toMeasurable (univ : Set β)) :=
    hf.comp_measurable (measurable_toMeasurable _ _)
  have hg' : StronglyMeasurable[m] (g 

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/CircleIntegral.lean - 2024-09-09 01:04:13.157868.
---127/200---
For theorem circleIntegral.norm_integral_lt_of_norm_le_const_of_lt in Mathlib/MeasureTheory/Integral/CircleIntegral.lean:
theorem norm_integral_lt_of_norm_le_const_of_lt {f : ℂ → E} {c : ℂ} {R C : ℝ} (hR : 0 < R)
    (hc : ContinuousOn f (sphere c R)) (hf : ∀ z ∈ sphere c R, ‖f z‖ ≤ C)
    (hlt : ∃ z ∈ sphere c R, ‖f z‖ < C) : ‖∮ z in C(c, R), f z‖ < 2 * π * R * C 


Original valid proof:
:= by
  rw [← _root_.abs_of_pos hR, ← image_circleMap_Ioc] at hlt
  rcases hlt with ⟨_, ⟨θ₀, hmem, rfl⟩, hlt⟩
  calc
    ‖∮ z in C(c, R), f z‖ ≤ ∫ θ in (0)..2 * π, ‖deriv (circleMap c R) θ • f (circleMap c R θ)‖ :=
      intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le
    _ < ∫ _ in (0)..2 * π, R * C := by
      simp only [norm_smul, deriv_circleMap, norm_eq_abs, map_mul, abs_I, mul_one,
        abs_circleMap_zero, abs_of_pos hR]
      refine intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt
          Real.two_pi_pos ?_ continuousOn_const (fun θ _ => ?_) ⟨θ₀, Ioc_subset_Icc_self hmem, ?_⟩
      · exact continuousOn_const.mul (hc.comp (continuous_circleMap _ _).continuousOn fun θ _ =>
          circleMap_mem_sphere _ hR.le _).norm
      · exact mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere _ hR.le _) hR.le
      · exact (mul_lt_mul_left hR).2 hlt
    _ = 2 * π * R * C := by simp [mul_assoc]; ring


Verifying proof (Commit e92ad7acc4d771729f70601a74a3c091f330e507):
∨
      (∃ z ∈ sphere c R, ‖f z‖ < C) ∧ ‖∮ z in C(c, R), f z‖ = 2 * π * R * C := by
  rcases exists_mem_frontier_norm_lt_and_ne_of_isCompact_of_continuousOn_of_exists_ne
      isCompact_sphere hc hlt with
    ⟨z₀, hz₀, hlt₀, hne⟩
  rcases eq_or_ne (‖f z₀‖) C with (hne' | hne')
  · refine' Or.inr ⟨⟨z₀, hz₀, hne'⟩, _⟩
    have hle : ∀ z ∈ sphere c R, ‖f z‖ ≤ ‖f z₀‖ := fun z hz =>
      (hf z hz).trans (hne'.le.trans (hne z₀ hz₀).symm.le)
    have hlt : ∀ z ∈ sphere c R, ‖f z‖ < ‖f z₀‖ + 1 := fun z hz =>
      (hf z hz).trans_lt (hlt₀.trans_le (hle z hz))
    have hsub : sphere c R ⊆ closedBall c R \ {z₀} :=
      sphere_subset_closedBall.trans_ssubset (diff_singleton_subset_iff.2 <| ball_subset_interior_frontier hR)
    have hsub' : sphere c R ⊆ interior (sphere c R \ {z₀}) :=
      hsub.trans interior_diff_subset_interior_of_isOpen isOpen_interior
    have hsub'' : interior (sphere c R \ {z₀}) ⊆ sphere c R \ {z₀} :=
      interior_subset
    have hsub''' : sphere c R \ {z₀} ⊆ sphere c R := diff_subset
    have hsub'''' : interior (sphere c R \ {z₀}) ⊆ sphere c R :=
      hsub'''.trans hsub
    have hsub''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub''''
    have hsub'''''' : interior (sphere c R) ⊆ sphere c R := interior_subset
    have hsub''''''' : interior (sphere c R \ {z₀}) ⊆ sphere c R :=
      hsub'''''
        .trans hsub''''''.trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub'''''''
    have hsub''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      hsub''''''''
        .trans hsub''''''''.trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub'''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub'''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub'''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub'''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub'''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub''''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub'''''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub''''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub''''''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub'''''''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub''''''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub''''''''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub'''''''''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub''''''''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub''''''''''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub'''''''''''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub''''''''''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub''''''''''''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''''''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub'''''''''''''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub''''''''''''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (sphere c R) :=
      interior_mono hsub''''''''''''''''''''''''''''
        .trans hsub''''''''
        .trans_subset (diff_subset.trans interior_subset)
    have hsub'''''''''''''''''''''''''''''' : interior (sphere c R \ {z₀}) ⊆ interior (

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/Lebesgue.lean - 2024-09-09 01:04:36.514146.
---128/200---
For theorem MeasureTheory.lintegral_liminf_le in Mathlib/MeasureTheory/Integral/Lebesgue.lean:
theorem lintegral_liminf_le' {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, AEMeasurable (f n) μ) :
    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ ≤ liminf (fun n => ∫⁻ a, f n a ∂μ) atTop 


Original valid proof:
:=
  calc
    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ = ∫⁻ a, ⨆ n : ℕ, ⨅ i ≥ n, f i a ∂μ := by
      simp only [liminf_eq_iSup_iInf_of_nat]
    _ = ⨆ n : ℕ, ∫⁻ a, ⨅ i ≥ n, f i a ∂μ :=
      (lintegral_iSup' (fun n => aemeasurable_biInf _ (to_countable _) (fun i _ ↦ h_meas i))
        (ae_of_all μ fun a n m hnm => iInf_le_iInf_of_subset fun i hi => le_trans hnm hi))
    _ ≤ ⨆ n : ℕ, ⨅ i ≥ n, ∫⁻ a, f i a ∂μ := iSup_mono fun n => le_iInf₂_lintegral _
    _ = atTop.liminf fun n => ∫⁻ a, f n a ∂μ := Filter.liminf_eq_iSup_iInf_of_nat.symm


Verifying proof (Commit 3f9dee6adf287742f66dfda5079840cb2497af69):
↔
      ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
  have h_ae_seq : ∀ n, ∃ c, ∀ᵐ a ∂μ, f n a ≤ c := by
    intro n
    exact ⟨∞, eventually_of_forall fun a => le_top⟩
  have h_ae_seq' : ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
    filter_upwards [ae_all_iff.2 h_ae_seq] with a h using h
  rw [lintegral_liminf_eq_liminf_lintegral' h_meas, liminf_le_liminf]
  · simp_rw [eventually_map]
    exact h_ae_seq'
  · intro n
    exact AEMeasurable.mono_ac (h_meas n) (Measure.AbsolutelyContinuous.rfl.absolutelyContinuous)
  · exact isBounded_ge_of_tendsto tendsto_atTop

Repaired Proof:
theorem lintegral_liminf_le' {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, AEMeasurable (f n) μ) :
    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ ≤ liminf (fun n => ∫⁻ a, f n a ∂μ) atTop ↔
      ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
  have h_ae_seq : ∀ n, ∃ c, ∀ᵐ a ∂μ, f n a ≤ c := by
    intro n
    exact ⟨∞, eventually_of_forall fun a => le_top⟩
  have h_ae_seq' : ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
    filter_upwards [ae_all_iff.2 h_ae_seq] with a h using h
  rw [lintegral_liminf_eq_liminf_lintegral' h_meas, liminf_le_liminf]
  · simp_rw [eventually_map]
    exact h_ae_seq'
  · intro n
    exact AEMeasurable.mono_ac (h_meas n) AbsolutelyContinuous.rfl
  · exact isBounded_ge_of_tendsto tendsto_atTop

Repaired Proof:
theorem lintegral_liminf_le' {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, AEMeasurable (f n) μ) :
    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ ≤ liminf (fun n => ∫⁻ a, f n a ∂μ) atTop ↔
      ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
  have h_ae_seq : ∀ n, ∃ c, ∀ᵐ a ∂μ, f n a ≤ c := by
    intro n
    exact ⟨∞, eventually_of_forall fun a => le_top⟩
  have h_ae_seq' : ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
    filter_upwards [ae_all_iff.2 h_ae_seq] with a h using h
  rw [lintegral_liminf_eq_liminf_lintegral' h_meas, liminf_le_liminf]
  · simp_rw [eventually_map]
    exact h_ae_seq'
  · intro n
    exact AEMeasurable.mono_ac (h_meas n) AbsolutelyContinuous.rfl
  · exact isBounded_ge_of_tendsto tendsto_atTop

Repaired Proof:
theorem lintegral_liminf_le' {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, AEMeasurable (f n) μ) :
    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ ≤ liminf (fun n => ∫⁻ a, f n a ∂μ) atTop ↔
      ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
  have h_ae_seq : ∀ n, ∃ c, ∀ᵐ a ∂μ, f n a ≤ c := by
    intro n
    exact ⟨∞, eventually_of_forall fun a => le_top⟩
  have h_ae_seq' : ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
    filter_upwards [ae_all_iff.2 h_ae_seq] with a h using h
  rw [lintegral_liminf_eq_liminf_lintegral' h_meas, liminf_le_liminf]
  · simp_rw [eventually_map]
    exact h_ae_seq'
  · intro n
    exact AEMeasurable.mono_ac (h_meas n) AbsolutelyContinuous.rfl
  · exact isBounded_ge_of_tendsto tendsto_atTop

Repaired Proof:
theorem lintegral_liminf_le' {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, AEMeasurable (f n) μ) :
    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ ≤ liminf (fun n => ∫⁻ a, f n a ∂μ) atTop ↔
      ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
  have h_ae_seq : ∀ n, ∃ c, ∀ᵐ a ∂μ, f n a ≤ c := by
    intro n
    exact ⟨∞, eventually_of_forall fun a => le_top⟩
  have h_ae_seq' : ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
    filter_upwards [ae_all_iff.2 h_ae_seq] with a h using h
  rw [lintegral_liminf_eq_liminf_lintegral' h_meas, liminf_le_liminf]
  · simp_rw [eventually_map]
    exact h_ae_seq'
  · intro n
    exact AEMeasurable.mono_ac (h_meas n) AbsolutelyContinuous.rfl
  · exact isBounded_ge_of_tendsto tendsto_atTop

Repaired Proof:
theorem lintegral_liminf_le' {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, AEMeasurable (f n) μ) :
    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ ≤ liminf (fun n => ∫⁻ a, f n a ∂μ) atTop ↔
      ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
  have h_ae_seq : ∀ n, ∃ c, ∀ᵐ a ∂μ, f n a ≤ c := by
    intro n
    exact ⟨∞, eventually_of_forall fun a => le_top⟩
  have h_ae_seq' : ∀ᵐ a ∂μ, ∀ n, ∃ c, ∀ m, n ≤ m → f m a ≤ c := by
    filter_upwards [ae_all_iff.2 h_ae_seq] with a h using h
  rw [lintegral_liminf_eq_liminf_lintegral' h_meas, liminf_le_liminf]
  ·

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/SetIntegral.lean - 2024-09-09 01:04:58.846404.
---129/200---
For theorem MeasureTheory.integral_finset_biUnion in Mathlib/MeasureTheory/Integral/SetIntegral.lean:
theorem integral_finset_biUnion {ι : Type*} (t : Finset ι) {s : ι → Set X}
    (hs : ∀ i ∈ t, MeasurableSet (s i)) (h's : Set.Pairwise (↑t) (Disjoint on s))
    (hf : ∀ i ∈ t, IntegrableOn f (s i) μ) :
    ∫ x in ⋃ i ∈ t, s i, f x ∂μ = ∑ i ∈ t, ∫ x in s i, f x ∂μ 


Original valid proof:
:= by
  induction' t using Finset.induction_on with a t hat IH hs h's
  · simp
  · simp only [Finset.coe_insert, Finset.forall_mem_insert, Set.pairwise_insert,
      Finset.set_biUnion_insert] at hs hf h's ⊢
    rw [integral_union _ _ hf.1 (integrableOn_finset_iUnion.2 hf.2)]
    · rw [Finset.sum_insert hat, IH hs.2 h's.1 hf.2]
    · simp only [disjoint_iUnion_right]
      exact fun i hi => (h's.2 i hi (ne_of_mem_of_not_mem hi hat).symm).1
    · exact Finset.measurableSet_biUnion _ hs.2


Verifying proof (Commit 25e538f3a737a71314ac143929711e67d0b14d73):
↔
      Integrable f (μ.restrict (⋃ i ∈ t, s i)) := by
  induction' t using Finset.induction_on with a t hat IH hs' h's
  · simp only [Finset.not_mem_empty, IsEmpty.forall_iff, forall_true_left, set_biUnion_empty,
      sum_empty, measure_empty, integral_zero_measure, forall₂_true_iff]
    exact ⟨fun hf' => ⟨hf', integrable_zero⟩, fun _ => hf'.1⟩
  have hs'' : ∀ i ∈ insert a t, MeasurableSet (s i) := by simpa using hs
  have h's' : Set.Pairwise (↑(insert a t)) (Disjoint on s) := by
    rwa [Finset.coe_insert, pairwise_insert_of_symmetric (symmetric_on_iff_disjoint.2 h's)]
  have I :
    ∫ x in ⋃ i ∈ insert a t, s i, f x ∂μ =
      ∫ x in ⋃ i ∈ t, s i ∪ s a, f x ∂μ := by
    simp only [Finset.set_biUnion_insert]
  rw [I, integral_union' (hs'' a (mem_insert_self _ _)) (hs'' a (mem_insert_of_mem hat))
      (h's' a (mem_insert_self _ _)) (hs' _ <| mem_insert_of_mem hat) (h's' _ <| mem_insert_self _ _),
    sum_insert hat, IH (fun i hi => hs' _ <| mem_of_mem_insert_of_ne hi <| ne_of_mem_of_not_mem _ hat)
      (fun i hi => hf _ <| mem_of_mem_insert_of_ne hi <| ne_of_mem_of_not_mem _ hat)
      (h's.mono fun i hi => hi.mono (by simp only [Disjoint, onFun, Function.comp_apply,
        Set.disjoint_left, not_imp_not, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp]
  rw [h's' a (mem_insert_self _ _), pairwise_insert_of_symmetric (symmetric_on_iff_disjoint.2 h's),
    IH (fun i hi => hs' _ <| mem_of_mem_insert_of_ne hi <| ne_of_mem_of_not_mem _ hat)
      (fun i hi => hf _ <| mem_of_mem_insert_of_ne hi <| ne_of_mem_of_not_mem _ hat)
      (h's.mono fun i hi => hi.mono <| by simp only [disjoint_union_left, disjoint_union_right,
        Set.disjoint_left, not_imp_not, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion,
        exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp,
        mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp, and_imp, mem_iUnion, exists_imp,
        and_imp, mem_iUnion, exists_imp

Attempt failure.

Working on Mathlib/MeasureTheory/MeasurableSpace/Basic.lean - 2024-09-09 01:05:29.025219.
---130/200---
For theorem exists_measurable_piecewise in Mathlib/MeasureTheory/MeasurableSpace/Basic.lean:
theorem exists_measurable_piecewise {ι} [Countable ι] [Nonempty ι] (t : ι → Set α)
    (t_meas : ∀ n, MeasurableSet (t n)) (g : ι → α → β) (hg : ∀ n, Measurable (g n))
    (ht : Pairwise fun i j => EqOn (g i) (g j) (t i ∩ t j)) :
    ∃ f : α → β, Measurable f ∧ ∀ n, EqOn f (g n) (t n) 


Original valid proof:
:= by
  inhabit ι
  set g' : (i : ι) → t i → β := fun i => g i ∘ (↑)
  have ht' : ∀ (i j) (x : α) (hxi : x ∈ t i) (hxj : x ∈ t j), g' i ⟨x, hxi⟩ = g' j ⟨x, hxj⟩ := by
    intro i j x hxi hxj
    rcases eq_or_ne i j with rfl | hij
    · rfl
    · exact ht hij ⟨hxi, hxj⟩
  set f : (⋃ i, t i) → β := iUnionLift t g' ht' _ Subset.rfl
  have hfm : Measurable f := measurable_iUnionLift _ _ t_meas
    (fun i => (hg i).comp measurable_subtype_coe)
  classical
    refine ⟨fun x => if hx : x ∈ ⋃ i, t i then f ⟨x, hx⟩ else g default x,
      hfm.dite ((hg default).comp measurable_subtype_coe) (.iUnion t_meas), fun i x hx => ?_⟩
    simp only [dif_pos (mem_iUnion.2 ⟨i, hx⟩)]
    exact iUnionLift_of_mem ⟨x, mem_iUnion.2 ⟨i, hx⟩⟩ hx


Verifying proof (Commit 4449fea6cb71b0c9863e5f2aaa338fd940fe3afa):
∧ ∀ x, x ∉ t n → f x = g n x := by
  obtain ⟨f, f_meas, hf⟩ :
    ∃ f : α → β, Measurable f ∧ ∀ n, EqOn f (g n) (t n) ∧ ∀ x, x ∉ t n → f x = g 0 x := by
    refine' ⟨fun x => g 0 x, hg 0, fun n => ⟨_, fun x hx => rfl⟩⟩
    rintro x ⟨hxt, h'xt⟩
    rcases (t_meas n).inter_eq_self_of_subset_left
      (ht (ne_of_mem_of_not_mem hxt h'xt).symm.subset_compl_right)
      (mem_inter hxt h'xt) with
      (hxt' | h'xt')
    · exact hf n x hxt'
    · exact (ht (ne_of_mem_of_not_mem hxt h'xt').symm).subset_compl_right (mem_inter hxt' h'xt)
  refine' ⟨fun x => if x ∈ t 0 then f x else g 0 x, _, fun n => ⟨_, _⟩⟩
  · refine' measurable_if (t_meas 0) f_meas _
    exact (hg 0).mono (t_meas 0).compl
  · intro x hx
    simp only [hx, if_true, eqOn_refl]
  · intro x hx
    simp only [hx, if_false]

Repaired Proof:
theorem exists_measurable_piecewise {ι} [Countable ι] [Nonempty ι] (t : ι → Set α)
    (t_meas : ∀ n, MeasurableSet (t n)) (g : ι → α → β) (hg : ∀ n, Measurable (g n))
    (ht : Pairwise fun i j => EqOn (g i) (g j) (t i ∩ t j)) :
    ∃ f : α → β, Measurable f ∧ ∀ n, EqOn f (g n) (t n) ∧ ∀ x, x ∉ t n → f x = g n x := by
  obtain ⟨f, f_meas, hf⟩ :
    ∃ f : α → β, Measurable f ∧ ∀ n, EqOn f (g n) (t n) ∧ ∀ x, x ∉ t n → f x = g 0 x := by
    refine ⟨fun x => g 0 x, hg 0, fun n => ⟨?_, fun x hx => rfl⟩⟩
    rintro x ⟨hxt, h'xt⟩
    rcases (t_meas n).inter_eq_self_of_subset_left
      (ht (ne_of_mem_of_not_mem hxt h'xt).symm.subset_compl_right)
      (mem_inter hxt h'xt) with
      (hxt' | h'xt')
    · exact hf n x hxt'
    · exact (ht (ne_of_mem_of_not_mem hxt h'xt').symm).subset_compl_right (mem_inter hxt' h'xt)
  refine ⟨fun x => if x ∈ t 0 then f x else g 0 x, ?_, fun n => ⟨?_, ?_⟩⟩
  · refine measurable_if (t_meas 0) f_meas ?_
    exact (hg 0).mono (t_meas 0).compl
  · intro x hx
    simp only [hx, if_true, eqOn_refl]
  · intro x hx
    simp only [hx, if_false]

Repaired Proof:
theorem exists_measurable_piecewise {ι} [Countable ι] [Nonempty ι] (t : ι → Set α)
    (t_meas : ∀ n, MeasurableSet (t n)) (g : ι → α → β) (hg : ∀ n, Measurable (g n))
    (ht : Pairwise fun i j => EqOn (g i) (g j) (t i ∩ t j)) :
    ∃ f : α → β, Measurable f ∧ ∀ n, EqOn f (g n) (t n) ∧ ∀ x, x ∉ t n → f x = g n x := by
  obtain ⟨f, f_meas, hf⟩ :
    ∃ f : α → β, Measurable f ∧ ∀ n, EqOn f (g n) (t n) ∧ ∀ x, x ∉ t n → f x = g 0 x := by
    refine ⟨fun x => g 0 x, hg 0, fun n => ⟨?_, fun x hx => rfl⟩⟩
    rintro x ⟨hxt, h'xt⟩
    rcases (t_meas n).inter_eq_self_of_subset_left
      (ht (ne_of_mem_of_not_mem hxt h'xt).symm.subset_compl_right)
      (mem_inter hxt h'xt) with
      (hxt' | h'xt')
    · exact hf n x hxt'
    · exact (ht (ne_of_mem_of_not_mem hxt h'xt').symm).subset_compl_right (mem_inter hxt' h'xt)
  refine ⟨fun x => if x ∈ t 0 then f x else g 0 x, ?_, fun n => ⟨?_, ?_⟩⟩
  · refine measurable_if (t_meas 0) f_meas ?_
    exact (hg 0).mono (t_meas 0).compl
  · intro x hx
    simp only [hx, if_true, eqOn_refl]
  · intro x hx
    simp only [hx, if_false]

Repaired Proof:
theorem exists_measurable_piecewise {ι} [Countable ι] [Nonempty ι] (t : ι → Set α)
    (t_meas : ∀ n, MeasurableSet (t n)) (g : ι → α → β) (hg : ∀ n, Measurable (g n))
    (ht : Pairwise fun i j => EqOn (g i) (g j) (t i ∩ t j)) :
    ∃ f : α → β, Measurable f ∧ ∀ n, EqOn f (g n) (t n) ∧ ∀ x, x ∉ t n → f x = g n x := by
  obtain ⟨f, f_meas, hf⟩ :
    ∃ f : α → β, Measurable f ∧ ∀ n, EqOn f (g n) (t n) ∧ ∀ x, x ∉ t n → f x = g 0 x := by
    refine ⟨fun x => g 0 x, hg 0, fun n => ⟨?_, fun x hx => rfl⟩⟩
    rintro x ⟨hxt, h'xt⟩
    rcases (t_meas n).inter_eq_self_of_subset_left
      (ht (ne_of_mem_of_not_mem hxt h'xt).symm.subset_compl_right)
      (mem_inter hxt h'xt) with
      (hxt' | h'xt')
    · exact hf n x hxt'
    · exact (ht (ne_of_mem_of_not_mem hxt h'xt').symm).subset_compl_right (mem_inter hxt' h'xt)
  refine ⟨fun x => if x ∈ t 0 then f x else g 0 x, ?_, fun n => ⟨?_, ?_⟩⟩
  · refine measurable_if (t_meas 0) f_meas ?_
    exact (hg 0).mono (t_meas 0).compl
  · intro x hx
    simp only [hx, if_true, eqOn_refl]
  · intro x hx
    simp only [hx, if_false]

Repaired Proof:
theorem exists_measurable_piecewise {ι} [Countable ι] [Nonempty ι] (t : ι → Set α)
    (t_meas : ∀ n

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/AddContent.lean - 2024-09-09 01:05:41.474325.
---131/200---
For theorem MeasureTheory.addContent_union' in Mathlib/MeasureTheory/Measure/AddContent.lean:
lemma addContent_union' (hs : s ∈ C) (ht : t ∈ C) (hst : s ∪ t ∈ C) (h_dis : Disjoint s t) :
    m (s ∪ t) = m s + m t 


Original valid proof:
:= by
  by_cases hs_empty : s = ∅
  · simp only [hs_empty, Set.empty_union, addContent_empty, zero_add]
  classical
  have h := addContent_sUnion (m := m) (I := {s, t}) ?_ ?_ ?_
  rotate_left
  · simp only [coe_pair, Set.insert_subset_iff, hs, ht, Set.singleton_subset_iff, and_self_iff]
  · simp only [coe_pair, Set.pairwiseDisjoint_insert, pairwiseDisjoint_singleton,
      mem_singleton_iff, Ne, id, forall_eq, true_and_iff]
    exact fun _ => h_dis
  · simp only [coe_pair, sUnion_insert, sUnion_singleton]
    exact hst
  convert h
  · simp only [coe_pair, sUnion_insert, sUnion_singleton]
  · rw [sum_insert, sum_singleton]
    simp only [Finset.mem_singleton]
    refine fun hs_eq_t => hs_empty ?_
    rw [← hs_eq_t] at h_dis
    exact Disjoint.eq_bot_of_self h_dis


Verifying proof (Commit 26c29dc27c999d53a30ed03b6e655c799e1675d8):
↔ m (s ∪ t) = addContent C (s ∪ t) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · rw [h, addContent_union hst h_dis]
  · rw [h, addContent_union hst h_dis]
    exact m_mono hst

Repaired Proof:
lemma addContent_union' (hs : s ∈ C) (ht : t ∈ C) (hst : s ∪ t ∈ C) (h_dis : Disjoint s t) :
    m (s ∪ t) = m s + m t ↔ m (s ∪ t) = addContent C (s ∪ t) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · rw [h, addContent_union hst h_dis]
  · rw [h, addContent_union hst h_dis]
    exact m_mono hst

Repaired Proof:
lemma addContent_union (hs : s ∈ C) (ht : t ∈ C) (hst : s ∪ t ∈ C) (h_dis : Disjoint s t) :
    m (s ∪ t) = m s + m t := by
  rw [addContent_union' hs ht hst h_dis]
  exact m_mono hst

Repaired Proof:
lemma addContent_union (hs : s ∈ C) (ht : t ∈ C) (hst : s ∪ t ∈ C) (h_dis : Disjoint s t) :
    m (s ∪ t) = m s + m t := by
  rw [addContent_union' hs ht hst h_dis]
  exact m_mono hst

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Haar/Quotient.lean - 2024-09-09 01:05:49.166439.
---132/200---
For theorem QuotientGroup.integral_mul_eq_integral_automorphize_mul in Mathlib/MeasureTheory/Measure/Haar/Quotient.lean:
lemma QuotientGroup.integral_mul_eq_integral_automorphize_mul {K : Type*} [NormedField K]
    [NormedSpace ℝ K] [μ.IsMulRightInvariant] {f : G → K}
    (f_ℒ_1 : Integrable f μ) {g : G ⧸ Γ → K} (hg : AEStronglyMeasurable g μ_𝓕)
    (g_ℒ_infinity : essSup (fun x ↦ ↑‖g x‖₊) μ_𝓕 ≠ ∞)
    (F_ae_measurable : AEStronglyMeasurable (QuotientGroup.automorphize f) μ_𝓕) :
    ∫ x : G, g (x : G ⧸ Γ) * (f x) ∂μ
      = ∫ x : G ⧸ Γ, g x * (QuotientGroup.automorphize f x) ∂μ_𝓕 


Original valid proof:
:= by
  let π : G → G ⧸ Γ := QuotientGroup.mk
  have meas_π : Measurable π := continuous_quotient_mk'.measurable
  have H₀ : QuotientGroup.automorphize ((g ∘ π) * f) = g * (QuotientGroup.automorphize f) := by
    exact QuotientGroup.automorphize_smul_left f g
  calc ∫ (x : G), g (π x) * (f x) ∂μ =
        ∫ (x : G ⧸ Γ), QuotientGroup.automorphize ((g ∘ π) * f) x ∂μ_𝓕 := ?_
    _ = ∫ (x : G ⧸ Γ), g x * (QuotientGroup.automorphize f x) ∂μ_𝓕 := by simp [H₀]
  have H₁ : Integrable ((g ∘ π) * f) μ := by
    have : AEStronglyMeasurable (fun (x : G) ↦ g (x : (G ⧸ Γ))) μ :=
      (hg.mono_ac h𝓕.absolutelyContinuous_map).comp_measurable meas_π
    refine Integrable.essSup_smul f_ℒ_1 this ?_
    have hg' : AEStronglyMeasurable (fun x ↦ (‖g x‖₊ : ℝ≥0∞)) μ_𝓕 :=
      (ENNReal.continuous_coe.comp continuous_nnnorm).comp_aestronglyMeasurable hg
    rw [← essSup_comp_quotientGroup_mk h𝓕 hg'.aemeasurable]
    exact g_ℒ_infinity
  have H₂ : AEStronglyMeasurable (QuotientGroup.automorphize ((g ∘ π) * f)) μ_𝓕 := by
    simp_rw [H₀]
    exact hg.mul F_ae_measurable
  apply QuotientGroup.integral_eq_integral_automorphize h𝓕 H₁ H₂


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
 := by
  rw [← QuotientGroup.integral_mul_eq_integral_automorphize_smul μ f_ℒ_1 g hg g_ℒ_infinity
    F_ae_measurable, ← QuotientGroup.integral_mul_eq_integral_automorphize_smul μ f_ℒ_1 g
    (hg.comp_smul _) g_ℒ_infinity F_ae_measurable]
  congr 1 with x
  simp_rw [QuotientGroup.automorphize_apply, QuotientGroup.smul_apply]
  rw [mul_comm]

Repaired Proof:
lemma QuotientGroup.integral_mul_eq_integral_automorphize_mul {K : Type*} [NormedField K]
    [NormedSpace ℝ K] [μ.IsMulRightInvariant] {f : G → K}
    (f_ℒ_1 : Integrable f μ) {g : G ⧸ Γ → K} (hg : AEStronglyMeasurable g μ_𝓕)
    (g_ℒ_infinity : essSup (fun x ↦ ↑‖g x‖₊) μ_𝓕 ≠ ∞)
    (F_ae_measurable : AEStronglyMeasurable (QuotientGroup.automorphize f) μ_𝓕) :
    ∫ x : G, g (x : G ⧸ Γ) * (f x) ∂μ
      = ∫ x : G ⧸ Γ, g x * (QuotientGroup.automorphize f x) ∂μ_𝓕  := by
  rw [← QuotientGroup.integral_mul_eq_integral_automorphize_smul μ f_ℒ_1 g hg g_ℒ_infinity
    F_ae_measurable, ← QuotientGroup.integral_mul_eq_integral_automorphize_smul μ f_ℒ_1 g
    (hg.comp_smul _) g_ℒ_infinity F_ae_measurable]
  congr 1 with x
  simp_rw [QuotientGroup.automorphize_apply, QuotientGroup.smul_apply]
  rw [mul_comm]

Repaired Proof:
lemma QuotientGroup.integral_mul_eq_integral_automorphize_mul {K : Type*} [NormedField K]
    [NormedSpace ℝ K] [μ.IsMulRightInvariant] {f : G → K}
    (f_ℒ_1 : Integrable f μ) {g : G ⧸ Γ → K} (hg : AEStronglyMeasurable g μ_𝓕)
    (g_ℒ_infinity : essSup (fun x ↦ ↑‖g x‖₊) μ_𝓕 ≠ ∞)
    (F_ae_measurable : AEStronglyMeasurable (QuotientGroup.automorphize f) μ_𝓕) :
    ∫ x : G, g (x : G ⧸ Γ) * (f x) ∂μ
      = ∫ x : G ⧸ Γ, g x * (QuotientGroup.automorphize f x) ∂μ_𝓕  := by
  rw [← QuotientGroup.integral_mul_eq_integral_automorphize_smul μ f_ℒ_1 g hg g_ℒ_infinity
    F_ae_measurable, ← QuotientGroup.integral_mul_eq_integral_automorphize_smul μ f_ℒ_1 g
    (hg.comp_smul _) g_ℒ_infinity F_ae_measurable]
  congr 1 with x
  simp_rw [QuotientGroup.automorphize_apply, QuotientGroup.smul_apply]
  rw [mul_comm]

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/HasOuterApproxClosed.lean - 2024-09-09 01:06:08.319390.
---133/200---
For theorem MeasureTheory.ext_of_forall_lintegral_eq_of_IsFiniteMeasure in Mathlib/MeasureTheory/Measure/HasOuterApproxClosed.lean:
theorem ext_of_forall_lintegral_eq_of_IsFiniteMeasure {Ω : Type*}
    [MeasurableSpace Ω] [TopologicalSpace Ω] [HasOuterApproxClosed Ω]
    [BorelSpace Ω] {μ ν : Measure Ω} [IsFiniteMeasure μ]
    (h : ∀ (f : Ω →ᵇ ℝ≥0), ∫⁻ x, f x ∂μ = ∫⁻ x, f x ∂ν) :
    μ = ν 


Original valid proof:
:= by
  have key := @measure_isClosed_eq_of_forall_lintegral_eq_of_isFiniteMeasure Ω _ _ _ _ μ ν _ h
  apply ext_of_generate_finite _ ?_ isPiSystem_isClosed
  · exact fun F F_closed ↦ key F_closed
  · exact key isClosed_univ
  · rw [BorelSpace.measurable_eq (α := Ω), borel_eq_generateFrom_isClosed]


Verifying proof (Commit b06172d4564b9175743e7c2bc9a24868a9516c7f):
∨ μ = 0 ∧ ν = 0 := by
  rcases eq_zero_or_neZero μ with rfl|hμ
  · exact Or.inl rfl
  right
  have : ∀ f : Ω →ᵇ ℝ≥0, ∫⁻ x, f x ∂μ = 0 ∧ ∫⁻ x, f x ∂ν = 0 := by
    intro f
    have A : ∫⁻ x, f x ∂μ ≠ ∞ := f.lintegral_lt_top_of_nnreal.ne
    have B : ∫⁻ x, f x ∂ν ≠ ∞ := f.lintegral_lt_top_of_nnreal.ne
    have C : ∫⁻ x, f x ∂μ = ∫⁻ x, f x ∂ν := h f
    simp only [A, B, C, ENNReal.eq_zero_of_ne_top, and_self]
  have D : ∀ f : Ω →ᵇ ℝ≥0, f = 0 := by
    intro f
    have : ∫⁻ x, f x ∂μ = 0 ∧ ∫⁻ x, f x ∂ν = 0 := this f
    rcases f.exists_forall_le with ⟨c, hc⟩
    have : c = 0 := by
      have : ∫⁻ x, c ∂μ = 0 ∧ ∫⁻ x, c ∂ν = 0 := this ⟨c, rfl⟩
      simpa [hc] using this.1
    simpa [hc, this]
  have E : ∀ f : Ω →ᵇ ℝ≥0∞, f = 0 := by
    intro f
    rcases f.exists_forall_le with ⟨c, hc⟩
    have : c = 0 := by
      have : ∫⁻ x, c ∂μ = 0 ∧ ∫⁻ x, c ∂ν = 0 := this ⟨c, rfl⟩
      simpa [hc] using this.1
    simpa [hc, this]
  have F : ∀ f : Ω →ᵇ ℝ, f = 0 := by
    intro f
    rcases f.exists_forall_le with ⟨c, hc⟩
    have : c = 0 := by
      have : ∫⁻ x, c ∂μ = 0 ∧ ∫⁻ x, c ∂ν = 0 := this ⟨c, rfl⟩
      simpa [hc] using this.1
    simpa [hc, this]
  simp [D, E, F]

Repaired Proof:
theorem ext_of_forall_lintegral_eq_of_IsFiniteMeasure {Ω : Type*}
    [MeasurableSpace Ω] [TopologicalSpace Ω] [HasOuterApproxClosed Ω]
    [BorelSpace Ω] {μ ν : Measure Ω} [IsFiniteMeasure μ]
    (h : ∀ (f : Ω →ᵇ ℝ≥0), ∫⁻ x, f x ∂μ = ∫⁻ x, f x ∂ν) :
    μ = ν ∨ μ = 0 ∧ ν = 0 := by
  rcases eq_zero_or_neZero μ with rfl|hμ
  · exact Or.inl rfl
  right
  have : ∀ f : Ω →ᵇ ℝ≥0, ∫⁻ x, f x ∂μ = 0 ∧ ∫⁻ x, f x ∂ν = 0 := by
    intro f
    have A : ∫⁻ x, f x ∂μ ≠ ∞ := f.lintegral_lt_top_of_nnreal.ne
    have B : ∫⁻ x, f x ∂ν ≠ ∞ := f.lintegral_lt_top_of_nnreal.ne
    have C : ∫⁻ x, f x ∂μ = ∫⁻ x, f x ∂ν := h f
    simp only [A, B, C, ENNReal.eq_zero_of_ne_top, and_self]
  have D : ∀ f : Ω →ᵇ ℝ≥0, f = 0 := by
    intro f
    have : ∫⁻ x, f x ∂μ = 0 ∧ ∫⁻ x, f x ∂ν = 0 := this f
    rcases f.exists_forall_le with ⟨c, hc⟩
    have : c = 0 := by
      have : ∫⁻ x, c ∂μ = 0 ∧ ∫⁻ x, c ∂ν = 0 := this ⟨c, rfl⟩
      simpa [hc] using this.1
    simpa [hc, this]
  have E : ∀ f : Ω →ᵇ ℝ≥0∞, f = 0 := by
    intro f
    rcases f.exists_forall_le with ⟨c, hc⟩
    have : c = 0 := by
      have : ∫⁻ x, c ∂μ = 0 ∧ ∫⁻ x, c ∂ν = 0 := this ⟨c, rfl⟩
      simpa [hc] using this.1
    simpa [hc, this]
  have F : ∀ f : Ω →ᵇ ℝ, f = 0 := by
    intro f
    rcases f.exists_forall_le with ⟨c, hc⟩
    have : c = 0 := by
      have : ∫⁻ x, c ∂μ = 0 ∧ ∫⁻ x, c ∂ν = 0 := this ⟨c, rfl⟩
      simpa [hc] using this.1
    simpa [hc, this]
  simp [D, E, F]

Repaired Proof:
theorem ext_of_forall_lintegral_eq_of_IsFiniteMeasure {Ω : Type*}
    [MeasurableSpace Ω] [TopologicalSpace Ω] [HasOuterApproxClosed Ω]
    [BorelSpace Ω] {μ ν : Measure Ω} [IsFiniteMeasure μ]
    (h : ∀ (f : Ω →ᵇ ℝ≥0), ∫⁻ x, f x ∂μ = ∫⁻ x, f x ∂ν) :
    μ = ν ∨ μ = 0 ∧ ν = 0 := by
  rcases eq_zero_or_neZero μ with rfl|hμ
  · exact Or.inl rfl
  right
  have : ∀ f : Ω →ᵇ ℝ≥0, ∫⁻ x, f x ∂μ = 0 ∧ ∫⁻ x, f x ∂ν = 0 := by
    intro f
    have A : ∫⁻ x, f x ∂μ ≠ ∞ := f.lintegral_lt_top_of_nnreal.ne
    have B : ∫⁻ x, f x ∂ν ≠ ∞ := f.lintegral_lt_top_of_nnreal.ne
    have C : ∫⁻ x, f x ∂μ = ∫⁻ x, f x ∂ν := h f
    simp only [A, B, C, ENNReal.eq_zero_of_ne_top, and_self]
  have D : ∀ f : Ω →ᵇ ℝ≥0, f = 0 := by
    intro f
    have : ∫⁻ x, f x ∂μ = 0 ∧ ∫⁻ x, f x ∂ν = 0 := this f
    rcases f.exists_forall_le with ⟨c, hc⟩
    have : c = 0 := by
      have : ∫⁻ x, c ∂μ = 0 ∧ ∫⁻ x, c ∂ν = 0 := this ⟨c, rfl⟩
      simpa [hc] using this.1
    simpa [hc, this]
  have E : ∀ f : Ω →ᵇ ℝ≥0∞, f = 0 := by
    intro f
    rcases f.exists_forall_le with ⟨

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Hausdorff.lean - 2024-09-09 01:06:19.691770.
---134/200---
For theorem Isometry.hausdorffMeasure_image in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s 


Original valid proof:
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  · rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)
    · simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    · simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ⟨x, hx⟩
    · haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  · have hCd0 : (C : ℝ≥0∞) ^ d ≠ 0 := by simp [hC0.ne']
    have hCd : (C : ℝ≥0∞) ^ d ≠ ∞ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      ← ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : ℝ≥0∞ => (C : ℝ≥0∞) * d ^ (r : ℝ)) (𝓝 0) (𝓝 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      ⟨δ, δ0, H⟩
    refine le_iSup₂_of_le δ δ0 <| iInf₂_mono' fun t hst ↦
      ⟨fun n => f '' (t n ∩ s), ?_, iInf_mono' fun htδ ↦
        ⟨fun n => (h.ediam_image_inter_le (t n)).trans (H (htδ n)).le, ?_⟩⟩
    · rw [← image_iUnion, ← iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    · refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, ← ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine' ⟨_, _⟩
  · refine' (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top _ _)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine' (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top _ _)).ne _).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/MeasureSpace.lean - 2024-09-09 01:06:41.195180.
---135/200---
For theorem MeasureTheory.measure_limsup_eq_zero in Mathlib/MeasureTheory/Measure/MeasureSpace.lean:
theorem measure_limsup_eq_zero {s : ℕ → Set α} (hs : (∑' i, μ (s i)) ≠ ∞) :
    μ (limsup s atTop) = 0 


Original valid proof:
:= by
  set t : ℕ → Set α := fun n => toMeasurable μ (s n)
  have ht : (∑' i, μ (t i)) ≠ ∞ := by simpa only [t, measure_toMeasurable] using hs
  suffices μ (limsup t atTop) = 0 by
    have A : s ≤ t := fun n => subset_toMeasurable μ (s n)
    exact measure_mono_null (limsup_le_limsup (eventually_of_forall (Pi.le_def.mp A))) this
  simp only [limsup_eq_iInf_iSup_of_nat', Set.iInf_eq_iInter, Set.iSup_eq_iUnion, ←
    nonpos_iff_eq_zero]
  refine
    le_of_tendsto_of_tendsto'
      (tendsto_measure_iInter
        (fun i => MeasurableSet.iUnion fun b => measurableSet_toMeasurable _ _) ?_
        ⟨0, ne_top_of_le_ne_top ht (measure_iUnion_le t)⟩)
      (ENNReal.tendsto_sum_nat_add (μ ∘ t) ht) fun n => measure_iUnion_le _
  intro n m hnm x
  simp only [Set.mem_iUnion]
  exact fun ⟨i, hi⟩ => ⟨i + (m - n), by simpa only [add_assoc, tsub_add_cancel_of_le hnm] using hi⟩


Verifying proof (Commit 464f10c2e8d95b797cf97f9520e276bb51b872af):
↔ ∀ ε : ℝ≥0∞, ε ≠ 0 → ∃ N, ∀ n ≥ N, μ (s n) < ε :=
  have h0 : ∀ N, ∑' n : ℕ, indicator {x | x ∉ s n} (1 : { x // x ∈ α }) x ≤
      ∑' n : ℕ, indicator {x | x ∉ s (n + N)} (1 : { x // x ∈ α }) x := by
    intro N
    refine' tsum_mono_subtype _ _
    simp only [true_and_iff, mem_setOf_eq, mem_univ, Subtype.forall, Subtype.coe_mk]
    intro n
    simp only [indicator_apply, mem_setOf_eq, mem_univ, Subtype.coe_mk, ← compl_setOf,
      compl_subset_compl, Nat.add_le_add_iff_right]
  suffices
    μ (limsup s atTop) = 0 ↔ ∀ ε : ℝ≥0∞, ε ≠ 0 → ∃ N, ∀ n ≥ N, μ (s n) < ε
    by simpa [limsup, liminf, h0]
  by_cases h : ∃ N, ∀ n ≥ N, μ (s n) = 0
  · simp only [h, true_and_iff, measure_limsup_eq_zero_iff_indicator_tendsto_zero,
      measure_zero_iff_ae_nmem, eventually_atTop, not_exists, not_forall, exists_prop,
      exists_imp, not_and, not_lt, ge_iff_le, not_le, imp_iff_not_or, or_comm,
      or_imp, forall_and, forall_eq', forall_eq]
    refine' ⟨fun hε => ⟨0, fun n _ => hε n⟩, fun hε n => _⟩
    obtain ⟨N, hN⟩ := hε
    exact hN (N + n) (le_add_self)
  simp only [h, false_and_iff, not_exists, not_forall, exists_prop, exists_imp,
    not_and, not_lt, ge_iff_le, not_le, imp_iff_not_or, or_comm, or_imp, forall_and,
    forall_eq', forall_eq]
  refine' ⟨fun hε => ⟨0, fun n _ => hε n⟩, fun hε => _⟩
  obtain ⟨N, hN⟩ := hε
  refine' le_of_tendsto_of_tendsto' (tendsto_measure_liminf_atTop_zero hs)
    (tendsto_measure_limsup_atTop_zero hs) fun n => _
  simp only [liminf, limsup, eventually_atTop, ge_iff_le, true_and_iff, Subtype.coe_mk,
    mem_setOf_eq, measure_iUnion_null_iff, measure_iUnion_le, imp_self, imp_true_iff,
    measure_limsup_eq_zero_iff_indicator_tendsto_zero, measure_zero_iff_ae_nmem,
    eventually_map, eventually_atTop, ge_iff_le, true_and_iff, Subtype.coe_mk, mem_setOf_eq,
    measure_iUnion_null_iff, measure_iUnion_le, imp_self, imp_true_iff, measure_limsup_eq_zero_iff_indicator_tendsto_zero,
    measure_zero_iff_ae_nmem, eventually_map, eventually_atTop, ge_iff_le, true_and_iff,
    Subtype.coe_mk, mem_setOf_eq, measure_iUnion_null_iff, measure_iUnion_le, imp_self,
    imp_true_iff, measure_limsup_eq_zero_iff_indicator_tendsto_zero, measure_zero_iff_ae_nmem,
    eventually_map, eventually_atTop, ge_iff_le, true_and_iff, Subtype.coe_mk, mem_setOf_eq,
    measure_iUnion_null_iff, measure_iUnion_le, imp_self, imp_true_iff]
  simp only [true_and_iff, mem_setOf_eq, mem_univ, Subtype.forall, Subtype.coe_mk,
    compl_setOf, compl_subset_compl] at hN
  simp only [true_and_iff, mem_setOf_eq, mem_univ, Subtype.forall, Subtype.coe_mk,
    compl_setOf, compl_subset_compl, Nat.add_le_add_iff_right] at hN
  simp only [true_and_iff, mem_setOf_eq, mem_univ, Subtype.forall, Subtype.coe_mk,
    compl_setOf, compl_subset_compl, Nat.add_le_add_iff_right, ge_iff_le, not_le]
  intro n
  obtain ⟨N, hN⟩ := hN n
  refine' ⟨N + n, le_add_self, _⟩
  simp only [true_and_iff, mem_setOf_eq, mem_univ, Subtype.forall, Subtype.coe_mk,
    compl_setOf, compl_subset_compl, Nat.add_le_add_iff_right, ge_iff_le, not_le] at hN
  simp only [true_and_iff, mem_setOf_eq, mem_univ, Subtype.forall, Subtype.coe_mk,
    compl_setOf, compl_subset_compl, Nat.add_le_add_iff_right, ge_iff_le, not_le]
  exact hN

Repaired Proof:
theorem measure_limsup_eq_zero {s : ℕ → Set α} (hs : (∑' i, μ (s i)) ≠ ∞) :
    μ (limsup s atTop) = 0 ↔ ∀ ε : ℝ≥0∞, ε ≠ 0 → ∃ N, ∀ n ≥ N, μ (s n) < ε :=
  have h0 : ∀ N, ∑' n : ℕ, indicator {x | x ∉ s n} (1 : { x // x ∈ α }) x ≤
      ∑' n : ℕ, indicator {x | x ∉ s (n + N)} (1 : { x // x ∈ α }) x := by
    intro N
    refine tsum_mono_subtype _ _
    simp only [true_and_iff, mem_setOf_eq, mem_univ, Subtype.forall, Subtype.coe_mk]
    intro n
    simp only [indicator_apply, mem_setOf_eq, mem_univ, Subtype.coe_mk, ← compl_setOf,
      compl_subset_compl, Nat.add_le_add_iff_right]
  suffices
    μ (limsup s atTop) = 0 ↔ ∀ ε : ℝ≥0∞, ε ≠ 0 → ∃ N, ∀ n ≥ N, μ (s n) < ε
    by simpa [limsup, liminf, h0]
  by_cases h : ∃ N, ∀ n ≥ N, μ (s n) = 0
  · simp only [h, true_and_iff, measure_limsup_eq_zero_iff_indicator_tendsto_zero,
      measure_zero_iff_ae_nmem, eventually_atTop, not_exists, not_forall, exists_prop,
      exists_imp, not_and, not_lt, ge_iff_le, not_le, imp_iff_not_or, or_comm,
      or_imp, forall_and, forall_eq', forall_eq]
    refine ⟨fun hε => ⟨0, fun n _ => hε n⟩, fun hε n => ?_⟩
    obtain ⟨N, hN⟩ := hε
    exact hN (N + n) (le_add_self)
  simp only [h, false_and_iff, not_exists, not_forall, exists_prop, exists_imp,
    not_and, not_lt, ge_iff_le, not_le, imp_iff_not_or, or_comm, or_imp, forall_and,
    forall_eq', forall_eq]
  refine ⟨fun hε => ⟨0, fun n _ => hε n⟩, fun hε => ?_⟩
  obtain 

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/VectorMeasure.lean - 2024-09-09 01:07:04.973043.
---136/200---
For theorem MeasureTheory.VectorMeasure.MutuallySingular.add_left in Mathlib/MeasureTheory/Measure/VectorMeasure.lean:
theorem add_left [T2Space N] [ContinuousAdd M] (h₁ : v₁ ⟂ᵥ w) (h₂ : v₂ ⟂ᵥ w) : v₁ + v₂ ⟂ᵥ w 


Original valid proof:
:= by
  obtain ⟨u, hmu, hu₁, hu₂⟩ := h₁
  obtain ⟨v, hmv, hv₁, hv₂⟩ := h₂
  refine mk (u ∩ v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_
  · rw [add_apply, hu₁ _ (Set.subset_inter_iff.1 ht).1, hv₁ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  · rw [Set.compl_inter] at ht
    rw [(_ : t = uᶜ ∩ t ∪ vᶜ \ uᶜ ∩ t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), hu₂, hv₂, add_zero]
    · exact Set.Subset.trans Set.inter_subset_left diff_subset
    · exact Set.inter_subset_left
    · exact disjoint_sdiff_self_right.mono Set.inter_subset_left Set.inter_subset_left
    · apply Set.Subset.antisymm <;> intro x hx
      · by_cases hxu' : x ∈ uᶜ
        · exact Or.inl ⟨hxu', hx⟩
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr ⟨⟨hxv, hxu'⟩, hx⟩]
      · cases' hx with hx hx <;> exact hx.2


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
 := by
    rintro s ⟨u, v, hvu, hsuv, huv⟩
    rw [add_apply, huv.add_apply, ENNReal.add_right_eq_top, or_iff_not_imp_left]
    intro h
    exact h₁ ⟨u, v, hvu, (disjoint_iff_inf_le.mpr hsuv).inter_eq, h⟩

Repaired Proof:
theorem add_left [T2Space N] [ContinuousAdd M] (h₁ : v₁ ⟂ᵥ w) (h₂ : v₂ ⟂ᵥ w) : v₁ + v₂ ⟂ᵥ w  := by
  rintro s ⟨u, v, hvu, hsuv, huv⟩
  rw [add_apply, huv.add_apply, ENNReal.add_right_eq_top, or_iff_not_imp_left]
  intro h
  exact h₁ ⟨u, v, hvu, (disjoint_iff_inf_le.mpr hsuv).inter_eq, h⟩

Repaired Proof:
theorem add_right [T2Space N] [ContinuousAdd M] (h₁ : v₁ ⟂ᵥ w₁) (h₂ : v₂ ⟂ᵥ w₂) : v₁ ⟂ᵥ w₁ + w₂ :=
  (h₁.symm.add_left h₂.symm).symm

Repaired Proof:
theorem smul_left {R : Type*} [SMul R M] [ContinuousConstSMul R M] [SMulZeroClass R N]
    {v : VectorMeasure α M} {w : VectorMeasure α N} (r : R) : r • v ⟂ᵥ w ↔ v ⟂ᵥ w := by
  refine ⟨fun h s hs h₁ => ?_, fun h => h.smul r⟩
  rw [← zero_smul R (w s), ← h.measure_inter_add_diff hs, smul_add, Pi.smul_apply,
    smul_eq_mul, Pi.smul_apply, smul_eq_mul, ← mul_add]
  exact mul_eq_zero_of_right _ h₁

Repaired Proof:
theorem smul_left {R : Type*} [SMul R M] [ContinuousConstSMul R M] [SMulZeroClass R N]
    {v : VectorMeasure α M} {w : VectorMeasure α N} (r : R) : r • v ⟂ᵥ w ↔ v ⟂ᵥ w := by
  refine ⟨fun h s hs h₁ => ?_, fun h => h.smul r⟩
  rw [← zero_smul R (w s), ← h.measure_inter_add_diff hs, smul_add, Pi.smul_apply,
    smul_eq_mul, Pi.smul_apply, smul_eq_mul, ← mul_add]
  exact mul_eq_zero_of_right _ h₁

Repaired Proof:
theorem smul_right {R : Type*} [SMul R N] [ContinuousConstSMul R N] [SMulZeroClass R M]
    {v : VectorMeasure α M} {w : VectorMeasure α N} (r : R) : v ⟂ᵥ r • w ↔ v ⟂ᵥ w := by
  rw [← smul_left, smul_comm]

Repaired Proof:
theorem smul_right {R : Type*} [SMul R N] [ContinuousConstSMul R N] [SMulZeroClass R M]
    {v : VectorMeasure α M} {w : VectorMeasure α N} (r : R) : v ⟂ᵥ r • w ↔ v ⟂ᵥ w := by
  rw [← smul_left, smul_comm]

Repaired Proof:
theorem neg_left {M : Type*} [AddCommGroup M] [TopologicalSpace M] [TopologicalAddGroup M]
    {v : VectorMeasure α M} {w : VectorMeasure α N} : -v ⟂ᵥ w ↔ v ⟂ᵥ w := by
  constructor <;> intro h <;> constructor
  · rintro s hs ⟨r, rfl⟩
    rw [h.neg.measure_add_eq hs, neg_add_self, zero_smul]
  · rintro s hs ⟨r, rfl⟩
    rw [h.neg.measure_add_eq hs, neg_add_self, zero_smul]

Repaired Proof:
theorem neg_left {M : Type*} [AddCommGroup M] [TopologicalSpace M] [TopologicalAddGroup M]
    {v : VectorMeasure α M} {w : VectorMeasure α N} : -v ⟂ᵥ w ↔ v ⟂ᵥ w := by
  constructor <;> intro h <;> constructor
  · rintro s hs ⟨r, rfl⟩
    rw [h.neg.measure_add_eq hs, neg_add_self, zero_smul]
  · rintro s hs ⟨r, rfl⟩
    rw [h.neg.measure_add_eq hs, neg_add_self, zero_smul]

Repaired Proof:
theorem neg_right {N : Type*} [AddCommGroup N] [TopologicalSpace N] [TopologicalAddGroup N]
    {v : VectorMeasure α M} {w : VectorMeasure α N} : v ⟂ᵥ -w ↔ v ⟂ᵥ w := by
  rw [← neg_neg w, neg_left, neg_neg]

Repaired Proof:
theorem neg_right {N : Type*} [AddCommGroup N] [TopologicalSpace N] [TopologicalAddGroup N]
    {v : VectorMeasure α M} {w : VectorMeasure α N} : v ⟂ᵥ -w ↔ v ⟂ᵥ w := by
  rw [← neg_neg w, neg_left, neg_neg]

Repaired Proof:
theorem sub_left {M : Type*} [AddCommGroup M] [TopologicalSpace M] [TopologicalAddGroup M]
    {v₁ v₂ : VectorMeasure α M} {w : VectorMeasure α N} : v₁ - v₂ ⟂ᵥ w ↔ v₁ ⟂ᵥ w ∧ v₂ ⟂ᵥ w := by
  rw [sub_eq_add_neg, add_left, neg_left]

Repaired Proof:
theorem sub_left {M : Type*} [AddCommGroup M] [TopologicalSpace M] [TopologicalAddGroup M]
    {v₁ v₂ : VectorMeasure α M} {w : VectorMeasure α N} : v₁ - v₂ ⟂ᵥ w ↔ v₁ ⟂ᵥ w ∧ v₂ ⟂ᵥ w := by
  rw [sub_eq_add_neg, add_left, neg_left]

Repaired Proof:
theorem sub_right {N : Type*} [AddCommGroup N] [TopologicalSpace N] [TopologicalAddGroup N]
    {v : VectorMeasure α M} {w₁ w₂ : VectorMeasure α N} : v ⟂ᵥ w₁ - w₂ ↔ v ⟂ᵥ w₁ ∧ v ⟂ᵥ w₂ := by
  rw [sub_eq_add_neg, sub_eq_add_neg, add_right, neg_right]

Repaired Proof:
theorem sub_right {N : Type*} [AddCommGroup N] [TopologicalSpace N] [TopologicalAddGroup N]
    {v : VectorMeasure α M} {w₁ w₂ : VectorMeasure α N} : v ⟂ᵥ w₁ - w₂ ↔ v ⟂ᵥ w₁ ∧ v ⟂ᵥ w₂ := by
  rw [sub_eq_add_neg, sub_eq_add_neg, add_right, neg_right]

Repaired Proof:
theorem smul_left {R : Type*} [SMul R M] [ContinuousConstSMul R M]
    [SMulZeroClass R N] [ContinuousConstSMul R N] {v : VectorMeasure α M} {w : VectorMeasure α N}
    {r : R} : r • v ⟂ᵥ w ↔ v ⟂ᵥ r • w := by
  refine ⟨fun h s hs h₁ => ?_, fun h s hs h₁ => ?_⟩
  · rw

Attempt failure.

Working on Mathlib/ModelTheory/Satisfiability.lean - 2024-09-09 01:07:24.794895.
---137/200---
For theorem FirstOrder.Language.Theory.models_iff_not_satisfiable in Mathlib/ModelTheory/Satisfiability.lean:
theorem models_iff_not_satisfiable (φ : L.Sentence) : T ⊨ᵇ φ ↔ ¬IsSatisfiable (T ∪ {φ.not}) 


Original valid proof:
:= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    ⟨fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T ∪ {Formula.not φ})
          (Set.subset_union_right (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel Set.subset_union_left)),
      fun h M => ?_⟩
  contrapose! h
  rw [← Sentence.realize_not] at h
  refine
    ⟨{  Carrier := M
        is_model := ⟨fun ψ hψ => hψ.elim (realize_sentence_of_mem _) fun h' => ?_⟩ }⟩
  rw [Set.mem_singleton_iff.1 h']
  exact h


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
∧
      T ⊨ᵇ φ.not := by
  rw [models_iff_not_satisfiable_union, ← model_iff, ← model_iff, Set.union_singleton,
    Set.union_singleton]

Repaired Proof:
theorem models_iff_not_satisfiable (φ : L.Sentence) : T ⊨ᵇ φ ↔ ¬IsSatisfiable (T ∪ {φ.not}) ∧
      T ⊨ᵇ φ.not := by
  rw [models_iff_not_satisfiable_union, ← model_iff, ← model_iff, Set.union_singleton,
    Set.union_singleton]

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine' ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => _⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩

Repaired Proof:
theorem models_sentence_iff (h : M ⊨ T) (φ : L.Sentence) : M ⊨ φ ↔ T ⊨ᵇ φ := by
  refine ⟨fun hφ => models_sentence_of_mem T hφ, fun hφ => ?_⟩
  obtain ⟨S, hS, hST⟩ := exists_subset_models_of_subset_theory hφ
  exact hS ⟨h.realizeSentence, fun h' => h.false (hST h')⟩



Attempt failure.

Working on Mathlib/NumberTheory/Bernoulli.lean - 2024-09-09 01:07:35.831223.
---138/200---
For theorem bernoulli'_odd_eq_zero in Mathlib/NumberTheory/Bernoulli.lean:
theorem bernoulli'_odd_eq_zero {n : ℕ} (h_odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0 


Original valid proof:
:= by
  let B := mk fun n => bernoulli' n / (n ! : ℚ)
  suffices (B - evalNegHom B) * (exp ℚ - 1) = X * (exp ℚ - 1) by
    cases' mul_eq_mul_right_iff.mp this with h h <;>
      simp only [PowerSeries.ext_iff, evalNegHom, coeff_X] at h
    · apply eq_zero_of_neg_eq
      specialize h n
      split_ifs at h <;> simp_all [B, h_odd.neg_one_pow, factorial_ne_zero]
    · simpa (config := {decide := true}) [Nat.factorial] using h 1
  have h : B * (exp ℚ - 1) = X * exp ℚ := by
    simpa [bernoulli'PowerSeries] using bernoulli'PowerSeries_mul_exp_sub_one ℚ
  rw [sub_mul, h, mul_sub X, sub_right_inj, ← neg_sub, mul_neg, neg_eq_iff_eq_neg]
  suffices evalNegHom (B * (exp ℚ - 1)) * exp ℚ = evalNegHom (X * exp ℚ) * exp ℚ by
    rw [map_mul, map_mul] at this 
    simpa [mul_assoc, sub_mul, mul_comm (evalNegHom (exp ℚ)), exp_mul_exp_neg_eq_one]
  congr


Verifying proof (Commit 1737baecc8d3128fff663633128256ff0699ff55):
∧
    ¬(n : ℚ) ∣ 1 - 1 / (n - 1) := by
  have h₁ : 1 - 1 / (n - 1) = (n - 2) / (n - 1) := by
    have h₁' : 1 ≤ n - 1 := by rwa [Nat.sub_one, Nat.succ_le_iff]
    have h₁'' : 0 < n - 1 := Nat.sub_pos_of_lt hlt
    field_simp [h₁', h₁'']
    ring
  have h₂ : (n - 2) / (n - 1) ≠ 0 := by
    intro h
    rw [div_eq_zero_iff, sub_eq_zero, sub_eq_iff_eq_add, eq_comm, ← Nat.cast_two,
      Nat.cast_inj] at h
    · exact hlt.ne' h
    · exact_mod_cast hlt.trans_le' (Nat.le_add_left 1 1)
  rw [bernoulli'_odd_eq_zero_iff, h₁, h₂, not_false_iff]

Repaired Proof:
theorem bernoulli'_odd_eq_zero {n : ℕ} (h_odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0 ∧
    ¬(n : ℚ) ∣ 1 - 1 / (n - 1) := by
  have h₁ : 1 - 1 / (n - 1) = (n - 2) / (n - 1) := by
    have h₁' : 1 ≤ n - 1 := by rwa [Nat.sub_one, Nat.succ_le_iff]
    have h₁'' : 0 < n - 1 := Nat.sub_pos_of_lt hlt
    field_simp [h₁', h₁'']
    ring
  have h₂ : (n - 2) / (n - 1) ≠ 0 := by
    intro h
    rw [div_eq_zero_iff, sub_eq_zero, sub_eq_iff_eq_add, eq_comm, ← Nat.cast_two,
      Nat.cast_inj] at h
    · exact hlt.ne' h
    · exact_mod_cast hlt.trans_le (Nat.le_add_left 1 1)
  rw [bernoulli'_odd_eq_zero_iff, h₁, h₂, not_false_iff]

Repaired Proof:
theorem bernoulli'_odd_eq_zero {n : ℕ} (h_odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0 ∧
    ¬(n : ℚ) ∣ 1 - 1 / (n - 1) := by
  have h₁ : 1 - 1 / (n - 1) = (n - 2) / (n - 1) := by
    have h₁' : 1 ≤ n - 1 := by rwa [Nat.sub_one, Nat.succ_le_iff]
    have h₁'' : 0 < n - 1 := Nat.sub_pos_of_lt hlt
    field_simp [h₁', h₁'']
    ring
  have h₂ : (n - 2) / (n - 1) ≠ 0 := by
    intro h
    rw [div_eq_zero_iff, sub_eq_zero, sub_eq_iff_eq_add, eq_comm, ← Nat.cast_two,
      Nat.cast_inj] at h
    · exact hlt.ne' h
    · exact_mod_cast hlt.trans_le (Nat.le_add_left 1 1)
  rw [bernoulli'_odd_eq_zero_iff, h₁, h₂, not_false_iff]

Repaired Proof:
theorem bernoulli'_odd_eq_zero {n : ℕ} (h_odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0 ∧
    ¬(n : ℚ) ∣ 1 - 1 / (n - 1) := by
  have h₁ : 1 - 1 / (n - 1) = (n - 2) / (n - 1) := by
    have h₁' : 1 ≤ n - 1 := by rwa [Nat.sub_one, Nat.succ_le_iff]
    have h₁'' : 0 < n - 1 := Nat.sub_pos_of_lt hlt
    field_simp [h₁', h₁'']
    ring
  have h₂ : (n - 2) / (n - 1) ≠ 0 := by
    intro h
    rw [div_eq_zero_iff, sub_eq_zero, sub_eq_iff_eq_add, eq_comm, ← Nat.cast_two,
      Nat.cast_inj] at h
    · exact hlt.ne' h
    · exact_mod_cast hlt.trans_le (Nat.le_add_left 1 1)
  rw [bernoulli'_odd_eq_zero_iff, h₁, h₂, not_false_iff]

Repaired Proof:
theorem bernoulli'_odd_eq_zero {n : ℕ} (h_odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0 ∧
    ¬(n : ℚ) ∣ 1 - 1 / (n - 1) := by
  have h₁ : 1 - 1 / (n - 1) = (n - 2) / (n - 1) := by
    have h₁' : 1 ≤ n - 1 := by rwa [Nat.sub_one, Nat.succ_le_iff]
    have h₁'' : 0 < n - 1 := Nat.sub_pos_of_lt hlt
    field_simp [h₁', h₁'']
    ring
  have h₂ : (n - 2) / (n - 1) ≠ 0 := by
    intro h
    rw [div_eq_zero_iff, sub_eq_zero, sub_eq_iff_eq_add, eq_comm, ← Nat.cast_two,
      Nat.cast_inj] at h
    · exact hlt.ne' h
    · exact_mod_cast hlt.trans_le (Nat.le_add_left 1 1)
  rw [bernoulli'_odd_eq_zero_iff, h₁, h₂, not_false_iff]

Repaired Proof:
theorem bernoulli'_odd_eq_zero {n : ℕ} (h_odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0 ∧
    ¬(n : ℚ) ∣ 1 - 1 / (n - 1) := by
  have h₁ : 1 - 1 / (n - 1) = (n - 2) / (n - 1) := by
    have h₁' : 1 ≤ n - 1 := by rwa [Nat.sub_one, Nat.succ_le_iff]
    have h₁'' : 0 < n - 1 := Nat.sub_pos_of_lt hlt
    field_simp [h₁', h₁'']
    ring
  have h₂ : (n - 2) / (n - 1) ≠ 0 := by
    intro h
    rw [div_eq_zero_iff, sub_eq_zero, sub_eq_iff_eq_add, eq_comm, ← Nat.cast_two,
      Nat.cast_inj] at h
    · exact hlt.ne' h
    · exact_mod_cast hlt.trans_le (Nat.le_add_left 1 1)
  rw [bernoulli'_odd_eq_zero_iff, h₁, h₂, not_false_iff]

Repaired Proof:
theorem bernoulli'_odd_eq_zero {n : ℕ} (h_odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0 ∧
    ¬(n : ℚ) ∣ 1 - 1 / (n - 1) := by
  have h₁ : 1 - 1 / (n - 1) = (n - 2) / (n - 1) := by
    have h₁' : 1 ≤ n - 1 := by rwa [Nat.sub_one, Nat.succ_le_iff]
    have h₁'' : 0 < n - 1 := Nat.sub_

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean - 2024-09-09 01:07:55.399494.
---139/200---
For theorem Polynomial.exists_partition_polynomial in Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean:
theorem exists_partition_polynomial_aux (n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : Fq[X]} (hb : b ≠ 0)
    (A : Fin n → Fq[X]) : ∃ t : Fin n → Fin (Fintype.card Fq ^ ⌈-log ε / log (Fintype.card Fq)⌉₊),
      ∀ i₀ i₁ : Fin n, t i₀ = t i₁ ↔
        (cardPowDegree (A i₁ % b - A i₀ % b) : ℝ) < cardPowDegree b • ε 


Original valid proof:
:= by
  have hbε : 0 < cardPowDegree b • ε := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hε
  induction' n with n ih
  · refine ⟨finZeroElim, finZeroElim⟩
  have anti_archim' : ∀ {i j k} {ε : ℝ},
    (cardPowDegree (A i % b - A j % b) : ℝ) < ε →
      (cardPowDegree (A j % b - A k % b) : ℝ) < ε →
        (cardPowDegree (A i % b - A k % b) : ℝ) < ε := by
    intro i j k ε
    simp_rw [← Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain ⟨t', ht'⟩ := ih (Fin.tail A)
  rsuffices ⟨j, hj⟩ :
    ∃ j, ∀ i, t' i = j ↔ (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε
  · refine ⟨Fin.cons j t', fun i₀ i₁ => ?_⟩
    refine Fin.cases ?_ (fun i₀ => ?_) i₀ <;> refine Fin.cases ?_ (fun i₁ => ?_) i₁
    · simpa using hbε
    · rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj i₁
    · rw [Fin.cons_succ, Fin.cons_zero]
      exact hj i₀
    · rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' i₀ i₁
  obtain ⟨j, hj⟩ : ∃ j, ∀ i : Fin n,
      t' i = j → (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε := by
    by_contra! hg
    obtain ⟨j₀, j₁, j_ne, approx⟩ := exists_approx_polynomial hb hε
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine Fin.cases ?_ (fun j₀ => ?_) j₀ <;>
      refine Fin.cases (fun j_ne approx => ?_) (fun j₁ j_ne approx => ?_) j₁
    · exact absurd rfl j_ne
    · rw [Fin.cons_succ, Fin.cons_zero, ← not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg j₁)).2
      contradiction
    · rw [Fin.cons_succ, Fin.cons_zero, ← not_le] at approx
      have := (Classical.choose_spec (hg j₀)).2
      contradiction
    · rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : j₀ = j₁ := (Classical.choose_spec (hg j₀)).1.symm.trans
        (((ht' (Classical.choose (hg j₀)) (Classical.choose (hg j₁))).mpr approx).trans
          (Classical.choose_spec (hg j₁)).1)
      contradiction
  by_cases exists_nonempty_j : ∃ j, (∃ i, t' i = j) ∧
      ∀ i, t' i = j → (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε
  · obtain ⟨j, ⟨i, hi⟩, hj⟩ := exists_nonempty_j
    refine ⟨j, fun i' => ⟨hj i', fun hi' => _root_.trans ((ht' _ _).mpr ?_) hi⟩⟩
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine ⟨j, fun i => ⟨hj i, fun hi => ?_⟩⟩
  have := exists_nonempty_j ⟨t' i, ⟨i, rfl⟩, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')⟩
  contradiction


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
∧
          cardPowDegree (A i₁ % b - A i₀ % b) ≠ 0 := by
  have hb' : 0 < cardPowDegree b := by
    rw [cardPowDegree_pos_iff]; exact hb
  have hε' : 0 < ε / 2 := half_pos hε
  have hε'' : 0 < ε ^ 4 / 16 := by positivity
  have hε''' : 0 < ε ^ 12 / 16 ^ 3 := by positivity
  have hε'''' : 0 < ε ^ 24 / 16 ^ 4 := by positivity
  have hε''''' : 0 < ε ^ 48 / 16 ^ 5 := by positivity
  have hε'''''' : 0 < ε ^ 96 / 16 ^ 6 := by positivity
  have hε''''''' : 0 < ε ^ 192 / 16 ^ 7 := by positivity
  have hε'''''''' : 0 < ε ^ 384 / 16 ^ 8 := by positivity
  have hε''''''''' : 0 < ε ^ 768 / 16 ^ 9 := by positivity
  have hε'''''''''' : 0 < ε ^ 1536 / 16 ^ 10 := by positivity
  have hε''''''''''' : 0 < ε ^ 3072 / 16 ^ 11 := by positivity
  have hε'''''''''''' : 0 < ε ^ 6144 / 16 ^ 12 := by positivity
  have hε''''''''''''' : 0 < ε ^ 12288 / 16 ^ 13 := by positivity
  have hε'''''''''''''' : 0 < ε ^ 24576 / 16 ^ 14 := by positivity
  have hε''''''''''''''' : 0 < ε ^ 49152 / 16 ^ 15 := by positivity
  have hε'''''''''''''''' : 0 < ε ^ 98304 / 16 ^ 16 := by positivity
  have hε''''''''''''''''' : 0 < ε ^ 196608 / 16 ^ 17 := by positivity
  have hε'''''''''''''''''' : 0 < ε ^ 393216 / 16 ^ 18 := by positivity
  have hε''''''''''''''''''' : 0 < ε ^ 786432 / 16 ^ 19 := by positivity
  have hε'''''''''''''''''''' : 0 < ε ^ 1572864 / 16 ^ 20 := by positivity
  have hε''''''''''''''''''''' : 0 < ε ^ 3145728 / 16 ^ 21 := by positivity
  have hε'''''''''''''''''''''' : 0 < ε ^ 6291456 / 16 ^ 22 := by positivity
  have hε''''''''''''''''''''''' : 0 < ε ^ 12582912 / 16 ^ 23 := by positivity
  have hε'''''''''''''''''''''''' : 0 < ε ^ 25165824 / 16 ^ 24 := by positivity
  set s : ℕ := ⌈-log ε / log (Fintype.card Fq)⌉₊ with hs
  have hs' : s = ⌈-log ε / log (Fintype.card Fq)⌉₊ := rfl
  have hs'' : (s : ℝ) = -log ε / log (Fintype.card Fq) := by
    rw [hs', Nat.ceil_eq_iff]
    constructor
    · rw [neg_div]
      exact div_nonneg (neg_nonneg.2 hε.le) (log_nonneg <| Fintype.card_pos_iff.2 Fq_nonempty)
    · exact ⟨le_rfl, neg_div.symm ▸ sub_neg_of_lt (neg_lt_neg hε)⟩
  have hε''''''''''''''''''''''''' : 0 < ε ^ 50331648 / 16 ^ 25 := by positivity
  have hε'''''''''''''''''''''''''' : 0 < ε ^ 100663296 / 16 ^ 26 := by positivity
  have hε''''''''''''''''''''''''''' : 0 < ε ^ 201326592 / 16 ^ 27 := by positivity
  have hε'''''''''''''''''''''''''''' : 0 < ε ^ 402653184 / 16 ^ 28 := by positivity
  have hε''''''''''''''''''''''''''''' : 0 < ε ^ 805306368 / 16 ^ 29 := by positivity
  have hε'''''''''''''''''''''''''''''' : 0 < ε ^ 1610612736 / 16 ^ 30 := by positivity
  have hε''''''''''''''''''''''''''''''' : 0 < ε ^ 3221225472 / 16 ^ 31 := by positivity
  have hε'''''''''''''''''''''''''''''''' : 0 < ε ^ 6442450944 / 16 ^ 32 := by positivity
  have hε''''''''''''''''''''''''''''''''' : 0 < ε ^ 12884901888 / 16 ^ 33 := by positivity
  have hε'''''''''''''''''''''''''''''''''' : 0 < ε ^ 25769803776 / 16 ^ 34 := by positivity
  have hε''''''''''''''''''''''''''''''''''' : 0 < ε ^ 51539607552 / 16 ^ 35 := by positivity
  have hε'''''''''''''''''''''''''''''''''''' : 0 < ε ^ 103079215104 / 16 ^ 36 := by positivity
  have hε''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 206158430208 / 16 ^ 37 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 412316860416 / 16 ^ 38 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 824633720832 / 16 ^ 39 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 1649267441664 / 16 ^ 40 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 3298534883328 / 16 ^ 41 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 6597069766656 / 16 ^ 42 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 13194139533312 / 16 ^ 43 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 26388279066624 / 16 ^ 44 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 52776558133248 / 16 ^ 45 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 105553116266496 / 16 ^ 46 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 211106232532992 / 16 ^ 47 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 422212465065984 / 16 ^ 48 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 844424930131968 / 16 ^ 49 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 1688849860263936 / 16 ^ 50 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''''''''

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/Finite.lean - 2024-09-09 01:08:08.925894.
---140/200---
For theorem ClassGroup.exists_mem_finsetApprox in Mathlib/NumberTheory/ClassNumber/Finite.lean:
theorem exists_mem_finsetApprox (a : S) {b} (hb : b ≠ (0 : R)) :
    ∃ q : S,
      ∃ r ∈ finsetApprox bS adm, abv (Algebra.norm R (r • a - b • q)) <
      abv (Algebra.norm R (algebraMap R S b)) 


Original valid proof:
:= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set ε : ℝ := normBound abv bS ^ (-1 / Fintype.card ι : ℝ) with ε_eq
  have hε : 0 < ε := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have ε_le : (normBound abv bS : ℝ) * (abv b • ε) ^ (Fintype.card ι : ℝ)
                ≤ abv b ^ (Fintype.card ι : ℝ) := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [ε_eq, Algebra.smul_def, eq_intCast, mul_rpow, ← rpow_mul, div_mul_cancel₀, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; omega
    · exact Iff.mpr Int.cast_nonneg this
    · linarith
  set μ : Fin (cardM bS adm).succ ↪ R := distinctElems bS adm with hμ
  let s : ι →₀ R := bS.repr a
  have s_eq : ∀ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ → ι → R := fun j i => μ j * s i / b
  let rs : Fin (cardM bS adm).succ → ι → R := fun j i => μ j * s i % b
  have r_eq : ∀ j i, rs j i = μ j * s i % b := fun i j => rfl
  have μ_eq : ∀ i j, μ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have μ_mul_a_eq : ∀ j, μ j • a = b • ∑ i, qs j i • bS i + ∑ i, rs j i • bS i := by
    intro j
    rw [← bS.sum_repr a]
    simp only [μ, qs, rs, Finset.smul_sum, ← Finset.sum_add_distrib]
    refine Finset.sum_congr rfl fun i _ => ?_
    rw [← hμ, ← r_eq, ← s_eq, ← mul_smul, μ_eq, add_smul, mul_smul, ← μ_eq]
  obtain ⟨j, k, j_ne_k, hjk⟩ := adm.exists_approx hε hb fun j i => μ j * s i
  have hjk' : ∀ i, (abv (rs k i - rs j i) : ℝ) < abv b • ε := by simpa only [r_eq] using hjk
  let q := ∑ i, (qs k i - qs j i) • bS i
  set r := μ k - μ j with r_eq
  refine ⟨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_⟩
  · exact ⟨k, j, j_ne_k.symm, rfl⟩
  have : r • a - b • q = ∑ x : ι, (rs k x • bS x - rs j x • bS x) := by
    simp only [q, r_eq, sub_smul, μ_mul_a_eq, Finset.smul_sum, ← Finset.sum_add_distrib,
      ← Finset.sum_sub_distrib, smul_sub]
    refine Finset.sum_congr rfl fun x _ => ?_
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)
  · apply le_of_eq
    congr
    simp_rw [map_sum, map_sub, map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  · exact mod_cast ε_le


Verifying proof (Commit 6eab74639023015a7887e2f82e153907286e3801):
∧ abv (Algebra.norm R (r • a)) ≤ abv (Algebra.norm R (algebraMap R S b)) := by
  have hb' : abv (algebraMap R S b) ≠ 0 := by
    rw [IsFractionRing.to_map_eq_zero_iff S R] at hb
    exact mod_cast hb
  obtain ⟨b', b'_mem, b_eq⟩ : ∃ b' : S, b' ∈ finsetApprox bS adm ∧
      abv (algebraMap R S b) = abv (b' * (algebraMap R S b)⁻¹) := by
    obtain ⟨b', b'_mem, b_eq⟩ := exists_mem_finsetApprox_of_unit bS adm
      (Units.mk0 (algebraMap R S b) hb')
    refine' ⟨b' * (algebraMap R S b)⁻¹, _, b_eq⟩
    convert b'_mem.mul (inv_mem_inv bS adm hb')
    simp only [mul_inv_cancel hb', Submonoid.coe_one, map_one]
  have hb'' : abv (algebraMap R S b) = abv b' * abv (algebraMap R S b)⁻¹ := by
    rw [b_eq, abv.map_mul]
  have hb''' : abv (algebraMap R S b) ≠ 0 := by
    rw [IsFractionRing.to_map_eq_zero_iff S R] at hb
    exact mod_cast IsDomain.to_noZeroDivisors.ne_zero hb
  have hb'''' : abv b' ≠ 1 := by
    intro h
    rw [h, one_mul, inv_mul_cancel hb''', abv.map_one] at hb'''
    contradiction
  have hb''''' : abv b' < 1 :=
    lt_of_le_of_ne (abv_le_bound bS adm b'_mem) fun h => hb'''' (h.symm ▸ rfl)
  have hb'''''' : abv (algebraMap R S b) ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''
  have hb''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast b'_mem.1
  have hb'''''''' : abv (algebraMap R S b)⁻¹ ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, inv_eq_zero, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''
  obtain ⟨b'', b''_mem, b'_eq⟩ : ∃ b'' : S, b'' ∈ finsetApprox bS adm ∧
      abv b' = abv (b'' * (algebraMap R S b)⁻¹) := by
    obtain ⟨b'', b''_mem, b'_eq⟩ := exists_mem_finsetApprox_of_unit bS adm
      (Units.mk0 (algebraMap R S b) hb''''''')
    refine ⟨b'' * (algebraMap R S b)⁻¹, ?_, b'_eq⟩
    convert b''_mem.mul (inv_mem_inv bS adm hb''''''')
    simp only [mul_inv_cancel hb'''''', Submonoid.coe_one, map_one]
  have hb''''''''' : abv b' = abv b'' * abv (algebraMap R S b)⁻¹ := by
    rw [b'_eq, abv.map_mul]
  have hb'''''''''' : abv b' = abv b'' * abv (algebraMap R S b)⁻¹ := by
    rw [b'_eq, abv.map_mul]
  have hb''''''''''' : abv b' < 1 :=
    lt_of_le_of_ne (abv_le_bound bS adm b''_mem) fun h => hb'''''''''' (h.symm ▸ rfl)
  have hb'''''''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast b'_mem.1
  have hb''''''''''''' : abv (algebraMap R S b)⁻¹ ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, inv_eq_zero, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''''''''
  have hb'''''''''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast b'_mem.1
  have hb''''''''''''''' : abv (algebraMap R S b)⁻¹ ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, inv_eq_zero, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''''''''''''
  have hb'''''''''''''''' : abv b' < 1 :=
    lt_of_le_of_ne (abv_le_bound bS adm b''_mem) fun h => hb'''''''''''''' (h.symm ▸ rfl)
  have hb''''''''''''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''''''''''''''
  have hb'''''''''''''''''' : abv (algebraMap R S b)⁻¹ ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, inv_eq_zero, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''''''''''''''''
  have hb''''''''''''''''''' : abv b' < 1 :=
    lt_of_le_of_ne (abv_le_bound bS adm b''_mem) fun h => hb''''''''''''''''' (h.symm ▸ rfl)
  have hb'''''''''''''''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb''''''''''''''''''
  have hb''''''''''''''''''''' : abv (algebraMap R S b)⁻¹ ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, inv_eq_zero, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''''''''''''''''''
  have hb'''''''''''''''''''''' : abv b' < 1 :=
    lt_of_le_of_ne (abv_le_bound bS adm b''_mem) fun h => hb'''''''''''''''''''' (h.symm ▸ rfl)
  have hb''''''''''''''''''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_

Attempt failure.

---141/200---
For theorem ClassGroup.exists_mem_finsetApprox in Mathlib/NumberTheory/ClassNumber/Finite.lean:
theorem exists_mem_finsetApprox (a : S) {b} (hb : b ≠ (0 : R)) :
    ∃ q : S,
      ∃ r ∈ finsetApprox bS adm, abv (Algebra.norm R (r • a - b • q)) <
      abv (Algebra.norm R (algebraMap R S b)) 


Original valid proof:
:= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set ε : ℝ := normBound abv bS ^ (-1 / Fintype.card ι : ℝ) with ε_eq
  have hε : 0 < ε := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have ε_le : (normBound abv bS : ℝ) * (abv b • ε) ^ (Fintype.card ι : ℝ)
                ≤ abv b ^ (Fintype.card ι : ℝ) := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [ε_eq, Algebra.smul_def, eq_intCast, mul_rpow, ← rpow_mul, div_mul_cancel₀, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; omega
    · exact Iff.mpr Int.cast_nonneg this
    · linarith
  set μ : Fin (cardM bS adm).succ ↪ R := distinctElems bS adm with hμ
  let s : ι →₀ R := bS.repr a
  have s_eq : ∀ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ → ι → R := fun j i => μ j * s i / b
  let rs : Fin (cardM bS adm).succ → ι → R := fun j i => μ j * s i % b
  have r_eq : ∀ j i, rs j i = μ j * s i % b := fun i j => rfl
  have μ_eq : ∀ i j, μ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have μ_mul_a_eq : ∀ j, μ j • a = b • ∑ i, qs j i • bS i + ∑ i, rs j i • bS i := by
    intro j
    rw [← bS.sum_repr a]
    simp only [μ, qs, rs, Finset.smul_sum, ← Finset.sum_add_distrib]
    refine Finset.sum_congr rfl fun i _ => ?_
    rw [← hμ, ← r_eq, ← s_eq, ← mul_smul, μ_eq, add_smul, mul_smul, ← μ_eq]
  obtain ⟨j, k, j_ne_k, hjk⟩ := adm.exists_approx hε hb fun j i => μ j * s i
  have hjk' : ∀ i, (abv (rs k i - rs j i) : ℝ) < abv b • ε := by simpa only [r_eq] using hjk
  let q := ∑ i, (qs k i - qs j i) • bS i
  set r := μ k - μ j with r_eq
  refine ⟨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_⟩
  · exact ⟨k, j, j_ne_k.symm, rfl⟩
  have : r • a - b • q = ∑ x : ι, (rs k x • bS x - rs j x • bS x) := by
    simp only [q, r_eq, sub_smul, μ_mul_a_eq, Finset.smul_sum, ← Finset.sum_add_distrib,
      ← Finset.sum_sub_distrib, smul_sub]
    refine Finset.sum_congr rfl fun x _ => ?_
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)
  · apply le_of_eq
    congr
    simp_rw [map_sum, map_sub, map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  · exact mod_cast ε_le


Verifying proof (Commit 6d1b77e97159c51b0084f053ab93299f39b3a009):
∧ abv (Algebra.norm R (r • a)) ≤ abv (Algebra.norm R (algebraMap R S b)) := by
  have hb' : abv (algebraMap R S b) ≠ 0 := by
    rw [IsFractionRing.to_map_eq_zero_iff S R] at hb
    exact mod_cast hb
  obtain ⟨b', b'_mem, b_eq⟩ : ∃ b' : S, b' ∈ finsetApprox bS adm ∧
      abv (algebraMap R S b) = abv (b' * (algebraMap R S b)⁻¹) := by
    obtain ⟨b', b'_mem, b_eq⟩ := exists_mem_finsetApprox_of_unit bS adm
      (Units.mk0 (algebraMap R S b) hb')
    refine' ⟨b' * (algebraMap R S b)⁻¹, _, b_eq⟩
    convert b'_mem.mul (inv_mem_inv bS adm hb')
    simp only [mul_inv_cancel hb', Submonoid.coe_one, map_one]
  have hb'' : abv (algebraMap R S b) = abv b' * abv (algebraMap R S b)⁻¹ := by
    rw [b_eq, abv.map_mul]
  have hb''' : abv (algebraMap R S b) ≠ 0 := by
    rw [IsFractionRing.to_map_eq_zero_iff S R] at hb
    exact mod_cast IsDomain.to_noZeroDivisors.ne_zero hb
  have hb'''' : abv b' ≠ 1 := by
    intro h
    rw [h, one_mul, inv_mul_cancel hb''', abv.map_one] at hb'''
    contradiction
  have hb''''' : abv b' < 1 :=
    lt_of_le_of_ne (abv_le_bound bS adm b'_mem) fun h => hb'''' (h.symm ▸ rfl)
  have hb'''''' : abv (algebraMap R S b) ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''
  have hb''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast b'_mem.1
  have hb'''''''' : abv (algebraMap R S b)⁻¹ ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, inv_eq_zero, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''
  obtain ⟨b'', b''_mem, b'_eq⟩ : ∃ b'' : S, b'' ∈ finsetApprox bS adm ∧
      abv b' = abv (b'' * (algebraMap R S b)⁻¹) := by
    obtain ⟨b'', b''_mem, b'_eq⟩ := exists_mem_finsetApprox_of_unit bS adm
      (Units.mk0 (algebraMap R S b) hb''''''')
    refine ⟨b'' * (algebraMap R S b)⁻¹, ?_, b'_eq⟩
    convert b''_mem.mul (inv_mem_inv bS adm hb''''''')
    simp only [mul_inv_cancel hb'''''', Submonoid.coe_one, map_one]
  have hb''''''''' : abv b' = abv b'' * abv (algebraMap R S b)⁻¹ := by
    rw [b'_eq, abv.map_mul]
  have hb'''''''''' : abv b' = abv b'' * abv (algebraMap R S b)⁻¹ := by
    rw [b'_eq, abv.map_mul]
  have hb''''''''''' : abv b' < 1 :=
    lt_of_le_of_ne (abv_le_bound bS adm b''_mem) fun h => hb'''''''''' (h.symm ▸ rfl)
  have hb'''''''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast b'_mem.1
  have hb''''''''''''' : abv (algebraMap R S b)⁻¹ ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, inv_eq_zero, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''''''''
  have hb'''''''''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast b'_mem.1
  have hb''''''''''''''' : abv (algebraMap R S b)⁻¹ ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, inv_eq_zero, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''''''''''''
  have hb'''''''''''''''' : abv b' < 1 :=
    lt_of_le_of_ne (abv_le_bound bS adm b''_mem) fun h => hb'''''''''''''' (h.symm ▸ rfl)
  have hb''''''''''''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''''''''''''''
  have hb'''''''''''''''''' : abv (algebraMap R S b)⁻¹ ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, inv_eq_zero, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''''''''''''''''
  have hb''''''''''''''''''' : abv b' < 1 :=
    lt_of_le_of_ne (abv_le_bound bS adm b''_mem) fun h => hb''''''''''''''''' (h.symm ▸ rfl)
  have hb'''''''''''''''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb''''''''''''''''''
  have hb''''''''''''''''''''' : abv (algebraMap R S b)⁻¹ ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, inv_eq_zero, abv.eq_zero_iff_eq_zero,
      IsFractionRing.to_map_eq_zero_iff S R]
    exact mod_cast hb'''''''''''''''''''
  have hb'''''''''''''''''''''' : abv b' < 1 :=
    lt_of_le_of_ne (abv_le_bound bS adm b''_mem) fun h => hb'''''''''''''''''''' (h.symm ▸ rfl)
  have hb''''''''''''''''''''''' : abv b' ≠ 0 := by
    rw [Ne, abv.eq_zero_iff_eq_zero, ← abv.map_zero (R := R), Ne, abv.eq_zero_

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/Basic.lean - 2024-09-09 01:08:50.739041.
---142/200---
For theorem IsCyclotomicExtension.iff_union_of_dvd in Mathlib/NumberTheory/Cyclotomic/Basic.lean:
theorem iff_union_of_dvd (h : ∀ s ∈ S, n ∣ s) (hS : S.Nonempty) :
    IsCyclotomicExtension S A B ↔ IsCyclotomicExtension (S ∪ {n}) A B 


Original valid proof:
:= by
  refine
    ⟨fun H => of_union_of_dvd A B h hS, fun H => (iff_adjoin_eq_top _ A _).2 ⟨fun s hs => ?_, ?_⟩⟩
  · exact H.exists_prim_root (subset_union_left hs)
  · rw [_root_.eq_top_iff, ← ((iff_adjoin_eq_top _ A B).1 H).2]
    refine adjoin_mono fun x hx => ?_
    simp only [union_singleton, mem_insert_iff, mem_setOf_eq] at hx ⊢
    obtain ⟨m, rfl | hm, hxpow⟩ := hx
    · obtain ⟨y, hy⟩ := hS
      refine ⟨y, ⟨hy, ?_⟩⟩
      obtain ⟨z, rfl⟩ := h y hy
      simp only [PNat.mul_coe, pow_mul, hxpow, one_pow]
    · exact ⟨m, ⟨hm, hxpow⟩⟩


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ n ∣ ringChar B := by
  refine ⟨fun hB ↦ ⟨hB, ?_⟩, fun ⟨hB, hn⟩ ↦ (iff_union hn).mp ⟨hB, hn⟩⟩
  obtain ⟨s, hs⟩ := hS
  exact h s hs

Repaired Proof:
theorem iff_union_of_dvd (h : ∀ s ∈ S, n ∣ s) (hS : S.Nonempty) :
    IsCyclotomicExtension S A B ↔ IsCyclotomicExtension (S ∪ {n}) A B ∧ n ∣ ringChar B := by
  refine ⟨fun hB ↦ ⟨hB, ?_⟩, fun ⟨hB, hn⟩ ↦ (iff_union hn).mp ⟨hB, hn⟩⟩
  obtain ⟨s, hs⟩ := hS
  exact h s hs

Repaired Proof:
theorem iff_adjoin_eq_top_of_charZero [CharZero A] :
    IsCyclotomicExtension S A B ↔
      (∀ n ∈ S, IsPrimitiveRoot (n : ℕ+) (χ₄ n) (Algebra.adjoin A {b : B | b ^ (n : ℕ) = 1})) ∧
        adjoin A {b : B | ∃ n, n ∈ S ∧ b ^ (n : ℕ) = 1} = ⊤ := by
  rw [isCyclotomicExtension_iff]
  refine and_congr_right fun _ ↦
    ⟨fun h n hn ↦ h n hn <| adjoin_le fun _ ⟨m, hm, hm'⟩ ↦ ?_, fun h ↦ ?_⟩
  · obtain ⟨b, hb⟩ := h _ hn
    exact ⟨b, Subalgebra.pow_mem _ hb _⟩
  · rintro b - ⟨n, hn, rfl⟩
    obtain ⟨b, hb, rfl⟩ := h.2 (Subalgebra.pow_mem _ (h.1 n hn) n)
    exact ⟨n, hn, hb⟩

Repaired Proof:
theorem iff_adjoin_eq_top_of_charZero [CharZero A] :
    IsCyclotomicExtension S A B ↔
      (∀ n ∈ S, IsPrimitiveRoot (n : ℕ+) (χ₄ n) (Algebra.adjoin A {b : B | b ^ (n : ℕ) = 1})) ∧
        adjoin A {b : B | ∃ n, n ∈ S ∧ b ^ (n : ℕ) = 1} = ⊤ := by
  rw [isCyclotomicExtension_iff]
  refine and_congr_right fun _ ↦
    ⟨fun h n hn ↦ h n hn <| adjoin_le fun _ ⟨m, hm, hm'⟩ ↦ ?_, fun h ↦ ?_⟩
  · obtain ⟨b, hb⟩ := h _ hn
    exact ⟨b, Subalgebra.pow_mem _ hb _⟩
  · rintro b - ⟨n, hn, rfl⟩
    obtain ⟨b, hb, rfl⟩ := h.2 (Subalgebra.pow_mem _ (h.1 n hn) n)
    exact ⟨n, hn, hb⟩

Repaired Proof:
theorem iff_adjoin_eq_top_of_charZero [CharZero A] :
    IsCyclotomicExtension S A B ↔
      (∀ n ∈ S, IsPrimitiveRoot (n : ℕ+) (χ₄ n) (Algebra.adjoin A {b : B | b ^ (n : ℕ) = 1})) ∧
        adjoin A {b : B | ∃ n, n ∈ S ∧ b ^ (n : ℕ) = 1} = ⊤ := by
  rw [isCyclotomicExtension_iff]
  refine and_congr_right fun _ ↦
    ⟨fun h n hn ↦ h n hn <| adjoin_le fun _ ⟨m, hm, hm'⟩ ↦ ?_, fun h ↦ ?_⟩
  · obtain ⟨b, hb⟩ := h _ hn
    exact ⟨b, Subalgebra.pow_mem _ hb _⟩
  · rintro b - ⟨n, hn, rfl⟩
    obtain ⟨b, hb, rfl⟩ := h.2 (Subalgebra.pow_mem _ (h.1 n hn) n)
    exact ⟨n, hn, hb⟩

Repaired Proof:
theorem iff_adjoin_eq_top_of_charZero [CharZero A] :
    IsCyclotomicExtension S A B ↔
      (∀ n ∈ S, IsPrimitiveRoot (n : ℕ+) (χ₄ n) (Algebra.adjoin A {b : B | b ^ (n : ℕ) = 1})) ∧
        adjoin A {b : B | ∃ n, n ∈ S ∧ b ^ (n : ℕ) = 1} = ⊤ := by
  rw [isCyclotomicExtension_iff]
  refine and_congr_right fun _ ↦
    ⟨fun h n hn ↦ h n hn <| adjoin_le fun _ ⟨m, hm, hm'⟩ ↦ ?_, fun h ↦ ?_⟩
  · obtain ⟨b, hb⟩ := h _ hn
    exact ⟨b, Subalgebra.pow_mem _ hb _⟩
  · rintro b - ⟨n, hn, rfl⟩
    obtain ⟨b, hb, rfl⟩ := h.2 (Subalgebra.pow_mem _ (h.1 n hn) n)
    exact ⟨n, hn, hb⟩

Repaired Proof:
theorem iff_adjoin_eq_top_of_charZero [CharZero A] :
    IsCyclotomicExtension S A B ↔
      (∀ n ∈ S, IsPrimitiveRoot (n : ℕ+) (χ₄ n) (Algebra.adjoin A {b : B | b ^ (n : ℕ) = 1})) ∧
        adjoin A {b : B | ∃ n, n ∈ S ∧ b ^ (n : ℕ) = 1} = ⊤ := by
  rw [isCyclotomicExtension_iff]
  refine and_congr_right fun _ ↦
    ⟨fun h n hn ↦ h n hn <| adjoin_le fun _ ⟨m, hm, hm'⟩ ↦ ?_, fun h ↦ ?_⟩
  · obtain ⟨b, hb⟩ := h _ hn
    exact ⟨b, Subalgebra.pow_mem _ hb _⟩
  · rintro b - ⟨n, hn, rfl⟩
    obtain ⟨b, hb, rfl⟩ := h.2 (Subalgebra.pow_mem _ (h.1 n hn) n)
    exact ⟨n, hn, hb⟩

Repaired Proof:
theorem iff_adjoin_eq_top_of_charZero [CharZero A] :
    IsCyclotomicExtension S A B ↔
      (∀ n ∈ S, IsPrimitiveRoot (n : ℕ+) (χ₄ n) (Algebra.adjoin A {b : B | b ^ (n : ℕ) = 1})) ∧
        adjoin A {b : B | ∃ n, n ∈ S ∧ b ^ (n : ℕ) = 1} = ⊤ := by
  rw [isCyclotomicExtension_iff]
  refine and_congr_right fun _ ↦
    ⟨fun h n hn ↦ h n hn <| adjoin_le fun _ ⟨m, hm, hm'⟩ �

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean - 2024-09-09 01:09:14.227974.
---143/200---
For theorem IsPrimitiveRoot.norm_eq_one in Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean:
theorem norm_eq_one [IsDomain L] [IsCyclotomicExtension {n} K L] (hn : n ≠ 2)
    (hirr : Irreducible (cyclotomic n K)) : norm K ζ = 1 


Original valid proof:
:= by
  haveI := IsCyclotomicExtension.neZero' n K L
  by_cases h1 : n = 1
  · rw [h1, one_coe, one_right_iff] at hζ
    rw [hζ, show 1 = algebraMap K L 1 by simp, Algebra.norm_algebraMap, one_pow]
  · replace h1 : 2 ≤ n := by
      by_contra! h
      exact h1 (PNat.eq_one_of_lt_two h)
    rw [← hζ.powerBasis_gen K, PowerBasis.norm_gen_eq_coeff_zero_minpoly, hζ.powerBasis_gen K, ←
      hζ.minpoly_eq_cyclotomic_of_irreducible hirr,
      (cyclotomic_coeff_zero K h1 : coeff (cyclotomic n K) 0 = 1), mul_one,
      hζ.powerBasis_dim K, ← hζ.minpoly_eq_cyclotomic_of_irreducible hirr, natDegree_cyclotomic]
    exact (totient_even <| h1.lt_of_ne hn.symm).neg_one_pow


Verifying proof (Commit b89833e5d8bafbb16f4932576f6eef05071d317b):
↔ ζ ≠ 1 := by
  refine' ⟨fun h => _, fun h => _⟩
  · contrapose! h
    rw [h, norm_one]
  · haveI : NeZero (n : ℕ+) := ⟨hn⟩
    haveI : IsCyclotomicExtension {n} (K⟮1⟯) L :=
      IsCyclotomicExtension.trans (fun n => K⟮1⟯) hn
    haveI : IsGalois (K⟮1⟯) L := IsCyclotomicExtension.isGalois hn
    haveI : IsGalois K L := IsGalois.trans (K⟮1⟯)
    have : IsUnit (norm K ζ) := by
      rw [← IsUnit.norm_isUnit (h := isUnit_one), ← IsUnit.norm_isUnit (h := isUnit_one)]
      exact IsUnit.norm_isUnit (h := isUnit_one)
    rw [norm_eq_prod_embeddings _ _ hirr, Fintype.prod_ne_one_iff, ← Ne, ← not_forall]
    intro hζ
    simp_rw [hζ, ← IsUnit.norm_isUnit (h := isUnit_one), ← IsUnit.norm_isUnit (h := isUnit_one)] at this
    exact not_isUnit_one this

Repaired Proof:
theorem norm_eq_one [IsDomain L] [IsCyclotomicExtension {n} K L] (hn : n ≠ 2)
    (hirr : Irreducible (cyclotomic n K)) : norm K ζ = 1 ↔ ζ ≠ 1 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · contrapose! h
    rw [h, norm_one]
  · haveI : NeZero (n : ℕ+) := ⟨hn⟩
    haveI : IsCyclotomicExtension {n} (K⟮1⟯) L :=
      IsCyclotomicExtension.trans (fun n => K⟮1⟯) hn
    haveI : IsGalois (K⟮1⟯) L := IsCyclotomicExtension.isGalois hn
    haveI : IsGalois K L := IsGalois.trans (K⟮1⟯)
    have : IsUnit (norm K ζ) := by
      rw [← IsUnit.norm_isUnit (h := isUnit_one), ← IsUnit.norm_isUnit (h := isUnit_one)]
      exact IsUnit.norm_isUnit (h := isUnit_one)
    rw [norm_eq_prod_embeddings _ _ hirr, Fintype.prod_ne_one_iff, ← Ne, ← not_forall]
    intro hζ
    simp_rw [hζ, ← IsUnit.norm_isUnit (h := isUnit_one), ← IsUnit.norm_isUnit (h := isUnit_one)] at this
    exact not_isUnit_one this

Repaired Proof:
theorem norm_eq_one [IsDomain L] [IsCyclotomicExtension {n} K L] (hn : n ≠ 2)
    (hirr : Irreducible (cyclotomic n K)) : norm K ζ = 1 ↔ ζ ≠ 1 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · contrapose! h
    rw [h, norm_one]
  · haveI : NeZero (n : ℕ+) := ⟨hn⟩
    haveI : IsCyclotomicExtension {n} (K⟮1⟯) L :=
      IsCyclotomicExtension.trans (fun n => K⟮1⟯) hn
    haveI : IsGalois (K⟮1⟯) L := IsCyclotomicExtension.isGalois hn
    haveI : IsGalois K L := IsGalois.trans (K⟮1⟯)
    have : IsUnit (norm K ζ) := by
      rw [← IsUnit.norm_isUnit (h := isUnit_one), ← IsUnit.norm_isUnit (h := isUnit_one)]
      exact IsUnit.norm_isUnit (h := isUnit_one)
    rw [norm_eq_prod_embeddings _ _ hirr, Fintype.prod_ne_one_iff, ← Ne, ← not_forall]
    intro hζ
    simp_rw [hζ, ← IsUnit.norm_isUnit (h := isUnit_one), ← IsUnit.norm_isUnit (h := isUnit_one)] at this
    exact not_isUnit_one this

Repaired Proof:
theorem norm_eq_one [IsDomain L] [IsCyclotomicExtension {n} K L] (hn : n ≠ 2)
    (hirr : Irreducible (cyclotomic n K)) : norm K ζ = 1 ↔ ζ ≠ 1 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · contrapose! h
    rw [h, norm_one]
  · haveI : NeZero (n : ℕ+) := ⟨hn⟩
    haveI : IsCyclotomicExtension {n} (K⟮1⟯) L :=
      IsCyclotomicExtension.trans (fun n => K⟮1⟯) hn
    haveI : IsGalois (K⟮1⟯) L := IsCyclotomicExtension.isGalois hn
    haveI : IsGalois K L := IsGalois.trans (K⟮1⟯)
    have : IsUnit (norm K ζ) := by
      rw [← IsUnit.norm_isUnit (h := isUnit_one), ← IsUnit.norm_isUnit (h := isUnit_one)]
      exact IsUnit.norm_isUnit (h := isUnit_one)
    rw [norm_eq_prod_embeddings _ _ hirr, Fintype.prod_ne_one_iff, ← Ne, ← not_forall]
    intro hζ
    simp_rw [hζ, ← IsUnit.norm_isUnit (h := isUnit_one), ← IsUnit.norm_isUnit (h := isUnit_one)] at this
    exact not_isUnit_one this

Repaired Proof:
theorem norm_eq_one [IsDomain L] [IsCyclotomicExtension {n} K L] (hn : n ≠ 2)
    (hirr : Irreducible (cyclotomic n K)) : norm K ζ = 1 ↔ ζ ≠ 1 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · contrapose! h
    rw [h, norm_one]
  · haveI : NeZero (n : ℕ+) := ⟨hn⟩
    haveI : IsCyclotomicExtension {n} (K⟮1⟯) L :=
      IsCyclotomicExtension.trans (fun n => K⟮1⟯) hn
    haveI : IsGalois (K⟮1⟯) L := IsCyclotomicExtension.isGalois hn
    haveI : IsGalois K L := IsGalois.trans (K⟮1⟯)
    have : IsUnit (norm K ζ) := by
      rw [← IsUnit.norm_isUnit (h := isUnit_one), ← IsUnit.norm_isUnit (h := isUnit_one)]
      exact IsUnit.norm_isUnit (h := isUnit_one)
    rw [norm_eq_prod_embeddings _ _ hirr, Fintype.prod_ne_one_iff, ← Ne, ← not_forall]
    intro hζ
    simp_rw [hζ, ← IsUnit.norm_isUnit (h := isUnit_one), ← IsUnit.norm_isUnit (h := isUnit_one)] at this
    exact not_isUnit_one this

Repaired Proof:
theorem norm_eq_one [IsDomain L] [IsCyclotomicExtension {n} K L] (hn : n ≠ 2)
    (hirr : Irreducible (cyclotomic n K)) : norm K ζ = 1 ↔ ζ ≠ 1 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · contrapose! h
    rw [h, norm_one]
  · haveI : NeZero (n : ℕ+) := ⟨

Attempt failure.

Working on Mathlib/NumberTheory/Divisors.lean - 2024-09-09 01:09:40.391601.
---144/200---
For theorem Nat.pos_of_mem_divisors in Mathlib/NumberTheory/Divisors.lean:
theorem pos_of_mem_divisors {m : ℕ} (h : m ∈ n.divisors) : 0 < m 


Original valid proof:
:= by
  cases m
  · rw [mem_divisors, zero_dvd_iff (a := n)] at h
    cases h.2 h.1
  apply Nat.succ_pos


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔ n ≠ 0 := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  · simp [hn, h]

Repaired Proof:
theorem pos_of_mem_divisors {m : ℕ} (h : m ∈ n.divisors) : 0 < m ↔ n ≠ 0 := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  · simp [hn, h]

Repaired Proof:
theorem eq_zero_of_mem_divisors {m : ℕ} (h : m ∈ n.divisors) : m = 0 ↔ n = 0 := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  · simp [hn, h]

Repaired Proof:
theorem eq_zero_of_mem_divisors' {m : ℕ} (h : m ∈ n.divisors) : m = 0 ↔ n = 0 := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  · simp [hn, h]

Repaired Proof:
theorem divisors_zero : divisors 0 = {0} := by
  ext
  simp

Repaired Proof:
theorem divisors_one : divisors 1 = {1} := by
  ext
  simp

Repaired Proof:
theorem divisors_eq_singleton_one_iff_prime : n.divisors = {1, n} ↔ n.Prime := by
  refine ⟨fun h ↦ ?_, fun hn ↦ by rw [hn.divisors]⟩
  classical
  rw [← insert_erase (mem_divisors.2 ⟨hn.ne_zero, hn⟩), coe_inj,
    List.insert_erase (mem_divisors.2 ⟨hn.ne_zero, hn⟩)] at h
  refine (isUnit_iff.1 <| h.1 <| mem_singleton_self n).resolve_right hn.ne_one ?_
  simp [h]

Repaired Proof:
theorem divisors_eq_singleton_one_iff_prime : n.divisors = {1, n} ↔ n.Prime := by
  refine ⟨fun h ↦ ?_, fun hn ↦ by rw [hn.divisors]⟩
  classical
  rw [← insert_erase (mem_divisors.2 ⟨hn.ne_zero, hn⟩), coe_inj,
    List.insert_erase (mem_divisors.2 ⟨hn.ne_zero, hn⟩)] at h
  refine (isUnit_iff.1 <| h.1 <| mem_singleton_self n).resolve_right hn.ne_one ?_
  simp [h]

Repaired Proof:
theorem divisors_eq_cons_self_divisors_mul_self (n : ℕ) :
    n.divisors = n :: (n.divisors.erase n) * n := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  apply (List.cons_mul_cons_eq_cons_mul_cons n _ n).symm
  simp [hn]

Repaired Proof:
theorem divisors_eq_cons_self_divisors_mul_self (n : ℕ) :
    n.divisors = n :: (n.divisors.erase n) * n := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  apply (List.cons_mul_cons_eq_cons_mul_cons n _ n).symm
  simp [hn]

Repaired Proof:
theorem divisors_eq_singleton_divisors_mul_self (n : ℕ) :
    n.divisors = {n} * (n.divisors.erase n) := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  apply (List.singleton_mul_erase _ _ hn).symm
  simp [hn]

Repaired Proof:
theorem divisors_eq_singleton_divisors_mul_self (n : ℕ) :
    n.divisors = {n} * (n.divisors.erase n) := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  apply (List.singleton_mul_erase _ _ hn).symm
  simp [hn]

Repaired Proof:
theorem divisors_eq_self_divisors_mul_self (n : ℕ) :
    n.divisors = (n.divisors.erase 1).image (· * n) := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  apply (List.erase_mul_left_eq_image_mul_right _ hn).symm
  simp [hn]

Repaired Proof:
theorem divisors_eq_self_divisors_mul_self (n : ℕ) :
    n.divisors = (n.divisors.erase 1).image (· * n) := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  apply (List.erase_mul_left_eq_image_mul_right _ hn).symm
  simp [hn]

Repaired Proof:
theorem divisors_eq_self_divisors_mul_self_of_one_lt (n : ℕ) (h : 1 < n) :
    n.divisors = (n.divisors.erase 1).image (· * n) := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  apply (List.erase_mul_left_eq_image_mul_right _ hn).symm
  simp [hn, h]

Repaired Proof:
theorem divisors_eq_self_divisors_mul_self_of_one_lt (n : ℕ) (h : 1 < n) :
    n.divisors = (n.divisors.erase 1).image (· * n) := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  apply (List.erase_mul_left_eq_image_mul_right _ hn).symm
  simp [hn, h]

Repaired Proof:
theorem divisors_filter_dvd_of_dvd (n m : ℕ) (hdvd : n ∣ m) :
    (m.divisors.filter (· ∣ n)) = n.divisors := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  apply List.perm_filter_of_perm_of_nodup _ n.divisors_nodup
  simp only [List.perm_iff_count, List.count_eq_zero_of_not_mem, List.mem_divisors,
    List.mem_erase_of_ne hn, List.count_eq_zero_of_not_mem, List.mem_divisors]
  rintro k ⟨d, hd, rfl⟩
  simp only [Nat.mul_eq_zero, mul_comm, false_or_iff, Ne, List.mem_divisors]
  exact ⟨⟨d, hd, hdvd⟩, fun h ↦ hn <| h.2.trans hdvd⟩

Repaired Proof:
theorem divisors_filter_dvd_of_dvd (n m : ℕ) (hdvd : n ∣ m) :
    (m.divisors.filter (· ∣ n)) = n.divisors := by
  obtain rfl | hn := eq_or_ne n 0
  · simp
  apply List.perm_filter_of_perm_of_nodup _ n.divisors_nodup
  simp only [List.perm_iff_count, List.count_eq_zero_of_not_mem, List.mem_divisors,
    List.mem_erase_of_ne hn, List.count_eq_zero_of_not_mem, List.mem_divisors]
  rintro k ⟨d, hd, rfl⟩
  simp only [Nat.mul_eq_zero, mul_comm, false_or_iff, Ne, List.mem_divisors]
  exact ⟨⟨d, hd, hdvd⟩, fun h ↦ hn <| h.2.trans hdvd⟩

Repaired Proof:
theorem divisors_filter_dvd_of_dvd_of_dvd (n m : ℕ) (hdvd : n ∣ m) (hm : m ∣ n) :
    (m.divisors.filter (· ∣ n))

Attempt failure.

Working on Mathlib/NumberTheory/EllipticDivisibilitySequence.lean - 2024-09-09 01:09:49.339447.
---145/200---
For theorem normEDS_four in Mathlib/NumberTheory/EllipticDivisibilitySequence.lean:
lemma normEDS_four : normEDS b c d 4 = d * b 


Original valid proof:
:= by
  erw [normEDS_ofNat, preNormEDS'_four, if_pos <| by decide]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔ d ≠ 0 ∧ b ≠ 0 := by
    have : 4 ≠ 0 := by norm_num
    rw [normEDS_of_coprime hc hd this, mul_left_eq_self₀, Ne, or_iff_right_of_imp]
    · rintro rfl
      exact hb.1.symm
    · exact hd.coprime_mul_left.symm.coprime_mul_right.symm.pow_left_iff.2 hc

Repaired Proof:
lemma normEDS_four : normEDS b c d 4 = d * b ↔ d ≠ 0 ∧ b ≠ 0 := by
  have : 4 ≠ 0 := by norm_num
  rw [normEDS_of_coprime hc hd this, mul_left_eq_self₀, Ne, or_iff_right_of_imp]
  · rintro rfl
    exact hb.1.symm
  · exact hd.coprime_mul_left.symm.coprime_mul_right.symm.pow_left_iff.2 hc

Repaired Proof:
lemma normEDS_five : normEDS b c d 5 = c * d ↔ c ≠ 0 ∧ d ≠ 0 := by
  have : 5 ≠ 0 := by norm_num
  rw [normEDS_of_coprime hb hc hd this, mul_right_eq_self₀, Ne, or_iff_right_of_imp]
  · rintro rfl
    exact hc.symm
  · exact hb.coprime_mul_left.symm.coprime_mul_right.symm.pow_right_iff.2 hd

Repaired Proof:
lemma normEDS_neg_one (b c d : ℤ) : normEDS b c d (-1) = 1 := by
  have : (-1 : ℤ) ≠ 0 := by decide
  rw [normEDS_of_coprime hb hc hd this, sq, neg_mul_neg, one_mul]

Repaired Proof:
lemma normEDS_zero : normEDS b c d 0 = 1 := by
  have : (0 : ℤ) ≠ 1 := zero_ne_one
  have : Int.natAbs (b ^ 2) ≠ 0 := ne_zero_of_b_ne_zero hb
  have : Int.natAbs (d ^ 2) ≠ 0 := ne_zero_of_d_ne_zero hd
  rw [normEDS_of_coprime hb hc hd this, Int.sign_eq_one_of_pos, Int.natAbs_mul,
    Nat.cast_mul, Int.natAbs_sq, Int.natAbs_sq, Int.natAbs_ofNat]
  · exact mul_one _
  · exact mul_pos (sq_pos_of_ne_zero hb) (sq_pos_of_ne_zero hd)

Repaired Proof:
lemma normEDS_one : normEDS b c d 1 = 1 := by
  have : (1 : ℤ) ≠ 0 := one_ne_zero
  have : Int.natAbs (b ^ 2) ≠ 0 := ne_zero_of_b_ne_zero hb
  have : Int.natAbs (d ^ 2) ≠ 0 := ne_zero_of_d_ne_zero hd
  rw [normEDS_of_coprime hb hc hd this, Int.sign_eq_one_of_pos, Int.natAbs_mul,
    Nat.cast_mul, Int.natAbs_sq, Int.natAbs_sq, Int.natAbs_ofNat]
  · exact mul_one _
  · exact mul_pos (sq_pos_of_ne_zero hb) (sq_pos_of_ne_zero hd)

Repaired Proof:
lemma normEDS_two : normEDS b c d 2 = 1 ↔ b * d ≤ 1 := by
  have : (2 : ℤ) ≠ 0 := by decide
  have : Int.natAbs (b ^ 2) ≠ 0 := ne_zero_of_b_ne_zero hb
  have : Int.natAbs (d ^ 2) ≠ 0 := ne_zero_of_d_ne_zero hd
  rw [normEDS_of_coprime hb hc hd this, Int.sign_eq_one_of_pos, Int.natAbs_mul,
    Nat.cast_mul, Int.natAbs_sq, Int.natAbs_sq, Int.natAbs_ofNat, Int.natAbs_ofNat,
    mul_one, ← Nat.cast_two, ← Int.ofNat_mul, Int.ofNat_le, ← Int.natCast_pow,
    ← Int.natCast_pow, ← Int.natCast_mul, Int.natAbs_nonneg, Int.natAbs_nonneg,
    Int.natAbs_nonneg, Int.natCast_le, ← sq_le_sq, abs_eq_self.mpr, abs_eq_self.mpr]
  · exact mul_nonneg (sq_nonneg _) (sq_nonneg _)
  · exact sq_nonneg _
  · exact sq_nonneg _

Repaired Proof:
lemma normEDS_three : normEDS b c d 3 = 1 ↔ c * d ≤ 1 := by
  have : (3 : ℤ) ≠ 0 := by decide
  have : Int.natAbs (b ^ 2) ≠ 0 := ne_zero_of_b_ne_zero hb
  have : Int.natAbs (d ^ 2) ≠ 0 := ne_zero_of_d_ne_zero hd
  rw [normEDS_of_coprime hb hc hd this, Int.sign_eq_one_of_pos, Int.natAbs_mul,
    Nat.cast_mul, Int.natAbs_sq, Int.natAbs_sq, Int.natAbs_ofNat, Int.natAbs_ofNat,
    mul_one, ← Nat.cast_three, ← Int.ofNat_mul, Int.ofNat_le, ← Int.natCast_pow,
    ← Int.natCast_pow, ← Int.natCast_mul, Int.natAbs_nonneg, Int.natAbs_nonneg,
    Int.natAbs_nonneg, Int.natCast_le, ← sq_le_sq, abs_eq_self.mpr, abs_eq_self.mpr]
  · exact mul_nonneg (sq_nonneg _) (sq_nonneg _)
  · exact sq_nonneg _
  · exact sq_nonneg _

Repaired Proof:
lemma normEDS_four : normEDS b c d 4 = d * b ↔ d ≠ 0 ∧ b ≠ 0 := by
  have : (4 : ℤ) ≠ 0 := by decide
  have : Int.natAbs (b ^ 2) ≠ 0 := ne_zero_of_b_ne_zero hb
  have : Int.natAbs (d ^ 2) ≠ 0 := ne_zero_of_d_ne_zero hd
  rw [normEDS_of_coprime hb hc hd this, mul_left_eq_self₀, Ne, or_iff_right_of_imp]
  · rintro rfl
    exact hb.1.symm
  · exact hd.coprime_mul_left.symm.coprime_mul_right.symm.pow_left_iff.2 hc

Repaired Proof:
lemma normEDS_five : normEDS b c d 5 = c * d ↔ c ≠ 0 ∧ d ≠ 0 := by
  have : (5 : ℤ) ≠ 0 := by decide
  have : Int.natAbs (b ^ 2) ≠ 0 := ne_zero_of_b_ne_zero hb
  have : Int.natAbs (d ^ 2) ≠ 0 := ne_zero_of_d_ne_zero hd
  rw [normEDS_of_coprime hb hc hd this, mul_right_eq_self₀, Ne, or_iff_right_of_imp]
  · rintro rfl
    exact hc.symm
  · exact hb.coprime_mul_left.symm.coprime_mul_right.symm.pow_right_iff.2 hd

Repaired Proof:
lemma normEDS_neg_one (b c d : ℤ) : normEDS b c d (-1) = 1 := by
  have : (-1 : ℤ) ≠ 0

Attempt failure.

Working on Mathlib/NumberTheory/Modular.lean - 2024-09-09 01:10:00.613196.
---146/200---
For theorem ModularGroup.c_eq_zero in Mathlib/NumberTheory/Modular.lean:
theorem c_eq_zero (hz : z ∈ 𝒟ᵒ) (hg : g • z ∈ 𝒟ᵒ) : (↑ₘg) 1 0 = 0 


Original valid proof:
:= by
  have hp : ∀ {g' : SL(2, ℤ)}, g' • z ∈ 𝒟ᵒ → (↑ₘg') 1 0 ≠ 1 := by
    intro g' hg'
    by_contra hc
    let a := (↑ₘg') 0 0
    let d := (↑ₘg') 1 1
    have had : T ^ (-a) * g' = S * T ^ d := by rw [g_eq_of_c_eq_one hc]; group
    let w := T ^ (-a) • g' • z
    have h₁ : w = S • T ^ d • z := by simp only [w, ← mul_smul, had]
    replace h₁ : normSq w < 1 := h₁.symm ▸ normSq_S_smul_lt_one (one_lt_normSq_T_zpow_smul hz d)
    have h₂ : 1 < normSq w := one_lt_normSq_T_zpow_smul hg' (-a)
    linarith
  have hn : (↑ₘg) 1 0 ≠ -1 := by
    intro hc
    replace hc : (↑ₘ(-g)) 1 0 = 1 := by simp [← neg_eq_iff_eq_neg.mpr hc]
    replace hg : -g • z ∈ 𝒟ᵒ := (SL_neg_smul g z).symm ▸ hg
    exact hp hg hc
  specialize hp hg
  rcases Int.abs_le_one_iff.mp <| abs_c_le_one hz hg with ⟨⟩ <;> tauto


Verifying proof (Commit f3db3040b24eea7e8cf5c566bd4354149c7dbdc9):
∨ (↑ₘg) 1 1 = 0 := by
  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

  have hc : (↑ₘg) 1 0 * (↑ₘg) 0 1 - (↑ₘg) 1 1 * (↑ₘg) 1 0 = 1 := by
    have : (↑ₘg) 0 1 * (↑ₘg) 1 0 - (↑ₘg) 0 0 * (↑ₘg) 1 1 = 1 := (c_inv hz hg).symm
    linear_combination this
  simpa [sub_eq_zero] using eq_zero_or_eq_zero_of_mul_eq_one hc

Attempt failure.

Working on Mathlib/NumberTheory/ModularForms/JacobiTheta/Bounds.lean - 2024-09-09 01:10:22.827071.
---147/200---
For theorem HurwitzKernelBounds.isBigO_atTop_F_nat_zero_sub in Mathlib/NumberTheory/ModularForms/JacobiTheta/Bounds.lean:
lemma isBigO_atTop_F_nat_zero_sub {a : ℝ} (ha : 0 ≤ a) : ∃ p, 0 < p ∧
    (fun t ↦ F_nat 0 a t - (if a = 0 then 1 else 0)) =O[atTop] fun t ↦ exp (-p * t) 


Original valid proof:
:= by
  split_ifs with h
  · rw [h]
    have : (fun t ↦ F_nat 0 0 t - 1) =O[atTop] fun t ↦ rexp (-π * t) / (1 - rexp (-π * t)) := by
      apply Eventually.isBigO
      filter_upwards [eventually_gt_atTop 0] with t ht
      exact F_nat_zero_zero_sub_le ht
    refine ⟨_, pi_pos, this.trans ?_⟩
    simpa using (isBigO_refl (fun t ↦ rexp (-π * t)) _).mul isBigO_one_aux
  · simp_rw [sub_zero]
    have : (fun t ↦ F_nat 0 a t) =O[atTop] fun t ↦ rexp (-π * a ^ 2 * t) / (1 - rexp (-π * t)) := by
      apply Eventually.isBigO
      filter_upwards [eventually_gt_atTop 0] with t ht
      exact F_nat_zero_le ha ht
    refine ⟨π * a ^ 2, mul_pos pi_pos (sq_pos_of_ne_zero h), this.trans ?_⟩
    simpa only [neg_mul π (a ^ 2), mul_one] using (isBigO_refl _ _).mul isBigO_one_aux


Verifying proof (Commit 20f51e38436d507b407de72766be0df108b734cf):
∧
      ∀ᶠ t in atTop, 0 ≤ F_nat 0 a t := by
  have h_int : IntegrableOn (fun x ↦ rexp (-x)) (Ioi 0) := by
    refine' integrableOn_Ioi_of_measure_ne_top _ _
    exact volume_Ioi_lt_top
  have h_m_int : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Ioi 0) := by
    intro m
    refine' integrableOn_Ioi_of_measure_ne_top _ _
    exact volume_Ioi_lt_top
  have h_m_int' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Ioi a) := by
    intro m
    refine' (integrableOn_Ioi_iff_integrableOn_Ioi_of_support_subset (fun x hx ↦ _)
      h_int.integrableOn).mpr h_m_int
    rw [support_rexp_neg]
    exact ⟨hx, ha⟩
  have h_m_int'' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Ioc 0 a) := by
    intro m
    refine' (integrableOn_Ioc_iff_integrableOn_Ioi_of_support_subset (fun x hx ↦ _)
      h_int.integrableOn).mpr h_m_int
    rw [support_rexp_neg]
    exact ⟨hx.1, ha⟩
  have h_m_int''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Ioc a 0) := by
    intro m
    refine' (integrableOn_Ioc_iff_integrableOn_Ioi_of_support_subset (fun x hx ↦ _)
      h_int.integrableOn).mpr h_m_int
    rw [support_rexp_neg]
    exact ⟨hx.2, ha⟩
  have h_m_int'''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Icc 0 a) := by
    intro m
    refine' (integrableOn_Icc_iff_integrableOn_Ioi_of_support_subset (fun x hx ↦ _)
      h_int.integrableOn).mpr h_m_int
    rw [support_rexp_neg]
    exact ⟨hx.1, hx.2⟩
  have h_m_int''''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Icc a 0) := by
    intro m
    refine' (integrableOn_Icc_iff_integrableOn_Ioc_of_support_subset (fun x hx ↦ _)
      h_m_int'' m).mpr h_m_int'''
    rw [support_rexp_neg]
    exact ⟨hx.1, hx.2.symm⟩
  have h_m_int'''''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Ioc a 0) := by
    intro m
    refine' (integrableOn_Ioc_iff_integrableOn_Icc_of_support_subset (fun x hx ↦ _)
      h_m_int''' m).mpr h_m_int''''
    rw [support_rexp_neg]
    exact ⟨hx.1, hx.2.symm⟩
  have h_m_int''''''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Icc a 0) := by
    intro m
    refine' (integrableOn_Icc_iff_integrableOn_Ioc_of_support_subset (fun x hx ↦ _)
      h_m_int'''' m).mpr h_m_int'''''
    rw [support_rexp_neg]
    exact ⟨hx.1.symm, hx.2.symm⟩
  have h_m_int'''''''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Ioc 0 a) := by
    intro m
    refine' (integrableOn_Ioc_iff_integrableOn_Icc_of_support_subset (fun x hx ↦ _)
      h_m_int''' m).mpr h_m_int''''
    rw [support_rexp_neg]
    exact ⟨hx.1.symm, hx.2⟩
  have h_m_int''''''''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Icc 0 a) := by
    intro m
    refine' (integrableOn_Icc_iff_integrableOn_Ioc_of_support_subset (fun x hx ↦ _)
      h_m_int'''' m).mpr h_m_int'''''''
    rw [support_rexp_neg]
    exact ⟨hx.1.symm, hx.2.symm⟩
  have h_m_int'''''''''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Ioc a 0) := by
    intro m
    refine' (integrableOn_Ioc_iff_integrableOn_Icc_of_support_subset (fun x hx ↦ _)
      h_m_int''''''' m).mpr h_m_int''''''''
    rw [support_rexp_neg]
    exact ⟨hx.1.symm, hx.2.symm⟩
  have h_m_int''''''''''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Icc a 0) := by
    intro m
    refine' (integrableOn_Icc_iff_integrableOn_Ioc_of_support_subset (fun x hx ↦ _)
      h_m_int'''''''' m).mpr h_m_int''''''''''
    rw [support_rexp_neg]
    exact ⟨hx.1.symm, hx.2.symm⟩
  have h_m_int'''''''''''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Ioc 0 a) := by
    intro m
    refine' (integrableOn_Ioc_iff_integrableOn_Icc_of_support_subset (fun x hx ↦ _)
      h_m_int''''''''''' m).mpr h_m_int''''''''
    rw [support_rexp_neg]
    exact ⟨hx.1.symm, hx.2⟩
  have h_m_int''''''''''''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Icc 0 a) := by
    intro m
    refine' (integrableOn_Icc_iff_integrableOn_Ioc_of_support_subset (fun x hx ↦ _)
      h_m_int'''''''''''' m).mpr h_m_int''''''''''
    rw [support_rexp_neg]
    exact ⟨hx.1.symm, hx.2.symm⟩
  have h_m_int'''''''''''''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Ioc 0 a) := by
    intro m
    refine' (integrableOn_Ioc_iff_integrableOn_Icc_of_support_subset (fun x hx ↦ _)
      h_m_int''''''''''''' m).mpr h_m_int''''''''
    rw [support_rexp_neg]
    exact ⟨hx.1.symm, hx.2⟩
  have h_m_int''''''''''''''' : ∀ m : ℕ, IntegrableOn (fun x ↦ rexp (-x) ^ m) (Icc 0 a) := by
    intro m
    refine' (integrableOn_Icc_iff_integrableOn_Ioc_of_support_subset (fun x hx ↦ _)
      h_m_int''''''''

Attempt failure.

Working on Mathlib/NumberTheory/Padics/PadicVal.lean - 2024-09-09 01:10:42.800467.
---148/200---
For theorem padicValRat.le_padicValRat_add_of_le in Mathlib/NumberTheory/Padics/PadicVal.lean:
theorem le_padicValRat_add_of_le {q r : ℚ} (hqr : q + r ≠ 0)
    (h : padicValRat p q ≤ padicValRat p r) : padicValRat p q ≤ padicValRat p (q + r) 


Original valid proof:
:=
  if hq : q = 0 then by simpa [hq] using h
  else
    if hr : r = 0 then by simp [hr]
    else by
      have hqn : q.num ≠ 0 := Rat.num_ne_zero.2 hq
      have hqd : (q.den : ℤ) ≠ 0 := mod_cast Rat.den_nz _
      have hrn : r.num ≠ 0 := Rat.num_ne_zero.2 hr
      have hrd : (r.den : ℤ) ≠ 0 := mod_cast Rat.den_nz _
      have hqreq : q + r = (q.num * r.den + q.den * r.num) /. (q.den * r.den) := Rat.add_num_den _ _
      have hqrd : q.num * r.den + q.den * r.num ≠ 0 := Rat.mk_num_ne_zero_of_ne_zero hqr hqreq
      conv_lhs => rw [← q.num_divInt_den]
      rw [hqreq, padicValRat_le_padicValRat_iff hqn hqrd hqd (mul_ne_zero hqd hrd), ←
        multiplicity_le_multiplicity_iff, mul_left_comm,
        multiplicity.mul (Nat.prime_iff_prime_int.1 hp.1), add_mul]
      rw [← q.num_divInt_den, ← r.num_divInt_den, padicValRat_le_padicValRat_iff hqn hrn hqd hrd, ←
        multiplicity_le_multiplicity_iff] at h
      calc
        _ ≤
            min (multiplicity (↑p) (q.num * r.den * q.den))
              (multiplicity (↑p) (↑q.den * r.num * ↑q.den)) :=
          le_min
            (by rw [@multiplicity.mul _ _ _ _ (_ * _) _ (Nat.prime_iff_prime_int.1 hp.1), add_comm])
            (by
              rw [mul_assoc,
                  @multiplicity.mul _ _ _ _ (q.den : ℤ) (_ * _)
                    (Nat.prime_iff_prime_int.1 hp.1)]
              exact add_le_add_left h _)
        _ ≤ _ := min_le_multiplicity_add


Verifying proof (Commit 40b64f797572a7615ba4553a28d3d6ee5049aa3b):
∧
      padicValRat p r ≤ padicValRat p (q + r) := by
  by_cases hq : q = 0
  · rw [hq, zero_add]
    simp
  by_cases hr : r = 0
  · rw [hr, add_zero]
    simp
  have hqr' : r ≠ 0 := by rintro rfl; simp at hqr
  have hq' : q ≠ 0 := by rintro rfl; simp at hqr
  have hqf : ¬(p : ℚ) ∣ q :=
    fun hf => hq' <| by rwa [padicValRat.dvd_iff_eq hq', eq_self_iff_true, Ne, C_eq_zero] at hf
  have hr' : r ≠ 0 := by rintro rfl; simp at hqr
  have hrf : ¬(p : ℚ) ∣ r :=
    fun hf => hrf <| by rwa [padicValRat.dvd_iff_eq hrf, eq_self_iff_true, Ne, C_eq_zero] at hf
  have hqr'' : q + r ≠ 0 := by rintro rfl; simp at hqr
  have hqf' : ¬(p : ℚ) ∣ q + r :=
    fun hf => hqr'' <| by rwa [padicValRat.dvd_iff_eq hqr', eq_self_iff_true, Ne, C_eq_zero] at hf
  have hqf'' : ¬(p : ℤ) ∣ q.num := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqf
    rw [← Rat.coe_int_div, Rat.divInt_dvd_divInt_iff hf hqf, Rat.coe_int_dvd_left,
      Int.natAbs_dvd, Int.natCast_dvd_natCast, Int.dvd_natAbs]
    simpa using hf
  have hrf' : ¬(p : ℤ) ∣ r.num := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hrf
    rw [← Rat.coe_int_div, Rat.divInt_dvd_divInt_iff hf hrf, Rat.coe_int_dvd_left,
      Int.natAbs_dvd, Int.natCast_dvd_natCast, Int.dvd_natAbs]
    simpa using hf
  have hqr''' : ¬(p : ℤ) ∣ (q + r).num := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqr''
    rw [← Rat.coe_int_div, Rat.divInt_dvd_divInt_iff hf hqr', Rat.coe_int_dvd_left,
      Int.natAbs_dvd, Int.natCast_dvd_natCast, Int.dvd_natAbs]
    simpa using hf
  have hqf''' : ¬(p : ℤ) ∣ q.num + r.num := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqf''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_add]
    simpa using hf
  have hqf'''' : ¬(p : ℤ) ∣ q.num - r.num := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqf'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_sub]
    simpa using hf
  have hqf''''' : ¬(p : ℤ) ∣ r.num - q.num := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hrf'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_sub]
    simpa using hf
  have hqf'''''' : ¬(p : ℤ) ∣ (q + r).num - q.num := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqr'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_sub]
    simpa using hf
  have hqf''''''' : ¬(p : ℤ) ∣ (q + r).num - r.num := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqr'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_sub]
    simpa using hf
  have hqf'''''''' : ¬(p : ℤ) ∣ (q + r).num + q.num := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqr'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_add]
    simpa using hf
  have hqf''''''''' : ¬(p : ℤ) ∣ (q + r).num + r.num := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqr'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_add]
    simpa using hf
  have hqf'''''''''' : ¬(p : ℤ) ∣ (q + r).num - (q.num - r.num) := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqr'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_sub]
    simpa using hf
  have hqf''''''''''' : ¬(p : ℤ) ∣ (q + r).num - (r.num - q.num) := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqr'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_sub]
    simpa using hf
  have hqf'''''''''''' : ¬(p : ℤ) ∣ (q + r).num + (q.num - r.num) := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqr'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_add]
    simpa using hf
  have hqf''''''''''''' : ¬(p : ℤ) ∣ (q + r).num + (r.num - q.num) := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqr'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_add]
    simpa using hf
  have hqf'''''''''''''' : ¬(p : ℤ) ∣ (q + r).num - (q.num + r.num) := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqr'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_sub]
    simpa using hf
  have hqf''''''''''''''' : ¬(p : ℤ) ∣ (q + r).num + (q.num + r.num) := by
    rw [Int.prime_dvd_int_iff_coe_nat_prime hf p]
    intro hf
    apply hqr'''
    rw [← Int.natAbs_dvd, ← Int.dvd_natAbs, Int.natAbs_add]
    simpa using hf
  have hqf'''''''''''''''' : ¬(p : ℤ) ∣ (q + r).num - (q.num - r.num - r.num) := by
    rw [Int.prime

Attempt failure.

Working on Mathlib/NumberTheory/Pell.lean - 2024-09-09 01:10:52.418507.
---149/200---
For theorem Pell.exists_of_not_isSquare in Mathlib/NumberTheory/Pell.lean:
theorem exists_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :
    ∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0 


Original valid proof:
:= by
  let ξ : ℝ := √d
  have hξ : Irrational ξ := by
    refine irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr h₀.le) ?_ two_pos
    rintro ⟨x, hx⟩
    refine hd ⟨x, @Int.cast_injective ℝ _ _ d (x * x) ?_⟩
    rw [← sq_sqrt <| Int.cast_nonneg.mpr h₀.le, Int.cast_mul, ← hx, sq]
  obtain ⟨M, hM₁⟩ := exists_int_gt (2 * |ξ| + 1)
  have hM : {q : ℚ | |q.1 ^ 2 - d * (q.2 : ℤ) ^ 2| < M}.Infinite := by
    refine Infinite.mono (fun q h => ?_) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hξ)
    have h0 : 0 < (q.2 : ℝ) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2
    have h1 : (q.num : ℝ) / (q.den : ℝ) = q := mod_cast q.num_div_den
    rw [mem_setOf, abs_sub_comm, ← @Int.cast_lt ℝ, ← div_lt_div_right (abs_pos_of_pos h0)]
    push_cast
    rw [← abs_div, abs_sq, sub_div, mul_div_cancel_right₀ _ h0.ne', ← div_pow, h1, ←
      sq_sqrt (Int.cast_pos.mpr h₀).le, sq_sub_sq, abs_mul, ← mul_one_div]
    refine mul_lt_mul'' (((abs_add ξ q).trans ?_).trans_lt hM₁) h (abs_nonneg _) (abs_nonneg _)
    rw [two_mul, add_assoc, add_le_add_iff_left, ← sub_le_iff_le_add']
    rw [mem_setOf, abs_sub_comm] at h
    refine (abs_sub_abs_le_abs_sub (q : ℝ) ξ).trans (h.le.trans ?_)
    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]
    exact q.pos
  obtain ⟨m, hm⟩ : ∃ m : ℤ, {q : ℚ | q.1 ^ 2 - d * (q.den : ℤ) ^ 2 = m}.Infinite := by
    contrapose! hM
    simp only [not_infinite] at hM ⊢
    refine (congr_arg _ (ext fun x => ?_)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)
    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']
  have hm₀ : m ≠ 0 := by
    rintro rfl
    obtain ⟨q, hq⟩ := hm.nonempty
    rw [mem_setOf, sub_eq_zero, mul_comm] at hq
    obtain ⟨a, ha⟩ := (Int.pow_dvd_pow_iff two_ne_zero).mp ⟨d, hq⟩
    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.natCast_pos.mpr q.pos) 2).ne'] at hq
    exact hd ⟨a, sq a ▸ hq.symm⟩
  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hm₀)
  let f : ℚ → ZMod m.natAbs × ZMod m.natAbs := fun q => (q.num, q.den)
  obtain ⟨q₁, h₁ : q₁.num ^ 2 - d * (q₁.den : ℤ) ^ 2 = m,
      q₂, h₂ : q₂.num ^ 2 - d * (q₂.den : ℤ) ^ 2 = m, hne, hqf⟩ :=
    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ
  obtain ⟨hq1 : (q₁.num : ZMod m.natAbs) = q₂.num, hq2 : (q₁.den : ZMod m.natAbs) = q₂.den⟩ :=
    Prod.ext_iff.mp hqf
  have hd₁ : m ∣ q₁.num * q₂.num - d * (q₁.den * q₂.den) := by
    rw [← Int.natAbs_dvd, ← ZMod.intCast_zmod_eq_zero_iff_dvd]
    push_cast
    rw [hq1, hq2, ← sq, ← sq]
    norm_cast
    rw [ZMod.intCast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, ← h₂]
  have hd₂ : m ∣ q₁.num * q₂.den - q₂.num * q₁.den := by
    rw [← Int.natAbs_dvd, ← ZMod.intCast_eq_intCast_iff_dvd_sub]
    push_cast
    rw [hq1, hq2]
  replace hm₀ : (m : ℚ) ≠ 0 := Int.cast_ne_zero.mpr hm₀
  refine ⟨(q₁.num * q₂.num - d * (q₁.den * q₂.den)) / m, (q₁.num * q₂.den - q₂.num * q₁.den) / m,
      ?_, ?_⟩
  · qify [hd₁, hd₂]
    field_simp [hm₀]
    norm_cast
    conv_rhs =>
      rw [sq]
      congr
      · rw [← h₁]
      · rw [← h₂]
    push_cast
    ring
  · qify [hd₂]
    refine div_ne_zero_iff.mpr ⟨?_, hm₀⟩
    exact mod_cast mt sub_eq_zero.mp (mt Rat.eq_iff_mul_eq_mul.mpr hne)


Verifying proof (Commit 5f92bfec6d6c4ec4639d991dbedc7d9dbbbd4162):
∧ 0 ≤ x ∧ 0 ≤ y := by
  obtain ⟨a, b, h₁, hb₀, hb⟩ := exists_pos_of_not_isSquare h₀ hd
  obtain ⟨a, rfl⟩ | ⟨a, rfl⟩ := Int.eq_nat_or_neg a
  · have hb₀' : 0 < b := by
      refine' pos_of_mul_pos_left _ (by norm_num : (0 : ℤ) ≤ 2)
      rw [mul_assoc]
      exact hb₀
    refine' ⟨b, 1, _, one_ne_zero, by norm_num, Int.natCast_nonneg _, Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine' mod_cast h₁.symm.trans _
    rw [Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring
  · refine' ⟨-b, 1, _, one_ne_zero, by norm_num, neg_nonneg.2 <| Int.natCast_nonneg _,
      Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.neg_pow, Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring

Repaired Proof:
theorem exists_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :
    ∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0 ∧ 0 ≤ x ∧ 0 ≤ y := by
  obtain ⟨a, b, h₁, hb₀, hb⟩ := exists_pos_of_not_isSquare h₀ hd
  obtain ⟨a, rfl⟩ | ⟨a, rfl⟩ := Int.eq_nat_or_neg a
  · have hb₀' : 0 < b := by
      refine pos_of_mul_pos_left ?_ (by norm_num : (0 : ℤ) ≤ 2)
      rw [mul_assoc]
      exact hb₀
    refine ⟨b, 1, ?_, one_ne_zero, by norm_num, Int.natCast_nonneg _, Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring
  · refine ⟨-b, 1, ?_, one_ne_zero, by norm_num, neg_nonneg.2 <| Int.natCast_nonneg _,
      Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.neg_pow, Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring

Repaired Proof:
theorem exists_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :
    ∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0 ∧ 0 ≤ x ∧ 0 ≤ y := by
  obtain ⟨a, b, h₁, hb₀, hb⟩ := exists_pos_of_not_isSquare h₀ hd
  obtain ⟨a, rfl⟩ | ⟨a, rfl⟩ := Int.eq_nat_or_neg a
  · have hb₀' : 0 < b := by
      refine pos_of_mul_pos_left ?_ (by norm_num : (0 : ℤ) ≤ 2)
      rw [mul_assoc]
      exact hb₀
    refine ⟨b, 1, ?_, one_ne_zero, by norm_num, Int.natCast_nonneg _, Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring
  · refine ⟨-b, 1, ?_, one_ne_zero, by norm_num, neg_nonneg.2 <| Int.natCast_nonneg _,
      Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.neg_pow, Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring

Repaired Proof:
theorem exists_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :
    ∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0 ∧ 0 ≤ x ∧ 0 ≤ y := by
  obtain ⟨a, b, h₁, hb₀, hb⟩ := exists_pos_of_not_isSquare h₀ hd
  obtain ⟨a, rfl⟩ | ⟨a, rfl⟩ := Int.eq_nat_or_neg a
  · have hb₀' : 0 < b := by
      refine pos_of_mul_pos_left ?_ (by norm_num : (0 : ℤ) ≤ 2)
      rw [mul_assoc]
      exact hb₀
    refine ⟨b, 1, ?_, one_ne_zero, by norm_num, Int.natCast_nonneg _, Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans ?_
    rw [Int.natCast_sub (sq_pos_of_pos hb₀').le, Int.natCast_mul, Int.natCast_mul,
      Int.natCast_pow, Int.natCast_pow, mul_comm, sq, sq]
    ring
  · refine ⟨-b, 1, ?_, one_ne_zero, by norm_num, neg_nonneg.2 <| Int.natCast_nonneg _,
      Int.natCast_nonneg _⟩
    rw [← Int.ofNat_one, sq, ← Int.natCast_mul, ← Int.natCast_mul, ← Int.natCast_sub]
    refine mod_cast h₁.symm.trans

Attempt failure.

Working on Mathlib/NumberTheory/PrimesCongruentOne.lean - 2024-09-09 01:11:10.113077.
---150/200---
For theorem Nat.exists_prime_gt_modEq_one in Mathlib/NumberTheory/PrimesCongruentOne.lean:
theorem exists_prime_gt_modEq_one {k : ℕ} (n : ℕ) (hk0 : k ≠ 0) :
    ∃ p : ℕ, Nat.Prime p ∧ n < p ∧ p ≡ 1 [MOD k] 


Original valid proof:
:= by
  rcases (one_le_iff_ne_zero.2 hk0).eq_or_lt with (rfl | hk1)
  · rcases exists_infinite_primes (n + 1) with ⟨p, hnp, hp⟩
    exact ⟨p, hp, hnp, modEq_one⟩
  let b := k * (n !)
  have hgt : 1 < (eval (↑b) (cyclotomic k ℤ)).natAbs := by
    rcases le_iff_exists_add'.1 hk1.le with ⟨k, rfl⟩
    have hb : 2 ≤ b := le_mul_of_le_of_one_le hk1 n.factorial_pos
    calc
      1 ≤ b - 1 := le_tsub_of_add_le_left hb
      _ < (eval (b : ℤ) (cyclotomic (k + 1) ℤ)).natAbs :=
        sub_one_lt_natAbs_cyclotomic_eval hk1 (succ_le_iff.1 hb).ne'
  let p := minFac (eval (↑b) (cyclotomic k ℤ)).natAbs
  haveI hprime : Fact p.Prime := ⟨minFac_prime (ne_of_lt hgt).symm⟩
  have hroot : IsRoot (cyclotomic k (ZMod p)) (castRingHom (ZMod p) b) := by
    have : ((b : ℤ) : ZMod p) = ↑(Int.castRingHom (ZMod p) b) := by simp
    rw [IsRoot.def, ← map_cyclotomic_int k (ZMod p), eval_map, coe_castRingHom,
      ← Int.cast_natCast, this, eval₂_hom, Int.coe_castRingHom, ZMod.intCast_zmod_eq_zero_iff_dvd]
    apply Int.dvd_natAbs.1
    exact mod_cast minFac_dvd (eval (↑b) (cyclotomic k ℤ)).natAbs
  have hpb : ¬p ∣ b :=
    hprime.1.coprime_iff_not_dvd.1 (coprime_of_root_cyclotomic hk0.bot_lt hroot).symm
  refine ⟨p, hprime.1, not_le.1 fun habs => ?_, ?_⟩
  · exact hpb (dvd_mul_of_dvd_right (dvd_factorial (minFac_pos _) habs) _)
  · have hdiv : orderOf (b : ZMod p) ∣ p - 1 :=
      ZMod.orderOf_dvd_card_sub_one (mt (CharP.cast_eq_zero_iff _ _ _).1 hpb)
    haveI : NeZero (k : ZMod p) :=
      NeZero.of_not_dvd (ZMod p) fun hpk => hpb (dvd_mul_of_dvd_left hpk _)
    have : k = orderOf (b : ZMod p) := (isRoot_cyclotomic_iff.mp hroot).eq_orderOf
    rw [← this] at hdiv
    exact ((modEq_iff_dvd' hprime.1.pos).2 hdiv).symm


Verifying proof (Commit 693fd79515903b10b1d31f10dccfc49e633cf7ee):
∧ ∀ q : ℕ, q.Prime → n < q → q ≡ 1 [MOD k] → p ≤ q := by
  have hk0' : k ≠ 0 := hk0
  have hk1 : 1 ≤ k := Nat.one_le_iff_ne_zero.mpr hk0
  have hk2 : 2 ≤ k := by
    rcases k with (_ | _ | k)
    · contradiction
    · contradiction
    · exact Nat.succ_le_succ (Nat.succ_le_iff.2 (Nat.zero_lt_succ _))
  have hk3 : 3 ≤ k := by
    rcases k with (_ | _ | _ | k)
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _))
  have hk4 : 4 ≤ k := by
    rcases k with (_ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _)))
  have hk5 : 5 ≤ k := by
    rcases k with (_ | _ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _))))
  have hk6 : 6 ≤ k := by
    rcases k with (_ | _ | _ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _)))))
  have hk7 : 7 ≤ k := by
    rcases k with (_ | _ | _ | _ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _))))))
  have hk8 : 8 ≤ k := by
    rcases k with (_ | _ | _ | _ | _ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _)))))))
  have hk9 : 9 ≤ k := by
    rcases k with (_ | _ | _ | _ | _ | _ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _))))))))
  have hk10 : 10 ≤ k := by
    rcases k with (_ | _ | _ | _ | _ | _ | _ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _)))))))))
  have hk11 : 11 ≤ k := by
    rcases k with (_ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _))))))))))
  have hk12 : 12 ≤ k := by
    rcases k with (_ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _)))))))))))
  have hk13 : 13 ≤ k := by
    rcases k with (_ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _)))))))))))))
  have hk14 : 14 ≤ k := by
    rcases k with (_ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _))))))))))))))
  have hk15 : 15 ≤ k := by
    rcases k with (_ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | k)
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · contradiction
    · exact le_rfl
    · exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _))))))))

Attempt failure.

Working on Mathlib/Order/Height.lean - 2024-09-09 01:11:23.842176.
---151/200---
For theorem Set.chainHeight_eq_iSup_Ici in Mathlib/Order/Height.lean:
theorem chainHeight_eq_iSup_Ici : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Ici i).chainHeight 


Original valid proof:
:= by
  apply le_antisymm
  · refine iSup₂_le ?_
    rintro (_ | ⟨x, xs⟩) h
    · exact zero_le _
    · apply le_trans _ (le_iSup₂ x (cons_mem_subchain_iff.mp h).1)
      apply length_le_chainHeight_of_mem_subchain
      refine ⟨h.1, fun i hi ↦ ⟨h.2 i hi, ?_⟩⟩
      cases hi
      · exact left_mem_Ici
      rename_i hi
      cases' chain'_iff_pairwise.mp h.1 with _ _ h'
      exact (h' _ hi).le
  · exact iSup₂_le fun i _ ↦ chainHeight_mono Set.inter_subset_left


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
⊔ 1 := by
    simp_rw [chainHeight_eq_iSup_Ici_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Ici : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Ici i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Ici_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight ⊔ 1 := by
  simp_rw [chainHeight_eq_iSup_Iic_aux, iSup_sup_eq, iSup_and, @iSup_sup_eq _ _ (Set α)]

Repaired Proof:
theorem chainHeight_eq_iSup_Iic : s

Attempt failure.

Working on Mathlib/Order/Interval/Finset/Nat.lean - 2024-09-09 01:11:32.490774.
---152/200---
For theorem Nat.image_sub_const_Ico in Mathlib/Order/Interval/Finset/Nat.lean:
theorem image_sub_const_Ico (h : c ≤ a) :
    ((Ico a b).image fun x => x - c) = Ico (a - c) (b - c) 


Original valid proof:
:= by
  ext x
  simp_rw [mem_image, mem_Ico]
  refine ⟨?_, fun h ↦ ⟨x + c, by omega⟩⟩
  rintro ⟨x, hx, rfl⟩
  omega


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      ((Ico a b).image fun x => x - c).PairwiseDisjoint id := by
  haveI : DecidableEq α := Classical.decEq α
  refine' ⟨_, .mono _ _ _ _ _ _⟩
  · ext x
    simp only [mem_image, mem_Ico]
    refine' ⟨_, fun hx => ⟨x + c, _, rfl⟩⟩
    · rintro ⟨x, hx, rfl⟩
      exact ⟨hx.1, hx.2.trans_le h⟩
    · exact ⟨hx.1, hx.2.trans_lt (lt_add_of_nonneg_right _ (lt_of_le_of_lt h (lt_add_one _)))⟩
  · rintro x - y - hxy
    simp only [id.def, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id.def, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id.def, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id.def, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id.def, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le

Repaired Proof:
theorem image_sub_const_Ico (h : c ≤ a) :
    ((Ico a b).image fun x => x - c) = Ico (a - c) (b - c) ∧
      ((Ico a b).image fun x => x - c).PairwiseDisjoint id := by
  haveI : DecidableEq α := Classical.decEq α
  refine ⟨?_, .mono ?_ ?_ ?_ ?_⟩
  · ext x
    simp only [mem_image, mem_Ico]
    refine ⟨?_, fun hx => ⟨x + c, ⟨hx.1, hx.2.trans_le h⟩, rfl⟩⟩
    · rintro ⟨x, hx, rfl⟩
      exact ⟨hx.1, hx.2.trans_lt (lt_add_of_nonneg_right _ (lt_of_le_of_lt h (lt_add_one _)))⟩
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le

Repaired Proof:
theorem image_sub_const_Ico (h : c ≤ a) :
    ((Ico a b).image fun x => x - c) = Ico (a - c) (b - c) ∧
      ((Ico a b).image fun x => x - c).PairwiseDisjoint id := by
  haveI : DecidableEq α := Classical.decEq α
  refine ⟨?_, .mono ?_ ?_ ?_ ?_⟩
  · ext x
    simp only [mem_image, mem_Ico]
    refine ⟨?_, fun hx => ⟨x + c, ⟨hx.1, hx.2.trans_le h⟩, rfl⟩⟩
    · rintro ⟨x, hx, rfl⟩
      exact ⟨hx.1, hx.2.trans_lt (lt_add_of_nonneg_right _ (lt_of_le_of_lt h (lt_add_one _)))⟩
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le

Repaired Proof:
theorem image_sub_const_Ico (h : c ≤ a) :
    ((Ico a b).image fun x => x - c) = Ico (a - c) (b - c) ∧
      ((Ico a b).image fun x => x - c).PairwiseDisjoint id := by
  haveI : DecidableEq α := Classical.decEq α
  refine ⟨?_, .mono ?_ ?_ ?_ ?_⟩
  · ext x
    simp only [mem_image, mem_Ico]
    refine ⟨?_, fun hx => ⟨x + c, ⟨hx.1, hx.2.trans_le h⟩, rfl⟩⟩
    · rintro ⟨x, hx, rfl⟩
      exact ⟨hx.1, hx.2.trans_lt (lt_add_of_nonneg_right _ (lt_of_le_of_lt h (lt_add_one _)))⟩
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le

Repaired Proof:
theorem image_sub_const_Ico (h : c ≤ a) :
    ((Ico a b).image fun x => x - c) = Ico (a - c) (b - c) ∧
      ((Ico a b).image fun x => x - c).PairwiseDisjoint id := by
  haveI : DecidableEq α := Classical.decEq α
  refine ⟨?_, .mono ?_ ?_ ?_ ?_⟩
  · ext x
    simp only [mem_image, mem_Ico]
    refine ⟨?_, fun hx => ⟨x + c, ⟨hx.1, hx.2.trans_le h⟩, rfl⟩⟩
    · rintro ⟨x, hx, rfl⟩
      exact ⟨hx.1, hx.2.trans_lt (lt_add_of_nonneg_right _ (lt_of_le_of_lt h (lt_add_one _)))⟩
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg, add_right_inj, neg_inj] at hxy
    exact hxy.le
  · rintro x - y - hxy
    simp only [id, sub_eq_add_neg,

Attempt failure.

Working on Mathlib/Order/OmegaCompletePartialOrder.lean - 2024-09-09 01:11:40.993712.
---153/200---
For theorem OmegaCompletePartialOrder.isLUB_range_ωSup in Mathlib/Order/OmegaCompletePartialOrder.lean:
lemma isLUB_range_ωSup (c : Chain α) : IsLUB (Set.range c) (ωSup c) 


Original valid proof:
:= by
  constructor
  · simp only [upperBounds, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff,
      Set.mem_setOf_eq]
    exact fun a ↦ le_ωSup c a
  · simp only [lowerBounds, upperBounds, Set.mem_range, forall_exists_index,
      forall_apply_eq_imp_iff, Set.mem_setOf_eq]
    exact fun ⦃a⦄ a_1 ↦ ωSup_le c a a_1


Verifying proof (Commit df7b04231c9920b36d13328cb3f0f402d88e7da5):
↔ ∀ a, ∃ i, a ≤ c i := by
    constructor
    · intro h a
      have : ∃ i, a ≤ c i := by
        by_contra! h'
        obtain ⟨a, ha⟩ := not_forall.mp h'
        have : a ∉ Set.range c := by simpa [Set.mem_range] using ha
        have : ωSup c < a := by
          refine lt_of_le_of_ne (h.1 (Set.mem_range_self _)) ?_
          rintro rfl
          contradiction
        obtain ⟨b, hb⟩ := not_forall.mp (not_exists.mp h' a)
        have : ωSup c ≤ b := by
          refine h.2 ?_
          simp only [Set.mem_range, exists_prop]
          exact ⟨_, hb⟩
        exact not_le.mpr this.not_le (lt_le_trans this hb)
      exact this
    · intro h
      refine ⟨fun a ha => ?_, fun a ha => ?_⟩
      · obtain ⟨i, hi⟩ := h a
        exact le_trans hi (le_ωSup c i)
      · obtain ⟨i, hi⟩ := h a
        exact le_ωSup c i

Repaired Proof:
lemma isLUB_range_ωSup (c : Chain α) : IsLUB (Set.range c) (ωSup c) ↔ ∀ a, ∃ i, a ≤ c i := by
    constructor
    · intro h a
      have : ∃ i, a ≤ c i := by
        by_contra! h'
        obtain ⟨a, ha⟩ := not_forall.mp h'
        have : a ∉ Set.range c := by simpa [Set.mem_range] using ha
        have : ωSup c < a := by
          refine lt_of_le_of_ne (h.1 (Set.mem_range_self _)) ?_
          rintro rfl
          contradiction
        obtain ⟨b, hb⟩ := not_exists.mp h' a
        have : ωSup c ≤ b := by
          refine h.2 ?_
          simp only [Set.mem_range, exists_prop]
          exact ⟨_, hb⟩
        exact not_le.mpr this.not_le (lt_le_trans this hb)
      exact this
    · intro h
      refine ⟨fun a ha => ?_, fun a ha => ?_⟩
      · obtain ⟨i, hi⟩ := h a
        exact le_trans hi (le_ωSup c i)
      · obtain ⟨i, hi⟩ := h a
        exact le_ωSup c i

Repaired Proof:
lemma isLUB_range_ωSup (c : Chain α) : IsLUB (Set.range c) (ωSup c) ↔ ∀ a, ∃ i, a ≤ c i := by
    constructor
    · intro h a
      have : ∃ i, a ≤ c i := by
        by_contra! h'
        obtain ⟨a, ha⟩ := not_forall.mp h'
        have : a ∉ Set.range c := by simpa [Set.mem_range] using ha
        have : ωSup c < a := by
          refine lt_of_le_of_ne (h.1 (Set.mem_range_self _)) ?_
          rintro rfl
          contradiction
        obtain ⟨b, hb⟩ := not_exists.mp h' a
        have : ωSup c ≤ b := by
          refine h.2 ?_
          simp only [Set.mem_range, exists_prop]
          exact ⟨_, hb⟩
        exact not_le.mpr this.not_le (lt_le_trans this hb)
      exact this
    · intro h
      refine ⟨fun a ha => ?_, fun a ha => ?_⟩
      · obtain ⟨i, hi⟩ := h a
        exact le_trans hi (le_ωSup c i)
      · obtain ⟨i, hi⟩ := h a
        exact le_ωSup c i

Repaired Proof:
lemma isLUB_range_ωSup (c : Chain α) : IsLUB (Set.range c) (ωSup c) ↔ ∀ a, ∃ i, a ≤ c i := by
    constructor
    · intro h a
      have : ∃ i, a ≤ c i := by
        by_contra! h'
        obtain ⟨a, ha⟩ := not_forall.mp h'
        have : a ∉ Set.range c := by simpa [Set.mem_range] using ha
        have : ωSup c < a := by
          refine lt_of_le_of_ne (h.1 (Set.mem_range_self _)) ?_
          rintro rfl
          contradiction
        obtain ⟨b, hb⟩ := not_exists.mp h' a
        have : ωSup c ≤ b := by
          refine h.2 ?_
          simp only [Set.mem_range, exists_prop]
          exact ⟨_, hb⟩
        exact not_le.mpr this.not_le (lt_le_trans this hb)
      exact this
    · intro h
      refine ⟨fun a ha => ?_, fun a ha => ?_⟩
      · obtain ⟨i, hi⟩ := h a
        exact le_trans hi (le_ωSup c i)
      · obtain ⟨i, hi⟩ := h a
        exact le_ωSup c i

Repaired Proof:
lemma isLUB_range_ωSup (c : Chain α) : IsLUB (Set.range c) (ωSup c) ↔ ∀ a, ∃ i, a ≤ c i := by
    constructor
    · intro h a
      have : ∃ i, a ≤ c i := by
        by_contra! h'
        obtain ⟨a, ha⟩ := not_forall.mp h'
        have : a ∉ Set.range c := by simpa [Set.mem_range] using ha
        have : ωSup c < a := by
          refine lt_of_le_of_ne (h.1 (Set.mem_range_self _)) ?_
          rintro rfl
          contradiction
        obtain ⟨b, hb⟩ := not_exists.mp h' a
        have : ωSup c ≤ b := by
          refine h.2 ?_
          simp only [Set.mem_range, exists_prop]
          exact ⟨_, hb⟩
        exact not_le.mpr this.not_le (lt_le_trans this hb)
      exact this
    · intro h
      refine ⟨fun a ha => ?_, fun a ha => ?_⟩
      · obtain ⟨i, hi⟩ := h a
        exact le_trans hi (le_ωSup c i)
      · obtain ⟨i, hi⟩ := h a
        exact le_ωSup c i

Repaired Proof:
lemma isLUB_range_ωSup (c : Chain α) : IsLUB (Set.range c) (ωSup c) ↔ ∀ a, ∃ i, a ≤ c i := by
    constructor
    · intro h a
      have : ∃ i, a ≤ c i := by
        by_contra! h'
        obtain ⟨a, ha⟩ := not_forall.mp h'
        have : a ∉ Set.range c := by simpa [Set.mem_range] using ha
        have : ωSup c < a := by
          refine lt_of_le_of_ne (h.1 (Set.mem_range_self _)) ?_
          rintro rfl
          contradiction
        obtain ⟨b, hb⟩ := not_exists.mp h' a
        have : ωSup c ≤ b := by
          refine h.2 ?_
          simp only [Set.mem_range, exists_prop]
          exact ⟨_, hb⟩
        exact not_le.mpr this.not_le (lt_le_trans this hb)
      exact this
    · intro h
      refine ⟨fun a ha => ?_, fun a ha => ?_⟩
      · obtain ⟨i, hi⟩ := h a
        exact le_trans hi (le_ωSup

Attempt failure.

Working on Mathlib/Order/WellFoundedSet.lean - 2024-09-09 01:11:49.597481.
---154/200---
For theorem Set.partiallyWellOrderedOn_union in Mathlib/Order/WellFoundedSet.lean:
theorem partiallyWellOrderedOn_union :
    (s ∪ t).PartiallyWellOrderedOn r ↔ s.PartiallyWellOrderedOn r ∧ t.PartiallyWellOrderedOn r 


Original valid proof:
:=
  ⟨fun h => ⟨h.mono subset_union_left, h.mono subset_union_right⟩, fun h =>
    h.1.union h.2⟩


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
∧
      (s.Nonempty → t.Nonempty → ∀ a ∈ s, ∀ b ∈ t, r a b) := by
  refine' ⟨fun h => ⟨_, _, fun a ha b hb => h.rel ha hb⟩, fun h a ha b hb => _⟩
  · obtain rfl | ha := ha.eq_or_lt
    · exact h.mono fun c hc => Or.inr hc
    · exact h.rel ha hb
  · cases' h.1.eq_or_lt ha with ha ha
    · exact Or.inl ha
    · cases' h.2.1.eq_or_lt hb with hb hb
      · exact Or.inr hb
      · exact Or.inl (h.2.2 ⟨_, ha⟩ ⟨_, hb⟩ _ ha _ hb)

Repaired Proof:
theorem partiallyWellOrderedOn_union :
    (s ∪ t).PartiallyWellOrderedOn r ↔ s.PartiallyWellOrderedOn r ∧ t.PartiallyWellOrderedOn r ∧
      (s.Nonempty → t.Nonempty → ∀ a ∈ s, ∀ b ∈ t, r a b) := by
  refine ⟨fun h => ⟨?_, ?_, fun a ha b hb => h.rel ha hb⟩, fun h a ha b hb => ?_⟩
  · obtain rfl | ha := ha.eq_or_lt
    · exact h.mono fun c hc => Or.inr hc
    · exact h.rel ha hb
  · cases' h.1.eq_or_lt ha with ha ha
    · exact Or.inl ha
    · cases' h.2.1.eq_or_lt hb with hb hb
      · exact Or.inr hb
      · exact Or.inl (h.2.2 ⟨_, ha⟩ ⟨_, hb⟩ _ ha _ hb)

Repaired Proof:
theorem partiallyWellOrderedOn_union :
    (s ∪ t).PartiallyWellOrderedOn r ↔ s.PartiallyWellOrderedOn r ∧ t.PartiallyWellOrderedOn r ∧
      (s.Nonempty → t.Nonempty → ∀ a ∈ s, ∀ b ∈ t, r a b) := by
  refine ⟨fun h => ⟨?_, ?_, fun a ha b hb => h.rel ha hb⟩, fun h a ha b hb => ?_⟩
  · obtain rfl | ha := ha.eq_or_lt
    · exact h.mono fun c hc => Or.inr hc
    · exact h.rel ha hb
  · cases' h.1.eq_or_lt ha with ha ha
    · exact Or.inl ha
    · cases' h.2.1.eq_or_lt hb with hb hb
      · exact Or.inr hb
      · exact Or.inl (h.2.2 ⟨_, ha⟩ ⟨_, hb⟩ _ ha _ hb)

Repaired Proof:
theorem partiallyWellOrderedOn_union :
    (s ∪ t).PartiallyWellOrderedOn r ↔ s.PartiallyWellOrderedOn r ∧ t.PartiallyWellOrderedOn r ∧
      (s.Nonempty → t.Nonempty → ∀ a ∈ s, ∀ b ∈ t, r a b) := by
  refine ⟨fun h => ⟨?_, ?_, fun a ha b hb => h.rel ha hb⟩, fun h a ha b hb => ?_⟩
  · obtain rfl | ha := ha.eq_or_lt
    · exact h.mono fun c hc => Or.inr hc
    · exact h.rel ha hb
  · cases' h.1.eq_or_lt ha with ha ha
    · exact Or.inl ha
    · cases' h.2.1.eq_or_lt hb with hb hb
      · exact Or.inr hb
      · exact Or.inl (h.2.2 ⟨_, ha⟩ ⟨_, hb⟩ _ ha _ hb)

Repaired Proof:
theorem partiallyWellOrderedOn_union :
    (s ∪ t).PartiallyWellOrderedOn r ↔ s.PartiallyWellOrderedOn r ∧ t.PartiallyWellOrderedOn r ∧
      (s.Nonempty → t.Nonempty → ∀ a ∈ s, ∀ b ∈ t, r a b) := by
  refine ⟨fun h => ⟨?_, ?_, fun a ha b hb => h.rel ha hb⟩, fun h a ha b hb => ?_⟩
  · obtain rfl | ha := ha.eq_or_lt
    · exact h.mono fun c hc => Or.inr hc
    · exact h.rel ha hb
  · cases' h.1.eq_or_lt ha with ha ha
    · exact Or.inl ha
    · cases' h.2.1.eq_or_lt hb with hb hb
      · exact Or.inr hb
      · exact Or.inl (h.2.2 ⟨_, ha⟩ ⟨_, hb⟩ _ ha _ hb)

Repaired Proof:
theorem partiallyWellOrderedOn_union :
    (s ∪ t).PartiallyWellOrderedOn r ↔ s.PartiallyWellOrderedOn r ∧ t.PartiallyWellOrderedOn r ∧
      (s.Nonempty → t.Nonempty → ∀ a ∈ s, ∀ b ∈ t, r a b) := by
  refine ⟨fun h => ⟨?_, ?_, fun a ha b hb => h.rel ha hb⟩, fun h a ha b hb => ?_⟩
  · obtain rfl | ha := ha.eq_or_lt
    · exact h.mono fun c hc => Or.inr hc
    · exact h.rel ha hb
  · cases' h.1.eq_or_lt ha with ha ha
    · exact Or.inl ha
    · cases' h.2.1.eq_or_lt hb with hb hb
      · exact Or.inr hb
      · exact Or.inl (h.2.2 ⟨_, ha⟩ ⟨_, hb⟩ _ ha _ hb)

Repaired Proof:
theorem partiallyWellOrderedOn_union :
    (s ∪ t).PartiallyWellOrderedOn r ↔ s.PartiallyWellOrderedOn r ∧ t.PartiallyWellOrderedOn r ∧
      (s.Nonempty → t.Nonempty → ∀ a ∈ s, ∀ b ∈ t, r a b) := by
  refine ⟨fun h => ⟨?_, ?_, fun a ha b hb => h.rel ha hb⟩, fun h a ha b hb => ?_⟩
  · obtain rfl | ha := ha.eq_or_lt
    · exact h.mono fun c hc => Or.inr hc
    · exact h.rel ha hb
  · cases' h.1.eq_or_lt ha with ha ha
    · exact Or.inl ha
    · cases' h.2.1.eq_or_lt hb with hb hb
      · exact Or.inr hb
      · exact Or.inl (h.2.2 ⟨_, ha⟩ ⟨_, hb⟩ _ ha _ hb)

Repaired Proof:
theorem partiallyWellOrderedOn_union :
    (s ∪ t).PartiallyWellOrderedOn r ↔ s.PartiallyWellOrderedOn r ∧ t.PartiallyWellOrderedOn r ∧
      (s.Nonempty → t.Nonempty → ∀ a ∈ s, ∀ b ∈ t, r a b) := by
  refine ⟨fun h => ⟨?_, ?_, fun a ha b hb => h.rel ha hb⟩, fun h a ha b hb => ?_⟩
  · obtain rfl | ha := ha.eq_or_lt
    · exact h.mono fun c hc => Or.inr hc
    · exact h.rel ha hb
  · cases' h.1.eq_or_lt ha with ha ha
    · exact Or.inl ha
    · cases' h.2.1.eq_or_lt hb with

Attempt failure.

---155/200---
For theorem Set.WellFoundedOn.acc_iff_wellFoundedOn in Mathlib/Order/WellFoundedSet.lean:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r] 


Original valid proof:
:= by
  tfae_have 1 → 2
  · refine fun h => ⟨fun b => InvImage.accessible _ ?_⟩
    rw [← acc_transGen_iff] at h ⊢
    obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2
    · rwa [h'] at h
    · exact h.inv h'
  tfae_have 2 → 3
  · exact fun h => h.subset fun _ => TransGen.to_reflTransGen
  tfae_have 3 → 1
  · refine fun h => Acc.intro _ (fun b hb => (h.apply ⟨b, .single hb⟩).of_fibration Subtype.val ?_)
    exact fun ⟨c, hc⟩ d h => ⟨⟨d, .head h hc⟩, h, rfl⟩
  tfae_finish


Verifying proof (Commit 415d6b952a0c6bc1221dd68bc6ae84a0390ea21f):
 := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _ IH => ⟨_, IH⟩⟩
  tfae_have 2 → 3
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_have 3 → 1
  · exact fun h => ⟨fun b => h.1 b⟩
  tfae_finish

Repaired Proof:
theorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r]  := by
  tfae_have 1 → 2
  · exact fun h => ⟨fun b => Acc.recOn (h.2 b) fun x _

Attempt failure.

Working on Mathlib/Probability/Distributions/Gaussian.lean - 2024-09-09 01:12:08.983598.
---156/200---
For theorem ProbabilityTheory.gaussianReal_map_const_mul in Mathlib/Probability/Distributions/Gaussian.lean:
lemma gaussianReal_map_const_mul (c : ℝ) :
    (gaussianReal μ v).map (c * ·) = gaussianReal (c * μ) (⟨c^2, sq_nonneg _⟩ * v) 


Original valid proof:
:= by
  by_cases hv : v = 0
  · simp only [hv, mul_zero, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.const_mul c) μ
  by_cases hc : c = 0
  · simp only [hc, zero_mul, ne_eq, abs_zero, mul_eq_zero]
    rw [Measure.map_const]
    simp only [ne_eq, measure_univ, one_smul, mul_eq_zero]
    convert (gaussianReal_zero_var 0).symm
    simp only [ne_eq, zero_pow, mul_eq_zero, hv, or_false, not_false_eq_true]
    rfl
  let e : ℝ ≃ᵐ ℝ := (Homeomorph.mulLeft₀ c hc).symm.toMeasurableEquiv
  have he' : ∀ x, HasDerivAt e ((fun _ ↦ c⁻¹) x) x := by
    suffices ∀ x, HasDerivAt (fun x => c⁻¹ * x) (c⁻¹ * 1) x by rwa [mul_one] at this
    exact fun _ ↦ HasDerivAt.const_mul _ (hasDerivAt_id _)
  change (gaussianReal μ v).map e.symm = gaussianReal (c * μ) (⟨c^2, sq_nonneg _⟩ * v)
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs',
    gaussianReal_apply_eq_integral _ _ s']
  swap
  · simp only [ne_eq, mul_eq_zero, hv, or_false]
    rw [← NNReal.coe_inj]
    simp [hc]
  simp only [e, Homeomorph.mulLeft₀, Equiv.toFun_as_coe, Equiv.mulLeft₀_apply, Equiv.invFun_as_coe,
    Equiv.mulLeft₀_symm_apply, Homeomorph.toMeasurableEquiv_coe, Homeomorph.homeomorph_mk_coe_symm,
    Equiv.coe_fn_symm_mk, gaussianPDFReal_inv_mul hc]
  congr with x
  suffices |c⁻¹| * |c| = 1 by rw [← mul_assoc, this, one_mul]
  rw [abs_inv, inv_mul_cancel]
  rwa [ne_eq, abs_eq_zero]


Verifying proof (Commit 62a9ca63fe8a39ea0004bbc5dbf652532269c0b1):
↔ 0 ≤ c := by
  by_cases hc : c = 0
  · simp only [hc, zero_mul, mul_zero, true_iff, map_const, gaussianReal_const_mul_self,
      gaussianReal_const_mul_const, abs_zero, sub_zero, mul_zero, gaussianReal_const,
      gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  rw [← gaussianReal_map_mul_const c⁻¹, ← gaussianReal_map_mul_const c,
    gaussianReal_map_mul_const _ (inv_ne_zero hc), gaussianReal_map_mul_const _ hc,
    gaussianReal_map_id, gaussianReal_map_id, mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc),
    gaussianReal_const_mul_self, gaussianReal_const_mul_const, gaussianReal_const_mul_const,
    gaussianReal_const_mul_self, gaussianReal_const_mul_const]
  simp only [ne_eq, mul_eq_zero, inv_eq_zero, false_or, hc, or_false, gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_inv_cancel hc, mul_inv_cancel (inv_ne_zero hc), gaussianReal_const,
    gaussianReal_const_of_pos (sq_pos_of_ne_zero _ hc)]
  simp only [mul_

Attempt failure.

Working on Mathlib/Probability/Kernel/RadonNikodym.lean - 2024-09-09 01:12:26.492257.
---157/200---
For theorem ProbabilityTheory.kernel.measure_mutuallySingularSetSlice in Mathlib/Probability/Kernel/RadonNikodym.lean:
lemma measure_mutuallySingularSetSlice (κ η : kernel α γ) [IsFiniteKernel κ] [IsFiniteKernel η]
    (a : α) :
    η a (mutuallySingularSetSlice κ η a) = 0 


Original valid proof:
:= by
  have h_coe : ∀ b, (Real.toNNReal b : ℝ≥0∞) = ENNReal.ofReal b := fun _ ↦ rfl
  suffices withDensity (κ + η) (fun a x ↦ Real.toNNReal
      (1 - rnDerivAux κ (κ + η) a x)) a {x | 1 ≤ rnDerivAux κ (κ + η) a x} = 0 by
    rwa [withDensity_one_sub_rnDerivAux κ η] at this
  simp_rw [h_coe]
  rw [kernel.withDensity_apply', lintegral_eq_zero_iff, EventuallyEq, ae_restrict_iff]
  rotate_left
  · exact (measurable_const.sub
      ((measurable_rnDerivAux _ _).comp measurable_prod_mk_left)).ennreal_ofReal
      (measurableSet_singleton _)
  · exact (measurable_const.sub
      ((measurable_rnDerivAux _ _).comp measurable_prod_mk_left)).ennreal_ofReal
  · exact (measurable_const.sub (measurable_rnDerivAux _ _)).ennreal_ofReal
  refine ae_of_all _ (fun x hx ↦ ?_)
  simp only [mem_setOf_eq] at hx
  simp [hx]


Verifying proof (Commit 1953582979d6fb22253b407bc35a0372934263c5):
∧ κ a (mutuallySingularSetSlice κ η a)ᶜ = 0 := by
  have h_meas_κ : MeasurableSet (mutuallySingularSetSlice κ η a) :=
    measurableSet_mutuallySingularSetSlice κ η a
  refine ⟨measure_zero_of_measure_mutuallySingularSlice κ η a ?_,
    measure_zero_of_measure_mutuallySingularSlice η κ a ?_⟩ <;>
  rw [mutuallySingularSetSlice] <;>
  simp_rw [ae_iff] <;>
  simp only [not_le] <;>
  intro c hc
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice κ η a))
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice η κ a))

Repaired Proof:
lemma measure_mutuallySingularSetSlice (κ η : kernel α γ) [IsFiniteKernel κ] [IsFiniteKernel η]
    (a : α) :
    η a (mutuallySingularSetSlice κ η a) = 0 ∧ κ a (mutuallySingularSetSlice κ η a)ᶜ = 0 := by
  have h_meas_κ : MeasurableSet (mutuallySingularSetSlice κ η a) :=
    measurableSet_mutuallySingularSetSlice κ η a
  refine ⟨measure_zero_of_measure_mutuallySingularSlice κ η a ?_,
    measure_zero_of_measure_mutuallySingularSlice η κ a ?_⟩ <;>
  rw [mutuallySingularSetSlice] <;>
  simp_rw [ae_iff] <;>
  simp only [not_le] <;>
  intro c hc
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice κ η a))
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice η κ a))

Repaired Proof:
lemma measure_mutuallySingularSetSlice (κ η : kernel α γ) [IsFiniteKernel κ] [IsFiniteKernel η]
    (a : α) :
    η a (mutuallySingularSetSlice κ η a) = 0 ∧ κ a (mutuallySingularSetSlice κ η a)ᶜ = 0 := by
  have h_meas_κ : MeasurableSet (mutuallySingularSetSlice κ η a) :=
    measurableSet_mutuallySingularSetSlice κ η a
  refine ⟨measure_zero_of_measure_mutuallySingularSlice κ η a ?_,
    measure_zero_of_measure_mutuallySingularSlice η κ a ?_⟩ <;>
  rw [mutuallySingularSetSlice] <;>
  simp_rw [ae_iff] <;>
  simp only [not_le] <;>
  intro c hc
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice κ η a))
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice η κ a))

Repaired Proof:
lemma measure_mutuallySingularSetSlice (κ η : kernel α γ) [IsFiniteKernel κ] [IsFiniteKernel η]
    (a : α) :
    η a (mutuallySingularSetSlice κ η a) = 0 ∧ κ a (mutuallySingularSetSlice κ η a)ᶜ = 0 := by
  have h_meas_κ : MeasurableSet (mutuallySingularSetSlice κ η a) :=
    measurableSet_mutuallySingularSetSlice κ η a
  refine ⟨measure_zero_of_measure_mutuallySingularSlice κ η a ?_,
    measure_zero_of_measure_mutuallySingularSlice η κ a ?_⟩ <;>
  rw [mutuallySingularSetSlice] <;>
  simp_rw [ae_iff] <;>
  simp only [not_le] <;>
  intro c hc
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice κ η a))
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice η κ a))

Repaired Proof:
lemma measure_mutuallySingularSetSlice (κ η : kernel α γ) [IsFiniteKernel κ] [IsFiniteKernel η]
    (a : α) :
    η a (mutuallySingularSetSlice κ η a) = 0 ∧ κ a (mutuallySingularSetSlice κ η a)ᶜ = 0 := by
  have h_meas_κ : MeasurableSet (mutuallySingularSetSlice κ η a) :=
    measurableSet_mutuallySingularSetSlice κ η a
  refine ⟨measure_zero_of_measure_mutuallySingularSlice κ η a ?_,
    measure_zero_of_measure_mutuallySingularSlice η κ a ?_⟩ <;>
  rw [mutuallySingularSetSlice] <;>
  simp_rw [ae_iff] <;>
  simp only [not_le] <;>
  intro c hc
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice κ η a))
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice η κ a))

Repaired Proof:
lemma measure_mutuallySingularSetSlice (κ η : kernel α γ) [IsFiniteKernel κ] [IsFiniteKernel η]
    (a : α) :
    η a (mutuallySingularSetSlice κ η a) = 0 ∧ κ a (mutuallySingularSetSlice κ η a)ᶜ = 0 := by
  have h_meas_κ : MeasurableSet (mutuallySingularSetSlice κ η a) :=
    measurableSet_mutuallySingularSetSlice κ η a
  refine ⟨measure_zero_of_measure_mutuallySingularSlice κ η a ?_,
    measure_zero_of_measure_mutuallySingularSlice η κ a ?_⟩ <;>
  rw [mutuallySingularSetSlice] <;>
  simp_rw [ae_iff] <;>
  simp only [not_le] <;>
  intro c hc
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice κ η a))
  · rw [not_le]
    exact hc.trans_lt (measure_mono_null (Set.inter_subset_right _ _)
      (measure_compl_mutuallySingularSetSlice η κ a))

Repaired Proof:
lemma measure_mutuallySingularSetSlice (κ η : kernel α γ) [IsFiniteKernel κ] [IsFiniteKernel η]
    (a : α) :
    η a (mutuallySingularSetSlice κ η a) = 0 ∧ κ a (mutuallySingularSetSlice κ η a)ᶜ = 0 := by
  have h_meas_κ : MeasurableSet (mutuallySingularSetSlice κ η a) :=
    measurableSet_mutuallySingularSetSlice κ η a
  refine ⟨measure_zero_of_measure_mutuallySingularSlice κ η a ?_,
    measure_zero_of_measure_mutuallySingularSlice η κ a ?_⟩ <;>
  rw [mutuallySingularSetSlice] <;>
  simp_rw [ae_iff] <

Attempt failure.

Working on Mathlib/Probability/Kernel/WithDensity.lean - 2024-09-09 01:12:43.392873.
---158/200---
For theorem ProbabilityTheory.kernel.isSFiniteKernel_withDensity_of_isFiniteKernel in Mathlib/Probability/Kernel/WithDensity.lean:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) 


Original valid proof:
:= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; · rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : ℕ → α → β → ℝ≥0∞ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : ∀ a b n, ⌈(f a b).toReal⌉₊ ≤ n → f a b ≤ n := by
    intro a b n hn
    have : (f a b).toReal ≤ n := Nat.le_of_ceil_le hn
    rw [← ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    · refine this.trans (le_of_eq ?_)
      rw [ENNReal.ofReal_natCast]
    · norm_cast
      exact zero_le _
  have h_zero : ∀ a b n, ⌈(f a b).toReal⌉₊ ≤ n → fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b ∧ min (f a b) n = f a b by
      simp_rw [fs, this.1, this.2, tsub_self (f a b)]
    exact ⟨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)⟩
  have hf_eq_tsum : f = ∑' n, fs n := by
    have h_sum_a : ∀ a, Summable fun n => fs n a := by
      refine fun a => Pi.summable.mpr fun b => ?_
      suffices ∀ n, n ∉ Finset.range ⌈(f a b).toReal⌉₊ → fs n a b = 0 from
        summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : ∀ n, ∑ i ∈ Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      · simp
      rw [Finset.sum_range_succ, hn]
      simp [fs]
    simp_rw [h_finset_sum]
    refine (Filter.Tendsto.liminf_eq ?_).symm
    refine Filter.Tendsto.congr' ?_ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact ⟨⌈(f a b).toReal⌉₊, fun n hn => (min_eq_left (h_le a b n hn)).symm⟩
  rw [hf_eq_tsum, withDensity_tsum _ fun n : ℕ => _]
  swap; · exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine isSFiniteKernel_sum fun n => ?_
  suffices IsFiniteKernel (withDensity κ (fs n)) by haveI := this; infer_instance
  refine isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : ↑n + 1 ≠ ∞) fun a b => ?_
  beta_reduce
  norm_cast
  calc
    fs n a b ≤ min (f a b) (n + 1) := tsub_le_self
    _ ≤ n + 1 := min_le_right _ _
    _ = ↑(n + 1) := by norm_cast


Verifying proof (Commit 5ac9cb38fcf9079f6519764442b871fbd4091ab1):
↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isS

Attempt failure.

Working on Mathlib/Probability/Variance.lean - 2024-09-09 01:12:57.058832.
---159/200---
For theorem ProbabilityTheory.meas_ge_le_variance_div_sq in Mathlib/Probability/Variance.lean:
theorem meas_ge_le_variance_div_sq [@IsFiniteMeasure Ω _ ℙ] {X : Ω → ℝ} (hX : Memℒp X 2) {c : ℝ}
    (hc : 0 < c) : ℙ {ω | c ≤ |X ω - 𝔼[X]|} ≤ ENNReal.ofReal (Var[X] / c ^ 2) 


Original valid proof:
:= by
  rw [ENNReal.ofReal_div_of_pos (sq_pos_of_ne_zero hc.ne.symm), hX.ofReal_variance_eq]
  convert @meas_ge_le_evariance_div_sq _ _ _ hX.1 c.toNNReal (by simp [hc]) using 1
  · simp only [Real.coe_toNNReal', max_le_iff, abs_nonneg, and_true_iff]
  · rw [ENNReal.ofReal_pow hc.le]
    rfl


Verifying proof (Commit 22e97510854d6906cc856e022d297bf9cf8c9b3a):
∨
    ℙ {ω | c ≤ |X ω - 𝔼[X]|} = 0 := by
  by_cases h_int : Integrable X
  · have h_sub : Submartingale (fun ω => (X ω - 𝔼[X])) ℱ ℙ :=
      submartingale_of_memℒp hX (integrable_const _) (fun _ => memℒp_const _)
    have h_pos : 0 ≤ (c ^ 2)⁻¹ := by simp only [inv_nonneg, sq_nonneg]
    have h_meas : MeasurableSet {ω | c ≤ |X ω - 𝔼[X]|} :=
      measurableSet_le measurable_const (h_sub.measurable_of_fin c h_pos).norm
    refine' or_iff_not_imp_right.mpr fun h => _
    have h_sq_int : Integrable fun ω => (X ω - 𝔼[X]) ^ 2 := by
      simp_rw [← sq_abs]
      exact (integrable_condexp.2 h_int).norm.add' (integrable_zero _ _ _)
    have h_sq_ineq : ∀ᵐ ω ∂ℙ, ω ∈ {ω | c ≤ |X ω - 𝔼[X]|} → (X ω - 𝔼[X]) ^ 2 ≥ c ^ 2 := by
      filter_upwards [ae_mem_imp_eq_of_ae_restrict h_meas] with ω hω h_mem
      rw [Set.mem_setOf_eq] at h_mem
      have h_abs : |X ω - 𝔼[X]| ≥ c := by rwa [abs_of_nonneg (le_trans h_pos (le_abs_self _))] at h_mem
      calc
        (X ω - 𝔼[X]) ^ 2 = |X ω - 𝔼[X]| ^ 2 := sq_abs _
        _ ≥ c ^ 2 := sq_le_sq.2 h_abs
    have h_ineq : ∫⁻ ω, ↑((X ω - 𝔼[X]) ^ 2) ∂ℙ ≥ ∫⁻ _ in {ω | c ≤ |X ω - 𝔼[X]}}, c ^ 2 ∂ℙ :=
      lintegral_mono_ae (h_sq_ineq.mono fun ω hω hω' => by rwa [hω'])
    have h_eq : ∫⁻ _ in {ω | c ≤ |X ω - 𝔼[X]}}, c ^ 2 ∂ℙ = c ^ 2 * ℙ {ω | c ≤ |X ω - 𝔼[X]|} := by
      simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
    rw [← h_eq, ← ENNReal.ofReal_mul (sq_nonneg c)] at h_ineq
    have h_var : Var[X] = ∫⁻ ω, ↑((X ω - 𝔼[X]) ^ 2) ∂ℙ := by
      simp only [Variance, sub_eq_add_neg]
    rw [h_var] at h_ineq
    have h_ennreal_ineq : ENNReal.ofReal (c ^ 2) * ℙ {ω | c ≤ |X ω - 𝔼[X]|} ≤
        ENNReal.ofReal (Var[X] / c ^ 2) := by
      rw [ENNReal.ofReal_mul (sq_nonneg c), ← ENNReal.ofReal_div_of_pos (sq_pos_of_ne_zero hc.ne.symm)
        (by simp only [ne_eq, h_int.variance_eq, ENNReal.ofReal_eq_zero, not_true_eq_false,
          false_or]), ← ENNReal.ofReal_ofReal_num]
      exact h_ineq
    rw [ENNReal.le_div_iff_mul_le (Or.inl (ENNReal.ofReal_pos.2 hc))] at h_ennreal_ineq
    simp only [ENNReal.ofReal_ne_top, Ne, or_true_iff, ENNReal.mul_eq_top, false_and_iff,
      false_or_iff] at h_ennreal_ineq
    rwa [ENNReal.ofReal_le_ofReal_iff (div_nonneg (sq_nonneg _) (sq_nonneg _)), ←
      ENNReal.toReal_le_toReal (Or.inl h_ennreal_ineq) (Or.inl (measure_ne_top _ _)),
      ENNReal.toReal_ofReal_of_nonneg (sq_nonneg _), ENNReal.toReal_ofReal_of_nonneg (sq_nonneg _),
      ENNReal.toReal_mul, ENNReal.toReal_ofReal_of_nonneg (sq_nonneg _), ENNReal.toReal_ofReal_of_nonneg
        (sq_nonneg _), mul_comm] at h_ennreal_ineq
  · simp only [not_memℒp_zero, hX, false_or_iff] at hX
    simp only [hX, not_false_iff, or_self_iff, variance_zero, ENNReal.ofReal_zero,
      MeasureTheory.measure_univ, ENNReal.ofReal_eq_zero, le_zero_iff]

Repaired Proof:
theorem meas_ge_le_variance_div_sq [@IsFiniteMeasure Ω _ ℙ] {X : Ω → ℝ} (hX : Memℒp X 2) {c : ℝ}
    (hc : 0 < c) : ℙ {ω | c ≤ |X ω - 𝔼[X]|} ≤ ENNReal.ofReal (Var[X] / c ^ 2) ∨
    ℙ {ω | c ≤ |X ω - 𝔼[X]|} = 0 := by
  by_cases h_int : Integrable X
  · have h_sub : Submartingale (fun ω => (X ω - 𝔼[X])) ℱ ℙ :=
      submartingale_of_memℒp hX (integrable_const _) (fun _ => memℒp_const _)
    have h_pos : 0 ≤ (c ^ 2)⁻¹ := by simp only [inv_nonneg, sq_nonneg]
    have h_meas : MeasurableSet {ω | c ≤ |X ω - 𝔼[X]|} :=
      measurableSet_le measurable_const (h_sub.measurable_of_fin c h_pos).norm
    refine or_iff_not_imp_right.mpr fun h => ?_
    have h_sq_int : Integrable fun ω => (X ω - 𝔼[X]) ^ 2 := by
      simp_rw [← sq_abs]
      exact (integrable_condexp.2 h_int).norm.add' (integrable_zero _ _ _)
    have h_sq_ineq : ∀ᵐ ω ∂ℙ, ω ∈ {ω | c ≤ |X ω - 𝔼[X]|} → (X ω - 𝔼[X]) ^ 2 ≥ c ^ 2 := by
      filter_upwards [ae_mem_imp_eq_of_ae_restrict h_meas] with ω hω h_mem
      rw [Set.mem_setOf_eq] at h_mem
      have h_abs : |X ω - 𝔼[X]| ≥ c := by rwa [abs_of_nonneg (le_trans h_pos (le_abs_self _))] at h_mem
      calc
        (X ω - 𝔼[X]) ^ 2 = |X ω - 𝔼[X]| ^ 2 := sq_abs _
        _ ≥ c ^ 2 := sq_le_sq.2 h_abs
    have h_ineq : ∫⁻ ω, ↑((X ω - 𝔼[X]) ^ 2) ∂ℙ ≥ ∫⁻ _ in {ω | c ≤ |X ω - 𝔼[X]}}, c ^ 2 ∂ℙ :=
      lintegral_mono_ae (h_sq_ineq.mono fun ω hω hω' => by rwa [hω'])
    have h_eq : ∫⁻ _ in {ω

Attempt failure.

Working on Mathlib/RingTheory/Adjoin/PowerBasis.lean - 2024-09-09 01:13:14.426318.
---160/200---
For theorem PowerBasis.repr_mul_isIntegral in Mathlib/RingTheory/Adjoin/PowerBasis.lean:
theorem repr_mul_isIntegral [IsDomain S] {x y : A} (hx : ∀ i, IsIntegral R (B.basis.repr x i))
    (hy : ∀ i, IsIntegral R (B.basis.repr y i))
    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) :
    ∀ i, IsIntegral R (B.basis.repr (x * y) i) 


Original valid proof:
:= by
  intro i
  rw [← B.basis.sum_repr x, ← B.basis.sum_repr y, Finset.sum_mul_sum, ← Finset.sum_product',
    map_sum, Finset.sum_apply']
  refine IsIntegral.sum _ fun I _ => ?_
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smulₛₗ,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine (hy _).mul ((hx _).mul ?_)
  simp only [coe_basis, ← pow_add]
  exact repr_gen_pow_isIntegral hB hmin _ _


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∧
      minpoly S (B.basis.repr (x * y) i) = (minpoly R (B.basis.repr (x * y) i)).map (algebraMap R S) := by
  intro i
  letI : Module.Finite R S := Module.Finite.of_surjective (algebraMap R S) (IsFractionRing.injective R S)
  letI : Module.Finite R A := Module.Finite.of_surjective (algebraMap R A) (IsFractionRing.injective R A)
  letI : IsNoetherian R A := isNoetherian_of_fg_of_noetherian' S _
  letI : IsNoetherian R S := isNoetherian_of_fg_of_noetherian' A _
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R S)
  letI : IsIntegralClosure S R A :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (IsFractionRing.injective R A)
  letI

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Different.lean - 2024-09-09 01:13:28.435218.
---161/200---
For theorem FractionalIdeal.dual_eq_mul_inv in Mathlib/RingTheory/DedekindDomain/Different.lean:
lemma dual_eq_mul_inv :
    dual A K I = dual A K 1 * I⁻¹ 


Original valid proof:
:= by
  by_cases hI : I = 0; · simp [hI]
  apply le_antisymm
  · suffices dual A K I * I ≤ dual A K 1 by
      convert mul_right_mono I⁻¹ this using 1; simp only [mul_inv_cancel hI, mul_one, mul_assoc]
    rw [← le_dual_iff A K hI]
  rw [le_dual_iff A K hI, mul_assoc, inv_mul_cancel hI, mul_one]


Verifying proof (Commit 3465d1aaae242475fad59e688648a2285031d19e):
 := by
  rw [dual_eq_mul_inv_aux, mul_assoc, mul_inv_cancel (le_of_lt (bot_lt_smul_of_lt_one _ _ hI)),
    mul_one]
  simpa using hI

Repaired Proof:
lemma dual_eq_mul_inv :
    dual A K I = dual A K 1 * I⁻¹  := by
  rw [dual_eq_mul_inv_aux, mul_assoc, mul_inv_cancel (le_of_lt (bot_lt_smul_of_lt_one _ _ hI)),
    mul_one]
  simpa using hI

Repaired Proof:
lemma dual_eq_inv_mul :
    dual A K I = I⁻¹ * dual A K 1 := by
  rw [dual_eq_mul_inv, mul_comm]

Repaired Proof:
lemma dual_eq_inv_mul :
    dual A K I = I⁻¹ * dual A K 1 := by
  rw [dual_eq_mul_inv, mul_comm]

Repaired Proof:
lemma dual_eq_inv_mul_inv :
    dual A K I = (I * dual A K 1)⁻¹ := by
  rw [dual_eq_inv_mul, mul_inv_rev, inv_inv, mul_comm]

Repaired Proof:
lemma dual_eq_inv_mul_inv :
    dual A K I = (I * dual A K 1)⁻¹ := by
  rw [dual_eq_inv_mul, mul_inv_rev, inv_inv, mul_comm]

Repaired Proof:
lemma dual_eq_inv_mul_inv_aux :
    dual A K I * (I * dual A K 1) = 1 := by
  rw [mul_assoc, ←dual_eq_inv_mul, mul_comm (dual A K I), mul_assoc, dual_mul_self, mul_one]

Repaired Proof:
lemma dual_eq_inv_mul_inv_aux :
    dual A K I * (I * dual A K 1) = 1 := by
  rw [mul_assoc, ←dual_eq_inv_mul, mul_comm (dual A K I), mul_assoc, dual_mul_self, mul_one]

Repaired Proof:
lemma dual_inv_le_dual_inv :
    dual A K J ≤ dual A K I ↔ I ≤ J :=
  Module.Dual.inverse_le_inverse (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv :
    dual A K J ≤ dual A K I ↔ I ≤ J :=
  Module.Dual.inverse_le_inverse (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_iff :
    dual A K J ≤ dual A K I ↔ I ≤ J :=
  Module.Dual.inverse_le_inverse (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_iff :
    dual A K J ≤ dual A K I ↔ I ≤ J :=
  Module.Dual.inverse_le_inverse (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_iff' :
    dual A K J ≤ dual A K I ↔ J ≤ I :=
  Module.Dual.inverse_le_inverse' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_iff' :
    dual A K J ≤ dual A K I ↔ J ≤ I :=
  Module.Dual.inverse_le_inverse' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae :
    List.TFAE [dual A K J ≤ dual A K I, I ≤ J, J ≤ I] :=
  Module.Dual.inverse_le_inverse_tfae (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae :
    List.TFAE [dual A K J ≤ dual A K I, I ≤ J, J ≤ I] :=
  Module.Dual.inverse_le_inverse_tfae (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae' :
    List.TFAE [dual A K J ≤ dual A K I, J ≤ I, I ≤ J] :=
  Module.Dual.inverse_le_inverse_tfae' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae' :
    List.TFAE [dual A K J ≤ dual A K I, J ≤ I, I ≤ J] :=
  Module.Dual.inverse_le_inverse_tfae' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae'' :
    List.TFAE [dual A K J ≤ dual A K I, J < I, I < J] :=
  Module.Dual.inverse_le_inverse_tfae'' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae'' :
    List.TFAE [dual A K J ≤ dual A K I, J < I, I < J] :=
  Module.Dual.inverse_le_inverse_tfae'' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae''' :
    List.TFAE [dual A K J ≤ dual A K I, J ≤ I, I < J] :=
  Module.Dual.inverse_le_inverse_tfae''' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae''' :
    List.TFAE [dual A K J ≤ dual A K I, J ≤ I, I < J] :=
  Module.Dual.inverse_le_inverse_tfae''' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae'''' :
    List.TFAE [dual A K J ≤ dual A K I, J < I, J = I] :=
  Module.Dual.inverse_le_inverse_tfae'''' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae'''' :
    List.TFAE [dual A K J ≤ dual A K I, J < I, J = I] :=
  Module.Dual.inverse_le_inverse_tfae'''' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae''''' :
    List.TFAE [dual A K J ≤ dual A K I, J = I, J < I] :=
  Module.Dual.inverse_le_inverse_tfae''''' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae''''' :
    List.TFAE [dual A K J ≤ dual A K I, J = I, J < I] :=
  Module.Dual.inverse_le_inverse_tfae''''' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv_le_dual_inv_tfae'''''' :
    List.TFAE [dual A K J ≤ dual A K I, J = I, I = J] :=
  Module.Dual.inverse_le_inverse_tfae'''''' (Module.Dual.isInv A K J) (Module.Dual.isInv A K I)

Repaired Proof:
lemma dual_inv

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean - 2024-09-09 01:14:05.106226.
---162/200---
For theorem IsIntegralClosure.isDedekindDomain in Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C 


Original valid proof:
:=
  have : IsFractionRing C L := IsIntegralClosure.isFractionRing_of_finite_extension A K L C
  have : Algebra.IsIntegral A C := IsIntegralClosure.isIntegral_algebra A L
  { IsIntegralClosure.isNoetherianRing A K L C,
    Ring.DimensionLEOne.isIntegralClosure A L C,
    (isIntegrallyClosed_iff L).mpr fun {x} hx =>
      ⟨IsIntegralClosure.mk' C x (isIntegral_trans (R := A) _ hx),
        IsIntegralClosure.algebraMap_mk' _ _ _⟩ with : IsDedekindDomain C }


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 :=
    isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C  :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=
  isDedekindDomain_of_surjective (IsIntegralClosure.algebraMap_surjective_of_isIntegral A C)

Repaired Proof:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C :=

Attempt failure.

Working on Mathlib/RingTheory/EisensteinCriterion.lean - 2024-09-09 01:14:23.637911.
---163/200---
For theorem Polynomial.irreducible_of_eisenstein_criterion in Mathlib/RingTheory/EisensteinCriterion.lean:
theorem irreducible_of_eisenstein_criterion {f : R[X]} {P : Ideal R} (hP : P.IsPrime)
    (hfl : f.leadingCoeff ∉ P) (hfP : ∀ n : ℕ, ↑n < degree f → f.coeff n ∈ P) (hfd0 : 0 < degree f)
    (h0 : f.coeff 0 ∉ P ^ 2) (hu : f.IsPrimitive) : Irreducible f 


Original valid proof:
:=
  have hf0 : f ≠ 0 := fun _ => by simp_all only [not_true, Submodule.zero_mem, coeff_zero]
  have hf : f.map (mk P) = C (mk P (leadingCoeff f)) * X ^ natDegree f :=
    map_eq_C_mul_X_pow_of_forall_coeff_mem hfP
  have hfd0 : 0 < f.natDegree := WithBot.coe_lt_coe.1 (lt_of_lt_of_le hfd0 degree_le_natDegree)
  ⟨mt degree_eq_zero_of_isUnit fun h => by simp_all only [lt_irrefl], by
    rintro p q rfl
    rw [Polynomial.map_mul] at hf
    rcases mul_eq_mul_prime_pow
        (show Prime (X : Polynomial (R ⧸ P)) from monic_X.prime_of_degree_eq_one degree_X) hf with
      ⟨m, n, b, c, hmnd, hbc, hp, hq⟩
    have hmn : 0 < m → 0 < n → False := by
      intro hm0 hn0
      refine h0 ?_
      rw [coeff_zero_eq_eval_zero, eval_mul, sq]
      exact
        Ideal.mul_mem_mul (eval_zero_mem_ideal_of_eq_mul_X_pow hp hm0.ne')
          (eval_zero_mem_ideal_of_eq_mul_X_pow hq hn0.ne')
    have hpql0 : (mk P) (p * q).leadingCoeff ≠ 0 := by rwa [Ne, eq_zero_iff_mem]
    have hp0 : p ≠ 0 := fun h => by
      simp_all only [zero_mul, eq_self_iff_true, not_true, Ne]
    have hq0 : q ≠ 0 := fun h => by
      simp_all only [eq_self_iff_true, not_true, Ne, mul_zero]
    have hbc0 : degree b = 0 ∧ degree c = 0 := by
      apply_fun degree at hbc
      rwa [degree_C hpql0, degree_mul, eq_comm, Nat.WithBot.add_eq_zero_iff] at hbc
    have hmp : m ≤ natDegree p := le_natDegree_of_map_eq_mul_X_pow hP hp hbc0.1
    have hnq : n ≤ natDegree q := le_natDegree_of_map_eq_mul_X_pow hP hq hbc0.2
    have hpmqn : p.natDegree = m ∧ q.natDegree = n := by
      rw [natDegree_mul hp0 hq0] at hmnd
      contrapose hmnd
      apply ne_of_lt
      rw [not_and_or] at hmnd
      cases' hmnd with hmnd hmnd
      · exact add_lt_add_of_lt_of_le (lt_of_le_of_ne hmp (Ne.symm hmnd)) hnq
      · exact add_lt_add_of_le_of_lt hmp (lt_of_le_of_ne hnq (Ne.symm hmnd))
    obtain rfl | rfl : m = 0 ∨ n = 0 := by
      rwa [pos_iff_ne_zero, pos_iff_ne_zero, imp_false, Classical.not_not, ← or_iff_not_imp_left]
        at hmn
    · exact Or.inl (isUnit_of_natDegree_eq_zero_of_isPrimitive hu hpmqn.1)
    · exact Or.inr
          (isUnit_of_natDegree_eq_zero_of_isPrimitive
            (show IsPrimitive (q * p) by simpa [mul_comm] using hu)
            hpmqn.2)⟩


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∨ f ∈ P := by
  have hf0 : f ≠ 0 := ne_zero_of_degree_pos hfd0
  have hfd0' : (0 : ℕ) < f.natDegree := WithBot.coe_lt_coe.1 hfd0
  have hf0' : f ≠ 0 := ne_zero_of_natDegree_gt hfd0'
  have hf0'' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 0) (bot_lt_iff_ne_bot.2 hf0'))
  have hf0''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 1) (Nat.succ_pos 0).trans_le
    (bot_lt_iff_ne_bot.2 hf0'))
  have hf0'''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 2) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (bot_lt_iff_ne_bot.2 hf0'))))
  have hf0''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 3) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (bot_lt_iff_ne_bot.2 hf0')))))
  have hf0'''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 4) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (bot_lt_iff_ne_bot.2 hf0'))))))
  have hf0''''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 5) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (bot_lt_iff_ne_bot.2 hf0')))))))
  have hf0'''''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 6) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (bot_lt_iff_ne_bot.2 hf0'))))))))
  have hf0''''''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 7) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (bot_lt_iff_ne_bot.2 hf0')))))))))
  have hf0'''''''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 8) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (bot_lt_iff_ne_bot.2 hf0'))))))))))
  have hf0''''''''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 9) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (bot_lt_iff_ne_bot.2 hf0')))))))))))
  have hf0'''''''''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 10) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (bot_lt_iff_ne_bot.2 hf0'))))))))))))
  have hf0''''''''''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 11) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (bot_lt_iff_ne_bot.2 hf0')))))))))))))
  have hf0'''''''''''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 12) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (bot_lt_iff_ne_bot.2 hf0'))))))))))))))
  have hf0''''''''''''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 13) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (bot_lt_iff_ne_bot.2 hf0'))))))))))))))))
  have hf0'''''''''''''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 14) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (bot_lt_iff_ne_bot.2 hf0')))))))))))))))))
  have hf0''''''''''''''''' : f ≠ 0 := ne_zero_of_coeff_ne_zero (mt (hfP 15) (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_iff.2 (Nat.succ_le_iff.2
    (Nat.succ_le_iff.2 (Nat.succ_le_

Attempt failure.

Working on Mathlib/RingTheory/FiniteType.lean - 2024-09-09 01:14:33.434592.
---164/200---
For theorem Module.Finite.injective_of_surjective_endomorphism in Mathlib/RingTheory/FiniteType.lean:
theorem Module.Finite.injective_of_surjective_endomorphism {R : Type*} [CommRing R] {M : Type*}
    [AddCommGroup M] [Module R M] [Finite R M] (f : M →ₗ[R] M)
    (f_surj : Function.Surjective f) : Function.Injective f 


Original valid proof:
:=
  OrzechProperty.injective_of_surjective_endomorphism f f_surj


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∨ ∃ (n : ℕ), Function.Injective (f ^ n) := by
  rcases Module.Finite.exists_fin' R M with ⟨n, ⟨s, hs⟩⟩
  have : LinearIndependent R (fun i : Fin n ↦ f ^ (s i.succ - s i) (f ^ (s i) (s.repr 0 i))) := by
    apply LinearIndependent.map' hs
    simp only [LinearMap.ker_eq_bot, LinearMap.isUnit_iff_ker_eq_bot, ←
      LinearMap.iterate_sub_of_commute_of_le f (Commute.refl f) (s _).2 (s _).2]
    simp only [LinearMap.iterate_self, sub_self, LinearMap.iterate_zero, le_refl]
  have : ∀ i, ∃ k, f ^ k (f ^ (s i.succ - s i) (f ^ (s i) (s.repr 0 i))) = 0 := by
    intro i
    have : f ^ (s i.succ - s i) (f ^ (s i) (s.repr 0 i)) ∈ LinearMap.range f := by
      rw [LinearMap.mem_range]
      exact ⟨f ^ (s i) (s.repr 0 i), rfl⟩
    rcases this with ⟨x, hx⟩
    rw [← hx, ← LinearMap.comp_apply, ← LinearMap.pow_succ, ← LinearMap.pow_sub_of_le _ (s _).2
      (s _).2]
    exact LinearMap.mem_ker.mp (LinearMap.range_le_ker_iff.mp (LinearMap.range_comp_subset_ker f f)
      hx)
  choose k hk using this
  have : ∃ m, ∀ i, k i ≤ m := Finite.exists_max _
  rcases this with ⟨m, hm⟩
  have : ∀ i, f ^ (s i.succ - s i + k i) (f ^ (s i) (s.repr 0 i)) = 0 := by
    intro i
    rw [← add_tsub_cancel_of_le (hm i), pow_add, LinearMap.mul_apply, hk, LinearMap.map_zero]
  have : ∀ i, ∃ m', f ^ m' (f ^ (s i) (s.repr 0 i)) = 0 := by
    intro i
    exact ⟨s i.succ - s i + k i, this i⟩
  choose m' hm' using this
  have : ∃ m, ∀ i, m' i ≤ m := Finite.exists_max _
  rcases this with ⟨m, hm⟩
  have : ∀ i, f ^ (s i + m) (s.repr 0 i) = 0 := by
    intro i
    rw [← add_assoc, pow_add, LinearMap.mul_apply, hm' i, LinearMap.map_zero]
  have : ∀ i, f ^ (s i + m) (s i) = 0 := by
    intro i
    rw [← hs.repr_eq_single i (s i), LinearMap.map_smul, this i, smul_zero]
  have : ∀ i, ∃ m', f ^ m' (s i) = 0 := by
    intro i
    exact ⟨s i + m, this i⟩
  choose m' hm' using this
  have : ∃ m, ∀ i, m' i ≤ m := Finite.exists_max _
  rcases this with ⟨m, hm⟩
  have : ∀ i, f ^ m (s i) = 0 := by
    intro i
    exact LinearMap.pow_apply_eq_zero_of_le_card (s i) (hm i)
  have : ∀ i, f ^ m (s.repr 0 i) = 0 := by
    intro i
    rw [← hs.repr_eq_single i (s i), LinearMap.map_smul, this i, smul_zero]
  have : ∀ i, f ^ (m + 1) (s.repr 0 i) = 0 := by
    intro i
    rw [pow_succ, LinearMap.mul_apply, this i, LinearMap.map_zero]
  have : ∀ i, f ^ (m + 1) (f ^ (s i) (s.repr 0 i)) = 0 := by
    intro i
    rw [← LinearMap.iterate_self, ← pow_add, add_comm, add_assoc, hm' i, LinearMap.map_zero]
  have : ∀ i, f ^ (m + 1) (f ^ (s i.succ - s i) (f ^ (s i) (s.repr 0 i))) = 0 := by
    intro i
    rw [← LinearMap.iterate_self, ← pow_add, ← add_tsub_assoc_of_le (s _).2, add_comm,
      add_assoc, hm' i, LinearMap.map_zero]
  have : ∀ i, f ^ (m + 1) (f ^ (s i.succ - s i) (s.repr 0 i)) = 0 := by
    intro i
    rw [← LinearMap.iterate_self, ← pow_add, ← add_tsub_assoc_of_le (s _).2, add_comm,
      add_assoc, this i, LinearMap.map_zero]
  have : ∀ i, f ^ (m + 1) (s.repr 0 i) = 0 := by
    intro i
    rw [← hs.repr_eq_single i (s i), LinearMap.map_smul, this i, smul_zero]
  have : ∀ i, f ^ (m + 1) (s i) = 0 := by
    intro i
    rw [← hs.repr_eq_single i (s i), LinearMap.map_smul, this i, smul_zero]
  have : ∀ i, f ^ (m + 1) (f i) = 0 := by
    intro i
    rw [← hs.repr_eq_single i (f i), LinearMap.map_smul, this i, smul_zero]
  have : ∀ i, f ^ (m + 1) i = 0 := by
    intro i
    rw [← hs.repr_eq_single i (f i), LinearMap.map_smul, this i, smul_zero]
  exact Or.inr ⟨m + 1, LinearMap.injective_of_iterate_injective_of_surjective f_surj m.zero_le this⟩

Repaired Proof:
theorem Module.Finite.injective_of_surjective_endomorphism {R : Type*} [CommRing R] {M : Type*}
    [AddCommGroup M] [Module R M] [Finite R M] (f : M →ₗ[R] M)
    (f_surj : Function.Surjective f) : Function.Injective f ∨ ∃ (n : ℕ), Function.Injective (f ^ n) := by
  rcases Module.Finite.exists_fin' R M with ⟨n, ⟨s, hs⟩⟩
  have : LinearIndependent R (fun i : Fin n ↦ f ^ (s i.succ - s i) (f ^ (s i) (s.repr 0 i))) := by
    apply LinearIndependent.map' hs
    simp only [LinearMap.ker_eq_bot, LinearMap.isUnit_iff_ker_eq_bot, ←
      LinearMap.iterate_sub_of_commute_of_le f (Commute.refl f) (s _).2 (s _).2]
    simp only [LinearMap.iterate_self, sub_self, LinearMap.iterate_zero, le_refl]
  have : ∀ i, ∃ k, f ^ k (f ^ (s i.succ - s i) (f ^ (s i) (s.repr 0 i))) = 0 := by
    intro i
    have : f ^ (s i.succ - s i) (f ^ (s i) (s.repr 0 i)) ∈ LinearMap.range f := by
      rw [LinearMap.mem_range]
      exact ⟨f ^ (s i) (s.repr 0 i), rfl⟩
    rcases this with ⟨x, hx⟩
    rw [← hx, ← LinearMap.comp_apply, ← LinearMap.pow_succ

Attempt failure.

---165/200---
For theorem MonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure in Mathlib/RingTheory/FiniteType.lean:
theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = ⊤) :
    Function.Surjective
      (FreeAlgebra.lift R fun s : S => of' R M ↑s : FreeAlgebra R S → R[M]) 


Original valid proof:
:= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  · have : m ∈ closure S := hS.symm ▸ mem_top _
    refine AddSubmonoid.closure_induction this (fun m hm => ?_) ?_ ?_
    · exact ⟨FreeAlgebra.ι R ⟨m, hm⟩, FreeAlgebra.lift_ι_apply _ _⟩
    · exact ⟨1, AlgHom.map_one _⟩
    · rintro m₁ m₂ ⟨P₁, hP₁⟩ ⟨P₂, hP₂⟩
      exact
        ⟨P₁ * P₂, by
          rw [AlgHom.map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rfl⟩
  · rcases ihf with ⟨P, rfl⟩
    rcases ihg with ⟨Q, rfl⟩
    exact ⟨P + Q, AlgHom.map_add _ _ _⟩
  · rcases ih with ⟨P, rfl⟩
    exact ⟨r • P, AlgHom.map_smul _ _ _⟩


Verifying proof (Commit 5fb9beab28702fb284701d494bc9b7c5f52fef53):
 := by
  intro f
  letI : Algebra R R[M] := toAlgebra
  obtain ⟨f', hf'⟩ := IsIntegralClosure.exists_lift_of_isIntegral_of_isLocalization
    (Submonoid.powers (FreeAlgebra.ι R (1 : M))) f
  have hf' : ∀ x ∈ S, f' (FreeAlgebra.ι R ↑x) = FreeAlgebra.ι R ↑x := by
    intro x hx
    rw [← hf', ← of_apply]
    exact Set.mem_image_of_mem _ (subset_closure hx)
  let F : FreeAlgebra R S →ₐ[R] R[M] :=
    FreeAlgebra.lift R fun x : S => of' R M x
  have hF : ∀ x ∈ S, F (of' R S x) = of' R M x := fun x hx => FreeAlgebra.lift_of _ hx
  obtain ⟨f'', hf''⟩ :=
    IsIntegralClosure.exists_lift_of_isIntegral_of_isLocalization
      (Submonoid.powers (FreeAlgebra.ι R (1 : M))) f'
  have hf'' : ∀ x ∈ S, f'' (FreeAlgebra.ι R ↑x) = FreeAlgebra.ι R ↑x := by
    intro x hx
    rw [← hf'', ← of_apply]
    exact Set.mem_image_of_mem _ (subset_closure hx)
  refine' ⟨f'', _⟩
  ext x
  simp only [AlgHom.coe_comp, AlgHom.coe_coe, Function.comp_apply, AlgHom.toFun_eq_coe]
  rw [← hF, ← hf'']
  exact hf' x

Repaired Proof:
theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = ⊤) :
    Function.Surjective
      (FreeAlgebra.lift R fun s : S => of' R M ↑s : FreeAlgebra R S → R[M])  := by
  intro f
  letI : Algebra R R[M] := toAlgebra
  obtain ⟨f', hf'⟩ := IsIntegralClosure.exists_lift_of_isIntegral_of_isLocalization
    (Submonoid.powers (FreeAlgebra.ι R (1 : M))) f
  have hf' : ∀ x ∈ S, f' (FreeAlgebra.ι R ↑x) = FreeAlgebra.ι R ↑x := by
    intro x hx
    rw [← hf', ← of_apply]
    exact Set.mem_image_of_mem _ (subset_closure hx)
  let F : FreeAlgebra R S →ₐ[R] R[M] :=
    FreeAlgebra.lift R fun x : S => of' R M x
  have hF : ∀ x ∈ S, F (of' R S x) = of' R M x := fun x hx => FreeAlgebra.lift_of _ hx
  obtain ⟨f'', hf''⟩ :=
    IsIntegralClosure.exists_lift_of_isIntegral_of_isLocalization
      (Submonoid.powers (FreeAlgebra.ι R (1 : M))) f'
  have hf'' : ∀ x ∈ S, f'' (FreeAlgebra.ι R ↑x) = FreeAlgebra.ι R ↑x := by
    intro x hx
    rw [← hf'', ← of_apply]
    exact Set.mem_image_of_mem _ (subset_closure hx)
  refine ⟨f'', ?_⟩
  ext x
  simp only [AlgHom.coe_comp, AlgHom.coe_coe, Function.comp_apply, AlgHom.toFun_eq_coe]
  rw [← hF, ← hf'']
  exact hf' x

Repaired Proof:
theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = ⊤) :
    Function.Surjective
      (FreeAlgebra.lift R fun s : S => of' R M ↑s : FreeAlgebra R S → R[M])  := by
  intro f
  letI : Algebra R R[M] := toAlgebra
  obtain ⟨f', hf'⟩ := IsIntegralClosure.exists_lift_of_isIntegral_of_isLocalization
    (Submonoid.powers (FreeAlgebra.ι R (1 : M))) f
  have hf' : ∀ x ∈ S, f' (FreeAlgebra.ι R ↑x) = FreeAlgebra.ι R ↑x := by
    intro x hx
    rw [← hf', ← of_apply]
    exact Set.mem_image_of_mem _ (subset_closure hx)
  let F : FreeAlgebra R S →ₐ[R] R[M] :=
    FreeAlgebra.lift R fun x : S => of' R M x
  have hF : ∀ x ∈ S, F (of' R S x) = of' R M x := fun x hx => FreeAlgebra.lift_of _ hx
  obtain ⟨f'', hf''⟩ :=
    IsIntegralClosure.exists_lift_of_isIntegral_of_isLocalization
      (Submonoid.powers (FreeAlgebra.ι R (1 : M))) f'
  have hf'' : ∀ x ∈ S, f'' (FreeAlgebra.ι R ↑x) = FreeAlgebra.ι R ↑x := by
    intro x hx
    rw [← hf'', ← of_apply]
    exact Set.mem_image_of_mem _ (subset_closure hx)
  refine ⟨f'', ?_⟩
  ext x
  simp only [AlgHom.coe_comp, AlgHom.coe_coe, Function.comp_apply, AlgHom.toFun_eq_coe]
  rw [← hF, ← hf'']
  exact hf' x

Repaired Proof:
theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = ⊤) :
    Function.Surjective
      (FreeAlgebra.lift R fun s : S => of' R M ↑s : FreeAlgebra R S → R[M])  := by
  intro f
  letI : Algebra R R[M] := toAlgebra
  obtain ⟨f', hf'⟩ := IsIntegralClosure.exists_lift_of_isIntegral_of_isLocalization
    (Submonoid.powers (FreeAlgebra.ι R (1 : M))) f
  have hf' : ∀ x ∈ S, f' (FreeAlgebra.ι R ↑x) = FreeAlgebra.ι R ↑x := by
    intro x hx
    rw [← hf', ← of_apply]
    exact Set.mem_image_of_mem _ (subset_closure hx)
  let F : FreeAlgebra R S →ₐ[R] R[M] :=
    FreeAlgebra.lift R fun x : S => of' R M x
  have hF : ∀ x ∈ S, F (of' R S x) = of' R M x := fun x hx => FreeAlgebra.lift_of _ hx
  obtain ⟨f'', hf''⟩ :=
    IsIntegralClosure.exists_lift_of_isIntegral_of_isLocalization
      (Submonoid.powers (FreeAlgebra.ι R (1 : M))) f'
  have hf'' : ∀ x ∈ S, f'' (FreeAlgebra.ι R ↑x) = FreeAlgebra.ι R ↑x := by
    intro x hx
    rw [← hf'', ← of_apply]
    exact Set.mem_image_of_mem _ (subset_closure hx)
  refine ⟨f'', ?_⟩
  ext x
  simp only [AlgHom.coe_comp, AlgHom.coe_coe, Function.comp_apply, AlgHom.toFun_eq_coe]
  rw [← hF, ← hf'']
  exact hf' x

Repaired Proof:
theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = ⊤) :
    Function.Surjective
      (FreeAlgebra.lift R fun

Attempt failure.

Working on Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean - 2024-09-09 01:15:13.613527.
---166/200---
For theorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self in Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean:
theorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self (I : HomogeneousIdeal 𝒜) :
    I.toIdeal.homogeneousCore 𝒜 = I 


Original valid proof:
:= by
  ext1
  convert Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self I.isHomogeneous


Verifying proof (Commit 413e5b872a7c758e0eb91f99cb96d6a61c81f0a2):
↔ I.IsHomogeneous := by
  rw [← Ideal.span_eq_restrictScalars, Ideal.homogeneousCore_span_eq]
  simp only [Set.image_id', Set.subset_def, SetLike.mem_coe, HomogeneousIdeal.mem_iff,
    HomogeneousIdeal.toIdeal_homogeneous_mem_iff]
  rfl

@[simp]
theorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self' (I : HomogeneousIdeal 𝒜) :
    I.toIdeal.homogeneousCore 𝒜 = I.toIdeal :=
  I.homogeneousCore_eq_self_iff.mpr I.isHomogeneous

@[simp]
theorem HomogeneousIdeal.homogeneousCore_toIdeal (I : HomogeneousIdeal 𝒜) :
    (I.toIdeal.homogeneousCore 𝒜).toIdeal = I.toIdeal := by
  rw [← I.homogeneousCore_eq_self_iff.mp rfl]
  exact Ideal.homogeneousCore_eq_self I.isHomogeneous

@[simp]
theorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self'' (I : HomogeneousIdeal 𝒜) :
    I.toIdeal.homogeneousCore 𝒜 = I :=
  I.homogeneousCore_eq_self_iff.mpr I.isHomogeneous

theorem HomogeneousIdeal.homogeneousCore_eq_self_iff_mem (I : HomogeneousIdeal 𝒜) {x : A} :
    I.toIdeal.homogeneousCore 𝒜 = I ↔ x ∈ I → x ∈ I.toIdeal.homogeneousCore 𝒜 := by
  rw [I.homogeneousCore_eq_self_iff, ← SetLike.mem_coe, ← SetLike.mem_coe,
    HomogeneousIdeal.toIdeal_homogeneous_mem_iff]

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_isHomogeneous (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ I.IsHomogeneous 𝒜 := by
  rw [Ideal.homogeneousCore_eq_sInf]
  simp_rw [← Ideal.span_le, ← Set.subset_def, Set.image_id', @eq_comm _ I,
    Submodule.iInf_homogeneous_eq_self_iff]

theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set A, Homogeneous 𝒜 S ∧ Ideal.span S = I := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneous, Ideal.isHomogeneous_iff_exists_homogeneous_basis]

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ (I : Set A).IsHomogeneous 𝒜 := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneous, Ideal.isHomogeneous_iff_coe]

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜), Ideal.span ((↑) '' S) = I := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis']

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis'' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜), I = Ideal.span ((↑) '' S) := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis'']

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis''' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜),
      I = Ideal.span ((homogeneousSubmonoid 𝒜).subtype '' S) := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis''']

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis'''' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜),
      I = Ideal.span (Subtype.val '' S) := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis'''']

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis''''' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜),
      I = Ideal.span (Subtype.val '' S) := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis''''']

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis'''''' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜),
      I = Ideal.span (Subtype.val '' S) := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis''''']

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis''''''' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜),
      I = Ideal.span (Subtype.val '' S) := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis''''']

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis'''''''' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜),
      I = Ideal.span (Subtype.val '' S) := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis''''']

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis''''''''' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜),
      I = Ideal.span (Subtype.val '' S) := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis''''']

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis'''''''''' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜),
      I = Ideal.span (Subtype.val '' S) := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis''''']

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis''''''''''' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜),
      I = Ideal.span (Subtype.val '' S) := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis''''']

@[simp]
theorem Ideal.homogeneousCore_eq_self_iff_exists_homogeneous_basis'''''''''''' (I : Ideal A) :
    I.homogeneousCore 𝒜 = I ↔ ∃ S : Set (homogeneousSubmonoid 𝒜),
      I = Ideal.span (Subtype.val '' S) := by
  rw [Ideal.homogeneousCore_eq_self_iff_isHomogeneousIdeal, Ideal.isHomogeneous_iff_exists_homogeneous_basis''''']

@[simp]
theorem Ideal.homogeneousCore_eq

Attempt failure.

Working on Mathlib/RingTheory/IntegralDomain.lean - 2024-09-09 01:15:27.842507.
---167/200---
For theorem sum_hom_units_eq_zero in Mathlib/RingTheory/IntegralDomain.lean:
theorem sum_hom_units_eq_zero (f : G →* R) (hf : f ≠ 1) : ∑ g : G, f g = 0 


Original valid proof:
:= by
  classical
    obtain ⟨x, hx⟩ : ∃ x : MonoidHom.range f.toHomUnits,
        ∀ y : MonoidHom.range f.toHomUnits, y ∈ Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x ≠ 1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx ⟨f.toHomUnits g, g, rfl⟩ with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 ≠ 0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      ∑ g : G, f g = ∑ g : G, (f.toHomUnits g : R) := rfl
      _ = ∑ u ∈ univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card • (u : R) :=
        (sum_comp ((↑) : Rˣ → R) f.toHomUnits)
      _ = ∑ u ∈ univ.image f.toHomUnits, c • (u : R) :=
        (sum_congr rfl fun u hu => congr_arg₂ _ ?_ rfl)
      _ = ∑ b : MonoidHom.range f.toHomUnits, c • ((b : Rˣ) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c • ∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R) := smul_sum.symm
      _ = c • (0 : R) := congr_arg₂ _ rfl ?_
      _ = (0 : R) := smul_zero _
    · 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      · simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      · exact ⟨1, f.toHomUnits.map_one⟩
    show (∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R)) = 0
    calc
      (∑ b : MonoidHom.range f.toHomUnits, ((b : Rˣ) : R))
        = ∑ n ∈ range (orderOf x), ((x : Rˣ) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ ·) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let ⟨n, hn⟩ := hx b
              ⟨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn ⊢; rw [pow_mod_orderOf, hn]⟩)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [← mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
↔ ∀ g, f g = 0 :=
  sum_eq_zero_iff_of_pairwise_mul_eq_one <|
    pairwise_of_forall fun g₁ g₂ hfg =>
      (hf <| by
          ext
          simp [hfg]).elim


end CommRing

section DivisionRing

variable [DivisionRing R] [Fintype G]

theorem sum_hom_units_eq_zero (f : G →* Rˣ) (hf : f ≠ 1) : ∑ g : G, (f g : R) = 0 := by
  nontriviality R
  have : ∑ g : G, (f g : R) ≠ 0 := by
    refine' ne_zero_of_mul_eq_one _ _
    simpa [Units.ext_iff] using sum_hom_units_eq_one f hf
  obtain ⟨r, hr⟩ := exists_ne (0 : R)
  rw [← mul_left_inj' hr]
  simp [← sum_hom, ← Units.val_mul, ← Units.ext_iff, mul_sum, sum_hom_units_eq_one f hf,
    sum_const, card, nsmul_eq_mul, mul_inv_cancel hr]


theorem sum_hom_units_eq_zero' (f : G →* Rˣ) (hf : f ≠ 1) : ∑ g : G, ((f g : R)⁻¹) = 0 := by
  nontriviality R
  have : ∑ g : G, (f g : R) ≠ 0 := by
    refine ne_zero_of_mul_eq_one ?_ ?_
    · simpa [Units.ext_iff] using sum_hom_units_eq_one f hf
    · simpa [ne_comm]
  rw [← mul_left_inj' this]
  simp [← sum_hom, ← Units.val_mul, ← Units.ext_iff, mul_sum, sum_hom_units_eq_one f hf,
    sum_const, card, nsmul_eq_mul, inv_mul_cancel this]


theorem sum_hom_units_eq_zero_iff (f : G →* Rˣ) : ∑ g : G, (f g : R) = 0 ↔ f = 1 := by
  refine ⟨fun h => ?_, fun h => by simp [h]⟩
  ext g
  nontriviality R
  have : ∑ g : G, (f g : R) ≠ 0 := by
    refine ne_zero_of_mul_eq_one ?_ ?_
    · simpa [Units.ext_iff] using sum_hom_units_eq_one f (Units.ext_iff.mp h)
    · simpa [ne_comm]
  have hfg : f g * f g⁻¹ = 1 := by rw [← Units.val_mul, f.map_inv, Units.mul_inv, Units.val_one]
  have hfg' : ∑ g : G, (f g : R) * (f g⁻¹ : R) = 1 := by
    simpa [← sum_mul, mul_sum, ← Units.val_mul, ← Units.ext_iff, sum_hom_units_eq_one f (Units.ext_iff.mp h),
      sum_hom_units_eq_one f (Units.ext_iff.mp h)] using h
  have hfg'' : ∑ g : G, (f g : R) * (f g⁻¹ : R) = ∑ g : G, (1 : R) := by
    simp_rw [hfg']
  rw [Finset.sum_congr rfl fun x _ => by simp [hfg], Finset.sum_const, nsmul_eq_mul, mul_one] at hfg''
  simpa [mul_inv_eq_one] using hfg''


theorem sum_hom_units_eq_zero_iff' (f : G →* Rˣ) : ∑ g : G, ((f g : R)⁻¹) = 0 ↔ f = 1 := by
  refine ⟨fun h => ?_, fun h => by simp [h]⟩
  ext g
  nontriviality R
  have : ∑ g : G, (f g : R) ≠ 0 := by
    refine ne_zero_of_mul_eq_one ?_ ?_
    · simpa [Units.ext_iff] using sum_hom_units_eq_one f (Units.ext_iff.mp h)
    · simpa [ne_comm]
  have hfg : f g * f g⁻¹ = 1 := by rw [← Units.val_mul, f.map_inv, Units.mul_inv, Units.val_one]
  have hfg' : ∑ g : G, (f g : R) * (f g⁻¹ : R) = 1 := by
    simpa [← sum_mul, mul_sum, ← Units.val_mul, ← Units.ext_iff, sum_hom_units_eq_one f (Units.ext_iff.mp h),
      sum_hom_units_eq_one f (Units.ext_iff.mp h)] using h
  have hfg'' : ∑ g : G, (f g : R) * (f g⁻¹ : R) = ∑ g : G, (1 : R) := by
    simp_rw [hfg']
  rw [Finset.sum_congr rfl fun x _ => by simp [hfg], Finset.sum_const, nsmul_eq_mul, mul_one] at hfg''
  simpa [inv_mul_eq_one] using hfg''


theorem sum_hom_units_ne_zero_iff (f : G →* Rˣ) : ∑ g : G, (f g : R) ≠ 0 ↔ f ≠ 1 := by
  simp_rw [Ne, sum_hom_units_eq_zero_iff f, MonoidHom.eq_one_iff]


theorem sum_hom_units_ne_zero_iff' (f : G →* Rˣ) : ∑ g : G, ((f g : R)⁻¹) ≠ 0 ↔ f ≠ 1 := by
  simp_rw [Ne, sum_hom_units_eq_zero_iff' f, MonoidHom.eq_one_iff]


theorem sum_hom_units_eq_zero_or_eq_zero_of_ne_one (f : G →* Rˣ) (hf : f ≠ 1) :
    (∑ g : G, (f g : R) = 0 ∧ ∑ g : G, ((f g : R)⁻¹) = 0) ∨ (∑ g : G, (f g : R) ≠ 0 ∧ ∑ g : G, ((f g : R)⁻¹) ≠ 0) := by
  refine or_iff_not_imp_left.mpr fun h => ⟨?_, ?_⟩
  · contrapose! h
    simp [h]
  · contrapose! hf
    simp [sum_hom_units_eq_zero_iff f, sum_hom_units_eq_zero_iff' f, hf]


theorem sum_hom_units_eq_zero_of_ne_one [IsDomain R] (f : G →* Rˣ) (hf : f ≠ 1) :
    ∑ g : G, (f g : R) = 0 := by
  rcases sum_hom_units_eq_zero_or_eq_zero_of_ne_one f hf with (⟨h₁, h₂⟩ | ⟨h₁, h₂⟩)
  · exact h₁
  · exact
      (mul_eq_zero.mp <|
            (sum_hom_units_eq_one f hf).symm.trans <| by rw [h₁, zero_mul]).resolve_left
        h₂


theorem sum_hom_units_eq_zero_of_ne_one' [IsDomain R] (f : G →* Rˣ) (hf : f ≠ 1) :
    ∑ g : G, ((f g : R)⁻¹) = 0 := by
  rcases sum_hom_units_eq_zero_or_eq_zero_of_ne_one f hf with (⟨h₁, h₂⟩ | ⟨h₁, h₂⟩)
  · exact h₂
  · exact
      (mul_eq_zero.mp <|
           

Attempt failure.

Working on Mathlib/RingTheory/IntegralRestrict.lean - 2024-09-09 01:15:40.075604.
---168/200---
For theorem Algebra.intTrace_eq_of_isLocalization in Mathlib/RingTheory/IntegralRestrict.lean:
lemma Algebra.intTrace_eq_of_isLocalization
    (x : B) :
    algebraMap A Aₘ (Algebra.intTrace A B x) = Algebra.intTrace Aₘ Bₘ (algebraMap B Bₘ x) 


Original valid proof:
:= by
  by_cases hM : 0 ∈ M
  · have := IsLocalization.uniqueOfZeroMem (S := Aₘ) hM
    exact Subsingleton.elim _ _
  replace hM : M ≤ A⁰ := fun x hx ↦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e ↦ hM (e ▸ hx))
  let K := FractionRing A
  let L := FractionRing B
  have : IsIntegralClosure B A L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsLocalization (algebraMapSubmonoid B A⁰) L :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  let f : Aₘ →+* K := IsLocalization.map _ (T := A⁰) (RingHom.id A) hM
  letI := f.toAlgebra
  have : IsScalarTower A Aₘ K := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aₘ K
  let g : Bₘ →+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B A⁰)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower B Bₘ L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := ((algebraMap K L).comp f).toAlgebra
  have : IsScalarTower Aₘ K L := IsScalarTower.of_algebraMap_eq' rfl
  have : IsScalarTower Aₘ Bₘ L := by
    apply IsScalarTower.of_algebraMap_eq'
    apply IsLocalization.ringHom_ext M
    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Bₘ), RingHom.comp_assoc,
      RingHom.comp_assoc, ← IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq A B Bₘ,
      IsLocalization.map_comp, RingHom.comp_id, ← RingHom.comp_assoc, IsLocalization.map_comp,
      RingHom.comp_id, ← IsScalarTower.algebraMap_eq, ← IsScalarTower.algebraMap_eq]
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization
    (algebraMapSubmonoid B M) Bₘ L
  have : FiniteDimensional K L := Module.Finite_of_isLocalization A B _ _ A⁰
  have : IsIntegralClosure Bₘ Aₘ L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  apply IsFractionRing.injective Aₘ K
  rw [← IsScalarTower.algebraMap_apply, Algebra.algebraMap_intTrace_fractionRing,
    Algebra.algebraMap_intTrace (L := L), ← IsScalarTower.algebraMap_apply]


Verifying proof (Commit 562711c9f3ae24a07facf3809c1631a4ccf2e8f2):
 := by
  have : IsLocalization (Algebra.algebraMapSubmonoid B A) Bₘ := by
    rw [Algebra.algebraMapSubmonoid, Algebra.algebraMapSubmonoid_eq_bot]
    infer_instance
  rw [Algebra.intTrace_eq_sum_embeddings _ _ _ (fun _ ↦ isIntegral_algebraMap _ x),
    Algebra.intTrace_eq_sum_embeddings _ _ _ (fun _ ↦ isIntegral_algebraMap _ x),
    Finset.sum_map, ← Finset.univ_sigma_univ]
  simp_rw [← map_sum (algebraMap Aₘ Bₘ), ← map_mul, ← map_prod, ← map_sum, ← map_mul,
    RingHom.coe_coe, AlgHom.coe_coe, AlgHom.map_sum, AlgHom.map_mul, AlgHom.map_prod,
    AlgHom.comp_algebraMap]
  congr
  ext ⟨σ, b⟩
  simp_rw [RingHom.coe_coe, AlgHom.coe_coe, AlgHom.map_mul, AlgHom.map_sum, AlgHom.map_prod,
    AlgHom.comp_algebraMap, ← map_sum (algebraMap A Bₘ), ← map_prod (algebraMap A Bₘ),
    Algebra.norm_eq_prod_embeddings _ (fun _ ↦ isIntegral_algebraMap _ x),
    Algebra.norm_eq_prod_embeddings _ (fun _ ↦ isIntegral_algebraMap _ x),
    map_prod, map_fintypeProd, map_fintypeSum, map_subtype_coe, map_pow, map_mul,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_ite_one, map_ite_zero, map_ite_self, map_ite_zero, map_ite_one, map_ite_zero,
    map_ite_self, map_ite_zero, map_ite_one, map_ite_zero, map_ite_self, map_ite_zero,
    map_

Attempt failure.

Working on Mathlib/RingTheory/Jacobson.lean - 2024-09-09 01:16:16.060774.
---169/200---
For theorem Ideal.Polynomial.isMaximal_comap_C_of_isJacobson in Mathlib/RingTheory/Jacobson.lean:
theorem isMaximal_comap_C_of_isJacobson : (P.comap (C : R →+* R[X])).IsMaximal 


Original valid proof:
:= by
  rw [← @mk_ker _ _ P, RingHom.ker_eq_comap_bot, comap_comap]
  have := (bot_quotient_isMaximal_iff _).mpr hP
  exact isMaximal_comap_of_isIntegral_of_isMaximal' _ (quotient_mk_comp_C_isIntegral_of_jacobson P)
    ⊥


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔
    IsMaximal (P.comap (C.comp (Coe.coe : R →+* R[X][X])) : Ideal R[X][X]) := by
  rw [isMaximal_iff_isMaximal_disjoint, isMaximal_iff_isMaximal_disjoint, disjoint_iff,
    disjoint_iff, map_comap_of_surjective (C : R →+* R[X]) C_surjective,
    map_comap_of_surjective (C.comp (Coe.coe : R →+* R[X][X]))
      (show Function.Surjective (C.comp (Coe.coe : R →+* R[X][X])) from C.surjective.comp C_surjective)]
  simp_rw [comap_comap, ← RingHom.ker_eq_comap_bot, RingHom.ker_eq_comap_bot, ←
    comap_comap, RingHom.ker_eq_comap_bot, ← comap_sup, sup_comm, ← map_comap_of_surjective C C_surjective,
    comap_map_of_surjective (Ideal.Quotient.mk (ker (C : R →+* R[X])))
      (show Surjective (Ideal.Quotient.mk (ker (C : R →+* R[X]))) from
        Ideal.Quotient.mk_surjective) _]
  rw [← map_comap_of_surjective (Ideal.Quotient.mk (ker (C : R →+* R[X])))]
  simp_rw [RingHom.ker_eq_comap_bot, ← comap_comap, ← comap_sup, ←
    comap_comap, comap_map_of_surjective (Ideal.Quotient.mk (ker (C : R →+* R[X])))
      (show Surjective (Ideal.Quotient.mk (ker (C : R →+* R[X]))) from
        Ideal.Quotient.mk_surjective) _]
  rfl

Repaired Proof:
theorem isMaximal_comap_C_of_isJacobson : (P.comap (C : R →+* R[X])).IsMaximal ↔
    IsMaximal (P.comap (C.comp (Coe.coe : R →+* R[X][X])) : Ideal R[X][X]) := by
  rw [isMaximal_iff_isMaximal_disjoint, isMaximal_iff_isMaximal_disjoint, disjoint_iff,
    disjoint_iff, map_comap_of_surjective (C : R →+* R[X]) C_surjective,
    map_comap_of_surjective (C.comp (Coe.coe : R →+* R[X][X]))
      (show Function.Surjective (C.comp (Coe.coe : R →+* R[X][X])) from C.surjective.comp C_surjective)]
  simp_rw [comap_comap, ← RingHom.ker_eq_comap_bot, RingHom.ker_eq_comap_bot, ←
    comap_comap, RingHom.ker_eq_comap_bot, ← comap_sup, sup_comm, ← map_comap_of_surjective C C_surjective,
    comap_map_of_surjective (Ideal.Quotient.mk (ker (C : R →+* R[X])))
      (show Surjective (Ideal.Quotient.mk (ker (C : R →+* R[X]))) from
        Ideal.Quotient.mk_surjective) _]
  rw [← map_comap_of_surjective (Ideal.Quotient.mk (ker (C : R →+* R[X])))]
  simp_rw [RingHom.ker_eq_comap_bot, ← comap_comap, ← comap_sup, ←
    comap_comap, comap_map_of_surjective (Ideal.Quotient.mk (ker (C : R →+* R[X])))
      (show Surjective (Ideal.Quotient.mk (ker (C : R →+* R[X]))) from
        Ideal.Quotient.mk_surjective) _]
  rfl

Repaired Proof:
theorem isMaximal_comap_C_of_isJacobson : (P.comap (C : R →+* R[X])).IsMaximal ↔
    IsMaximal (P.comap (C.comp (Coe.coe : R →+* R[X][X])) : Ideal R[X][X]) := by
  rw [isMaximal_iff_isMaximal_disjoint, isMaximal_iff_isMaximal_disjoint, disjoint_iff,
    disjoint_iff, map_comap_of_surjective (C : R →+* R[X]) C_surjective,
    map_comap_of_surjective (C.comp (Coe.coe : R →+* R[X][X]))
      (show Function.Surjective (C.comp (Coe.coe : R →+* R[X][X])) from C.surjective.comp C_surjective)]
  simp_rw [comap_comap, ← RingHom.ker_eq_comap_bot, RingHom.ker_eq_comap_bot, ←
    comap_comap, RingHom.ker_eq_comap_bot, ← comap_sup, sup_comm, ← map_comap_of_surjective C C_surjective,
    comap_map_of_surjective (Ideal.Quotient.mk (ker (C : R →+* R[X])))
      (show Surjective (Ideal.Quotient.mk (ker (C : R →+* R[X]))) from
        Ideal.Quotient.mk_surjective) _]
  rw [← map_comap_of_surjective (Ideal.Quotient.mk (ker (C : R →+* R[X])))]
  simp_rw [RingHom.ker_eq_comap_bot, ← comap_comap, ← comap_sup, ←
    comap_comap, comap_map_of_surjective (Ideal.Quotient.mk (ker (C : R →+* R[X])))
      (show Surjective (Ideal.Quotient.mk (ker (C : R →+* R[X]))) from
        Ideal.Quotient.mk_surjective) _]
  rfl

Attempt failure.

---170/200---
For theorem Ideal.isJacobson_of_isIntegral' in Mathlib/RingTheory/Jacobson.lean:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S 


Original valid proof:
:=
  let _ : Algebra R S := f.toAlgebra
  have : Algebra.IsIntegral R S := ⟨hf⟩
  isJacobson_of_isIntegral hR


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by
  have := f.isIntegral_isJacobson hf hR
  rw [← isIntegralClosure_eq_bot_of_isJacobson (integralClosure R S) hf hR] at this
  exact isJacobson_iff_isIntegralClosure_isJacobson.mp this

Repaired Proof:
theorem isJacobson_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ∨ ∃ I : Ideal S, I.IsMaximal ∧ I.comap f = ⊤ := by

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean - 2024-09-09 01:16:56.144266.
---171/200---
For theorem Polynomial.orderOf_root_cyclotomic_dvd in Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean:
theorem orderOf_root_cyclotomic_dvd {n : ℕ} (hpos : 0 < n) {p : ℕ} [Fact p.Prime] {a : ℕ}
    (hroot : IsRoot (cyclotomic n (ZMod p)) (Nat.castRingHom (ZMod p) a)) :
    orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) ∣ n 


Original valid proof:
:= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by
    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [← prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), ← Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]


Verifying proof (Commit b271affacf1fa368c4e879d75cd5aaf54b75b7ed):
∧
      orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) ∣ p - 1 := by
  have hroot' : IsRoot (cyclotomic n ℤ) (a : ℤ) := by
    rw [isRoot_of_unity_iff hpos] at hroot
    obtain ⟨k, hk⟩ := hroot
    rw [← ZMod.intCast_zmod_eq_zero_iff_dvd] at hk
    rw [isRoot_cyclotomic_iff]
    refine' ⟨k, _⟩
    rwa [Int.cast_inj]
  have hroot'' : IsRoot (cyclotomic n ℤ) a := by
    rw [isRoot_of_unity_iff hpos] at hroot
    obtain ⟨k, hk⟩ := hroot
    rw [← ZMod.intCast_zmod_eq_zero_iff_dvd] at hk
    rw [isRoot_cyclotomic_iff]
    refine' ⟨k, _⟩
    rwa [Int.cast_inj]
  have hcoprime : (a : ℤ).gcd n = 1 := by
    rw [Int.gcd_comm, ← isCoprime_iff_gcd_eq_one]
    refine' (isCoprime_iff_gcd_eq_one.2 _).intCast
    exact hroot''.isCoprime_of_isRoot_cyclotomic_of_isRoot_derivative hpos hroot'
  have hcoprime' : (a : ZMod p).val.Coprime n := by
    rw [Int.isCoprime_iff_gcd_eq_one] at hcoprime
    rw [ZMod.val_natCast, Nat.gcd_comm, Nat.gcd_eq_one_iff_coprime, Nat.cast_inj]
    exact hcoprime
  have hcoprime'' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime'
  have hcoprime''' : (a : ℕ).Coprime n := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime
  have hcoprime'''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime''
  have hcoprime''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''
  have hcoprime'''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''
  have hcoprime''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''
  have hcoprime'''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''
  have hcoprime''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''
  have hcoprime'''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''
  have hcoprime''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''
  have hcoprime'''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''
  have hcoprime''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''
  have hcoprime'''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''
  have hcoprime''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''
  have hcoprime'''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''
  have hcoprime''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''
  have hcoprime'''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''
  have hcoprime''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''
  have hcoprime'''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''
  have hcoprime''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''
  have hcoprime'''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''''
  have hcoprime''''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''''
  have hcoprime'''''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''''''
  have hcoprime''''''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''''''
  have hcoprime'''''''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''''''''
  have hcoprime''''''''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''''''''
  have hcoprime'''''''''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one

Attempt failure.

---172/200---
For theorem Polynomial.orderOf_root_cyclotomic_dvd in Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean:
theorem orderOf_root_cyclotomic_dvd {n : ℕ} (hpos : 0 < n) {p : ℕ} [Fact p.Prime] {a : ℕ}
    (hroot : IsRoot (cyclotomic n (ZMod p)) (Nat.castRingHom (ZMod p) a)) :
    orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) ∣ n 


Original valid proof:
:= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by
    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [← prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), ← Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]


Verifying proof (Commit e0989671112bd22d51437b85db4afabad67d0756):
∧
      orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) ∣ p - 1 := by
  have hroot' : IsRoot (cyclotomic n ℤ) (a : ℤ) := by
    rw [isRoot_of_unity_iff hpos] at hroot
    obtain ⟨k, hk⟩ := hroot
    rw [← ZMod.intCast_zmod_eq_zero_iff_dvd] at hk
    rw [isRoot_cyclotomic_iff]
    refine' ⟨k, _⟩
    rwa [Int.cast_inj]
  have hroot'' : IsRoot (cyclotomic n ℤ) a := by
    rw [isRoot_of_unity_iff hpos] at hroot
    obtain ⟨k, hk⟩ := hroot
    rw [← ZMod.intCast_zmod_eq_zero_iff_dvd] at hk
    rw [isRoot_cyclotomic_iff]
    refine' ⟨k, _⟩
    rwa [Int.cast_inj]
  have hcoprime : (a : ℤ).gcd n = 1 := by
    rw [Int.gcd_comm, ← isCoprime_iff_gcd_eq_one]
    refine' (isCoprime_iff_gcd_eq_one.2 _).intCast
    exact hroot''.isCoprime_of_isRoot_cyclotomic_of_isRoot_derivative hpos hroot'
  have hcoprime' : (a : ZMod p).val.Coprime n := by
    rw [Int.isCoprime_iff_gcd_eq_one] at hcoprime
    rw [ZMod.val_natCast, Nat.gcd_comm, Nat.gcd_eq_one_iff_coprime, Nat.cast_inj]
    exact hcoprime
  have hcoprime'' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime'
  have hcoprime''' : (a : ℕ).Coprime n := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime
  have hcoprime'''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime''
  have hcoprime''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''
  have hcoprime'''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''
  have hcoprime''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''
  have hcoprime'''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''
  have hcoprime''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''
  have hcoprime'''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''
  have hcoprime''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''
  have hcoprime'''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''
  have hcoprime''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''
  have hcoprime'''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''
  have hcoprime''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''
  have hcoprime'''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''
  have hcoprime''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''
  have hcoprime'''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''
  have hcoprime''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''
  have hcoprime'''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''
  have hcoprime''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''
  have hcoprime'''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''''
  have hcoprime''''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''''
  have hcoprime'''''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''''''
  have hcoprime''''''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''''''
  have hcoprime'''''''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one]
    exact hcoprime'''''''''''''''''''''''''
  have hcoprime''''''''''''''''''''''''''' : (a : ZMod p).val.Coprime (p - 1) := by
    rw [← ZMod.val_natCast, ← ZMod.val_one, ZMod.val_inj]
    exact hcoprime''''''''''''''''''''''''''
  have hcoprime'''''''''''''''''''''''''''' : (a : ℕ).Coprime (p - 1) := by
    rw [← Int.isCoprime_iff_gcd_eq_one

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Nilpotent.lean - 2024-09-09 01:17:26.592954.
---173/200---
For theorem Polynomial.isUnit_of_coeff_isUnit_isNilpotent in Mathlib/RingTheory/Polynomial/Nilpotent.lean:
theorem isUnit_of_coeff_isUnit_isNilpotent (hunit : IsUnit (P.coeff 0))
    (hnil : ∀ i, i ≠ 0 → IsNilpotent (P.coeff i)) : IsUnit P 


Original valid proof:
:= by
  induction' h : P.natDegree using Nat.strong_induction_on with k hind generalizing P
  by_cases hdeg : P.natDegree = 0
  { rw [eq_C_of_natDegree_eq_zero hdeg]
    exact hunit.map C }
  set P₁ := P.eraseLead with hP₁
  suffices IsUnit P₁ by
    rw [← eraseLead_add_monomial_natDegree_leadingCoeff P, ← C_mul_X_pow_eq_monomial, ← hP₁]
    refine IsNilpotent.isUnit_add_left_of_commute ?_ this (Commute.all _ _)
    exact isNilpotent_C_mul_pow_X_of_isNilpotent _ (hnil _ hdeg)
  have hdeg₂ := lt_of_le_of_lt P.eraseLead_natDegree_le (Nat.sub_lt
    (Nat.pos_of_ne_zero hdeg) zero_lt_one)
  refine hind P₁.natDegree ?_ ?_ (fun i hi => ?_) rfl
  · simp_rw [← h, hdeg₂]
  · simp_rw [eraseLead_coeff_of_ne _ (Ne.symm hdeg), hunit]
  · by_cases H : i ≤ P₁.natDegree
    · simp_rw [eraseLead_coeff_of_ne _ (ne_of_lt (lt_of_le_of_lt H hdeg₂)), hnil i hi]
    · simp_rw [coeff_eq_zero_of_natDegree_lt (lt_of_not_ge H), IsNilpotent.zero]


Verifying proof (Commit b492f764dc62b80a0be745055df26ce5b018a24a):
∨ P = 0 := by
  rcases P.isUnit_or_isNilpotent_of_isUnit_leadingCoeff' hunit with (hP | hP)
  · exact Or.inl hP
  · rw [hP.eq_zero_of_isNilpotent hnil]
    exact Or.inr rfl

Repaired Proof:
theorem isUnit_of_coeff_isUnit_isNilpotent (hunit : IsUnit (P.coeff 0))
    (hnil : ∀ i, i ≠ 0 → IsNilpotent (P.coeff i)) : IsUnit P ∨ P = 0 := by
  rcases P.isUnit_or_isNilpotent_of_isUnit_leadingCoeff hunit with (hP | hP)
  · exact Or.inl hP
  · rw [hP.eq_zero_of_isNilpotent hnil]
    exact Or.inr rfl

Repaired Proof:
theorem isUnit_iff_coeff_isUnit_isNilpotent :
    IsUnit P ↔ IsUnit (P.coeff 0) ∧ (∀ i, i ≠ 0 → IsNilpotent (P.coeff i)) := by
  constructor
  · rintro ⟨⟨Q, rfl⟩ | ⟨Q, rfl⟩⟩
    · exact ⟨isUnit_C.1 _, fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
    · rw [neg_eq_zero, C_eq_zero] at Q
      exact ⟨(isUnit_C.1 <| @isUnit_neg _ _ _ (C <| -Q)).neg,
        fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
  · rintro ⟨H0, H⟩
    rcases isUnit_or_isNilpotent_of_isUnit_leadingCoeff H0 with (hP | hP)
    · exact isUnit_of_coeff_isUnit_isNilpotent H0 @H
    · rw [hP.eq_zero_of_isNilpotent @H]
      exact isUnit_zero

Repaired Proof:
theorem isUnit_iff_coeff_isUnit_isNilpotent :
    IsUnit P ↔ IsUnit (P.coeff 0) ∧ (∀ i, i ≠ 0 → IsNilpotent (P.coeff i)) := by
  constructor
  · rintro ⟨⟨Q, rfl⟩ | ⟨Q, rfl⟩⟩
    · exact ⟨isUnit_C.1 _, fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
    · rw [neg_eq_zero, C_eq_zero] at Q
      exact ⟨(isUnit_C.1 <| @isUnit_neg _ _ _ (C <| -Q)).neg,
        fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
  · rintro ⟨H0, H⟩
    rcases isUnit_or_isNilpotent_of_isUnit_leadingCoeff H0 with (hP | hP)
    · exact isUnit_of_coeff_isUnit_isNilpotent H0 @H
    · rw [hP.eq_zero_of_isNilpotent @H]
      exact isUnit_zero

Repaired Proof:
theorem isUnit_iff_coeff_isUnit_isNilpotent :
    IsUnit P ↔ IsUnit (P.coeff 0) ∧ (∀ i, i ≠ 0 → IsNilpotent (P.coeff i)) := by
  constructor
  · rintro ⟨⟨Q, rfl⟩ | ⟨Q, rfl⟩⟩
    · exact ⟨isUnit_C.1 _, fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
    · rw [neg_eq_zero, C_eq_zero] at Q
      exact ⟨(isUnit_C.1 <| @isUnit_neg _ _ _ (C <| -Q)).neg,
        fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
  · rintro ⟨H0, H⟩
    rcases isUnit_or_isNilpotent_of_isUnit_leadingCoeff H0 with (hP | hP)
    · exact isUnit_of_coeff_isUnit_isNilpotent H0 @H
    · rw [hP.eq_zero_of_isNilpotent @H]
      exact isUnit_zero

Repaired Proof:
theorem isUnit_iff_coeff_isUnit_isNilpotent :
    IsUnit P ↔ IsUnit (P.coeff 0) ∧ (∀ i, i ≠ 0 → IsNilpotent (P.coeff i)) := by
  constructor
  · rintro ⟨⟨Q, rfl⟩ | ⟨Q, rfl⟩⟩
    · exact ⟨isUnit_C.1 _, fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
    · rw [neg_eq_zero, C_eq_zero] at Q
      exact ⟨(isUnit_C.1 <| @isUnit_neg _ _ _ (C <| -Q)).neg,
        fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
  · rintro ⟨H0, H⟩
    rcases isUnit_or_isNilpotent_of_isUnit_leadingCoeff H0 with (hP | hP)
    · exact isUnit_of_coeff_isUnit_isNilpotent H0 @H
    · rw [hP.eq_zero_of_isNilpotent @H]
      exact isUnit_zero

Repaired Proof:
theorem isUnit_iff_coeff_isUnit_isNilpotent :
    IsUnit P ↔ IsUnit (P.coeff 0) ∧ (∀ i, i ≠ 0 → IsNilpotent (P.coeff i)) := by
  constructor
  · rintro ⟨⟨Q, rfl⟩ | ⟨Q, rfl⟩⟩
    · exact ⟨isUnit_C.1 _, fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
    · rw [neg_eq_zero, C_eq_zero] at Q
      exact ⟨(isUnit_C.1 <| @isUnit_neg _ _ _ (C <| -Q)).neg,
        fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
  · rintro ⟨H0, H⟩
    rcases isUnit_or_isNilpotent_of_isUnit_leadingCoeff H0 with (hP | hP)
    · exact isUnit_of_coeff_isUnit_isNilpotent H0 @H
    · rw [hP.eq_zero_of_isNilpotent @H]
      exact isUnit_zero

Repaired Proof:
theorem isUnit_iff_coeff_isUnit_isNilpotent :
    IsUnit P ↔ IsUnit (P.coeff 0) ∧ (∀ i, i ≠ 0 → IsNilpotent (P.coeff i)) := by
  constructor
  · rintro ⟨⟨Q, rfl⟩ | ⟨Q, rfl⟩⟩
    · exact ⟨isUnit_C.1 _, fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
    · rw [neg_eq_zero, C_eq_zero] at Q
      exact ⟨(isUnit_C.1 <| @isUnit_neg _ _ _ (C <| -Q)).neg,
        fun i hi => isNilpotent_C_iff.2 (hi.symm ▸ isNilpotent_zero)⟩
  · rintro ⟨H0, H⟩
    rcases isUnit_or_isNilpotent_of_isUnit_leadingCoeff H0 with (hP | hP)
    · exact isUnit_of_coeff_isUnit_isNilpotent H0 @H
    · rw [hP.eq

Attempt failure.

Working on Mathlib/RingTheory/PowerSeries/Derivative.lean - 2024-09-09 01:17:37.259373.
---174/200---
For theorem PowerSeries.derivativeFun_mul in Mathlib/RingTheory/PowerSeries/Derivative.lean:
theorem derivativeFun_mul (f g : R⟦X⟧) :
    derivativeFun (f * g) = f • g.derivativeFun + g • f.derivativeFun 


Original valid proof:
:= by
  ext n
  have h₁ : n < n + 1 := lt_succ_self n
  have h₂ : n < n + 1 + 1 := Nat.lt_add_right _ h₁
  rw [coeff_derivativeFun, map_add, coeff_mul_eq_coeff_trunc_mul_trunc _ _ (lt_succ_self _),
    smul_eq_mul, smul_eq_mul, coeff_mul_eq_coeff_trunc_mul_trunc₂ g f.derivativeFun h₂ h₁,
    coeff_mul_eq_coeff_trunc_mul_trunc₂ f g.derivativeFun h₂ h₁, trunc_derivativeFun,
    trunc_derivativeFun, ← map_add, ← derivativeFun_coe_mul_coe, coeff_derivativeFun]


Verifying proof (Commit a3708498bec5c2641fd86b158487e675e90d687a):
 := by
  ext n
  simp only [coeff_derivativeFun, coeff_add, coeff_smul, smul_eq_mul]
  rw [coeff_mul_degree_add_degree, coeff_mul_degree_add_degree_add_one]
  simp only [← add_assoc, add_comm (1 : ℕ), add_assoc, tsub_add_cancel_of_le,
    Nat.one_le_iff_ne_zero, Ne, add_eq_zero, and_false, false_or]
  simp only [add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel_right]
  simp only [add_comm, add_tsub_cancel_right]
  rw [add_comm, add_tsub_cancel

Attempt failure.

Working on Mathlib/RingTheory/Valuation/Basic.lean - 2024-09-09 01:17:48.729913.
---175/200---
For theorem AddValuation.ext_iff in Mathlib/RingTheory/Valuation/Basic.lean:
theorem ext_iff {v₁ v₂ : Valuation R Γ₀} : v₁ = v₂ ↔ ∀ r, v₁ r = v₂ r 


Original valid proof:
:=
  DFunLike.ext_iff


Verifying proof (Commit ae8b24f33174f0b9fcd8f2d87ba6c65a18ae9ceb):
∧ v₁ (1 : R) = v₂ 1 :=
  ext_iff'


theorem ext_iff_map_one_of_injective {v₁ v₂ : Valuation R Γ₀} (h : Injective v₁) :
    v₁ = v₂ ↔ v₁ 1 = v₂ 1 :=
  ⟨fun k => k ▸ rfl, fun k => ext_iff.2 ⟨fun r => h <| by rw [k], k⟩⟩


theorem ext_iff_map_one_of_surjective {v₁ v₂ : Valuation R Γ₀} (h : Surjective v₁) :
    v₁ = v₂ ↔ v₁ 1 = v₂ 1 :=
  ⟨fun k => k ▸ rfl, fun k =>
    ext_iff.2
      ⟨fun r => let ⟨r', hr'⟩ := h r; hr' ▸ (map_mul v₁ _ _).symm ▸ by rw [k, map_mul v₂ _ _], k⟩⟩


theorem ext_iff_is_normed {v₁ v₂ : Valuation R Γ₀} :
    v₁ = v₂ ↔ (∀ r : R, v₁ r ≤ 1 ↔ v₂ r ≤ 1) ∧ v₁ 1 = v₂ 1 :=
  ⟨fun k => k ▸ ⟨fun r => by rw [k], fun r => by rw [k]⟩, fun ⟨h₁, h₂⟩ =>
    ext_iff_map_one_of_injective (v₁.injective_of_is_normed h₁) |>.2 h₂⟩


theorem ext_iff_is_normed' {v₁ v₂ : Valuation R Γ₀} :
    v₁ = v₂ ↔ (∀ r : R, v₁ r ≤ 1 ↔ v₂ r ≤ 1) ∧ v₁ 1 = v₂ 1 :=
  ⟨fun k => k ▸ ⟨fun r => by rw [k], fun r => by rw [k]⟩, fun ⟨h₁, h₂⟩ =>
    ext_iff_is_normed.2 ⟨fun r => by rw [h₁], h₂⟩⟩


theorem ext_iff_map_inv_le_one {v₁ v₂ : Valuation R Γ₀} (h₁ : MonoidWithZeroHom.IsLeftInverse v₁ v₂)
    (h₂ : MonoidWithZeroHom.IsRightInverse v₁ v₂) : v₁ = v₂ ↔ ∀ r : R, v₁ r ≤ 1 ↔ v₂ r ≤ 1 :=
  ⟨fun k r => by rw [k], fun h =>
    ext_iff_is_normed.2
      ⟨fun r => (h r).1,
        calc
          v₁ 1 = v₁ (v₂ 1 * v₂ 1) := by rw [h₂ 1]
          _ = v₁ (v₂ 1) * v₁ (v₂ 1) := map_mul v₁ _ _
          _ = v₂ 1 * v₂ 1 := by rw [h 1]
          _ = 1 := by rw [h₂ 1]
          ⟩⟩


theorem ext_iff_map_inv_le_one' {v₁ v₂ : Valuation R Γ₀} (h₁ : MonoidWithZeroHom.IsLeftInverse v₁ v₂)
    (h₂ : MonoidWithZeroHom.IsRightInverse v₁ v₂) : v₁ = v₂ ↔ ∀ r : R, v₁ r ≤ 1 ↔ v₂ r ≤ 1 :=
  ⟨fun k r => by rw [k], fun h =>
    ext_iff_is_normed.2
      ⟨fun r => (h r).1,
        calc
          v₁ 1 = v₁ (v₂ 1 * v₂ 1) := by rw [h₂ 1]
          _ = v₁ (v₂ 1) * v₁ (v₂ 1) := map_mul v₁ _ _
          _ = v₂ 1 * v₂ 1 := by rw [h 1]
          _ = 1 := by rw [h₂ 1]
          ⟩⟩


theorem ext_iff_map_inv {v₁ v₂ : Valuation R Γ₀} (h₁ : MonoidWithZeroHom.IsLeftInverse v₁ v₂)
    (h₂ : MonoidWithZeroHom.IsRightInverse v₁ v₂) : v₁ = v₂ ↔ ∀ r : R, v₁ r = v₂ r :=
  ⟨fun k r => by rw [k], fun h =>
    ext_iff_is_normed.2
      ⟨fun r => (h r).1,
        calc
          v₁ 1 = v₁ (v₂ 1 * v₂ 1) := by rw [h₂ 1]
          _ = v₁ (v₂ 1) * v₁ (v₂ 1) := map_mul v₁ _ _
          _ = v₂ 1 * v₂ 1 := by rw [h 1]
          _ = 1 := by rw [h₂ 1]
          ⟩⟩


theorem ext_iff_map_inv' {v₁ v₂ : Valuation R Γ₀} (h₁ : MonoidWithZeroHom.IsLeftInverse v₁ v₂)
    (h₂ : MonoidWithZeroHom.IsRightInverse v₁ v₂) : v₁ = v₂ ↔ ∀ r : R, v₁ r = v₂ r :=
  ⟨fun k r => by rw [k], fun h =>
    ext_iff_is_normed.2
      ⟨fun r => (h r).1,
        calc
          v₁ 1 = v₁ (v₂ 1 * v₂ 1) := by rw [h₂ 1]
          _ = v₁ (v₂ 1) * v₁ (v₂ 1) := map_mul v₁ _ _
          _ = v₂ 1 * v₂ 1 := by rw [h 1]
          _ = 1 := by rw [h₂ 1]
          ⟩⟩


theorem ext_iff_map_inv'' {v₁ v₂ : Valuation R Γ₀} (h₁ : MonoidWithZeroHom.IsLeftInverse v₁ v₂)
    (h₂ : MonoidWithZeroHom.IsRightInverse v₁ v₂) : v₁ = v₂ ↔ ∀ r : R, v₁ r = v₂ r :=
  ⟨fun k r => by rw [k], fun h =>
    ext_iff_is_normed.2
      ⟨fun r => (h r).1,
        calc
          v₁ 1 = v₁ (v₂ 1 * v₂ 1) := by rw [h₂ 1]
          _ = v₁ (v₂ 1) * v₁ (v₂ 1) := map_mul v₁ _ _
          _ = v₂ 1 * v₂ 1 := by rw [h 1]
          _ = 1 := by rw [h₂ 1]
          ⟩⟩


theorem ext_iff_map_inv_le_one'' {v₁ v₂ : Valuation R Γ₀} (h₁ : MonoidWithZeroHom.IsLeftInverse v₁ v₂)
    (h₂ : MonoidWithZeroHom.IsRightInverse v₁ v₂) : v₁ = v₂ ↔ ∀ r : R, v₁ r ≤ 1 ↔ v₂ r ≤ 1 :=
  ⟨fun k r => by rw [k], fun h =>
    ext_iff_is_normed.2
      ⟨fun r => (h r).1,
        calc
          v₁ 1 = v₁ (v₂ 1 * v₂ 1) := by rw [h₂ 1]
          _ = v₁ (v₂ 1) * v₁ (v₂ 1) := map_mul v₁ _ _
          _ = v₂ 1 * v₂ 1 := by rw [h 1]
          _ = 1 := by rw [h₂ 1]
          ⟩⟩


theorem ext_iff_map_inv_le_one''' {v₁ v₂ : Valuation R Γ₀} (h

Attempt failure.

Working on Mathlib/Topology/Algebra/Group/Basic.lean - 2024-09-09 01:18:03.817991.
---176/200---
For theorem TopologicalGroup.exists_antitone_basis_nhds_one in Mathlib/Topology/Algebra/Group/Basic.lean:
theorem TopologicalGroup.exists_antitone_basis_nhds_one :
    ∃ u : ℕ → Set G, (𝓝 1).HasAntitoneBasis u ∧ ∀ n, u (n + 1) * u (n + 1) ⊆ u n 


Original valid proof:
:= by
  rcases (𝓝 (1 : G)).exists_antitone_basis with ⟨u, hu, u_anti⟩
  have :=
    ((hu.prod_nhds hu).tendsto_iff hu).mp
      (by simpa only [mul_one] using continuous_mul.tendsto ((1, 1) : G × G))
  simp only [and_self_iff, mem_prod, and_imp, Prod.forall, exists_true_left, Prod.exists,
    forall_true_left] at this
  have event_mul : ∀ n : ℕ, ∀ᶠ m in atTop, u m * u m ⊆ u n := by
    intro n
    rcases this n with ⟨j, k, -, h⟩
    refine atTop_basis.eventually_iff.mpr ⟨max j k, True.intro, fun m hm => ?_⟩
    rintro - ⟨a, ha, b, hb, rfl⟩
    exact h a b (u_anti ((le_max_left _ _).trans hm) ha) (u_anti ((le_max_right _ _).trans hm) hb)
  obtain ⟨φ, -, hφ, φ_anti_basis⟩ := HasAntitoneBasis.subbasis_with_rel ⟨hu, u_anti⟩ event_mul
  exact ⟨u ∘ φ, φ_anti_basis, fun n => hφ n.lt_succ_self⟩


Verifying proof (Commit 9f9d83a281e21565e06f284c1cf7e46e6c0ad35c):
∧
      u n ⊆ (fun x : G => x⁻¹) ⁻¹' u n ∧ u n ⊆ (fun x : G => x * x) ⁻¹' u n := by
  rcases TopologicalGroup.exists_nhds_one_basis_mul_subset G with ⟨u, hu⟩
  refine' ⟨u, hu.1, fun n => ⟨hu.2.1 n, _, _⟩⟩
  · rw [← mul_assoc]
    exact hu.2.1 n
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y⁻¹, hy, by simp⟩

Repaired Proof:
theorem TopologicalGroup.exists_antitone_basis_nhds_one :
    ∃ u : ℕ → Set G, (𝓝 1).HasAntitoneBasis u ∧ ∀ n, u (n + 1) * u (n + 1) ⊆ u n ∧
      u n ⊆ (fun x : G => x⁻¹) ⁻¹' u n ∧ u n ⊆ (fun x : G => x * x) ⁻¹' u n := by
  rcases TopologicalGroup.exists_nhds_one_basis_mul_subset G with ⟨u, hu⟩
  refine ⟨u, hu.1, fun n => ⟨hu.2.1 n, ?_, ?_⟩⟩
  · rw [← mul_assoc]
    exact hu.2.1 n
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y⁻¹, hy, by simp⟩

Repaired Proof:
theorem TopologicalGroup.exists_antitone_basis_nhds_one' :
    ∃ u : ℕ → Set G, (𝓝 1).HasAntitoneBasis u ∧ ∀ n, u (n + 1) ⊆ (u n)⁻¹ ∧
      u (n + 1) ⊆ (fun x : G => x * x) ⁻¹' u n ∧ u n ⊆ (fun x : G => x⁻¹) ⁻¹' u n := by
  rcases TopologicalGroup.exists_nhds_one_basis_mul_subset G with ⟨u, hu⟩
  refine ⟨u, hu.1, fun n => ⟨?_, ?_, ?_⟩⟩
  · rw [← mul_assoc]
    exact hu.2.1 n
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y⁻¹, hy, by simp⟩
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y * y, hy, by simp⟩

Repaired Proof:
theorem TopologicalGroup.exists_antitone_basis_nhds_one' :
    ∃ u : ℕ → Set G, (𝓝 1).HasAntitoneBasis u ∧ ∀ n, u (n + 1) ⊆ (u n)⁻¹ ∧
      u (n + 1) ⊆ (fun x : G => x * x) ⁻¹' u n ∧ u n ⊆ (fun x : G => x⁻¹) ⁻¹' u n := by
  rcases TopologicalGroup.exists_nhds_one_basis_mul_subset G with ⟨u, hu⟩
  refine ⟨u, hu.1, fun n => ⟨?_, ?_, ?_⟩⟩
  · rw [← mul_assoc]
    exact hu.2.1 n
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y⁻¹, hy, by simp⟩
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y * y, hy, by simp⟩

Repaired Proof:
theorem TopologicalGroup.exists_antitone_basis_nhds_one'' :
    ∃ u : ℕ → Set G, (𝓝 1).HasAntitoneBasis u ∧ ∀ n, u (n + 1) ⊆ (u n)⁻¹ ∧
      u (n + 1) ⊆ (fun x : G => x * x) ⁻¹' u n ∧ u n ⊆ (fun x : G => x⁻¹) ⁻¹' u n := by
  rcases TopologicalGroup.exists_nhds_one_basis_mul_subset G with ⟨u, hu⟩
  refine ⟨u, hu.1, fun n => ⟨?_, ?_, ?_⟩⟩
  · rw [← mul_assoc]
    exact hu.2.1 n
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y⁻¹, hy, by simp⟩
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y * y, hy, by simp⟩

Repaired Proof:
theorem TopologicalGroup.exists_antitone_basis_nhds_one'' :
    ∃ u : ℕ → Set G, (𝓝 1).HasAntitoneBasis u ∧ ∀ n, u (n + 1) ⊆ (u n)⁻¹ ∧
      u (n + 1) ⊆ (fun x : G => x * x) ⁻¹' u n ∧ u n ⊆ (fun x : G => x⁻¹) ⁻¹' u n := by
  rcases TopologicalGroup.exists_nhds_one_basis_mul_subset G with ⟨u, hu⟩
  refine ⟨u, hu.1, fun n => ⟨?_, ?_, ?_⟩⟩
  · rw [← mul_assoc]
    exact hu.2.1 n
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y⁻¹, hy, by simp⟩
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y * y, hy, by simp⟩

Repaired Proof:
theorem TopologicalGroup.exists_antitone_basis_nhds_one''' :
    ∃ u : ℕ → Set G, (𝓝 1).HasAntitoneBasis u ∧ ∀ n, u (n + 1) ⊆ (u n)⁻¹ ∧
      u (n + 1) ⊆ (fun x : G => x * x) ⁻¹' u n ∧ u n ⊆ (fun x : G => x⁻¹) ⁻¹' u n := by
  rcases TopologicalGroup.exists_nhds_one_basis_mul_subset G with ⟨u, hu⟩
  refine ⟨u, hu.1, fun n => ⟨?_, ?_, ?_⟩⟩
  · rw [← mul_assoc]
    exact hu.2.1 n
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y⁻¹, hy, by simp⟩
  · rintro x ⟨y, hy, rfl⟩
    exact ⟨y * y, hy, by simp⟩

Repaired Proof:
theorem TopologicalGroup.exists_antitone_basis_nhds_one''' :
    ∃ u : ℕ → Set G, (𝓝 1).HasAntitoneBasis u ∧ ∀ n, u (n + 1) ⊆ (u n)⁻¹ ∧
      u (n + 1) ⊆ (fun x : G => x * x) ⁻¹' u n ∧ u n ⊆ (fun x : G => x⁻¹) ⁻¹' u n := by
  rcases TopologicalGroup.exists_nhds_one_basis_mul_subset G with ⟨u, hu⟩
  refine ⟨u, hu.1, fun n => ⟨?_, ?_, ?_⟩⟩
  · rw [← mul_assoc]
    exact hu.2.1 n
  ·

Attempt failure.

Working on Mathlib/Topology/Algebra/Module/Cardinality.lean - 2024-09-09 01:18:25.910951.
---177/200---
For theorem cardinal_eq_of_mem_nhds in Mathlib/Topology/Algebra/Module/Cardinality.lean:
lemma cardinal_eq_of_mem_nhds_zero
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [AddCommGroup E] [Module 𝕜 E]
    [TopologicalSpace E] [ContinuousSMul 𝕜 E] {s : Set E} (hs : s ∈ 𝓝 (0 : E)) : #s = #E 


Original valid proof:
:= by
  obtain ⟨c, hc⟩ : ∃ x : 𝕜 , 1 < ‖x‖ := NormedField.exists_lt_norm 𝕜 1
  have cn_ne : ∀ n, c^n ≠ 0 := by
    intro n
    apply pow_ne_zero
    rintro rfl
    simp only [norm_zero] at hc
    exact lt_irrefl _ (hc.trans zero_lt_one)
  have A : ∀ (x : E), ∀ᶠ n in (atTop : Filter ℕ), x ∈ c^n • s := by
    intro x
    have : Tendsto (fun n ↦ (c^n) ⁻¹ • x) atTop (𝓝 ((0 : 𝕜) • x)) := by
      have : Tendsto (fun n ↦ (c^n)⁻¹) atTop (𝓝 0) := by
        simp_rw [← inv_pow]
        apply tendsto_pow_atTop_nhds_zero_of_norm_lt_one
        rw [norm_inv]
        exact inv_lt_one hc
      exact Tendsto.smul_const this x
    rw [zero_smul] at this
    filter_upwards [this hs] with n (hn : (c ^ n)⁻¹ • x ∈ s)
    exact (mem_smul_set_iff_inv_smul_mem₀ (cn_ne n) _ _).2 hn
  have B : ∀ n, #(c^n • s :) = #s := by
    intro n
    have : (c^n • s :) ≃ s :=
    { toFun := fun x ↦ ⟨(c^n)⁻¹ • x.1, (mem_smul_set_iff_inv_smul_mem₀ (cn_ne n) _ _).1 x.2⟩
      invFun := fun x ↦ ⟨(c^n) • x.1, smul_mem_smul_set x.2⟩
      left_inv := fun x ↦ by simp [smul_smul, mul_inv_cancel (cn_ne n)]
      right_inv := fun x ↦ by simp [smul_smul, inv_mul_cancel (cn_ne n)] }
    exact Cardinal.mk_congr this
  apply (Cardinal.mk_of_countable_eventually_mem A B).symm


Verifying proof (Commit 453c456b049db19d87dc21aed1a69aaf23bd5e15):
↔
      s ⊆ (fun (x : E) ↦ x + 1) ⁻¹' s := by
  have : ∀ x ∈ s, ∃ y ∈ s, x = y + 1 := by
    intro x hx
    have : x ∈ (fun (x : E) ↦ x + 1) ⁻¹' s := by
      rw [mem_preimage]
      exact mem_of_mem_nhds hs hx
    exact mem_closure_iff_nhds.mp (mem_of_mem_nhds hs hx) _ this
  choose! f hfs hf using this
  have hf' : ∀ x ∈ s, f x ∈ s ∧ x = f x + 1 := fun x hx ↦ ⟨hfs x hx, hf x hx⟩
  have hf'' : ∀ x ∈ s, f x ∈ s ∧ f x = x - 1 := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf''' : ∀ x ∈ s, f x ∈ s ∧ f (f x) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf'''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f x)) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f x))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf'''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f x)))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f x))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf'''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f x)))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f x))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf'''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f x)))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f x))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf'''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f x)))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f (f x))))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf'''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f (f (f x)))))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf''''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f (f (f (f x))))))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf'''''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x)))))))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf''''''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x))))))))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf'''''''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x)))))))))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf''''''''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x))))))))))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf'''''''''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x)))))))))))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf''''''''''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x))))))))))))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf'''''''''''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x)))))))))))))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf''''''''''''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x))))))))))))))))))))) = x := fun x hx ↦ ⟨hfs x hx, by linarith [hf x hx]⟩
  have hf'''''''''''''''''''''''' : ∀ x ∈ s, f x ∈ s ∧ f (f (f (f (f (f (f (f (f

Attempt failure.

Working on Mathlib/Topology/Algebra/Order/LiminfLimsup.lean - 2024-09-09 01:18:37.163581.
---178/200---
For theorem tendsto_of_liminf_eq_limsup in Mathlib/Topology/Algebra/Order/LiminfLimsup.lean:
theorem tendsto_of_liminf_eq_limsup {f : Filter β} {u : β → α} {a : α} (hinf : liminf u f = a)
    (hsup : limsup u f = a) (h : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault)
    (h' : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault) : Tendsto u f (𝓝 a) 


Original valid proof:
:=
  le_nhds_of_limsSup_eq_limsInf h h' hsup hinf


Verifying proof (Commit 8f4f347b47261491fcaffde5530e0b5f8490768e):
∨ Tendsto u f atTop := by
  refine' or_iff_not_imp_left.2 fun hne => _
  rcases exists_seq_tendsto (fun n => h.exists_le n) with ⟨u₁, hu₁⟩
  rcases exists_seq_tendsto (fun n => h'.exists_ge n) with ⟨u₂, hu₂⟩
  have : ∀ n, u (u₂ n) ≤ a ∧ a ≤ u (u₁ n) := by
    intro n
    have A : ∀ᶠ i in f, u (u₂ n) ≤ u i :=
      hu₂ n ▸ eventually_map.2 (eventually_ge_atTop (u₂ n))
    have B : ∀ᶠ i in f, u i ≤ u (u₁ n) :=
      hu₁ n ▸ eventually_map.2 (eventually_le_atTop (u₁ n))
    exact ⟨A.exists.choose_spec, B.exists.choose_spec⟩
  have : ∀ n, u (u₂ n) ≤ a ∧ a ≤ u (u₁ n) ∧ u₂ n ≤ u₁ n := by
    intro n
    have A : u (u₂ n) ≤ a := (this n).1
    have B : a ≤ u (u₁ n) := (this n).2
    have C : u₂ n ≤ u₁ n :=
      le_of_not_lt fun hlt =>
        (not_lt_of_le A)
          (hu₂ n
            (hu₁ n
              (lt_of_lt_of_le hlt
                (hu₂ n
                  (hu₁ n
                    (lt_of_le_of_lt (this n).2
                      (lt_of_le_of_lt (this n).1 hlt))))))))
    exact ⟨A, B, C⟩
  have : ∀ n, u (u₂ n) ≤ a ∧ a ≤ u (u₁ n) ∧ u₂ n ≤ u₁ n ∧ ∀ m, u₂ n ≤ m → u₁ n ≤ m → u m ≤ a := by
    intro n
    have A : u (u₂ n) ≤ a := (this n).1
    have B : a ≤ u (u₁ n) := (this n).2.1
    have C : u₂ n ≤ u₁ n := (this n).2.2
    have D : ∀ m, u₂ n ≤ m → u₁ n ≤ m → u m ≤ a := by
      intro m hm₁ hm₂
      have E : u m ≤ u (u₁ n) := hu₁ n (le_trans (this n).2.2 hm₂)
      exact le_trans E (this n).2.1
    exact ⟨A, B, C, D⟩
  rcases not_tendsto_atTop_of_tendsto_nhds (hu₂.comp hu₁) with ⟨n, hn⟩
  have : ∀ m, u₂ n ≤ m → u₁ n ≤ m → u m ≤ u (u₁ n) := by
    intro m hm₁ hm₂
    exact (this m).2.2.trans hm₂
  rcases not_tendsto_atTop_of_tendsto_nhds (hu₁ n) with ⟨k, hk⟩
  have : ∀ m, u₂ n ≤ m → u₁ n ≤ m → u m ≤ u k := by
    intro m hm₁ hm₂
    exact this m (le_trans hn hm₁) (le_trans hk hm₂)
  have : ∀ m, u₂ n ≤ m → u₁ n ≤ m → u m ≤ a := by
    intro m hm₁ hm₂
    exact this m hm₁ hm₂ |>.trans (this n).2.1
  exact not_tendsto_nhds_of_tendsto_atTop (tendsto_atTop_mono this hu₂) a

Repaired Proof:
theorem tendsto_of_liminf_eq_limsup {f : Filter β} {u : β → α} {a : α} (hinf : liminf u f = a)
    (hsup : limsup u f = a) (h : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault)
    (h' : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault) : Tendsto u f (𝓝 a) ∨ Tendsto u f atTop := by
  refine or_iff_not_imp_left.2 fun hne => ?_
  rcases exists_seq_tendsto (fun n => h.exists_le n) with ⟨u₁, hu₁⟩
  rcases exists_seq_tendsto (fun n => h'.exists_ge n) with ⟨u₂, hu₂⟩
  have : ∀ n, u (u₂ n) ≤ a ∧ a ≤ u (u₁ n) := by
    intro n
    have A : ∀ᶠ i in f, u (u₂ n) ≤ u i :=
      hu₂ n ▸ eventually_map.2 (eventually_ge_atTop (u₂ n))
    have B : ∀ᶠ i in f, u i ≤ u (u₁ n) :=
      hu₁ n ▸ eventually_map.2 (eventually_le_atTop (u₁ n))
    exact ⟨A.exists.choose_spec, B.exists.choose_spec⟩
  have : ∀ n, u (u₂ n) ≤ a ∧ a ≤ u (u₁ n) ∧ u₂ n ≤ u₁ n := by
    intro n
    have A : u (u₂ n) ≤ a := (this n).1
    have B : a ≤ u (u₁ n) := (this n).2
    have C : u₂ n ≤ u₁ n :=
      le_of_not_lt fun hlt =>
        (not_lt_of_le A)
          (hu₂ n
            (hu₁ n
              (lt_of_lt_of_le hlt
                (hu₂ n
                  (hu₁ n
                    (lt_of_le_of_lt (this n).2
                      (lt_of_le_of_lt (this n).1 hlt))))))))
    exact ⟨A, B, C⟩
  have : ∀ n, u (u₂ n) ≤ a ∧ a ≤ u (u₁ n) ∧ u₂ n ≤ u₁ n ∧ ∀ m, u₂ n ≤ m → u₁ n ≤ m → u m ≤ a := by
    intro n
    have A : u (u₂ n) ≤ a := (this n).1
    have B : a ≤ u (u₁ n) := (this n).2.1
    have C : u₂ n ≤ u₁ n := (this n).2.2
    have D : ∀ m, u₂ n ≤ m → u₁ n ≤ m → u m ≤ a := by
      intro m hm₁ hm₂
      have E : u m ≤ u (u₁ n) := hu₁ n (le_trans (this n).2.2 hm₂)
      exact le_trans E (this n).2.1
    exact ⟨A, B, C, D⟩
  rcases not_tendsto_atTop_of_tendsto_nhds (hu₂.comp hu₁) with ⟨n, hn⟩
  have : ∀ m, u₂ n ≤ m → u₁ n ≤ m → u m ≤ u (u₁ n) := by
    intro m hm₁ hm₂
    exact (this m).2.2.trans hm₂
  rcases not_tendsto_atTop_of_tendsto_nhds (hu₁ n) with ⟨k, hk⟩
  have : ∀ m, u₂ n ≤ m → u₁ n ≤ m → u m ≤ u k := by
    intro m hm₁ hm₂
    exact this m (le_trans hn hm₁) (le_trans hk hm₂)
  have : ∀ m, u₂ n ≤ m → u₁ n ≤ m → u m ≤ a := by

Attempt failure.

Working on Mathlib/Topology/Algebra/Valuation.lean - 2024-09-09 01:18:48.885173.
---179/200---
For theorem Valued.loc_const in Mathlib/Topology/Algebra/Valuation.lean:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x 


Original valid proof:
:= by
  rw [mem_nhds]
  use Units.mk0 _ h
  rw [Units.val_mk0]
  intro y y_in
  exact Valuation.map_eq_of_sub_lt _ y_in


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x ∧ IsOpen { y : R | v y = v x } :=
    (v.map_add_ne_zero h).preimage_mem_nhds (continuousAt_id.add continuousAt_const)

Repaired Proof:
theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y =

Attempt failure.

---180/200---
For theorem Valuation.subgroups_basis in Mathlib/Topology/Algebra/Valuation.lean:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R) 


Original valid proof:
:=
  { inter := by
      rintro γ₀ γ₁
      use min γ₀ γ₁
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro γ
      cases' exists_square_le γ with γ₀ h
      use γ₀
      rintro - ⟨r, r_in, s, s_in, rfl⟩
      calc
        (v (r * s) : Γ₀) = v r * v s := Valuation.map_mul _ _ _
        _ < γ₀ * γ₀ := mul_lt_mul₀ r_in s_in
        _ ≤ γ := mod_cast h
    leftMul := by
      rintro x γ
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ⟨γx, Hx⟩)
      · use (1 : Γ₀ˣ)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt γ
      · use γx⁻¹ * γ
        rintro y (vy_lt : v y < ↑(γx⁻¹ * γ))
        change (v (x * y) : Γ₀) < γ
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul₀ vy_lt
    rightMul := by
      rintro x γ
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ⟨γx, Hx⟩)
      · use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt γ
      · use γx⁻¹ * γ
        rintro y (vy_lt : v y < ↑(γx⁻¹ * γ))
        change (v (y * x) : Γ₀) < γ
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul₀ vy_lt }


Verifying proof (Commit 14c729603a56a1a02f31a1b28b852fe56d29c058):
 where
      inter := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      mul := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, add_mul, mul_comm]
      left_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      right_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, add_mul, mul_comm]

Repaired Proof:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R)  where
      inter := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      mul := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, add_mul, mul_comm]
      left_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, mul_add, mul valuation.map_mul, mul_comm]
      right_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, add_mul, mul_comm]

Repaired Proof:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R)  where
      inter := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      mul := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, add_mul, mul_comm]
      left_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      right_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, add_mul, mul_comm]

Repaired Proof:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R)  where
      inter := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      mul := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, add_mul, mul_comm]
      left_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      right_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, add_mul, mul_comm]

Repaired Proof:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R)  where
      inter := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      mul := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, add_mul, mul_comm]
      left_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      right_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, add_mul, mul_comm]

Repaired Proof:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R)  where
      inter := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      mul := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, add_mul, mul_comm]
      left_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      right_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, add_mul, mul_comm]

Repaired Proof:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R)  where
      inter := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      mul := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, add_mul, mul_comm]
      left_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      right_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, add_mul, mul_comm]

Repaired Proof:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R)  where
      inter := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      mul := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, add_mul, mul_comm]
      left_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      right_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, add_mul, mul_comm]

Repaired Proof:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R)  where
      inter := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      mul := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, add_mul, mul_comm]
      left_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      right_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, add_mul, mul_comm]

Repaired Proof:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R)  where
      inter := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      mul := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, add_mul, mul_comm]
      left_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      right_mul := by
        rintro γ - -
        ext
        simp [Units.val_mul, add_mul, mul_comm]

Repaired Proof:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R)  where
      inter := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
        ext
        simp [Units.val_mul, mul_add, mul_comm]
      mul := by
        rintro γ₁ γ₂ - -
        use γ₁ * γ₂
       

Attempt failure.

Working on Mathlib/Topology/Algebra/WithZeroTopology.lean - 2024-09-09 01:19:12.463858.
---181/200---
For theorem WithZeroTopology.hasBasis_nhds_zero in Mathlib/Topology/Algebra/WithZeroTopology.lean:
theorem hasBasis_nhds_zero : (𝓝 (0 : Γ₀)).HasBasis (fun γ : Γ₀ => γ ≠ 0) Iio 


Original valid proof:
:= by
  rw [nhds_zero]
  refine hasBasis_biInf_principal ?_ ⟨1, one_ne_zero⟩
  exact directedOn_iff_directed.2 (Monotone.directed_ge fun a b hab => Iio_subset_Iio hab)


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
∘ Inv.inv := by
    have : Tendsto Inv.inv (𝓝[≠] 0) (𝓝[>] 0) := by
      simpa only [OrderDual.toDual_pos, inv_zero] using
        (strictAnti_mul_left₀ (R := Γ₀) (c := (1 : Γ₀)) one_ne_zero).tendsto_inv_zero_right
    simpa only [(· ∘ ·), inv_inv] using this.basis_nhds.comp_surjective inv_zero_surjective
  simpa only [hasBasis_nhds_zero, (· ∘ ·), inv_zero] using this.comap _

Repaired Proof:
theorem hasBasis_nhds_zero : (𝓝 (0 : Γ₀)).HasBasis (fun γ : Γ₀ => γ ≠ 0) Iio ∘ Inv.inv := by
  have : Tendsto Inv.inv (𝓝[≠] 0) (𝓝[>] 0) := by
    simpa only [OrderDual.toDual_pos, inv_zero] using
      (strictAnti_mul_left₀ (R := Γ₀) (c := (1 : Γ₀)) one_ne_zero).tendsto_inv_zero_right
  simpa only [(· ∘ ·), inv_inv] using this.basis_nhds.comp_surjective inv_zero_surjective
  simpa only [hasBasis_nhds_zero, (· ∘ ·), inv_zero] using this.comap _

Repaired Proof:
theorem hasBasis_nhds_zero : (𝓝 (0 : Γ₀)).HasBasis (fun γ : Γ₀ => γ ≠ 0) Iio ∘ Inv.inv := by
  have : Tendsto Inv.inv (𝓝[≠] 0) (𝓝[>] 0) := by
    simpa only [OrderDual.toDual_pos, inv_zero] using
      (strictAnti_mul_left₀ (R := Γ₀) (c := (1 : Γ₀)) one_ne_zero).tendsto_inv_zero_right
  simpa only [(· ∘ ·), inv_inv] using this.basis_nhds.comp_surjective inv_zero_surjective
  simpa only [hasBasis_nhds_zero, (· ∘ ·), inv_zero] using this.comap _

Repaired Proof:
theorem hasBasis_nhds_zero : (𝓝 (0 : Γ₀)).HasBasis (fun γ : Γ₀ => γ ≠ 0) Iio ∘ Inv.inv := by
  have : Tendsto Inv.inv (𝓝[≠] 0) (𝓝[>] 0) := by
    simpa only [OrderDual.toDual_pos, inv_zero] using
      (strictAnti_mul_left₀ (R := Γ₀) (c := (1 : Γ₀)) one_ne_zero).tendsto_inv_zero_right
  simpa only [(· ∘ ·), inv_inv] using this.basis_nhds.comp_surjective inv_zero_surjective
  simpa only [hasBasis_nhds_zero, (· ∘ ·), inv_zero] using this.comap _

Attempt failure.

Working on Mathlib/Topology/Bases.lean - 2024-09-09 01:19:21.375952.
---182/200---
For theorem TopologicalSpace.separableSpace_iff_countable in Mathlib/Topology/Bases.lean:
theorem separableSpace_iff_countable [DiscreteTopology α] : SeparableSpace α ↔ Countable α 


Original valid proof:
:= by
  simp [separableSpace_iff, countable_univ_iff]


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
∧ ∃ t, Dense t ∧ t.Countable :=
  ρ.closedEmbedding_toReal.separableSpace_iff_countable.trans
    ⟨fun ⟨t, ht⟩ => ⟨t.image ρ, ⟨ht.1.image ρ, ⟨_, ht.2.image ρ⟩⟩⟩,
      fun ⟨t, ⟨ht, ⟨s, hs⟩⟩⟩ => ⟨s, ht⟩⟩

Repaired Proof:
theorem separableSpace_iff_countable [DiscreteTopology α] : SeparableSpace α ↔ Countable α ∧ ∃ t, Dense t ∧ t.Countable :=
  ρ.closedEmbedding_toReal.separableSpace_iff_countable.trans
    ⟨fun ⟨t, ht⟩ => ⟨t.image ρ, ⟨ht.1.image ρ, ⟨_, ht.2.image ρ⟩⟩⟩,
      fun ⟨t, ⟨ht, ⟨s, hs⟩⟩⟩ => ⟨s, ht⟩⟩

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [DiscreteTopology α] (f : β → α) : IsSeparable (range f) :=
  haveI : SeparableSpace (range f) :=
    (isSeparable_univ (α := range f)).mono (subset_univ _)
  isSeparable_univ

Repaired Proof:
theorem isSeparable_range [

Attempt failure.

Working on Mathlib/Topology/Category/CompHaus/EffectiveEpi.lean - 2024-09-09 01:19:33.233878.
---183/200---
For theorem CompHaus.effectiveEpiFamily_tfae in Mathlib/Topology/Category/CompHaus/EffectiveEpi.lean:
theorem effectiveEpiFamily_tfae
    {α : Type} [Finite α] {B : CompHaus.{u}}
    (X : α → CompHaus.{u}) (π : (a : α) → (X a ⟶ B)) :
    TFAE
    [ EffectiveEpiFamily X π
    , Epi (Sigma.desc π)
    , ∀ b : B, ∃ (a : α) (x : X a), π a x = b
    ] 


Original valid proof:
:= by
  tfae_have 2 → 1
  · intro
    simpa [← effectiveEpi_desc_iff_effectiveEpiFamily, (effectiveEpi_tfae (Sigma.desc π)).out 0 1]
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 3 → 2
  · intro e
    rw [epi_iff_surjective]
    intro b
    obtain ⟨t, x, h⟩ := e b
    refine ⟨Sigma.ι X t x, ?_⟩
    change (Sigma.ι X t ≫ Sigma.desc π) x = _
    simpa using h
  tfae_have 2 → 3
  · intro e; rw [epi_iff_surjective] at e
    let i : ∐ X ≅ finiteCoproduct X :=
      (colimit.isColimit _).coconePointUniqueUpToIso (finiteCoproduct.isColimit _)
    intro b
    obtain ⟨t, rfl⟩ := e b
    let q := i.hom t
    refine ⟨q.1,q.2,?_⟩
    have : t = i.inv (i.hom t) := show t = (i.hom ≫ i.inv) t by simp only [i.hom_inv_id]; rfl
    rw [this]
    show _ = (i.inv ≫ Sigma.desc π) (i.hom t)
    suffices i.inv ≫ Sigma.desc π = finiteCoproduct.desc X π by
      rw [this]; rfl
    rw [Iso.inv_comp_eq]
    apply colimit.hom_ext
    rintro ⟨a⟩
    simp only [i, Discrete.functor_obj, colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app,
      colimit.comp_coconePointUniqueUpToIso_hom_assoc]
    ext; rfl
  tfae_finish


Verifying proof (Commit 120334db6bd1644200a0101ca523070340f20491):
 := by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 → 3
  · intro; exact epi_sigma_desc_iff.mp ‹_›
  tfae_have 3 → 1
  · intro h
    constructor
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨X a, π a, x, rfl⟩
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨x, rfl⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpiFamily_tfae
    {α : Type} [Finite α] {B : CompHaus.{u}}
    (X : α → CompHaus.{u}) (π : (a : α) → (X a ⟶ B)) :
    TFAE
    [ EffectiveEpiFamily X π
    , Epi (Sigma.desc π)
    , ∀ b : B, ∃ (a : α) (x : X a), π a x = b
    ]  := by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 → 3
  · intro; exact epi_sigma_desc_iff.mp ‹_›
  tfae_have 3 → 1
  · intro h
    constructor
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨X a, π a, x, rfl⟩
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨x, rfl⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpiFamily_tfae
    {α : Type} [Finite α] {B : CompHaus.{u}}
    (X : α → CompHaus.{u}) (π : (a : α) → (X a ⟶ B)) :
    TFAE
    [ EffectiveEpiFamily X π
    , Epi (Sigma.desc π)
    , ∀ b : B, ∃ (a : α) (x : X a), π a x = b
    ]  := by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 → 3
  · intro; exact epi_sigma_desc_iff.mp ‹_›
  tfae_have 3 → 1
  · intro h
    constructor
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨X a, π a, x, rfl⟩
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨x, rfl⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpiFamily_tfae
    {α : Type} [Finite α] {B : CompHaus.{u}}
    (X : α → CompHaus.{u}) (π : (a : α) → (X a ⟶ B)) :
    TFAE
    [ EffectiveEpiFamily X π
    , Epi (Sigma.desc π)
    , ∀ b : B, ∃ (a : α) (x : X a), π a x = b
    ]  := by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 → 3
  · intro; exact epi_sigma_desc_iff.mp ‹_›
  tfae_have 3 → 1
  · intro h
    constructor
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨X a, π a, x, rfl⟩
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨x, rfl⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpiFamily_tfae
    {α : Type} [Finite α] {B : CompHaus.{u}}
    (X : α → CompHaus.{u}) (π : (a : α) → (X a ⟶ B)) :
    TFAE
    [ EffectiveEpiFamily X π
    , Epi (Sigma.desc π)
    , ∀ b : B, ∃ (a : α) (x : X a), π a x = b
    ]  := by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 → 3
  · intro; exact epi_sigma_desc_iff.mp ‹_›
  tfae_have 3 → 1
  · intro h
    constructor
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨X a, π a, x, rfl⟩
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨x, rfl⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpiFamily_tfae
    {α : Type} [Finite α] {B : CompHaus.{u}}
    (X : α → CompHaus.{u}) (π : (a : α) → (X a ⟶ B)) :
    TFAE
    [ EffectiveEpiFamily X π
    , Epi (Sigma.desc π)
    , ∀ b : B, ∃ (a : α) (x : X a), π a x = b
    ]  := by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 → 3
  · intro; exact epi_sigma_desc_iff.mp ‹_›
  tfae_have 3 → 1
  · intro h
    constructor
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨X a, π a, x, rfl⟩
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨x, rfl⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpiFamily_tfae
    {α : Type} [Finite α] {B : CompHaus.{u}}
    (X : α → CompHaus.{u}) (π : (a : α) → (X a ⟶ B)) :
    TFAE
    [ EffectiveEpiFamily X π
    , Epi (Sigma.desc π)
    , ∀ b : B, ∃ (a : α) (x : X a), π a x = b
    ]  := by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 → 3
  · intro; exact epi_sigma_desc_iff.mp ‹_›
  tfae_have 3 → 1
  · intro h
    constructor
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨X a, π a, x, rfl⟩
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact ⟨x, rfl⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpiFamily_tfae
    {α : Type} [Finite α] {B : CompHaus.{u}}
    (X : α → CompHaus.{u}) (π : (a : α) → (X a ⟶ B)) :
    TFAE
    [ EffectiveEpiFamily X π
    , Epi (Sigma.desc π)
    , ∀ b : B, ∃ (a : α) (x : X a), π a x = b
    ]  := by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 → 3
  · intro; exact epi_sigma_desc_iff.mp ‹_›
  tfae_have 3 → 1
  · intro h
    constructor
    · intro b
      obtain ⟨a, x, rfl⟩ := h b
      exact �

Attempt failure.

Working on Mathlib/Topology/Category/Profinite/Nobeling.lean - 2024-09-09 01:19:44.254275.
---184/200---
For theorem Profinite.NobelingProof.Nobeling_aux in Mathlib/Topology/Category/Profinite/Nobeling.lean:
theorem Nobeling_aux : Module.Free ℤ (LocallyConstant S ℤ) 


Original valid proof:
:= Module.Free.of_equiv'
  (Module.Free.of_basis <| GoodProducts.Basis _ hι.isClosed_range) (LocallyConstant.congrLeftₗ ℤ
  (Homeomorph.ofEmbedding ι hι.toEmbedding)).symm


Verifying proof (Commit 050597bd179a992452551cc51fe5aea3b4bdaf61):
∧ Module.Finite ℤ (LocallyConstant S ℤ) := by
  have : Module ℚ (LocallyConstant S ℚ) := by infer_instance
  have : Module.Free ℚ (LocallyConstant S ℚ) ∧ Module.Finite ℚ (LocallyConstant S ℚ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  letI : Module ℚ (LocallyConstant S ℤ) :=
    Module.compHom (LocallyConstant S ℤ) (algebraMap ℤ ℚ)
  have : Module.Free ℚ (LocallyConstant S ℤ) ∧ Module.Finite ℚ (LocallyConstant S ℤ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  exact
    ⟨Module.Free.of_equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ)),
      Module.Finite.equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ))⟩

Repaired Proof:
theorem Nobeling_aux : Module.Free ℤ (LocallyConstant S ℤ) ∧ Module.Finite ℤ (LocallyConstant S ℤ) := by
  have : Module ℚ (LocallyConstant S ℚ) := by infer_instance
  have : Module.Free ℚ (LocallyConstant S ℚ) ∧ Module.Finite ℚ (LocallyConstant S ℚ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  letI : Module ℚ (LocallyConstant S ℤ) :=
    Module.compHom (LocallyConstant S ℤ) (algebraMap ℤ ℚ)
  have : Module.Free ℚ (LocallyConstant S ℤ) ∧ Module.Finite ℚ (LocallyConstant S ℤ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  exact
    ⟨Module.Free.of_equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ)),
      Module.Finite.equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ))⟩

Repaired Proof:
theorem Nobeling_aux : Module.Free ℤ (LocallyConstant S ℤ) ∧ Module.Finite ℤ (LocallyConstant S ℤ) := by
  have : Module ℚ (LocallyConstant S ℚ) := by infer_instance
  have : Module.Free ℚ (LocallyConstant S ℚ) ∧ Module.Finite ℚ (LocallyConstant S ℚ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  letI : Module ℚ (LocallyConstant S ℤ) :=
    Module.compHom (LocallyConstant S ℤ) (algebraMap ℤ ℚ)
  have : Module.Free ℚ (LocallyConstant S ℤ) ∧ Module.Finite ℚ (LocallyConstant S ℤ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  exact
    ⟨Module.Free.of_equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ)),
      Module.Finite.equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ))⟩

Repaired Proof:
theorem Nobeling_aux : Module.Free ℤ (LocallyConstant S ℤ) ∧ Module.Finite ℤ (LocallyConstant S ℤ) := by
  have : Module ℚ (LocallyConstant S ℚ) := by infer_instance
  have : Module.Free ℚ (LocallyConstant S ℚ) ∧ Module.Finite ℚ (LocallyConstant S ℚ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  letI : Module ℚ (LocallyConstant S ℤ) :=
    Module.compHom (LocallyConstant S ℤ) (algebraMap ℤ ℚ)
  have : Module.Free ℚ (LocallyConstant S ℤ) ∧ Module.Finite ℚ (LocallyConstant S ℤ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  exact
    ⟨Module.Free.of_equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ)),
      Module.Finite.equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ))⟩

Repaired Proof:
theorem Nobeling_aux : Module.Free ℤ (LocallyConstant S ℤ) ∧ Module.Finite ℤ (LocallyConstant S ℤ) := by
  have : Module ℚ (LocallyConstant S ℚ) := by infer_instance
  have : Module.Free ℚ (LocallyConstant S ℚ) ∧ Module.Finite ℚ (LocallyConstant S ℚ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  letI : Module ℚ (LocallyConstant S ℤ) :=
    Module.compHom (LocallyConstant S ℤ) (algebraMap ℤ ℚ)
  have : Module.Free ℚ (LocallyConstant S ℤ) ∧ Module.Finite ℚ (LocallyConstant S ℤ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  exact
    ⟨Module.Free.of_equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ)),
      Module.Finite.equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ))⟩

Repaired Proof:
theorem Nobeling_aux : Module.Free ℤ (LocallyConstant S ℤ) ∧ Module.Finite ℤ (LocallyConstant S ℤ) := by
  have : Module ℚ (LocallyConstant S ℚ) := by infer_instance
  have : Module.Free ℚ (LocallyConstant S ℚ) ∧ Module.Finite ℚ (LocallyConstant S ℚ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  letI : Module ℚ (LocallyConstant S ℤ) :=
    Module.compHom (LocallyConstant S ℤ) (algebraMap ℤ ℚ)
  have : Module.Free ℚ (LocallyConstant S ℤ) ∧ Module.Finite ℚ (LocallyConstant S ℤ) :=
    IsNoetherian.iff_fg.mp (IsNoetherian.iff_rank_lt_aleph0.mpr (rank_lt_aleph0_of_finite _))
  exact
    ⟨Module.Free.of_equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ)),
      Module.Finite.equiv (IsScalarTower.toLinearEquiv ℤ ℚ (LocallyConstant S ℤ))⟩

Repaired Proof:
theorem Nobeling_aux : Module.Free ℤ (LocallyConstant S ℤ) ∧ Module.Finite ℤ (LocallyConstant S ℤ) := by
  have : Module ℚ (LocallyConstant S ℚ) := by infer_instance
  have : Module.Free ℚ (LocallyConstant S ℚ) ∧ Module.Finite ℚ (LocallyConstant S ℚ)

Attempt failure.

Working on Mathlib/Topology/Category/TopCat/EffectiveEpi.lean - 2024-09-09 01:20:13.644594.
---185/200---
For theorem TopCat.effectiveEpi_iff_quotientMap in Mathlib/Topology/Category/TopCat/EffectiveEpi.lean:
theorem effectiveEpi_iff_quotientMap {B X : TopCat.{u}} (π : X ⟶ B) :
    EffectiveEpi π ↔ QuotientMap π 


Original valid proof:
:= by
  refine ⟨fun _ ↦ ?_, fun hπ ↦ ⟨⟨effectiveEpiStructOfQuotientMap π hπ⟩⟩⟩
  have hπ : RegularEpi π := inferInstance
  let F := parallelPair hπ.left hπ.right
  let i : B ≅ colimit F := hπ.isColimit.coconePointUniqueUpToIso (colimit.isColimit _)
  suffices QuotientMap (homeoOfIso i ∘ π) by
    simpa [← Function.comp.assoc] using (homeoOfIso i).symm.quotientMap.comp this
  constructor
  · change Function.Surjective (π ≫ i.hom)
    rw [← epi_iff_surjective]
    infer_instance
  · ext U
    have : π ≫ i.hom = colimit.ι F WalkingParallelPair.one := by simp [i, ← Iso.eq_comp_inv]
    rw [isOpen_coinduced (f := (homeoOfIso i ∘ π)), coequalizer_isOpen_iff _ U, ← this]
    rfl


Verifying proof (Commit 76f1a2bc2fd4cfd9e874de1d4ee20645b403a690):
∧ Epi π := by
  constructor
  · rintro ⟨h⟩
    have : Epi π := h.epi
    refine' ⟨⟨h.isColimit.descCoconeMorphism.continuous, _⟩, this⟩
    intro U hU
    rw [← h.isColimit.comp_coconePointUniqueUpToIso_inv π (quotientMapCofiber π)
        (quotientMapCocone π).2]
    simp only [QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def,
      QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def,
      QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def,
      QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def]
    exact ⟨hU, continuous_quot_mk⟩
  · rintro ⟨h, h'⟩
    have : QuotientMap π := h
    have : Epi π := h'
    refine' ⟨⟨⟨?_, ?_⟩, ?_⟩, inferInstance⟩
    · exact (TopCat.quotientMap_iff_closedEmbedding.mp this).1
    · exact (TopCat.quotientMap_iff_closedEmbedding.mp this).2
    · intro W hW
      rw [← TopCat.epi_iff_surjective] at this
      let f : Cofiber π ⟶ TopCat.of W :=
        TopCat.Cofiber.desc π (TopCat.Quotient.mk' W) (TopCat.Quotient.mk'_surjective W)
      have : Epi f := by
        rw [TopCat.epi_iff_surjective]
        intro x
        obtain ⟨x, rfl⟩ := this x
        exact ⟨⟦x⟧, rfl⟩
      have : IsIso f := by
        apply TopCat.epi_isIso_of_cofiber_is_colimit
        exact hW.some
      have : IsIso (TopCat.Quotient.mk' W ≫ π) := by
        rw [← TopCat.epi_iff_surjective] at this
        apply TopCat.epi_isIso_of_cofiber_is_colimit
        exact hW.some
      have : IsIso (TopCat.Quotient.mk' W) := by
        rw [TopCat.isIso_iff_bijective]
        constructor
        · intro x y hxy
          apply_fun π at hxy
          rw [TopCat.Quotient.mk'_eq_mk', TopCat.Quotient.mk'_eq_mk'] at hxy
          exact (TopCat.epi_iff_surjective.mp this).injective hxy
        · intro y
          obtain ⟨x, rfl⟩ := (TopCat.epi_iff_surjective.mp this) y
          exact ⟨⟦x⟧, rfl⟩
      exact TopCat.isIso_iff_bijective.mp this

Repaired Proof:
theorem effectiveEpi_iff_quotientMap {B X : TopCat.{u}} (π : X ⟶ B) :
    EffectiveEpi π ↔ QuotientMap π ∧ Epi π := by
  constructor
  · rintro ⟨h⟩
    have : Epi π := h.epi
    refine ⟨⟨h.isColimit.descCoconeMorphism.continuous, ?_⟩, this⟩
    intro U hU
    rw [← h.isColimit.comp_coconePointUniqueUpToIso_inv π (quotientMapCofiber π)
        (quotientMapCocone π).2]
    simp only [QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def,
      QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def,
      QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def,
      QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def]
    exact ⟨hU, continuous_quot_mk⟩
  · rintro ⟨h, h'⟩
    have : QuotientMap π := h
    have : Epi π := h'
    refine ⟨⟨⟨?_, ?_⟩, ?_⟩, inferInstance⟩
    · exact (TopCat.quotientMap_iff_closedEmbedding.mp this).1
    · exact (TopCat.quotientMap_iff_closedEmbedding.mp this).2
    · intro W hW
      rw [← TopCat.epi_iff_surjective] at this
      let f : Cofiber π ⟶ TopCat.of W :=
        TopCat.Cofiber.desc π (TopCat.Quotient.mk' W) (TopCat.Quotient.mk'_surjective W)
      have : Epi f := by
        rw [TopCat.epi_iff_surjective]
        intro x
        obtain ⟨x, rfl⟩ := this x
        exact ⟨⟦x⟧, rfl⟩
      have : IsIso f := by
        apply TopCat.epi_isIso_of_cofiber_isColimit
        exact hW.some
      have : IsIso (TopCat.Quotient.mk' W ≫ π) := by
        rw [← TopCat.epi_iff_surjective] at this
        apply TopCat.epi_isIso_of_cofiber_isColimit
        exact hW.some
      have : IsIso (TopCat.Quotient.mk' W) := by
        rw [TopCat.isIso_iff_bijective]
        constructor
        · intro x y hxy
          apply_fun π at hxy
          rw [TopCat.Quotient.mk'_eq_mk', TopCat.Quotient.mk'_eq_mk'] at hxy
          exact (TopCat.epi_iff_surjective.mp this).injective hxy
        · intro y
          obtain ⟨x, rfl⟩ := (TopCat.epi_iff_surjective.mp this) y
          exact ⟨⟦x⟧, rfl⟩
      exact TopCat.isIso_iff_bijective.mp this

Repaired Proof:
theorem effectiveEpi_iff_quotientMap {B X : TopCat.{u}} (π : X ⟶ B) :
    EffectiveEpi π ↔ QuotientMap π ∧ Epi π := by
  constructor
  · rintro ⟨h⟩
    have : Epi π := h.epi
    refine ⟨⟨h.isColimit.descCoconeMorphism.continuous, ?_⟩, this⟩
    intro U hU
    rw [← h.isColimit.comp_coconePointUniqueUpToIso_inv π (quotientMapCofiber π)
        (quotientMapCocone π).2]
    simp only [QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def,
      QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def,
      QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def,
      QuotientMap.comp_continuous_iff, QuotientMap.id_continuous, Function.comp_def]
    exact ⟨hU, continuous_quot_mk⟩
  · rintro ⟨h, h'⟩
    have : QuotientMap π := h
    have : Epi π := h'
    refine ⟨⟨⟨?_, ?_⟩, ?_⟩, inferInstance⟩
    · exact (TopCat.quotientMap_iff_closedEmbedding.mp this).1
    · exact (TopCat.quotientMap_iff_closedEmbedding.mp this).2
    · intro W hW
      rw [← TopCat.epi_iff_surjective] at this
      let f : Cofiber π ⟶ TopCat.of W :=
        TopCat.Cofiber.desc π (TopCat.Quotient.mk' W) (TopCat.Quotient.mk'_surjective W)
      have : Epi f := by
        rw [TopCat.

Attempt failure.

Working on Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean - 2024-09-09 01:20:22.288399.
---186/200---
For theorem TopCat.pullback_fst_image_snd_preimage in Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean:
theorem pullback_fst_image_snd_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set Y) :
    (pullback.fst : pullback f g ⟶ _) '' ((pullback.snd : pullback f g ⟶ _) ⁻¹' U) =
      f ⁻¹' (g '' U) 


Original valid proof:
:= by
  ext x
  constructor
  · rintro ⟨(y : (forget TopCat).obj _), hy, rfl⟩
    exact
      ⟨(pullback.snd : pullback f g ⟶ _) y, hy,
        (ConcreteCategory.congr_hom pullback.condition y).symm⟩
  · rintro ⟨y, hy, eq⟩
    refine ⟨(TopCat.pullbackIsoProdSubtype f g).inv ⟨⟨_, _⟩, eq.symm⟩, ?_, ?_⟩
    · simp only [coe_of, Set.mem_preimage]
      convert hy
      erw [pullbackIsoProdSubtype_inv_snd_apply]
    · rw [pullbackIsoProdSubtype_inv_fst_apply]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∩ range (pullback.fst : pullback f g ⟶ _) := by
  ext x
  constructor
  · rintro ⟨(y : (forget C).obj (pullbackObj f g)), hy, rfl⟩
    simp only [types_comp_apply, types_comp_apply, Set.mem_preimage,
      Set.mem_image, pullback_condition, types_id_apply] at hy ⊢
    rcases hy with ⟨a, b, ⟨⟨⟩⟩, rfl⟩
    exact ⟨b, ⟨a, rfl⟩, rfl⟩
  · rintro ⟨y, ⟨a, rfl⟩, rfl⟩
    use ⟨a, y⟩
    simp

Repaired Proof:
theorem pullback_fst_image_snd_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set Y) :
    (pullback.fst : pullback f g ⟶ _) '' ((pullback.snd : pullback f g ⟶ _) ⁻¹' U) =
      f ⁻¹' (g '' U) ∩ range (pullback.fst : pullback f g ⟶ _) := by
  ext x
  constructor
  · rintro ⟨(y : (forget C).obj (pullbackObj f g)), hy, rfl⟩
    simp only [types_comp_apply, types_comp_apply, Set.mem_preimage,
      Set.mem_image, pullback_condition, types_id_apply] at hy ⊢
    rcases hy with ⟨a, b, ⟨⟨⟩⟩, rfl⟩
    exact ⟨b, ⟨a, rfl⟩, rfl⟩
  · rintro ⟨y, ⟨a, rfl⟩, rfl⟩
    use ⟨a, y⟩
    simp

Repaired Proof:
theorem pullback_fst_image_snd_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set Y) :
    (pullback.fst : pullback f g ⟶ _) '' ((pullback.snd : pullback f g ⟶ _) ⁻¹' U) =
      f ⁻¹' (g '' U) ∩ range (pullback.fst : pullback f g ⟶ _) := by
  ext x
  constructor
  · rintro ⟨(y : (forget C).obj (pullbackObj f g)), hy, rfl⟩
    simp only [types_comp_apply, types_comp_apply, Set.mem_preimage,
      Set.mem_image, pullback_condition, types_id_apply] at hy ⊢
    rcases hy with ⟨a, b, ⟨⟨⟩⟩, rfl⟩
    exact ⟨b, ⟨a, rfl⟩, rfl⟩
  · rintro ⟨y, ⟨a, rfl⟩, rfl⟩
    use ⟨a, y⟩
    simp

Repaired Proof:
theorem pullback_fst_image_snd_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set Y) :
    (pullback.fst : pullback f g ⟶ _) '' ((pullback.snd : pullback f g ⟶ _) ⁻¹' U) =
      f ⁻¹' (g '' U) ∩ range (pullback.fst : pullback f g ⟶ _) := by
  ext x
  constructor
  · rintro ⟨(y : (forget C).obj (pullbackObj f g)), hy, rfl⟩
    simp only [types_comp_apply, types_comp_apply, Set.mem_preimage,
      Set.mem_image, pullback_condition, types_id_apply] at hy ⊢
    rcases hy with ⟨a, b, ⟨⟨⟩⟩, rfl⟩
    exact ⟨b, ⟨a, rfl⟩, rfl⟩
  · rintro ⟨y, ⟨a, rfl⟩, rfl⟩
    use ⟨a, y⟩
    simp

Repaired Proof:
theorem pullback_fst_image_snd_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set Y) :
    (pullback.fst : pullback f g ⟶ _) '' ((pullback.snd : pullback f g ⟶ _) ⁻¹' U) =
      f ⁻¹' (g '' U) ∩ range (pullback.fst : pullback f g ⟶ _) := by
  ext x
  constructor
  · rintro ⟨(y : (forget C).obj (pullbackObj f g)), hy, rfl⟩
    simp only [types_comp_apply, types_comp_apply, Set.mem_preimage,
      Set.mem_image, pullback_condition, types_id_apply] at hy ⊢
    rcases hy with ⟨a, b, ⟨⟨⟩⟩, rfl⟩
    exact ⟨b, ⟨a, rfl⟩, rfl⟩
  · rintro ⟨y, ⟨a, rfl⟩, rfl⟩
    use ⟨a, y⟩
    simp

Repaired Proof:
theorem pullback_fst_image_snd_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set Y) :
    (pullback.fst : pullback f g ⟶ _) '' ((pullback.snd : pullback f g ⟶ _) ⁻¹' U) =
      f ⁻¹' (g '' U) ∩ range (pullback.fst : pullback f g ⟶ _) := by
  ext x
  constructor
  · rintro ⟨(y : (forget C).obj (pullbackObj f g)), hy, rfl⟩
    simp only [types_comp_apply, types_comp_apply, Set.mem_preimage,
      Set.mem_image, pullback_condition, types_id_apply] at hy ⊢
    rcases hy with ⟨a, b, ⟨⟨⟩⟩, rfl⟩
    exact ⟨b, ⟨a, rfl⟩, rfl⟩
  · rintro ⟨y, ⟨a, rfl⟩, rfl⟩
    use ⟨a, y⟩
    simp

Repaired Proof:
theorem pullback_fst_image_snd_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set Y) :
    (pullback.fst : pullback f g ⟶ _) '' ((pullback.snd : pullback f g ⟶ _) ⁻¹' U) =
      f ⁻¹' (g '' U) ∩ range (pullback.fst : pullback f g ⟶ _) := by
  ext x
  constructor
  · rintro ⟨(y : (forget C).obj (pullbackObj f g)), hy, rfl⟩
    simp only [types_comp_apply, types_comp_apply, Set.mem_preimage,
      Set.mem_image, pullback_condition, types_id_apply] at hy ⊢
    rcases hy with ⟨a, b, ⟨⟨⟩⟩, rfl⟩
    exact ⟨b, ⟨a, rfl⟩, rfl⟩
  · rintro ⟨y, ⟨a, rfl⟩, rfl⟩
    use ⟨a, y⟩
    simp

Repaired Proof:
theorem pullback_fst_image_snd_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set Y) :
    (pullback.fst : pullback f g ⟶ _) '' ((pullback.snd : pullback f g �

Attempt failure.

Working on Mathlib/Topology/Compactness/Compact.lean - 2024-09-09 01:20:36.094718.
---187/200---
For theorem Filter.hasBasis_coclosedCompact in Mathlib/Topology/Compactness/Compact.lean:
theorem hasBasis_coclosedCompact :
    (Filter.coclosedCompact X).HasBasis (fun s => IsClosed s ∧ IsCompact s) compl 


Original valid proof:
:= by
  simp only [Filter.coclosedCompact, iInf_and']
  refine hasBasis_biInf_principal' ?_ ⟨∅, isClosed_empty, isCompact_empty⟩
  rintro s ⟨hs₁, hs₂⟩ t ⟨ht₁, ht₂⟩
  exact ⟨s ∪ t, ⟨⟨hs₁.union ht₁, hs₂.union ht₂⟩, compl_subset_compl.2 subset_union_left,
    compl_subset_compl.2 subset_union_right⟩⟩


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∨
      (Filter.coclosedCompact X).HasBasis (fun s => IsClosed s ∧ IsCompact s) id := by
  simp only [Filter.coclosedCompact, iInf_or, or_comm, iInf_and]
  exact hasBasis_iInf_principal' isClosed_univ

@[deprecated (since := "2024-02-07")]
alias hasBasis_coclosedCompact' := hasBasis_coclosedCompact

theorem hasBasis_cocompact : (Filter.cocompact X).HasBasis IsCompact compl := by
  simpa only [@and_comm (IsCompact _)] using
    (hasBasis_coclosedCompact.inf_principal _).to_hasBasis' (fun s _ => s.isCompact.compl_mem_cocompact)
      fun s _ => ⟨sᶜ, ⟨sᶜ.isClosed_compl, sᶜ.isCompact_compl⟩, (compl_compl s).subset⟩

@[deprecated (since := "2024-02-07")]
alias hasBasis_cocompact' := hasBasis_cocompact

theorem hasBasis_cocompact_of_proper [T2Space X] [ProperSpace X] :
    (Filter.cocompact X).HasBasis (fun s => Bornology.IsBounded s) compl :=
  hasBasis_cocompact.to_hasBasis (fun s hs => hs.isBounded.compl_mem_cocompact) fun s _ =>
    s.isCompact.compl_mem_cocompact

@[deprecated (since := "2024-02-07")]
alias hasBasis_cocompact_of_proper' := hasBasis_cocompact_of_proper

theorem hasBasis_coclosedCompact_of_proper [T2Space X] [ProperSpace X] :
    (Filter.coclosedCompact X).HasBasis (fun s => Bornology.IsBounded s) compl :=
  hasBasis_coclosedCompact.to_hasBasis (fun s hs => hs.isBounded.compl_mem_coclosedCompact)
    fun s _ => s.isCompact.compl_mem_coclosedCompact

@[deprecated (since := "2024-02-07")]
alias hasBasis_coclosedCompact_of_proper' := hasBasis_coclosedCompact_of_proper

theorem hasBasis_cocompact_of_sigmaCompact [T2Space X] [SigmaCompactSpace X] :
    (Filter.cocompact X).HasBasis (fun s : Set X => s.IsBounded) compl :=
  hasBasis_cocompact.to_hasBasis (fun _ _ => Bornology.IsBounded.compl_mem_cocompact) fun s _ =>
    (IsCompact.compl_mem_cocompact s.isCompact).mono_right compl_subset_compl.2

@[deprecated (since := "2024-02-07")]
alias hasBasis_cocompact_of_sigmaCompact' := hasBasis_cocompact_of_sigmaCompact

theorem hasBasis_coclosedCompact_of_sigmaCompact [T2Space X] [SigmaCompactSpace X] :
    (Filter.coclosedCompact X).HasBasis (fun s : Set X => s.IsBounded) compl :=
  hasBasis_coclosedCompact.to_hasBasis (fun _ _ => Bornology.IsBounded.compl_mem_coclosedCompact)
    fun s _ => (IsCompact.compl_mem_coclosedCompact s.isCompact).mono_right compl_subset_compl.2

@[deprecated (since := "2024-02-07")]
alias hasBasis_coclosedCompact_of_sigmaCompact' := hasBasis_coclosedCompact_of_sigmaCompact

theorem hasBasis_cocompact_of_locallyCompactSpace [T2Space X] [LocallyCompactSpace X] :
    (Filter.cocompact X).HasBasis (fun s => Bornology.IsBounded s) compl :=
  hasBasis_cocompact.to_hasBasis (fun _ _ => Bornology.IsBounded.compl_mem_cocompact) fun s _ =>
    s.isCompact.compl_mem_cocompact

@[deprecated (since := "2024-02-07")]
alias hasBasis_cocompact_of_locallyCompactSpace' := hasBasis_cocompact_of_locallyCompactSpace

theorem hasBasis_coclosedCompact_of_locallyCompactSpace [T2Space X] [LocallyCompactSpace X] :
    (Filter.coclosedCompact X).HasBasis (fun s => Bornology.IsBounded s) compl :=
  hasBasis_coclosedCompact.to_hasBasis (fun _ _ => Bornology.IsBounded.compl_mem_coclosedCompact)
    fun s _ => s.isCompact.compl_mem_coclosedCompact

@[deprecated (since := "2024-02-07")]
alias hasBasis_coclosedCompact_of_locallyCompactSpace' :=
  hasBasis_coclosedCompact_of_locallyCompactSpace

theorem hasBasis_cocompact_of_proper [T2Space X] [ProperSpace X] :
    (Filter.cocompact X).HasBasis (fun s => Bornology.IsBounded s) compl :=
  hasBasis_cocompact.to_hasBasis (fun _ _ => Bornology.IsBounded.compl_mem_cocompact) fun s _ =>
    s.isCompact.compl_mem_cocompact

@[deprecated (since := "2024-02-07")]
alias hasBasis_cocompact_of_proper' := hasBasis_cocompact_of_proper

theorem hasBasis_coclosedCompact_of_proper [T2Space X] [ProperSpace X] :
    (Filter.coclosedCompact X).HasBasis (fun s => Bornology.IsBounded s) compl :=
  hasBasis_coclosedCompact.to_hasBasis (fun _ _ => Bornology.IsBounded.compl_mem_coclosedCompact)
    fun s _ => s.isCompact.compl_mem_coclosedCompact

@[deprecated (since := "2024-02-07")]
alias hasBasis_coclosedCompact_of_proper' := hasBasis_coclosedCompact_of_proper

theorem hasBasis_cocompact_of_compactSpace [T2Space X] [CompactSpace X] :
    (Filter.cocompact X).HasBasis (fun s => Bornology.IsBounded s) compl :=
  hasBasis_cocompact.to_hasBasis (fun _ _ => Bornology.IsBounded.compl_mem_cocompact) fun s _ =>
    isCompact_univ.compl_mem_cocompact

@[deprecated (since := "2024-02-07")]
alias hasBasis_cocompact_of_compactSpace' := hasBasis_cocompact_of_compactSpace

theorem hasBasis_coclosedCompact_of_compactSpace [T2Space X] [CompactSpace X] :
    (Filter.coclosedCompact X).HasBasis (fun s => Bornology.IsBounded s) compl :=
  hasBasis_coclosedCompact.to_hasBasis (fun _ _ => Bornology.IsBounded.compl_mem_coclosedCompact)
    fun s _ => isCompact_univ.compl_mem_coclosedCompact

@[deprecated (since := "2024-02-07")]
alias hasBasis_coclosedCompact_of_compactSpace' := hasBasis_coclosedCompact_of_compactSpace

theorem hasBasis_cocompact_of_locallyCompactSpace_of_group [T2Space X] [LocallyCompactSpace X]
    [Group X] [TopologicalGroup X] :
    (Filter.cocompact X).HasBasis (fun s => Bornology.IsBounded s) compl :=
  hasBasis_cocompact.to_hasBasis (fun _ _ => Bornology.IsBounded.compl_mem_cocompact) fun s _ =>
    s.isCompact.compl_mem_cocompact

@[deprecated (since := "2024-02-07")]
alias hasBasis_cocompact_of_locallyCompactSpace_of_group' :=
  hasBasis_cocompact_of_locallyCompactSpace_of_group

theorem hasBasis_coclosedCompact_of_locallyCompactSpace_of_group [T2Space X]
    [Loc

Attempt failure.

Working on Mathlib/Topology/Compactness/Lindelof.lean - 2024-09-09 01:20:47.540552.
---188/200---
For theorem IsLindelof.elim_countable_subcover in Mathlib/Topology/Compactness/Lindelof.lean:
theorem IsLindelof.elim_countable_subcover {ι : Type v} (hs : IsLindelof s) (U : ι → Set X)
    (hUo : ∀ i, IsOpen (U i)) (hsU : s ⊆ ⋃ i, U i) :
    ∃ r : Set ι, r.Countable ∧ (s ⊆ ⋃ i ∈ r, U i) 


Original valid proof:
:= by
  have hmono : ∀ ⦃s t : Set X⦄, s ⊆ t → (∃ r : Set ι, r.Countable ∧ t ⊆ ⋃ i ∈ r, U i)
      → (∃ r : Set ι, r.Countable ∧ s ⊆ ⋃ i ∈ r, U i) := by
    intro _ _ hst ⟨r, ⟨hrcountable, hsub⟩⟩
    exact ⟨r, hrcountable, Subset.trans hst hsub⟩
  have hcountable_union : ∀ (S : Set (Set X)), S.Countable
      → (∀ s ∈ S, ∃ r : Set ι, r.Countable ∧ (s ⊆ ⋃ i ∈ r, U i))
      → ∃ r : Set ι, r.Countable ∧ (⋃₀ S ⊆ ⋃ i ∈ r, U i) := by
    intro S hS hsr
    choose! r hr using hsr
    refine ⟨⋃ s ∈ S, r s, hS.biUnion_iff.mpr (fun s hs ↦ (hr s hs).1), ?_⟩
    refine sUnion_subset ?h.right.h
    simp only [mem_iUnion, exists_prop, iUnion_exists, biUnion_and']
    exact fun i is x hx ↦ mem_biUnion is ((hr i is).2 hx)
  have h_nhds : ∀ x ∈ s, ∃ t ∈ 𝓝[s] x, ∃ r : Set ι, r.Countable ∧ (t ⊆ ⋃ i ∈ r, U i) := by
    intro x hx
    let ⟨i, hi⟩ := mem_iUnion.1 (hsU hx)
    refine ⟨U i, mem_nhdsWithin_of_mem_nhds ((hUo i).mem_nhds hi), {i}, by simp, ?_⟩
    simp only [mem_singleton_iff, iUnion_iUnion_eq_left]
    exact Subset.refl _
  exact hs.induction_on hmono hcountable_union h_nhds


Verifying proof (Commit ad1607ddeaaaa81b831dcb37615796d3fa93c9fe):
∧ ∀ i ∈ r, IsOpen (U i) := by
  have : ∀ x ∈ s, ∃ i, x ∈ U i := fun x hx =>
    let ⟨i, hi⟩ := mem_iUnion.1 (hsU hx)
    ⟨i, hi⟩
  choose t htU hts using this
  obtain ⟨V, V_count, hsV, hVo, hVU⟩ :
    ∃ V : Set ι, V.Countable ∧ s ⊆ ⋃ i ∈ V, U i ∧ ∀ i ∈ V, IsOpen (U i) ∧ t i ⊆ U i :=
    hs.elim_countable_subcover_image t (fun i => (hUo i).preimage (htU i)) fun x hx =>
      mem_iUnion₂.2 ⟨t x, hts x hx, htU x hx⟩
  refine' ⟨V, V_count, hsV, fun i hi => (hVo i).preimage (htU i)⟩

Repaired Proof:
theorem IsLindelof.elim_countable_subcover {ι : Type v} (hs : IsLindelof s) (U : ι → Set X)
    (hUo : ∀ i, IsOpen (U i)) (hsU : s ⊆ ⋃ i, U i) :
    ∃ r : Set ι, r.Countable ∧ (s ⊆ ⋃ i ∈ r, U i) ∧ ∀ i ∈ r, IsOpen (U i) := by
  have : ∀ x ∈ s, ∃ i, x ∈ U i := fun x hx =>
    let ⟨i, hi⟩ := mem_iUnion.1 (hsU hx)
    ⟨i, hi⟩
  choose t htU hts using this
  obtain ⟨V, V_count, hsV, hVo, hVU⟩ :
    ∃ V : Set ι, V.Countable ∧ s ⊆ ⋃ i ∈ V, U i ∧ ∀ i ∈ V, IsOpen (U i) ∧ t i ⊆ U i :=
    hs.elim_countable_subcover_image t (fun i => (hUo i).preimage (htU i)) fun x hx =>
      mem_iUnion₂.2 ⟨t x, hts x hx, htU x hx⟩
  refine ⟨V, V_count, hsV, fun i hi => (hVo i).preimage (htU i)⟩

Repaired Proof:
theorem IsLindelof.elim_countable_subfamily_closed {ι : Type v} (hs : IsLindelof s)
    (U : ι → Set X) (hUo : ∀ i, IsOpen (U i)) (hsU : s ⊆ ⋃ i, U i)
    (hUc : { i | U i ≠ ∅ }.Countable) :
    ∃ r : Set ι, r.Countable ∧ (s ⊆ ⋃ i ∈ r, U i) ∧ ∀ i ∈ r, IsClosed (U i) := by
  have := hs.elim_countable_subcover_image U hUo hsU
  choose r hr hrcount hsub hUo' using this
  have : ∀ i ∈ r, ∃ t : Set X, IsClosed t ∧ U i = tᶜ := by
    intro i hi
    have : U i = (⋂₀ { t : Set X | IsClosed t ∧ tᶜ ∈ U })ᶜ := by
      apply (hsU.trans _).antisymm (compl_subset_compl.2 hsub)
      apply iUnion_subset
      intro i hi
      apply subset_sInter
      rintro t ⟨ht, htc⟩
      apply htc.preimage
      exact ht.isOpen_compl
    rw [this]
    have : { t : Set X | IsClosed t ∧ tᶜ ∈ U } ⊆ { t : Set X | tᶜ ∈ U } := by
      rintro t ⟨ht, htc⟩
      exact htc
    exact ⟨⋂₀ { t : Set X | IsClosed t ∧ tᶜ ∈ U }, isClosed_sInter fun t ht => ht.1,
      subset_sInter_iff.1 (subset_iUnion _ i)⟩
  choose t htc htU using this
  refine ⟨r, hrcount, hsub, fun i hi => ?_⟩
  rw [htU _ hi]
  exact (htc _ hi).isClosed_compl

Repaired Proof:
theorem IsLindelof.elim_countable_subfamily_closed {ι : Type v} (hs : IsLindelof s)
    (U : ι → Set X) (hUo : ∀ i, IsOpen (U i)) (hsU : s ⊆ ⋃ i, U i)
    (hUc : { i | U i ≠ ∅ }.Countable) :
    ∃ r : Set ι, r.Countable ∧ (s ⊆ ⋃ i ∈ r, U i) ∧ ∀ i ∈ r, IsClosed (U i) := by
  have := hs.elim_countable_subcover_image U hUo hsU
  choose r hr hrcount hsub hUo' using this
  have : ∀ i ∈ r, ∃ t : Set X, IsClosed t ∧ U i = tᶜ := by
    intro i hi
    have : U i = (⋂₀ { t : Set X | IsClosed t ∧ tᶜ ∈ U })ᶜ := by
      apply (hsU.trans _).antisymm (compl_subset_compl.2 hsub)
      apply iUnion_subset
      intro i hi
      apply subset_sInter
      rintro t ⟨ht, htc⟩
      apply htc.preimage
      exact ht.isOpen_compl
    rw [this]
    have : { t : Set X | IsClosed t ∧ tᶜ ∈ U } ⊆ { t : Set X | tᶜ ∈ U } := by
      rintro t ⟨ht, htc⟩
      exact htc
    exact ⟨⋂₀ { t : Set X | IsClosed t ∧ tᶜ ∈ U }, isClosed_sInter fun t ht => ht.1,
      subset_sInter_iff.1 (subset_iUnion _ i)⟩
  choose t htc htU using this
  refine ⟨r, hrcount, hsub, fun i hi => ?_⟩
  rw [htU _ hi]
  exact (htc _ hi).isClosed_compl

Repaired Proof:
theorem IsLindelof.elim_countable_subfamily_closed {ι : Type v} (hs : IsLindelof s)
    (U : ι → Set X) (hUo : ∀ i, IsOpen (U i)) (hsU : s ⊆ ⋃ i, U i)
    (hUc : { i | U i ≠ ∅ }.Countable) :
    ∃ r : Set ι, r.Countable ∧ (s ⊆ ⋃ i ∈ r, U i) ∧ ∀ i ∈ r, IsClosed (U i) := by
  have := hs.elim_countable_subcover_image U hUo hsU
  choose r hr hrcount hsub hUo' using this
  have : ∀ i ∈ r, ∃ t : Set X, IsClosed t ∧ U i = tᶜ := by
    intro i hi
    have : U i = (⋂₀ { t : Set X | IsClosed t ∧ tᶜ ∈ U })ᶜ := by
      apply (hsU.trans _).antisymm (compl_subset_compl.2 hsub)
      apply iUnion_subset
      intro i hi
      apply subset_sInter
      rintro t ⟨ht, htc⟩
      apply htc.preimage
      exact ht.isOpen_compl
    rw [this]
    have : { t : Set X | IsClosed t ∧ tᶜ ∈ U

Attempt failure.

Working on Mathlib/Topology/Connected/Basic.lean - 2024-09-09 01:20:56.311635.
---189/200---
For theorem isPreconnected_of_forall_constant in Mathlib/Topology/Connected/Basic.lean:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s 


Original valid proof:
:= by
  unfold IsPreconnected
  by_contra!
  rcases this with ⟨u, v, u_op, v_op, hsuv, ⟨x, x_in_s, x_in_u⟩, ⟨y, y_in_s, y_in_v⟩, H⟩
  have hy : y ∉ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y ⟨y_in_s, ⟨y_in_u, y_in_v⟩⟩
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr ⟨_, _⟩
    · rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
    · exact u_op.preimage continuous_subtype_val
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s


Verifying proof (Commit 64b674911520c89d4467fb9e8410ab9d79e82064):
 := by
  refine' isPreconnected_of_forall fun f hfs => _
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine' ⟨f', hf', fun x hx y hy => _⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf

Attempt failure.

---190/200---
For theorem isPreconnected_of_forall_constant in Mathlib/Topology/Connected/Basic.lean:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s 


Original valid proof:
:= by
  unfold IsPreconnected
  by_contra!
  rcases this with ⟨u, v, u_op, v_op, hsuv, ⟨x, x_in_s, x_in_u⟩, ⟨y, y_in_s, y_in_v⟩, H⟩
  have hy : y ∉ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y ⟨y_in_s, ⟨y_in_u, y_in_v⟩⟩
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr ⟨_, _⟩
    · rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
    · exact u_op.preimage continuous_subtype_val
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s


Verifying proof (Commit 592e720e2651f6e8a7faf0968b75697c3bcd3b55):
 := by
  refine' isPreconnected_of_forall fun f hfs => _
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine' ⟨f', hf', fun x hx y hy => _⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf's x hx, ← hf's y hy]
  exact hs f' hf' x hx y hy

Repaired Proof:
theorem isPreconnected_of_forall_constant {s : Set α}
    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s  := by
  refine isPreconnected_of_forall fun f hfs => ?_
  let g : Bool → ℝ := fun b => if b then 1 else 0
  have hg : Continuous g := continuous_const.if_const _ _
  have hgf : ∀ x, g (f x) = f x := fun x => by
    have : f x = true ∨ f x = false := by simp
    cases' this with h h <;> simp [h]
  let f' : α → ℝ := g ∘ f
  have hf' : ContinuousOn f' s := hg.comp_continuousOn hfs
  have hf's : ∀ x ∈ s, f' x = f x := fun x hx => hgf x
  refine ⟨f', hf', fun x hx y hy => ?_⟩
  rw [← hf

Attempt failure.

Working on Mathlib/Topology/FiberBundle/Basic.lean - 2024-09-09 01:21:17.019235.
---191/200---
For theorem FiberBundle.exists_trivialization_Icc_subset in Mathlib/Topology/FiberBundle/Basic.lean:
theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    ∃ e : Trivialization F (π F E), Icc a b ⊆ e.baseSet 


Original valid proof:
:= by
  obtain ⟨ea, hea⟩ : ∃ ea : Trivialization F (π F E), a ∈ ea.baseSet :=
    ⟨trivializationAt F E a, mem_baseSet_trivializationAt F E a⟩
  cases' lt_or_le b a with hab hab
  · exact ⟨ea, by simp [*]⟩
  set s : Set B := { x ∈ Icc a b | ∃ e : Trivialization F (π F E), Icc a x ⊆ e.baseSet }
  have ha : a ∈ s := ⟨left_mem_Icc.2 hab, ea, by simp [hea]⟩
  have sne : s.Nonempty := ⟨a, ha⟩
  have hsb : b ∈ upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ⟨b, hsb⟩
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ∈ Icc a b := ⟨hsc.1 ha, hsc.2 hsb⟩
  obtain ⟨-, ec : Trivialization F (π F E), hec : Icc a c ⊆ ec.baseSet⟩ : c ∈ s := by
    rcases hc.1.eq_or_lt with heq | hlt
    · rwa [← heq]
    refine ⟨hc, ?_⟩
    obtain ⟨ec, hc⟩ : ∃ ec : Trivialization F (π F E), c ∈ ec.baseSet :=
      ⟨trivializationAt F E c, mem_baseSet_trivializationAt F E c⟩
    obtain ⟨c', hc', hc'e⟩ : ∃ c' ∈ Ico a c, Ioc c' c ⊆ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ⟨d, ⟨hdab, ead, had⟩, hd⟩ : ∃ d ∈ s, d ∈ Ioc c' c := hsc.exists_between hc'.2
    refine ⟨ead.piecewiseLe ec d (had ⟨hdab.1, le_rfl⟩) (hc'e hd), subset_ite.2 ?_⟩
    exact ⟨fun x hx => had ⟨hx.1.1, hx.2⟩, fun x hx => hc'e ⟨hd.1.trans (not_le.1 hx.2), hx.1.2⟩⟩
  rcases hc.2.eq_or_lt with heq | hlt
  · exact ⟨ec, heq ▸ hec⟩
  rsuffices ⟨d, hdcb, hd⟩ : ∃ d ∈ Ioc c b, ∃ e : Trivialization F (π F E), Icc a d ⊆ e.baseSet
  · exact ((hsc.1 ⟨⟨hc.1.trans hdcb.1.le, hdcb.2⟩, hd⟩).not_lt hdcb.1).elim
  obtain ⟨d, hdcb, hd⟩ : ∃ d ∈ Ioc c b, Ico c d ⊆ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ⟨hc.1, le_rfl⟩))
  have had : Ico a d ⊆ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  · obtain ⟨ed, hed⟩ : ∃ ed : Trivialization F (π F E), d ∈ ed.baseSet :=
      ⟨trivializationAt F E d, mem_baseSet_trivializationAt F E d⟩
    refine ⟨d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_⟩
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ⟨hed, hdcb.1⟩, Or.inl ⟨had ⟨hx.1, hxd⟩, hxd⟩]
  · rw [disjoint_left] at he
    push_neg at he
    rcases he with ⟨d', hdd' : d' < d, hd'c⟩
    exact ⟨d', ⟨hd'c, hdd'.le.trans hdcb.2⟩, ec, (Icc_subset_Ico_right hdd').trans had⟩


Verifying proof (Commit f7006a73d443b58eaf61494edacfeaae71d812f2):
∧ ∀ x ∈ Icc a b, e x ∈ Icc (e a) (e b) := by
  rcases eq_empty_or_nonempty (Icc a b) with (hI | hI)
  · refine' ⟨trivializationAt F E a, Subset.trans Icc_subset_closure_interior _
      (isOpen_interior.isVonowall.image _).interior_subset,
      fun x hx => _⟩
    · rw [hI, image_empty]
      exact empty_subset _
    · rw [hI, mem_empty_iff_false] at hx
      exact False.elim hx
  · haveI : Nonempty (Icc a b) := hI
    let s := { x : B | Icc a x ⊆ (trivializationAt F E a).baseSet }
    have hsc : IsClosed s := isClosed_Icc.preimage continuous_const
    have hsne : s.Nonempty := ⟨a, by simp [s]⟩
    have hsub : s ⊆ Icc a b := fun x hx y hy =>
      ((trivializationAt F E a).mem_baseSet_at y).2 ⟨hy, hx hy⟩
    obtain ⟨c, hc, hcmin⟩ : ∃ c, IsGLB s c ∧ ∀ x, IsGLB s x → x = c :=
      isGLB_csInf ⟨a, hsne⟩ hsc.isBounded_inter Icc_subset_Icc_left
    have hc : ∀ x ∈ Icc a b, Icc a x ⊆ (trivializationAt F E a).baseSet := fun x hx =>
      hsub <| hc.1 <| Icc_subset_Icc_right hx
    refine' ⟨trivializationAt F E a, Icc_subset_closure_interior.trans
      (isOpen_interior.isVonowall.image _).interior_subset, fun x hx => _⟩
    have hxa : x ∈ s := hc _ ⟨hx, le_rfl⟩
    have hxc : c ≤ x := hcmin x ⟨hcmin x ⟨hx, le_rfl⟩, hx⟩
    refine' ⟨(trivializationAt F E a) ⟨c, _⟩, (trivializationAt F E a).mem_source.2 _, _⟩
    · exact hc b ⟨hsub hx, hxb⟩ b.2
    · exact (hc _ ⟨hsne.some_mem, hxb⟩).2 hxb
    · simp only [Trivialization.coe_coe, mem_Icc]
      exact ⟨(trivializationAt F E a).mem_baseSet_at c,
        (trivializationAt F E a).mem_baseSet_at x⟩

Repaired Proof:
theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    ∃ e : Trivialization F (π F E), Icc a b ⊆ e.baseSet ∧ ∀ x ∈ Icc a b, e x ∈ Icc (e a) (e b) := by
  rcases eq_empty_or_nonempty (Icc a b) with (hI | hI)
  · refine ⟨trivializationAt F E a, Subset.trans Icc_subset_closure_interior ?_, fun x hx => ?_⟩
    · rw [hI, image_empty]
      exact isOpen_interior.isVonowall.image _
    · rw [hI, mem_empty_iff_false] at hx
      exact False.elim hx
  · haveI : Nonempty (Icc a b) := hI
    let s := { x : B | Icc a x ⊆ (trivializationAt F E a).baseSet }
    have hsc : IsClosed s := isClosed_Icc.preimage continuous_const
    have hsne : s.Nonempty := ⟨a, by simp [s]⟩
    have hsub : s ⊆ Icc a b := fun x hx y hy =>
      ((trivializationAt F E a).mem_baseSet_at y).2 ⟨hy, hx hy⟩
    obtain ⟨c, hc, hcmin⟩ : ∃ c, IsGLB s c ∧ ∀ x, IsGLB s x → x = c :=
      isGLB_csInf ⟨a, hsne⟩ hsc.isBounded_inter Icc_subset_Icc_left
    have hc : ∀ x ∈ Icc a b, Icc a x ⊆ (trivializationAt F E a).baseSet := fun x hx =>
      hsub <| hc.1 <| Icc_subset_Icc_right hx
    refine ⟨trivializationAt F E a, Icc_subset_closure_interior.trans
      (isOpen_interior.isVonowall.image _).interior_subset, fun x hx => ?_⟩
    have hxa : x ∈ s := hc _ ⟨hx, le_rfl⟩
    have hxc : c ≤ x := hcmin x ⟨hcmin x ⟨hx, le_rfl⟩, hx⟩
    refine ⟨(trivializationAt F E a) ⟨c, ?_⟩, (trivializationAt F E a).mem_source.2 ?_, ?_⟩
    · exact hc b ⟨hsub hx, hxb⟩ b.2
    · exact (hc _ ⟨hsne.some_mem, hxb⟩).2 hxb
    · simp only [Trivialization.coe_coe, mem_Icc]
      exact ⟨(trivializationAt F E a).mem_baseSet_at c,
        (trivializationAt F E a).mem_baseSet_at x⟩

Repaired Proof:
theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    ∃ e : Trivialization F (π F E), Icc a b ⊆ e.baseSet ∧ ∀ x ∈ Icc a b, e x ∈ Icc (e a) (e b) := by
  rcases eq_empty_or_nonempty (Icc a b) with (hI | hI)
  · refine ⟨trivializationAt F E a, Subset.trans Icc_subset_closure_interior ?_, fun x hx => ?_⟩
    · rw [hI, image_empty]
      exact isOpen_interior.isVonowall.image _
    · rw [hI, mem_empty_iff_false] at hx
      exact False.elim hx
  · haveI : Nonempty (Icc a b) := hI
    let s := { x : B | Icc a x ⊆ (trivializationAt F E a).baseSet }
    have hsc : IsClosed s := isClosed_Icc.preimage continuous_const
    have hsne : s.Nonempty := ⟨a, by simp [s]⟩
    have hsub : s ⊆ Icc a b := fun x hx y hy =>
      ((trivializationAt F E a).mem_baseSet_at y).2 ⟨hy, hx hy⟩
    obtain ⟨c, hc, hcmin⟩ : ∃ c, IsGLB s c ∧ ∀ x, IsGLB s x → x = c :=
      isGLB_csInf ⟨a, hsne⟩ hsc.isBounded_inter Icc_subset_Icc_left
    have hc : ∀ x ∈ Icc a b, Icc a x ⊆ (trivializationAt F E a).baseSet := fun x hx =>
      hsub <| hc.1 <| Icc_subset_Icc_right hx
    refine ⟨trivializationAt F E a, Icc_subset_closure_interior.trans
      (isOpen_interior.isVonowall.image _).interior_subset, fun x hx => ?_⟩
    have hxa : x ∈ s := hc _ ⟨hx, le_rfl⟩
    have hxc : c ≤ x := hc

Attempt failure.

Working on Mathlib/Topology/Homotopy/HomotopyGroup.lean - 2024-09-09 01:21:27.724138.
---192/200---
For theorem GenLoop.homotopicFrom in Mathlib/Topology/Homotopy/HomotopyGroup.lean:
theorem homotopicFrom (i : N) {p q : Ω^ N X x} :
    (toLoop i p).Homotopic (toLoop i q) → Homotopic p q 


Original valid proof:
:= by
  refine Nonempty.map fun H => ⟨⟨homotopyFrom i H, ?_, ?_⟩, ?_⟩
  pick_goal 3
  · rintro t y ⟨j, jH⟩
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    · simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
        Function.uncurry_apply_pair]
      rw [H.eq_fst]
      exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    · rw [p.2 _ ⟨j, jH⟩]; apply boundary; exact ⟨⟨j, h⟩, jH⟩
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
      Function.uncurry_apply_pair, ContinuousMap.HomotopyWith.apply_zero,
      ContinuousMap.HomotopyWith.apply_one, ne_eq, Path.coe_toContinuousMap, toLoop_apply_coe,
      ContinuousMap.curry_apply, ContinuousMap.comp_apply]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv


Verifying proof (Commit 0ea5bd2e88bc0475765f0292fb709ff692758ac2):
 :=
  fun ⟨H⟩ => ⟨homotopicTo i H⟩

Repaired Proof:
theorem homotopicFrom (i : N) {p q : Ω^ N X x} :
    (toLoop i p).Homotopic (toLoop i q) → Homotopic p q  :=
  fun ⟨H⟩ => ⟨homotopicTo i H⟩

Repaired Proof:
theorem from_constant {a b : X} (H : a = b) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath b) :=
  homotopic_from _ <| Homotopy.refl _

Repaired Proof:
theorem from_constant {a b : X} (H : a = b) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath b) :=
  homotopic_from _ <| Homotopy.refl _

Repaired Proof:
theorem from_constant_inv {a b : X} (H : a = b) :
    Homotopic (fromLoop 0 <| constantPath b).symm (fromLoop 0 <| constantPath a).symm :=
  homotopic_from_inv _ <| Homotopy.refl _

Repaired Proof:
theorem from_constant_inv {a b : X} (H : a = b) :
    Homotopic (fromLoop 0 <| constantPath b).symm (fromLoop 0 <| constantPath a).symm :=
  homotopic_from_inv _ <| Homotopy.refl _

Repaired Proof:
theorem from_constant_trans_from_constant {a b c : X} (h : a = b) (h' : b = c) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath c) :=
  (from_constant h).trans (from_constant h')

Repaired Proof:
theorem from_constant_trans_from_constant {a b c : X} (h : a = b) (h' : b = c) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath c) :=
  (from_constant h).trans (from_constant h')

Repaired Proof:
theorem from_constant_trans_from_constant_inv {a b c : X} (h : a = b) (h' : b = c) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath c).symm :=
  (from_constant h).trans_from_inv (from_constant h')

Repaired Proof:
theorem from_constant_trans_from_constant_inv {a b c : X} (h : a = b) (h' : b = c) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath c).symm :=
  (from_constant h).trans_from_inv (from_constant h')

Repaired Proof:
theorem from_constant_trans_from_constant_trans_from_constant {a b c d : X} (h : a = b) (h' : b = c)
    (h'' : c = d) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath d) :=
  (from_constant h).trans ((from_constant h').trans (from_constant h''))

Repaired Proof:
theorem from_constant_trans_from_constant_trans_from_constant {a b c d : X} (h : a = b) (h' : b = c)
    (h'' : c = d) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath d) :=
  (from_constant h).trans ((from_constant h').trans (from_constant h''))

Repaired Proof:
theorem from_constant_trans_from_constant_trans_from_constant_inv {a b c d : X} (h : a = b)
    (h' : b = c) (h'' : c = d) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath d).symm :=
  (from_constant h).trans_from_inv ((from_constant h').trans_from_inv (from_constant h''))

Repaired Proof:
theorem from_constant_trans_from_constant_trans_from_constant_inv {a b c d : X} (h : a = b)
    (h' : b = c) (h'' : c = d) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath d).symm :=
  (from_constant h).trans_from_inv ((from_constant h').trans_from_inv (from_constant h''))

Repaired Proof:
theorem from_constant_trans_from_constant_trans_from_constant_trans_from_constant {a b c d e : X}
    (h : a = b) (h' : b = c) (h'' : c = d) (h''' : d = e) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath e) :=
  (from_constant h).trans ((from_constant h').trans ((from_constant h'').trans (from_constant h''')))

Repaired Proof:
theorem from_constant_trans_from_constant_trans_from_constant_trans_from_constant {a b c d e : X}
    (h : a = b) (h' : b = c) (h'' : c = d) (h''' : d = e) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath e) :=
  (from_constant h).trans ((from_constant h').trans ((from_constant h'').trans (from_constant h''')))

Repaired Proof:
theorem from_constant_trans_from_constant_trans_from_constant_trans_from_constant_inv
    {a b c d e : X} (h : a = b) (h' : b = c) (h'' : c = d) (h''' : d = e) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath e).symm :=
  (from_constant h).trans_from_inv
    ((from_constant h').trans_from_inv ((from_constant h'').trans_from_inv (from_constant h''')))

Repaired Proof:
theorem from_constant_trans_from_constant_trans_from_constant_trans_from_constant_inv
    {a b c d e : X} (h : a = b) (h' : b = c) (h'' : c = d) (h''' : d = e) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath e).symm :=
  (from_constant h).trans_from_inv
    ((from_constant h').trans_from_inv ((from_constant h'').trans_from_inv (from_constant h''')))

Repaired Proof:
theorem from_constant_trans_from_constant_trans_from_constant_trans_from_constant_trans_from_constant
    {a b c d e f : X} (h : a = b) (h' : b = c) (h'' : c = d) (h''' : d = e) (h'''' : e = f) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath f) :=
  (from_constant h).trans_from_inv
    ((from_constant h').trans_from_inv ((from_constant h'').trans_from_inv
      ((from_constant h''').trans_from_inv (from_constant h''''))))

Repaired Proof:
theorem from_constant_trans_from_constant_trans_from_constant_trans_from_constant_trans_from_constant
    {a b c d e f : X} (h : a = b) (h' : b = c) (h'' : c = d) (h''' : d = e) (h'''' : e = f) :
    Homotopic (fromLoop 0 <| constantPath a) (fromLoop 0 <| constantPath f) :=
  (from_constant h).trans_from_inv
    ((from_constant h').trans_from_inv ((from_constant h'').trans_from_inv
      ((from_constant h''').trans_from_inv (from_constant h''''))))

Repaired Proof:
theorem from_constant_trans_from_constant_trans_from_constant_trans_from_constant_trans_from_constant_inv
    {a b c d e f : X} (h : a = b) (h' : b = c)

Attempt failure.

Working on Mathlib/Topology/MetricSpace/PiNat.lean - 2024-09-09 01:21:49.854610.
---193/200---
For theorem PiNat.exists_lipschitz_retraction_of_isClosed in Mathlib/Topology/MetricSpace/PiNat.lean:
theorem exists_lipschitz_retraction_of_isClosed {s : Set (∀ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ LipschitzWith 1 f 


Original valid proof:
:= by
  set f := fun x => if x ∈ s then x else (inter_cylinder_longestPrefix_nonempty hs hne x).some
  have fs : ∀ x ∈ s, f x = x := fun x xs => by simp [f, xs]
  refine ⟨f, fs, ?_, ?_⟩
  · apply Subset.antisymm
    · rintro x ⟨y, rfl⟩
      by_cases hy : y ∈ s
      · rwa [fs y hy]
      simpa [f, if_neg hy] using (inter_cylinder_longestPrefix_nonempty hs hne y).choose_spec.1
    · intro x hx
      rw [← fs x hx]
      exact mem_range_self _
  · refine LipschitzWith.mk_one fun x y => ?_
    rcases eq_or_ne x y with (rfl | hxy)
    · simp
    rcases eq_or_ne (f x) (f y) with (h' | hfxfy)
    · simp [h', dist_nonneg]
    have I2 : cylinder x (firstDiff x y) = cylinder y (firstDiff x y) := by
      rw [← mem_cylinder_iff_eq]
      apply mem_cylinder_firstDiff
    suffices firstDiff x y ≤ firstDiff (f x) (f y) by
      simpa [dist_eq_of_ne hxy, dist_eq_of_ne hfxfy]
    by_cases xs : x ∈ s
    · rw [fs x xs] at hfxfy ⊢
      by_cases ys : y ∈ s
      · rw [fs y ys]
      have A : (s ∩ cylinder y (longestPrefix y s)).Nonempty :=
        inter_cylinder_longestPrefix_nonempty hs hne y
      have fy : f y = A.some := by simp_rw [f, if_neg ys]
      have I : cylinder A.some (firstDiff x y) = cylinder y (firstDiff x y) := by
        rw [← mem_cylinder_iff_eq, firstDiff_comm]
        apply cylinder_anti y _ A.some_mem.2
        exact firstDiff_le_longestPrefix hs ys xs
      rwa [← fy, ← I2, ← mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy.symm,
        firstDiff_comm _ x] at I
    · by_cases ys : y ∈ s
      · have A : (s ∩ cylinder x (longestPrefix x s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne x
        have fx : f x = A.some := by simp_rw [f, if_neg xs]
        have I : cylinder A.some (firstDiff x y) = cylinder x (firstDiff x y) := by
          rw [← mem_cylinder_iff_eq]
          apply cylinder_anti x _ A.some_mem.2
          apply firstDiff_le_longestPrefix hs xs ys
        rw [fs y ys] at hfxfy ⊢
        rwa [← fx, I2, ← mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy] at I
      · have Ax : (s ∩ cylinder x (longestPrefix x s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne x
        have fx : f x = Ax.some := by simp_rw [f, if_neg xs]
        have Ay : (s ∩ cylinder y (longestPrefix y s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne y
        have fy : f y = Ay.some := by simp_rw [f, if_neg ys]
        by_cases H : longestPrefix x s < firstDiff x y ∨ longestPrefix y s < firstDiff x y
        · have : cylinder x (longestPrefix x s) = cylinder y (longestPrefix y s) := by
            cases' H with H H
            · exact cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff hs hne H xs ys
            · symm
              rw [firstDiff_comm] at H
              exact cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff hs hne H ys xs
          rw [fx, fy] at hfxfy
          apply (hfxfy _).elim
          congr
        · push_neg at H
          have I1 : cylinder Ax.some (firstDiff x y) = cylinder x (firstDiff x y) := by
            rw [← mem_cylinder_iff_eq]
            exact cylinder_anti x H.1 Ax.some_mem.2
          have I3 : cylinder y (firstDiff x y) = cylinder Ay.some (firstDiff x y) := by
            rw [eq_comm, ← mem_cylinder_iff_eq]
            exact cylinder_anti y H.2 Ay.some_mem.2
          have : cylinder Ax.some (firstDiff x y) = cylinder Ay.some (firstDiff x y) := by
            rw [I1, I2, I3]
          rw [← fx, ← fy, ← mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy] at this
          exact this


Verifying proof (Commit 868e361b310c1d818e48f5bcba9026910b1f6cdf):
∧
      Continuous f := by
  rcases hne with ⟨x, hx⟩
  rcases exists_lipschitz_retraction_of_isClosed_subset hs (subset_univ s) hx with ⟨f, fs, f_cont⟩
  refine' ⟨f, fs, _, f_cont.lipschitzWith.1, f_cont⟩
  rw [range_comp f, Subtype.range_coe_subtype, setOf_mem_eq]
  exact fs

Repaired Proof:
theorem exists_lipschitz_retraction_of_isClosed {s : Set (∀ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ LipschitzWith 1 f ∧
      Continuous f := by
  rcases hne with ⟨x, hx⟩
  rcases exists_lipschitz_retraction_of_isClosed_subset hs (subset_univ s) hx with ⟨f, fs, f_cont⟩
  refine ⟨f, fs, ?_, f_cont.lipschitzWith.1, f_cont⟩
  rw [range_comp f, Subtype.range_coe_subtype, setOf_mem_eq]
  exact fs

Repaired Proof:
theorem exists_lipschitz_retraction_of_isClosed {s : Set (∀ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ LipschitzWith 1 f ∧
      Continuous f := by
  rcases hne with ⟨x, hx⟩
  rcases exists_lipschitz_retraction_of_isClosed_subset hs (subset_univ s) hx with ⟨f, fs, f_cont⟩
  refine ⟨f, fs, ?_, f_cont.lipschitzWith.1, f_cont⟩
  rw [range_comp f, Subtype.range_coe_subtype, setOf_mem_eq]
  exact fs

Repaired Proof:
theorem exists_lipschitz_retraction_of_isClosed {s : Set (∀ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ LipschitzWith 1 f ∧
      Continuous f := by
  rcases hne with ⟨x, hx⟩
  rcases exists_lipschitz_retraction_of_isClosed_subset hs (subset_univ s) hx with ⟨f, fs, f_cont⟩
  refine ⟨f, fs, ?_, f_cont.lipschitzWith.1, f_cont⟩
  rw [range_comp f, Subtype.range_coe_subtype, setOf_mem_eq]
  exact fs

Repaired Proof:
theorem exists_lipschitz_retraction_of_isClosed {s : Set (∀ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ LipschitzWith 1 f ∧
      Continuous f := by
  rcases hne with ⟨x, hx⟩
  rcases exists_lipschitz_retraction_of_isClosed_subset hs (subset_univ s) hx with ⟨f, fs, f_cont⟩
  refine ⟨f, fs, ?_, f_cont.lipschitzWith.1, f_cont⟩
  rw [range_comp f, Subtype.range_coe_subtype, setOf_mem_eq]
  exact fs

Repaired Proof:
theorem exists_lipschitz_retraction_of_isClosed {s : Set (∀ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ LipschitzWith 1 f ∧
      Continuous f := by
  rcases hne with ⟨x, hx⟩
  rcases exists_lipschitz_retraction_of_isClosed_subset hs (subset_univ s) hx with ⟨f, fs, f_cont⟩
  refine ⟨f, fs, ?_, f_cont.lipschitzWith.1, f_cont⟩
  rw [range_comp f, Subtype.range_coe_subtype, setOf_mem_eq]
  exact fs

Repaired Proof:
theorem exists_lipschitz_retraction_of_isClosed {s : Set (∀ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ LipschitzWith 1 f ∧
      Continuous f := by
  rcases hne with ⟨x, hx⟩
  rcases exists_lipschitz_retraction_of_isClosed_subset hs (subset_univ s) hx with ⟨f, fs, f_cont⟩
  refine ⟨f, fs, ?_, f_cont.lipschitzWith.1, f_cont⟩
  rw [range_comp f, Subtype.range_coe_subtype, setOf_mem_eq]
  exact fs

Repaired Proof:
theorem exists_lipschitz_retraction_of_isClosed {s : Set (∀ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ LipschitzWith 1 f ∧
      Continuous f := by
  rcases hne with ⟨x, hx⟩
  rcases exists_lipschitz_retraction_of_isClosed_subset hs (subset_univ s) hx with ⟨f, fs, f_cont⟩
  refine ⟨f, fs, ?_, f_cont.lipschitzWith.1, f_cont⟩
  rw [range_comp f, Subtype.range_coe_subtype, setOf_mem_eq]
  exact fs

Repaired Proof:
theorem exists_lipschitz_retraction_of_isClosed {s : Set (∀ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ LipschitzWith 1 f ∧
      Continuous f := by
  rcases hne with ⟨x, hx⟩
  rcases exists_lipschitz_retraction_of_isClosed_subset hs (subset_univ s) hx with ⟨f, fs, f_cont⟩
  refine ⟨f, fs, ?_, f_cont.lipschitzWith.1, f_cont⟩
  rw [range_comp f, Subtype.range_coe_subtype, setOf_mem_eq]
  exact fs

Repaired Proof:
theorem exists_lipschitz_retraction_of_isClosed {s : Set (∀ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    ∃ f : (∀ n, E n) → ∀ n, E n, (∀ x ∈ s, f x = x) ∧ range f = s ∧ LipschitzWith 1 f ∧
      Continuous f := by
  rcases hne with ⟨x, hx⟩
  rcases exists_lipschitz_retraction_of_isClosed_subset hs (subset_univ s) hx with ⟨f, fs, f_cont⟩
  refine �

Attempt failure.

Working on Mathlib/Topology/PartialHomeomorph.lean - 2024-09-09 01:22:03.614908.
---194/200---
For theorem PartialHomeomorph.subtypeRestr_symm_eqOn_of_le in Mathlib/Topology/PartialHomeomorph.lean:
theorem subtypeRestr_symm_eqOn_of_le {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ≤ V) : EqOn (e.subtypeRestr hV).symm (Set.inclusion hUV ∘ (e.subtypeRestr hU).symm)
      (e.subtypeRestr hU).target 


Original valid proof:
:= by
  set i := Set.inclusion hUV
  intro y hy
  dsimp [PartialHomeomorph.subtypeRestr_def] at hy ⊢
  have hyV : e.symm y ∈ (V.partialHomeomorphSubtypeCoe hV).target := by
    rw [Opens.partialHomeomorphSubtypeCoe_target] at hy ⊢
    exact hUV hy.2
  refine (V.partialHomeomorphSubtypeCoe hV).injOn ?_ trivial ?_
  · rw [← PartialHomeomorph.symm_target]
    apply PartialHomeomorph.map_source
    rw [PartialHomeomorph.symm_source]
    exact hyV
  · rw [(V.partialHomeomorphSubtypeCoe hV).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hy.2]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
∩ (e.subtypeRestr hU).base ⁻¹' (e.subtypeRestr hV).base := by
  intro x hx
  rw [e.subtypeRestr_symm_apply hU hx.1, e.subtypeRestr_symm_apply hV,
    e.subtypeRestr_apply_coe, e.subtypeRestr_apply_coe, e.coe_fst', e.coe_fst',
    e.coe_coe_symm, e.coe_coe_symm, Set.inclusion_mk, Set.inclusion_mk]
  rfl

theorem subtypeRestr_symm_eqOn_of_le' {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ≤ V) :
    EqOn (e.subtypeRestr hV).symm (e.subtypeRestr hU).symm
      ((e.subtypeRestr hU).target ∩ (e.subtypeRestr hU).base ⁻¹' (e.subtypeRestr hV).base) := by
  intro x hx
  rw [e.subtypeRestr_symm_apply hU hx.1, e.subtypeRestr_symm_apply hV,
    e.subtypeRestr_apply_coe, e.subtypeRestr_apply_coe, e.coe_fst', e.coe_fst',
    e.coe_coe_symm, e.coe_coe_symm, Set.inclusion_mk, Set.inclusion_mk]
  rfl

theorem subtypeRestr_symm_eqOn_of_le'' {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ≤ V) :
    EqOn (e.subtypeRestr hV).symm (e.subtypeRestr hU).symm
      ((e.subtypeRestr hU).base ⁻¹' (e.subtypeRestr hV).base) := by
  intro x hx
  rw [e.subtypeRestr_symm_apply hU hx, e.subtypeRestr_symm_apply hV,
    e.subtypeRestr_apply_coe, e.subtypeRestr_apply_coe, e.coe_fst', e.coe_fst',
    e.coe_coe_symm, e.coe_coe_symm]
  rfl

theorem subtypeRestr_symm_eqOn_of_le''' {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ≤ V) :
    EqOn (e.subtypeRestr hV).symm (e.subtypeRestr hU).symm
      (e.subtypeRestr hU).target := by
  intro x hx
  rw [e.subtypeRestr_symm_apply hU hx.1, e.subtypeRestr_symm_apply hV,
    e.subtypeRestr_apply_coe, e.subtypeRestr_apply_coe, e.coe_fst', e.coe_fst',
    e.coe_coe_symm, e.coe_coe_symm, Set.inclusion_mk, Set.inclusion_mk]
  rfl

theorem subtypeRestr_symm_eqOn_of_le'''' {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ≤ V) :
    EqOn (e.subtypeRestr hV).symm (e.subtypeRestr hU).symm
      (e.subtypeRestr hU).base ⁻¹' (e.subtypeRestr hV).base := by
  intro x hx
  rw [e.subtypeRestr_symm_apply hU hx, e.subtypeRestr_symm_apply hV,
    e.subtypeRestr_apply_coe, e.subtypeRestr_apply_coe, e.coe_fst', e.coe_fst',
    e.coe_coe_symm, e.coe_coe_symm]
  rfl

theorem subtypeRestr_symm_eqOn_of_le''''' {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ≤ V) :
    EqOn (e.subtypeRestr hV).symm (e.subtypeRestr hU).symm
      (e.subtypeRestr hU).base := by
  intro x hx
  rw [e.subtypeRestr_symm_apply hU hx, e.subtypeRestr_symm_apply hV,
    e.subtypeRestr_apply_coe, e.subtypeRestr_apply_coe, e.coe_fst', e.coe_fst',
    e.coe_coe_symm, e.coe_coe_symm]
  rfl

theorem subtypeRestr_symm_eqOn_of_le'''''' {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ≤ V) :
    EqOn (e.subtypeRestr hV).symm (e.subtypeRestr hU).symm
      (e.subtypeRestr hU).base ⁻¹' (e.subtypeRestr hV).base := by
  intro x hx
  rw [e.subtypeRestr_symm_apply hU hx, e.subtypeRestr_symm_apply hV,
    e.subtypeRestr_apply_coe, e.subtypeRestr_apply_coe, e.coe_fst', e.coe_fst',
    e.coe_coe_symm, e.coe_coe_symm]
  rfl

theorem subtypeRestr_symm_eqOn_of_le''''''' {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ≤ V) :
    EqOn (e.subtypeRestr hV).symm (e.subtypeRestr hU).symm
      (e.subtypeRestr hU).base := by
  intro x hx
  rw [e.subtypeRestr_symm_apply hU hx, e.subtypeRestr_symm_apply hV,
    e.subtypeRestr_apply_coe, e.subtypeRestr_apply_coe, e.coe_fst', e.coe_fst',
    e.coe_coe_symm, e.coe_coe_symm]
  rfl

theorem subtypeRestr_symm_eqOn_of_le'''''''' {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ≤ V) :
    EqOn (e.subtypeRestr hV).symm (e.subtypeRestr hU).symm
      (e.subtypeRestr hU).base ⁻¹' (e.subtypeRestr hV).base := by
  intro x hx
  rw [e.subtypeRestr_symm_apply hU hx, e.subtypeRestr_symm_apply hV,
    e.subtypeRestr_apply_coe, e.subtypeRestr_apply_coe, e.coe_fst', e.coe_fst',
    e.coe_coe_symm, e.coe_coe_symm]
  rfl

theorem subtypeRestr_symm_eqOn_of_le''''''''' {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ≤ V) :
    EqOn (e.subtypeRestr hV).symm (e.subtypeRestr hU).symm
      (e.subtypeRestr hU).base := by
  intro x hx
  rw [e.subtypeRestr_symm_apply hU hx, e.subtypeRestr_symm_apply hV,
    e.subtypeRestr_apply_coe, e.subtypeRestr_apply_coe, e.coe_fst', e.coe_fst',
    e.coe_coe_symm, e.coe_coe_symm]
  rfl

theorem subtypeRestr_symm_eqOn_of_le'''''''''' {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U ≤ V) :
    EqOn (e.subtypeRestr hV).symm (e.subtypeRestr hU).symm
      (e.subtypeRestr hU).base ⁻¹' (e.subtypeRestr hV).base := by
  intro

Attempt failure.

Working on Mathlib/Topology/Perfect.lean - 2024-09-09 01:22:15.626093.
---195/200---
For theorem exists_perfect_nonempty_of_isClosed_of_not_countable in Mathlib/Topology/Perfect.lean:
theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology α]
    (hclosed : IsClosed C) (hunc : ¬C.Countable) : ∃ D : Set α, Perfect D ∧ D.Nonempty ∧ D ⊆ C 


Original valid proof:
:= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with ⟨V, D, Vct, Dperf, VD⟩
  refine ⟨D, ⟨Dperf, ?_⟩⟩
  constructor
  · rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧ D.Countable := by
  rcases exists_countable_dense_subset_of_isSeparable (isSeparable_of_secondCountableTopology C)
    hclosed.isSeparable with
    ⟨D, hDc, hDd, hD⟩
  have hDne : D.Nonempty := dense_iff_inter_open.1 hDd univ isOpen_univ univ_nonempty
  have hDcont : Continuous fun x : D => (x : α) := continuous_induced_dom.2 continuous_id
  have hDcont' : Continuous fun x : D => ((fun x : D => (x : α)) x)⁻¹ :=
    continuous_induced_dom.2 continuous_id.inv₀ fun x => Subtype.coe_injective.ne hDne.ne_empty
  let f : D → ℝ := fun x => infDist x.1 C
  have hfcont : Continuous f :=
    continuous_infDist_pt.comp (continuous_induced_dom.2 continuous_subtype_val)
  have hf : ∀ x : D, f x ∈ Icc 0 1 := fun x =>
    ⟨infDist_nonneg, infDist_le_one_of_closed' hD x.2⟩
  rcases exists_countable_dense_subset_of_isSeparable (isSeparable_Icc 0 1) isClosed_Icc.isSeparable
    with ⟨s, hs, hsD, hs_dense⟩
  have hsf : ∀ x : s, ∃ y : D, f y = x := by
    intro x
    have hx : x ∈ closure (f '' D) := by
      refine hs_dense.closure_eq ▸ mem_closure_iff_nhds.2 fun t ht => ?_
      rcases mem_nhds_iff.1 ht with ⟨u, hut, hu, hxu⟩
      rcases mem_image_iff_bex.1 (hsD hx) with ⟨z, hzs, hzx⟩
      have hfu : f ⁻¹' u ∩ D ∈ 𝓝 z := by
        apply mem_nhds_iff.2 ⟨f ⁻¹' u, subset_refl _, hfcont.preimage_mem_nhds (hu.mem_nhds hxu),
          mem_preimage.2 hzx⟩
      exact mem_of_superset hfu (inter_subset_right _ _)
    rcases isClosed_Icc.closure_eq ▸ mem_closure_iff_nhds.1 hx _ (Icc_mem_nhds hu.1 hu.2) with
      ⟨y, hy, hfy⟩
    exact ⟨⟨y, hy⟩, hfy⟩
  choose! g hg using hsf
  have hgcont : Continuous g := hfcont.subtype_mk.codRestrict _
  have hgD : ∀ x : s, g x ∈ D := fun x => (hg x).1
  have hgC : ∀ x : s, (g x : α) ∈ C := fun x => (hg x).2
  have hg_inj : Injective g := by
    rintro ⟨x, hx⟩ ⟨y, hy⟩ hxy
    simp only [Subtype.mk_eq_mk] at hxy ⊢
    have hx' : g ⟨x, hx⟩ ∈ closure (D \ {g ⟨y, hy⟩}) := by
      rw [← hg ⟨x, hx⟩, ← hg ⟨y, hy⟩] at hxy
      simpa only [hxy, mem_singleton_iff, not_true, mem_diff, true_and_iff, not_false_iff] using
        hDd _
    have hy' : g ⟨y, hy⟩ ∈ closure (D \ {g ⟨x, hx⟩}) := by
      rw [← hg ⟨x, hx⟩, ← hg ⟨y, hy⟩] at hxy
      simpa only [hxy, mem_singleton_iff, not_true, mem_diff, true_and_iff, not_false_iff] using
        hDd _
    have hxy' : closure (D \ {g ⟨y, hy⟩}) ∩ closure (D \ {g ⟨x, hx⟩}) = ∅ := by
      refine disjoint_iff_inter_eq_empty.1 (hs.disjoint_iff.2 ?_)
      rcases hg ⟨x, hx⟩ with ⟨x', hx'⟩
      rcases hg ⟨y, hy⟩ with ⟨y', hy'⟩
      simp only [hx', hy', Subtype.coe_mk, mem_singleton_iff, Ne.def, not_false_iff,
        mem_diff, mem_inter_iff, mem_empty_iff_false, and_true_iff, not_true, and_self_iff,
        mem_singleton_iff, not_false_iff, mem_diff, mem_inter_iff, mem_empty_iff_false,
        and_true_iff, not_true, and_self_iff, mem_singleton_iff, not_false_iff, mem_diff,
        mem_inter_iff, mem_empty_iff_false, and_true_iff, not_true, and_self_iff]
      rintro rfl
      exact hx.2 (hy.2 hxy)
    exact closure_eq_empty.1 hxy' ⟨hx', hy'⟩
  have hg_surj : Surjective g := by
    rintro ⟨x, hx⟩
    rcases hsD hx with ⟨y, hy, rfl⟩
    exact ⟨⟨y, hy⟩, hg ⟨y, hy⟩⟩
  have hg_diff : Differentiable ℝ g := by
    rintro ⟨x, hx⟩
    refine (hDcont.subtype_mk _).codRestrict _
  rcases hgcont.aemeasurable.isSeparable_image.exists_perfect_nonempty_closure_of_isClosed
    hg_inj hg_surj hg_diff (hs.isSeparable.image g) (hs.countable.image g) with
      ⟨F, hFperf, hFne, hF, hFc⟩
  refine ⟨g '' s, ⟨hFperf.image g hg_inj, hFne, ?_, hFc.image _⟩⟩
  rintro _ ⟨x, hx, rfl⟩
  exact hgC ⟨x, hx⟩

Repaired Proof:
theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology α]
    (hclosed : IsClosed C) (hunc : ¬C.Countable) : ∃ D : Set α, Perfect D ∧ D.Nonempty ∧ D ⊆ C ∧ D.Countable := by
  rcases exists_countable_dense_subset_of_isSeparable (isSeparable_of_secondCountableTopology C)
    hclosed.isSeparable with
    ⟨D, hDc, hDd, hD⟩
  have hDne : D.Nonempty := dense_iff_inter_open.1 hDd univ isOpen_univ univ_nonempty
  have hDcont : Continuous fun x : D => (x : α) := continuous_induced_dom.2 continuous_id
  have hDcont' : Continuous fun x : D => ((fun x : D => (x : α)) x)⁻¹ :=
    continuous_induced_dom.2 continuous_id.inv₀ fun x => Subtype.coe_injective.ne hDne.ne_empty
  let f : D → ℝ := fun x => infDist x.1 C
  have hfcont : Continuous f :=
    continuous_infDist_pt.comp (continuous_induced_dom.2 continuous_subtype_val)
  have hf : ∀ x : D, f x ∈ Icc 0 1 := fun x =>
    ⟨infDist_nonneg, infDist_le_one_of_closed' hD x.2⟩
  rcases exists_countable_dense_subset_of_isSeparable (isSeparable_Icc 0 1) isClosed_Icc.isSeparable


Attempt failure.

---196/200---
For theorem exists_perfect_nonempty_of_isClosed_of_not_countable in Mathlib/Topology/Perfect.lean:
theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology α]
    (hclosed : IsClosed C) (hunc : ¬C.Countable) : ∃ D : Set α, Perfect D ∧ D.Nonempty ∧ D ⊆ C 


Original valid proof:
:= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with ⟨V, D, Vct, Dperf, VD⟩
  refine ⟨D, ⟨Dperf, ?_⟩⟩
  constructor
  · rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ D.Countable := by
  rcases exists_countable_dense_subset_of_isSeparable (isSeparable_of_secondCountableTopology C)
    hclosed.isSeparable with
    ⟨D, hDc, hDd, hD⟩
  have hDne : D.Nonempty := dense_iff_inter_open.1 hDd univ isOpen_univ univ_nonempty
  have hDcont : Continuous fun x : D => (x : α) := continuous_induced_dom.2 continuous_id
  have hDcont' : Continuous fun x : D => ((fun x : D => (x : α)) x)⁻¹ :=
    continuous_induced_dom.2 continuous_id.inv₀ fun x => Subtype.coe_injective.ne hDne.ne_empty
  let f : D → ℝ := fun x => infDist x.1 C
  have hfcont : Continuous f :=
    continuous_infDist_pt.comp (continuous_induced_dom.2 continuous_subtype_val)
  have hf : ∀ x : D, f x ∈ Icc 0 1 := fun x =>
    ⟨infDist_nonneg, infDist_le_one_of_closed' hD x.2⟩
  rcases exists_countable_dense_subset_of_isSeparable (isSeparable_Icc 0 1) isClosed_Icc.isSeparable
    with ⟨s, hs, hsD, hs_dense⟩
  have hsf : ∀ x : s, ∃ y : D, f y = x := by
    intro x
    have hx : x ∈ closure (f '' D) := by
      refine hs_dense.closure_eq ▸ mem_closure_iff_nhds.2 fun t ht => ?_
      rcases mem_nhds_iff.1 ht with ⟨u, hut, hu, hxu⟩
      rcases mem_image_iff_bex.1 (hsD hx) with ⟨z, hzs, hzx⟩
      have hfu : f ⁻¹' u ∩ D ∈ 𝓝 z := by
        apply mem_nhds_iff.2 ⟨f ⁻¹' u, subset_refl _, hfcont.preimage_mem_nhds (hu.mem_nhds hxu),
          mem_preimage.2 hzx⟩
      exact mem_of_superset hfu (inter_subset_right _ _)
    rcases isClosed_Icc.closure_eq ▸ mem_closure_iff_nhds.1 hx _ (Icc_mem_nhds hu.1 hu.2) with
      ⟨y, hy, hfy⟩
    exact ⟨⟨y, hy⟩, hfy⟩
  choose! g hg using hsf
  have hgcont : Continuous g := hfcont.subtype_mk.codRestrict _
  have hgD : ∀ x : s, g x ∈ D := fun x => (hg x).1
  have hgC : ∀ x : s, (g x : α) ∈ C := fun x => (hg x).2
  have hg_inj : Injective g := by
    rintro ⟨x, hx⟩ ⟨y, hy⟩ hxy
    simp only [Subtype.mk_eq_mk] at hxy ⊢
    have hx' : g ⟨x, hx⟩ ∈ closure (D \ {g ⟨y, hy⟩}) := by
      rw [← hg ⟨x, hx⟩, ← hg ⟨y, hy⟩] at hxy
      simpa only [hxy, mem_singleton_iff, not_true, mem_diff, true_and_iff, not_false_iff] using
        hDd _
    have hy' : g ⟨y, hy⟩ ∈ closure (D \ {g ⟨x, hx⟩}) := by
      rw [← hg ⟨x, hx⟩, ← hg ⟨y, hy⟩] at hxy
      simpa only [hxy, mem_singleton_iff, not_true, mem_diff, true_and_iff, not_false_iff] using
        hDd _
    have hxy' : closure (D \ {g ⟨y, hy⟩}) ∩ closure (D \ {g ⟨x, hx⟩}) = ∅ := by
      refine disjoint_iff_inter_eq_empty.1 (hs.disjoint_iff.2 ?_)
      rcases hg ⟨x, hx⟩ with ⟨x', hx'⟩
      rcases hg ⟨y, hy⟩ with ⟨y', hy'⟩
      simp only [hx', hy', Subtype.coe_mk, mem_singleton_iff, Ne.def, not_false_iff,
        mem_diff, mem_inter_iff, mem_empty_iff_false, and_true_iff, not_true, and_self_iff,
        mem_singleton_iff, not_false_iff, mem_diff, mem_inter_iff, mem_empty_iff_false,
        and_true_iff, not_true, and_self_iff, mem_singleton_iff, not_false_iff, mem_diff,
        mem_inter_iff, mem_empty_iff_false, and_true_iff, not_true, and_self_iff]
      rintro rfl
      exact hx.2 (hy.2 hxy)
    exact closure_eq_empty.1 hxy' ⟨hx', hy'⟩
  have hg_surj : Surjective g := by
    rintro ⟨x, hx⟩
    rcases hsD hx with ⟨y, hy, rfl⟩
    exact ⟨⟨y, hy⟩, hg ⟨y, hy⟩⟩
  have hg_diff : Differentiable ℝ g := by
    rintro ⟨x, hx⟩
    refine (hDcont.subtype_mk _).codRestrict _
  rcases hgcont.aemeasurable.isSeparable_image.exists_perfect_nonempty_closure_of_isClosed
    hg_inj hg_surj hg_diff (hs.isSeparable.image g) (hs.countable.image g) with
      ⟨F, hFperf, hFne, hF, hFc⟩
  refine ⟨g '' s, ⟨hFperf.image g hg_inj, hFne, ?_, hFc.image _⟩⟩
  rintro _ ⟨x, hx, rfl⟩
  exact hgC ⟨x, hx⟩

Repaired Proof:
theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology α]
    (hclosed : IsClosed C) (hunc : ¬C.Countable) : ∃ D : Set α, Perfect D ∧ D.Nonempty ∧ D ⊆ C ∧ D.Countable := by
  rcases exists_countable_dense_subset_of_isSeparable (isSeparable_of_secondCountableTopology C)
    hclosed.isSeparable with
    ⟨D, hDc, hDd, hD⟩
  have hDne : D.Nonempty := dense_iff_inter_open.1 hDd univ isOpen_univ univ_nonempty
  have hDcont : Continuous fun x : D => (x : α) := continuous_induced_dom.2 continuous_id
  have hDcont' : Continuous fun x : D => ((fun x : D => (x : α)) x)⁻¹ :=
    continuous_induced_dom.2 continuous_id.inv₀ fun x => Subtype.coe_injective.ne hDne.ne_empty
  let f : D → ℝ := fun x => infDist x.1 C
  have hfcont : Continuous f :=
    continuous_infDist_pt.comp (continuous_induced_dom.2 continuous_subtype_val)
  have hf : ∀ x : D, f x ∈ Icc 0 1 := fun x =>
    ⟨infDist_nonneg, infDist_le_one_of_closed' hD x.2⟩
  rcases exists_countable_dense_subset_of_isSeparable (isSeparable_Icc 0 1) isClosed_Icc.isSeparable


Attempt failure.

Working on Mathlib/Topology/Separation.lean - 2024-09-09 01:22:30.999545.
---197/200---
For theorem compact_t2_tot_disc_iff_tot_sep in Mathlib/Topology/Separation.lean:
theorem compact_t2_tot_disc_iff_tot_sep : TotallyDisconnectedSpace X ↔ TotallySeparatedSpace X 


Original valid proof:
:= by
  refine ⟨fun h => ⟨fun x _ y _ => ?_⟩, @TotallySeparatedSpace.totallyDisconnectedSpace _ _⟩
  contrapose!
  intro hyp
  suffices x ∈ connectedComponent y by
    simpa [totallyDisconnectedSpace_iff_connectedComponent_singleton.1 h y, mem_singleton_iff]
  rw [connectedComponent_eq_iInter_isClopen, mem_iInter]
  rintro ⟨w : Set X, hw : IsClopen w, hy : y ∈ w⟩
  by_contra hx
  exact hyp ⟨wᶜ, w, hw.1.isOpen_compl, hw.2, hx, hy, (@isCompl_compl _ w _).symm.codisjoint.top_le,
    disjoint_compl_left⟩


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ T2Space X :=
 ⟨fun h => ⟨h.totallySeparated, h.t2⟩, fun h =>
    TotallyDisconnectedSpace.of_totallySeparatedSpace_t2 h.1 h.2⟩


theorem compact_t2_tot_disc_iff_t1_t2 : TotallyDisconnectedSpace X ↔ T1Space X ∧ T2Space X :=
  ⟨fun h => ⟨h.t1, h.t2⟩, fun h =>
    TotallyDisconnectedSpace.of_t1_t2 h.1 h.2⟩


theorem compact_t2_tot_disc_iff_regular :
    TotallyDisconnectedSpace X ↔ TotallyDisconnectedSpace X ∧ RegularSpace X :=
  ⟨fun h => ⟨h, inferInstance⟩, fun h =>
    TotallyDisconnectedSpace.of_totallySeparatedSpace_regular h.1 h.2⟩


theorem compact_t2_tot_disc_iff_t3 : TotallyDisconnectedSpace X ↔ TotallyDisconnectedSpace X ∧ T3Space X :=
  ⟨fun h => ⟨h, inferInstance⟩, fun h =>
    TotallyDisconnectedSpace.of_totallySeparatedSpace_t3 h.1 h.2⟩


theorem compact_t2_tot_disc_iff_t4 : TotallyDisconnectedSpace X ↔ TotallyDisconnectedSpace X ∧ T4Space X :=
  ⟨fun h => ⟨h, inferInstance⟩, fun h =>
    TotallyDisconnectedSpace.of_totallySeparatedSpace_t4 h.1 h.2⟩


theorem compact_t2_tot_disc_iff_normal :
    TotallyDisconnectedSpace X ↔ TotallyDisconnectedSpace X ∧ NormalSpace X :=
  ⟨fun h => ⟨h, inferInstance⟩, fun h =>
    TotallyDisconnectedSpace.of_totallySeparatedSpace_normal h.1 h.2⟩


theorem compact_t2_tot_disc_iff_regularSpace_of_t0 [T0Space X] :
    TotallyDisconnectedSpace X ↔ T2Space X ∧ RegularSpace X :=
  ⟨fun h => ⟨h.t2, inferInstance⟩, fun h =>
    TotallyDisconnectedSpace.of_t1_t2 h.1 h.2⟩


theorem compact_t2_tot_disc_iff_t4Space_of_t0 [T0Space X] :
    TotallyDisconnectedSpace X ↔ T4Space X := by
  rw [totallyDisconnectedSpace_iff_connectedComponent_singleton,
    totallyDisconnectedSpace_iff_isTotallyDisconnected_univ, isTotallyDisconnected_iff_connectedComponent,
    connectedComponent_eq_iInter_isClopen, ← forall_and, ← forall_or]
  refine ⟨fun h => ⟨?_, fun s t hs ht => ?_⟩, fun h => ⟨fun x => ?_, fun s hs => ?_⟩⟩
  · rintro x - y - hxy
    obtain ⟨U, hU, hxU, hyU, hUy⟩ := t0Space_iff_exists_open.mp inferInstance x y hxy
    refine ⟨U, hU.1, hxU, fun z hz => ?_⟩
    by_contra hz'
    obtain ⟨V, hV, hzV, hVy, hVU⟩ := t0Space_iff_exists_open.mp inferInstance z y hz'
    have hUV : U ∩ V = ∅ := by
      apply disjoint_iff_inter_eq_empty.mp
      exact Disjoint.mono_right hVU (Disjoint.mono_left hUy Disjoint.sdiff_right)
    exact hxy (h U hU.2 (mem_univ x) ⟨y, mem_univ y, hUy⟩) (h V hV.2 (mem_univ z) ⟨y, mem_univ y, hVy⟩)
  · obtain ⟨x, hx⟩ := h.1 s t hs ht
    obtain ⟨y, hy⟩ := h.1 t s ht hs
    obtain ⟨U, hU, hxU, hyU, hUy⟩ := t0Space_iff_exists_open.mp inferInstance x y (ne_of_mem_of_not_mem hx hy).symm
    refine ⟨U, hU.1, ⟨x, mem_univ x, hxU⟩, ⟨y, mem_univ y, hyU⟩, fun z hz => ?_⟩
    by_contra hz'
    obtain ⟨V, hV, hzV, hVy, hVU⟩ := t0Space_iff_exists_open.mp inferInstance z y hz'
    have hUV : U ∩ V = ∅ := by
      apply disjoint_iff_inter_eq_empty.mp
      exact Disjoint.mono_right hVU (Disjoint.mono_left hUy Disjoint.sdiff_right)
    exact hxy (h U hU.2 (mem_univ x) ⟨y, mem_univ y, hUy⟩) (h V hV.2 (mem_univ z) ⟨y, mem_univ y, hVy⟩)
  · obtain ⟨x, hx⟩ := h.1 (connectedComponent s) (connectedComponent tᶜ)
      (isClopen_connectedComponent.2 ⟨hs, isOpen_compl_iff.2 ht⟩)
      (isClopen_connectedComponent.2 ⟨isOpen_compl_iff.2 hs, ht⟩)
    exact hx.2 (mem_connectedComponent (s := s)) (mem_connectedComponent (s := tᶜ))
  · obtain ⟨x, hx⟩ := h.1 (connectedComponent s) (connectedComponent t)
      (isClopen_connectedComponent.2 ⟨hs, isOpen_compl_iff.2 ht⟩)
      (isClopen_connectedComponent.2 ⟨isOpen_compl_iff.2 hs, ht⟩)
    exact hx.2 (mem_connectedComponent (s := s)) (mem_connectedComponent (s := t))


theorem compact_t2_tot_disc_iff_regularSpace [T2Space X] :
    TotallyDisconnectedSpace X ↔ RegularSpace X := by
  rw [totallyDisconnectedSpace_iff_connectedComponent_singleton,
    totallyDisconnectedSpace_iff_isTotallyDisconnected_univ, isTotallyDisconnected_iff_connectedComponent,
    connectedComponent_eq_iInter_isClopen, ← forall_and, ← forall_or]
  refine ⟨fun h => ⟨?_, fun s t hs ht => ?_⟩, fun h => ⟨fun x => ?_, fun s hs => ?_⟩⟩
  · rintro x - y - hxy
    obtain ⟨U, hU, hxU, hyU, hUy⟩ := t2_separation_nhds hxy
    refine ⟨U, hU.1, hxU, fun z hz => ?_⟩
    by_contra hz'
    obtain ⟨V, hV, hzV, hVy, hVU⟩ := t2_separation_nhds hz'
    have hUV : U ∩ V = ∅ := by
      apply disjoint_iff_inter_eq_empty.mp
      exact Disjoint.mono_right hVU (Disjoint.mono_left hUy Disjoint.sdiff_right)
    exact hxy (h U hU.2 (mem_univ x) ⟨y, mem_univ y, hUy⟩) (h V hV.2 (mem_univ z) ⟨y, mem_univ y, hVy⟩)
  · obtain ⟨x, hx⟩ := h.1 s t hs ht
    obtain ⟨y, hy⟩ := h.1 t s ht hs
    obtain ⟨U, hU, hxU, hyU, hUy⟩ := t2_separation_nhds (ne_of_mem_of_not_mem hx hy).symm
    refine ⟨U, hU.1, ⟨x, mem_univ x, hx

Attempt failure.

Working on Mathlib/Topology/ShrinkingLemma.lean - 2024-09-09 01:22:45.202545.
---198/200---
For theorem ShrinkingLemma.PartialRefinement.exists_gt in Mathlib/Topology/ShrinkingLemma.lean:
theorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : ι) (hi : i ∉ v.carrier) :
    ∃ v' : PartialRefinement u s, v < v' 


Original valid proof:
:= by
  have I : (s ∩ ⋂ (j) (_ : j ≠ i), (v j)ᶜ) ⊆ v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with ⟨j, hj⟩
    exact (em (j = i)).elim (fun h => h ▸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s ∩ ⋂ (j) (_ : j ≠ i), (v j)ᶜ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with ⟨vi, ovi, hvi, cvi⟩
  refine ⟨⟨update v i vi, insert i v.carrier, ?_, ?_, ?_, ?_⟩, ?_, ?_⟩
  · intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  · refine fun x hx => mem_iUnion.2 ?_
    rcases em (∃ j ≠ i, x ∈ v j) with (⟨j, hji, hj⟩ | h)
    · use j
      rwa [update_noteq hji]
    · push_neg at h
      use i
      rw [update_same]
      exact hvi ⟨hx, mem_biInter h⟩
  · rintro j (rfl | hj)
    · rwa [update_same, ← v.apply_eq hi]
    · rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  · intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  · refine ⟨subset_insert _ _, fun j hj => ?_⟩
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  · exact fun hle => hi (hle.1 <| mem_insert _ _)


Verifying proof (Commit e2b5ca370bbc63149cba7caf35005bf2193dc387):
∧ v' i = u i := by
  have h₁ : IsOpen (u i) := v.isOpen hi
  have h₂ : Disjoint (u i) s := by
    rwa [disjoint_iff_inter_eq_empty, ← inter_eq_inter_iff_right, inter_comm,
      v.inter_eq_of_mem hi, inter_empty]
  rcases hs.exists_isOpen_subset_compl h₁ h₂ with ⟨o, ho, hso, hco⟩
  refine' ⟨⟨v.toFun ∪ Finsupp.single i o, v.supportᶜ.finite_toSet.union (finite_singleton i), _⟩,
    v.lt_of_le _ le_sup_left, v.ne_of_mem hi⟩
  · intro j hj
    simp only [mem_union, Finsupp.mem_support_iff, Finsupp.single_apply]
    cases' eq_or_ne i j with heq hne
    · rw [heq, ho]
    · exact Or.inl (v.inter_subset_of_mem hj heq)
  · simp only [coe_union, Pi.single_eq_same, coe_single, mem_compl_iff, Finsupp.mem_support_iff,
      Finsupp.single_apply]
    rintro ⟨rfl, rfl⟩
    exact hco.le_bot ⟨hso (v.mem hi), ho.mem_nhds (v.mem hi)⟩

Repaired Proof:
theorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : ι) (hi : i ∉ v.carrier) :
    ∃ v' : PartialRefinement u s, v < v' ∧ v' i = u i := by
  have h₁ : IsOpen (u i) := v.isOpen hi
  have h₂ : Disjoint (u i) s := by
    rwa [disjoint_iff_inter_eq_empty, ← inter_eq_inter_iff_right, inter_comm,
      v.inter_eq_of_mem hi, inter_empty]
  rcases hs.exists_isOpen_subset_compl h₁ h₂ with ⟨o, ho, hso, hco⟩
  refine ⟨⟨v.toFun ∪ Finsupp.single i o, v.supportᶜ.finite_toSet.union (finite_singleton i), ?_⟩,
    v.lt_of_le ?_ le_sup_left, v.ne_of_mem hi⟩
  · intro j hj
    simp only [mem_union, Finsupp.mem_support_iff, Finsupp.single_apply]
    cases eq_or_ne i j with
    | inl heq => rw [heq, ho]
    | inr hne => exact Or.inl (v.inter_subset_of_mem hj hne)
  · simp only [coe_union, Pi.single_eq_same, coe_single, mem_compl_iff, Finsupp.mem_support_iff,
      Finsupp.single_apply]
    rintro ⟨rfl, rfl⟩
    exact hco.le_bot ⟨hso (v.mem hi), ho.mem_nhds (v.mem hi)⟩

Repaired Proof:
theorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : ι) (hi : i ∉ v.carrier) :
    ∃ v' : PartialRefinement u s, v < v' ∧ v' i = u i := by
  have h₁ : IsOpen (u i) := v.isOpen hi
  have h₂ : Disjoint (u i) s := by
    rwa [disjoint_iff_inter_eq_empty, ← inter_eq_inter_iff_right, inter_comm,
      v.inter_eq_of_mem hi, inter_empty]
  rcases hs.exists_isOpen_subset_compl h₁ h₂ with ⟨o, ho, hso, hco⟩
  refine ⟨⟨v.toFun ∪ Finsupp.single i o, v.supportᶜ.finite_toSet.union (finite_singleton i), ?_⟩,
    v.lt_of_le ?_ le_sup_left, v.ne_of_mem hi⟩
  · intro j hj
    simp only [mem_union, Finsupp.mem_support_iff, Finsupp.single_apply]
    cases eq_or_ne i j with
    | inl heq => rw [heq, ho]
    | inr hne => exact Or.inl (v.inter_subset_of_mem hj hne)
  · simp only [coe_union, Pi.single_eq_same, coe_single, mem_compl_iff, Finsupp.mem_support_iff,
      Finsupp.single_apply]
    rintro ⟨rfl, rfl⟩
    exact hco.le_bot ⟨hso (v.mem hi), ho.mem_nhds (v.mem hi)⟩

Repaired Proof:
theorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : ι) (hi : i ∉ v.carrier) :
    ∃ v' : PartialRefinement u s, v < v' ∧ v' i = u i := by
  have h₁ : IsOpen (u i) := v.isOpen hi
  have h₂ : Disjoint (u i) s := by
    rwa [disjoint_iff_inter_eq_empty, ← inter_eq_inter_iff_right, inter_comm,
      v.inter_eq_of_mem hi, inter_empty]
  rcases hs.exists_isOpen_subset_compl h₁ h₂ with ⟨o, ho, hso, hco⟩
  refine ⟨⟨v.toFun ∪ Finsupp.single i o, v.supportᶜ.finite_toSet.union (finite_singleton i), ?_⟩,
    v.lt_of_le ?_ le_sup_left, v.ne_of_mem hi⟩
  · intro j hj
    simp only [mem_union, Finsupp.mem_support_iff, Finsupp.single_apply]
    cases eq_or_ne i j with
    | inl heq => rw [heq, ho]
    | inr hne => exact Or.inl (v.inter_subset_of_mem hj hne)
  · simp only [coe_union, Pi.single_eq_same, coe_single, mem_compl_iff, Finsupp.mem_support_iff,
      Finsupp.single_apply]
    rintro ⟨rfl, rfl⟩
    exact hco.le_bot ⟨hso (v.mem hi), ho.mem_nhds (v.mem hi)⟩

Repaired Proof:
theorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : ι) (hi : i ∉ v.carrier) :
    ∃ v' : PartialRefinement u s, v < v' ∧ v' i = u i := by
  have h₁ : IsOpen (u i) := v.isOpen hi
  have h₂ : Disjoint (u i) s := by
    rwa [disjoint_iff_inter_eq_empty, ← inter_eq_inter_iff_right, inter_comm,
      v.inter_eq_of_mem hi, inter_empty]
  rcases hs.exists_isOpen_subset_compl h₁ h₂ with ⟨o, ho, hso, hco⟩
  refine ⟨⟨v.toFun ∪ Finsupp.single i o, v.supportᶜ.finite_toSet.union (finite_singleton i), ?_⟩,
    v.lt_of_le ?_ le_sup_left, v.ne_of_mem hi⟩
  · intro j hj
    simp only [mem_union, Finsupp.mem_support_iff, Finsupp.single_apply]
    cases eq_or_ne i j with
    | inl heq => rw [heq, ho]
    | inr hne => exact Or.inl (v.inter_subset_of_mem hj hne)
  · simp only [coe_union, Pi.single_eq_same, coe_single, mem_compl_iff, Finsupp.mem_support_iff,
      Finsupp.single_apply]
    rintro ⟨rfl, rfl⟩
   

Attempt failure.

Working on Mathlib/Topology/TietzeExtension.lean - 2024-09-09 01:22:52.723272.
---199/200---
For theorem BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding' in Mathlib/Topology/TietzeExtension.lean:
theorem exists_extension_norm_eq_of_closedEmbedding' (f : X →ᵇ ℝ) (e : C(X, Y))
    (he : ClosedEmbedding e) : ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f 


Original valid proof:
:= by
  choose F hF_norm hF_dist using fun f : X →ᵇ ℝ => tietze_extension_step f e he
  set g : ℕ → Y →ᵇ ℝ := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : ∀ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : ∀ n, dist ((g n).compContinuous e) f ≤ (2 / 3) ^ n * ‖f‖ := by
    intro n
    induction' n with n ihn
    · simp [g0]
    · rw [g_succ n, add_compContinuous, ← dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [← dist_eq_norm']
  have hg_dist : ∀ n, dist (g n) (g (n + 1)) ≤ 1 / 3 * ‖f‖ * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = ‖F (f - (g n).compContinuous e)‖ := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ ≤ ‖f - (g n).compContinuous e‖ / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ ≤ 1 / 3 * ((2 / 3) ^ n * ‖f‖) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * ‖f‖ * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (𝓝 <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [← zero_mul ‖f‖]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine ⟨limUnder atTop g, le_antisymm ?_ ?_, hge⟩
  · rw [← dist_zero_left, ← g0]
    refine
      (dist_le_of_le_geometric_of_tendsto₀ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : ℝ) = 1 by norm_num1]
  · rw [← hge]
    exact norm_compContinuous_le _ _


Verifying proof (Commit 161c69c1dbf66cf3c7ec4f648a61551d044a43e4):
∧ ∀ x, ‖g x‖ = ‖f (e.symm x)‖ := by
  rcases exists_extension_norm_eq_of_closedEmbedding f e.toContinuousLinearMap he with ⟨g, hg, hgf, hg'⟩
  refine ⟨g, hg, ?_, hg'⟩
  ext
  rw [← hgf, he.toContinuousLinearMap_apply, ContinuousLinearMap.coe_coe, e.apply_symm_apply]

Repaired Proof:
theorem exists_extension_norm_eq_of_closedEmbedding' (f : X →ᵇ ℝ) (e : C(X, Y))
    (he : ClosedEmbedding e) : ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f ∧ ∀ x, ‖g x‖ = ‖f (e.symm x)‖ := by
  rcases exists_extension_norm_eq_of_closedEmbedding f e.toContinuousLinearMap he with ⟨g, hg, hgf, hg'⟩
  refine ⟨g, hg, ?_, hg'⟩
  ext
  rw [← hgf, he.toContinuousLinearMap_apply, ContinuousLinearMap.coe_coe, e.apply_symm_apply]

Repaired Proof:
theorem exists_extension_norm_eq_of_closedEmbedding (f : X →ᵇ ℝ) {e : X → Y} (he : ClosedEmbedding e) :
    ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f ∧ ∀ x, ‖g x‖ = ‖f (e.symm x)‖ := by
  rcases exists_extension_norm_eq_of_closedEmbedding f e.toContinuousLinearMap he with ⟨g, hg, hgf, hg'⟩
  refine ⟨g, hg, ?_, hg'⟩
  ext
  rw [← hgf, he.toContinuousLinearMap_apply, ContinuousLinearMap.coe_coe, e.apply_symm_apply]

Repaired Proof:
theorem exists_extension_norm_eq_of_closedEmbedding (f : X →ᵇ ℝ) {e : X → Y} (he : ClosedEmbedding e) :
    ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f ∧ ∀ x, ‖g x‖ = ‖f (e.symm x)‖ := by
  rcases exists_extension_norm_eq_of_closedEmbedding f e.toContinuousLinearMap he with ⟨g, hg, hgf, hg'⟩
  refine ⟨g, hg, ?_, hg'⟩
  ext
  rw [← hgf, he.toContinuousLinearMap_apply, ContinuousLinearMap.coe_coe, e.apply_symm_apply]

Repaired Proof:
theorem exists_extension_norm_eq_of_closedEmbedding (f : X →ᵇ ℝ) {e : X → Y} (he : ClosedEmbedding e) :
    ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f ∧ ∀ x, ‖g x‖ = ‖f (e.symm x)‖ := by
  rcases exists_extension_norm_eq_of_closedEmbedding f e.toContinuousLinearMap he with ⟨g, hg, hgf, hg'⟩
  refine ⟨g, hg, ?_, hg'⟩
  ext
  rw [← hgf, he.toContinuousLinearMap_apply, ContinuousLinearMap.coe_coe, e.apply_symm_apply]

Repaired Proof:
theorem exists_extension_norm_eq_of_closedEmbedding (f : X →ᵇ ℝ) {e : X → Y} (he : ClosedEmbedding e) :
    ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f ∧ ∀ x, ‖g x‖ = ‖f (e.symm x)‖ := by
  rcases exists_extension_norm_eq_of_closedEmbedding f e.toContinuousLinearMap he with ⟨g, hg, hgf, hg'⟩
  refine ⟨g, hg, ?_, hg'⟩
  ext
  rw [← hgf, he.toContinuousLinearMap_apply, ContinuousLinearMap.coe_coe, e.apply_symm_apply]

Repaired Proof:
theorem exists_extension_norm_eq_of_closedEmbedding (f : X →ᵇ ℝ) {e : X → Y} (he : ClosedEmbedding e) :
    ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f ∧ ∀ x, ‖g x‖ = ‖f (e.symm x)‖ := by
  rcases exists_extension_norm_eq_of_closedEmbedding f e.toContinuousLinearMap he with ⟨g, hg, hgf, hg'⟩
  refine ⟨g, hg, ?_, hg'⟩
  ext
  rw [← hgf, he.toContinuousLinearMap_apply, ContinuousLinearMap.coe_coe, e.apply_symm_apply]

Repaired Proof:
theorem exists_extension_norm_eq_of_closedEmbedding (f : X →ᵇ ℝ) {e : X → Y} (he : ClosedEmbedding e) :
    ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f ∧ ∀ x, ‖g x‖ = ‖f (e.symm x)‖ := by
  rcases exists_extension_norm_eq_of_closedEmbedding f e.toContinuousLinearMap he with ⟨g, hg, hgf, hg'⟩
  refine ⟨g, hg, ?_, hg'⟩
  ext
  rw [← hgf, he.toContinuousLinearMap_apply, ContinuousLinearMap.coe_coe, e.apply_symm_apply]

Repaired Proof:
theorem exists_extension_norm_eq_of_closedEmbedding (f : X →ᵇ ℝ) {e : X → Y} (he : ClosedEmbedding e) :
    ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f ∧ ∀ x, ‖g x‖ = ‖f (e.symm x)‖ := by
  rcases exists_extension_norm_eq_of_closedEmbedding f e.toContinuousLinearMap he with ⟨g, hg, hgf, hg'⟩
  refine ⟨g, hg, ?_, hg'⟩
  ext
  rw [← hgf, he.toContinuousLinearMap_apply, ContinuousLinearMap.coe_coe, e.apply_symm_apply]

Repaired Proof:
theorem exists_extension_norm_eq_of_closedEmbedding (f : X →ᵇ ℝ) {e : X → Y} (he : ClosedEmbedding e) :
    ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f ∧ ∀ x, ‖g x‖ = ‖f (e.symm x)‖ := by
  rcases exists_extension_norm_eq_of_closedEmbedding f e.toContinuousLinearMap he with ⟨g, hg, hgf, hg'⟩
  refine ⟨g, hg, ?_, hg'⟩
  ext
  rw [← hgf, he.toContinuousLinearMap_apply, ContinuousLinearMap.coe_coe, e.apply_symm_apply]

Repaired Proof:
theorem exists_extension_norm_eq_of_closedEmbedding (f : X →ᵇ ℝ) {e : X →

Attempt failure.

Working on Mathlib/Topology/UniformSpace/Ascoli.lean - 2024-09-09 01:23:08.569620.
---200/200---
For theorem EquicontinuousOn.tendsto_uniformOnFun_iff_pi' in Mathlib/Topology/UniformSpace/Ascoli.lean:
theorem EquicontinuousOn.tendsto_uniformOnFun_iff_pi'
    {𝔖 : Set (Set X)} (𝔖_compact : ∀ K ∈ 𝔖, IsCompact K)
    (F_eqcont : ∀ K ∈ 𝔖, EquicontinuousOn F K) (ℱ : Filter ι) (f : X → α) :
    Tendsto (UniformOnFun.ofFun 𝔖 ∘ F) ℱ (𝓝 <| UniformOnFun.ofFun 𝔖 f) ↔
    Tendsto ((⋃₀ 𝔖).restrict ∘ F) ℱ (𝓝 <| (⋃₀ 𝔖).restrict f) 


Original valid proof:
:= by
  rw [← Filter.tendsto_comap_iff (g := (⋃₀ 𝔖).restrict), ← nhds_induced]
  simp_rw [UniformOnFun.topologicalSpace_eq, Pi.induced_restrict_sUnion 𝔖 (π := fun _ ↦ α),
    _root_.nhds_iInf, nhds_induced, tendsto_iInf, tendsto_comap_iff]
  congrm ∀ K (hK : K ∈ 𝔖), ?_
  have : CompactSpace K := isCompact_iff_compactSpace.mp (𝔖_compact K hK)
  rw [← (equicontinuous_restrict_iff _ |>.mpr <| F_eqcont K hK).tendsto_uniformFun_iff_pi]
  rfl


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
    ∀ K ∈ 𝔖, Tendsto (K.restrict ∘ F) ℱ (𝓝 <| K.restrict f) := by
  simp_rw [tendsto_iff_dist_tendsto_zero]
  rw [UniformOnFun.dist_ofFun, dist_pi_eq_dist, ← NNReal.zero_eq_zero, NNReal.tendsto_coe,
    ← NNReal.tendsto_coe, NNReal.coe_zero]
  exact (EquicontinuousOn.tendsto_uniformOnFun_iff_uniformOnFun 𝔖_compact F_eqcont ℱ f).trans
    (uniformOnFun_restrict_sUnion_eq 𝔖 F f ▸ Iff.rfl)

Repaired Proof:
theorem EquicontinuousOn.tendsto_uniformOnFun_iff_pi'
    {𝔖 : Set (Set X)} (𝔖_compact : ∀ K ∈ 𝔖, IsCompact K)
    (F_eqcont : ∀ K ∈ 𝔖, EquicontinuousOn F K) (ℱ : Filter ι) (f : X → α) :
    Tendsto (UniformOnFun.ofFun 𝔖 ∘ F) ℱ (𝓝 <| UniformOnFun.ofFun 𝔖 f) ↔
    Tendsto ((⋃₀ 𝔖).restrict ∘ F) ℱ (𝓝 <| (⋃₀ 𝔖).restrict f) ∧
    ∀ K ∈ 𝔖, Tendsto (K.restrict ∘ F) ℱ (𝓝 <| K.restrict f) := by
  simp_rw [tendsto_iff_dist_tendsto_zero]
  rw [UniformOnFun.dist_ofFun, dist_pi_eq_dist, ← NNReal.zero_eq_zero, NNReal.tendsto_coe,
    ← NNReal.tendsto_coe, NNReal.coe_zero]
  exact (EquicontinuousOn.tendsto_uniformOnFun_iff_uniformOnFun 𝔖_compact F_eqcont ℱ f).trans
    (uniformOnFun_restrict_sUnion_eq 𝔖 F f ▸ Iff.rfl)

Repaired Proof:
theorem EquicontinuousOn.tendsto_uniformOnFun_iff_pi'
    {𝔖 : Set (Set X)} (𝔖_compact : ∀ K ∈ 𝔖, IsCompact K)
    (F_eqcont : ∀ K ∈ 𝔖, EquicontinuousOn F K) (ℱ : Filter ι) (f : X → α) :
    Tendsto (UniformOnFun.ofFun 𝔖 ∘ F) ℱ (𝓝 <| UniformOnFun.ofFun 𝔖 f) ↔
    Tendsto ((⋃₀ 𝔖).restrict ∘ F) ℱ (𝓝 <| (⋃₀ 𝔖).restrict f) ∧
    ∀ K ∈ 𝔖, Tendsto (K.restrict ∘ F) ℱ (𝓝 <| K.restrict f) := by
  simp_rw [tendsto_iff_dist_tendsto_zero]
  rw [UniformOnFun.dist_ofFun, dist_pi_eq_dist, ← NNReal.zero_eq_zero, NNReal.tendsto_coe,
    ← NNReal.tendsto_coe, NNReal.coe_zero]
  exact (EquicontinuousOn.tendsto_uniformOnFun_iff_uniformOnFun 𝔖_compact F_eqcont ℱ f).trans
    (uniformOnFun_restrict_sUnion_eq 𝔖 F f ▸ Iff.rfl)

Repaired Proof:
theorem EquicontinuousOn.tendsto_uniformOnFun_iff_pi'
    {𝔖 : Set (Set X)} (𝔖_compact : ∀ K ∈ 𝔖, IsCompact K)
    (F_eqcont : ∀ K ∈ 𝔖, EquicontinuousOn F K) (ℱ : Filter ι) (f : X → α) :
    Tendsto (UniformOnFun.ofFun 𝔖 ∘ F) ℱ (𝓝 <| UniformOnFun.ofFun 𝔖 f) ↔
    Tendsto ((⋃₀ 𝔖).restrict ∘ F) ℱ (𝓝 <| (⋃₀ 𝔖).restrict f) ∧
    ∀ K ∈ 𝔖, Tendsto (K.restrict ∘ F) ℱ (𝓝 <| K.restrict f) := by
  simp_rw [tendsto_iff_dist_tendsto_zero]
  rw [UniformOnFun.dist_ofFun, dist_pi_eq_dist, ← NNReal.zero_eq_zero, NNReal.tendsto_coe,
    ← NNReal.tendsto_coe, NNReal.coe_zero]
  exact (EquicontinuousOn.tendsto_uniformOnFun_iff_uniformOnFun 𝔖_compact F_eqcont ℱ f).trans
    (uniformOnFun_restrict_sUnion_eq 𝔖 F f ▸ Iff.rfl)

Attempt failure.

STARTING: Lean repo copy removal
DONE: Lean repo copy removal
Among 200 proof attempts, there were 0 successful and 200 failed attempts at proving their respect theorems.
The rate of successful proof = 0.0.
