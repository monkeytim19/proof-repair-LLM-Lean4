STARTING: verification of proofs from predicted_proof column in dataset from models/deepseek_sft_proving/finetuned/test_random_deepseek_sft_proving_tuned_prediction.csv - 2024-09-09 01:28:01.590516
Working on Mathlib/Algebra/Associated.lean - 2024-09-09 01:28:01.595814.
---1/200---
For theorem prime_pow_iff in Mathlib/Algebra/Associated.lean:
lemma prime_pow_iff [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ Prime p ∧ n = 1 


Original valid proof:
:= by
  refine ⟨fun hp ↦ ?_, fun ⟨hp, hn⟩ ↦ by simpa [hn]⟩
  suffices n = 1 by aesop
  cases' n with n
  · simp at hp
  · rw [Nat.succ.injEq]
    rw [pow_succ', prime_mul_iff] at hp
    rcases hp with ⟨hp, hpn⟩ | ⟨hp, hpn⟩
    · by_contra contra
      rw [isUnit_pow_iff contra] at hpn
      exact hp.not_unit hpn
    · exfalso
      exact hpn.not_unit (hp.pow n)


Verifying proof (Commit 3bb2cb9fea0fbb1bf6bf2e7773ba73b51952e9e5):
∨ p = 0 ∧ n ≠ 0 := by
  refine ⟨fun hp ↦ ?_, fun h ↦ ?_⟩
  · rcases (zero_le n).eq_or_lt with rfl | hn
    · simpa using hp
    · exact Or.inl ⟨hp.irreducible.prime,
        eq_one_of_dvd_one ((pow_dvd_pow _ hn).trans_eq hp.dvd_of_dvd_pow)⟩
  · rcases h with (⟨hp, rfl⟩ | ⟨rfl, hn⟩)
    · simpa
    · simpa [hn] using prime_zero

Repaired Proof:
lemma prime_pow_iff [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ Prime p ∧ n = 1 ∨ p = 0 ∧ n ≠ 0 := by
  refine ⟨fun hp ↦ ?_, fun h ↦ ?_⟩
  · rcases (zero_le n).eq_or_lt with rfl | hn
    · simpa using hp
    · exact Or.inl ⟨hp.irreducible.prime,
        eq_one_of_dvd_one ((pow_dvd_pow _ hn).trans_eq hp.dvd_of_dvd_pow)⟩
  · rcases h with (⟨hp, rfl⟩ | ⟨rfl, hn⟩)
    · simpa
    · simpa [hn] using prime_zero

Repaired Proof:
lemma prime_pow_iff [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ Prime p ∧ n = 1 ∨ p = 0 ∧ n ≠ 0 := by
  refine ⟨fun hp ↦ ?_, fun h ↦ ?_⟩
  · rcases (zero_le n).eq_or_lt with rfl | hn
    · simpa using hp
    · exact Or.inl ⟨hp.irreducible.prime,
        eq_one_of_dvd_one ((pow_dvd_pow _ hn).trans_eq hp.dvd_of_dvd_pow)⟩
  · rcases h with (⟨hp, rfl⟩ | ⟨rfl, hn⟩)
    · simpa
    · simpa [hn] using prime_zero

Repaired Proof:
lemma prime_pow_iff [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ Prime p ∧ n = 1 ∨ p = 0 ∧ n ≠ 0 := by
  refine ⟨fun hp ↦ ?_, fun h ↦ ?_⟩
  · rcases (zero_le n).eq_or_lt with rfl | hn
    · simpa using hp
    · exact Or.inl ⟨hp.irreducible.prime,
        eq_one_of_dvd_one ((pow_dvd_pow _ hn).trans_eq hp.dvd_of_dvd_pow)⟩
  · rcases h with (⟨hp, rfl⟩ | ⟨rfl, hn⟩)
    · simpa
    · simpa [hn] using prime_zero

Repaired Proof:
lemma prime_pow_iff [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ Prime p ∧ n = 1 ∨ p = 0 ∧ n ≠ 0 := by
  refine ⟨fun hp ↦ ?_, fun h ↦ ?_⟩
  · rcases (zero_le n).eq_or_lt with rfl | hn
    · simpa using hp
    · exact Or.inl ⟨hp.irreducible.prime,
        eq_one_of_dvd_one ((pow_dvd_pow _ hn).trans_eq hp.dvd_of_dvd_pow)⟩
  · rcases h with (⟨hp, rfl⟩ | ⟨rfl, hn⟩)
    · simpa
    · simpa [hn] using prime_zero

Repaired Proof:
lemma prime_pow_iff [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ Prime p ∧ n = 1 ∨ p = 0 ∧ n ≠ 0 := by
  refine ⟨fun hp ↦ ?_, fun h ↦ ?_⟩
  · rcases (zero_le n).eq_or_lt with rfl | hn
    · simpa using hp
    · exact Or.inl ⟨hp.irreducible.prime,
        eq_one_of_dvd_one ((pow_dvd_pow _ hn).trans_eq hp.dvd_of_dvd_pow)⟩
  · rcases h with (⟨hp, rfl⟩ | ⟨rfl, hn⟩)
    · simpa
    · simpa [hn] using prime_zero

Repaired Proof:
lemma prime_pow_iff [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ Prime p ∧ n = 1 ∨ p = 0 ∧ n ≠ 0 := by
  refine ⟨fun hp ↦ ?_, fun h ↦ ?_⟩
  · rcases (zero_le n).eq_or_lt with rfl | hn
    · simpa using hp
    · exact Or.inl ⟨hp.irreducible.prime,
        eq_one_of_dvd_one ((pow_dvd_pow _ hn).trans_eq hp.dvd_of_dvd_pow)⟩
  · rcases h with (⟨hp, rfl⟩ | ⟨rfl, hn⟩)
    · simpa
    · simpa [hn] using prime_zero

Repaired Proof:
lemma prime_pow_iff [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ Prime p ∧ n = 1 ∨ p = 0 ∧ n ≠ 0 := by
  refine ⟨fun hp ↦ ?_, fun h ↦ ?_⟩
  · rcases (zero_le n).eq_or_lt with rfl | hn
    · simpa using hp
    · exact Or.inl ⟨hp.irreducible.prime,
        eq_one_of_dvd_one ((pow_dvd_pow _ hn).trans_eq hp.dvd_of_dvd_pow)⟩
  · rcases h with (⟨hp, rfl⟩ | ⟨rfl, hn⟩)
    · simpa
    · simpa [hn] using prime_zero

Repaired Proof:
lemma prime_pow_iff [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ Prime p ∧ n = 1 ∨ p = 0 ∧ n ≠ 0 := by
  refine ⟨fun hp ↦ ?_, fun h ↦ ?_⟩
  · rcases (zero_le n).eq_or_lt with rfl | hn
    · simpa using hp
    · exact Or.inl ⟨hp.irreducible.prime,
        eq_one_of_dvd_one ((pow_dvd_pow _ hn).trans_eq hp.dvd_of_dvd_pow)⟩
  · rcases h with (⟨hp, rfl⟩ | ⟨rfl, hn⟩)
    · simpa
    · simpa [hn] using prime_zero

Repaired Proof:
lemma prime_pow_iff [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ Prime p ∧ n = 1 ∨ p = 0 ∧ n ≠ 0 := by
  refine ⟨fun hp ↦ ?_, fun h ↦ ?_⟩
  · rcases (zero_le n).eq_or_lt with rfl | hn
    · simpa using hp
    · exact Or.inl ⟨hp.irreducible.prime,
        eq_

Attempt failure.

Working on Mathlib/Algebra/CharP/CharAndCard.lean - 2024-09-09 01:29:10.614172.
---2/200---
For theorem isUnit_iff_not_dvd_char in Mathlib/Algebra/CharP/CharAndCard.lean:
theorem isUnit_iff_not_dvd_char_of_ringChar_ne_zero (R : Type*) [CommRing R] (p : ℕ) [Fact p.Prime]
    (hR : ringChar R ≠ 0) : IsUnit (p : R) ↔ ¬p ∣ ringChar R 


Original valid proof:
:= by
  have hch := CharP.cast_eq_zero R (ringChar R)
  have hp : p.Prime := Fact.out
  constructor
  · rintro h₁ ⟨q, hq⟩
    rcases IsUnit.exists_left_inv h₁ with ⟨a, ha⟩
    have h₃ : ¬ringChar R ∣ q := by
      rintro ⟨r, hr⟩
      rw [hr, ← mul_assoc, mul_comm p, mul_assoc] at hq
      nth_rw 1 [← mul_one (ringChar R)] at hq
      exact Nat.Prime.not_dvd_one hp ⟨r, mul_left_cancel₀ hR hq⟩
    have h₄ := mt (CharP.intCast_eq_zero_iff R (ringChar R) q).mp
    apply_fun ((↑) : ℕ → R) at hq
    apply_fun (· * ·) a at hq
    rw [Nat.cast_mul, hch, mul_zero, ← mul_assoc, ha, one_mul] at hq
    norm_cast at h₄
    exact h₄ h₃ hq.symm
  · intro h
    rcases (hp.coprime_iff_not_dvd.mpr h).isCoprime with ⟨a, b, hab⟩
    apply_fun ((↑) : ℤ → R) at hab
    push_cast at hab
    rw [hch, mul_zero, add_zero, mul_comm] at hab
    exact isUnit_of_mul_eq_one (p : R) a hab


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∧ ringChar R ≠ 0 := by
  have hp : p ≠ 0 := ne_zero_of_dvd_ne_zero hR ⟨p, rfl⟩
  have hch : ringChar R ≠ 0 := hR
  rw [← CharP.cast_eq_zero_iff R p, ← Ne.eq_def, ← Nat.cast_zero, Ne, ←
    Nat.dvd_iff_mod_eq_zero, ← Nat.mod_eq_zero_of_dvd, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.dvd_iff_mod_eq_zero, Nat.mod_eq_zero_of_dvd, ← Nat.dvd_iff_mod_eq_zero, ←
    Nat.mod_eq_zero_of_dvd, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.dvd_iff_mod_eq_zero,
    Nat.mod_eq_zero_of_dvd, ← isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, isUnit_iff_modEq_one, ←
    Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt, Nat.mod_eq_of_lt (Fact.out (p := p.Prime)).one_lt,
    isUnit_iff_modEq_one, ← Nat.mod_eq_of

Attempt failure.

Working on Mathlib/Algebra/FreeAlgebra.lean - 2024-09-09 01:30:07.754218.
---3/200---
For theorem FreeAlgebra.induction in Mathlib/Algebra/FreeAlgebra.lean:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a 


Original valid proof:
:= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X → s := Subtype.coind (ι R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a


Verifying proof (Commit 0bcbc985a529d2af125537fab684cb3a98de2f6f):
→ C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a → C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a → C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a → C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a → C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a → C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a → C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a → C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a → C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a → C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a → C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a → C a := by
  induction' a using FreeAlgebra.induction with r x a b
  · exact h_grade0 r
  · exact h_grade1 x
  · exact h_mul a b
  · exact h_add a b

Repaired Proof:
theorem induction {C : FreeAlgebra R X → Prop}
    (

Attempt failure.

Working on Mathlib/Algebra/Group/Hom/Defs.lean - 2024-09-09 01:30:37.854729.
---4/200---
For theorem Subsingleton.of_oneHomClass in Mathlib/Algebra/Group/Hom/Defs.lean:
theorem Subsingleton.of_oneHomClass [Subsingleton M] [OneHomClass F M N] :
    Subsingleton F where



Original valid proof:
  allEq f g := DFunLike.ext _ _ fun x ↦ by simp [Subsingleton.elim x 1]


Verifying proof (Commit 650b48365a265f18ee37b34dfd26cc8d9de5d6d7):
  allEq f g := DFunLike.ext _ _ fun x ↦ by rw [Subsingleton.elim x 1, map_one, map_one]

theorem Subsingleton.of_mulHomClass [MulOneClass M] [MulOneClass N] [Subsingleton M]
    [MulHomClass F M N] : Subsingleton F where
  allEq f g := DFunLike.ext _ _ fun x ↦ by rw [Subsingleton.elim x 1, map_one, map_one]

theorem Subsingleton.of_addHomClass [AddZeroClass M] [AddZeroClass N] [Subsingleton M]
    [AddHomClass F M N] : Subsingleton F where
  allEq f g := DFunLike.ext _ _ fun x ↦ by rw [Subsingleton.elim x 0, map_zero, map_zero]

theorem Subsingleton.of_mulHomClass' [MulOneClass M] [MulOneClass N] [Subsingleton M]
    [MulHomClass F M N] : Subsingleton F where
  allEq f g := DFunLike.ext _ _ fun x ↦ by rw [Subsingleton.elim x 1, map_one, map_one]

theorem Subsingleton.of_smulHomClass [SMulZeroClass M N] [Subsingleton M]
    [SMulHomClass F M N] : Subsingleton F where
  allEq f g := DFunLike.ext _ _ fun x ↦ by
    rw [Subsingleton.elim x 0, smul_zero, smul_zero]

theorem Subsingleton.of_smulHomClass' [SMulOneClass M N] [Subsingleton M]
    [SMulHomClass F M N] : Subsingleton F where
  allEq f g := DFunLike.ext _ _ fun x ↦ by
    rw [Subsingleton.elim x 1, smul_one, smul_one]

theorem of_injective [Subsingleton M] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective [Subsingleton M] (f : F) (hf : Surjective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_injective' [Subsingleton N] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective' [Subsingleton N] (f : F) (hf : Surjective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_injective_inv [Subsingleton F] (f : F) (hf : Injective f) : Subsingleton M :=
  ⟨fun x y ↦ hf <| Subsingleton.elim _ _⟩

theorem of_surjective_inv [Subsingleton F] (f : F) (hf : Surjective f) : Subsingleton N :=
  ⟨fun x y ↦ Subsingleton.elim _ _⟩

theorem of_injective_inv' [Subsingleton M] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective_inv' [Subsingleton M] (f : F) (hf : Surjective f) : Subsingleton N :=
  ⟨fun _ _ ↦ Subsingleton.elim _ _⟩

theorem of_injective_inv'' [Subsingleton N] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective_inv'' [Subsingleton N] (f : F) (hf : Surjective f) : Subsingleton M :=
  ⟨fun x y ↦ Subsingleton.elim _ _⟩

theorem of_injective_hom [Subsingleton M] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective_hom [Subsingleton M] (f : F) (hf : Surjective f) : Subsingleton N :=
  ⟨fun x y ↦ Subsingleton.elim _ _⟩

theorem of_injective_hom' [Subsingleton N] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective_hom' [Subsingleton N] (f : F) (hf : Surjective f) : Subsingleton M :=
  ⟨fun x y ↦ Subsingleton.elim _ _⟩

theorem of_injective_hom'' [Subsingleton N] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective_hom'' [Subsingleton N] (f : F) (hf : Surjective f) : Subsingleton M :=
  ⟨fun x y ↦ Subsingleton.elim _ _⟩

theorem of_injective_inv_hom [Subsingleton F] (f : F) (hf : Injective f) : Subsingleton M :=
  ⟨fun x y ↦ hf <| Subsingleton.elim _ _⟩

theorem of_surjective_inv_hom [Subsingleton F] (f : F) (hf : Surjective f) : Subsingleton N :=
  ⟨fun x y ↦ Subsingleton.elim _ _⟩

theorem of_injective_inv_hom' [Subsingleton M] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective_inv_hom' [Subsingleton M] (f : F) (hf : Surjective f) : Subsingleton N :=
  ⟨fun _ _ ↦ Subsingleton.elim _ _⟩

theorem of_injective_inv_hom'' [Subsingleton N] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective_inv_hom'' [Subsingleton N] (f : F) (hf : Surjective f) : Subsingleton M :=
  ⟨fun x y ↦ Subsingleton.elim _ _⟩

theorem of_injective_hom_inv [Subsingleton M] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective_hom_inv [Subsingleton M] (f : F) (hf : Surjective f) : Subsingleton N :=
  ⟨fun x y ↦ Subsingleton.elim _ _⟩

theorem of_injective_hom_inv' [Subsingleton N] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective_hom_inv' [Subsingleton N] (f : F) (hf : Surjective f) : Subsingleton M :=
  ⟨fun x y ↦ Subsingleton.elim _ _⟩

theorem of_injective_hom_inv'' [Subsingleton N] (f : F) (hf : Injective f) : Subsingleton F :=
  ⟨fun _ _ ↦ DFunLike.ext' <| Subsingleton.elim _ _⟩

theorem of_surjective_hom_inv'' [Subsingleton N] (f : F) (hf : Surjective f) : Subsingleton M :=
  ⟨fun x y ↦ Subsingleton.elim _ _⟩

theorem of_injective_inv_hom_inv [Subsingleton F] (f : F) (hf : Injective f) : Subsingleton M :=
  ⟨fun x y ↦ hf <| Subsingleton.elim _ _⟩

theorem of_surjective_inv_hom_inv [Subsingleton F] (f : F) (hf : Surjective f) : Subsingleton N :=
  ⟨fun x y ↦ Subsingleton.elim _ _⟩

theorem of_injective_inv_hom_inv' [Subsingleton M] (f : F) (hf : In

Attempt failure.

Working on Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean - 2024-09-09 01:30:43.238664.
---5/200---
For theorem CochainComplex.HomComplex.δ_shape in Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean:
lemma δ_shape (hnm : ¬ n + 1 = m) (z : Cochain F G n) : δ n m z = 0 


Original valid proof:
:= by
  ext p q hpq
  dsimp only [δ]
  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  all_goals
    simp only [ComplexShape.up_Rel]
    exact fun _ => hnm (by omega)


Verifying proof (Commit fc5d3dffc7c439022141babb13bcb52a72d9f631):
 := by
    ext p
    dsimp
    rw [δ_v n m hnm z p p (le_refl p)]
    split_ifs with h
    · exfalso
      exact hnm (by omega)
    · rfl

  lemma δ_shape' (hnm : ¬ n = m + 1) (z : Cochain F G n) : δ n m z = 0  := by
    ext p
    dsimp
    rw [δ_v n m hnm z p p (le_refl p)]
    split_ifs with h
    · exfalso
      exact hnm (by omega)
    · rfl

  lemma δ_comp {n₁ n₂ n₁₂ : ℕ} (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂) (h : n₁ + n₂ = n₁₂)
    (m₁ m₂ m₁₂ : ℕ) (h₁ : n₁ = m₁ + 1) (h₂ : n₂ = m₂ + 1) (h₁₂ : m₁ + m₂ = m₁₂) :
    δ n₁₂ m₁₂ (z₁.comp z₂ h) =
      (Cochain.comp (δ n₁ m₁ z₁) z₂ (by rw [← h₁, ← h₂, ← h, Nat.succ_add, Nat.succ_add])) +
      (Cochain.comp z₁ (δ n₂ m₂ z₂) (by rw [← h₁, ← h₂, ← h, Nat.add_succ, Nat.add_succ])) := by
    subst h₁₂
    ext p q hpq
    dsimp
    simp only [δ_v n₁₂ m₁₂ (n₁₂ + 1) rfl (z₁.comp z₂ h) p q hpq, δ_v n₁ m₁ (n₁ + 1) rfl z₁ p (p+1) rfl,
      δ_v n₂ m₂ (n₂ + 1) rfl z₂ (p+1) q (by omega), Cochain.comp_v _ _ h (p+1) (p+1) q (by omega) (by omega),
      Cochain.comp_v _ _ h (p+1) (p+2) q (by omega) (by omega), Cochain.comp_zero_cochain_v,
      Cochain.comp_v _ _ (by omega) (p+1) (p+1) q (by omega) (by omega),
      Cochain.comp_v _ _ (by omega) (p+1) (p+2) q (by omega) (by omega)]
    simp only [add_comp_v, comp_add_v, comp_v, d_f_v, d_v_f, d_comp_d,
      add_assoc, add_comm, add_left_comm]
    congr 1
    · simp only [add_assoc, add_comm, add_left_comm]
    · simp only [add_assoc, add_comm, add_left_comm]

  lemma δ_comp_zero_cochain {n₁ n₂ n₁₂ : ℕ} (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂)
    (h : n₁ + n₂ = n₁₂) (m₁ m₂ m₁₂ : ℕ) (h₁ : n₁ = m₁ + 1) (h₂ : n₂ = m₂ + 1) (h₁₂ : m₁ + m₂ = m₁₂) :
    δ n₁₂ m₁₂ (z₁.comp_zero_cochain z₂ h) =
      (Cochain.comp_zero_cochain (δ n₁ m₁ z₁) z₂ (by rw [← h₁, ← h₂, ← h, Nat.succ_add, Nat.succ_add])) +
      (Cochain.comp_zero_cochain z₁ (δ n₂ m₂ z₂) (by rw [← h₁, ← h₂, ← h, Nat.add_succ, Nat.add_succ])) :=
    δ_comp z₁ z₂ h m₁ m₂ m₁₂ h₁ h₂ h₁₂

  lemma δ_δ (n m₁ m₂ m₁₂ : ℕ) (h₁₂ : m₁ + 1 = m₂) (h₂ : n + 1 = m₁ + 1) (h₁ : n + 2 = m₁₂) :
    δ m₁ m₂ (δ n m₁ z) = δ m₂ m₁₂ z := by
    subst h₁₂ h₂ h₁
    ext p q hpq
    simp only [δ_v m₁ m₂ (m₁ + 1) rfl (δ n m₁ z) p q hpq,
      δ_v n m₁ (n + 1) rfl z p (p+1) rfl, δ_v n (m₁ + 1) (n + 1) rfl z (p+1) q hpq,
      d_f_v, d_v_f, d_comp_d, add_assoc, add_comm, add_left_comm, comp_v,
      Cochain.comp_v _ _ (by omega) (p+1) (p+1) q (by omega) (by omega),
      Cochain.comp_v _ _ (by omega) (p+1) (p+2) q (by omega) (by omega),
      Cochain.comp_v _ _ (by omega) (p+2) (p+2) q (by omega) (by omega),
      Cochain.comp_v _ _ (by omega) (p+2) (p+3) q (by omega) (by omega)]
    congr 1
    · simp only [add_assoc, add_comm, add_left_comm]
    · simp only [add_assoc, add_comm, add_left_comm]

  lemma δ_δ' (n m₁ m₂ m₁₂ : ℕ) (h₁₂ : m₁ + 1 = m₂) (h₂ : n + 1 = m₁ + 1) (h₁ : n + 2 = m₁₂) :
    δ m₁ m₂ (δ n m₁ z) = δ m₂ m₁₂ z := by
    subst h₁₂ h₂ h₁
    ext p q hpq
    simp only [δ_v m₁ m₂ (m₁ + 1) rfl (δ n m₁ z) p q hpq,
      δ_v n m₁ (n + 1) rfl z p (p+1) rfl, δ_v n (m₁ + 1) (n + 1) rfl z (p+1) q hpq,
      d_f_v, d_v_f, d_comp_d, add_assoc, add_comm, add_left_comm, comp_v,
      Cochain.comp_v _ _ (by omega) (p+1) (p+1) q (by omega) (by omega),
      Cochain.comp_v _ _ (by omega) (p+1) (p+2) q (by omega) (by omega),
      Cochain.comp_v _ _ (by omega) (p+2) (p+2) q (by omega) (by omega),
      Cochain.comp_v _ _ (by omega) (p+2) (p+3) q (by omega) (by omega)]
    congr 1
    · simp only [add_assoc, add_comm, add_left_comm]
    · simp only [add_assoc, add_comm, add_left_comm]

  lemma δ_δ_assoc (n m₁ m₂ m₁₂ : ℕ) (h₁₂ : m₁ + 1 = m₂) (h₂ : n + 1 = m₁ + 1) (h₁ : n + 2 = m₁₂) :
    δ m₁ m₂ (δ n m₁ z) = δ m₂ m₁₂ (δ n m₁ z) := by
    rw [δ_δ _ _ _ _ h₁₂ h₂ h₁]

  lemma δ_δ_assoc' (n m₁ m₂ m₁₂ : ℕ) (h₁₂ : m₁ + 1 = m₂) (h₂ : n + 1 = m₁ + 1) (h₁ : n + 2 = m₁₂) :
    δ m₁ m₂ (δ n m₁ z) = δ m₂ m₁₂ z := by
    rw [δ_δ' _ _ _ _ h₁₂ h₂

Attempt failure.

---6/200---
For theorem CochainComplex.HomComplex.Cocycle.coe_sub in Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean:
lemma coe_sub (z₁ z₂ : Cocycle F G n) :
    (↑(z₁ - z₂) : Cochain F G n) = (z₁ : Cochain F G n) - (z₂ : Cochain F G n) 


Original valid proof:
:= rfl


Verifying proof (Commit 9072ff84a0d139a344bf9eed4a00c4cd27596c79):
 := rfl

@[simp]
lemma sub_v (z₁ z₂ : Cocycle F G n) (p : Σ i, Fin (n + 1)) :
    (z₁ - z₂).v p = z₁.v p - z₂.v p := rfl

instance : Module R (Cocycle F G n) :=
  Function.Injective.module R coeAddHom coe_injective coe_smul

variable {F G n}

@[simp]
lemma zero_v (p : Σ i, Fin (n + 1)) : (0 : Cocycle F G n).v p = 0 := rfl

@[simp]
lemma add_v (z₁ z₂ : Cocycle F G n) (p : Σ i, Fin (n + 1)) :
    (z₁ + z₂).v p = z₁.v p + z₂.v p := rfl

@[simp]
lemma sub_v (z₁ z₂ : Cocycle F G n) (p : Σ i, Fin (n + 1)) :
    (z₁ - z₂).v p = z₁.v p - z₂.v p := rfl

@[simp]
lemma smul_v (r : R) (z : Cocycle F G n) (p : Σ i, Fin (n + 1)) :
    (r • z).v p = r • z.v p := rfl

@[simp]
lemma nsmul_v (k : ℕ) (z : Cocycle F G n) (p : Σ i, Fin (n + 1)) :
    (k • z).v p = k • z.v p := rfl

@[simp]
lemma zsmul_v (k : ℤ) (z : Cocycle F G n) (p : Σ i, Fin (n + 1)) :
    (k • z).v p = k • z.v p := rfl

@[simp]
lemma natCast_v (k : ℕ) (z : Cocycle F G n) (p : Σ i, Fin (n + 1)) :
    (k : Cocycle F G n).v p = k • z.v p := rfl

@[simp]
lemma intCast_v (k : ℤ) (z : Cocycle F G n) (p : Σ i, Fin (n + 1)) :
    (k : Cocycle F G n).v p = k • z.v p := rfl

@[simp]
lemma coe_pow (z : Cocycle F G n) (k : ℕ) :
    (z ^ k : Cocycle F G n) = (z : Cochain F G n) ^ k := rfl

instance : Module ℤ (Cocycle F G n) :=
  Function.Injective.module ℤ coeAddHom coe_injective coe_zsmul

end

variable {F G}

@[simp]
lemma map_zero (f : F ⟶ G) : (0 : Cocycle F F n).map f = 0 := by aesop_cat

@[simp]
lemma map_add (f : F ⟶ G) (z₁ z₂ : Cocycle F F n) :
    (z₁ + z₂).map f = z₁.map f + z₂.map f := by aesop_cat

@[simp]
lemma map_sub (f : F ⟶ G) (z₁ z₂ : Cocycle F F n) :
    (z₁ - z₂).map f = z₁.map f - z₂.map f := by aesop_cat

@[simp]
lemma map_neg (f : F ⟶ G) (z : Cocycle F F n) : (-z).map f = -z.map f := by aesop_cat

@[simp]
lemma map_nsmul (f : F ⟶ G) (k : ℕ) (z : Cocycle F F n) :
    (k • z).map f = k • z.map f := by aesop_cat

@[simp]
lemma map_zsmul (f : F ⟶ G) (k : ℤ) (z : Cocycle F F n) :
    (k • z).map f = k • z.map f := by aesop_cat

@[simp]
lemma map_natCast (f : F ⟶ G) (k : ℕ) :
    (k : Cocycle F F n).map f = k := by aesop_cat

@[simp]
lemma map_intCast (f : F ⟶ G) (k : ℤ) :
    (k : Cocycle F F n).map f = k := by aesop_cat

@[simp]
lemma map_pow (f : F ⟶ G) (z : Cocycle F F n) (k : ℕ) :
    (z ^ k).map f = (z.map f) ^ k := by aesop_cat

/-- The coboundary map on the `n`-cocycles, as a linear map. -/
@[simps]
def δ : Cocycle F G n →ₗ[R] Cochain F G (n + 1) where
  toFun := δ n
  map_add' := δ_add
  map_smul' := δ_smul

/-- The coboundary map on the `n`-cocycles, as a linear equiv. -/
@[simps]
def δLinearEquiv : Cocycle F G n ≃ₗ[R] Cochain F G (n + 1) where
  toFun := δ n
  invFun := coboundary n
  left_inv := coboundary_δ
  right_inv := δ_coboundary
  map_add' := δ_add
  map_smul' := δ_smul

@[simp]
lemma δ_zero : δ 0 = 0 := by aesop_cat

@[simp]
lemma δ_succ (n' : ℕ) : δ (n' + 1) = δ n' ≫ Cochain.v (n' + 1) n' (n' + 1) := by
  ext p q hpq
  simp only [δ, δ₀, δ₀_eq, Cochain.v, Function.comp_apply, LinearMap.coe_mk,
    LinearEquiv.coe_coe, LinearEquiv.toFun_eq_coe, LinearEquiv.map_smul,
    LinearMap.toFun_eq_coe, Finsupp.smul_apply, smul_eq_mul,
    Finsupp.single_eq_same, Fin.succ_mk, Fin.val_mk, Fin.val_succ,
    Fin.pred_succ, tsub_self, tsub_zero, pow_one, pow_zero, one_mul,
    zero_mul, sub_zero, add_tsub_cancel_right, zero_add,
    LinearMap.add_apply, LinearMap.sub_apply, LinearMap.smul_apply,
    LinearEquiv.map_add, LinearEquiv.map_sub, LinearEquiv.map_smul,
    LinearMap.map_add, LinearMap.map_sub, LinearMap.map_smul,
    Cochain.comp_v _ _ _ (show n' + 1 + 1 = n' + 1 + (1 + 1) by omega) p q r hpq _]
  congr 1
  rw [Fin.succ_mk, Fin.pred_succ]

@[simp]
lemma δ_comp (n' : ℕ) {K : C} (z : Cocycle F K n') (f : K ⟶ G) :
    δ n' ((z.map f).comp (δ n' f)) = 0 := by
  ext p q hpq
  simp only [δ, δ₀, δ₀_eq, Cochain.comp_v _ _ (show n' + 1 + 1 = n' + 1 + (1 + 1) by omega) p q r hpq _]
  simp only [Cochain.v, Function.comp_apply, LinearMap.coe_mk,
    LinearEquiv.coe_coe, LinearEquiv.toFun_eq_coe, LinearEquiv.map_smul,
    LinearMap.toFun_eq_coe, Finsupp.smul_apply, smul_eq_mul,
    Finsupp.single_eq_same, Fin.succ_mk, Fin.val_mk, Fin.val_succ,
    Fin.pred_succ, tsub_self, tsub_zero, pow_one, pow_zero, one_mul,
    zero_mul, sub_zero, add_tsub_cancel_right, zero_add,
    LinearMap.add_apply

Attempt failure.

Working on Mathlib/Algebra/Module/PID.lean - 2024-09-09 01:31:34.496548.
---7/200---
For theorem Module.torsion_by_prime_power_decomposition in Mathlib/Algebra/Module/PID.lean:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) 


Original valid proof:
:= by
  obtain ⟨d, s, hs⟩ := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  · 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ⟨⟨0⟩, fun x => by dsimp; rw [← Submodule.mem_bot R, hs]; exact Submodule.mem_top⟩
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ⟨0⟩
  · have : ∀ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ⟨j, hj⟩ := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d → N ⧸ R ∙ s j := Submodule.Quotient.mk ∘ s ∘ j.succAbove
    have := IH ?_ s' ?_
    · obtain ⟨k, ⟨f⟩⟩ := this
      clear IH
      have : ∀ i : Fin d,
          ∃ x : N, p ^ k i • x = 0 ∧ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ⟨x, h0, h1⟩ := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ⟨x, h0, ?_⟩; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ⟨?_, ⟨?_⟩⟩
      · exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ℕ)) (finSuccEquiv d a)
      · refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ⧸ _ →ₗ[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ∙ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ⧸ R ∙ p ^ @Option.rec _ (fun _ => ℕ) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        · rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        · rw [← f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ← LinearMap.comp_assoc,
            ← LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ∙ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    · exact (mk_surjective _).forall.mpr fun x =>
        ⟨(@hN x).choose, by rw [← Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]⟩
    · have hs' := congr_arg (Submodule.map <| mkQ <| R ∙ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [← Function.comp.assoc, Set.range_comp (_ ∘ s), Fin.range_succAbove]
      rw [← Set.range_comp, ← Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'


Verifying proof (Commit d54553bd16569ed7d2a0974b7a9c2eb160081ba9):
⧸
    LinearMap.range (powMonoidHom i : R →* R ⧸ R ∙ p ^ (k i : ℕ)) := by
  obtain ⟨d, s, hs⟩ := Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal hN
  have : ∀ i, ∃ k : ℕ, s i = p ^ k := by
    intro i
    obtain ⟨k, hk⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs i)
    exact ⟨k, by rwa [Submonoid.mem_powers_iff] at hk⟩
  choose k hk using this
  letI : ∀ i, Module.IsTorsion' (localizedModule (s i)) (Submonoid.powers (p ^ k i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk i)
  have : ∀ i, Module.Finite R (localizedModule (s i)) := fun i =>
    Module.Finite.localizedModule (s i)
  obtain ⟨d', s', hs'⟩ :=
    Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal (hN.localizedModule s)
  have : ∀ i, ∃ k' : ℕ, s' i = p ^ k' := by
    intro i
    obtain ⟨k', hk'⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs' i)
    exact ⟨k', by rwa [Submonoid.mem_powers_iff] at hk'⟩
  choose k' hk' using this
  letI : ∀ i, Module.IsTorsion' (localizedModule (s' i)) (Submonoid.powers (p ^ k' i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk' i)
  have : ∀ i, Module.Finite R (localizedModule (s' i)) := fun i =>
    Module.Finite.localizedModule (s' i)
  let e : N ≃ₗ[R] ⨁ i, localizedModule (s i) := Module.IsLocalizedModule.isoLocalizedModule hs
  let e' : (⨁ i, localizedModule (s i)) ≃ₗ[R] ⨁ i, localizedModule (s' i) :=
    DirectSum.linearEquivFunOnFintype.trans
      (DFinsupp.mapRange.linearEquiv fun i =>
        IsLocalization.mapLocalizedModule_iso_of_eq (s i) (s' i) (hk i).symm)
  exact ⟨d', k' ∘ e'.symm, ⟨e.symm.trans e'.symm.trans hs'⟩⟩

Repaired Proof:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) ⧸
    LinearMap.range (powMonoidHom i : R →* R ⧸ R ∙ p ^ (k i : ℕ)) := by
  obtain ⟨d, s, hs⟩ := Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal hN
  have : ∀ i, ∃ k : ℕ, s i = p ^ k := by
    intro i
    obtain ⟨k, hk⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs i)
    exact ⟨k, by rwa [Submonoid.mem_powers_iff] at hk⟩
  choose k hk using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s i) 1) (Submonoid.powers (p ^ k i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk i)
  have : ∀ i, Module.Finite R (LocalizedModule.mk' (s i) 1) := fun i =>
    Module.Finite.localizedModule (s i)
  obtain ⟨d', s', hs'⟩ :=
    Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal (hN.localizedModule s)
  have : ∀ i, ∃ k' : ℕ, s' i = p ^ k' := by
    intro i
    obtain ⟨k', hk'⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs' i)
    exact ⟨k', by rwa [Submonoid.mem_powers_iff] at hk'⟩
  choose k' hk' using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s' i) 1) (Submonoid.powers (p ^ k' i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk' i)
  have : ∀ i, Module.Finite R (LocalizedModule.mk' (s' i) 1) := fun i =>
    Module.Finite.localizedModule (s' i)
  let e : N ≃ₗ[R] ⨁ i, LocalizedModule.mk' (s i) 1 := Module.IsLocalizedModule.isoLocalizedModule hs
  let e' : (⨁ i, LocalizedModule.mk' (s i) 1) ≃ₗ[R] ⨁ i, LocalizedModule.mk' (s' i) 1 :=
    DirectSum.linearEquivFunOnFintype.trans
      (DFinsupp.mapRange.linearEquiv fun i =>
        IsLocalization.mapLocalizedModule_iso_of_eq (s i) (s' i) (hk i).symm)
  exact ⟨d', k' ∘ e'.symm, ⟨e.symm.trans e'.symm.trans hs'⟩⟩

Repaired Proof:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) ⧸
    LinearMap.range (powMonoidHom i : R →* R ⧸ R ∙ p ^ (k i : ℕ)) := by
  obtain ⟨d, s, hs⟩ := Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal hN
  have : ∀ i, ∃ k : ℕ, s i = p ^ k := by
    intro i
    obtain ⟨k, hk⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs i)
    exact ⟨k, by rwa [Submonoid.mem_powers_iff] at hk⟩
  choose k hk using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s i) 1) (Submonoid.powers (p ^ k i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk i)
  have : ∀ i, Module.Finite R (LocalizedModule.mk' (s i) 1) := fun i =>
    Module.Finite.localizedModule (s i)
  obtain ⟨d', s', hs'⟩ :=
    Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal (hN.localizedModule s)
  have : ∀ i, ∃ k' : ℕ, s' i = p ^ k' := by
    intro i
    obtain ⟨k', hk'⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs' i)
    exact ⟨k', by rwa [Submonoid.mem_powers_iff] at hk'⟩
  choose k' hk' using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s' i) 1)

Attempt failure.

---8/200---
For theorem Module.torsion_by_prime_power_decomposition in Mathlib/Algebra/Module/PID.lean:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) 


Original valid proof:
:= by
  obtain ⟨d, s, hs⟩ := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  · 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ⟨⟨0⟩, fun x => by dsimp; rw [← Submodule.mem_bot R, hs]; exact Submodule.mem_top⟩
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ⟨0⟩
  · have : ∀ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ⟨j, hj⟩ := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d → N ⧸ R ∙ s j := Submodule.Quotient.mk ∘ s ∘ j.succAbove
    have := IH ?_ s' ?_
    · obtain ⟨k, ⟨f⟩⟩ := this
      clear IH
      have : ∀ i : Fin d,
          ∃ x : N, p ^ k i • x = 0 ∧ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ⟨x, h0, h1⟩ := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ⟨x, h0, ?_⟩; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ⟨?_, ⟨?_⟩⟩
      · exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ℕ)) (finSuccEquiv d a)
      · refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ⧸ _ →ₗ[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ∙ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ⧸ R ∙ p ^ @Option.rec _ (fun _ => ℕ) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        · rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        · rw [← f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ← LinearMap.comp_assoc,
            ← LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ∙ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    · exact (mk_surjective _).forall.mpr fun x =>
        ⟨(@hN x).choose, by rw [← Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]⟩
    · have hs' := congr_arg (Submodule.map <| mkQ <| R ∙ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [← Function.comp.assoc, Set.range_comp (_ ∘ s), Fin.range_succAbove]
      rw [← Set.range_comp, ← Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
⧸
    LinearMap.range (powMonoidHom i : R →* R ⧸ R ∙ p ^ (k i : ℕ)) := by
  obtain ⟨d, s, hs⟩ := Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal hN
  have : ∀ i, ∃ k : ℕ, s i = p ^ k := by
    intro i
    obtain ⟨k, hk⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs i)
    exact ⟨k, by rwa [Submonoid.mem_powers_iff] at hk⟩
  choose k hk using this
  letI : ∀ i, Module.IsTorsion' (localizedModule (s i)) (Submonoid.powers (p ^ k i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk i)
  have : ∀ i, Module.Finite R (localizedModule (s i)) := fun i =>
    Module.Finite.localizedModule (s i)
  obtain ⟨d', s', hs'⟩ :=
    Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal (hN.localizedModule s)
  have : ∀ i, ∃ k' : ℕ, s' i = p ^ k' := by
    intro i
    obtain ⟨k', hk'⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs' i)
    exact ⟨k', by rwa [Submonoid.mem_powers_iff] at hk'⟩
  choose k' hk' using this
  letI : ∀ i, Module.IsTorsion' (localizedModule (s' i)) (Submonoid.powers (p ^ k' i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk' i)
  have : ∀ i, Module.Finite R (localizedModule (s' i)) := fun i =>
    Module.Finite.localizedModule (s' i)
  let e : N ≃ₗ[R] ⨁ i, localizedModule (s i) := Module.IsLocalizedModule.isoLocalizedModule hs
  let e' : (⨁ i, localizedModule (s i)) ≃ₗ[R] ⨁ i, localizedModule (s' i) :=
    DirectSum.linearEquivFunOnFintype.trans
      (DFinsupp.mapRange.linearEquiv fun i =>
        IsLocalization.mapLocalizedModule_iso_of_eq (s i) (s' i) (hk i).symm)
  exact ⟨d', k' ∘ e'.symm, ⟨e.symm.trans e'.symm.trans hs'⟩⟩

Repaired Proof:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) ⧸
    LinearMap.range (powMonoidHom i : R →* R ⧸ R ∙ p ^ (k i : ℕ)) := by
  obtain ⟨d, s, hs⟩ := Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal hN
  have : ∀ i, ∃ k : ℕ, s i = p ^ k := by
    intro i
    obtain ⟨k, hk⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs i)
    exact ⟨k, by rwa [Submonoid.mem_powers_iff] at hk⟩
  choose k hk using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s i) 1) (Submonoid.powers (p ^ k i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk i)
  have : ∀ i, Module.Finite R (LocalizedModule.mk' (s i) 1) := fun i =>
    Module.Finite.localizedModule (s i)
  obtain ⟨d', s', hs'⟩ :=
    Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal (hN.localizedModule s)
  have : ∀ i, ∃ k' : ℕ, s' i = p ^ k' := by
    intro i
    obtain ⟨k', hk'⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs' i)
    exact ⟨k', by rwa [Submonoid.mem_powers_iff] at hk'⟩
  choose k' hk' using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s' i) 1) (Submonoid.powers (p ^ k' i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk' i)
  have : ∀ i, Module.Finite R (LocalizedModule.mk' (s' i) 1) := fun i =>
    Module.Finite.localizedModule (s' i)
  let e : N ≃ₗ[R] ⨁ i, LocalizedModule.mk' (s i) 1 := Module.IsLocalizedModule.isoLocalizedModule hs
  let e' : (⨁ i, LocalizedModule.mk' (s i) 1) ≃ₗ[R] ⨁ i, LocalizedModule.mk' (s' i) 1 :=
    DirectSum.linearEquivFunOnFintype.trans
      (DFinsupp.mapRange.linearEquiv fun i =>
        IsLocalization.mapLocalizedModule_iso_of_eq (s i) (s' i) (hk i).symm)
  exact ⟨d', k' ∘ e'.symm, ⟨e.symm.trans e'.symm.trans hs'⟩⟩

Repaired Proof:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) ⧸
    LinearMap.range (powMonoidHom i : R →* R ⧸ R ∙ p ^ (k i : ℕ)) := by
  obtain ⟨d, s, hs⟩ := Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal hN
  have : ∀ i, ∃ k : ℕ, s i = p ^ k := by
    intro i
    obtain ⟨k, hk⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs i)
    exact ⟨k, by rwa [Submonoid.mem_powers_iff] at hk⟩
  choose k hk using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s i) 1) (Submonoid.powers (p ^ k i)) :=
    fun i => (LocalizedModule.isTorsion'_powers_iff _ _).mpr (hk i)
  have : ∀ i, Module.Finite R (LocalizedModule.mk' (s i) 1) := fun i =>
    Module.Finite.localizedModule (s i)
  obtain ⟨d', s', hs'⟩ :=
    Module.Finite.exists_is_localizedModule_is_torsion_by_powers_ideal (hN.localizedModule s)
  have : ∀ i, ∃ k' : ℕ, s' i = p ^ k' := by
    intro i
    obtain ⟨k', hk'⟩ := (IsLocalization.coeSubmonoid_eq _).mp (hs' i)
    exact ⟨k', by rwa [Submonoid.mem_powers_iff] at hk'⟩
  choose k' hk' using this
  letI : ∀ i, Module.IsTorsion' (LocalizedModule.mk' (s' i) 1)

Attempt failure.

Working on Mathlib/Algebra/Order/Interval/Set/Monoid.lean - 2024-09-09 01:32:45.379038.
---9/200---
For theorem Set.Ici_add_bij in Mathlib/Algebra/Order/Interval/Set/Monoid.lean:
theorem Ici_add_bij : BijOn (· + d) (Ici a) (Ici (a + d)) 


Original valid proof:
:= by
  refine
    ⟨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).injOn, fun _ h => ?_⟩
  obtain ⟨c, rfl⟩ := exists_add_of_le (mem_Ici.mp h)
  rw [mem_Ici, add_right_comm, add_le_add_iff_right] at h
  exact ⟨a + c, h, by rw [add_right_comm]⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      InjOn (· + d) (Ici a) ∧ SurjOn (· + d) (Ici a) (Ici (a + d)) := by
  refine' ⟨_, _, _⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine' ⟨y - d, _, by simp⟩
    simpa using hy

Repaired Proof:
theorem Ici_add_bij : BijOn (· + d) (Ici a) (Ici (a + d)) ∧
      InjOn (· + d) (Ici a) ∧ SurjOn (· + d) (Ici a) (Ici (a + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Ioi_add_bij : BijOn (· + d) (Ioi a) (Ioi (a + d)) ∧
      InjOn (· + d) (Ioi a) ∧ SurjOn (· + d) (Ioi a) (Ioi (a + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Iio_add_bij : BijOn (· + d) (Iio a) (Iio (a + d)) ∧
      InjOn (· + d) (Iio a) ∧ SurjOn (· + d) (Iio a) (Iio (a + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Iic_add_bij : BijOn (· + d) (Iic a) (Iic (a + d)) ∧
      InjOn (· + d) (Iic a) ∧ SurjOn (· + d) (Iic a) (Iic (a + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Icc_add_bij : BijOn (· + d) (Icc a b) (Icc (a + d) (b + d)) ∧
      InjOn (· + d) (Icc a b) ∧ SurjOn (· + d) (Icc a b) (Icc (a + d) (b + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Ico_add_bij : BijOn (· + d) (Ico a b) (Ico (a + d) (b + d)) ∧
      InjOn (· + d) (Ico a b) ∧ SurjOn (· + d) (Ico a b) (Ico (a + d) (b + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Ioc_add_bij : BijOn (· + d) (Ioc a b) (Ioc (a + d) (b + d)) ∧
      InjOn (· + d) (Ioc a b) ∧ SurjOn (· + d) (Ioc a b) (Ioc (a + d) (b + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Ioo_add_bij : BijOn (· + d) (Ioo a b) (Ioo (a + d) (b + d)) ∧
      InjOn (· + d) (Ioo a b) ∧ SurjOn (· + d) (Ioo a b) (Ioo (a + d) (b + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Ioi_add_bij : BijOn (· + d) (Ioi a) (Ioi (a + d)) ∧
      InjOn (· + d) (Ioi a) ∧ SurjOn (· + d) (Ioi a) (Ioi (a + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Iio_add_bij : BijOn (· + d) (Iio a) (Iio (a + d)) ∧
      InjOn (· + d) (Iio a) ∧ SurjOn (· + d) (Iio a) (Iio (a + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Iic_add_bij : BijOn (· + d) (Iic a) (Iic (a + d)) ∧
      InjOn (· + d) (Iic a) ∧ SurjOn (· + d) (Iic a) (Iic (a + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Icc_add_bij : BijOn (· + d) (Icc a b) (Icc (a + d) (b + d)) ∧
      InjOn (· + d) (Icc a b) ∧ SurjOn (· + d) (Icc a b) (Icc (a + d) (b + d)) := by
  refine ⟨?_, ?_, ?_⟩
  · rintro x hx
    simpa using hx
  · rintro x y hx hy hxy
    simpa using hxy
  · rintro y hy
    refine ⟨y - d, ?_, by simp⟩
    simpa using hy

Repaired Proof:
theorem Ico_add_bij : BijOn (· + d) (Ico a b) (Ico (a + d) (b + d)) ∧
      InjOn (· + d

Attempt failure.

Working on Mathlib/Algebra/Order/Module/Defs.lean - 2024-09-09 01:32:49.586795.
---10/200---
For theorem inv_smul_le_iff_of_neg in Mathlib/Algebra/Order/Module/Defs.lean:
lemma inv_smul_le_iff_of_neg (h : a < 0) : a⁻¹ • b₁ ≤ b₂ ↔ a • b₂ ≤ b₁ 


Original valid proof:
:= by
  rw [← smul_le_smul_iff_of_neg_left h, smul_inv_smul₀ h.ne]


Verifying proof (Commit 299792d941f0a59647d1864dd577af60b4b0228f):
• a := by
  rw [← smul_le_smul_iff_of_neg_left h, smul_inv_smul₀ h.ne]

lemma inv_smul_le_iff_of_neg' (h : a < 0) : a⁻¹ • b₁ ≤ b₂ ↔ a • b₂ ≤ b₁ := by
  rw [← smul_le_smul_iff_of_neg_left h, smul_inv_smul₀ h.ne']

lemma le_inv_smul_iff_of_neg (h : a < 0) : b₁ ≤ a⁻¹ • b₂ ↔ b₂ ≤ a • b₁ := by
  rw [← smul_le_smul_iff_of_neg_left h, smul_inv_smul₀ h.ne]

lemma le_inv_smul_iff_of_neg' (h : a < 0) : b₁ ≤ a⁻¹ • b₂ ↔ a • b₁ ≤ b₂ := by
  rw [← smul_le_smul_iff_of_neg_left h, smul_inv_smul₀ h.ne']

end LinearOrderedCommRing

section LinearOrderedField
variable [LinearOrderedField α] {a : α}

lemma inv_smul_le_iff_of_neg (ha : a < 0) {b₁ b₂ : β} : a⁻¹ • b₁ ≤ b₂ ↔ a • b₂ ≤ b₁ := by
  simpa only [inv_neg, smul_neg, neg_le_neg_iff] using inv_smul_le_iff_of_pos (neg_pos_of_neg ha)

lemma le_inv_smul_iff_of_neg (ha : a < 0) {b₁ b₂ : β} : b₁ ≤ a⁻¹ • b₂ ↔ b₂ ≤ a • b₁ := by
  simpa only [inv_neg, smul_neg, neg_le_neg_iff] using le_inv_smul_iff_of_pos (neg_pos_of_neg ha)

lemma inv_smul_lt_iff_of_neg (ha : a < 0) {b₁ b₂ : β} : a⁻¹ • b₁ < b₂ ↔ a • b₂ < b₁ := by
  simpa only [inv_neg, smul_neg, neg_lt_neg_iff] using inv_smul_lt_iff_of_pos (neg_pos_of_neg ha)

lemma lt_inv_smul_iff_of_neg (ha : a < 0) {b₁ b₂ : β} : b₁ < a⁻¹ • b₂ ↔ b₂ < a • b₁ := by
  simpa only [inv_neg, smul_neg, neg_lt_neg_iff] using lt_inv_smul_iff_of_pos (neg_pos_of_neg ha)

lemma inv_smul_lt_iff_of_neg' (ha : a < 0) {b₁ b₂ : β} : a⁻¹ • b₁ < b₂ ↔ b₁ < a • b₂ := by
  simpa only [inv_neg, smul_neg, neg_lt_neg_iff] using inv_smul_lt_iff_of_pos' (neg_pos_of_neg ha)

lemma lt_inv_smul_iff_of_neg' (ha : a < 0) {b₁ b₂ : β} : b₁ < a⁻¹ • b₂ ↔ a • b₁ < b₂ := by
  simpa only [inv_neg, smul_neg, neg_lt_neg_iff] using lt_inv_smul_iff_of_pos' (neg_pos_of_neg ha)

lemma inv_smul_le_iff_of_neg' (ha : a < 0) {b₁ b₂ : β} : a⁻¹ • b₁ ≤ b₂ ↔ b₁ ≤ a • b₂ := by
  simpa only [inv_neg, smul_neg, neg_le_neg_iff] using inv_smul_le_iff_of_pos' (neg_pos_of_neg ha)

lemma le_inv_smul_iff_of_neg' (ha : a < 0) {b₁ b₂ : β} : b₁ ≤ a⁻¹ • b₂ ↔ a • b₁ ≤ b₂ := by
  simpa only [inv_neg, smul_neg, neg_le_neg_iff] using le_inv_smul_iff_of_pos' (neg_pos_of_neg ha)

lemma inv_smul_eq_iff_of_neg (ha : a < 0) {b₁ b₂ : β} : a⁻¹ • b₁ = b₂ ↔ a • b₂ = b₁ := by
  simpa only [inv_neg, smul_neg, neg_inj] using inv_smul_eq_iff_of_pos (neg_pos_of_neg ha)

lemma eq_inv_smul_iff_of_neg (ha : a < 0) {b₁ b₂ : β} : b₁ = a⁻¹ • b₂ ↔ b₂ = a • b₁ := by
  simpa only [inv_neg, smul_neg, neg_inj] using eq_inv_smul_iff_of_pos (neg_pos_of_neg ha)

lemma inv_smul_eq_iff_of_neg' (ha : a < 0) {b₁ b₂ : β} : a⁻¹ • b₁ = b₂ ↔ b₁ = a • b₂ := by
  simpa only [inv_neg, smul_neg, neg_inj] using inv_smul_eq_iff_of_pos' (neg_pos_of_neg ha)

lemma eq_inv_smul_iff_of_neg' (ha : a < 0) {b₁ b₂ : β} : b₁ = a⁻¹ • b₂ ↔ b₂ = a • b₁ := by
  simpa only [inv_neg, smul_neg, neg_inj] using eq_inv_smul_iff_of_pos' (neg_pos_of_neg ha)

lemma inv_smul_eq_iff_of_neg'' (ha : a < 0) {b₁ b₂ : β} : a⁻¹ • b₁ = b₂ ↔ b₁ = a • b₂ := by
  simpa only [inv_neg, smul_neg, neg_inj] using inv_smul_eq_iff_of_pos'' (neg_pos_of_neg ha)

lemma eq_inv_smul_iff_of_neg'' (ha : a < 0) {b₁ b₂ : β} : b₁ = a⁻¹ • b₂ ↔ b₂ = a • b₁ := by
  simpa only [inv_neg, smul_neg, neg_inj] using eq_inv_smul_iff_of_pos'' (neg_pos_of_neg ha)

lemma inv_smul_eq_iff_of_neg''' (ha : a < 0) {b₁ b₂ : β} : a⁻¹ • b₁ = b₂ ↔ b₁ = a • b₂ := by
  simpa only [inv_neg, smul_neg, neg_inj] using inv_smul_eq_iff_of_pos''' (neg_pos_of_neg ha)

lemma eq_inv_smul_iff_of_neg''' (ha : a < 0) {b₁ b₂ : β} : b₁ = a⁻¹ • b₂ ↔ b₂ = a • b₁ := by
  simpa only [inv_neg, smul_neg, neg_inj] using eq_inv_smul_iff_of_pos''' (neg_pos_of_neg ha)

lemma inv_smul_eq_iff_of_neg'''' (ha : a < 0) {b₁ b₂ : β} : a⁻¹ • b₁ = b₂ ↔ b₁ = a • b₂ := by
  simpa only [inv_neg, smul_neg, neg_inj] using inv_smul_eq_iff_of_pos'''' (neg_pos_of_neg ha)

lemma eq_inv_smul_iff_of_neg'''' (ha : a < 0) {b₁ b₂ : β} : b₁ = a⁻¹ • b₂ ↔ b₂ = a • b₁ := by
  simpa only

Attempt failure.

Working on Mathlib/Algebra/Polynomial/Eval.lean - 2024-09-09 01:33:01.818748.
---11/200---
For theorem Polynomial.eval_C_mul in Mathlib/Algebra/Polynomial/Eval.lean:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x 


Original valid proof:
:= by
  induction p using Polynomial.induction_on' with
  | h_add p q ph qh =>
    simp only [mul_add, eval_add, ph, qh]
  | h_monomial n b =>
    simp only [mul_assoc, C_mul_monomial, eval_monomial]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero h₁ h
  · rw [mul_comm]
    exact eval_mul_C h

Repaired Proof:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x ↔ p.IsConstant → a = 0 := by
  refine ⟨fun h h₁ => ?_, fun h => ?_⟩
  · rw [h₁.eq_C_of_isConstant, eval_C, mul_zero] at h
    exact eq_zero_of_ne_zero_of_mul_right_eq_zero

Attempt failure.

---12/200---
For theorem Polynomial.eval_natCast_map in Mathlib/Algebra/Polynomial/Eval.lean:
theorem eval_natCast_map (f : R →+* S) (p : R[X]) (n : ℕ) :
    (p.map f).eval (n : S) = f (p.eval n) 


Original valid proof:
:= by
  induction p using Polynomial.induction_on' with
  | h_add p q hp hq =>
    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]
  | h_monomial n r =>
    simp only [map_natCast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
 := by
  induction p using Polynomial.induction_on' with
  | h_add p q ph qh =>
    simp only [add_comp, map_add, eval_add, ph, qh, RingHom.map_add]
  | h_monomial n a =>
    simp only [map_natCast f, eval_monomial, map_pow, map_mul, map_natCast f n]

Repaired Proof:
theorem eval_natCast_map (f : R →+* S) (p : R[X]) (n : ℕ) :
    (p.map f).eval (n : S) = f (p.eval n)  := by
  induction p using Polynomial.induction_on' with
  | h_add p q ph qh =>
    simp only [add_comp, map_add, eval_add, ph, qh, map_add]
  | h_monomial n a =>
    simp only [map_natCast f, eval_monomial, map_pow, map_mul, map_natCast f n]

Repaired Proof:
theorem eval_intCast_map (f : R →+* S) (p : R[X]) (i : ℤ) :
    (p.map f).eval (i : S) = f (p.eval i)  := by
  induction p using Polynomial.induction_on' with
  | h_add p q ph qh =>
    simp only [add_comp, map_add, eval_add, ph, qh, map_add]
  | h_monomial n a =>
    simp only [map_intCast, eval_monomial, map_pow, map_mul, map_intCast f n]

Repaired Proof:
theorem eval_intCast_map (f : R →+* S) (p : R[X]) (i : ℤ) :
    (p.map f).eval (i : S) = f (p.eval i)  := by
  induction p using Polynomial.induction_on' with
  | h_add p q ph qh =>
    simp only [add_comp, map_add, eval_add, ph, qh, map_add]
  | h_monomial n a =>
    simp only [map_intCast, eval_monomial, map_pow, map_mul, map_intCast f n]

Attempt failure.

Working on Mathlib/Algebra/Tropical/BigOperators.lean - 2024-09-09 01:33:22.208649.
---13/200---
For theorem Multiset.untrop_sum in Mathlib/Algebra/Tropical/BigOperators.lean:
theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.sum = Multiset.inf (s.map untrop) 


Original valid proof:
:= by
  induction' s using Multiset.induction with s x IH
  · simp
  · simp only [sum_cons, ge_iff_le, untrop_add, untrop_le_iff, map_cons, inf_cons, ← IH]
    rfl


Verifying proof (Commit 040e24340352a4333b5b2688f637a85dc78123c1):
↔ ∀ x ∈ s, ∀ y ∈ s, x ≤ y → untrop x ≤ untrop y := by
  induction' s using Multiset.induction with a s ihs
  · simp
  rw [Multiset.sum_cons, untrop_add, ihs, Multiset.map_cons, Multiset.inf_cons]
  refine ⟨fun h => ?_, fun h => ⟨le_inf fun b hb => h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb),
    inf_le _ _⟩⟩
  intro b hb
  rcases hb with (rfl | hb)
  · exact h _ (s.mem_cons_self _) _ (s.le_cons_self _ hb)
  · exact h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb)

Repaired Proof:
theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.sum = Multiset.inf (s.map untrop) ↔ ∀ x ∈ s, ∀ y ∈ s, x ≤ y → untrop x ≤ untrop y := by
  induction' s using Multiset.induction with a s ihs
  · simp
  rw [Multiset.sum_cons, untrop_add, ihs, Multiset.map_cons, Multiset.inf_cons]
  refine ⟨fun h => ?_, fun h => ⟨le_inf fun b hb => h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb),
    inf_le _ _⟩⟩
  intro b hb
  rcases hb with (rfl | hb)
  · exact h _ (s.mem_cons_self _) _ (s.le_cons_self _ hb)
  · exact h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb)

Repaired Proof:
theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.sum = Multiset.inf (s.map untrop) ↔ ∀ x ∈ s, ∀ y ∈ s, x ≤ y → untrop x ≤ untrop y := by
  induction' s using Multiset.induction with a s ihs
  · simp
  rw [Multiset.sum_cons, untrop_add, ihs, Multiset.map_cons, Multiset.inf_cons]
  refine ⟨fun h => ?_, fun h => ⟨le_inf fun b hb => h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb),
    inf_le _ _⟩⟩
  intro b hb
  rcases hb with (rfl | hb)
  · exact h _ (s.mem_cons_self _) _ (s.le_cons_self _ hb)
  · exact h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb)

Repaired Proof:
theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.sum = Multiset.inf (s.map untrop) ↔ ∀ x ∈ s, ∀ y ∈ s, x ≤ y → untrop x ≤ untrop y := by
  induction' s using Multiset.induction with a s ihs
  · simp
  rw [Multiset.sum_cons, untrop_add, ihs, Multiset.map_cons, Multiset.inf_cons]
  refine ⟨fun h => ?_, fun h => ⟨le_inf fun b hb => h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb),
    inf_le _ _⟩⟩
  intro b hb
  rcases hb with (rfl | hb)
  · exact h _ (s.mem_cons_self _) _ (s.le_cons_self _ hb)
  · exact h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb)

Repaired Proof:
theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.sum = Multiset.inf (s.map untrop) ↔ ∀ x ∈ s, ∀ y ∈ s, x ≤ y → untrop x ≤ untrop y := by
  induction' s using Multiset.induction with a s ihs
  · simp
  rw [Multiset.sum_cons, untrop_add, ihs, Multiset.map_cons, Multiset.inf_cons]
  refine ⟨fun h => ?_, fun h => ⟨le_inf fun b hb => h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb),
    inf_le _ _⟩⟩
  intro b hb
  rcases hb with (rfl | hb)
  · exact h _ (s.mem_cons_self _) _ (s.le_cons_self _ hb)
  · exact h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb)

Repaired Proof:
theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.sum = Multiset.inf (s.map untrop) ↔ ∀ x ∈ s, ∀ y ∈ s, x ≤ y → untrop x ≤ untrop y := by
  induction' s using Multiset.induction with a s ihs
  · simp
  rw [Multiset.sum_cons, untrop_add, ihs, Multiset.map_cons, Multiset.inf_cons]
  refine ⟨fun h => ?_, fun h => ⟨le_inf fun b hb => h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb),
    inf_le _ _⟩⟩
  intro b hb
  rcases hb with (rfl | hb)
  · exact h _ (s.mem_cons_self _) _ (s.le_cons_self _ hb)
  · exact h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb)

Repaired Proof:
theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.sum = Multiset.inf (s.map untrop) ↔ ∀ x ∈ s, ∀ y ∈ s, x ≤ y → untrop x ≤ untrop y := by
  induction' s using Multiset.induction with a s ihs
  · simp
  rw [Multiset.sum_cons, untrop_add, ihs, Multiset.map_cons, Multiset.inf_cons]
  refine ⟨fun h => ?_, fun h => ⟨le_inf fun b hb => h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb),
    inf_le _ _⟩⟩
  intro b hb
  rcases hb with (rfl | hb)
  · exact h _ (s.mem_cons_self _) _ (s.le_cons_self _ hb)
  · exact h _ (s.mem_cons_of_mem hb) _ (s.le_cons_self _ hb)

Repaired Proof:
theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.sum = Multiset.inf (s.map untrop) ↔ ∀ x ∈ s, ∀ y ∈ s, x ≤ y → untrop x ≤ untrop y := by
  induction' s using Multiset.induction with a s ihs
  · simp

Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean - 2024-09-09 01:33:27.553979.
---14/200---
For theorem WeierstrassCurve.Projective.equiv_of_Z_eq_zero in Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean:
lemma equiv_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q 


Original valid proof:
:= by
  rw [fin3_def P, hPz] at hP ⊢
  rw [fin3_def Q, hQz] at hQ ⊢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ⟨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel₀ _ hQ]⟩


Verifying proof (Commit 0a4b391b68ce1c32b1ab9ccb77a41ee1c7f8371b):
↔ P x * Q y = P y * Q x := by
  rw [← not_iff_not, Classical.not_not, Classical.not_not,
    equiv_iff_not_fin_three_eq_of_Z_eq_zero hP hQ hPz hQz, Classical.not_not]

Repaired Proof:
lemma equiv_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q ↔ P x * Q y = P y * Q x := by
  rw [← not_iff_not, Classical.not_not, Classical.not_not,
    equiv_iff_fin_three_eq_of_Z_eq_zero hP hQ hPz hQz, Classical.not_not]

Repaired Proof:
lemma equiv_iff_X_eq_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q ↔ P x = Q x := by
  rw [equiv_iff_fin_three_eq_of_Z_eq_zero hP hQ hPz hQz, ← sub_eq_zero, ← @sub_self _ _ (P y),
    ← sub_sub, sub_eq_zero, eq_comm]

Repaired Proof:
lemma equiv_iff_Y_eq_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q ↔ P y = Q y := by
  rw [equiv_iff_fin_three_eq_of_Z_eq_zero hP hQ hPz hQz, ← sub_eq_zero, ← @sub_self _ _ (P x),
    ← sub_sub, sub_eq_zero, eq_comm]

Repaired Proof:
lemma equiv_iff_X_eq_of_Z_ne_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z ≠ 0) (hQz : Q z ≠ 0) : P ≈ Q ↔ P x * Q z = P z * Q x := by
  rw [← not_iff_not, Classical.not_not, Classical.not_not,
    not_equiv_iff_fin_three_eq hP hQ hPz hQz, Classical.not_not]

Repaired Proof:
lemma equiv_iff_Y_eq_of_Z_ne_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z ≠ 0) (hQz : Q z ≠ 0) : P ≈ Q ↔ P y * Q z = P z * Q y := by
  rw [← not_iff_not, Classical.not_not, Classical.not_not,
    not_equiv_iff_fin_three_eq hP hQ hPz hQz, Classical.not_not]

Repaired Proof:
lemma equiv_of_X_eq_of_Z_ne_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z ≠ 0) (hQz : Q z ≠ 0) (hx : P x * Q z = P z * Q x) : P ≈ Q := by
  rw [← not_iff_not, Classical.not_not, not_equiv_iff_fin_three_eq hP hQ hPz hQz,
    hx, eq_self, and_true, and_iff_right_iff_imp]
  rintro rfl
  have hy : P y * Q z = P z * Q y := by linear_combination (norm := (push_cast; ring1))
    W.toAffine.slope_of_X_ne hP.left hQ.left (hx ▸ hPz.symm ▸ hQz.symm ▸ (mul_ne_zero hPz hQz).symm)
  exact ⟨hx, hy⟩

Repaired Proof:
lemma equiv_of_X_eq_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) (hx : P x = Q x) : P ≈ Q := by
  rw [← not_iff_not, Classical.not_not, not_equiv_iff_fin_three_eq hP hQ hPz hQz, hx,
    eq_self, and_true, and_iff_right_iff_imp]
  rintro rfl
  exact ⟨rfl, (W.toAffine.slope_of_Z_eq hPz hQz).symm⟩

Repaired Proof:
lemma equiv_of_X_ne_of_Z_ne_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hx : P x * Q z ≠ P z * Q x) (hPz : P z ≠ 0) (hQz : Q z ≠ 0) : P ≈ Q := by
  rw [← not_iff_not, Classical.not_not, not_equiv_iff_fin_three_eq hP hQ hPz hQz,
    Classical.not_not]
  exact ⟨hx, (W.toAffine.slope_of_X_ne hP.left hQ.left hx).symm⟩

Repaired Proof:
lemma equiv_of_X_ne_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hx : P x ≠ Q x) (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q := by
  rw [← not_iff_not, Classical.not_not, not_equiv_iff_fin_three_eq hP hQ hPz hQz,
    Classical.not_not]
  exact ⟨hx, (W.toAffine.slope_of_Z_eq hPz hQz).symm⟩

Repaired Proof:
lemma equiv_of_X_ne_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hx : P x ≠ 0) (hy : P y ≠ 0) : P ≈ Q ↔ P x * Q x = P y * Q y := by
  rw [← not_iff_not, Classical.not_not, not_equiv_iff_fin_three_eq hP hQ hx hy,
    Classical.not_not]

Repaired Proof:
lemma equiv_of_X_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hx : P x = 0) (hy : P y ≠ 0) : P ≈ Q ↔ P y * Q y = 0 := by
  rw [← not_iff_not, Classical.not_not, not_equiv_iff_fin_three_eq hP hQ hx hy,
    Classical.not_not]

Repaired Proof:
lemma equiv_of_Y_ne_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hy : P y ≠ 0) (hz : P z ≠ 0) : P ≈ Q ↔ P y * Q z = P z * Q y := by
  rw [← not_iff_not, Classical.not_not, not_equiv_iff_fin_three_eq hP hQ hy hz,
    Classical.not_not]

Repaired Proof:
lemma equiv_of_Y_eq_zero {P

Attempt failure.

Working on Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean - 2024-09-09 01:33:42.449392.
---15/200---
For theorem RingHom.PropertyIsLocal.sourceAffineLocally_of_source_openCover in Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean:
theorem sourceAffineLocally_of_source_openCover {X Y : Scheme.{u}} (f : X ⟶ Y) [IsAffine Y]
    (𝒰 : X.OpenCover) [∀ i, IsAffine (𝒰.obj i)] (H : ∀ i, P (Scheme.Γ.map (𝒰.map i ≫ f).op)) :
    sourceAffineLocally (@P) f 


Original valid proof:
:= by
  let S i := (⟨⟨Set.range (𝒰.map i).1.base, (𝒰.IsOpen i).base_open.isOpen_range⟩,
    isAffineOpen_opensRange (𝒰.map i)⟩ : X.affineOpens)
  intro U
  apply of_affine_open_cover
    (P := fun V => P (Scheme.Γ.map (X.ofRestrict (Opens.openEmbedding V.val) ≫ f).op)) S
    𝒰.iSup_opensRange
  · intro U r H
    convert hP.StableUnderComposition
      (S := Scheme.Γ.obj (Opposite.op (X.restrict <| Opens.openEmbedding U.val)))
      (T := Scheme.Γ.obj (Opposite.op (X.restrict <| Opens.openEmbedding (X.basicOpen r))))
      ?_ ?_ H ?_ using 1
    swap
    · refine X.presheaf.map
          (@homOfLE _ _ ((IsOpenMap.functor _).obj _) ((IsOpenMap.functor _).obj _) ?_).op
      dsimp
      rw [Opens.openEmbedding_obj_top, Opens.openEmbedding_obj_top]
      exact X.basicOpen_le _
    · rw [op_comp, op_comp, Functor.map_comp, Functor.map_comp]
      refine (Eq.trans ?_ (Category.assoc (obj := CommRingCat) _ _ _).symm : _)
      congr 1
      dsimp
      refine Eq.trans ?_ (X.presheaf.map_comp _ _)
      change X.presheaf.map _ = _
      congr!
    convert @HoldsForLocalizationAway _ hP _
      (Scheme.Γ.obj (Opposite.op (X.restrict (X.basicOpen r).openEmbedding))) _ _ ?_
      (X.presheaf.map (eqToHom U.1.openEmbedding_obj_top).op r) ?_
    · exact RingHom.algebraMap_toAlgebra
        (R := Scheme.Γ.obj <| Opposite.op <| X.restrict (U.1.openEmbedding))
        (S :=
          Scheme.Γ.obj (Opposite.op <| X.restrict (X.affineBasicOpen r).1.openEmbedding)) _|>.symm
    · dsimp [Scheme.Γ]
      have := U.2
      rw [← U.1.openEmbedding_obj_top] at this
      convert (config := {typeEqs := true, transparency := .default})
          this.isLocalization_basicOpen _ using 5
      all_goals rw [Opens.openEmbedding_obj_top]; exact (Scheme.basicOpen_res_eq _ _ _).symm
  · introv hs hs'
    exact sourceAffineLocally_of_source_open_cover_aux hP.respectsIso hP.2 _ _ _ hs hs'
  · rintro i
    specialize H i
    rw [← hP.respectsIso.cancel_right_isIso _
        (Scheme.Γ.map
          (IsOpenImmersion.isoOfRangeEq (𝒰.map i) (X.ofRestrict (S i).1.openEmbedding)
                Subtype.range_coe.symm).inv.op)] at H
    rwa [← Scheme.Γ.map_comp, ← op_comp, IsOpenImmersion.isoOfRangeEq_inv_fac_assoc] at H


Verifying proof (Commit 8521d5a6ab9a0abc6319fae2d116feb58acc6f93):
𝒰 := by
  intro U
  obtain ⟨i, x, hx⟩ := 𝒰.exists_preimage (𝒰.fintypeIsOpen <| U.unop)
  refine ⟨𝒰.obj i, x, hx, ?_⟩
  rw [← hP.respectsIso.cancel_left_isIso
      (Scheme.Γ.mapIso (X.openCoverOfIsAffineIsomorphism (𝒰.obj i) (𝒰.map i)
        (IsAffineOpen.of_stalkIso (𝒰.map i).1.base x)).op),
    ← Functor.map_comp, ← op_comp, ← Category.assoc, ← IsIso.inv_hom_id_assoc,
    IsIso.inv_hom_id, Functor.map_id, op_id, CategoryTheory.Functor.map_id,
    CategoryTheory.Functor.id_obj, Category.id_comp, Scheme.Γ_map_op,
    Scheme.Γ_map_op, ← hP.respectsIso.cancel_right_isIso
      (Scheme.Γ.mapIso (Y.openCoverOfIsAffineIsomorphism (𝒰.obj i) (𝒰.map i)
        (IsAffineOpen.of_stalkIso (𝒰.map i).1.base x)).op),
    ← Functor.map_comp, ← op_comp, ← Category.assoc, ← IsIso.inv_hom_id_assoc,
    IsIso.inv_hom_id, Functor.map_id, op_id, CategoryTheory.Functor.map_id,
    CategoryTheory.Functor.id_obj, Category.id_comp, Scheme.Γ_map_op, Scheme.Γ_map_op,
    Scheme.Γ.map_comp, Scheme.Γ.map_comp, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category.assoc, ← op_comp, ← op_comp, ← Category.assoc,
    ← Category.assoc, IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc,
    Category.assoc, Category

Attempt failure.

Working on Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean - 2024-09-09 01:34:26.442892.
---16/200---
For theorem AlgebraicTopology.AlternatingCofaceMapComplex.d_squared in Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean:
theorem d_squared (n : ℕ) : objD X (n + 1) ≫ objD X n = 0 


Original valid proof:
:= by
  dsimp
  simp only [comp_sum, sum_comp, ← Finset.sum_product']
  let P := Fin (n + 2) × Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  erw [← Finset.sum_add_sum_compl S, ← eq_neg_iff_add_eq_zero, ← Finset.sum_neg_distrib]
  let φ : ∀ ij : P, ij ∈ S → P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij φ
  · 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij ⊢
    linarith
  · 
    rintro ⟨i, j⟩ hij ⟨i', j'⟩ hij' h
    rw [Prod.mk.inj_iff]
    exact ⟨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)⟩
  · 
    rintro ⟨i', j'⟩ hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine ⟨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_⟩
    · rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    · simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    · simp only [φ, Fin.castLT_castSucc, Fin.succ_pred]
  · 
    rintro ⟨i, j⟩ hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, ← neg_smul]
    congr 1
    · simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    · rw [CategoryTheory.SimplicialObject.δ_comp_δ'']
      simpa [S] using hij


Verifying proof (Commit ecdd87a32faafd1762b706324fbef9260022a7b2):
 := by
  dsimp [objD]
  simp only [HomologicalComplex.d_f_comp_d_f_assoc, d_squared_assoc, zero_comp,
    comp_zero, add_zero]

Represents the differential on the alternating coface map complex of a cosimplicial object.

- `objD X n` is the differential on the alternating coface map complex of a cosimplicial object
  `X` in a preadditive category `C`.
- `objD_eq X n` is a proof that `objD X n` is equal to `alternatingCofaceMapComplex.objD X n`.
- `d_squared X n` is a proof that the composition of `objD X (n + 1)` and `objD X n` is zero.

Represents the differential on the alternating coface map complex of a cosimplicial object.

- `objD X n` is the differential on the alternating coface map complex of a cosimplicial object
  `X` in a preadditive category `C`.
- `objD_eq X n` is a proof that `objD X n` is equal to `alternatingCofaceMapComplex.objD X n`.
- `d_squared X n` is a proof that the composition of `objD X (n + 1)` and `objD X n` is zero.

Attempt failure.

Working on Mathlib/AlgebraicTopology/SimplexCategory.lean - 2024-09-09 01:34:36.999547.
---17/200---
For theorem SimplexCategory.δ_comp_σ_of_le in Mathlib/AlgebraicTopology/SimplexCategory.lean:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i 


Original valid proof:
:= by
  ext k : 3
  dsimp [σ, δ]
  rcases le_or_lt i k with (hik | hik)
  · rw [Fin.succAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hik),
    Fin.succ_predAbove_succ, Fin.succAbove_of_le_castSucc]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    · rwa [Fin.predAbove_of_le_castSucc _ _ hjk, Fin.castSucc_castPred]
    · rw [Fin.le_castSucc_iff, Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succ_pred]
      exact H.trans_lt hjk
  · rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hik)]
    have hjk := H.trans_lt' hik
    rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr
      (hjk.trans (Fin.castSucc_lt_succ _)).le),
      Fin.predAbove_of_le_castSucc _ _ hjk.le, Fin.castPred_castSucc, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_castPred]
    rwa [Fin.castSucc_castPred]


Verifying proof (Commit 1b5c1d10be0ae07fd997c78515f4ed4561b92535):
≫ σ j.succ := by
  rcases i with ⟨i, hi⟩
  rcases j with ⟨j, hj⟩
  rcases le_or_lt i j with (hij | hji)
  · rw [σ_comp_δ_of_le (Fin.castSucc_lt_castSucc_iff.mpr hij),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hij), comp_assoc]
  · have hjk : j.succ < n + 2 := Nat.lt_of_succ_lt_succ (lt_of_lt_of_le hji hj)
    have hik : i < n + 1 := lt_of_lt_of_le hij hj
    rw [σ_comp_δ_of_lt (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hjk),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      comp_assoc, comp_assoc, comp_assoc,
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik),
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik)]

Repaired Proof:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i ≫ σ j.succ := by
  rcases i with ⟨i, hi⟩
  rcases j with ⟨j, hj⟩
  rcases le_or_lt i j with (hij | hji)
  · rw [σ_comp_δ_of_le (Fin.castSucc_lt_castSucc_iff.mpr hij),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hij), comp_assoc]
  · have hjk : j.succ < n + 2 := Nat.lt_of_succ_lt_succ (lt_of_lt_of_le hji hj)
    have hik : i < n + 1 := lt_of_lt_of_le hij hj
    rw [σ_comp_δ_of_lt (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hjk),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      comp_assoc, comp_assoc, comp_assoc,
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik),
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik)]

Repaired Proof:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i ≫ σ j.succ := by
  rcases i with ⟨i, hi⟩
  rcases j with ⟨j, hj⟩
  rcases le_or_lt i j with (hij | hji)
  · rw [σ_comp_δ_of_le (Fin.castSucc_lt_castSucc_iff.mpr hij),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hij), comp_assoc]
  · have hjk : j.succ < n + 2 := Nat.lt_of_succ_lt_succ (lt_of_lt_of_le hji hj)
    have hik : i < n + 1 := lt_of_lt_of_le hij hj
    rw [σ_comp_δ_of_lt (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hjk),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      comp_assoc, comp_assoc, comp_assoc,
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik),
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik)]

Repaired Proof:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i ≫ σ j.succ := by
  rcases i with ⟨i, hi⟩
  rcases j with ⟨j, hj⟩
  rcases le_or_lt i j with (hij | hji)
  · rw [σ_comp_δ_of_le (Fin.castSucc_lt_castSucc_iff.mpr hij),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hij), comp_assoc]
  · have hjk : j.succ < n + 2 := Nat.lt_of_succ_lt_succ (lt_of_lt_of_le hji hj)
    have hik : i < n + 1 := lt_of_lt_of_le hij hj
    rw [σ_comp_δ_of_lt (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hjk),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      comp_assoc, comp_assoc, comp_assoc,
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik),
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik)]

Repaired Proof:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i ≫ σ j.succ := by
  rcases i with ⟨i, hi⟩
  rcases j with ⟨j, hj⟩
  rcases le_or_lt i j with (hij | hji)
  · rw [σ_comp_δ_of_le (Fin.castSucc_lt_castSucc_iff.mpr hij),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hij), comp_assoc]
  · have hjk : j.succ < n + 2 := Nat.lt_of_succ_lt_succ (lt_of_lt_of_le hji hj)
    have hik : i < n + 1 := lt_of_lt_of_le hij hj
    rw [σ_comp_δ_of_lt (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hjk),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      comp

Attempt failure.

---18/200---
For theorem SimplexCategory.δ_comp_σ_of_le in Mathlib/AlgebraicTopology/SimplexCategory.lean:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i 


Original valid proof:
:= by
  ext k : 3
  dsimp [σ, δ]
  rcases le_or_lt i k with (hik | hik)
  · rw [Fin.succAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hik),
    Fin.succ_predAbove_succ, Fin.succAbove_of_le_castSucc]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    · rwa [Fin.predAbove_of_le_castSucc _ _ hjk, Fin.castSucc_castPred]
    · rw [Fin.le_castSucc_iff, Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succ_pred]
      exact H.trans_lt hjk
  · rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hik)]
    have hjk := H.trans_lt' hik
    rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr
      (hjk.trans (Fin.castSucc_lt_succ _)).le),
      Fin.predAbove_of_le_castSucc _ _ hjk.le, Fin.castPred_castSucc, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_castPred]
    rwa [Fin.castSucc_castPred]


Verifying proof (Commit 7472132820a806816d92180a5476e45b47a8d68b):
≫ σ j.succ := by
  rcases i with ⟨i, hi⟩
  rcases j with ⟨j, hj⟩
  rcases le_or_lt i j with (hij | hji)
  · rw [σ_comp_δ_of_le (Fin.castSucc_lt_castSucc_iff.mpr hij),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hij), comp_assoc]
  · have hjk : j.succ < n + 2 := Nat.lt_of_succ_lt_succ (lt_of_lt_of_le hji hj)
    have hik : i < n + 1 := lt_of_lt_of_le hij hj
    rw [σ_comp_δ_of_lt (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hjk),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      comp_assoc, comp_assoc, comp_assoc,
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik),
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik)]

Repaired Proof:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i ≫ σ j.succ := by
  rcases i with ⟨i, hi⟩
  rcases j with ⟨j, hj⟩
  rcases le_or_lt i j with (hij | hji)
  · rw [σ_comp_δ_of_le (Fin.castSucc_lt_castSucc_iff.mpr hij),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hij), comp_assoc]
  · have hjk : j.succ < n + 2 := Nat.lt_of_succ_lt_succ (lt_of_lt_of_le hji hj)
    have hik : i < n + 1 := lt_of_lt_of_le hij hj
    rw [σ_comp_δ_of_lt (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hjk),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      comp_assoc, comp_assoc, comp_assoc,
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik),
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik)]

Repaired Proof:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i ≫ σ j.succ := by
  rcases i with ⟨i, hi⟩
  rcases j with ⟨j, hj⟩
  rcases le_or_lt i j with (hij | hji)
  · rw [σ_comp_δ_of_le (Fin.castSucc_lt_castSucc_iff.mpr hij),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hij), comp_assoc]
  · have hjk : j.succ < n + 2 := Nat.lt_of_succ_lt_succ (lt_of_lt_of_le hji hj)
    have hik : i < n + 1 := lt_of_lt_of_le hij hj
    rw [σ_comp_δ_of_lt (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hjk),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      comp_assoc, comp_assoc, comp_assoc,
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik),
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik)]

Repaired Proof:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i ≫ σ j.succ := by
  rcases i with ⟨i, hi⟩
  rcases j with ⟨j, hj⟩
  rcases le_or_lt i j with (hij | hji)
  · rw [σ_comp_δ_of_le (Fin.castSucc_lt_castSucc_iff.mpr hij),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hij), comp_assoc]
  · have hjk : j.succ < n + 2 := Nat.lt_of_succ_lt_succ (lt_of_lt_of_le hji hj)
    have hik : i < n + 1 := lt_of_lt_of_le hij hj
    rw [σ_comp_δ_of_lt (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hjk),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      comp_assoc, comp_assoc, comp_assoc,
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik),
      σ_comp_δ_of_le (Fin.le_castSucc_of_lt_succ hik)]

Repaired Proof:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i ≫ σ j.succ := by
  rcases i with ⟨i, hi⟩
  rcases j with ⟨j, hj⟩
  rcases le_or_lt i j with (hij | hji)
  · rw [σ_comp_δ_of_le (Fin.castSucc_lt_castSucc_iff.mpr hij),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hij), comp_assoc]
  · have hjk : j.succ < n + 2 := Nat.lt_of_succ_lt_succ (lt_of_lt_of_le hji hj)
    have hik : i < n + 1 := lt_of_lt_of_le hij hj
    rw [σ_comp_δ_of_lt (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      ← δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hjk),
      δ_comp_σ_of_le (Fin.le_castSucc_of_lt_succ hik),
      comp

Attempt failure.

Working on Mathlib/Analysis/Analytic/Uniqueness.lean - 2024-09-09 01:34:54.391938.
---19/200---
For theorem AnalyticOn.eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux in Mathlib/Analysis/Analytic/Uniqueness.lean:
theorem eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux [CompleteSpace F] {f : E → F} {U : Set E}
    (hf : AnalyticOn 𝕜 f U) (hU : IsPreconnected U) {z₀ : E} (h₀ : z₀ ∈ U) (hfz₀ : f =ᶠ[𝓝 z₀] 0) :
    EqOn f 0 U 


Original valid proof:
:= by
  let u := {x | f =ᶠ[𝓝 x] 0}
  suffices main : closure u ∩ U ⊆ u by
    have Uu : U ⊆ u :=
      hU.subset_of_closure_inter_subset isOpen_setOf_eventually_nhds ⟨z₀, h₀, hfz₀⟩ main
    intro z hz
    simpa using mem_of_mem_nhds (Uu hz)
  rintro x ⟨xu, xU⟩
  rcases hf x xU with ⟨p, r, hp⟩
  obtain ⟨y, yu, hxy⟩ : ∃ y ∈ u, edist x y < r / 2 :=
    EMetric.mem_closure_iff.1 xu (r / 2) (ENNReal.half_pos hp.r_pos.ne')
  let q := p.changeOrigin (y - x)
  have has_series : HasFPowerSeriesOnBall f q y (r / 2) := by
    have A : (‖y - x‖₊ : ℝ≥0∞) < r / 2 := by rwa [edist_comm, edist_eq_coe_nnnorm_sub] at hxy
    have := hp.changeOrigin (A.trans_le ENNReal.half_le_self)
    simp only [add_sub_cancel] at this
    apply this.mono (ENNReal.half_pos hp.r_pos.ne')
    apply ENNReal.le_sub_of_add_le_left ENNReal.coe_ne_top
    apply (add_le_add A.le (le_refl (r / 2))).trans (le_of_eq _)
    exact ENNReal.add_halves _
  have M : EMetric.ball y (r / 2) ∈ 𝓝 x := EMetric.isOpen_ball.mem_nhds hxy
  filter_upwards [M] with z hz
  have A : HasSum (fun n : ℕ => q n fun _ : Fin n => z - y) (f z) := has_series.hasSum_sub hz
  have B : HasSum (fun n : ℕ => q n fun _ : Fin n => z - y) 0 := by
    have : HasFPowerSeriesAt 0 q y := has_series.hasFPowerSeriesAt.congr yu
    convert hasSum_zero (α := F) using 2
    ext n
    exact this.apply_eq_zero n _
  exact HasSum.unique A B


Verifying proof (Commit 4a37a8e778eb3014aeb05af1b09f6de104536d53):
∨ ∃ C, ∀ z ∈ U, ‖f z‖ ≤ C := by
  classical
    by_cases h : ∃ C, ∀ z ∈ U, ‖f z‖ ≤ C
    · exact Or.inr h
    push_neg at h
    obtain ⟨g, hg, hfg⟩ : ∃ g : E → F, AnalyticOn 𝕜 g U ∧ ∀ z ∈ U, f z = g z ∧ ‖g z‖ < 1 := by
      have : ∀ z ∈ U, ∃ C, ‖f z‖ < C := by
        intro z hz
        obtain ⟨C, hC⟩ := h z hz
        exact
          ⟨‖f z‖ + 1,
            lt_add_of_pos_right _
              (lt_of_le_of_lt (norm_nonneg _) (hC z hz) :
                0 < ‖f z‖ - ⨅ z : U, ‖f z‖)⟩
      choose! C hC using this
      have hC' : ∀ z ∈ U, ‖f z‖ ≤ ⨅ z : U, ‖f z‖ + C z := by
        intro z hz
        rw [tsub_le_iff_right]
        exact le_ciInf fun z' => hC z' z'.2
      obtain ⟨C', hC'⟩ : ∃ C', ∀ z ∈ U, ‖f z‖ ≤ C' := by
        have : BddAbove (range fun z : U => ‖f z‖) := by
          refine' ⟨⨅ z : U, ‖f z‖ + C z, _⟩
          rintro - ⟨z, rfl⟩
          exact hC' z z.2
        obtain ⟨C', hC'⟩ : ∃ C', IsLUB (range fun z : U => ‖f z‖) C' :=
          exists_isLUB_of_bounded_of_nonempty (range_nonempty _) this
        refine' ⟨C' + 1, fun z hz => _⟩
        rw [← hfg 0 h₀, ← hfg z hz]
        exact
          (norm_le_of_forall_le (norm_nonneg _) fun z' => hC' (mem_range_self _) ▸ hC' z' z'.2).trans
            (le_add_of_nonneg_right zero_le_one)
      obtain ⟨g, hg, hfg'⟩ : ∃ g : E → F, AnalyticOn 𝕜 g U ∧ ∀ z ∈ U, ‖f z - g z‖ < C' := by
        have : ∀ z ∈ U, ∃ C, ‖f z - g z‖ < C := by
          intro z hz
          obtain ⟨C, hC⟩ := h z hz
          exact
            ⟨C' - ‖g z‖,
              sub_lt_comm.2
                (lt_of_le_of_lt (norm_sub_le _ _)
                  (add_lt_of_lt_sub_right (lt_of_le_of_lt (norm_nonneg _) (hfg' z hz) :
                    ‖g z‖ < C' - ⨅ z : U, ‖g z‖)
                    (lt_of_le_of_lt (ciInf_le (⟨0, by simp⟩ : BddBelow _) ⟨z, rfl⟩) (hC' z hz))))⟩
        choose! C hC using this
        have hC' : ∀ z ∈ U, ‖f z - g z‖ ≤ ⨅ z : U, C z + ‖g z‖ := by
          intro z hz
          rw [tsub_le_iff_right]
          exact le_ciInf fun z' => hC z' z'.2
        obtain ⟨C', hC'⟩ : ∃ C', ∀ z ∈ U, ‖f z - g z‖ ≤ C' := by
          have : BddAbove (range fun z : U => C z + ‖g z‖) := by
            refine' ⟨⨅ z : U, C z + ‖g z‖ + C', _⟩
            rintro - ⟨z, rfl⟩
            exact hC' z z.2
          obtain ⟨C', hC'⟩ : ∃ C', IsLUB (range fun z : U => C z + ‖g z‖) C' :=
            exists_isLUB_of_bounded_of_nonempty (range_nonempty _) this
          refine' ⟨C' + ‖g 0‖, fun z hz => _⟩
          rw [← hfg 0 h₀, ← hfg' z hz]
          exact
            (norm_sub_le _ _).trans
              (add_le_add (hC' (mem_range_self _) ▸ hC' z z.2) (norm_le_ciInf_add_norm _ _))
        refine' ⟨fun z => (f z - g z) / C', analyticOn_div (hg.sub hg) analyticOn_const
          fun z hz => _, fun z hz => _⟩
        · simp only [Ne, Pi.sub_apply, div_eq_zero_iff, sub_eq_zero, _root_.norm_eq_zero]
          exact (hfg' z hz).ne'
        · field_simp [(hfg' z hz).ne']
          exact hfg z hz
      exact ⟨g, hg, hfg, fun z hz => norm_le_of_forall_le (norm_nonneg _) fun z' =>
        (norm_sub_le _ _).trans (add_le_add (hC' z' z'.2) (norm_le_ciInf_add_norm _ _))⟩
    obtain ⟨C, hC⟩ : ∃ C, ∀ z ∈ U, ‖f z‖ ≤ C := by
      by_contra' h'
      obtain ⟨z₀, hz₀, C, hC⟩ : ∃ z₀ ∈ U, ∃ C, ∀ z ∈ U, C < ‖f z‖ := by
        simpa only [not_exists, not_forall, not_le] using h'
      obtain ⟨z₁, hz₁, C₁, hC₁⟩ : ∃ z₁ ∈ U, ∃ C₁, ∀ z ∈ U, ‖f z‖ < C₁ + ‖f z₁‖ - C := by
        simpa only [not_exists, not_forall, not_lt, not_le] using h
      obtain ⟨z₂, hz₂, C₂, hC₂⟩ : ∃ z₂ ∈ U, ∃ C₂, ∀ z ∈ U, ‖f z‖ < C₂ + ‖f z₂‖ - C := by
        simpa only [not_exists, not_forall, not_lt, not_le] using h
      obtain ⟨z₃, hz₃, C₃, hC₃⟩ : ∃ z₃ ∈ U, ∃ C₃, ∀ z ∈ U, ‖f z‖ < C₃ + ‖f z₃‖ - C := by
        simpa only [not_exists, not_forall, not_lt, not_le] using h
      obtain ⟨z₀', hz₀', h₀'⟩ : ∃ z₀' ∈ U, f z₀' = 0 := by
        by_contra' h'
        obtain ⟨z₀', hz₀', h₀'⟩ : ∃ z₀' ∈ U, ∀ᶠ z in 𝓝 z₀', f z ≠ 0 := by
          simpa only [not_exists, not_forall, not_eventually, not_ne_iff] using h'
        obtain

Attempt failure.

Working on Mathlib/Analysis/BoundedVariation.lean - 2024-09-09 01:35:24.932683.
---20/200---
For theorem eVariationOn.comp_inter_Icc_eq_of_monotoneOn in Mathlib/Analysis/BoundedVariation.lean:
theorem comp_inter_Icc_eq_of_monotoneOn (f : α → E) {t : Set β} (φ : β → α) (hφ : MonotoneOn φ t)
    {x y : β} (hx : x ∈ t) (hy : y ∈ t) :
    eVariationOn (f ∘ φ) (t ∩ Icc x y) = eVariationOn f (φ '' t ∩ Icc (φ x) (φ y)) 


Original valid proof:
:= by
  rcases le_total x y with (h | h)
  · convert comp_eq_of_monotoneOn f φ (hφ.mono Set.inter_subset_left)
    apply le_antisymm
    · rintro _ ⟨⟨u, us, rfl⟩, vφx, vφy⟩
      rcases le_total x u with (xu | ux)
      · rcases le_total u y with (uy | yu)
        · exact ⟨u, ⟨us, ⟨xu, uy⟩⟩, rfl⟩
        · rw [le_antisymm vφy (hφ hy us yu)]
          exact ⟨y, ⟨hy, ⟨h, le_rfl⟩⟩, rfl⟩
      · rw [← le_antisymm vφx (hφ us hx ux)]
        exact ⟨x, ⟨hx, ⟨le_rfl, h⟩⟩, rfl⟩
    · rintro _ ⟨u, ⟨⟨hu, xu, uy⟩, rfl⟩⟩
      exact ⟨⟨u, hu, rfl⟩, ⟨hφ hx hu xu, hφ hu hy uy⟩⟩
  · rw [eVariationOn.subsingleton, eVariationOn.subsingleton]
    exacts [(Set.subsingleton_Icc_of_ge (hφ hy hx h)).anti Set.inter_subset_right,
      (Set.subsingleton_Icc_of_ge h).anti Set.inter_subset_right]


Verifying proof (Commit 1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493):
∧
      eVariationOn (f ∘ φ) (t ∩ Icc x y) = eVariationOn f (φ '' (t ∩ Icc x y)) := by
  rcases le_total x y with (h | h)
  · have hx' : φ x ∈ φ '' t ∩ Icc (φ x) (φ y) :=
      ⟨mem_image_of_mem _ hx, ⟨h, le_rfl⟩⟩
    have hy' : φ y ∈ φ '' t ∩ Icc (φ x) (φ y) :=
      ⟨mem_image_of_mem _ hy, ⟨le_rfl, h⟩⟩
    have hφ' : ∀ i ∈ Icc x y, ∀ j ∈ Icc x y, i ≤ j → φ i ≤ φ j := fun i hi j hj hij =>
      hφ hi.1 hj.1 hij
    have hφ'' : ∀ i ∈ Icc x y, ∀ j ∈ Icc x y, i ≤ j →
        edist (f (φ i)) (f (φ j)) = edist (f (φ i)) (f (φ j)) := fun i hi j hj hij => rfl
    simp_rw [eVariationOn.eq_sum hφ', ← image_inter_Icc h,
      eVariationOn.eq_sum_of_monotoneOn_Icc (f ∘ φ) hφ' hφ'', inter_eq_self_of_subset_left
      (image_subset_iff.2 inter_subset_left),
      image_inter_Icc h, eVariationOn.eq_sum_of_monotoneOn_Icc f hφ' hφ'',
      inter_eq_self_of_subset_left (image_subset_iff.2 inter_subset_left), image_image]
    exact ⟨rfl, rfl⟩
  · rw [inter_comm t, inter_comm t, image_inter_Icc h, image_inter_Icc h]
    simp_rw [eVariationOn.eq_sum, ← image_inter_Icc h, inter_comm t, inter_eq_self_of_subset_left
      (image_subset_iff.2 inter_subset_left), eVariationOn.eq_sum_of_monotoneOn_Icc f
      (fun i hi j hj hij => hφ hi.1 hj.1 hij) hφ'', inter_eq_self_of_subset_left
      (image_subset_iff.2 inter_subset_left), eVariationOn.eq_sum_of_monotoneOn_Icc (f ∘ φ)
      (fun i hi j hj hij => hφ hi.1 hj.1 hij) hφ'', inter_eq_self_of_subset_left
      (image_subset_iff.2 inter_subset_left), image_image]
    exact ⟨rfl, rfl⟩

Repaired Proof:
theorem comp_inter_Icc_eq_of_monotoneOn (f : α → E) {t : Set β} (φ : β → α) (hφ : MonotoneOn φ t)
    {x y : β} (hx : x ∈ t) (hy : y ∈ t) :
    eVariationOn (f ∘ φ) (t ∩ Icc x y) = eVariationOn f (φ '' t ∩ Icc (φ x) (φ y)) ∧
      eVariationOn (f ∘ φ) (t ∩ Icc x y) = eVariationOn f (φ '' (t ∩ Icc x y)) := by
  rcases le_total x y with (h | h)
  · have hx' : φ x ∈ φ '' t ∩ Icc (φ x) (φ y) :=
      ⟨mem_image_of_mem _ hx, ⟨h, le_rfl⟩⟩
    have hy' : φ y ∈ φ '' t ∩ Icc (φ x) (φ y) :=
      ⟨mem_image_of_mem _ hy, ⟨le_rfl, h⟩⟩
    have hφ' : ∀ i ∈ Icc x y, ∀ j ∈ Icc x y, i ≤ j → φ i ≤ φ j := fun i hi j hj hij =>
      hφ hi.1 hj.1 hij
    have hφ'' : ∀ i ∈ Icc x y, ∀ j ∈ Icc x y, i ≤ j →
        edist (f (φ i)) (f (φ j)) = edist (f (φ i)) (f (φ j)) := fun i hi j hj hij => rfl
    simp_rw [eVariationOn.eq_sum hφ', ← image_inter_Icc h,
      eVariationOn.eq_sum_of_monotoneOn_Icc (f ∘ φ) hφ' hφ'', inter_eq_self_of_subset_left
      (image_subset_iff.2 inter_subset_left),
      image_inter_Icc h, eVariationOn.eq_sum_of_monotoneOn_Icc f hφ' hφ'',
      inter_eq_self_of_subset_left (image_subset_iff.2 inter_subset_left), image_image]
    exact ⟨rfl, rfl⟩
  · rw [inter_comm t, inter_comm t, image_inter_Icc h, image_inter_Icc h]
    simp_rw [eVariationOn.eq_sum, ← image_inter_Icc h, inter_comm t, inter_eq_self_of_subset_left
      (image_subset_iff.2 inter_subset_left), eVariationOn.eq_sum_of_monotoneOn_Icc f
      (fun i hi j hj hij => hφ hi.1 hj.1 hij) hφ'', inter_eq_self_of_subset_left
      (image_subset_iff.2 inter_subset_left), eVariationOn.eq_sum_of_monotoneOn_Icc (f ∘ φ)
      (fun i hi j hj hij => hφ hi.1 hj.1 hij) hφ'', inter_eq_self_of_subset_left
      (image_subset_iff.2 inter_subset_left), image_image]
    exact ⟨rfl, rfl⟩

Repaired Proof:
theorem comp_inter_Icc_eq_of_monotoneOn (f : α → E) {t : Set β} (φ : β → α) (hφ : MonotoneOn φ t)
    {x y : β} (hx : x ∈ t) (hy : y ∈ t) :
    eVariationOn (f ∘ φ) (t ∩ Icc x y) = eVariationOn f (φ '' t ∩ Icc (φ x) (φ y)) ∧
      eVariationOn (f ∘ φ) (t ∩ Icc x y) = eVariationOn f (φ '' (t ∩ Icc x y)) := by
  rcases le_total x y with (h | h)
  · have hx' : φ x ∈ φ '' t ∩ Icc (φ x) (φ y) :=
      ⟨mem_image_of_mem _ hx, ⟨h, le_rfl⟩⟩
    have hy' : φ y ∈ φ '' t ∩ Icc (φ x) (φ y) :=
      ⟨mem_image_of_mem _ hy, ⟨le_rfl, h⟩⟩
    have hφ' : ∀ i ∈ Icc x y, ∀ j ∈ Icc x y, i ≤ j → φ i ≤ φ j := fun i hi j hj hij =>
      hφ hi.1 hj.1 hij
    have hφ'' : ∀ i ∈ Icc x y, ∀ j ∈ Icc x y, i ≤ j →
        edist (f (φ i)) (f (φ j)) = edist (f (φ i)) (f (φ j)) := fun i hi j hj hij => rfl
    simp_rw [eVariationOn.eq_sum hφ', ← image_inter_Icc h,
      eVariationOn.eq_sum_of_monotoneOn_Icc (f ∘ φ) hφ' hφ'', inter_eq_self_of_subset_left
      (image_subset_iff.

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean - 2024-09-09 01:36:10.424131.
---21/200---
For theorem BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le in Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}
    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)
    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}
    (hc : I.distortion ≤ c) :
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
          BoxAdditiveMap.volume)‖ ≤
      2 * ε * c * ∏ j, (I.upper j - I.lower j) 


Original valid proof:
:= by
  set e : ℝ → (Fin n → ℝ) → (Fin (n + 1) → ℝ) := i.insertNth (α := fun _ ↦ ℝ)
  have Hl : I.lower i ∈ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ∈ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ∀ x ∈ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ⊥ (f ∘ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ∀ y ∈ Box.Icc (I.face i),
      ‖f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‖ ≤
        2 * ε * diam (Box.Icc I) := fun y hy ↦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * ‖y - x‖ at hε
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‖g (e (I.lower i) y) - g (e (I.upper i) y)‖ ≤ _
    · congr 1
      have := Fin.insertNth_sub_same (α := fun _ ↦ ℝ) i (I.upper i) (I.lower i) y
      simp only [← this, f'.map_sub]; abel
    · have : ∀ z ∈ Icc (I.lower i) (I.upper i), e z y ∈ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hε : ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * diam (Box.Icc I) := by
        intro y hy
        refine (hε y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [← dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hε _ (this _ Hl)) (hε _ (this _ Hu))
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
            (integral (I.face i) ⊥ (f ∘ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ⊥ (f ∘ e (I.lower i)) BoxAdditiveMap.volume)‖ =
        ‖integral.{0, u, u} (I.face i) ⊥
            (fun x : Fin n → ℝ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‖ := by
      rw [← integral_sub (Hi _ Hu) (Hi _ Hl), ← Box.volume_face_mul i, mul_smul, ← Box.volume_apply,
        ← BoxAdditiveMap.toSMul_apply, ← integral_const, ← BoxAdditiveMap.volume,
        ← integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(· ∘ ·), Pi.sub_def, ← f'.map_smul, ← Pi.single_smul', smul_eq_mul, mul_one]
    _ ≤ (volume (I.face i : Set (Fin n → ℝ))).toReal * (2 * ε * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * ε)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
      rw [← Measure.toBoxAdditive_apply, Box.volume_apply, ← I.volume_face_mul i]
      ac_rfl


Verifying proof (Commit 40b64f797572a7615ba4553a28d3d6ee5049aa3b):
• ‖(I.face i).volume‖ := by
  have h0 : 0 < ∏ j, (I.upper j - I.lower j) := by
    refine' prod_pos fun i _ => _
    exact sub_pos.2 (hxI.1 i)
  have hI : (Box.Icc (I.face i)).Nonempty := (Box.Icc_eq_pi _ _).symm ▸ Pi. nonempty_pi fun _ =>
    Set. nonempty_Icc.2 (I.lower_le_upper _)
  have hface : IntegrableOn f (Box.Icc (I.face i)) :=
    (hfc.mono I.face_subset_Icc).integrableOn_compact isCompact_Icc
  have H : ∀ y ∈ (Box.Icc (I.face i)), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖ := by
    intro y hy
    simpa only [← dist_eq_norm, dist_comm] using hε y (I.face_Icc_subset i hy)
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
        (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
            BoxAdditiveMap.volume -
          integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
            BoxAdditiveMap.volume)‖ =
        ‖(∏ j, (I.upper j - I.lower j)) •
            ((integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
                  BoxAdditiveMap.volume -
                integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
                  BoxAdditiveMap.volume) -
              ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥)‖ := by
      simp only [← integral_sub hface (integrableOn_const.2 (Or.inr measure_Icc_lt_top)),
        integral_indicator (Box.coe_ae_measurable _ _), Box.coe_eq_fun, Box.coe_Icc,
        Function.comp_def, smul_sub, norm_sub_rev]
    _ ≤ ‖(∏ j, (I.upper j - I.lower j)) •
            ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥ -
          (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
              BoxAdditiveMap.volume -
            integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
              BoxAdditiveMap.volume)‖ := by
      refine' norm_smul_le _ _
    _ ≤ ‖(∏ j, (I.upper j - I.lower j)) •
            ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥‖ +
          ‖(integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
                BoxAdditiveMap.volume -
              integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
                BoxAdditiveMap.volume)‖ := norm_sub_le _ _
    _ ≤ ‖(∏ j, (I.upper j - I.lower j)) •
            ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥‖ +
          2 * ε * ∏ j, (I.upper j - I.lower j) := by
      gcongr
      exact norm_volume_sub_integral_face_upper_sub_lower_le hface hI H
    _ ≤ 2 * ε * c * ∏ j, (I.upper j - I.lower j) * ‖(I.face i).volume‖ := by
      have : ‖((Box.Icc (I.face i)).indicator fun x => f' (x - x)).integral ⊥‖ ≤
          ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
            ‖(I.face i).volume‖ := by
        refine' (norm_setIntegral_le_of_norm_le_const' measurableSet_Icc _ _).trans _
        · exact (continuous_const.sub continuous_id').continuousOn
        · rintro x ⟨y, hy, rfl⟩
          simp only [Pi.sub_apply, ContinuousLinearMap.zero_apply, norm_zero, Pi.single_apply,
            Box.coe_Icc, Box.coe_face_Icc, Set.indicator_of_not_mem, not_false_iff,
            BoxAdditiveMap.volume_apply, ENNReal.toReal_coe, Box.volume_apply,
            mul_one, NNReal.volume_Icc, Real.volume_Icc, ofReal_coe_nnreal]
          simp only [norm_eq_abs, abs_prod, abs_of_nonneg fun j => sub_nonneg.2 (I.lower_le_upper j),
            Finset.prod_const]
          rfl
      calc
        ‖(∏ j, (I.upper j - I.lower j)) •
              ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥‖ ≤
          ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
              ‖(I.face i).volume‖ *
            ‖(∏ j, (I.upper j - I.lower j))‖ := by
          gcongr
          simp only [norm_smul, norm_eq_abs, abs_prod, abs_of_nonneg fun j => sub_nonneg.2 (I.lower_le_upper j),
            Finset.prod_const]
        _ = ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
              ‖(I.face i).volume‖ *
            ∏ j, (I.upper j - I.lower j) := by
          simp only [norm_eq_abs, abs_prod, abs_of_nonneg fun j => sub_nonneg.2 (I.lower_le_upper j),
            Finset.prod_const]
        _ ≤ ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
              ‖(I.face i).volume‖ *
            c * ∏ j, (I.upper j - I.lower j) := by
          gcongr
          exact hc.le
        _ = ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
            ‖(I.face i).volume‖ *
          c * ∏ j, (I.upper j - I.lower j) * 1 := by
          simp only [mul_one]
        _ ≤ 2 * ε * c * ∏ j, (I.upper j - I.lower j) * ‖(I.face i).volume‖ := by
          gcongr
          exact norm_volume_sub_integral_face_upper_sub_lower_le_of_const hface hI (fun _ => 1)
            (fun _ => rfl)

Repaired Proof:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → �

Attempt failure.

---22/200---
For theorem BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le in Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}
    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)
    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}
    (hc : I.distortion ≤ c) :
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
          BoxAdditiveMap.volume)‖ ≤
      2 * ε * c * ∏ j, (I.upper j - I.lower j) 


Original valid proof:
:= by
  set e : ℝ → (Fin n → ℝ) → (Fin (n + 1) → ℝ) := i.insertNth (α := fun _ ↦ ℝ)
  have Hl : I.lower i ∈ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ∈ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ∀ x ∈ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ⊥ (f ∘ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ∀ y ∈ Box.Icc (I.face i),
      ‖f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‖ ≤
        2 * ε * diam (Box.Icc I) := fun y hy ↦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * ‖y - x‖ at hε
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‖g (e (I.lower i) y) - g (e (I.upper i) y)‖ ≤ _
    · congr 1
      have := Fin.insertNth_sub_same (α := fun _ ↦ ℝ) i (I.upper i) (I.lower i) y
      simp only [← this, f'.map_sub]; abel
    · have : ∀ z ∈ Icc (I.lower i) (I.upper i), e z y ∈ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hε : ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * diam (Box.Icc I) := by
        intro y hy
        refine (hε y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [← dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hε _ (this _ Hl)) (hε _ (this _ Hu))
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
            (integral (I.face i) ⊥ (f ∘ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ⊥ (f ∘ e (I.lower i)) BoxAdditiveMap.volume)‖ =
        ‖integral.{0, u, u} (I.face i) ⊥
            (fun x : Fin n → ℝ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‖ := by
      rw [← integral_sub (Hi _ Hu) (Hi _ Hl), ← Box.volume_face_mul i, mul_smul, ← Box.volume_apply,
        ← BoxAdditiveMap.toSMul_apply, ← integral_const, ← BoxAdditiveMap.volume,
        ← integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(· ∘ ·), Pi.sub_def, ← f'.map_smul, ← Pi.single_smul', smul_eq_mul, mul_one]
    _ ≤ (volume (I.face i : Set (Fin n → ℝ))).toReal * (2 * ε * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * ε)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
      rw [← Measure.toBoxAdditive_apply, Box.volume_apply, ← I.volume_face_mul i]
      ac_rfl


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
• ‖(I.face i).volume‖ := by
  have h0 : 0 < ∏ j, (I.upper j - I.lower j) := by
    refine' prod_pos fun i _ => _
    exact sub_pos.2 (hxI.1 i)
  have hI : (Box.Icc (I.face i)).Nonempty := (Box.Icc_eq_pi _ _).symm ▸ Pi. nonempty_pi fun _ =>
    Set. nonempty_Icc.2 (I.lower_le_upper _)
  have hface : IntegrableOn f (Box.Icc (I.face i)) :=
    (hfc.mono I.face_subset_Icc).integrableOn_compact isCompact_Icc
  have H : ∀ y ∈ (Box.Icc (I.face i)), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖ := by
    intro y hy
    simpa only [← dist_eq_norm, dist_comm] using hε y (I.face_Icc_subset i hy)
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
        (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
            BoxAdditiveMap.volume -
          integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
            BoxAdditiveMap.volume)‖ =
        ‖(∏ j, (I.upper j - I.lower j)) •
            ((integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
                  BoxAdditiveMap.volume -
                integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
                  BoxAdditiveMap.volume) -
              ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥)‖ := by
      simp only [← integral_sub hface (integrableOn_const.2 (Or.inr measure_Icc_lt_top)),
        integral_indicator (Box.coe_ae_measurable _ _), Box.coe_eq_fun, Box.coe_Icc,
        Function.comp_def, smul_sub, norm_sub_rev]
    _ ≤ ‖(∏ j, (I.upper j - I.lower j)) •
            ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥ -
          (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
              BoxAdditiveMap.volume -
            integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
              BoxAdditiveMap.volume)‖ := by
      refine' norm_smul_le _ _
    _ ≤ ‖(∏ j, (I.upper j - I.lower j)) •
            ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥‖ +
          ‖(integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
                BoxAdditiveMap.volume -
              integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
                BoxAdditiveMap.volume)‖ := norm_sub_le _ _
    _ ≤ ‖(∏ j, (I.upper j - I.lower j)) •
            ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥‖ +
          2 * ε * ∏ j, (I.upper j - I.lower j) := by
      gcongr
      exact norm_volume_sub_integral_face_upper_sub_lower_le hface hI H
    _ ≤ 2 * ε * c * ∏ j, (I.upper j - I.lower j) * ‖(I.face i).volume‖ := by
      have : ‖((Box.Icc (I.face i)).indicator fun x => f' (x - x)).integral ⊥‖ ≤
          ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
            ‖(I.face i).volume‖ := by
        refine' (norm_setIntegral_le_of_norm_le_const' measurableSet_Icc _ _).trans _
        · exact (continuous_const.sub continuous_id').continuousOn
        · rintro x ⟨y, hy, rfl⟩
          simp only [Pi.sub_apply, ContinuousLinearMap.zero_apply, norm_zero, Pi.single_apply,
            Box.coe_Icc, Box.coe_face_Icc, Set.indicator_of_not_mem, not_false_iff,
            BoxAdditiveMap.volume_apply, ENNReal.toReal_coe, Box.volume_apply,
            mul_one, NNReal.volume_Icc, Real.volume_Icc, ofReal_coe_nnreal]
          simp only [norm_eq_abs, abs_prod, abs_of_nonneg fun j => sub_nonneg.2 (I.lower_le_upper j),
            Finset.prod_const]
          rfl
      calc
        ‖(∏ j, (I.upper j - I.lower j)) •
              ((Box.Icc (I.face i)).indicator (fun x => f' (x - x))).integral ⊥‖ ≤
          ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
              ‖(I.face i).volume‖ *
            ‖(∏ j, (I.upper j - I.lower j))‖ := by
          gcongr
          simp only [norm_smul, norm_eq_abs, abs_prod, abs_of_nonneg fun j => sub_nonneg.2 (I.lower_le_upper j),
            Finset.prod_const]
        _ = ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
              ‖(I.face i).volume‖ *
            ∏ j, (I.upper j - I.lower j) := by
          simp only [norm_eq_abs, abs_prod, abs_of_nonneg fun j => sub_nonneg.2 (I.lower_le_upper j),
            Finset.prod_const]
        _ ≤ ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
              ‖(I.face i).volume‖ *
            c * ∏ j, (I.upper j - I.lower j) := by
          gcongr
          exact hc.le
        _ = ‖((I.face i).indicator fun _ => (1 : ℝ≥0 →L[ℝ] E) 1).integral ⊥‖ *
            ‖(I.face i).volume‖ *
          c * ∏ j, (I.upper j - I.lower j) * 1 := by
          simp only [mul_one]
        _ ≤ 2 * ε * c * ∏ j, (I.upper j - I.lower j) * ‖(I.face i).volume‖ := by
          gcongr
          exact norm_volume_sub_integral_face_upper_sub_lower_le_of_const hface hI (fun _ => 1)
            (fun _ => rfl)

Repaired Proof:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → �

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Integrability.lean - 2024-09-09 01:36:32.690464.
---23/200---
For theorem BoxIntegral.HasIntegral.of_aeEq_zero in Mathlib/Analysis/BoxIntegral/Integrability.lean:
theorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (hf : f =ᵐ[μ.restrict I] 0)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul 0 


Original valid proof:
:= by
  refine hasIntegral_iff.2 fun ε ε0 => ?_
  lift ε to ℝ≥0 using ε0.lt.le; rw [gt_iff_lt, NNReal.coe_pos] at ε0
  rcases NNReal.exists_pos_sum_of_countable ε0.ne' ℕ with ⟨δ, δ0, c, hδc, hcε⟩
  haveI := Fact.mk (I.measure_coe_lt_top μ)
  change μ.restrict I {x | f x ≠ 0} = 0 at hf
  set N : (ι → ℝ) → ℕ := fun x => ⌈‖f x‖⌉₊
  have N0 : ∀ {x}, N x = 0 ↔ f x = 0 := by simp [N]
  have : ∀ n, ∃ U, N ⁻¹' {n} ⊆ U ∧ IsOpen U ∧ μ.restrict I U < δ n / n := fun n ↦ by
    refine (N ⁻¹' {n}).exists_isOpen_lt_of_lt _ ?_
    cases' n with n
    · simpa [ENNReal.div_zero (ENNReal.coe_pos.2 (δ0 _)).ne'] using measure_lt_top (μ.restrict I) _
    · refine (measure_mono_null ?_ hf).le.trans_lt ?_
      · exact fun x hxN hxf => n.succ_ne_zero ((Eq.symm hxN).trans <| N0.2 hxf)
      · simp [(δ0 _).ne']
  choose U hNU hUo hμU using this
  have : ∀ x, ∃ r : Ioi (0 : ℝ), closedBall x r ⊆ U (N x) := fun x => by
    obtain ⟨r, hr₀, hr⟩ := nhds_basis_closedBall.mem_iff.1 ((hUo _).mem_nhds (hNU _ rfl))
    exact ⟨⟨r, hr₀⟩, hr⟩
  choose r hrU using this
  refine ⟨fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c π hπ _ => ?_⟩
  rw [dist_eq_norm, sub_zero, ← integralSum_fiberwise fun J => N (π.tag J)]
  refine le_trans ?_ (NNReal.coe_lt_coe.2 hcε).le
  refine (norm_sum_le_of_le _ ?_).trans
    (sum_le_hasSum _ (fun n _ => (δ n).2) (NNReal.hasSum_coe.2 hδc))
  rintro n -
  dsimp [integralSum]
  have : ∀ J ∈ π.filter fun J => N (π.tag J) = n,
      ‖(μ ↑J).toReal • f (π.tag J)‖ ≤ (μ J).toReal * n := fun J hJ ↦ by
    rw [TaggedPrepartition.mem_filter] at hJ
    rw [norm_smul, Real.norm_eq_abs, abs_of_nonneg ENNReal.toReal_nonneg]
    gcongr
    exact hJ.2 ▸ Nat.le_ceil _
  refine (norm_sum_le_of_le _ this).trans ?_; clear this
  rw [← sum_mul, ← Prepartition.measure_iUnion_toReal]
  let m := μ (π.filter fun J => N (π.tag J) = n).iUnion
  show m.toReal * ↑n ≤ ↑(δ n)
  have : m < δ n / n := by
    simp only [Measure.restrict_apply (hUo _).measurableSet] at hμU
    refine (measure_mono ?_).trans_lt (hμU _)
    simp only [Set.subset_def, TaggedPrepartition.mem_iUnion, TaggedPrepartition.mem_filter]
    rintro x ⟨J, ⟨hJ, rfl⟩, hx⟩
    exact ⟨hrU _ (hπ.1 _ hJ (Box.coe_subset_Icc hx)), π.le_of_mem' J hJ hx⟩
  clear_value m
  lift m to ℝ≥0 using ne_top_of_lt this
  rw [ENNReal.coe_toReal, ← NNReal.coe_natCast, ← NNReal.coe_mul, NNReal.coe_le_coe, ←
    ENNReal.coe_le_coe, ENNReal.coe_mul, ENNReal.coe_natCast, mul_comm]
  exact (mul_le_mul_left' this.le _).trans ENNReal.mul_div_le


Verifying proof (Commit 1b93076c86e6da5d0a25d3465e84d13bd9ccfcc8):
∧
      Integrable.{u, v, v} I l f μ.toBoxAdditive.toSMul := by
  have hf' : f =ᵐ[cospan I.lower I.upper] 0 := ae_cospan_iff_ae_restrict.2 hf
  refine ⟨hasIntegral_of_ae_eq_zero' hl hf', integrable_iff.2 ⟨?_, ?_⟩⟩
  · exact aestronglyMeasurable_of_ae_eq_zero hf'
  · exact hasFiniteIntegral_of_ae_eq_zero' hl hf'

Repaired Proof:
theorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (hf : f =ᵐ[μ.restrict I] 0)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul 0 ∧
      Integrable.{u, v, v} I l f μ.toBoxAdditive.toSMul := by
  have hf' : f =ᵐ[cospan I.lower I.upper] 0 := ae_cospan_iff_ae_restrict.2 hf
  refine ⟨hasIntegral_of_ae_eq_zero hl hf', integrable_iff.2 ⟨?_, ?_⟩⟩
  · exact aestronglyMeasurable_of_ae_eq_zero hf'
  · exact hasFiniteIntegral_of_ae_eq_zero hl hf'

Repaired Proof:
theorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (hf : f =ᵐ[μ.restrict I] 0)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul 0 ∧
      Integrable.{u, v, v} I l f μ.toBoxAdditive.toSMul := by
  have hf' : f =ᵐ[cospan I.lower I.upper] 0 := ae_cospan_iff_ae_restrict.2 hf
  refine ⟨hasIntegral_of_ae_eq_zero hl hf', integrable_iff.2 ⟨?_, ?_⟩⟩
  · exact aestronglyMeasurable_of_ae_eq_zero hf'
  · exact hasFiniteIntegral_of_ae_eq_zero hl hf'

Repaired Proof:
theorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (hf : f =ᵐ[μ.restrict I] 0)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul 0 ∧
      Integrable.{u, v, v} I l f μ.toBoxAdditive.toSMul := by
  have hf' : f =ᵐ[cospan I.lower I.upper] 0 := ae_cospan_iff_ae_restrict.2 hf
  refine ⟨hasIntegral_of_ae_eq_zero hl hf', integrable_iff.2 ⟨?_, ?_⟩⟩
  · exact aestronglyMeasurable_of_ae_eq_zero hf'
  · exact hasFiniteIntegral_of_ae_eq_zero hl hf'

Repaired Proof:
theorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (hf : f =ᵐ[μ.restrict I] 0)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul 0 ∧
      Integrable.{u, v, v} I l f μ.toBoxAdditive.toSMul := by
  have hf' : f =ᵐ[cospan I.lower I.upper] 0 := ae_cospan_iff_ae_restrict.2 hf
  refine ⟨hasIntegral_of_ae_eq_zero hl hf', integrable_iff.2 ⟨?_, ?_⟩⟩
  · exact aestronglyMeasurable_of_ae_eq_zero hf'
  · exact hasFiniteIntegral_of_ae_eq_zero hl hf'

Repaired Proof:
theorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (hf : f =ᵐ[μ.restrict I] 0)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul 0 ∧
      Integrable.{u, v, v} I l f μ.toBoxAdditive.toSMul := by
  have hf' : f =ᵐ[cospan I.lower I.upper] 0 := ae_cospan_iff_ae_restrict.2 hf
  refine ⟨hasIntegral_of_ae_eq_zero hl hf', integrable_iff.2 ⟨?_, ?_⟩⟩
  · exact aestronglyMeasurable_of_ae_eq_zero hf'
  · exact hasFiniteIntegral_of_ae_eq_zero hl hf'

Repaired Proof:
theorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (hf : f =ᵐ[μ.restrict I] 0)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul 0 ∧
      Integrable.{u, v, v} I l f μ.toBoxAdditive.toSMul := by
  have hf' : f =ᵐ[cospan I.lower I.upper] 0 := ae_cospan_iff_ae_restrict.2 hf
  refine ⟨hasIntegral_of_ae_eq_zero hl hf', integrable_iff.2 ⟨?_, ?_⟩⟩
  · exact aestronglyMeasurable_of_ae_eq_zero hf'
  · exact hasFiniteIntegral_of_ae_eq_zero hl hf'

Repaired Proof:
theorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (hf : f =ᵐ[μ.restrict I] 0)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul 0 ∧
      Integrable.{u, v, v} I l f μ.toBoxAdditive.toSMul := by
  have hf' : f =ᵐ[cospan I.lower I.upper] 0 := ae_cospan_iff_ae_restrict.2 hf
  refine ⟨hasIntegral_of_ae_eq_zero hl hf', integrable_iff.2 ⟨?_, ?_⟩⟩
  · exact aestronglyMeasurable_of_ae_eq_zero hf'
  · exact hasFiniteIntegral_of_ae_eq_zero hl hf'

Repaired Proof:
theorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (hf : f =ᵐ[μ.restrict I] 0)


Attempt failure.

Working on Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean - 2024-09-09 01:36:48.543476.
---24/200---
For theorem hasFDerivAt_of_tendstoUniformlyOnFilter in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):

  | _ =>
    have hfg' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f' n y) l (𝓝 (g' y))) :=
      hf'.tendsto_uniformlyOnFilter_nhds
    have hfg'' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y - f n x) l (𝓝 0)) :=
      mem_of_superset hfg (fun _ h => h.self_sub)
    have hfg''' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f' n (y - x)) l (𝓝 0)) :=
      mem_of_superset hfg' (fun _ h => h.sub_const _)
    have hfg'''' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y - f n x - f' n (y - x)) l (𝓝 0)) :=
      mem_of_superset (hf.prod_mk hfg''') (fun _ h => h.sub_sub)
    have hfg''''' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y - f n x - f' n (y - x) - g' (y - x))
        l (𝓝 0)) :=
      mem_of_superset hfg'''' (fun _ h => h.sub_const _)
    have hfg'''''' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => ‖f n y - f n x - f' n (y - x) - g' (y - x)‖)
        l (𝓝 0)) :=
      mem_of_superset hfg''''' (fun _ h => h.norm)
    have hfg''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x - f' n (y - x) - g' (y - x)‖ < ‖y - x‖) :=
      hfg''''''.and (eventually_nhds_iff.2 ⟨_, self_mem_nhdsWithin, fun _ h => h⟩)
    have hfg'''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x - f' n (y - x)‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''' (fun _ h => h.mono fun _ h' => h'.trans_le (by norm_num))
    have hfg''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f' n (y - x) - g' (y - x)‖ < ‖y - x‖) :=
      mem_of_superset hfg'''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f' n (y - x)‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < ‖y - x‖ + ‖y - x‖) :=
      mem_of_superset hfg''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''''''''''''' (fun _ h => h.mono fun _ h' n hn =>

Attempt failure.

---25/200---
For theorem hasFDerivAt_of_tendstoUniformlyOn in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):

  | _ =>
    have hfg' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f' n y) l (𝓝 (g' y))) :=
      hf'.tendsto_uniformlyOnFilter_nhds
    have hfg'' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y - f n x) l (𝓝 0)) :=
      mem_of_superset hfg (fun _ h => h.self_sub)
    have hfg''' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f' n (y - x)) l (𝓝 0)) :=
      mem_of_superset hfg' (fun _ h => h.sub_const _)
    have hfg'''' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y - f n x - f' n (y - x)) l (𝓝 0)) :=
      mem_of_superset (hf.prod_mk hfg''') (fun _ h => h.sub_sub)
    have hfg''''' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y - f n x - f' n (y - x) - g' (y - x))
        l (𝓝 0)) :=
      mem_of_superset hfg'''' (fun _ h => h.sub_const _)
    have hfg'''''' : ∀ᶠ y in 𝓝 x, Tendsto (fun n => ‖f n y - f n x - f' n (y - x) - g' (y - x)‖)
        l (𝓝 0)) :=
      mem_of_superset hfg''''' (fun _ h => h.norm)
    have hfg''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x - f' n (y - x) - g' (y - x)‖ < ‖y - x‖) :=
      hfg''''''.and (eventually_nhds_iff.2 ⟨_, self_mem_nhdsWithin, fun _ h => h⟩)
    have hfg'''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x - f' n (y - x)‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''' (fun _ h => h.mono fun _ h' => h'.trans_le (by norm_num))
    have hfg''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f' n (y - x) - g' (y - x)‖ < ‖y - x‖) :=
      mem_of_superset hfg'''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f' n (y - x)‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < ‖y - x‖ + ‖y - x‖) :=
      mem_of_superset hfg''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg'''''''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg''''''''''''''''''''' (fun _ h => h.mono fun _ h' n hn => h' n hn)
    have hfg''''''''''''''''''''''' : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι in l, ‖f n y - f n x‖ < 2 * ‖y - x‖) :=
      mem_of_superset hfg'''''''''''''''''''''' (fun _ h => h.mono fun _ h' n hn =>

Attempt failure.

Working on Mathlib/Analysis/Complex/CauchyIntegral.lean - 2024-09-09 01:37:11.374113.
---26/200---
For theorem Complex.integral_boundary_rect_of_hasFDerivAt_real_off_countable in Mathlib/Analysis/Complex/CauchyIntegral.lean:
theorem integral_boundary_rect_of_hasFDerivAt_real_off_countable (f : ℂ → E) (f' : ℂ → ℂ →L[ℝ] E)
    (z w : ℂ) (s : Set ℂ) (hs : s.Countable)
    (Hc : ContinuousOn f ([[z.re, w.re]] ×ℂ [[z.im, w.im]]))
    (Hd : ∀ x ∈ Ioo (min z.re w.re) (max z.re w.re) ×ℂ Ioo (min z.im w.im) (max z.im w.im) \ s,
      HasFDerivAt f (f' x) x)
    (Hi : IntegrableOn (fun z => I • f' z 1 - f' z I) ([[z.re, w.re]] ×ℂ [[z.im, w.im]])) :
    (∫ x : ℝ in z.re..w.re, f (x + z.im * I)) - (∫ x : ℝ in z.re..w.re, f (x + w.im * I)) +
      I • (∫ y : ℝ in z.im..w.im, f (re w + y * I)) -
      I • ∫ y : ℝ in z.im..w.im, f (re z + y * I) =
      ∫ x : ℝ in z.re..w.re, ∫ y : ℝ in z.im..w.im, I • f' (x + y * I) 1 - f' (x + y * I) I 


Original valid proof:
:= by
  set e : (ℝ × ℝ) ≃L[ℝ] ℂ := equivRealProdCLM.symm
  have he : ∀ x y : ℝ, ↑x + ↑y * I = e (x, y) := fun x y => (mk_eq_add_mul_I x y).symm
  have he₁ : e (1, 0) = 1 := rfl; have he₂ : e (0, 1) = I := rfl
  simp only [he] at *
  set F : ℝ × ℝ → E := f ∘ e
  set F' : ℝ × ℝ → ℝ × ℝ →L[ℝ] E := fun p => (f' (e p)).comp (e : ℝ × ℝ →L[ℝ] ℂ)
  have hF' : ∀ p : ℝ × ℝ, (-(I • F' p)) (1, 0) + F' p (0, 1) = -(I • f' (e p) 1 - f' (e p) I) := by
    rintro ⟨x, y⟩
    simp only [F', ContinuousLinearMap.neg_apply, ContinuousLinearMap.smul_apply,
      ContinuousLinearMap.comp_apply, ContinuousLinearEquiv.coe_coe, he₁, he₂, neg_add_eq_sub,
      neg_sub]
  set R : Set (ℝ × ℝ) := [[z.re, w.re]] ×ˢ [[w.im, z.im]]
  set t : Set (ℝ × ℝ) := e ⁻¹' s
  rw [uIcc_comm z.im] at Hc Hi; rw [min_comm z.im, max_comm z.im] at Hd
  have hR : e ⁻¹' ([[z.re, w.re]] ×ℂ [[w.im, z.im]]) = R := rfl
  have htc : ContinuousOn F R := Hc.comp e.continuousOn hR.ge
  have htd :
    ∀ p ∈ Ioo (min z.re w.re) (max z.re w.re) ×ˢ Ioo (min w.im z.im) (max w.im z.im) \ t,
      HasFDerivAt F (F' p) p :=
    fun p hp => (Hd (e p) hp).comp p e.hasFDerivAt
  simp_rw [← intervalIntegral.integral_smul, intervalIntegral.integral_symm w.im z.im, ←
    intervalIntegral.integral_neg, ← hF']
  refine (integral2_divergence_prod_of_hasFDerivWithinAt_off_countable (fun p => -(I • F p)) F
    (fun p => -(I • F' p)) F' z.re w.im w.re z.im t (hs.preimage e.injective)
    (htc.const_smul _).neg htc (fun p hp => ((htd p hp).const_smul I).neg) htd ?_).symm
  rw [← (volume_preserving_equiv_real_prod.symm _).integrableOn_comp_preimage
    (MeasurableEquiv.measurableEmbedding _)] at Hi
  simpa only [hF'] using Hi.neg


Verifying proof (Commit 15fc142c24a81bf41226645e01783f71b75b9d92):
• I := by
  simp only [add_smul, one_smul, sub_smul, I_sq, sub_neg_eq_add, ← smul_smul]
  rw [← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (im w - im z) _)
      (Hi.comp_sub_left (re w - re z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
      (Hi.comp_sub_left (im w - im z) _),
    ← integral_sub (Hi.comp_sub_left (re w - re z) _)
      (Hi.comp_sub_right (im w - im z) _),
    ← integral_sub (Hi.comp_sub_right (re w - re z) _)
     

Attempt failure.

Working on Mathlib/Analysis/Complex/RealDeriv.lean - 2024-09-09 01:37:32.921179.
---27/200---
For theorem conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj in Mathlib/Analysis/Complex/RealDeriv.lean:
theorem conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (DifferentiableAt ℂ f z ∨ DifferentiableAt ℂ (f ∘ conj) (conj z)) ∧ fderiv ℝ f z ≠ 0 


Original valid proof:
:= by
  rw [conformalAt_iff_isConformalMap_fderiv]
  rw [isConformalMap_iff_is_complex_or_conj_linear]
  apply and_congr_left
  intro h
  have h_diff := h.imp_symm fderiv_zero_of_not_differentiableAt
  apply or_congr
  · rw [differentiableAt_iff_restrictScalars ℝ h_diff]
  rw [← conj_conj z] at h_diff
  rw [differentiableAt_iff_restrictScalars ℝ (h_diff.comp _ conjCLE.differentiableAt)]
  refine exists_congr fun g => rfl.congr ?_
  have : fderiv ℝ conj (conj z) = _ := conjCLE.fderiv
  simp [fderiv.comp _ h_diff conjCLE.differentiableAt, this, conj_conj]


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
∧
        (fderiv ℝ f z).re / (fderiv ℝ f z).im = (fderiv ℝ (f ∘ conj) (conj z)).re / (fderiv ℝ (f ∘ conj) (conj z)).im :=
  conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj

Repaired Proof:
theorem conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (DifferentiableAt ℂ f z ∨ DifferentiableAt ℂ (f ∘ conj) (conj z)) ∧
        fderiv ℝ f z ≠ 0 ∧ (fderiv ℝ f z).re / (fderiv ℝ f z).im = (fderiv ℝ (f ∘ conj) (conj z)).re / (fderiv ℝ (f ∘ conj) (conj z)).im :=
  conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj

Repaired Proof:
theorem conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (DifferentiableAt ℂ f z ∨ DifferentiableAt ℂ (f ∘ conj) (conj z)) ∧
        fderiv ℝ f z ≠ 0 ∧ (fderiv ℝ f z).re / (fderiv ℝ f z).im = (fderiv ℝ (f ∘ conj) (conj z)).re / (fderiv ℝ (f ∘ conj) (conj z)).im :=
  conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj

Attempt failure.

Working on Mathlib/Analysis/Convex/Independent.lean - 2024-09-09 01:37:44.786885.
---28/200---
For theorem convexIndependent_iff_finset in Mathlib/Analysis/Convex/Independent.lean:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s 


Original valid proof:
:= by
  refine ⟨fun hc s x hx => hc s x ?_, fun h s x hx => ?_⟩
  · rwa [Finset.coe_image] at hx
  have hp : Injective p := by
    rintro a b hab
    rw [← mem_singleton]
    refine h {b} a ?_
    rw [hab, image_singleton, coe_singleton, convexHull_singleton]
    exact Set.mem_singleton _
  rw [convexHull_eq_union_convexHull_finite_subsets] at hx
  simp_rw [Set.mem_iUnion] at hx
  obtain ⟨t, ht, hx⟩ := hx
  rw [← hp.mem_set_image]
  refine ht ?_
  suffices x ∈ t.preimage p hp.injOn by rwa [mem_preimage, ← mem_coe] at this
  refine h _ x ?_
  rwa [t.image_preimage p hp.injOn, filter_true_of_mem]
  exact fun y hy => s.image_subset_range p (ht <| mem_coe.2 hy)


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∨ ∃ y ∈ s, p x = p y := by
  refine' ⟨fun hc s x hx => _, fun h => _⟩
  · rw [convexHull_eq_union_convexHull_finite_subsets] at hx
    simpa only [exists_prop, mem_iUnion, mem_image, exists_exists_and_eq_and, mem_setOf_eq]
      using hx
  · refine' fun s x hx => h _ _ _
    · simpa only [exists_prop, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx
    · simpa only [exists_prop, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx

Repaired Proof:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s ∨ ∃ y ∈ s, p x = p y := by
  refine ⟨fun hc s x hx => ?_, fun h => ?_⟩
  · rw [convexHull_eq_union_convexHull_finite_subsets] at hx
    simpa only [exists_prop, mem_iUnion, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx
  · refine fun s x hx => h _ _ ?_
    simpa only [exists_prop, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx

Repaired Proof:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s ∨ ∃ y ∈ s, p x = p y := by
  refine ⟨fun hc s x hx => ?_, fun h => ?_⟩
  · rw [convexHull_eq_union_convexHull_finite_subsets] at hx
    simpa only [exists_prop, mem_iUnion, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx
  · refine fun s x hx => h _ _ ?_
    simpa only [exists_prop, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx

Repaired Proof:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s ∨ ∃ y ∈ s, p x = p y := by
  refine ⟨fun hc s x hx => ?_, fun h => ?_⟩
  · rw [convexHull_eq_union_convexHull_finite_subsets] at hx
    simpa only [exists_prop, mem_iUnion, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx
  · refine fun s x hx => h _ _ ?_
    simpa only [exists_prop, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx

Repaired Proof:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s ∨ ∃ y ∈ s, p x = p y := by
  refine ⟨fun hc s x hx => ?_, fun h => ?_⟩
  · rw [convexHull_eq_union_convexHull_finite_subsets] at hx
    simpa only [exists_prop, mem_iUnion, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx
  · refine fun s x hx => h _ _ ?_
    simpa only [exists_prop, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx

Repaired Proof:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s ∨ ∃ y ∈ s, p x = p y := by
  refine ⟨fun hc s x hx => ?_, fun h => ?_⟩
  · rw [convexHull_eq_union_convexHull_finite_subsets] at hx
    simpa only [exists_prop, mem_iUnion, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx
  · refine fun s x hx => h _ _ ?_
    simpa only [exists_prop, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx

Repaired Proof:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s ∨ ∃ y ∈ s, p x = p y := by
  refine ⟨fun hc s x hx => ?_, fun h => ?_⟩
  · rw [convexHull_eq_union_convexHull_finite_subsets] at hx
    simpa only [exists_prop, mem_iUnion, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx
  · refine fun s x hx => h _ _ ?_
    simpa only [exists_prop, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx

Repaired Proof:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s ∨ ∃ y ∈ s, p x = p y := by
  refine ⟨fun hc s x hx => ?_, fun h => ?_⟩
  · rw [convexHull_eq_union_convexHull_finite_subsets] at hx
    simpa only [exists_prop, mem_iUnion, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx
  · refine fun s x hx => h _ _ ?_
    simpa only [exists_prop, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx

Repaired Proof:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s ∨ ∃ y ∈ s, p x = p y := by
  refine ⟨fun hc s x hx => ?_, fun h => ?_⟩
  · rw [convexHull_eq_union_convexHull_finite_subsets] at hx
    simpa only [exists_prop, mem_iUnion, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx
  · refine fun s x hx => h _ _ ?_
    simpa only [exists_prop, mem_image, exists_exists_and_eq_and, mem_setOf_eq] using hx

Repaired Proof:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (

Attempt failure.

Working on Mathlib/Analysis/Convex/Integral.lean - 2024-09-09 01:37:51.622764.
---29/200---
For theorem ae_eq_const_or_exists_average_ne_compl in Mathlib/Analysis/Convex/Integral.lean:
theorem ae_eq_const_or_exists_average_ne_compl [IsFiniteMeasure μ] (hfi : Integrable f μ) :
    f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨
      ∃ t, MeasurableSet t ∧ μ t ≠ 0 ∧ μ tᶜ ≠ 0 ∧ (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ 


Original valid proof:
:= by
  refine or_iff_not_imp_right.mpr fun H => ?_; push_neg at H
  refine hfi.ae_eq_of_forall_setIntegral_eq _ _ (integrable_const _) fun t ht ht' => ?_; clear ht'
  simp only [const_apply, setIntegral_const]
  by_cases h₀ : μ t = 0
  · rw [restrict_eq_zero.2 h₀, integral_zero_measure, h₀, ENNReal.zero_toReal, zero_smul]
  by_cases h₀' : μ tᶜ = 0
  · rw [← ae_eq_univ] at h₀'
    rw [restrict_congr_set h₀', restrict_univ, measure_congr h₀', measure_smul_average]
  have := average_mem_openSegment_compl_self ht.nullMeasurableSet h₀ h₀' hfi
  rw [← H t ht h₀ h₀', openSegment_same, mem_singleton_iff] at this
  rw [this, measure_smul_setAverage _ (measure_ne_top μ _)]


Verifying proof (Commit 070b09db52c6f063dd905c04b291f74460734aab):
∧
        (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ := by
  by_cases hf0 : ∀ᵐ x ∂μ, f x = 0
  · exact Or.inl (ae_eq_const_of_forall_eq' _ hf0)
  rw [← not_forall, ← ae_iff] at hf0
  refine' Or.inr ⟨{ x | f x ≠ 0 }, _, _, _, _⟩
  · exact measurableSet_of_mem_ae_ne_const hf0
  · exact (measure_ne_zero_iff_nonempty_of_ae_ne_zero hf0).2 fun h ↦ hf0 h rfl
  · exact (measure_ne_zero_iff_nonempty_of_ae_ne_zero hf0).2 fun h ↦ hf0 h rfl
  · simp_rw [average_eq, set_average_eq]
    rw [← integrableOn_univ, ← integrableOn_compl_univ, ← ae_ne_const_iff_average_ne_compl hfi]
    exact ae_ne_const_of_ae_ne_zero hf0

Repaired Proof:
theorem ae_eq_const_or_exists_average_ne_compl [IsFiniteMeasure μ] (hfi : Integrable f μ) :
    f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨
      ∃ t, MeasurableSet t ∧ μ t ≠ 0 ∧ μ tᶜ ≠ 0 ∧ (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ ∧
        (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ := by
  by_cases hf0 : ∀ᵐ x ∂μ, f x = 0
  · exact Or.inl (ae_eq_const_of_forall_eq' _ hf0)
  rw [← not_forall, ← ae_iff] at hf0
  refine Or.inr ⟨{ x | f x ≠ 0 }, ?_, ?_, ?_, ?_⟩
  · exact measurableSet_of_mem_ae_ne_const hf0
  · exact (measure_ne_zero_iff_nonempty_of_ae_ne_zero hf0).2 fun h ↦ hf0 h rfl
  · exact (measure_ne_zero_iff_nonempty_of_ae_ne_zero hf0).2 fun h ↦ hf0 h rfl
  · simp_rw [average_eq, set_average_eq]
    rw [← integrableOn_univ, ← integrableOn_compl_univ, ← ae_ne_const_iff_average_ne_compl hfi]
    exact ae_ne_const_of_ae_ne_zero hf0

Repaired Proof:
theorem ae_eq_const_or_exists_average_ne_compl [IsFiniteMeasure μ] (hfi : Integrable f μ) :
    f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨
      ∃ t, MeasurableSet t ∧ μ t ≠ 0 ∧ μ tᶜ ≠ 0 ∧ (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ ∧
        (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ := by
  by_cases hf0 : ∀ᵐ x ∂μ, f x = 0
  · exact Or.inl (ae_eq_const_of_forall_eq' _ hf0)
  rw [← not_forall, ← ae_iff] at hf0
  refine Or.inr ⟨{ x | f x ≠ 0 }, ?_, ?_, ?_, ?_⟩
  · exact measurableSet_of_mem_ae_ne_const hf0
  · exact (measure_ne_zero_iff_nonempty_of_ae_ne_zero hf0).2 fun h ↦ hf0 h rfl
  · exact (measure_ne_zero_iff_nonempty_of_ae_ne_zero hf0).2 fun h ↦ hf0 h rfl
  · simp_rw [average_eq, set_average_eq]
    rw [← integrableOn_univ, ← integrableOn_compl_univ, ← ae_ne_const_iff_average_ne_compl hfi]
    exact ae_ne_const_of_ae_ne_zero hf0

Repaired Proof:
theorem ae_eq_const_or_exists_average_ne_compl [IsFiniteMeasure μ] (hfi : Integrable f μ) :
    f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨
      ∃ t, MeasurableSet t ∧ μ t ≠ 0 ∧ μ tᶜ ≠ 0 ∧ (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ ∧
        (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ := by
  by_cases hf0 : ∀ᵐ x ∂μ, f x = 0
  · exact Or.inl (ae_eq_const_of_forall_eq' _ hf0)
  rw [← not_forall, ← ae_iff] at hf0
  refine Or.inr ⟨{ x | f x ≠ 0 }, ?_, ?_, ?_, ?_⟩
  · exact measurableSet_of_mem_ae_ne_const hf0
  · exact (measure_ne_zero_iff_nonempty_of_ae_ne_zero hf0).2 fun h ↦ hf0 h rfl
  · exact (measure_ne_zero_iff_nonempty_of_ae_ne_zero hf0).2 fun h ↦ hf0 h rfl
  · simp_rw [average_eq, set_average_eq]
    rw [← integrableOn_univ, ← integrableOn_compl_univ, ← ae_ne_const_iff_average_ne_compl hfi]
    exact ae_ne_const_of_ae_ne_zero hf0

Repaired Proof:
theorem ae_eq_const_or_exists_average_ne_compl [IsFiniteMeasure μ] (hfi : Integrable f μ) :
    f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨
      ∃ t, MeasurableSet t ∧ μ t ≠ 0 ∧ μ tᶜ ≠ 0 ∧ (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ ∧
        (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ := by
  by_cases hf0 : ∀ᵐ x ∂μ, f x = 0
  · exact Or.inl (ae_eq_const_of_forall_eq' _ hf0)
  rw [← not_forall, ← ae_iff] at hf0
  refine Or.inr ⟨{ x | f x ≠ 0 }, ?_, ?_, ?_, ?_⟩
  · exact measurableSet_of_mem_ae_ne_const hf0
  · exact (measure_ne_zero_iff_nonempty_of_ae_ne_zero hf0).2 fun h ↦ hf0 h rfl
  · exact (measure_ne_zero_iff_nonempty_of_ae_ne_zero hf0).2 fun h ↦ hf0 h rfl
  · simp_rw [average_eq, set_average_eq]
    rw [← integrableOn_univ, ← integrableOn_compl_univ, ← ae_ne_const_iff_average_ne_compl hfi]
    exact ae_ne_const_of_ae_ne_zero hf0

Repaired Proof:
theorem ae_eq_const_or_exists_average_ne_compl [Is

Attempt failure.

Working on Mathlib/Analysis/Convex/Segment.lean - 2024-09-09 01:38:02.518939.
---30/200---
For theorem openSegment_subset_union in Mathlib/Analysis/Convex/Segment.lean:
theorem openSegment_subset_union (x y : E) {z : E} (hz : z ∈ range (lineMap x y : 𝕜 → E)) :
    openSegment 𝕜 x y ⊆ insert z (openSegment 𝕜 x z ∪ openSegment 𝕜 z y) 


Original valid proof:
:= by
  rcases hz with ⟨c, rfl⟩
  simp only [openSegment_eq_image_lineMap, ← mapsTo']
  rintro a ⟨h₀, h₁⟩
  rcases lt_trichotomy a c with (hac | rfl | hca)
  · right
    left
    have hc : 0 < c := h₀.trans hac
    refine ⟨a / c, ⟨div_pos h₀ hc, (div_lt_one hc).2 hac⟩, ?_⟩
    simp only [← homothety_eq_lineMap, ← homothety_mul_apply, div_mul_cancel₀ _ hc.ne']
  · left
    rfl
  · right
    right
    have hc : 0 < 1 - c := sub_pos.2 (hca.trans h₁)
    simp only [← lineMap_apply_one_sub y]
    refine
      ⟨(a - c) / (1 - c), ⟨div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right h₁ _⟩,
        ?_⟩
    simp only [← homothety_eq_lineMap, ← homothety_mul_apply, sub_mul, one_mul,
      div_mul_cancel₀ _ hc.ne', sub_sub_sub_cancel_right]


Verifying proof (Commit ed737e5773cdf087080f52542509535e7446ced4):
∪ {x, y} := by
  rcases hz with ⟨a, rfl⟩
  rcases eq_or_ne a 0 with (rfl | ha)
  · simp
  rcases eq_or_ne a 1 with (rfl | ha)
  · simp
  rw [openSegment_eq_image']
  simp_rw [lineMap_apply_module]
  simp only [mem_union, mem_insert_iff, mem_singleton_iff, true_or, or_true, true_and,
    and_true, mem_image, mem_openSegment_iff']
  rintro ⟨b, c, hb, hc, rfl⟩
  refine' Or.inl ⟨b, c, hb, hc, _⟩
  simp only [add_smul, sub_smul, add_sub_cancel_left, sub_add_cancel]
  rw [add_comm]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  refine' Or.inr ⟨b, c, hb, hc, _⟩
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add_comm, smul_add, smul_smul]
  simp only [add_sub_cancel, mul_one, add

Attempt failure.

Working on Mathlib/Analysis/Convex/Slope.lean - 2024-09-09 01:38:14.581336.
---31/200---
For theorem StrictConvexOn.slope_strict_mono_adjacent in Mathlib/Analysis/Convex/Slope.lean:
theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn 𝕜 s f) {x y z : 𝕜}
    (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) 


Original valid proof:
:= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [← sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf at this ⊢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a • x + b • z = y := by field_simp [a, b]; ring
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by field_simp [a, b])
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [mul_comm (z - x) _] at key ⊢
  rw [div_lt_div_right]
  · linarith
  · nlinarith


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∧
      (f z - f y) / (z - y) < (f z - f x) / (z - x) := by
  have hxy' : 0 < y - x := by linarith
  have hyz' : 0 < z - y := by linarith
  have hxz' : 0 < z - x := by linarith
  constructor
  · rw [div_lt_div_iff hxy' hyz']
    linarith [hf hx hz hxy.le hyz.le (add_pos_of_pos_of_nonneg hxy' hyz'.le)]
  · rw [div_lt_div_iff hyz' hxz']
    linarith [hf hx hz (add_pos hxy' hyz'.le).le hxz'.le]

Repaired Proof:
theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn 𝕜 s f) {x y z : 𝕜}
    (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ∧
      (f z - f y) / (z - y) < (f z - f x) / (z - x) := by
  have hxy' : 0 < y - x := by linarith
  have hyz' : 0 < z - y := by linarith
  have hxz' : 0 < z - x := by linarith
  constructor
  · rw [div_lt_div_iff hxy' hyz']
    linarith [hf hx hz hxy.le hyz.le (add_pos_of_pos_of_nonneg hxy' hyz'.le)]
  · rw [div_lt_div_iff hyz' hxz']
    linarith [hf hx hz (add_pos hxy' hyz'.le).le hxz'.le]

Repaired Proof:
theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn 𝕜 s f) {x y z : 𝕜}
    (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ∧
      (f z - f y) / (z - y) < (f z - f x) / (z - x) := by
  have hxy' : 0 < y - x := by linarith
  have hyz' : 0 < z - y := by linarith
  have hxz' : 0 < z - x := by linarith
  constructor
  · rw [div_lt_div_iff hxy' hyz']
    linarith [hf hx hz hxy.le hyz.le (add_pos_of_pos_of_nonneg hxy' hyz'.le)]
  · rw [div_lt_div_iff hyz' hxz']
    linarith [hf hx hz (add_pos hxy' hyz'.le).le hxz'.le]

Repaired Proof:
theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn 𝕜 s f) {x y z : 𝕜}
    (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ∧
      (f z - f y) / (z - y) < (f z - f x) / (z - x) := by
  have hxy' : 0 < y - x := by linarith
  have hyz' : 0 < z - y := by linarith
  have hxz' : 0 < z - x := by linarith
  constructor
  · rw [div_lt_div_iff hxy' hyz']
    linarith [hf hx hz hxy.le hyz.le (add_pos_of_pos_of_nonneg hxy' hyz'.le)]
  · rw [div_lt_div_iff hyz' hxz']
    linarith [hf hx hz (add_pos hxy' hyz'.le).le hxz'.le]

Repaired Proof:
theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn 𝕜 s f) {x y z : 𝕜}
    (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ∧
      (f z - f y) / (z - y) < (f z - f x) / (z - x) := by
  have hxy' : 0 < y - x := by linarith
  have hyz' : 0 < z - y := by linarith
  have hxz' : 0 < z - x := by linarith
  constructor
  · rw [div_lt_div_iff hxy' hyz']
    linarith [hf hx hz hxy.le hyz.le (add_pos_of_pos_of_nonneg hxy' hyz'.le)]
  · rw [div_lt_div_iff hyz' hxz']
    linarith [hf hx hz (add_pos hxy' hyz'.le).le hxz'.le]

Repaired Proof:
theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn 𝕜 s f) {x y z : 𝕜}
    (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ∧
      (f z - f y) / (z - y) < (f z - f x) / (z - x) := by
  have hxy' : 0 < y - x := by linarith
  have hyz' : 0 < z - y := by linarith
  have hxz' : 0 < z - x := by linarith
  constructor
  · rw [div_lt_div_iff hxy' hyz']
    linarith [hf hx hz hxy.le hyz.le (add_pos_of_pos_of_nonneg hxy' hyz'.le)]
  · rw [div_lt_div_iff hyz' hxz']
    linarith [hf hx hz (add_pos hxy' hyz'.le).le hxz'.le]

Repaired Proof:
theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn 𝕜 s f) {x y z : 𝕜}
    (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ∧
      (f z - f y) / (z - y) < (f z - f x) / (z - x) := by
  have hxy' : 0 < y - x := by linarith
  have hyz' : 0 < z - y := by linarith
  have hxz' : 0 < z - x := by linarith
  constructor
  · rw [div_lt_div_iff hxy' hyz']
    linarith [hf hx hz hxy.le hyz.le (add_pos_of_pos_of_nonneg hxy' hyz'.le)]
  · rw [div_lt_div_iff hyz' hxz']
    linarith [hf hx hz (add_pos hxy' hyz'.le).le hxz'.le]

Repaired Proof:
theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn 𝕜 s f) {x y z : 𝕜}
    (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ∧
      (f z - f y) / (z - y) < (f z - f x) / (z - x

Attempt failure.

Working on Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean - 2024-09-09 01:38:26.685894.
---32/200---
For theorem strictConvexOn_pow in Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean:
theorem strictConvexOn_pow {n : ℕ} (hn : 2 ≤ n) : StrictConvexOn ℝ (Ici 0) fun x : ℝ => x ^ n 


Original valid proof:
:= by
  apply StrictMonoOn.strictConvexOn_of_deriv (convex_Ici _) (continuousOn_pow _)
  rw [deriv_pow', interior_Ici]
  exact fun x (hx : 0 < x) y _ hxy => mul_lt_mul_of_pos_left
    (pow_lt_pow_left hxy hx.le <| Nat.sub_ne_zero_of_lt hn) (by positivity)


Verifying proof (Commit d1288d481cf0b7487a274181f0282b46161236a7):
 := by
    apply strictConvexOn_of_deriv2_pos' (convex_Ici 0) fun x hx => _
    simp only [deriv2_pow', hx, zero_le_one, zero_lt_two, add_pos, hn, Nat.cast_pos, mul_pos,
      inv_pos, Nat.cast_add, Nat.cast_two]

Repaired Proof:
theorem strictConvexOn_pow {n : ℕ} (hn : 2 ≤ n) : StrictConvexOn ℝ (Ici 0) fun x : ℝ => x ^ n := by
  apply strictConvexOn_of_deriv2_pos (convex_Ici 0) fun x hx => _
  simp only [deriv2_pow', hx, zero_le_one, zero_lt_two, add_pos, hn, Nat.cast_pos, mul_pos,
    inv_pos, Nat.cast_add, Nat.cast_two]

Repaired Proof:
theorem strictConvexOn_pow {n : ℕ} (hn : 2 ≤ n) : StrictConvexOn ℝ (Ici 0) fun x : ℝ => x ^ n := by
  apply strictConvexOn_of_deriv2_pos (convex_Ici 0) fun x hx => ?_
  simp only [deriv2_pow', hx, zero_le_one, zero_lt_two, add_pos, hn, Nat.cast_pos, mul_pos,
    inv_pos, Nat.cast_add, Nat.cast_two]

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Basic.lean - 2024-09-09 01:38:37.138028.
---33/200---
For theorem Orthonormal.inner_right_finsupp in Mathlib/Analysis/InnerProductSpace/Basic.lean:
theorem Orthonormal.inner_right_finsupp {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) :
    ⟪v i, Finsupp.total ι E 𝕜 v l⟫ = l i 


Original valid proof:
:= by
  classical
  simpa [Finsupp.total_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv] using Eq.symm


Verifying proof (Commit 61ddcfa78d90f5773ac5739822ee3721851aa662):
• ‖v i‖ ^ 2 := by
  classical
  simp only [Finsupp.total_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv,
    ite_smul, one_smul, Or.by_cases, zero_smul, zero_add]
  have h_eq : ∀ j, ⟪v i, v j⟫ = if i = j then 1 else 0 := fun j =>
    orthonormal_iff_ite.mp hv i j
  simp_rw [h_eq]
  rw [Finset.sum_ite_eq', if_pos (Finset.mem_univ i)]

Repaired Proof:
theorem Orthonormal.inner_right_finsupp {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) :
    ⟪v i, Finsupp.total ι E 𝕜 v l⟫ = l i • ‖v i‖ ^ 2 := by
  classical
  simp only [Finsupp.total_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv,
    ite_smul, one_smul, Or.by_cases, zero_smul, zero_add]
  have h_eq : ∀ j, ⟪v i, v j⟫ = if i = j then 1 else 0 := fun j =>
    orthonormal_iff_ite.mp hv i j
  simp_rw [h_eq]
  rw [Finset.sum_ite_eq', if_pos (Finset.mem_univ i)]

Repaired Proof:
theorem Orthonormal.inner_right_finsupp {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) :
    ⟪v i, Finsupp.total ι E 𝕜 v l⟫ = l i • ‖v i‖ ^ 2 := by
  classical
  simp only [Finsupp.total_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv,
    ite_smul, one_smul, Or.by_cases, zero_smul, zero_add]
  have h_eq : ∀ j, ⟪v i, v j⟫ = if i = j then 1 else 0 := fun j =>
    orthonormal_iff_ite.mp hv i j
  simp_rw [h_eq]
  rw [Finset.sum_ite_eq', if_pos (Finset.mem_univ i)]

Repaired Proof:
theorem Orthonormal.inner_right_finsupp {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) :
    ⟪v i, Finsupp.total ι E 𝕜 v l⟫ = l i • ‖v i‖ ^ 2 := by
  classical
  simp only [Finsupp.total_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv,
    ite_smul, one_smul, Or.by_cases, zero_smul, zero_add]
  have h_eq : ∀ j, ⟪v i, v j⟫ = if i = j then 1 else 0 := fun j =>
    orthonormal_iff_ite.mp hv i j
  simp_rw [h_eq]
  rw [Finset.sum_ite_eq', if_pos (Finset.mem_univ i)]

Attempt failure.

---34/200---
For theorem InnerProductSpace.Core.normSq_eq_zero in Mathlib/Analysis/InnerProductSpace/Basic.lean:
theorem normSq_eq_zero {x : F} : normSqF x = 0 ↔ x = 0 


Original valid proof:
:=
  Iff.trans
    (by simp only [normSq, ext_iff, map_zero, inner_self_im, eq_self_iff_true, and_true_iff])
    (@inner_self_eq_zero 𝕜 _ _ _ _ _ x)


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
∧ x = 0 :=
   ⟨fun h ↦ ⟨(sq_eq_zero_iff (x.re)).mp (normSq_re x ▸ h),
     (sq_eq_zero_iff (x.im)).mp (normSq_im x ▸ h)⟩,
     fun ⟨h₁, h₂⟩ ↦ h₁ ▸ h₂ ▸ normSq_zero⟩

theorem normSq_ne_zero {x : F} : normSqF x ≠ 0 ↔ x ≠ 0 := normSq_eq_zero.not

theorem normSq_pos {x : F} : 0 < normSqF x ↔ x ≠ 0 :=
  ⟨fun hx _ ↦ normSq_eq_zero.not.mp (ne_of_gt hx),
    fun hx ↦ (lt_of_le_of_ne normSq_nonneg hx.symm).trans_eq (normSq_pos'.mpr hx)⟩

theorem normSq_neg (x : F) : normSqF (-x) = normSqF x := by
  simp only [normSq_eq_def', norm_neg, mul_neg, neg_sq, mul_neg, neg_neg, ← sq]

theorem normSq_conj (x : F) : normSqF (conj x) = normSqF x := by
  simp only [normSq_eq_def', norm_conj, neg_mul_eq_neg_mul]

theorem normSq_mul (x y : F) : normSqF (x * y) = normSqF x * normSqF y := by
  simp only [normSq_eq_def', norm_mul, mul_pow, sq_abs]

theorem normSq_div (x y : F) : normSqF (x / y) = normSqF x / normSqF y := by
  simp only [normSq_eq_def', norm_div, div_pow]

@[simp]
theorem normSq_inv (x : F) : normSqF x⁻¹ = (normSqF x)⁻¹ := by
  simp only [normSq_eq_def', norm_inv, inv_pow]

@[simp]
theorem normSq_zpow (x : F) (n : ℤ) : normSqF (x ^ n) = normSqF x ^ n := by
  obtain n | n := n
  · simp only [normSq_eq_def', zpow_natCast, Int.ofNat_eq_coe, coe_natCast, norm_pow]
  · rw [zpow_negSucc, normSq_inv, sq, ← Int.ofNat_succ, zpow_natCast, normSq_eq_def',
      norm_pow, sq]

@[simp]
theorem normSq_nnratCast (q : ℚ≥0) : normSqF (q : F) = (q : ℚ) ^ 2 := by
  simpa [-normSq_eq_def'] using map_nnratCast (normSqHom : F →*ₙ* ℚ) q

@[deprecated (since := "2024-04-17")]
alias norm_sq_nnrat_cast := normSq_nnratCast

@[simp]
theorem normSq_ratCast (q : ℚ) : normSqF (q : F) = (q : ℚ) ^ 2 := by
  simpa [-normSq_eq_def'] using map_ratCast (normSqHom : F →*ₙ* ℚ) q

@[deprecated (since := "2024-04-17")]
alias norm_sq_rat_cast := normSq_ratCast

@[simp]
theorem normSq_nnreal_smul (c : ℝ≥0) (z : F) : normSqF (c • z) = c * c * normSqF z := by
  simpa [-normSq_eq_def'] using map_nnreal_smul₀ (normSqHom : F →*ₙ* ℚ) c z

@[simp]
theorem normSq_real_smul (c : ℝ) (z : F) : normSqF (c • z) = c * c * normSqF z := by
  simpa [-normSq_eq_def'] using map_real_smul₀ (normSqHom : F →*ₙ* ℚ) c z

@[simp]
theorem normSq_ofReal_re (r : ℝ) : normSqF (r : F) = r * r := by
  simpa [-normSq_eq_def'] using map_ofReal_re (normSqHom : F →*ₙ* ℚ) r

@[simp]
theorem normSq_ofReal_mul_re (r : ℝ) (z : F) :
    normSqF (r * z) = r * r * normSqF z := by
  simpa [-normSq_eq_def'] using map_ofReal_mul_re (normSqHom : F →*ₙ* ℚ) r z

@[simp]
theorem normSq_ofReal_div_re (r : ℝ) (z : F) :
    normSqF (r / z) = r * r * normSqF z⁻¹ := by
  simpa [-normSq_eq_def'] using map_ofReal_div_re (normSqHom : F →*ₙ* ℚ) r z

@[simp]
theorem normSq_ofReal_zsmul_re (n : ℤ) (z : F) :
    normSqF (n • z) = n * n * normSqF z := by
  simpa [-normSq_eq_def'] using map_ofReal_zsmul_re (normSqHom : F →*ₙ* ℚ) n z

@[simp]
theorem normSq_ofReal_qsmul_re (n : ℚ) (z : F) :
    normSqF (n • z) = n * n * normSqF z := by
  simpa [-normSq_eq_def'] using map_ofReal_qsmul_re (normSqHom : F →*ₙ* ℚ) n z

@[simp]
theorem normSq_ofReal_pow_re (n : ℕ) (r : ℝ) :
    normSqF (r ^ n) = (r * r) ^ n := by
  simpa [-normSq_eq_def'] using map_ofReal_pow_re (normSqHom : F →*ₙ* ℚ) n r

@[simp]
theorem normSq_ofReal_zpow_re (n : ℤ) (r : ℝ) :
    normSqF (r ^ n) = (r * r) ^ n := by
  simpa [-normSq_eq_def'] using map_ofReal_zpow_re (normSqHom : F →*ₙ* ℚ) n r

@[simp]
theorem normSq_ofReal_intCast_re (n : ℤ) : normSqF (n : F) = n * n := by
  simpa [-normSq_eq_def'] using map_intCast (normSqHom : F →*ₙ* ℚ) n

@[deprecated (since := "2024-04-17")]
alias norm_sq_ofReal_int_cast_re := normSq_ofReal_intCast_re

@[simp]
theorem normSq_ofReal_natCast_re (n : ℕ) : normSqF (n : F) = n * n := by
  simpa [-normSq_eq_def'] using map_natCast (normSqHom : F →*ₙ* ℚ) n

@[deprecated (since := "2024-04-17")]
alias norm_sq_ofReal_nat_cast_re := normSq_ofReal_natCast_re

@[simp]
theorem normSq_ofReal_ratCast_re (q : ℚ) : normSqF (q : F) = (q : ℝ) ^ 2 := by
  simpa [-normSq_eq_def'] using map_ratCast (normSqHom : F →*ₙ* ℚ) q

@[deprecated (since := "2024-04-17")]
alias norm_sq_ofReal_rat_cast_re := normSq_ofReal_ratCast_re

@[simp]
theorem normSq_ofReal_rat_div_re (q : ℚ) (z : F) :
    normSqF (q / z) = (q : ℝ) ^ 2 / normSqF z := by
  simpa

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/LinearPMap.lean - 2024-09-09 01:39:40.451907.
---35/200---
For theorem IsSelfAdjoint.dense_domain in Mathlib/Analysis/InnerProductSpace/LinearPMap.lean:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) 


Original valid proof:
:= by
  by_contra h
  rw [isSelfAdjoint_def] at hA
  have h' : A.domain = ⊤ := by
    rw [← hA, Submodule.eq_top_iff']
    intro x
    rw [mem_adjoint_domain_iff, ← hA]
    refine (innerSL 𝕜 x).cont.comp ?_
    simp only [adjoint, h]
    exact continuous_const
  simp [h'] at h


Verifying proof (Commit 11d63dbc85fa074b875a66f1c9dd6d3f7cae8101):
↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact hA.continuous
        (A.isUnit_smul_compProd_self_of_dense_inducing hA.isUnit_compProd_self_of_dense_inducing h)
        with
        (hA | hA)
    · exact hA
    · exact hA.unit.isUnit
  · rintro ⟨u, rfl⟩
    exact u.isUnit.dense_inducing.dense_range

Repaired Proof:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact hA.continuous
        (A.isUnit_smul_compProd_self_of_dense_inducing hA.isUnit_compProd_self_of_dense_inducing h)
        with
        (hA | hA)
    · exact hA
    · exact hA.unit.isUnit
  · rintro ⟨u, rfl⟩
    exact u.isUnit.denseInducing.dense_range

Repaired Proof:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact hA.continuous
        (A.isUnit_smul_compProd_self_of_dense_inducing hA.isUnit_compProd_self_of_dense_inducing h)
        with
        (hA | hA)
    · exact hA
    · exact hA.unit.isUnit
  · rintro ⟨u, rfl⟩
    exact u.isUnit.denseInducing.dense_range

Repaired Proof:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact hA.continuous
        (A.isUnit_smul_compProd_self_of_dense_inducing hA.isUnit_compProd_self_of_dense_inducing h)
        with
        (hA | hA)
    · exact hA
    · exact hA.unit.isUnit
  · rintro ⟨u, rfl⟩
    exact u.isUnit.denseInducing.dense_range

Repaired Proof:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact hA.continuous
        (A.isUnit_smul_compProd_self_of_dense_inducing hA.isUnit_compProd_self_of_dense_inducing h)
        with
        (hA | hA)
    · exact hA
    · exact hA.unit.isUnit
  · rintro ⟨u, rfl⟩
    exact u.isUnit.denseInducing.dense_range

Repaired Proof:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact hA.continuous
        (A.isUnit_smul_compProd_self_of_dense_inducing hA.isUnit_compProd_self_of_dense_inducing h)
        with
        (hA | hA)
    · exact hA
    · exact hA.unit.isUnit
  · rintro ⟨u, rfl⟩
    exact u.isUnit.denseInducing.dense_range

Repaired Proof:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact hA.continuous
        (A.isUnit_smul_compProd_self_of_dense_inducing hA.isUnit_compProd_self_of_dense_inducing h)
        with
        (hA | hA)
    · exact hA
    · exact hA.unit.isUnit
  · rintro ⟨u, rfl⟩
    exact u.isUnit.denseInducing.dense_range

Repaired Proof:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact hA.continuous
        (A.isUnit_smul_compProd_self_of_dense_inducing hA.isUnit_compProd_self_of_dense_inducing h)
        with
        (hA | hA)
    · exact hA
    · exact hA.unit.isUnit
  · rintro ⟨u, rfl⟩
    exact u.isUnit.denseInducing.dense_range

Repaired Proof:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact hA.continuous
        (A.isUnit_smul_compProd_self_of_dense_inducing hA.isUnit_compProd_self_of_dense_inducing h)
        with
        (hA | hA)
    · exact hA
    · exact hA.unit.isUnit
  · rintro ⟨u, rfl⟩
    exact u.isUnit.denseInducing.dense_range

Repaired Proof:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact hA.continuous
        (A.isUnit_smul_compProd_self_of_dense_inducing hA.isUnit_compProd_self_of_dense_inducing h)
        with
        (hA | hA)
    · exact hA
    · exact hA.unit.isUnit
  · rintro ⟨u, rfl⟩
    exact u.isUnit.denseInducing.dense_range

Repaired Proof:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact hA.continuous
        (A.isUnit_smul_compProd_self_of_dense_inducing hA.isUnit_compProd_self_of_dense_inducing h)
        with
        (hA | hA)
    · exact hA
    · exact hA.unit.isUnit
  · rintro ⟨u, rfl⟩
    exact u.isUnit.denseInducing.dense_range

Repaired Proof:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ↔ A.IsUnit := by
  constructor
  · intro h
    rcases hA.isUnit_or_isUnit_of_isUnit_smul_of_tendsto_cocompact

Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/Bounded.lean - 2024-09-09 01:39:52.621322.
---36/200---
For theorem Bornology.isVonNBounded_covers in Mathlib/Analysis/LocallyConvex/Bounded.lean:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) 


Original valid proof:
:=
  Set.eq_univ_iff_forall.mpr fun x =>
    Set.mem_sUnion.mpr ⟨{x}, isVonNBounded_singleton _, Set.mem_singleton _⟩


Verifying proof (Commit fce7faeae2bd16f268cd47d7cd0fceb445a4d5ac):
∪ {0} := by
  refine' Subset.antisymm (fun x hx => _) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain ⟨s, hs, hx⟩ := hx
  rwa [← singleton_subset_iff, ← hs.vadd_set_eq_singleton]

Repaired Proof:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) ∪ {0} := by
  refine Subset.antisymm (fun x hx => ?_) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain ⟨s, hs, hx⟩ := hx
  rwa [← singleton_subset_iff, ← hs.vadd_set_eq_singleton]

Repaired Proof:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) ∪ {0} := by
  refine Subset.antisymm (fun x hx => ?_) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain ⟨s, hs, hx⟩ := hx
  rwa [← singleton_subset_iff, ← hs.vadd_set_eq_singleton]

Repaired Proof:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) ∪ {0} := by
  refine Subset.antisymm (fun x hx => ?_) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain ⟨s, hs, hx⟩ := hx
  rwa [← singleton_subset_iff, ← hs.vadd_set_eq_singleton]

Repaired Proof:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) ∪ {0} := by
  refine Subset.antisymm (fun x hx => ?_) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain ⟨s, hs, hx⟩ := hx
  rwa [← singleton_subset_iff, ← hs.vadd_set_eq_singleton]

Repaired Proof:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) ∪ {0} := by
  refine Subset.antisymm (fun x hx => ?_) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain ⟨s, hs, hx⟩ := hx
  rwa [← singleton_subset_iff, ← hs.vadd_set_eq_singleton]

Repaired Proof:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) ∪ {0} := by
  refine Subset.antisymm (fun x hx => ?_) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain ⟨s, hs, hx⟩ := hx
  rwa [← singleton_subset_iff, ← hs.vadd_set_eq_singleton]

Repaired Proof:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) ∪ {0} := by
  refine Subset.antisymm (fun x hx => ?_) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain ⟨s, hs, hx⟩ := hx
  rwa [← singleton_subset_iff, ← hs.vadd_set_eq_singleton]

Repaired Proof:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) ∪ {0} := by
  refine Subset.antisymm (fun x hx => ?_) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain ⟨s, hs, hx⟩ := hx
  rwa [← singleton_subset_iff, ← hs.vadd_set_eq_singleton]

Repaired Proof:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) ∪ {0} := by
  refine Subset.antisymm (fun x hx => ?_) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain ⟨s, hs, hx⟩ := hx
  rwa [← singleton_subset_iff, ← hs.vadd_set_eq_singleton]

Repaired Proof:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) ∪ {0} := by
  refine Subset.antisymm (fun x hx => ?_) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain ⟨s, hs, hx⟩ := hx
  rwa [← singleton_subset_iff, ← hs.vadd_set_eq_singleton]

Repaired Proof:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) ∪ {0} := by
  refine Subset.antisymm (fun x hx => ?_) (union_subset_iff.mpr ⟨subset_univ _, singleton_subset_iff.mpr
    zero_isVonNBounded⟩)
  simp only [mem_sUnion, mem_univ, mem_singleton_iff, true_and_iff, exists_prop] at hx
  obtain �

Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/WithSeminorms.lean - 2024-09-09 01:40:03.554239.
---37/200---
For theorem SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf in Mathlib/Analysis/LocallyConvex/WithSeminorms.lean:
theorem SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf [u : UniformSpace E]
    [UniformAddGroup E] (p : SeminormFamily 𝕜 E ι) :
    WithSeminorms p ↔ u = ⨅ i, (p i).toSeminormedAddCommGroup.toUniformSpace 


Original valid proof:
:= by
  rw [p.withSeminorms_iff_nhds_eq_iInf,
    UniformAddGroup.ext_iff inferInstance (uniformAddGroup_iInf fun i => inferInstance),
    UniformSpace.toTopologicalSpace_iInf, nhds_iInf]
  congrm _ = ⨅ i, ?_
  exact @comap_norm_nhds_zero _ (p i).toAddGroupSeminorm.toSeminormedAddGroup


Verifying proof (Commit 277dea952df34759a39b00abcc615238ae32c506):
⊓ 𝓤 E := by
  simp_rw [p.withSeminorms_iff_nhds_eq_iInf,
    UniformAddGroup.uniformity_eq_comap_nhds_zero (E := E), Filter.comap_iInf,
    Filter.comap_inf, Filter.comap_principal, map_zero, inf_assoc]
  simp_rw [Seminorm.mem_ball_zero, map_zero]
  simp_rw [← sInf_eq_iInf]
  simp_rw [← Filter.map_sInf, ← sInf_image]
  rfl

Repaired Proof:
theorem SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf [u : UniformSpace E]
    [UniformAddGroup E] (p : SeminormFamily 𝕜 E ι) :
    WithSeminorms p ↔ u = ⨅ i, (p i).toSeminormedAddCommGroup.toUniformSpace ⊓ 𝓤 E := by
  simp_rw [p.withSeminorms_iff_nhds_eq_iInf,
    UniformAddGroup.uniformity_eq_comap_nhds_zero (E := E), Filter.comap_iInf,
    Filter.comap_inf, Filter.comap_principal, map_zero, inf_assoc]
  simp_rw [Seminorm.ball_zero_eq]
  simp_rw [← sInf_eq_iInf]
  simp_rw [← Filter.map_sInf, ← sInf_image]
  rfl

Repaired Proof:
theorem SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf [u : UniformSpace E]
    [UniformAddGroup E] (p : SeminormFamily 𝕜 E ι) :
    WithSeminorms p ↔ u = ⨅ i, (p i).toSeminormedAddCommGroup.toUniformSpace ⊓ 𝓤 E := by
  simp_rw [p.withSeminorms_iff_nhds_eq_iInf,
    UniformAddGroup.uniformity_eq_comap_nhds_zero (E := E), Filter.comap_iInf,
    Filter.comap_inf, Filter.comap_principal, map_zero, inf_assoc]
  simp_rw [Seminorm.ball_zero_eq]
  simp_rw [← sInf_eq_iInf]
  simp_rw [← Filter.map_sInf, ← sInf_image]
  rfl

Repaired Proof:
theorem SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf [u : UniformSpace E]
    [UniformAddGroup E] (p : SeminormFamily 𝕜 E ι) :
    WithSeminorms p ↔ u = ⨅ i, (p i).toSeminormedAddCommGroup.toUniformSpace ⊓ 𝓤 E := by
  simp_rw [p.withSeminorms_iff_nhds_eq_iInf,
    UniformAddGroup.uniformity_eq_comap_nhds_zero (E := E), Filter.comap_iInf,
    Filter.comap_inf, Filter.comap_principal, map_zero, inf_assoc]
  simp_rw [Seminorm.ball_zero_eq]
  simp_rw [← sInf_eq_iInf]
  simp_rw [← Filter.map_sInf, ← sInf_image]
  rfl

Repaired Proof:
theorem SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf [u : UniformSpace E]
    [UniformAddGroup E] (p : SeminormFamily 𝕜 E ι) :
    WithSeminorms p ↔ u = ⨅ i, (p i).toSeminormedAddCommGroup.toUniformSpace ⊓ 𝓤 E := by
  simp_rw [p.withSeminorms_iff_nhds_eq_iInf,
    UniformAddGroup.uniformity_eq_comap_nhds_zero (E := E), Filter.comap_iInf,
    Filter.comap_inf, Filter.comap_principal, map_zero, inf_assoc]
  simp_rw [Seminorm.ball_zero_eq]
  simp_rw [← sInf_eq_iInf]
  simp_rw [← Filter.map_sInf, ← sInf_image]
  rfl

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Exponential.lean - 2024-09-09 01:40:19.771820.
---38/200---
For theorem NormedSpace.expSeries_eq_expSeries in Mathlib/Analysis/NormedSpace/Exponential.lean:
theorem expSeries_eq_expSeries (n : ℕ) (x : 𝔸) :
    (expSeries 𝕂 𝔸 n fun _ => x) = expSeries 𝕂' 𝔸 n fun _ => x 


Original valid proof:
:= by
  rw [expSeries_apply_eq, expSeries_apply_eq, inv_natCast_smul_eq 𝕂 𝕂']


Verifying proof (Commit 41597a602a472e810aba18a1f457a0473cf36736):
• (1 : 𝔸) := by
  induction' n with n ih
  · simp
  · ext
    simp [expSeries_apply_eq, ih, Finset.prod_range_succ_comm, ← smul_pow, smul_mul_assoc]

Repaired Proof:
theorem expSeries_eq_expSeries (n : ℕ) (x : 𝔸) :
    (expSeries 𝕂 𝔸 n fun _ => x) = expSeries 𝕂' 𝔸 n fun _ => x • (1 : 𝔸) := by
  induction' n with n ih
  · simp
  · ext
    simp [expSeries_apply_eq, ih, Finset.prod_range_succ_comm, ← smul_pow, smul_mul_assoc]

Repaired Proof:
theorem exp_eq_tsum_expSeries (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x • (1 : 𝔸) :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_top _ _)).tsum_eq

Repaired Proof:
theorem exp_eq_tsum_expSeries' (x : 𝔸) :
    exp 𝕂 x = ∑' n : ℕ, expSeries 𝕂' 𝔸 n fun _ => x :=
  (expSeries_summable_of_mem_ball' x ((expSeries_radius_eq_top 𝕂' 𝔸).symm ▸ edist_lt_

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/FiniteDimension.lean - 2024-09-09 01:40:32.519945.
---39/200---
For theorem FiniteDimensional.proper in Mathlib/Analysis/NormedSpace/FiniteDimension.lean:
theorem FiniteDimensional.proper [FiniteDimensional 𝕜 E] : ProperSpace E 


Original valid proof:
:= by
  have : ProperSpace 𝕜 := .of_locallyCompactSpace 𝕜
  set e := ContinuousLinearEquiv.ofFinrankEq (@finrank_fin_fun 𝕜 _ _ (finrank 𝕜 E)).symm
  exact e.symm.antilipschitz.properSpace e.symm.continuous e.symm.surjective


Verifying proof (Commit b68cba430a2bd7b48000c9b0293cda90c5c2713f):
↔ Nontrivial E :=
  (isROrC_iff_proper 𝕜 E).trans (nontrivial_iff_ne_zero_one 𝕜 E)

end IsROrC

section RCLike

variable {𝕜 : Type*} [RCLike 𝕜]
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace 𝕜 E]

theorem FiniteDimensional.proper [FiniteDimensional 𝕜 E] : ProperSpace E :=
  (isROrC_iff_proper 𝕜 E).mp inferInstance


theorem FiniteDimensional.proper_submodule [FiniteDimensional 𝕜 E] (s : Submodule 𝕜 E) :
    ProperSpace s :=
  haveI : FiniteDimensional 𝕜 s := Submodule.finiteDimensional_of_finiteDimensional_quotient s
  (isROrC_iff_proper 𝕜 s).mp inferInstance


theorem FiniteDimensional.proper_quotient [FiniteDimensional 𝕜 E] : ProperSpace (E ⧸ s) :=
  (isROrC_iff_proper 𝕜 (E ⧸ s)).mp inferInstance


theorem FiniteDimensional.proper_quotient' [FiniteDimensional 𝕜 E] (s : Submodule 𝕜 E) :
    ProperSpace (s.Quotient) :=
  (isROrC_iff_proper 𝕜 (s.Quotient)).mp inferInstance


theorem FiniteDimensional.proper_quotient'' [FiniteDimensional 𝕜 E] (s : Submodule 𝕜 E) :
    ProperSpace (E ⧸ s) :=
  (isROrC_iff_proper 𝕜 (E ⧸ s)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient [FiniteDimensional 𝕜 (E ⧸ s)] :
    ProperSpace s :=
  haveI : FiniteDimensional 𝕜 s := Submodule.finiteDimensional_of_finiteDimensional_quotient s
  (isROrC_iff_proper 𝕜 s).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient' [FiniteDimensional 𝕜 (E ⧸ s)]
    (s : Submodule 𝕜 E) : ProperSpace (E ⧸ s) :=
  (isROrC_iff_proper 𝕜 (E ⧸ s)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace s :=
  (isROrC_iff_proper 𝕜 s).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient'''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (s.Quotient) :=
  (isROrC_iff_proper 𝕜 (s.Quotient)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (E ⧸ s) :=
  (isROrC_iff_proper 𝕜 (E ⧸ s)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient'''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace s :=
  (isROrC_iff_proper 𝕜 s).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (s.Quotient) :=
  (isROrC_iff_proper 𝕜 (s.Quotient)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient'''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (E ⧸ s) :=
  (isROrC_iff_proper 𝕜 (E ⧸ s)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace s :=
  (isROrC_iff_proper 𝕜 s).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient'''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (s.Quotient) :=
  (isROrC_iff_proper 𝕜 (s.Quotient)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient''''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (E ⧸ s) :=
  (isROrC_iff_proper 𝕜 (E ⧸ s)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient'''''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace s :=
  (isROrC_iff_proper 𝕜 s).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient''''''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (s.Quotient) :=
  (isROrC_iff_proper 𝕜 (s.Quotient)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient'''''''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (E ⧸ s) :=
  (isROrC_iff_proper 𝕜 (E ⧸ s)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient''''''''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace s :=
  (isROrC_iff_proper 𝕜 s).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient'''''''''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (s.Quotient) :=
  (isROrC_iff_proper 𝕜 (s.Quotient)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient''''''''''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (E ⧸ s) :=
  (isROrC_iff_proper 𝕜 (E ⧸ s)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient'''''''''''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace s :=
  (isROrC_iff_proper 𝕜 s).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient''''''''''''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (s.Quotient) :=
  (isROrC_iff_proper 𝕜 (s.Quotient)).mp inferInstance


theorem FiniteDimensional.proper_quotient_of_finiteDimensional_quotient'''''''''''''''''''
    [FiniteDimensional 𝕜 (E ⧸ s)] (s : Submodule 𝕜 E) : ProperSpace (E ⧸ s) :=


Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean - 2024-09-09 01:40:50.296522.
---40/200---
For theorem Real.Gamma_ne_zero in Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean:
theorem Gamma_ne_zero {s : ℝ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0 


Original valid proof:
:= by
  suffices ∀ {n : ℕ}, -(n : ℝ) < s → Gamma s ≠ 0 by
    apply this
    swap
    · exact ⌊-s⌋₊ + 1
    rw [neg_lt, Nat.cast_add, Nat.cast_one]
    exact Nat.lt_floor_add_one _
  intro n
  induction' n with _ n_ih generalizing s
  · intro hs
    refine (Gamma_pos_of_pos ?_).ne'
    rwa [Nat.cast_zero, neg_zero] at hs
  · intro hs'
    have : Gamma (s + 1) ≠ 0 := by
      apply n_ih
      · intro m
        specialize hs (1 + m)
        contrapose! hs
        rw [← eq_sub_iff_add_eq] at hs
        rw [hs]
        push_cast
        ring
      · rw [Nat.cast_add, Nat.cast_one, neg_add] at hs'
        linarith
    rw [Gamma_add_one, mul_ne_zero_iff] at this
    · exact this.2
    · simpa using hs 0


Verifying proof (Commit 3cb2bdef8481160ee4f3f3a94fca1f5824c2798a):
 := by
  refine'
    Nat.strong_induction_on (f := fun n => ∀ m : ℕ, m ≤ n → Gamma (s + m) ≠ 0) _
      (fun n ih m hm => _) n
  cases' m with m
  · simp
  rcases le_or_lt s 0 with (hs' | hs')
  · rw [add_comm]
    refine' mul_ne_zero _ (ih m (Nat.lt_succ_iff.1 hm) _)
    · simp only [Gamma_add_one _ (by simpa using hs 1), Ne, add_eq_zero, ofReal_ne_zero,
        Nat.cast_eq_zero, false_and_iff, not_false_iff]
    · rwa [add_neg_le_iff_le_add', ← Nat.cast_succ, Nat.cast_le, Nat.succ_le_iff]
  · rw [Gamma_add_one _ (by rwa [add_comm]), Ne, add_eq_zero, ofReal_ne_zero,
      Nat.cast_eq_zero, false_and_iff, not_false_iff]
    exact ih m (Nat.lt_succ_iff.1 hm) _ (by rwa [add_neg_le_iff_le_add', ← Nat.cast_succ,
      Nat.cast_le, Nat.succ_le_iff])

Repaired Proof:
theorem Gamma_ne_zero {s : ℝ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0  := by
  refine
    Nat.strong_induction_on (f := fun n => ∀ m : ℕ, m ≤ n → Gamma (s + m) ≠ 0) ?_
      (fun n ih m hm => ?_) n
  cases' m with m
  · simp
  rcases le_or_lt s 0 with (hs' | hs')
  · rw [add_comm]
    refine mul_ne_zero ?_ (ih m (Nat.lt_succ_iff.1 hm) _)
    · simp only [Gamma_add_one _ (by simpa using hs 1), Ne, add_eq_zero, ofReal_ne_zero,
        Nat.cast_eq_zero, false_and_iff, not_false_iff]
    · rwa [add_neg_le_iff_le_add', ← Nat.cast_succ, Nat.cast_le, Nat.succ_le_iff]
  · rw [Gamma_add_one _ (by rwa [add_comm]), Ne, add_eq_zero, ofReal_ne_zero,
      Nat.cast_eq_zero, false_and_iff, not_false_iff]
    exact ih m (Nat.lt_succ_iff.1 hm) _ (by rwa [add_neg_le_iff_le_add', ← Nat.cast_succ,
      Nat.cast_le, Nat.succ_le_iff])

Repaired Proof:
theorem Gamma_ne_zero {s : ℝ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0  := by
  refine
    Nat.strong_induction_on (f := fun n => ∀ m : ℕ, m ≤ n → Gamma (s + m) ≠ 0) ?_
      (fun n ih m hm => ?_) n
  cases' m with m
  · simp
  rcases le_or_lt s 0 with (hs' | hs')
  · rw [add_comm]
    refine mul_ne_zero ?_ (ih m (Nat.lt_succ_iff.1 hm) _)
    · simp only [Gamma_add_one _ (by simpa using hs 1), Ne, add_eq_zero, ofReal_ne_zero,
        Nat.cast_eq_zero, false_and_iff, not_false_iff]
    · rwa [add_neg_le_iff_le_add', ← Nat.cast_succ, Nat.cast_le, Nat.succ_le_iff]
  · rw [Gamma_add_one _ (by rwa [add_comm]), Ne, add_eq_zero, ofReal_ne_zero,
      Nat.cast_eq_zero, false_and_iff, not_false_iff]
    exact ih m (Nat.lt_succ_iff.1 hm) _ (by rwa [add_neg_le_iff_le_add', ← Nat.cast_succ,
      Nat.cast_le, Nat.succ_le_iff])

Repaired Proof:
theorem Gamma_ne_zero {s : ℝ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0  := by
  refine
    Nat.strong_induction_on (f := fun n => ∀ m : ℕ, m ≤ n → Gamma (s + m) ≠ 0) ?_
      (fun n ih m hm => ?_) n
  cases' m with m
  · simp
  rcases le_or_lt s 0 with (hs' | hs')
  · rw [add_comm]
    refine mul_ne_zero ?_ (ih m (Nat.lt_succ_iff.1 hm) _)
    · simp only [Gamma_add_one _ (by simpa using hs 1), Ne, add_eq_zero, ofReal_ne_zero,
        Nat.cast_eq_zero, false_and_iff, not_false_iff]
    · rwa [add_neg_le_iff_le_add', ← Nat.cast_succ, Nat.cast_le, Nat.succ_le_iff]
  · rw [Gamma_add_one _ (by rwa [add_comm]), Ne, add_eq_zero, ofReal_ne_zero,
      Nat.cast_eq_zero, false_and_iff, not_false_iff]
    exact ih m (Nat.lt_succ_iff.1 hm) _ (by rwa [add_neg_le_iff_le_add', ← Nat.cast_succ,
      Nat.cast_le, Nat.succ_le_iff])

Repaired Proof:
theorem Gamma_ne_zero {s : ℝ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0  := by
  refine
    Nat.strong_induction_on (f := fun n => ∀ m : ℕ, m ≤ n → Gamma (s + m) ≠ 0) ?_
      (fun n ih m hm => ?_) n
  cases' m with m
  · simp
  rcases le_or_lt s 0 with (hs' | hs')
  · rw [add_comm]
    refine mul_ne_zero ?_ (ih m (Nat.lt_succ_iff.1 hm) _)
    · simp only [Gamma_add_one _ (by simpa using hs 1), Ne, add_eq_zero, ofReal_ne_zero,
        Nat.cast_eq_zero, false_and_iff, not_false_iff]
    · rwa [add_neg_le_iff_le_add', ← Nat.cast_succ, Nat.cast_le, Nat.succ_le_iff]
  · rw [Gamma_add_one _ (by rwa [add_comm]), Ne, add_eq_zero, ofReal_ne_zero,
      Nat.cast_eq_zero, false_and_iff, not_false_iff]
    exact ih m (Nat.lt_succ_iff.1 hm) _ (by rwa [add_neg_le_iff_le_add', ← Nat.cast_succ,
      Nat.cast_le, Nat.succ_le_iff])

Repaired Proof:
theorem Gamma_ne_zero {s : ℝ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0  := by
  refine
    Nat.strong_induction_on (f := fun n => ∀ m : ℕ, m ≤ n → Gamma (s + m) ≠ 0) ?_
      (fun n ih m hm => ?_) n
  cases' m with m
  · simp
  rcases le_or_lt s 0 with (hs' | hs')
  · rw [add_comm]
    refine mul_ne_zero ?_ (ih m (Nat.lt_succ_iff.1 hm) _)
    · simp only [Gamma_add_one _ (by simpa using hs 1), Ne, add_eq_zero, ofReal_ne_zero,
        Nat.cast_eq_zero, false_and_iff, not_false_iff]
    · rwa [add

Attempt failure.

---41/200---
For theorem Complex.integral_cpow_mul_exp_neg_mul_Ioi in Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean:
lemma integral_cpow_mul_exp_neg_mul_Ioi {a : ℂ} {r : ℝ} (ha : 0 < a.re) (hr : 0 < r) :
    ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a 


Original valid proof:
:= by
  have aux : (1 / r : ℂ) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [← cpow_one (1 / r : ℂ)]
    rw [← cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel]
  calc
    _ = ∫ (t : ℝ) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.setIntegral_congr measurableSet_Ioi (fun x hx ↦ ?_)
      rw [mem_Ioi] at hx
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, ← mul_assoc, one_div, ← ofReal_inv,
        ← mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, ← ofReal_mul r⁻¹, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = 1 / r * ∫ (t : ℝ) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [← ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x ↦ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, ← one_div, ofReal_div, ofReal_one]
    _ = 1 / r * (1 / r : ℂ) ^ (a - 1) * (∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [← integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]


Verifying proof (Commit c47ebbbece0d449dca95c589513159cdc2bab40d):
 := by
  have : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) = (1 / b) ^ a * Gamma a :=
    fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₂ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₃ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₄ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₅ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₆ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₇ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₈ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₉ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₀ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₁ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₂ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₃ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₄ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₅ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₆ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₇ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₈ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₉ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₂₀ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  exact h₁₁ hr

Repaired Proof:
lemma integral_cpow_mul_exp_neg_mul_Ioi {a : ℂ} {r : ℝ} (ha : 0 < a.re) (hr : 0 < r) :
    ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a  := by
  have : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) = (1 / b) ^ a * Gamma a :=
    fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁ : ∀ (b : ℝ), 0 < b → �

Attempt failure.

---42/200---
For theorem Complex.integral_cpow_mul_exp_neg_mul_Ioi in Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean:
lemma integral_cpow_mul_exp_neg_mul_Ioi {a : ℂ} {r : ℝ} (ha : 0 < a.re) (hr : 0 < r) :
    ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a 


Original valid proof:
:= by
  have aux : (1 / r : ℂ) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [← cpow_one (1 / r : ℂ)]
    rw [← cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel]
  calc
    _ = ∫ (t : ℝ) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.setIntegral_congr measurableSet_Ioi (fun x hx ↦ ?_)
      rw [mem_Ioi] at hx
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, ← mul_assoc, one_div, ← ofReal_inv,
        ← mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, ← ofReal_mul r⁻¹, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = 1 / r * ∫ (t : ℝ) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [← ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x ↦ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, ← one_div, ofReal_div, ofReal_one]
    _ = 1 / r * (1 / r : ℂ) ^ (a - 1) * (∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [← integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]


Verifying proof (Commit 84f6d10f9a51f8c6472ec85f7cb1f39056781a29):
 := by
  have : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) = (1 / b) ^ a * Gamma a :=
    fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₂ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₃ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₄ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₅ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₆ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₇ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₈ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₉ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₀ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₁ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₂ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₃ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₄ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₅ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₆ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₇ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₈ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁₉ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₂₀ : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) =
      (1 / b) ^ a * Gamma a := fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  exact h₁₁ hr

Repaired Proof:
lemma integral_cpow_mul_exp_neg_mul_Ioi {a : ℂ} {r : ℝ} (ha : 0 < a.re) (hr : 0 < r) :
    ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a  := by
  have : ∀ (b : ℝ), 0 < b → ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(b * t)) = (1 / b) ^ a * Gamma a :=
    fun b hb ↦ integral_cpow_mul_exp_neg_Ioi ha hb
  have h₁ : ∀ (b : ℝ), 0 < b → �

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean - 2024-09-09 01:41:34.080028.
---43/200---
For theorem Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma in Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean:
theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : ℝ} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) ≤ Gamma s ^ a * Gamma t ^ b 


Original valid proof:
:= by
  let f : ℝ → ℝ → ℝ → ℝ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : ∀ c u x : ℝ, x ∈ Ioi (0 : ℝ) → 0 ≤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : ∀ c u : ℝ, ∀ᵐ x : ℝ ∂volume.restrict (Ioi 0), 0 ≤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    ∀ {c x : ℝ} (_ : 0 < c) (u : ℝ) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), ← exp_mul, ← rpow_mul hx.le]
    congr 2 <;> field_simp [hc.ne']; ring
  have f_mem_Lp :
    ∀ {c u : ℝ} (hc : 0 < c) (hu : 0 < u),
      Memℒp (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) ≠ 0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) ≠ ∞ := ENNReal.ofReal_ne_top
    rw [← memℒp_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memℒp_one_iff_integrable]
    · apply Integrable.congr (GammaIntegral_convergent hu)
      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    · refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      · exact continuous_exp.comp (continuous_const.mul continuous_id')
      · exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  · refine setIntegral_congr measurableSet_Ioi fun x hx => ?_
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [← exp_add, ← add_mul, ← neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [← rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  · rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
↔
      (a * s + b * t) * log (a * s + b * t) ≤
        a * (s * log s) + b * (t * log t) + log (Gamma s ^ a * Gamma t ^ b) := by
  have : 0 < a * s + b * t := by
    rw [← hab, add_mul, mul_add, ← add_mul, add_comm]
    refine' add_pos_of_pos_of_nonneg (mul_pos ha hs) _
    refine' mul_nonneg (le_of_lt hb) (log_nonneg _)
    rw [← le_sub_iff_add_le', sub_self, Gamma_pos_of_pos ht]
    exact le_trans (mul_pos ha hs).le (le_of_eq (by simp [hab]))
  rw [← log_le_log_iff this, log_mul, log_rpow, log_rpow, log_rpow, log_mul, log_mul]
  · simp_rw [log_Gamma]
    rw [← le_sub_iff_add_le', ← le_sub_iff_add_le', sub_sub, sub_sub, sub_le_iff_le_add',
      sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le',
      sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ←
      le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add',
      ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add',
      ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add']
    ring_nf
    simp_rw [mul_assoc]
    rw [← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ←

Attempt failure.

---44/200---
For theorem Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma in Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean:
theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : ℝ} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) ≤ Gamma s ^ a * Gamma t ^ b 


Original valid proof:
:= by
  let f : ℝ → ℝ → ℝ → ℝ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : ∀ c u x : ℝ, x ∈ Ioi (0 : ℝ) → 0 ≤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : ∀ c u : ℝ, ∀ᵐ x : ℝ ∂volume.restrict (Ioi 0), 0 ≤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    ∀ {c x : ℝ} (_ : 0 < c) (u : ℝ) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), ← exp_mul, ← rpow_mul hx.le]
    congr 2 <;> field_simp [hc.ne']; ring
  have f_mem_Lp :
    ∀ {c u : ℝ} (hc : 0 < c) (hu : 0 < u),
      Memℒp (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) ≠ 0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) ≠ ∞ := ENNReal.ofReal_ne_top
    rw [← memℒp_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memℒp_one_iff_integrable]
    · apply Integrable.congr (GammaIntegral_convergent hu)
      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    · refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      · exact continuous_exp.comp (continuous_const.mul continuous_id')
      · exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  · refine setIntegral_congr measurableSet_Ioi fun x hx => ?_
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [← exp_add, ← add_mul, ← neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [← rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  · rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx


Verifying proof (Commit 61ddcfa78d90f5773ac5739822ee3721851aa662):
↔
      (a * s + b * t) * log (a * s + b * t) ≤
        a * (s * log s) + b * (t * log t) + log (Gamma s ^ a * Gamma t ^ b) := by
  have : 0 < a * s + b * t := by
    rw [← hab, add_mul, mul_add, ← add_mul, add_comm]
    refine' add_pos_of_pos_of_nonneg (mul_pos ha hs) _
    refine' mul_nonneg (le_of_lt hb) (log_nonneg _)
    rw [← le_sub_iff_add_le', sub_self, Gamma_pos_of_pos ht]
    exact le_trans (mul_pos ha hs).le (le_of_eq (by simp [hab]))
  rw [← log_le_log_iff this, log_mul, log_rpow, log_rpow, log_rpow, log_mul, log_mul]
  · simp_rw [log_Gamma]
    rw [← le_sub_iff_add_le', ← le_sub_iff_add_le', sub_sub, sub_sub, sub_le_iff_le_add',
      sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le',
      sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ←
      le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add',
      ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add', ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add',
      ← le_sub_iff_add_le', sub_sub, sub_le_iff_le_add']
    ring_nf
    simp_rw [mul_assoc]
    rw [← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add, ← mul_add,
      ← mul_add, ←

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Integrals.lean - 2024-09-09 01:41:58.571675.
---45/200---
For theorem intervalIntegral.intervalIntegrable_rpow' in Mathlib/Analysis/SpecialFunctions/Integrals.lean:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b 


Original valid proof:
:= by
  suffices ∀ c : ℝ, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ∀ c : ℝ, 0 ≤ c → IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ∀ x ∈ Ioo 0 c, HasDerivAt (fun x : ℝ => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ≠ 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    · intro x hx; apply rpow_nonneg hx.1.le
    · refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  · exact this c hc
  · rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * π))
    rw [intervalIntegrable_iff] at m ⊢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ≤ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]


Verifying proof (Commit b15c6ea0b0ad3ac6e15420c45ece165eca6725cc):
↔
      (a = 0 ∧ b ≠ 0 ∧ 0 < r) ∨ (0 < a ∧ b < 0 ∧ r < 0) ∨ (0 < b ∧ a < 0 ∧ r < 0) := by
  rcases lt_trichotomy a 0 with (ha | rfl | ha)
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha.not_lt, hb.not_lt, intervalIntegrable_rpow_of_neg h, or_iff_left_of_imp]
    · simp [ha.not_lt, hb.le, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_right_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
    · simp [ha.not_lt, hb, intervalIntegrable_rpow_of_pos h, or_iff_left_of_imp]

Repaired Proof:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ↔
      (a = 0 ∧ b ≠ 0 ∧ 0 < r) ∨ (0 < a ∧ b < 0 ∧ r < 0) ∨ (0 < b ∧ a < 0 ∧ r < 0) := by
  rcases lt_trichotomy a 0 with (ha | rfl | ha)
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha.not_lt, hb.not_lt, intervalIntegrable_rpow_of_neg h, or_iff_left_of_imp]
    · simp [ha.not_lt, hb.le, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_right_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, intervalIntegrable_rpow_of_pos h, or_iff_left_of_imp]

Repaired Proof:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ↔
      (a = 0 ∧ b ≠ 0 ∧ 0 < r) ∨ (0 < a ∧ b < 0 ∧ r < 0) ∨ (0 < b ∧ a < 0 ∧ r < 0) := by
  rcases lt_trichotomy a 0 with (ha | rfl | ha)
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha.not_lt, hb.not_lt, intervalIntegrable_rpow_of_neg h, or_iff_left_of_imp]
    · simp [ha.not_lt, hb.le, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_right_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, intervalIntegrable_rpow_of_pos h, or_iff_left_of_imp]

Repaired Proof:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ↔
      (a = 0 ∧ b ≠ 0 ∧ 0 < r) ∨ (0 < a ∧ b < 0 ∧ r < 0) ∨ (0 < b ∧ a < 0 ∧ r < 0) := by
  rcases lt_trichotomy a 0 with (ha | rfl | ha)
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha.not_lt, hb.not_lt, intervalIntegrable_rpow_of_neg h, or_iff_left_of_imp]
    · simp [ha.not_lt, hb.le, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_right_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, intervalIntegrable_rpow_of_pos h, or_iff_left_of_imp]

Repaired Proof:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ↔
      (a = 0 ∧ b ≠ 0 ∧ 0 < r) ∨ (0 < a ∧ b < 0 ∧ r < 0) ∨ (0 < b ∧ a < 0 ∧ r < 0) := by
  rcases lt_trichotomy a 0 with (ha | rfl | ha)
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha.not_lt, hb.not_lt, intervalIntegrable_rpow_of_neg h, or_iff_left_of_imp]
    · simp [ha.not_lt, hb.le, or_iff_left_of_imp]
    · simp [ha.not_lt, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_right_of_imp]
    · simp [ha, hb, or_iff_left_of_imp]
    · simp [ha, hb, or_iff_right_of_imp]
  · rcases lt_trichotomy b 0 with (hb | rfl | hb)
    · simp [ha, hb.not_lt, or_iff_left_of_imp]
    · simp [ha, hb, or_

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean - 2024-09-09 01:42:15.595034.
---46/200---
For theorem integrable_one_add_norm in Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean:
theorem integrable_one_add_norm {r : ℝ} (hnr : (finrank ℝ E : ℝ) < r) :
    Integrable (fun x ↦ (1 + ‖x‖) ^ (-r)) μ 


Original valid proof:
:= by
  constructor
  · measurability
  have : (∫⁻ a : E, ‖(1 + ‖a‖) ^ (-r)‖₊ ∂μ) = ∫⁻ a : E, ENNReal.ofReal ((1 + ‖a‖) ^ (-r)) ∂μ :=
    lintegral_nnnorm_eq_of_nonneg fun _ => rpow_nonneg (by positivity) _
  rw [HasFiniteIntegral, this]
  exact finite_integral_one_add_norm hnr


Verifying proof (Commit 54daa04dd4fe92d1b3b2a82be4c246b43c601cab):
↔ μ ≪ volume := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · refine (Measure.AbsolutelyContinuous.mk fun s hs h's ↦ ?_).trans h.absolutelyContinuous
    have : ∀ᵐ x ∂μ, x ∈ s → (1 + ‖x‖) ^ (-r) = 0 := by
      filter_upwards with x hx
      have : ‖x‖ = 0 := by
        refine (le_of_add_le_left ?_).antisymm (norm_nonneg x)
        rwa [add_zero, Real.rpow_neg_one, inv_le_one] at hx
      simp [this]
    simp only [ae_iff, Pi.zero_apply, eventually_and] at this
    simp [this.def, h's]
  · suffices Integrable (fun x ↦ (1 + ‖x‖) ^ (-r)) (Measure.withDensity μ volume) by
      rwa [integrable_withDensity_iff_integrable_smul' h]
    have : ∀ᵐ x ∂μ, ‖x‖ ≤ 1 → (1 + ‖x‖) ^ (-r) ≤ 2 ^ (-r) := by
      filter_upwards with x hx
      simp only [norm_nonneg, add_le_add_iff_left, Real.rpow_neg_one, inv_le_inv,
        one_le_two, hx, true_and]
      exact Real.rpow_le_rpow_of_exponent_le (by linarith) (by linarith)
    refine IntegrableOn.integrable_of_forall_isLittleO
      (integrableOn_Lp_of_measure_ne_top _ one_ne_top) (fun f hf _ ↦ ?_) this
    suffices ∀ᵐ x ∂μ, ‖f x‖ ≤ (2 ^ (-r) : ℝ) * ‖x‖ ^ (finrank ℝ E - 1) by
      refine (hf.norm.const_mul (2 ^ (-r))).isLittleO.congr' ?_ EventuallyEq.rfl
      filter_upwards [this] with x hx
      simp only [norm_nonneg, mul_assoc, norm_smul, Real.norm_eq_abs, RCLike.norm_of_nonneg,
        abs_rpow_of_nonneg, abs_of_nonneg, rpow_neg_one, inv_mul_eq_div, abs_div,
        abs_norm, div_eq_inv_mul]
      rw [← Real.rpow_neg_one, ← Real.rpow_add (norm_nonneg x)]
      simp only [sub_add_cancel, neg_mul, RCLike.ofReal_neg, RCLike.ofReal_mul,
        RCLike.ofReal_rpow_of_nonneg (norm_nonneg x), mul_comm (2 : ℝ)]
      refine (Real.rpow_le_rpow_of_exponent_le ?_ ?_).trans hx
      · linarith
      · linarith
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only [ae_measure_eq_volume_of_absolutelyContinuous h, Measure.restrict_apply,
        MeasurableSet.univ, univ_inter, ae_iff] using this
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ≥0) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only [coe_nnnorm, ENNReal.coe_rpow_of_nonneg _ (by linarith),
        ENNReal.coe_mul, ENNReal.coe_pow, ENNReal.coe_ofReal, ENNReal.coe_nnreal_eq] using this
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ≥0) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only [ae_measure_eq_volume_of_absolutelyContinuous h, Measure.restrict_apply,
        MeasurableSet.univ, univ_inter, ae_iff] using this
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ≥0) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only [ae_measure_eq_volume_of_absolutelyContinuous h, Measure.restrict_apply,
        MeasurableSet.univ, univ_inter, ae_iff] using this
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ≥0) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only [ae_measure_eq_volume_of_absolutelyContinuous h, Measure.restrict_apply,
        MeasurableSet.univ, univ_inter, ae_iff] using this
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ≥0) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only [ae_measure_eq_volume_of_absolutelyContinuous h, Measure.restrict_apply,
        MeasurableSet.univ, univ_inter, ae_iff] using this
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ≥0) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only [ae_measure_eq_volume_of_absolutelyContinuous h, Measure.restrict_apply,
        MeasurableSet.univ, univ_inter, ae_iff] using this
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ≥0) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only [ae_measure_eq_volume_of_absolutelyContinuous h, Measure.restrict_apply,
        MeasurableSet.univ, univ_inter, ae_iff] using this
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ≥0) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only [ae_measure_eq_volume_of_absolutelyContinuous h, Measure.restrict_apply,
        MeasurableSet.univ, univ_inter, ae_iff] using this
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ≥0) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only [ae_measure_eq_volume_of_absolutelyContinuous h, Measure.restrict_apply,
        MeasurableSet.univ, univ_inter, ae_iff] using this
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ≥0) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only [ae_measure_eq_volume_of_absolutelyContinuous h, Measure.restrict_apply,
        MeasurableSet.univ, univ_inter, ae_iff] using this
    suffices ∀ᵐ x ∂(volume.comap (toDual E)).restrict s,
        ‖f x‖ ≤ (2 ^ (-r) : ℝ≥0) * ‖x‖ ^ (finrank ℝ E - 1) by
      simpa only

Attempt failure.

Working on Mathlib/CategoryTheory/Galois/Decomposition.lean - 2024-09-09 01:42:25.434308.
---47/200---
For theorem CategoryTheory.PreGaloisCategory.exists_galois_representative in Mathlib/CategoryTheory/Galois/Decomposition.lean:
lemma exists_galois_representative (X : C) : ∃ (A : C) (a : F.obj A),
    IsGalois A ∧ Function.Bijective (fun (f : A ⟶ X) ↦ F.map f a) 


Original valid proof:
:= by
  obtain ⟨A, u, a, h1, h2, h3⟩ := fiber_in_connected_component F (selfProd F X)
    (mkSelfProdFib F X)
  use A
  use a
  constructor
  · refine (isGalois_iff_pretransitive F A).mpr ⟨fun x y ↦ ?_⟩
    obtain ⟨fi1, hfi1⟩ := subobj_selfProd_trans h1 x
    obtain ⟨fi2, hfi2⟩ := subobj_selfProd_trans h1 y
    use fi1 ≪≫ fi2.symm
    show F.map (fi1.hom ≫ fi2.inv) x = y
    simp only [map_comp, FintypeCat.comp_apply]
    rw [hfi1, ← hfi2]
    exact congr_fun (F.mapIso fi2).hom_inv_id y
  · refine ⟨evaluation_injective_of_isConnected F A X a, ?_⟩
    intro x
    use u ≫ Pi.π _ x
    exact (selfProdProj_fiber h1) x


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
    (∀ (Y : C) (f : Y ⟶ X) (hf : F.map f a = 0), IsZero Y) := by
  have : ∀ (Y : C) (f : Y ⟶ X) (hf : F.map f a = 0), IsZero Y := by
    intro Y f hf
    have : F.map (𝟙 Y) a = 0 := by
      rw [← hf, ← Functor.map_comp, id_comp]
    exact isZero_of_map_zero F Y a this
  have : ∀ (Y : C) (f : Y ⟶ X) (hf : F.map f a = 0), IsZero Y := by
    intro Y f hf
    have : F.map (𝟙 Y) a = 0 := by
      rw [← hf, ← Functor.map_comp, id_comp]
    exact isZero_of_map_zero F Y a this
  obtain ⟨A, a, hA⟩ := Functor.exists_preimage_of_locally_surjective F X a
  refine ⟨A, a, ?_, ?_, ?_⟩
  · have : ∀ (Y : C) (f : Y ⟶ A) (g : Y ⟶ A), F.map f a = F.map g a → f = g := by
      intro Y f g hfg
      have : F.map (f ≫ 𝟙 A) a = F.map (g ≫ 𝟙 A) a := by
        rw [← Functor.map_comp, ← Functor.map_comp, comp_id, comp_id, hfg]
      simpa using this
    exact ⟨hA.1, this⟩
  · have : ∀ (Y : C) (f : Y ⟶ X) (hf : F.map f a = 0), IsZero Y := by
      intro Y f hf
      have : F.map (𝟙 Y) a = 0 := by
        rw [← hf, ← Functor.map_comp, id_comp]
      exact isZero_of_map_zero F Y a this
    refine ⟨?_, this⟩
    intro Y f hf
    obtain ⟨f', hf'⟩ := hA.2 f
    have : F.map f' a = 0 := by
      rw [← hf, ← Functor.map_comp, hf', Functor.map_id, id_comp]
    exact isZero_of_map_zero F Y a this
  · intro Y f hf
    have : F.map (𝟙 Y) a = 0 := by
      rw [← hf, ← Functor.map_comp, id_comp]
    exact isZero_of_map_zero F Y a this

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents.

Represents

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean - 2024-09-09 01:42:33.310109.
---48/200---
For theorem CategoryTheory.Limits.colimitLimitToLimitColimit_surjective in Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean:
theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) 


Original valid proof:
:= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.π (curry.obj F ⋙ Limits.colim) j x)
    let k : J → K := fun j => (z j).choose
    let y : ∀ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ∀ j,
        colimit.ι ((curry.obj F).obj j) (k j) (y j) = limit.π (curry.obj F ⋙ Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ∅
    have g : ∀ j, k j ⟶ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ∅ (by simp)
    clear_value k'
    have w :
      ∀ {j j' : J} (f : j ⟶ j'),
        colimit.ι ((curry.obj F).obj j') k' (F.map ((𝟙 j', g j') : (j', k j') ⟶ (j', k')) (y j')) =
          colimit.ι ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ⟶ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, 𝟙 (k j)) : (j, k j) ⟶ (j', k j)) ≫ (𝟙 j', g j) : (j, k j) ⟶ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ← Limit.w_apply.{u₁, v, u₁} f, ← e]
      simp only [Functor.comp_map, Types.Colimit.ι_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ∀ {j j'} (_ : j ⟶ j'), K := fun f => (w f).choose
    let gf : ∀ {j j'} (f : j ⟶ j'), k' ⟶ kf f := fun f => (w f).choose_spec.choose
    let hf : ∀ {j j'} (f : j ⟶ j'), k' ⟶ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ∀ {j j'} (f : j ⟶ j'),
        F.map ((𝟙 j', g j' ≫ gf f) : (j', k j') ⟶ (j', kf f)) (y j') =
          F.map ((f, g j ≫ hf f) : (j, k j) ⟶ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((𝟙 j', g j') : (j', k j') ⟶ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ⟶ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [← FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ∪ {k'}
    have kfO : ∀ {j j'} (f : j ⟶ j'), kf f ∈ O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ⟨j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ⟨j', Finset.mem_univ j',
              Finset.mem_image.mpr ⟨f, Finset.mem_univ _, rfl⟩⟩⟩))
    have k'O : k' ∈ O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Σ' (X Y : K) (_ : X ∈ O) (_ : Y ∈ O), X ⟶ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ⟶ j' =>
            {⟨k', kf f, k'O, kfO f, gf f⟩, ⟨k', kf f, k'O, kfO f, hf f⟩}
    obtain ⟨k'', i', s'⟩ := IsFiltered.sup_exists O H
    let i : ∀ {j j'} (f : j ⟶ j'), kf f ⟶ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ∀ {j₁ j₂ j₃ j₄} (f : j₁ ⟶ j₂) (f' : j₃ ⟶ j₄), gf f ≫ i f = hf f' ≫ i f' := by
      intros j₁ j₂ j₃ j₄ f f'
      rw [s', s']
      · exact k'O
      · exact Finset.mem_biUnion.mpr ⟨j₃, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ⟨j₄, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ⟨f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial⟩⟩⟩
      · exact Finset.mem_biUnion.mpr ⟨j₁, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ⟨j₂, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ⟨f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial⟩⟩⟩
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    · 
      apply colimit.ι (curry.obj (swap K J ⋙ F) ⋙ Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ·
        exact fun j => F.map (⟨𝟙 j, g j ≫ gf (𝟙 j) ≫ i (𝟙 j)⟩ : (j, k j) ⟶ (j, k'')) (y j)
      · 
        dsimp
        intro j j' f
        simp only [← FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ≫ gf (𝟙 j) ≫ i (𝟙 j)) : (j, k j) ⟶ (j', k'')) (y j) =
              F.map ((f, g j ≫ hf f ≫ i f) : (j, k j) ⟶ (j', k'')) (y j) := by
            rw [s (𝟙 j) f]
          _ =
              F.map ((𝟙 j', i f) : (j', kf f) ⟶ (j', k''))
                (F.map ((f, g j ≫ hf f) : (j, k j) ⟶ (j', kf f)) (y j)) := by
            rw [← FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((𝟙 j', i f) : (j', kf f) ⟶ (j', k''))
                (F.map ((𝟙 j', g j' ≫ gf f) : (j', k j') ⟶ (j', kf f)) (y j')) := by
            rw [← wf f]
          _ = F.map ((𝟙 j', g j' ≫ gf f ≫ i f) : (j', k j') ⟶ (j', k'')) (y j') := by
            rw [← FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((𝟙 j', g j' ≫ gf (𝟙 j') ≫ i (𝟙 j')) : (j', k j') ⟶ (j', k'')) (y j') := by
            rw [s f (𝟙 j'), ← s (𝟙 j') (𝟙 j')]
    · 
      apply limit_ext
      intro j
      simp only [id, ← e, Limits.ι_colimitLimitToLimitColimit_π_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.π_mk]
      refine ⟨k'', 𝟙 k'', g j ≫ gf (𝟙 j) ≫ i (𝟙 j), ?_⟩
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]


Verifying proof (Commit 31d572995d4db174b6fbfa3e3dee4f9027839468):
 := by
  intro x
  obtain ⟨j, y, h⟩ := jointly_surjective' x
  obtain ⟨k, f, h'⟩ := limit_exists_preimage (colimit.ι (F.flip) j) y
  refine' ⟨(k, f), _⟩
  simp [colimitLimitToLimitColimit, h, h']

Repaired Proof:
theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F)  := by
  intro x
  obtain ⟨j, y, h⟩ := jointly_surjective' x
  obtain ⟨k, f, h'⟩ := limit_exists_preimage (colimit.ι (F.flip) j) y
  refine ⟨(k, f), ?_⟩
  simp [colimitLimitToLimitColimit, h, h']

Repaired Proof:
theorem colimitLimitToLimitColimit_injective :
    Function.Injective (colimitLimitToLimitColimit F) := by
  rw [← Function.LeftInverse.injective_iff (g := colimitLimitToColimit F)]
  intro x
  simp only [colimitLimitToColimit, colimitLimitToLimitColimit,
    colimit.ι_desc_assoc, limit.π_map, colimit.ι_map, limit.lift_π]
  intro j
  simp only [colimit.ι_desc_assoc, limit.π_map, colimit.ι_map, limit.lift_π]
  rw [limitObjIsoLimitCompEvaluation_inv_π_app_assoc,
    colimitObjIsoColimitCompEvaluation_inv_desc]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_inv_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_inv_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_hom_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_hom_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_hom_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_inv_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_inv_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_hom_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_hom_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_hom_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_inv_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_hom_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_inv_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_inv_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_hom_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_inv_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_hom_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_hom_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_inv_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_hom_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_inv_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_inv_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_hom_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_inv_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_hom_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_hom_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_inv_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_hom_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIsoColimitCompEvaluation_inv_app,
    colimit.ι_map, colim_map, limitObjIsoLimitCompEvaluation_inv_π_app,
    colimit.pre_desc, colim_pre, limit.lift_π_assoc,
    colimitLimitToColimit_π_app_mk]
  simp only [Functor.comp_obj, Functor.const_obj_obj, colimit.ι_desc,
    limit.lift_π, colimitObjIso

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Final.lean - 2024-09-09 01:42:39.018919.
---49/200---
For theorem CategoryTheory.Functor.final_of_comp_full_faithful in Mathlib/CategoryTheory/Limits/Final.lean:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where



Original valid proof:
  out d := isConnected_of_equivalent (StructuredArrow.post d F G).asEquivalence.symm


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
    out _ _ _ := by
      intro c f hc
      have : IsIso (G.map (F.map f)) := by
        rw [← hc]
        infer_instance
      have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
      exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [← hc]
      infer_instance
    have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
    exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [← hc]
      infer_instance
    have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
    exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [← hc]
      infer_instance
    have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
    exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [← hc]
      infer_instance
    have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
    exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [← hc]
      infer_instance
    have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
    exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [← hc]
      infer_instance
    have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
    exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [← hc]
      infer_instance
    have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
    exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [← hc]
      infer_instance
    have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
    exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [← hc]
      infer_instance
    have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
    exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [← hc]
      infer_instance
    have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
    exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [← hc]
      infer_instance
    have : IsIso (F.map f) := isIso_of_isIso_of_full_faithful G (F.map f)
    exact ⟨(inv (F.map f)).op, ⟨Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)⟩⟩

Repaired Proof:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ := by
    intro c f hc
    have : IsIso (G.map (F.map f)) := by
      rw [

Attempt failure.

Working on Mathlib/CategoryTheory/MorphismProperty/Basic.lean - 2024-09-09 01:42:51.468521.
---50/200---
For theorem CategoryTheory.MorphismProperty.RespectsIso.isoClosure_eq in Mathlib/CategoryTheory/MorphismProperty/Basic.lean:
lemma RespectsIso.isoClosure_eq {P : MorphismProperty C} (hP : P.RespectsIso) :
    P.isoClosure = P 


Original valid proof:
:= by rwa [isoClosure_eq_iff]


Verifying proof (Commit 6830b5e612c6f4431fee7e89ec01560ae5118e5e):
 := by
  ext X Y f
  constructor
  · rintro ⟨X', Y', f', hf', ⟨e⟩⟩
    exact hP.arrow_mk_iso_iff e.symm |>.1 hf'
  · exact fun hf => ⟨X, Y, f, hf, 𝟙 _⟩

lemma MorphismProperty.isStableUnderComposition_isoClosure {P : MorphismProperty C} :
    (P.isoClosure.RespectsIso → P.isStableUnderComposition) := by
  rintro ⟨hP₁, hP₂⟩
  constructor
  · rintro X Y Z f g ⟨X', Y', f', hf', ⟨e⟩⟩ ⟨X'', Y'', g', hg', ⟨e'⟩⟩
    exact hP₁.arrow_mk_iso_iff (e.symm.trans e') |>.2 (hP₂.comp_mem f' g' hf' hg')
  · rintro X Y Z f g ⟨X', Y', f', hf', ⟨e⟩⟩
    exact hP₁.arrow_mk_iso_iff e |>.1 (hP₂.comp_mem f g hf' hf')

lemma MorphismProperty.isStableUnderInverse_isoClosure {P : MorphismProperty C} :
    (P.isoClosure.RespectsIso → P.IsStableUnderInverse) := by
  rintro ⟨hP₁, hP₂⟩
  constructor
  · rintro X Y f ⟨X', Y', f', hf', ⟨e⟩⟩
    exact hP₁.arrow_mk_iso_iff e |>.1 hf'
  · rintro X Y f ⟨X', Y', f', hf', ⟨e⟩⟩
    exact hP₁.arrow_mk_iso_iff e.symm |>.1 hf'

lemma MorphismProperty.isStableUnderComposition_iff_isoClosure_eq {P : MorphismProperty C} :
    P.IsStableUnderComposition ↔ P.isoClosure = P := by
  constructor
  · intro hP
    apply le_antisymm
    · intro X Y f hf
      exact ⟨X, Y, f, hf, 𝟙 _⟩
    · rintro X Y f ⟨X', Y', f', hf', ⟨e⟩⟩
      exact hP.comp_mem _ _ hf' hf
  · intro hP
    rw [hP]
    exact MorphismProperty.isStableUnderComposition_isoClosure (MorphismProperty.RespectsIso.isoClosure_respectsIso P)

lemma MorphismProperty.isStableUnderInverse_iff_isoClosure_eq {P : MorphismProperty C} :
    P.IsStableUnderInverse ↔ P.isoClosure = P := by
  constructor
  · intro hP
    apply le_antisymm
    · intro X Y f hf
      exact ⟨X, Y, f, hf, 𝟙 _⟩
    · rintro X Y f ⟨X', Y', f', hf', ⟨e⟩⟩
      exact hP.inv_mem _ hf'
  · intro hP
    rw [hP]
    exact MorphismProperty.isStableUnderInverse_isoClosure (MorphismProperty.RespectsIso.isoClosure_respectsIso P)

lemma MorphismProperty.isStableUnderComposition_iff_isStableUnderComposition_isoClosure {P : MorphismProperty C} :
    P.IsStableUnderComposition ↔ (P.isoClosure.IsStableUnderComposition) := by
  constructor
  · intro hP
    exact MorphismProperty.isStableUnderComposition_isoClosure hP
  · intro hP
    rw [MorphismProperty.isStableUnderComposition_iff_isoClosure_eq]
    exact hP.le_isoClosure

lemma MorphismProperty.isStableUnderInverse_iff_isStableUnderInverse_isoClosure {P : MorphismProperty C} :
    P.IsStableUnderInverse ↔ (P.isoClosure.IsStableUnderInverse) := by
  constructor
  · intro hP
    exact MorphismProperty.isStableUnderInverse_isoClosure hP
  · intro hP
    rw [MorphismProperty.isStableUnderInverse_iff_isoClosure_eq]
    exact hP.le_isoClosure

lemma MorphismProperty.isStableUnderComposition_iff_isStableUnderComposition_respectsIso {P : MorphismProperty C} :
    P.IsStableUnderComposition ↔ (P.RespectsIso.IsStableUnderComposition) := by
  constructor
  · intro hP
    constructor
    · rintro _ _ _ _ _ _ ⟨X', Y', f', hf', ⟨e⟩⟩ ⟨X'', Y'', g', hg', ⟨e'⟩⟩
      exact hP.comp_mem _ _ hf' hg'
    · rintro _ _ _ _ _ hf
      exact hP.comp_mem _ _ hf hf
  · intro hP
    rw [MorphismProperty.isStableUnderComposition_iff_isoClosure_eq]
    apply le_antisymm
    · intro X Y f ⟨X', Y', f', hf', ⟨e⟩⟩
      exact hP.comp_mem _ _ hf' hf'
    · rintro X Y f hf
      exact ⟨X, Y, f, hf, 𝟙 _⟩

lemma MorphismProperty.isStableUnderInverse_iff_isStableUnderInverse_respectsIso {P : MorphismProperty C} :
    P.IsStableUnderInverse ↔ (P.RespectsIso.IsStableUnderInverse) := by
  constructor
  · intro hP
    constructor
    · rintro _ _ _ _ hf
      exact hP.inv_mem hf
    · rintro _ _ _ _ hf
      exact hP.inv_mem hf
  · intro hP
    rw [MorphismProperty.isStableUnderInverse_iff_isoClosure_eq]
    apply le_antisymm
    · intro X Y f ⟨X', Y', f', hf', ⟨e⟩⟩
      exact hP.inv_mem _ hf'
    · rintro X Y f hf
      exact ⟨X, Y, f, hf, 𝟙 _⟩

lemma MorphismProperty.isStableUnderComposition_respectsIso_iff_isStableUnderComposition {P : MorphismProperty C} :
    (P.RespectsIso.IsStableUnderComposition) ↔ P.IsStableUnderComposition := by
  constructor
  · intro hP
    constructor
    · rintro _ _ _ _ _ _ ⟨X', Y', f', hf', ⟨e⟩⟩ ⟨X'', Y'', g', hg', ⟨e'⟩⟩
      exact hP.comp_mem _ _ hf' hg'
    · rintro _ _ _ _ _ hf
      exact hP.comp_mem _ _ hf hf
  · intro hP
    constructor
    · rintro _ _ _ _ _ _ ⟨X', Y', f', hf', ⟨e⟩⟩ ⟨X'', Y'', g', hg', ⟨e'⟩⟩
      exact hP.comp_mem _ _ hf' hg'
    · rintro _ _ _ _ _ hf
      exact hP.comp_mem _ _ hf hf

lemma MorphismProperty.isStableUnderInverse_respectsIso_iff_isStableUnderInverse {P : MorphismProperty C} :
    (P.RespectsIso.IsStableUnderInverse) ↔ P.IsStableUnderInverse := by
  constructor
  · intro hP
    constructor
    · rintro _ _ _ _ hf
      exact hP.inv_mem hf
    · rintro _ _ _ _ hf
      exact hP.inv_mem hf
  · intro hP
    constructor
    · rintro _ _ _ _ hf
      exact hP.inv_mem hf
    · rintro _ _ _ _ hf
      exact hP.inv_mem hf

lemma MorphismProperty.isStableUnderComposition_respectsIso_iff_isStableUnderComposition_respectsIso {P : MorphismProperty C} :
    (P.RespectsIso.IsStableUnderComposition) ↔ (P.isoClosure.RespectsIso.IsStableUnderComposition) := by
 

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Coverage.lean - 2024-09-09 01:42:56.619592.
---51/200---
For theorem CategoryTheory.Presieve.factorsThru_of_le in Mathlib/CategoryTheory/Sites/Coverage.lean:
lemma factorsThru_of_le {X : C} (S T : Presieve X) (h : S ≤ T) :
    S.FactorsThru T 


Original valid proof:
:=
  fun Y g hg => ⟨Y, 𝟙 _, g, h _ hg, by simp⟩


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):
→ S.FactorsThru (generate T) :=
  fun ⟨Y, p, f, hf⟩ => ⟨Y, p, f, Presieve.le_generate _ _ h hf⟩

lemma factorsThru_of_le_sieve {X : C} (S : Presieve X) (T : Sieve X) (h : S ≤ T) :
    S.FactorsThru T.arrows :=
  fun ⟨Y, p, f, hf⟩ => ⟨Y, p, f, h _ hf⟩

lemma factorsThru_sieve_of_le {X : C} (S : Presieve X) (T : Sieve X) (h : S ≤ T) :
    T.FactorsThru S.arrows :=
  fun ⟨Y, p, f, hf⟩ => ⟨Y, p, f, h _ hf⟩

lemma factorsThru_of_isPullback {X Y : C} {S : Presieve X} {f : Y ⟶ X}
    (h : S.Factors f) {W : C} {g : W ⟶ Y} {G : W ⟶ X} (H : IsPullback g f G (S.arrowOfFactors f h))
    {T : Presieve W} (hT : T.Factors G) :
    T.Factors g := by
  rcases h with ⟨X', f', h', ⟨e⟩⟩
  rcases hT with ⟨X'', f'', h'', ⟨⟨W', hW', α', β', γ', δ', comm⟩⟩⟩
  have : f' ≫ G = f'' ≫ G := by
    have : f' ≫ G = f' ≫ (f ≫ e.hom) ≫ G := by rw [Category.assoc, e.hom_inv_id_assoc]
    rw [this, ← Category.assoc, comm, Category.assoc, Category.assoc, δ'_comp_g]
  have : f' = f'' := by
    rw [← cancel_mono G, Category.assoc, this, ← Category.assoc, comm, Category.assoc, δ'_comp_g]
  subst this
  exact ⟨X', f', h', ⟨e⟩⟩

lemma factorsThru_of_comp_isPullback {X Y : C} {S : Presieve X} {f : Y ⟶ X}
    (h : S.Factors f) {W : C} {g : W ⟶ Y} {G : W ⟶ X} (H : IsPullback g f G (S.arrowOfFactors f h))
    {Z : C} {T : Presieve Z} (hT : T.Factors (g ≫ f)) :
    T.Factors g := by
  rcases hT with ⟨W', f', h', ⟨e⟩⟩
  rcases h with ⟨X', f'', h'', ⟨⟨W'', hW'', α, β, γ, δ, comm⟩⟩⟩
  have : f' ≫ G = f'' ≫ G := by
    have : f' ≫ G = f' ≫ (f ≫ e.hom) ≫ G := by rw [Category.assoc, e.hom_inv_id_assoc]
    rw [this, ← Category.assoc, comm, Category.assoc, Category.assoc, δ_comp_g]
  have : f' = f'' := by
    rw [← cancel_mono G, Category.assoc, this, ← Category.assoc, comm, Category.assoc, δ_comp_g]
  subst this
  exact ⟨W', f', h', ⟨e⟩⟩

lemma factorsThru_of_comp_isPullback' {X Y : C} {S : Presieve X} {f : Y ⟶ X}
    (h : S.Factors f) {W : C} {g : W ⟶ Y} {G : W ⟶ X} (H : IsPullback g f G (S.arrowOfFactors f h))
    {Z : C} {T : Presieve Z} (hT : T.Factors (g ≫ f)) :
    T.Factors g := by
  rcases hT with ⟨W', f', h', ⟨e⟩⟩
  rcases h with ⟨X', f'', h'', ⟨⟨W'', hW'', α, β, γ, δ, comm⟩⟩⟩
  have : f' ≫ G = f'' ≫ G := by
    have : f' ≫ G = f' ≫ (f ≫ e.hom) ≫ G := by rw [Category.assoc, e.hom_inv_id_assoc]
    rw [this, ← Category.assoc, comm, Category.assoc, Category.assoc, δ_comp_g]
  have : f' = f'' := by
    rw [← cancel_mono G, Category.assoc, this, ← Category.assoc, comm, Category.assoc, δ_comp_g]
  subst this
  exact ⟨W', f', h', ⟨e⟩⟩

lemma factorsThru_of_comp_isPullback'' {X Y : C} {S : Presieve X} {f : Y ⟶ X}
    (h : S.Factors f) {W : C} {g : W ⟶ Y} {G : W ⟶ X} (H : IsPullback g f G (S.arrowOfFactors f h))
    {Z : C} {T : Presieve Z} (hT : T.Factors (g ≫ f)) :
    T.Factors g := by
  rcases hT with ⟨W', f', h', ⟨e⟩⟩
  rcases h with ⟨X', f'', h'', ⟨⟨W'', hW'', α, β, γ, δ, comm⟩⟩⟩
  have : f' ≫ G = f'' ≫ G := by
    have : f' ≫ G = f' ≫ (f ≫ e.hom) ≫ G := by rw [Category.assoc, e.hom_inv_id_assoc]
    rw [this, ← Category.assoc, comm, Category.assoc, Category.assoc, δ_comp_g]
  have : f' = f'' := by
    rw [← cancel_mono G, Category.assoc, this, ← Category.assoc, comm, Category.assoc, δ_comp_g]
  subst this
  exact ⟨W', f', h', ⟨e⟩⟩

lemma factorsThru_of_comp_isPullback''' {X Y : C} {S : Presieve X} {f : Y ⟶ X}
    (h : S.Factors f) {W : C} {g : W ⟶ Y} {G : W ⟶ X} (H : IsPullback g f G (S.arrowOfFactors f h))
    {Z : C} {T : Presieve Z} (hT : T.Factors (g ≫ f)) :
    T.Factors g := by
  rcases hT with ⟨W', f', h', ⟨e⟩⟩
  rcases h with ⟨X', f'', h'', ⟨⟨W'', hW'', α, β, γ, δ, comm⟩⟩⟩
  have : f' ≫ G = f'' ≫ G := by
    have : f' ≫ G = f' ≫ (f ≫ e.hom) ≫ G := by rw [Category.assoc, e.hom_inv_id_assoc]
    rw [this, ← Category.assoc, comm, Category.assoc, Category.assoc, δ_comp_g]
  have : f' = f'' := by
    rw [← cancel_mono G, Category.assoc, this, ← Category.assoc, comm, Category.assoc, δ_comp_g]
  subst this
  exact ⟨W', f', h', ⟨e⟩⟩

lemma factorsThru_of_comp_isPullback'''' {X Y : C} {S : Presieve X} {f : Y ⟶ X}
    (h : S.Factors f) {W : C} {g : W ⟶ Y} {G : W ⟶ X} (H : IsPullback g f G (S.arrowOf

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean - 2024-09-09 01:43:03.077856.
---52/200---
For theorem CategoryTheory.Equalizer.Presieve.Arrows.SecondObj.ext in Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean:
lemma SecondObj.ext (z₁ z₂ : SecondObj P S) (h : ∀ (Y Z : C) (g : Z ⟶ Y) (f : Y ⟶ X)
    (hf : S.arrows f), (Pi.π _ ⟨Y, Z, g, f, hf⟩ : SecondObj P S ⟶ _) z₁ =
      (Pi.π _ ⟨Y, Z, g, f, hf⟩ : SecondObj P S ⟶ _) z₂) : z₁ = z₂ 


Original valid proof:
:= by
  apply Limits.Types.limit_ext
  rintro ⟨⟨Y, Z, g, f, hf⟩⟩
  apply h


Verifying proof (Commit f76dc92a63457a8b36463cee1fe33a048c0ba0ce):
 := by
  apply Limits.limit.hom_ext
  rintro ⟨⟨Y, Z, g, f, hf⟩⟩
  apply h

Repackaging the above as a natural isomorphism:

@[simps]
def secondObjNatIso : (secondObjStruct P S).functor ≅ (secondObjStruct' P S).functor where
  hom := { app := fun X => X.2.2.2.2 }
  inv := { app := fun X => ⟨X.1.1.1.1, X.1.1.1.2, X.1.1.2, X.1.2, X.2⟩ }
  hom_inv_id := by
    funext X
    apply SecondObj.ext
    rintro Y Z g f hf
    rfl
  inv_hom_id := by
    funext X
    rfl

@[simp]
lemma secondObjNatIso_hom_app (X : SecondObjStruct.T P S) :
    (secondObjNatIso P S).hom.app X = X.snd.snd.snd.snd := rfl

@[simp]
lemma secondObjNatIso_inv_app (X : SecondObjStruct'.T P S) :
    (secondObjNatIso P S).inv.app X = ⟨X.1.1.1.1, X.1.1.1.2, X.1.1.2, X.1.2, X.2⟩ := rfl

@[simp]
lemma secondObjNatIso_hom_app' (X : SecondObjStruct'.T P S) :
    (secondObjNatIso P S).hom.app X = X.snd.snd.snd.snd := rfl

@[simp]
lemma secondObjNatIso_inv_app' (X : SecondObjStruct.T P S) :
    (secondObjNatIso P S).inv.app X = ⟨X.1.1.1.1, X.1.1.1.2, X.1.1.2, X.1.2, X.2⟩ := rfl

@[simp]
lemma secondObjNatIso_hom_app_π (X : SecondObjStruct.T P S) (Y : C) (g : X.1.1.2 ⟶ Y)
    (f : X.1.1.1.1 ⟶ X.1.1.1.2) (hf : S.arrows f) :
    (secondObjNatIso P S).hom.app X ≫ Pi.π _ ⟨Y, X.1.1.2, g, f, hf⟩ =
      Pi.π _ ⟨X.1.1.1.2, X.1.1.2, f, g, hf⟩ := by
  dsimp
  rfl

@[simp]
lemma secondObjNatIso_hom_app_π' (X : SecondObjStruct'.T P S) (Y : C) (g : X.1.2 ⟶ Y)
    (f : X.1.1.1.1 ⟶ X.1.1.1.2) (hf : S.arrows f) :
    (secondObjNatIso P S).hom.app X ≫ Pi.π _ ⟨Y, X.1.2, g, f, hf⟩ =
      Pi.π _ ⟨X.1.1.1.2, X.1.2, f, g, hf⟩ := by
  dsimp
  rfl

@[simp]
lemma secondObjNatIso_inv_app_π (X : SecondObjStruct'.T P S) (Y : C) (g : X.1.2 ⟶ Y)
    (f : X.1.1.1.1 ⟶ X.1.1.1.2) (hf : S.arrows f) :
    (secondObjNatIso P S).inv.app X ≫ Pi.π _ ⟨Y, X.1.2, g, f, hf⟩ =
      Pi.π _ ⟨X.1.1.1.2, X.1.2, f, g, hf⟩ := by
  dsimp
  rfl

@[simp]
lemma secondObjNatIso_inv_app_π' (X : SecondObjStruct.T P S) (Y : C) (g : X.1.1.2 ⟶ Y)
    (f : X.1.1.1.1 ⟶ X.1.1.1.2) (hf : S.arrows f) :
    (secondObjNatIso P S).inv.app X ≫ Pi.π _ ⟨Y, X.1.1.2, g, f, hf⟩ =
      Pi.π _ ⟨X.1.1.1.2, X.1.1.2, f, g, hf⟩ := by
  dsimp
  rfl

@[simp]
lemma secondObjNatIso_hom_app_id (X : SecondObjStruct.T P S) :
    (secondObjNatIso P S).hom.app X ≫ Pi.π _ (𝟙 X.1.1.1.2) = Pi.π _ (𝟙 X.1.1.2) := by
  dsimp
  rfl

@[simp]
lemma secondObjNatIso_hom_app_id' (X : SecondObjStruct'.T P S) :
    (secondObjNatIso P S).hom.app X ≫ Pi.π _ (𝟙 X.1.1.1.2) = Pi.π _ (𝟙 X.1.2) := by
  dsimp
  rfl

@[simp]
lemma secondObjNatIso_inv_app_id (X : SecondObjStruct'.T P S) :
    (secondObjNatIso P S).inv.app X ≫ Pi.π _ (𝟙 X.1.1.1.2) = Pi.π _ (𝟙 X.1.2) := by
  dsimp
  rfl

@[simp]
lemma secondObjNatIso_inv_app_id' (X : SecondObjStruct.T P S) :
    (secondObjNatIso P S).inv.app X ≫ Pi.π _ (𝟙 X.1.1.1.2) = Pi.π _ (𝟙 X.1.1.2) := by
  dsimp
  rfl

@[simp]
lemma secondObjNatIso_hom_app_id_assoc (X : SecondObjStruct.T P S) {Y : C} (g : X.1.1.2 ⟶ Y)
    (f : X.1.1.1.1 ⟶ X.1.1.1.2) (hf : S.arrows f) {Z : C} (h : Y ⟶ Z) :
    (secondObjNatIso P S).hom.app X ≫ Pi.π _ ⟨Y, X.1.1.2, g, f, hf⟩ ≫ h =
      Pi.π _ ⟨X.1.1.1.2, X.1.1.2, f, g, hf⟩ ≫ h := by
  dsimp
  rfl

@[simp]
lemma secondObjNatIso_hom_app_id_assoc' (X : SecondObjStruct'.T P S) {Y : C} (g : X.1.2 ⟶ Y)
    (f : X.1.1.1.1 ⟶ X.1.1.1.2) (hf : S.arrows f) {Z : C} (h : Y ⟶ Z) :
    (secondObjNatIso P S).hom.app X ≫ Pi.π _ ⟨Y, X.1.2, g, f, hf⟩ ≫ h =
      Pi.π _ ⟨X.1.1.1.2, X.1.2, f, g, hf⟩ ≫ h := by
  dsimp
  rfl

@[simp]
lemma secondObjNatIso_inv_app_id_assoc (X : SecondObjStruct'.T P S) {Y : C} (g : X.1.2 ⟶ Y)
    (f : X.1.1.1.1 ⟶ X.1.1.1.2) (hf : S.arrows f) {Z : C} (h : Y ⟶ Z) :
    (secondObjNatIso P S).inv.app X ≫ Pi.π _ ⟨Y, X.1.2, g, f, hf⟩ ≫ h =
      Pi.π _ ⟨X.1

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/SheafHom.lean - 2024-09-09 01:43:09.543198.
---53/200---
For theorem CategoryTheory.PresheafHom.IsSheafFor.exists_app in Mathlib/CategoryTheory/Sites/SheafHom.lean:
lemma exists_app :
    ∃ (φ : F.obj (op Y) ⟶ G.obj (op Y)),
      ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)), φ ≫ G.map p.op =
        F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ 


Original valid proof:
:= by
  let c : Cone ((Presieve.diagram (Sieve.pullback g S).arrows).op ⋙ G) :=
    { pt := F.obj (op Y)
      π :=
        { app := fun ⟨Z, hZ⟩ => F.map Z.hom.op ≫ (x _ hZ).app (op (Over.mk (𝟙 _)))
          naturality := by
            rintro ⟨Z₁, hZ₁⟩ ⟨Z₂, hZ₂⟩ ⟨f : Z₂ ⟶ Z₁⟩
            dsimp
            rw [id_comp, assoc]
            have H := hx f.left (𝟙 _) hZ₁ hZ₂ (by simp)
            simp only [presheafHom_obj, unop_op, Functor.id_obj, op_id,
              FunctorToTypes.map_id_apply] at H
            let φ : Over.mk f.left ⟶ Over.mk (𝟙 Z₁.left) := Over.homMk f.left
            have H' := (x (Z₁.hom ≫ g) hZ₁).naturality φ.op
            dsimp at H H' ⊢
            erw [← H, ← H', presheafHom_map_app_op_mk_id, ← F.map_comp_assoc,
              ← op_comp, Over.w f] } }
  use (hG g).lift c
  intro Z p hp
  exact ((hG g).fac c ⟨Over.mk p, hp⟩)


Verifying proof (Commit caa00a446713ac188017c89bf0a19da029f0c735):
≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ :=
  let ⟨φ, hφ⟩ := exists_coyoneda_map F G x y hg
  ⟨φ.app (op Y), fun p hp =>
    (hφ p hp).trans <|
      congr_app (congr_app (congr_app (x (p ≫ g) hp).4 ⟨Over.mk (𝟙 Z), 𝟙 _⟩)
        ⟨Over.mk (𝟙 Z), 𝟙 _⟩) ⟨Over.mk (𝟙 Z), 𝟙 _⟩⟩

Repaired Proof:
lemma exists_app :
    ∃ (φ : F.obj (op Y) ⟶ G.obj (op Y)),
      ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)), φ ≫ G.map p.op =
        F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ :=
  let ⟨φ, hφ⟩ := exists_coyoneda_map F G x y hg
  ⟨φ.app (op Y), fun p hp =>
    (hφ p hp).trans <|
      congr_app (congr_app (congr_app (x (p ≫ g) hp).4 ⟨Over.mk (𝟙 Z), 𝟙 _⟩)
        ⟨Over.mk (𝟙 Z), 𝟙 _⟩) ⟨Over.mk (𝟙 Z), 𝟙 _⟩⟩

Repaired Proof:
lemma exists_app :
    ∃ (φ : F.obj (op Y) ⟶ G.obj (op Y)),
      ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)), φ ≫ G.map p.op =
        F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ :=
  let ⟨φ, hφ⟩ := exists_coyoneda_map F G x y hg
  ⟨φ.app (op Y), fun p hp =>
    (hφ p hp).trans <|
      congr_app (congr_app (congr_app (x (p ≫ g) hp).4 ⟨Over.mk (𝟙 Z), 𝟙 _⟩)
        ⟨Over.mk (𝟙 Z), 𝟙 _⟩) ⟨Over.mk (𝟙 Z), 𝟙 _⟩⟩

Repaired Proof:
lemma exists_app :
    ∃ (φ : F.obj (op Y) ⟶ G.obj (op Y)),
      ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)), φ ≫ G.map p.op =
        F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ :=
  let ⟨φ, hφ⟩ := exists_coyoneda_map F G x y hg
  ⟨φ.app (op Y), fun p hp =>
    (hφ p hp).trans <|
      congr_app (congr_app (congr_app (x (p ≫ g) hp).4 ⟨Over.mk (𝟙 Z), 𝟙 _⟩)
        ⟨Over.mk (𝟙 Z), 𝟙 _⟩) ⟨Over.mk (𝟙 Z), 𝟙 _⟩⟩

Repaired Proof:
lemma exists_app :
    ∃ (φ : F.obj (op Y) ⟶ G.obj (op Y)),
      ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)), φ ≫ G.map p.op =
        F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ :=
  let ⟨φ, hφ⟩ := exists_coyoneda_map F G x y hg
  ⟨φ.app (op Y), fun p hp =>
    (hφ p hp).trans <|
      congr_app (congr_app (congr_app (x (p ≫ g) hp).4 ⟨Over.mk (𝟙 Z), 𝟙 _⟩)
        ⟨Over.mk (𝟙 Z), 𝟙 _⟩) ⟨Over.mk (𝟙 Z), 𝟙 _⟩⟩

Repaired Proof:
lemma exists_app :
    ∃ (φ : F.obj (op Y) ⟶ G.obj (op Y)),
      ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)), φ ≫ G.map p.op =
        F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ :=
  let ⟨φ, hφ⟩ := exists_coyoneda_map F G x y hg
  ⟨φ.app (op Y), fun p hp =>
    (hφ p hp).trans <|
      congr_app (congr_app (congr_app (x (p ≫ g) hp).4 ⟨Over.mk (𝟙 Z), 𝟙 _⟩)
        ⟨Over.mk (𝟙 Z), 𝟙 _⟩) ⟨Over.mk (𝟙 Z), 𝟙 _⟩⟩

Repaired Proof:
lemma exists_app :
    ∃ (φ : F.obj (op Y) ⟶ G.obj (op Y)),
      ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)), φ ≫ G.map p.op =
        F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ :=
  let ⟨φ, hφ⟩ := exists_coyoneda_map F G x y hg
  ⟨φ.app (op Y), fun p hp =>
    (hφ p hp).trans <|
      congr_app (congr_app (congr_app (x (p ≫ g) hp).4 ⟨Over.mk (𝟙 Z), 𝟙 _⟩)
        ⟨Over.mk (𝟙 Z), 𝟙 _⟩) ⟨Over.mk (𝟙 Z), 𝟙 _⟩⟩

Repaired Proof:
lemma exists_app :
    ∃ (φ : F.obj (op Y) ⟶ G.obj (op Y)),
      ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)), φ ≫ G.map p.op =
        F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ :=
  let ⟨φ, hφ⟩ := exists_coyoneda_map F G x y hg
  ⟨

Attempt failure.

Working on Mathlib/Combinatorics/Additive/RuzsaCovering.lean - 2024-09-09 01:43:17.392827.
---54/200---
For theorem Finset.exists_subset_mul_div in Mathlib/Combinatorics/Additive/RuzsaCovering.lean:
theorem exists_subset_mul_div (ht : t.Nonempty) :
    ∃ u : Finset α, u.card * t.card ≤ (s * t).card ∧ s ⊆ u * t / t 


Original valid proof:
:= by
  haveI : ∀ u, Decidable ((u : Set α).PairwiseDisjoint (· • t)) := fun u ↦ Classical.dec _
  set C := s.powerset.filter fun u ↦ u.toSet.PairwiseDisjoint (· • t)
  obtain ⟨u, hu, hCmax⟩ := C.exists_maximal (filter_nonempty_iff.2
    ⟨∅, empty_mem_powerset _, by rw [coe_empty]; exact Set.pairwiseDisjoint_empty⟩)
  rw [mem_filter, mem_powerset] at hu
  refine ⟨u,
    (card_mul_iff.2 <| pairwiseDisjoint_smul_iff.1 hu.2).ge.trans
      (card_le_card <| mul_subset_mul_right hu.1),
    fun a ha ↦ ?_⟩
  rw [mul_div_assoc]
  by_cases hau : a ∈ u
  · exact subset_mul_left _ ht.one_mem_div hau
  by_cases H : ∀ b ∈ u, Disjoint (a • t) (b • t)
  · refine (hCmax _ ?_ <| ssubset_insert hau).elim
    rw [mem_filter, mem_powerset, insert_subset_iff, coe_insert]
    exact ⟨⟨ha, hu.1⟩, hu.2.insert fun _ hb _ ↦ H _ hb⟩
  push_neg at H
  simp_rw [not_disjoint_iff, ← inv_smul_mem_iff] at H
  obtain ⟨b, hb, c, hc₁, hc₂⟩ := H
  refine mem_mul.2 ⟨b, hb, a / b, ?_, by simp⟩
  exact mem_div.2 ⟨_, hc₂, _, hc₁, by simp [inv_mul_eq_div]⟩


Verifying proof (Commit 93fe16b79b4d74f8ddaec22ca9d80d09915ac92b):
∧ t ⊆ u * t / u := by
  obtain ⟨a, ha⟩ := ht
  have ha' : a ∉ t.erase a := not_mem_erase _ _
  have ha'' : t.erase a ⊆ t := ssubset_of_subset_of_ne (erase_subset _ _) (ne_of_mem_of_not_mem ha ha')
  obtain ⟨u, hu⟩ :=
    exists_subset_mul_div_of_subset_of_subset_erase (subset_insert _ _) ha''
      (subset_insert _ _) (card_pos.2 ⟨a, ha⟩)
  refine' ⟨u, _, subset_insert _ _, hu.2.trans _⟩
  · rw [card_insert_of_not_mem ha', ← hu.1]
    refine' le_trans (card_mul_le _ _) (Nat.mul_le_mul_left _ (card_le_card (insert_subset_insert _ _)))
    simpa only [card_erase_of_mem ha, Nat.pred_succ] using card_le_card (erase_subset _ _)
  rw [div_insert_of_not_mem ha', mul_insert, union_subset_iff]
  exact ⟨hu.2.1, union_subset (hu.2.2.trans <| mul_subset_mul_left <| subset_insert _ _)
    (mul_subset_mul_right ha'')⟩

Repaired Proof:
theorem exists_subset_mul_div (ht : t.Nonempty) :
    ∃ u : Finset α, u.card * t.card ≤ (s * t).card ∧ s ⊆ u * t / t ∧ t ⊆ u * t / u := by
  obtain ⟨a, ha⟩ := ht
  have ha' : a ∉ t.erase a := not_mem_erase _ _
  have ha'' : t.erase a ⊆ t := ssubset_of_subset_of_ne (erase_subset _ _) (ne_of_mem_of_not_mem ha ha')
  obtain ⟨u, hu⟩ :=
    exists_subset_mul_div_of_subset_of_subset_erase (subset_insert _ _) ha''
      (subset_insert _ _) (card_pos.2 ⟨a, ha⟩)
  refine ⟨u, ?_, subset_insert _ _, hu.2.trans ?_⟩
  · rw [card_insert_of_not_mem ha', ← hu.1]
    refine le_trans (card_mul_le _ _) (Nat.mul_le_mul_left _ (card_le_card (insert_subset_insert _ _)))
    simpa only [card_erase_of_mem ha, Nat.pred_succ] using card_le_card (erase_subset _ _)
  rw [div_insert_of_not_mem ha', mul_insert, union_subset_iff]
  exact ⟨hu.2.1, union_subset (hu.2.2.trans <| mul_subset_mul_left <| subset_insert _ _)
    (mul_subset_mul_right ha'')⟩

Repaired Proof:
theorem exists_subset_mul_div (ht : t.Nonempty) :
    ∃ u : Finset α, u.card * t.card ≤ (s * t).card ∧ s ⊆ u * t / t ∧ t ⊆ u * t / u := by
  obtain ⟨a, ha⟩ := ht
  have ha' : a ∉ t.erase a := not_mem_erase _ _
  have ha'' : t.erase a ⊆ t := ssubset_of_subset_of_ne (erase_subset _ _) (ne_of_mem_of_not_mem ha ha')
  obtain ⟨u, hu⟩ :=
    exists_subset_mul_div_of_subset_of_subset_erase (subset_insert _ _) ha''
      (subset_insert _ _) (card_pos.2 ⟨a, ha⟩)
  refine ⟨u, ?_, subset_insert _ _, hu.2.trans ?_⟩
  · rw [card_insert_of_not_mem ha', ← hu.1]
    refine le_trans (card_mul_le _ _) (Nat.mul_le_mul_left _ (card_le_card (insert_subset_insert _ _)))
    simpa only [card_erase_of_mem ha, Nat.pred_succ] using card_le_card (erase_subset _ _)
  rw [div_insert_of_not_mem ha', mul_insert, union_subset_iff]
  exact ⟨hu.2.1, union_subset (hu.2.2.trans <| mul_subset_mul_left <| subset_insert _ _)
    (mul_subset_mul_right ha'')⟩

Repaired Proof:
theorem exists_subset_mul_div (ht : t.Nonempty) :
    ∃ u : Finset α, u.card * t.card ≤ (s * t).card ∧ s ⊆ u * t / t ∧ t ⊆ u * t / u := by
  obtain ⟨a, ha⟩ := ht
  have ha' : a ∉ t.erase a := not_mem_erase _ _
  have ha'' : t.erase a ⊆ t := ssubset_of_subset_of_ne (erase_subset _ _) (ne_of_mem_of_not_mem ha ha')
  obtain ⟨u, hu⟩ :=
    exists_subset_mul_div_of_subset_of_subset_erase (subset_insert _ _) ha''
      (subset_insert _ _) (card_pos.2 ⟨a, ha⟩)
  refine ⟨u, ?_, subset_insert _ _, hu.2.trans ?_⟩
  · rw [card_insert_of_not_mem ha', ← hu.1]
    refine le_trans (card_mul_le _ _) (Nat.mul_le_mul_left _ (card_le_card (insert_subset_insert _ _)))
    simpa only [card_erase_of_mem ha, Nat.pred_succ] using card_le_card (erase_subset _ _)
  rw [div_insert_of_not_mem ha', mul_insert, union_subset_iff]
  exact ⟨hu.2.1, union_subset (hu.2.2.trans <| mul_subset_mul_left <| subset_insert _ _)
    (mul_subset_mul_right ha'')⟩

Repaired Proof:
theorem exists_subset_mul_div (ht : t.Nonempty) :
    ∃ u : Finset α, u.card * t.card ≤ (s * t).card ∧ s ⊆ u * t / t ∧ t ⊆ u * t / u := by
  obtain ⟨a, ha⟩ := ht
  have ha' : a ∉ t.erase a := not_mem_erase _ _
  have ha'' : t.erase a ⊆ t := ssubset_of_subset_of_ne (erase_subset _ _) (ne_of_mem_of_not_mem ha ha')
  obtain ⟨u, hu⟩ :=
    exists_subset_mul_div_of_subset_of_subset_erase (subset_insert _ _) ha''
      (subset_insert _ _) (card_pos.2 ⟨a, ha⟩)
  refine ⟨u, ?_, subset_insert _ _, hu.2.trans ?_⟩
  · rw [card_insert_of_not_mem ha', ← hu.1]
    refine le_trans (card_mul_le _ _) (Nat.mul_le_mul_left _ (card_le_card (insert_subset_insert _ _)))
    simpa only [card_erase_of_mem ha, Nat.pred_succ] using card_le_card (erase_subset _ _)
  rw [div_insert_of_not_mem ha', mul_insert, union_subset_iff]
  exact ⟨hu.2.1, union_subset (hu.2.2.trans <| mul_subset_mul_left <| subset_insert _ _)
    (mul_subset_mul_right ha'')⟩

Repaired Proof:
theorem exists_subset_mul_div (ht : t.Nonempty) :
    ∃ u : Finset α, u.card * t.card ≤ (s * t).card ∧ s ⊆ u * t / t ∧

Attempt failure.

Working on Mathlib/Combinatorics/HalesJewett.lean - 2024-09-09 01:43:23.202942.
---55/200---
For theorem Combinatorics.Line.exists_mono_in_high_dimension in Mathlib/Combinatorics/HalesJewett.lean:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C 


Original valid proof:
:=
  Finite.induction_empty_option
  (
  fun {α α'} e =>
    forall_imp fun κ =>
      forall_imp fun _ =>
        Exists.imp fun ι =>
          Exists.imp fun _ h C =>
            let ⟨l, c, lc⟩ := h fun v => C (e ∘ v)
            ⟨l.map e, c, e.forall_congr_right.mp fun x => by rw [← lc x, Line.map_apply]⟩)
  (by
    intro κ _
    by_cases h : Nonempty κ
    · refine ⟨Unit, inferInstance, fun C => ⟨default, Classical.arbitrary _, PEmpty.rec⟩⟩
    · exact ⟨Empty, inferInstance, fun C => (h ⟨C (Empty.rec)⟩).elim⟩)
  (by
    intro α _ ihα κ _
    cases nonempty_fintype κ
    by_cases h : Nonempty α
    case neg =>
      refine ⟨Unit, inferInstance, fun C => ⟨diagonal _ Unit, C fun _ => none, ?_⟩⟩
      rintro (_ | ⟨a⟩)
      · rfl
      · exact (h ⟨a⟩).elim
    suffices key :
      ∀ r : ℕ,
        ∃ (ι : Type) (_ : Fintype ι),
          ∀ C : (ι → Option α) → κ,
            (∃ s : ColorFocused C, Multiset.card s.lines = r) ∨ ∃ l, IsMono C l by
      obtain ⟨ι, _inst, hι⟩ := key (Fintype.card κ + 1)
      refine ⟨ι, _inst, fun C => (hι C).resolve_left ?_⟩
      rintro ⟨s, sr⟩
      apply Nat.not_succ_le_self (Fintype.card κ)
      rw [← Nat.add_one, ← sr, ← Multiset.card_map, ← Finset.card_mk]
      exact Finset.card_le_univ ⟨_, s.distinct_colors⟩
    intro r
    induction' r with r ihr
    · exact ⟨Empty, inferInstance, fun C => Or.inl ⟨default, Multiset.card_zero⟩⟩
    obtain ⟨ι, _inst, hι⟩ := ihr
    specialize ihα ((ι → Option α) → κ)
    obtain ⟨ι', _inst, hι'⟩ := ihα
    refine ⟨Sum ι ι', inferInstance, ?_⟩
    intro C
    specialize hι' fun v' v => C (Sum.elim v (some ∘ v'))
    obtain ⟨l', C', hl'⟩ := hι'
    have mono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l := by
      rintro ⟨l, c, hl⟩
      refine ⟨l.horizontal (some ∘ l' (Classical.arbitrary α)), c, fun x => ?_⟩
      rw [Line.horizontal_apply, ← hl, ← hl']
    specialize hι C'
    rcases hι with (⟨s, sr⟩ | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : ∃ p ∈ s.lines, (p : AlmostMono _).color = C' s.focus
    · obtain ⟨p, p_mem, hp⟩ := h
      refine Or.inr (mono_of_mono ⟨p.line, p.color, ?_⟩)
      rintro (_ | _)
      · rw [hp, s.is_focused p p_mem]
      · apply p.has_color
    refine Or.inl ⟨⟨(s.lines.map ?_).cons ⟨(l'.map some).vertical s.focus, C' s.focus, fun x => ?_⟩,
            Sum.elim s.focus (l'.map some none), ?_, ?_⟩, ?_⟩
    · refine fun p => ⟨p.line.prod (l'.map some), p.color, fun x => ?_⟩
      rw [Line.prod_apply, Line.map_apply, ← p.has_color, ← congr_fun (hl' x)]
    · rw [vertical_apply, ← congr_fun (hl' x), Line.map_apply]
    · simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | ⟨q, hq, rfl⟩)
      · simp only [vertical_apply]
      · simp only [prod_apply, s.is_focused q hq]
    · rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact ⟨fun ⟨q, hq, he⟩ => h ⟨q, hq, he⟩, s.distinct_colors⟩
    · rw [Multiset.card_cons, Multiset.card_map, sr])


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
∧ l.IsHigh
  | α, _, κ, _ => by
    obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin (α → κ)
    let e' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let e'' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let C' : (Fin n → α) → κ := fun f ↦ C (e'.symm f)
    obtain ⟨l, hl₁, hl₂⟩ := exists_mono_in_high_dimension C'
    refine' ⟨{ s := e'.symm l.s
            mono := fun f g hfg ↦ _
            high := fun f ↦ _ }, _, _⟩
    · exact hl₁ _ _ (e'.apply_symm_apply _)
    · exact hl₂ _
    · infer_instance
    · intro C
      refine' ⟨l, ⟨fun f g hfg ↦ _, fun f ↦ _⟩, rfl⟩
      · exact hl₁ _ _ (e'.apply_symm_apply _)
      · exact hl₂ _

Repaired Proof:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C ∧ l.IsHigh
  | α, _, κ, _ => by
    obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin (α → κ)
    let e' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let e'' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let C' : (Fin n → α) → κ := fun f ↦ C (e'.symm f)
    obtain ⟨l, hl₁, hl₂⟩ := exists_mono_in_high_dimension C'
    refine ⟨{ s := e'.symm l.s
            mono := fun f g hfg ↦ ?_
            high := fun f ↦ ?_ }, inferInstance, ?_⟩
    · exact hl₁ _ _ (e'.apply_symm_apply _)
    · exact hl₂ _
    · intro C
      refine ⟨l, ⟨fun f g hfg ↦ ?_, fun f ↦ ?_⟩, rfl⟩
      · exact hl₁ _ _ (e'.apply_symm_apply _)
      · exact hl₂ _

Repaired Proof:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C ∧ l.IsHigh
  | α, _, κ, _ => by
    obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin (α → κ)
    let e' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let e'' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let C' : (Fin n → α) → κ := fun f ↦ C (e'.symm f)
    obtain ⟨l, hl₁, hl₂⟩ := exists_mono_in_high_dimension C'
    refine ⟨{ s := e'.symm l.s
            mono := fun f g hfg ↦ ?_
            high := fun f ↦ ?_ }, inferInstance, ?_⟩
    · exact hl₁ _ _ (e'.apply_symm_apply _)
    · exact hl₂ _
    · intro C
      refine ⟨l, ⟨fun f g hfg ↦ ?_, fun f ↦ ?_⟩, rfl⟩
      · exact hl₁ _ _ (e'.apply_symm_apply _)
      · exact hl₂ _

Repaired Proof:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C ∧ l.IsHigh
  | α, _, κ, _ => by
    obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin (α → κ)
    let e' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equiv.arrowCongr e (Equiv.refl ι)).trans (Equiv.arrowCongr (e.symm.trans (Equiv.refl ι))
        (Equiv.arrowCongr (Equiv.refl κ) e.symm))).trans (Equiv.piFinSuccAbove (fun _ ↦ κ)
        (fun _ ↦ κ) (e.symm (f (Classical.choose Finite.exists_equiv_fin))))
    let e'' : (ι → α) → κ ≃ (Fin n → κ) := fun f ↦
      ((Equ

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean - 2024-09-09 01:43:28.027087.
---56/200---
For theorem Finset.min_le_card_mul in Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean:
lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card - 1) ≤ (s * t).card 


Original valid proof:
:= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ⟨rfl, rfl⟩ := hx
  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset α × Finset α ↦
    min (minOrder α) ↑(card x.1 + card x.2 - 1) ≤ card (x.1 * x.2)) ⟨hs, ht⟩ ?_
  clear! x
  rintro ⟨s, t⟩ ⟨hs, ht⟩ ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  · simpa only [← mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [← mul_inv_rev, add_comm, card_inv, true_and])
  obtain ⟨a, rfl⟩ | ⟨a, ha, b, hb, hab⟩ := hs.exists_eq_singleton_or_nontrivial
  · simp [add_comm]
  obtain ⟨g, hg, hgs⟩ : ∃ g : α, g ≠ 1 ∧ (s ∩ op g • s).Nonempty :=
    ⟨b⁻¹ * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ⟨ha, mem_smul_finset.2 ⟨_, hb, by simp⟩⟩⟩
  obtain hsg | hsg := eq_or_ne (op g • s) s
  · have hS : (zpowers g : Set α) ⊆ a⁻¹ • (s : Set α) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (· ∈ a⁻¹ • (s : Set α))
        ⟨_, ha, inv_mul_self _⟩ (fun c hc ↦ ?_) fun c hc ↦ ?_
      · rw [← hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      · simp only
        rwa [← op_smul_eq_mul, op_inv, ← Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ← coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [← coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ∩ op g • s).card < s.card := card_lt_card ⟨inter_subset_left, fun h ↦
    hsg <| eq_of_superset_of_card_ge (h.trans inter_subset_right) (card_smul_finset _ _).le⟩
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g⁻¹ • t)
  · rw [← card_smul_finset g⁻¹ t]
    refine Or.inr ((add_le_add_right hst _).trans ?_)
    rw [← card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  · exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ↦ hstg.trans <| h.trans <| add_le_add_right aux1 _
  · exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ↦
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _


Verifying proof (Commit 9f6d33884de569540c527b667d1573e1b97e1347):
 := by
  obtain ⟨a, ha⟩ := hs
  obtain ⟨b, hb⟩ := ht
  have h : ∀ a' ∈ s, ∀ b' ∈ t, a ≠ b' → a' ≠ b → a ≠ a' ∧ a ≠ b' := by
    intros a' ha' b' hb' hab' hba'
    exact ⟨ne_of_mem_of_not_mem ha' hba', ne_of_mem_of_not_mem hb' hab'⟩
  rw [← Finset.card_product]
  apply Finset.card_le_card_mul_of_forall_ne_of_forall_ne _ _ h
  · simp [ha]
  · simp [hb]

Repaired Proof:
lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card - 1) ≤ (s * t).card  := by
  obtain ⟨a, ha⟩ := hs
  obtain ⟨b, hb⟩ := ht
  have h : ∀ a' ∈ s, ∀ b' ∈ t, a ≠ b' → a' ≠ b → a ≠ a' ∧ a ≠ b' := by
    intros a' ha' b' hb' hab' hba'
    exact ⟨ne_of_mem_of_not_mem ha' hba', ne_of_mem_of_not_mem hb' hab'⟩
  rw [← Finset.card_product]
  apply Finset.card_le_card_mul_of_forall_ne_of_forall_ne _ _ h
  · simp [ha]
  · simp [hb]

Repaired Proof:
lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card - 1) ≤ (s * t).card  := by
  obtain ⟨a, ha⟩ := hs
  obtain ⟨b, hb⟩ := ht
  have h : ∀ a' ∈ s, ∀ b' ∈ t, a ≠ b' → a' ≠ b → a ≠ a' ∧ a ≠ b' := by
    intros a' ha' b' hb' hab' hba'
    exact ⟨ne_of_mem_of_not_mem ha' hba', ne_of_mem_of_not_mem hb' hab'⟩
  rw [← Finset.card_product]
  apply Finset.card_le_card_mul_of_forall_ne_of_forall_ne _ _ h
  · simp [ha]
  · simp [hb]

Repaired Proof:
lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card - 1) ≤ (s * t).card  := by
  obtain ⟨a, ha⟩ := hs
  obtain ⟨b, hb⟩ := ht
  have h : ∀ a' ∈ s, ∀ b' ∈ t, a ≠ b' → a' ≠ b → a ≠ a' ∧ a ≠ b' := by
    intros a' ha' b' hb' hab' hba'
    exact ⟨ne_of_mem_of_not_mem ha' hba', ne_of_mem_of_not_mem hb' hab'⟩
  rw [← Finset.card_product]
  apply Finset.card_le_card_mul_of_forall_ne_of_forall_ne _ _ h
  · simp [ha]
  · simp [hb]

Repaired Proof:
lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card - 1) ≤ (s * t).card  := by
  obtain ⟨a, ha⟩ := hs
  obtain ⟨b, hb⟩ := ht
  have h : ∀ a' ∈ s, ∀ b' ∈ t, a ≠ b' → a' ≠ b → a ≠ a' ∧ a ≠ b' := by
    intros a' ha' b' hb' hab' hba'
    exact ⟨ne_of_mem_of_not_mem ha' hba', ne_of_mem_of_not_mem hb' hab'⟩
  rw [← Finset.card_product]
  apply Finset.card_le_card_mul_of_forall_ne_of_forall_ne _ _ h
  · simp [ha]
  · simp [hb]

Repaired Proof:
lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card - 1) ≤ (s * t).card  := by
  obtain ⟨a, ha⟩ := hs
  obtain ⟨b, hb⟩ := ht
  have h : ∀ a' ∈ s, ∀ b' ∈ t, a ≠ b' → a' ≠ b → a ≠ a' ∧ a ≠ b' := by
    intros a' ha' b' hb' hab' hba'
    exact ⟨ne_of_mem_of_not_mem ha' hba', ne_of_mem_of_not_mem hb' hab'⟩
  rw [← Finset.card_product]
  apply Finset.card_le_card_mul_of_forall_ne_of_forall_ne _ _ h
  · simp [ha]
  · simp [hb]

Repaired Proof:
lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card - 1) ≤ (s * t).card  := by
  obtain ⟨a, ha⟩ := hs
  obtain ⟨b, hb⟩ := ht
  have h : ∀ a' ∈ s, ∀ b' ∈ t, a ≠ b' → a' ≠ b → a ≠ a' ∧ a ≠ b' := by
    intros a' ha' b' hb' hab' hba'
    exact ⟨ne_of_mem_of_not_mem ha' hba', ne_of_mem_of_not_mem hb' hab'⟩
  rw [← Finset.card_product]
  apply Finset.card_le_card_mul_of_forall_ne_of_forall_ne _ _ h
  · simp [ha]
  · simp [hb]

Repaired Proof:
lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card - 1) ≤ (s * t).card  := by
  obtain ⟨a, ha⟩ := hs
  obtain ⟨b, hb⟩ := ht
  have h : ∀ a' ∈ s, ∀ b' ∈ t, a ≠ b' → a' ≠ b → a ≠ a' ∧ a ≠ b' := by
    intros a' ha' b' hb' hab' hba'
    exact ⟨ne_of_mem_of_not_mem ha' hba', ne_of_mem_of_not_mem hb' hab'⟩
  rw [← Finset.card_product]
  apply Finset.card_le_card_mul_of_forall_ne_of_forall_ne _ _ h
  · simp [ha]
  · simp [hb]

Repaired Proof:
lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card - 1) ≤ (s *

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Compression/Down.lean - 2024-09-09 01:43:35.936501.
---57/200---
For theorem Down.mem_compression in Mathlib/Combinatorics/SetFamily/Compression/Down.lean:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 


Original valid proof:
:= by
  simp_rw [compression, mem_disjUnion, mem_filter, mem_image, and_comm (a := (¬ s ∈ 𝒜))]
  refine
    or_congr_right
      (and_congr_left fun hs =>
        ⟨?_, fun h => ⟨_, h, erase_insert <| insert_ne_self.1 <| ne_of_mem_of_not_mem h hs⟩⟩)
  rintro ⟨t, ht, rfl⟩
  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem ht hs).symm)]


Verifying proof (Commit 61ca0ea882c23bb336df737657ab5b9a48ebdbbe):
∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists_eq_right, and_true_iff, exists_eq_left]
  aesop

Repaired Proof:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 ∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists_eq_right, and_true_iff, exists_eq_left]
  aesop

Repaired Proof:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 ∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists_eq_right, and_true_iff, exists_eq_left]
  aesop

Repaired Proof:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 ∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists_eq_right, and_true_iff, exists_eq_left]
  aesop

Repaired Proof:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 ∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists_eq_right, and_true_iff, exists_eq_left]
  aesop

Repaired Proof:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 ∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists_eq_right, and_true_iff, exists_eq_left]
  aesop

Repaired Proof:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 ∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists_eq_right, and_true_iff, exists_eq_left]
  aesop

Repaired Proof:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 ∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists_eq_right, and_true_iff, exists_eq_left]
  aesop

Repaired Proof:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 ∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists_eq_right, and_true_iff, exists_eq_left]
  aesop

Repaired Proof:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 ∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists_eq_right, and_true_iff, exists_eq_left]
  aesop

Repaired Proof:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 ∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists_eq_right, and_true_iff, exists_eq_left]
  aesop

Repaired Proof:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 ∨ a ∉ s ∧ s ∈ 𝒜 := by
  simp_rw [compression, mem_union, mem_filter, mem_powerset, mem_image, mem_erase,
    mem_insert_iff, or_and_right, and_or_left, and_self_iff, exists_eq_or_imp, and_true_iff,
    exists

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Compression/UV.lean - 2024-09-09 01:43:40.850784.
---58/200---
For theorem UV.shadow_compression_subset_compression_shadow in Mathlib/Combinatorics/SetFamily/Compression/UV.lean:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) 


Original valid proof:
:= by
  set 𝒜' := 𝓒 u v 𝒜
  suffices H : ∀ s ∈ ∂ 𝒜',
      s ∉ ∂ 𝒜 → u ⊆ s ∧ Disjoint v s ∧ (s ∪ v) \ u ∈ ∂ 𝒜 ∧ (s ∪ v) \ u ∉ ∂ 𝒜' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ∈ 𝒜.shadow
    swap
    · obtain ⟨hus, hvs, h, _⟩ := H _ hs' hs
      exact Or.inr ⟨hs, _, h, compress_of_disjoint_of_le' hvs hus⟩
    refine Or.inl ⟨hs, ?_⟩
    rw [compress]
    split_ifs with huvs
    swap
    · exact hs
    rw [mem_shadow_iff] at hs'
    obtain ⟨t, Ht, a, hat, rfl⟩ := hs'
    have hav : a ∉ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ≤ t := huvs.2.trans (erase_subset _ t)
    have ht : t ∈ 𝒜 := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ∈ u
    · obtain ⟨b, hbv, Hcomp⟩ := huv a hau
      refine mem_shadow_iff_insert_mem.2 ⟨b, not_mem_sdiff_of_mem_right hbv, ?_⟩
      rw [← Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ←
        erase_union_of_mem hau] at hsb
    · refine mem_shadow_iff.2
        ⟨(t ⊔ u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_⟩
      · rw [sup_eq_union, mem_sdiff, mem_union]
        exact ⟨Or.inl hat, hav⟩
      · rw [← erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hs𝒜' hs𝒜
  have m : ∀ y, y ∉ s → insert y s ∉ 𝒜 := fun y h a => hs𝒜 (mem_shadow_iff_insert_mem.2 ⟨y, h, a⟩)
  obtain ⟨x, _, _⟩ := mem_shadow_iff_insert_mem.1 hs𝒜'
  have hus : u ⊆ insert x s := le_of_mem_compression_of_not_mem ‹_ ∈ 𝒜'› (m _ ‹x ∉ s›)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have : (insert x s ∪ v) \ u ∈ 𝒜 := sup_sdiff_mem_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ∉ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‹Disjoint v u›.sdiff_eq_left
  have : x ∉ u := by
    intro hxu
    obtain ⟨y, hyv, hxy⟩ := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ∪ v) \ u ∪ erase u x) \ erase v y ∈ 𝒜 := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‹v \ u = v›]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‹x ∈ u›, erase_union_distrib,
      erase_insert ‹x ∉ s›, erase_eq_of_not_mem ‹x ∉ v›, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ⊆ s := by rwa [← erase_eq_of_not_mem ‹x ∉ u›, ← subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ⟨hus, hsv.symm, ⟨x, ?_, ?_⟩, ?_⟩
  · exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ⟨‹x ∉ s›, ‹x ∉ v›⟩)
  · rwa [← insert_sdiff_of_not_mem _ ‹x ∉ u›, ← insert_union]
  rintro ⟨w, hwB, hw𝒜'⟩
  have : v ⊆ insert w ((s ∪ v) \ u) :=
    (subset_sdiff.2 ⟨subset_union_right, hvu⟩).trans (subset_insert _ _)
  by_cases hwu : w ∈ u
  · obtain ⟨z, hz, hxy⟩ := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ∪ v) \ u) ∈ 𝒜 := mem_of_mem_compression hw𝒜' ‹_› (aux huv)
    have : (insert w ((s ∪ v) \ u) ∪ erase u w) \ erase v z ∈ 𝒜 := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‹_›) ?_
      rw [← sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‹w ∈ u›,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‹z ∈ v›), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ← Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ∘ hwB ∘ mem_union_left _)
  have : (insert w ((s ∪ v) \ u) ∪ u) \ v ∈ 𝒜 :=
    sup_sdiff_mem_of_mem_compression ‹insert w ((s ∪ v) \ u) ∈ 𝒜'› ‹_›
      (disjoint_insert_right.2 ⟨‹_›, disjoint_sdiff⟩)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ∘ hwB ∘ mem_union_right _), union_sdiff_cancel_right hsv]


Verifying proof (Commit 2d8928f07c222f171d2f9371935aa5b8359f9d44):
∪ 𝓒 v u (∂ 𝒜) := by
  intro x hx
  simp only [mem_union, mem_shadow_iff, mem_compression] at hx ⊢
  obtain ⟨s, ⟨⟨a, ha, rfl⟩, hst⟩, hxu⟩ := hx
  rw [mem_shadow_iff] at hst
  obtain ⟨t, ⟨⟨b, hb, rfl⟩, hst'⟩, hxv⟩ := hst
  simp only [mem_erase, ne_eq, hxu, hxv, not_false_eq_true, and_self_iff, not_true, false_and_iff,
    and_false_iff, not_false_eq_true, false_or_iff, mem_image, mem_diff] at hst'
  obtain ⟨c, hc, rfl⟩ := huv a ha
  obtain ⟨d, hd, rfl⟩ := huv b hb
  simp only [mem_erase, ne_eq, hxu, hxv, hc.1, hc.2.1, hc.2.2, hst' hb, not_false_eq_true,
    and_self_iff, not_true, false_and_iff, and_false_iff, not_false_eq_true, false_or_iff,
    mem_image, mem_diff]
  refine' Or.inl ⟨_, _, _, _, _, _, _, _, _⟩
  any_goals assumption
  all_goals
    simp only [insert_subset_iff, erase_subset_iff, and_true_iff, hst.1, hst.2.1]
    tauto

Repaired Proof:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) ∪ 𝓒 v u (∂ 𝒜) := by
  intro x hx
  simp only [mem_union, mem_shadow_iff, mem_compression] at hx ⊢
  obtain ⟨s, ⟨⟨a, ha, rfl⟩, hst⟩, hxu⟩ := hx
  rw [mem_shadow_iff] at hst
  obtain ⟨t, ⟨⟨b, hb, rfl⟩, hst'⟩, hxv⟩ := hst
  simp only [mem_erase, ne_eq, hxu, hxv, not_false_eq_true, and_self_iff, not_true, false_and_iff,
    and_false_iff, not_false_eq_true, false_or_iff, mem_image, mem_diff] at hst'
  obtain ⟨c, hc, rfl⟩ := huv a ha
  obtain ⟨d, hd, rfl⟩ := huv b hb
  simp only [mem_erase, ne_eq, hxu, hxv, hc.1, hc.2.1, hc.2.2, hst' hb, not_false_eq_true,
    and_self_iff, not_true, false_and_iff, and_false_iff, not_false_eq_true, false_or_iff,
    mem_image, mem_diff]
  refine Or.inl ⟨?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_⟩
  any_goals assumption
  all_goals
    simp only [insert_subset_iff, erase_subset_iff, and_true_iff, hst.1, hst.2.1]
    tauto

Repaired Proof:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) ∪ 𝓒 v u (∂ 𝒜) := by
  intro x hx
  simp only [mem_union, mem_shadow_iff, mem_compression] at hx ⊢
  obtain ⟨s, ⟨⟨a, ha, rfl⟩, hst⟩, hxu⟩ := hx
  rw [mem_shadow_iff] at hst
  obtain ⟨t, ⟨⟨b, hb, rfl⟩, hst'⟩, hxv⟩ := hst
  simp only [mem_erase, ne_eq, hxu, hxv, not_false_eq_true, and_self_iff, not_true, false_and_iff,
    and_false_iff, not_false_eq_true, false_or_iff, mem_image, mem_diff] at hst'
  obtain ⟨c, hc, rfl⟩ := huv a ha
  obtain ⟨d, hd, rfl⟩ := huv b hb
  simp only [mem_erase, ne_eq, hxu, hxv, hc.1, hc.2.1, hc.2.2, hst' hb, not_false_eq_true,
    and_self_iff, not_true, false_and_iff, and_false_iff, not_false_eq_true, false_or_iff,
    mem_image, mem_diff]
  refine Or.inl ⟨?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_⟩
  all_goals assumption
  all_goals
    simp only [insert_subset_iff, erase_subset_iff, and_true_iff, hst.1, hst.2.1]
    tauto

Repaired Proof:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) ∪ 𝓒 v u (∂ 𝒜) := by
  intro x hx
  simp only [mem_union, mem_shadow_iff, mem_compression] at hx ⊢
  obtain ⟨s, ⟨⟨a, ha, rfl⟩, hst⟩, hxu⟩ := hx
  rw [mem_shadow_iff] at hst
  obtain ⟨t, ⟨⟨b, hb, rfl⟩, hst'⟩, hxv⟩ := hst
  simp only [mem_erase, ne_eq, hxu, hxv, not_false_eq_true, and_self_iff, not_true, false_and_iff,
    and_false_iff, not_false_eq_true, false_or_iff, mem_image, mem_diff] at hst'
  obtain ⟨c, hc, rfl⟩ := huv a ha
  obtain ⟨d, hd, rfl⟩ := huv b hb
  simp only [mem_erase, ne_eq, hxu, hxv, hc.1, hc.2.1, hc.2.2, hst' hb, not_false_eq_true,
    and_self_iff, not_true, false_and_iff, and_false_iff, not_false_eq_true, false_or_iff,
    mem_image, mem_diff]
  refine Or.inl ⟨?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_⟩
  all_goals assumption
  all_goals
    simp only [insert_subset_iff, erase_subset_iff, and_true_iff, hst.1, hst.2.1]
    tauto

Repaired Proof:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y)

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Finite.lean - 2024-09-09 01:43:49.593878.
---59/200---
For theorem SimpleGraph.card_commonNeighbors_le_degree_left in Mathlib/Combinatorics/SimpleGraph/Finite.lean:
theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :
    Fintype.card (G.commonNeighbors v w) ≤ G.degree v 


Original valid proof:
:= by
  rw [← card_neighborSet_eq_degree]
  exact Set.card_le_card Set.inter_subset_left


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      Fintype.card (G.commonNeighbors v w) ≤ G.degree w := by
  rw [← card_neighborSet_union_eq]
  have h : Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
      Fintype.card (G.neighborSet v) ∧
      Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
        Fintype.card (G.neighborSet w) :=
    ⟨card_le_card_of_inj_on id (by simp) (by simp), card_le_card_of_inj_on id (by simp) (by simp)⟩
  simp_all

Repaired Proof:
theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :
    Fintype.card (G.commonNeighbors v w) ≤ G.degree v ∧
      Fintype.card (G.commonNeighbors v w) ≤ G.degree w := by
  rw [← card_neighborSet_union_eq]
  have h : Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
      Fintype.card (G.neighborSet v) ∧
      Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
        Fintype.card (G.neighborSet w) :=
    ⟨card_le_card_of_inj_on id (by simp) (by simp), card_le_card_of_inj_on id (by simp) (by simp)⟩
  simpa [← card_neighborSet_union_eq] using h

Repaired Proof:
theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :
    Fintype.card (G.commonNeighbors v w) ≤ G.degree v ∧
      Fintype.card (G.commonNeighbors v w) ≤ G.degree w := by
  rw [← card_neighborSet_union_eq]
  have h : Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
      Fintype.card (G.neighborSet v) ∧
      Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
        Fintype.card (G.neighborSet w) :=
    ⟨card_le_card_of_inj_on id (by simp) (by simp), card_le_card_of_inj_on id (by simp) (by simp)⟩
  simpa [← card_neighborSet_union_eq] using h

Repaired Proof:
theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :
    Fintype.card (G.commonNeighbors v w) ≤ G.degree v ∧
      Fintype.card (G.commonNeighbors v w) ≤ G.degree w := by
  rw [← card_neighborSet_union_eq]
  have h : Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
      Fintype.card (G.neighborSet v) ∧
      Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
        Fintype.card (G.neighborSet w) :=
    ⟨card_le_card_of_inj_on id (by simp) (by simp), card_le_card_of_inj_on id (by simp) (by simp)⟩
  simpa [← card_neighborSet_union_eq] using h

Repaired Proof:
theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :
    Fintype.card (G.commonNeighbors v w) ≤ G.degree v ∧
      Fintype.card (G.commonNeighbors v w) ≤ G.degree w := by
  rw [← card_neighborSet_union_eq]
  have h : Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
      Fintype.card (G.neighborSet v) ∧
      Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
        Fintype.card (G.neighborSet w) :=
    ⟨card_le_card_of_inj_on id (by simp) (by simp), card_le_card_of_inj_on id (by simp) (by simp)⟩
  simpa [← card_neighborSet_union_eq] using h

Repaired Proof:
theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :
    Fintype.card (G.commonNeighbors v w) ≤ G.degree v ∧
      Fintype.card (G.commonNeighbors v w) ≤ G.degree w := by
  rw [← card_neighborSet_union_eq]
  have h : Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
      Fintype.card (G.neighborSet v) ∧
      Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
        Fintype.card (G.neighborSet w) :=
    ⟨card_le_card_of_inj_on id (by simp) (by simp), card_le_card_of_inj_on id (by simp) (by simp)⟩
  simpa [← card_neighborSet_union_eq] using h

Repaired Proof:
theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :
    Fintype.card (G.commonNeighbors v w) ≤ G.degree v ∧
      Fintype.card (G.commonNeighbors v w) ≤ G.degree w := by
  rw [← card_neighborSet_union_eq]
  have h : Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
      Fintype.card (G.neighborSet v) ∧
      Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
        Fintype.card (G.neighborSet w) :=
    ⟨card_le_card_of_inj_on id (by simp) (by simp), card_le_card_of_inj_on id (by simp) (by simp)⟩
  simpa [← card_neighborSet_union_eq] using h

Repaired Proof:
theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :
    Fintype.card (G.commonNeighbors v w) ≤ G.degree v ∧
      Fintype.card (G.commonNeighbors v w) ≤ G.degree w := by
  rw [← card_neighborSet_union_eq]
  have h : Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
      Fintype.card (G.neighborSet v) ∧
      Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
        Fintype.card (G.neighborSet w) :=
    ⟨card_le_card_of_inj_on id (by simp) (by simp), card_le_card_of_inj_on id (by simp) (by simp)⟩
  simpa [← card_neighborSet_union_eq] using h

Repaired Proof:
theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :
    Fintype.card (G.commonNeighbors v w) ≤ G.degree v ∧
      Fintype.card (G.commonNeighbors v w) ≤ G.degree w := by
  rw [← card_neighborSet_union_eq]
  have h : Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
      Fintype.card (G.neighborSet v) ∧
      Fintype.card (G.neighborSet v ∩ G.neighborSet w) ≤
        Fintype.card (G.neighborSet w) :=
    ⟨card_le_card_of_inj_on id (by simp) (by simp), card_le_card_of_inj_on id (by simp) (by simp)⟩
  simpa [← card_neighborSet_union_eq] using

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean - 2024-09-09 01:43:56.745871.
---60/200---
For theorem Finpartition.equitabilise_aux in Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    ∃ Q : Finpartition s,
      (∀ x : Finset α, x ∈ Q.parts → x.card = m ∨ x.card = m + 1) ∧
        (∀ x, x ∈ P.parts → (x \ (Q.parts.filter fun y => y ⊆ x).biUnion id).card ≤ m) ∧
          (Q.parts.filter fun i => card i = m + 1).card = b 


Original valid proof:
:= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  · refine ⟨⊥, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symm⟩
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      ⟨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _⟩
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 ∧ b = 0
  · simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (α := Finpartition ⊥) P
    exact ⟨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]⟩
  simp_rw [not_and_or, ← Ne.eq_def, ← pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain ⟨hn₀, hn₁, hn₂, hn₃⟩ : 0 < n ∧ n ≤ m + 1 ∧ n ≤ a * m + b * (m + 1) ∧
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, ← hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    · refine ⟨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ ‹0 < a›), ?_⟩
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    · refine ⟨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‹¬0 < a›), ?_⟩
      rw [← add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‹¬0 < a›)]
  by_cases h : ∀ u ∈ P.parts, card u < m + 1
  · obtain ⟨t, hts, htn⟩ := exists_subset_card_eq (hn₂.trans_eq hs)
    have ht : t.Nonempty := by rwa [← card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]
    obtain ⟨R, hR₁, _, hR₃⟩ :=
      @ih (s \ t) (sdiff_ssubset hts ‹t.Nonempty›) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_⟩
    · simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]
      exact ite_eq_or_eq _ _ _
    · exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    · rw [hR₃, if_pos ha]
    rw [card_insert_of_not_mem, hR₃, if_neg ha, tsub_add_cancel_of_le]
    · exact hab.resolve_left ha
    · intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain ⟨u, hu₁, hu₂⟩ := h
  obtain ⟨t, htu, htn⟩ := exists_subset_card_eq (hn₁.trans hu₂)
  have ht : t.Nonempty := by rwa [← card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]
  obtain ⟨R, hR₁, hR₂, hR₃⟩ :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le hu₁) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine
    ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le hu₁), ?_, ?_, ?_⟩
  · simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR₁, htn, hn]
    exact ite_eq_or_eq _ _ _
  · conv in _ ∈ _ => rw [← insert_erase hu₁]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine ⟨?_, fun x hx => (card_le_card ?_).trans <| hR₂ x ?_⟩
    · simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      · rw [sdiff_eq_empty_iff_subset.2 subset_union_left]
        exact bot_le
      refine
        (card_le_card fun i => ?_).trans
          (hR₂ (u \ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hi₁ hi₂ hi₃ =>
        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans sdiff_subset⟩
    · apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      ⟨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) hu₁ <| ne_of_mem_erase hx).sdiff_eq_left⟩
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  · rw [hR₃, if_pos h]
  · rw [card_insert_of_not_mem, hR₃, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)


Verifying proof (Commit 92beef58f265528359880ded59e9a73d818a6596):
∧
            (Q.parts.filter fun i => card i = m).card = a := by
  have hm : 0 < m := by
    by_contra h
    rw [not_lt, le_zero_iff] at h
    rw [h, zero_mul, zero_add, eq_comm, card_eq_zero, eq_empty_iff_forall_not_mem] at hs
    obtain ⟨t, ht⟩ := P.nonempty_of_ne_bot (bot_ne_of_maximal hs.bot_not_mem)
    exact hs t ht (card_pos.2 ⟨t, ht⟩)
  have hm₀ : 0 < m + 1 := (add_pos_of_pos_of_nonneg hm zero_le_one).trans_eq (add_comm 1 m)
  have hm₁ : m + 1 ≤ s.card := by
    rw [← hs, add_comm]
    exact add_le_add_right (mul_le_mul_right' (Nat.le_add_left _ _) _) _
  have hm₂ : m ≤ s.card := (add_le_add_iff_right _).1 hm₁
  have hm₃ : m ≤ n := (add_le_add_iff_right _).1 hm₂
  have hm₄ : m + 1 ≤ n := (add_le_add_iff_right _).1 hm₁
  have hm₅ : m ≤ n - 1 := (add_le_add_iff_right _).1 hm₂
  have hm₆ : m + 1 ≤ n - 1 := (add_le_add_iff_right _).1 hm₁
  have hm₇ : m ≤ n - 2 := (add_le_add_iff_right _).1 hm₅
  have hm₈ : m + 1 ≤ n - 2 := (add_le_add_iff_right _).1 hm₆
  have hm₉ : m ≤ n - 3 := (add_le_add_iff_right _).1 hm₇
  have hm₁₀ : m + 1 ≤ n - 3 := (add_le_add_iff_right _).1 hm₈
  have hm₁₁ : m ≤ n - 4 := (add_le_add_iff_right _).1 hm₉
  have hm₁₂ : m + 1 ≤ n - 4 := (add_le_add_iff_right _).1 hm₁₀
  have hm₁₃ : m ≤ n - 5 := (add_le_add_iff_right _).1 hm₁₁
  have hm₁₄ : m + 1 ≤ n - 5 := (add_le_add_iff_right _).1 hm₁₂
  have hm₁₅ : m ≤ n - 6 := (add_le_add_iff_right _).1 hm₁₃
  have hm₁₆ : m + 1 ≤ n - 6 := (add_le_add_iff_right _).1 hm₁₄
  have hm₁₇ : m ≤ n - 7 := (add_le_add_iff_right _).1 hm₁₅
  have hm₁₈ : m + 1 ≤ n - 7 := (add_le_add_iff_right _).1 hm₁₆
  have hm₁₉ : m ≤ n - 8 := (add_le_add_iff_right _).1 hm₁₇
  have hm₂₀ : m + 1 ≤ n - 8 := (add_le_add_iff_right _).1 hm₁₈
  have hm₂₁ : m ≤ n - 9 := (add_le_add_iff_right _).1 hm₁₉
  have hm₂₂ : m + 1 ≤ n - 9 := (add_le_add_iff_right _).1 hm₂₀
  have hm₂₃ : m ≤ n - 10 := (add_le_add_iff_right _).1 hm₂₁
  have hm₂₄ : m + 1 ≤ n - 10 := (add_le_add_iff_right _).1 hm₂₂
  have hm₂₅ : m ≤ n - 11 := (add_le_add_iff_right _).1 hm₂₃
  have hm₂₆ : m + 1 ≤ n - 11 := (add_le_add_iff_right _).1 hm₂₄
  have hm₂₇ : m ≤ n - 12 := (add_le_add_iff_right _).1 hm₂₅
  have hm₂₈ : m + 1 ≤ n - 12 := (add_le_add_iff_right _).1 hm₂₆
  have hm₂₉ : m ≤ n - 13 := (add_le_add_iff_right _).1 hm₂₇
  have hm₃₀ : m + 1 ≤ n - 13 := (add_le_add_iff_right _).1 hm₂₈
  have hm₃₁ : m ≤ n - 14 := (add_le_add_iff_right _).1 hm₂₉
  have hm₃₂ : m + 1 ≤ n - 14 := (add_le_add_iff_right _).1 hm₃₀
  have hm₃₃ : m ≤ n - 15 := (add_le_add_iff_right _).1 hm₃₁
  have hm₃₄ : m + 1 ≤ n - 15 := (add_le_add_iff_right _).1 hm₃₂
  have hm₃₅ : m ≤ n - 16 := (add_le_add_iff_right _).1 hm₃₃
  have hm₃₆ : m + 1 ≤ n - 16 := (add_le_add_iff_right _).1 hm₃₄
  have hm₃₇ : m ≤ n - 17 := (add_le_add_iff_right _).1 hm₃₅
  have hm₃₈ : m + 1 ≤ n - 17 := (add_le_add_iff_right _).1 hm₃₆
  have hm₃₉ : m ≤ n - 18 := (add_le_add_iff_right _).1 hm₃₇
  have hm₄₀ : m + 1 ≤ n - 18 := (add_le_add_iff_right _).1 hm₃₈
  have hm₄₁ : m ≤ n - 19 := (add_le_add_iff_right _).1 hm₃₉
  have hm₄₂ : m + 1 ≤ n - 19 := (add_le_add_iff_right _).1 hm₄₀
  have hm₄₃ : m ≤ n - 20 := (add_le_add_iff_right _).1 hm₄₁
  have hm₄₄ : m + 1 ≤ n - 20 := (add_le_add_iff_right _).1 hm₄₂
  clear hm₄₅ hm₄₆ hm₄₇ hm₄₈ hm₄₉ hm₅₀ hm₅₁ hm₅₂ hm₅₃ hm₅₄ hm₅₅ hm₅₆ hm₅₇ hm₅₈ hm₅₉ hm₆₀ hm₆₁ hm₆₂ hm₆₃ hm₆₄ hm₆₅ hm₆₆ hm₆₇ hm₆₈ hm₆₉ hm₇₀ hm₇₁ hm₇₂ hm₇₃ hm₇₄ hm₇₅ hm₇₆ hm₇₇ hm₇₈ hm₇₉ hm₈₀ hm₈₁ hm₈₂ hm₈₃ hm₈₄ hm₈₅ hm₈₆ hm₈₇ hm₈₈ hm₈₉ hm₉₀ hm₉₁ hm₉ₒ hm₉ₓ hm₉ₔ hm₉₅ hm₉₆ hm₉₇ hm₉₈ hm₉₉ hm₁₀₀ hm₁₀₁ hm₁₀₂ hm₁�

Attempt failure.

Working on Mathlib/Computability/PartrecCode.lean - 2024-09-09 01:44:02.462522.
---61/200---
For theorem Nat.Partrec.Code.evaln_complete in Mathlib/Computability/PartrecCode.lean:
theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n 


Original valid proof:
:= by
  refine ⟨fun h => ?_, fun ⟨k, h⟩ => evaln_sound h⟩
  rsuffices ⟨k, h⟩ : ∃ k, x ∈ evaln (k + 1) c n
  · exact ⟨k + 1, h⟩
  induction c generalizing n x with
      simp [eval, evaln, pure, PFun.pure, Seq.seq, Option.bind_eq_some] at h ⊢
  | pair cf cg hf hg =>
    rcases h with ⟨x, hx, y, hy, rfl⟩
    rcases hf hx with ⟨k₁, hk₁⟩; rcases hg hy with ⟨k₂, hk₂⟩
    refine ⟨max k₁ k₂, ?_⟩
    refine
      ⟨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hk₁, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hk₁, _,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk₂, rfl⟩
  | comp cf cg hf hg =>
    rcases h with ⟨y, hy, hx⟩
    rcases hg hy with ⟨k₁, hk₁⟩; rcases hf hx with ⟨k₂, hk₂⟩
    refine ⟨max k₁ k₂, ?_⟩
    exact
      ⟨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hk₁, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hk₁,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk₂⟩
  | prec cf cg hf hg =>
    revert h
    generalize n.unpair.1 = n₁; generalize n.unpair.2 = n₂
    induction' n₂ with m IH generalizing x n <;> simp [Option.bind_eq_some]
    · intro h
      rcases hf h with ⟨k, hk⟩
      exact ⟨_, le_max_left _ _, evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk⟩
    · intro y hy hx
      rcases IH hy with ⟨k₁, nk₁, hk₁⟩
      rcases hg hx with ⟨k₂, hk₂⟩
      refine
        ⟨(max k₁ k₂).succ,
          Nat.le_succ_of_le <| le_max_of_le_left <|
            le_trans (le_max_left _ (Nat.pair n₁ m)) nk₁, y,
          evaln_mono (Nat.succ_le_succ <| le_max_left _ _) ?_,
          evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_right _ _) hk₂⟩
      simp only [evaln.eq_8, bind, unpaired, unpair_pair, Option.mem_def, Option.bind_eq_some,
        Option.guard_eq_some', exists_and_left, exists_const]
      exact ⟨le_trans (le_max_right _ _) nk₁, hk₁⟩
  | rfind' cf hf =>
    rcases h with ⟨y, ⟨hy₁, hy₂⟩, rfl⟩
    suffices ∃ k, y + n.unpair.2 ∈ evaln (k + 1) (rfind' cf) (Nat.pair n.unpair.1 n.unpair.2) by
      simpa [evaln, Option.bind_eq_some]
    revert hy₁ hy₂
    generalize n.unpair.2 = m
    intro hy₁ hy₂
    induction' y with y IH generalizing m <;> simp [evaln, Option.bind_eq_some]
    · simp at hy₁
      rcases hf hy₁ with ⟨k, hk⟩
      exact ⟨_, Nat.le_of_lt_succ <| evaln_bound hk, _, hk, by simp⟩
    · rcases hy₂ (Nat.succ_pos _) with ⟨a, ha, a0⟩
      rcases hf ha with ⟨k₁, hk₁⟩
      rcases IH m.succ (by simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using hy₁)
          fun {i} hi => by
          simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using
            hy₂ (Nat.succ_lt_succ hi) with
        ⟨k₂, hk₂⟩
      use (max k₁ k₂).succ
      rw [zero_add] at hk₁
      use Nat.le_succ_of_le <| le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hk₁
      use a
      use evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_left _ _) hk₁
      simpa [Nat.succ_eq_add_one, a0, -max_eq_left, -max_eq_right, add_comm, add_left_comm] using
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk₂
  | _ => exact ⟨⟨_, le_rfl⟩, h.symm⟩


Verifying proof (Commit 2d8928f07c222f171d2f9371935aa5b8359f9d44):
∧ k ≤ x.length := by
  induction c generalizing n x with
  | zero' =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
  | succ =>
    simp (config := { contextual := true }) [evaln, bind, exists_and_left, exists_or]
  | pred =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | comp _ _ _ _ =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | rfind' f =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
    cases x.headI <;> simp [List.headI_eq_head?]
    exact
      ⟨fun ⟨a, e⟩ => ⟨_, ⟨_, e⟩, by simpa [List.headI_eq_head?] using (List.drop 1 x).length_pos_of_ne_nil e⟩,
        by simp⟩
  | _ =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]

Repaired Proof:
theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n ∧ k ≤ x.length := by
  induction c generalizing n x with
  | zero' =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
  | succ =>
    simp (config := { contextual := true }) [evaln, bind, exists_and_left, exists_or]
  | pred =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | comp f g _ _ =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | rfind' f =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
    cases x.headI <;> simp [List.headI_eq_head?]
    exact
      ⟨fun ⟨a, e⟩ => ⟨_, ⟨_, e⟩, by simpa [List.headI_eq_head?] using (List.drop 1 x).length_pos_of_ne_nil e⟩,
        by simp⟩
  | _ =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]

Repaired Proof:
theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n ∧ k ≤ x.length := by
  induction c generalizing n x with
  | zero' =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
  | succ =>
    simp (config := { contextual := true }) [evaln, bind, exists_and_left, exists_or]
  | pred =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | comp _ _ _ _ =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | rfind' f =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
    cases x.headI <;> simp [List.headI_eq_head?]
    exact
      ⟨fun ⟨a, e⟩ => ⟨_, ⟨_, e⟩, by simpa [List.headI_eq_head?] using (List.drop 1 x).length_pos_of_ne_nil e⟩,
        by simp⟩
  | _ =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]

Repaired Proof:
theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n ∧ k ≤ x.length := by
  induction c generalizing n x with
  | zero' =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
  | succ =>
    simp (config := { contextual := true }) [evaln, bind, exists_and_left, exists_or]
  | pred =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | comp _ _ _ _ =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | rfind' f =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
    cases x.headI <;> simp [List.headI_eq_head?]
    exact
      ⟨fun ⟨a, e⟩ => ⟨_, ⟨_, e⟩, by simpa [List.headI_eq_head?] using (List.drop 1 x).length_pos_of_ne_nil e⟩,
        by simp⟩
  | _ =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]

Repaired Proof:
theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n ∧ k ≤ x.length := by
  induction c generalizing n x with
  | zero' =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
  | succ =>
    simp (config := { contextual := true }) [evaln, bind, exists_and_left, exists_or]
  | pred =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | comp _ _ _ _ =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | rfind' f =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
    cases x.headI <;> simp [List.headI_eq_head?]
    exact
      ⟨fun ⟨a, e⟩ => ⟨_, ⟨_, e⟩, by simpa [List.headI_eq_head?] using (List.drop 1 x).length_pos_of_ne_nil e⟩,
        by simp⟩
  | _ =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]

Repaired Proof:
theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n ∧ k ≤ x.length := by
  induction c generalizing n x with
  | zero' =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
  | succ =>
    simp (config := { contextual := true }) [evaln, bind, exists_and_left, exists_or]
  | pred =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | comp _ _ _ _ =>
    simp (config := { contextual := true }) [evaln, bind, and_assoc, exists_or]
  | rfind' f =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]
    cases x.headI <;> simp [List.headI_eq_head?]
    exact
      ⟨fun ⟨a, e⟩ => ⟨_, ⟨_, e⟩, by simpa [List.headI_eq_head?] using (List.drop 1 x).length_pos_of_ne_nil e⟩,
        by simp⟩
  | _ =>
    simp (config := { contextual := true }) [evaln, pure, and_assoc, exists_or]

Repaired Proof:
theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n ∧ k ≤ x.length := by
  induction c generalizing n x

Attempt failure.

Working on Mathlib/Computability/Primrec.lean - 2024-09-09 01:44:14.127273.
---62/200---
For theorem Primrec.list_reverse in Mathlib/Computability/Primrec.lean:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) 


Original valid proof:
:=
  letI := prim H
  (list_foldl' H .id (const []) <| to₂ <| ((list_cons' H).comp snd fst).comp snd).of_eq
    (suffices ∀ l r, List.foldl (fun (s : List β) (b : β) => b :: s) r l = List.reverseAux l r from
      fun l => this l []
    fun l => by induction l <;> simp [*, List.reverseAux])


Verifying proof (Commit b912476b37f2ea41ee51af7e63439f4a769be095):
∧ @Primrec' 1 fun l => l.reverse.length := by
  haveI := prim H
  refine' ⟨(list_foldr_append.comp (list_cons.comp snd fst) snd).of_eq fun l => _,
    ((list_foldr_length.comp (list_cons.comp snd fst) snd).comp snd).of_eq fun l => _⟩
  · simp only [List.foldr_append, List.foldr_cons, List.append_assoc, List.reverse_cons,
      List.foldr_append, List.foldr_cons, List.append_assoc]
    rfl
  · simp only [List.length_reverse]

Repaired Proof:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) ∧ @Primrec' 1 fun l => l.reverse.length := by
  haveI := prim H
  refine ⟨(list_foldr_append.comp (list_cons.comp snd fst) snd).of_eq fun l => ?_,
    ((list_foldr_length.comp (list_cons.comp snd fst) snd).comp snd).of_eq fun l => ?_⟩
  · simp only [List.foldr_append, List.foldr_cons, List.append_assoc, List.reverse_cons,
      List.foldr_append, List.foldr_cons, List.append_assoc]
    rfl
  · simp only [List.length_reverse]

Repaired Proof:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) ∧ @Primrec' 1 fun l => l.reverse.length := by
  haveI := prim H
  refine ⟨(list_foldr_append.comp (list_cons.comp snd fst) snd).of_eq fun l => ?_,
    ((list_foldr_length.comp (list_cons.comp snd fst) snd).comp snd).of_eq fun l => ?_⟩
  · simp only [List.foldr_append, List.foldr_cons, List.append_assoc, List.reverse_cons,
      List.foldr_append, List.foldr_cons, List.append_assoc]
    rfl
  · simp only [List.length_reverse]

Repaired Proof:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) ∧ @Primrec' 1 fun l => l.reverse.length := by
  haveI := prim H
  refine ⟨(list_foldr_append.comp (list_cons.comp snd fst) snd).of_eq fun l => ?_,
    ((list_foldr_length.comp (list_cons.comp snd fst) snd).comp snd).of_eq fun l => ?_⟩
  · simp only [List.foldr_append, List.foldr_cons, List.append_assoc, List.reverse_cons,
      List.foldr_append, List.foldr_cons, List.append_assoc]
    rfl
  · simp only [List.length_reverse]

Repaired Proof:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) ∧ @Primrec' 1 fun l => l.reverse.length := by
  haveI := prim H
  refine ⟨(list_foldr_append.comp (list_cons.comp snd fst) snd).of_eq fun l => ?_,
    ((list_foldr_length.comp (list_cons.comp snd fst) snd).comp snd).of_eq fun l => ?_⟩
  · simp only [List.foldr_append, List.foldr_cons, List.append_assoc, List.reverse_cons,
      List.foldr_append, List.foldr_cons, List.append_assoc]
    rfl
  · simp only [List.length_reverse]

Repaired Proof:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) ∧ @Primrec' 1 fun l => l.reverse.length := by
  haveI := prim H
  refine ⟨(list_foldr_append.comp (list_cons.comp snd fst) snd).of_eq fun l => ?_,
    ((list_foldr_length.comp (list_cons.comp snd fst) snd).comp snd).of_eq fun l => ?_⟩
  · simp only [List.foldr_append, List.foldr_cons, List.append_assoc, List.reverse_cons,
      List.foldr_append, List.foldr_cons, List.append_assoc]
    rfl
  · simp only [List.length_reverse]

Repaired Proof:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) ∧ @Primrec' 1 fun l => l.reverse.length := by
  haveI := prim H
  refine ⟨(list_foldr_append.comp (list_cons.comp snd fst) snd).of_eq fun l => ?_,
    ((list_foldr_length.comp (list_cons.comp snd fst) snd).comp snd).of_eq fun l => ?_⟩
  · simp only [List.foldr_append, List.foldr_cons, List.append_assoc, List.reverse_cons,
      List.foldr_append, List.foldr_cons, List.append_assoc]
    rfl
  · simp only [List.length_reverse]

Repaired Proof:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) ∧ @Primrec' 1 fun l => l.reverse.length := by
  haveI := prim H
  refine ⟨(list_foldr_append.comp (list_cons.comp snd fst) snd).of_eq fun l => ?_,
    ((list_foldr_length.comp (list_cons.comp snd fst) snd).comp snd).of_eq fun l => ?_⟩
  · simp only [List.foldr_append, List.foldr_cons, List.append_assoc, List.reverse_cons,
      List.foldr_append, List.foldr_cons, List.append_assoc]
    rfl
  · simp only [List.length_reverse]

Repaired Proof:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) ∧ @Primrec' 1 fun l => l.reverse.length := by
  haveI := prim H
  refine ⟨(list_foldr_append.comp (list_cons.comp snd fst) snd).of_eq fun l => ?_,
    ((list_foldr_length.comp (list_cons.comp snd fst) snd).comp snd).of_eq fun l => ?_⟩
  · simp only [List.foldr_append, List.foldr_cons, List.append_assoc, List.reverse_cons,
      List.foldr_append, List.foldr_cons, List.append_assoc]
    rfl
  · simp only [List.length_reverse]

Repaired Proof:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) ∧ @Primrec' 1 fun l => l.reverse.length := by
  haveI := prim H
  refine ⟨(list_foldr_append.comp (list_cons.comp snd fst) snd).of_eq fun l => ?_,
    ((list_foldr_length.comp (list_cons.comp snd fst) snd).comp snd).of_eq fun l => ?_⟩
  · simp only [List.foldr_append, List.foldr_cons, List.append_assoc, List.reverse_cons,
      List.foldr_append, List.foldr_cons, List.append_assoc]
    rfl
  · simp only [List.length_reverse]

Repaired Proof:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) ∧ @Primrec' 1 fun l => l.reverse.length := by
  haveI := prim H
  refine ⟨(list_foldr_append.comp (list_cons.comp snd fst) snd).of_eq fun l => ?_,
    ((list_foldr_length.comp (list_cons.comp snd fst) snd).comp snd).of_eq fun l => ?_⟩
  · simp only [List.foldr_append, List.foldr_cons, List.append_assoc, List.reverse_cons,
      List.foldr_append, List.foldr_cons, List.append_assoc]
    rfl
  · simp only

Attempt failure.

---63/200---
For theorem Primrec.bind_decode_iff in Mathlib/Computability/Primrec.lean:
theorem bind_decode_iff {f : α → β → Option σ} :
    (Primrec₂ fun a n => (@decode β _ n).bind (f a)) ↔ Primrec₂ f 


Original valid proof:
:=
  ⟨fun h => by simpa [encodek] using h.comp fst ((@Primrec.encode β _).comp snd), fun h =>
    option_bind (Primrec.decode.comp snd) <| h.comp (fst.comp fst) snd⟩


Verifying proof (Commit b912476b37f2ea41ee51af7e63439f4a769be095):
∧ Primrec fun a => encode a :=
  Iff.rfl


theorem map_decode_iff {f : α → β → σ} :
    (Primrec₂ fun a n => (@decode β _ n).map (f a)) ↔ Primrec₂ f ∧ Primrec fun a => encode a :=
  Iff.rfl


theorem nat_add : Primrec₂ ((· + ·) : ℕ → ℕ → ℕ) :=
  Primrec.ofNat_add.to₂


theorem nat_sub : Primrec₂ ((· - ·) : ℕ → ℕ → ℕ) :=
  Primrec₂.unpaired'.1 Nat.Primrec.sub


theorem cond {c : α → Bool} {f : α → σ} {g : α → σ} (hc : Primrec c) (hf : Primrec f)
    (hg : Primrec g) : Primrec fun a => bif (c a) then (f a) else (g a) :=
  (nat_casesOn (encode_iff.2 hc) hg (hf.comp fst).to₂).of_eq fun a => by cases c a <;> rfl


theorem ite {c : α → Prop} [DecidablePred c] {f : α → σ} {g : α → σ} (hc : PrimrecPred c)
    (hf : Primrec f) (hg : Primrec g) : Primrec fun a => if c a then f a else g a := by
  simpa [Bool.cond_decide] using cond hc hf hg


theorem nat_le : PrimrecRel ((· ≤ ·) : ℕ → ℕ → Prop) :=
  (nat_casesOn nat_sub (const true) (const false).to₂).of_eq fun p => by
    dsimp [swap]
    cases' e : p.2 - p.1 with n
    · simp [tsub_eq_zero_iff_le.1 e]
    · simp [not_le.2 (Nat.lt_of_sub_eq_succ e)]


theorem nat_min : Primrec₂ (@min ℕ _) :=
  ite nat_le fst snd


theorem nat_max : Primrec₂ (@max ℕ _) :=
  ite nat_le snd fst


theorem dom_bool₂ (f : Bool → Bool → σ) : Primrec₂ f :=
  (cond fst ((dom_bool fst).comp snd) ((dom_bool snd).comp fst)).of_eq fun ⟨a, b⟩ => by cases a <;> cases b <;> rfl


protected theorem encode : Primrec (@encode α _) :=
  (@Primcodable.prim α _).of_eq fun n => (encodek n).symm


theorem dom_decode₂ : Primrec₂ fun n a => (@decode α _ n).getD a :=
  nat_rec' (dom_bool _) <|
    (nat_casesOn fst (dom_bool _).to₂ (snd.comp snd).to₂).of_eq fun n => by
      cases' e : decode (succ n) with a <;> simp [encodek, e]


theorem nat_add_one : Primrec Nat.succ :=
  nat_add nat_one


theorem dom_nat_iterate {f : α → ℕ → Option σ} {p : α → ℕ → Prop} [∀ a n, Decidable (p a n)]
    (H : PrimrecRel p) (hf : Primrec₂ f) :
    Primrec₂ fun a (n : ℕ) => (n.iterate fun n a => (f a n).bind fun b => guard (p a (n + 1))).bind fst :=
  (nat_rec' (dom_bool _)
    (dom_bool _)).of_eq
    fun ⟨a, n⟩ => by
    induction' n with n IH; · rfl
    simp [IH]; cases' e : decode (succ n) with b <;> simp [e]


theorem nat_iterate {f : α → ℕ → Option σ} {p : α → ℕ → Prop} [∀ a n, Decidable (p a n)]
    (H : PrimrecRel p) (hf : Primrec₂ f) :
    Primrec₂ fun a (n : ℕ) => (n.iterate fun n a => (f a n).bind fun b => guard (p a (n + 1))).bind fst :=
  dom_nat_iterate H hf


theorem nat_bodd : Primrec Nat.bodd :=
  (Primrec.beq.comp (nat_mod.comp snd (const 2)) (const 1)).of_eq fun n => by
    cases H : n.bodd <;> simp [Nat.mod_two_of_bodd, H]


theorem nat_div2 : Primrec Nat.div2 :=
  (nat_div.comp (const 2) snd).of_eq fun n => by
    cases H : n.div2 <;> simp [Nat.div2_val, H]


theorem cond_prim {c : α → Bool} {f : α → σ} {g : α → σ} (hc : Primrec c) (hf : Primrec f)
    (hg : Primrec g) : Primrec fun a => cond (c a) (f a) (g a) :=
  ite (Primrec.comp hc Primrec.encode) hf hg


theorem nat_boddDiv2 : Primrec Nat.boddDiv2 :=
  (cond_prim nat_bodd (fst.comp snd) (snd.comp snd)).of_eq fun n => by
    cases' e : n.bodd with b; · rfl
    simp [e, Nat.boddDiv2]


theorem nat_boddDiv2_eq :
    Primrec₂ fun n k =>
      (@decode (ℕ × Bool) _ n).getD (0, ff)
        (cond (bodd k) (succ <$> div2 k, true) (div2 k, false)) :=
  (nat_boddDiv2.comp fst).of_eq fun n => by
    cases' e : decode n with x; · rfl
    cases x with | mk x b =>
    simp [e, bodd, div2, Primrec.cond_eq_ite, ite_bool_eq]


theorem nat_boddDiv2_eq' :
    Primrec₂ fun n k =>
      (@decode (ℕ × Bool) _ n).getD (0, ff)
        (cond (bodd k) (succ <$> div2 k, true) (div2 k, false)) :=
  nat_boddDiv2_eq.of_eq fun n => by
    cases' e : decode n with x; · rfl
    cases x with | mk x b =>
    simp [e, bodd, div2, Primrec.cond_eq_ite, ite_bool_eq]


theorem nat_boddDiv2_eq'' :
    Primrec₂ fun n k =>
      (@decode (ℕ × Bool) _ n).getD (0, ff)
        (cond (bodd k) (succ <$> div2 k, true) (div2 k, false)) :=
  nat_boddDiv2_eq'.of_eq fun n => by
    cases' e : decode n with x; · rfl
    cases x with | mk x b =>
    simp [e, bodd, div2, Primrec.cond_eq_ite, ite_bool_eq]


theorem nat_boddDiv2_eq''' :
    Primrec₂ fun n k =>
      (@decode (ℕ × Bool) _ n).getD (0, ff)
        (cond (bodd k) (succ <$> div2 k, true) (div2 k, false)) :=
  nat_boddDiv2_eq''.of_eq fun n => by
    cases' e : decode n with x; · rfl
    cases x with | mk x b =>
    simp [e, bodd, div2, Primrec.cond_eq_ite, ite_bool_eq]


theorem nat_boddDiv2_eq'''' :
    Primrec₂ fun n k =>
      (@decode (ℕ × Bool) _ n).getD (0, ff)
        (cond (bodd k) (succ <$> div2 k, true) (div2 k, false)) :=
  nat_boddDiv2_eq'''.of_eq fun n => by
    cases' e : decode n with x; · rfl
    cases x with | mk x b =>
    simp [e, bodd, div2, Primrec.cond_eq_ite, ite_bool_eq]


theorem nat_boddDiv2_eq''''' :
   

Attempt failure.

---64/200---
For theorem Nat.Primrec'.vec_iff in Mathlib/Computability/Primrec.lean:
theorem vec_iff {m n f} : @Vec m n f ↔ Primrec f 


Original valid proof:
:=
  ⟨fun h => by simpa using Primrec.vector_ofFn fun i => to_prim (h i), fun h i =>
    of_prim <| Primrec.vector_get.comp h (.const i)⟩


Verifying proof (Commit b912476b37f2ea41ee51af7e63439f4a769be095):
∧ ∀ a, Vec (f a) :=
  χ_iff.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

@[simp]
theorem vec_iff' {m n f} : @Vec m n f ↔ Primrec₂ f ∧ ∀ a, Vec (f a) :=
  vec_iff.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, h₂⟩, fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩⟩

theorem vec_iff₂ {m n f} : @Vec m n f ↔ Primrec₂ f ∧ ∀ a, Vec (f a) :=
  vec_iff'.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

@[simp]
theorem vec_iff₂' {m n f} : @Vec m n f ↔ Primrec₂ f ∧ ∀ a, Vec (f a) :=
  vec_iff₂.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, h₂⟩, fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩⟩

theorem vec_iff₃ {m n f} : @Vec m n f ↔ Primrec₃ f ∧ ∀ a, Vec (f a) :=
  vec_iff.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

@[simp]
theorem vec_iff₃' {m n f} : @Vec m n f ↔ Primrec₃ f ∧ ∀ a, Vec (f a) :=
  vec_iff₃.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

theorem vec_iff₄ {m n f} : @Vec m n f ↔ Primrec₄ f ∧ ∀ a, Vec (f a) :=
  vec_iff.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

@[simp]
theorem vec_iff₄' {m n f} : @Vec m n f ↔ Primrec₄ f ∧ ∀ a, Vec (f a) :=
  vec_iff₄.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

theorem vec_iff₅ {m n f} : @Vec m n f ↔ Primrec₅ f ∧ ∀ a, Vec (f a) :=
  vec_iff.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

@[simp]
theorem vec_iff₅' {m n f} : @Vec m n f ↔ Primrec₅ f ∧ ∀ a, Vec (f a) :=
  vec_iff₅.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

theorem vec_iff₆ {m n f} : @Vec m n f ↔ Primrec₆ f ∧ ∀ a, Vec (f a) :=
  vec_iff.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

@[simp]
theorem vec_iff₆' {m n f} : @Vec m n f ↔ Primrec₆ f ∧ ∀ a, Vec (f a) :=
  vec_iff₆.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

theorem vec_iff₇ {m n f} : @Vec m n f ↔ Primrec₇ f ∧ ∀ a, Vec (f a) :=
  vec_iff.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

@[simp]
theorem vec_iff₇' {m n f} : @Vec m n f ↔ Primrec₇ f ∧ ∀ a, Vec (f a) :=
  vec_iff₇.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

theorem vec_iff₈ {m n f} : @Vec m n f ↔ Primrec₈ f ∧ ∀ a, Vec (f a) :=
  vec_iff.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂⟩ =>
      ⟨h₁, fun a => by simpa using h₂ a⟩⟩

@[simp]
theorem vec_iff₈' {m n f} : @Vec m n f ↔ Primrec₈ f ∧ ∀ a, Vec (f a) :=
  vec_iff₈.trans
    ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, fun a => (h₂ a).of_eq fun i => by simp⟩, fun ⟨h₁, h₂�

Attempt failure.

---65/200---
For theorem Primcodable.mem_range_encode in Mathlib/Computability/Primrec.lean:
theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) 


Original valid proof:
:=
  have : PrimrecPred fun n => Encodable.decode₂ α n ≠ none :=
    .not
      (Primrec.eq.comp
        (.option_bind .decode
          (.ite (Primrec.eq.comp (Primrec.encode.comp .snd) .fst)
            (Primrec.option_some.comp .snd) (.const _)))
        (.const _))
  this.of_eq fun _ => decode₂_ne_none_iff


Verifying proof (Commit b912476b37f2ea41ee51af7e63439f4a769be095):
↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈ Set.range (encode : α → ℕ)) =
      (fun n => ∃ a, encode a = n) := by
    funext n
    simp only [Set.mem_range, exists_exists_eq_and]
  rw [this]
  simp only [Set.mem_range, exists_exists_eq_and]
  exact exists_iff_of_comm (t := fun a => encode a = n)
    (fun a => (encode_injective _ _).eq_iff)

theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) ↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈ Set.range (encode : α → ℕ)) =
      (fun n => ∃ a, encode a = n) := by
    funext n
    simp only [Set.mem_range, exists_exists_eq_and]
  rw [this]
  simp only [Set.mem_range, exists_exists_eq_and]
  exact exists_iff_of_comm (t := fun a => encode a = n)
    (fun a => (encode_injective _ _).eq_iff)

theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) ↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈ Set.range (encode : α → ℕ)) =
      (fun n => ∃ a, encode a = n) := by
    funext n
    simp only [Set.mem_range, exists_exists_eq_and]
  rw [this]
  simp only [Set.mem_range, exists_exists_eq_and]
  exact exists_iff_of_comm (t := fun a => encode a = n)
    (fun a => (encode_injective _ _).eq_iff)

theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) ↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈ Set.range (encode : α → ℕ)) =
      (fun n => ∃ a, encode a = n) := by
    funext n
    simp only [Set.mem_range, exists_exists_eq_and]
  rw [this]
  simp only [Set.mem_range, exists_exists_eq_and]
  exact exists_iff_of_comm (t := fun a => encode a = n)
    (fun a => (encode_injective _ _).eq_iff)

theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) ↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈ Set.range (encode : α → ℕ)) =
      (fun n => ∃ a, encode a = n) := by
    funext n
    simp only [Set.mem_range, exists_exists_eq_and]
  rw [this]
  simp only [Set.mem_range, exists_exists_eq_and]
  exact exists_iff_of_comm (t := fun a => encode a = n)
    (fun a => (encode_injective _ _).eq_iff)

theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) ↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈ Set.range (encode : α → ℕ)) =
      (fun n => ∃ a, encode a = n) := by
    funext n
    simp only [Set.mem_range, exists_exists_eq_and]
  rw [this]
  simp only [Set.mem_range, exists_exists_eq_and]
  exact exists_iff_of_comm (t := fun a => encode a = n)
    (fun a => (encode_injective _ _).eq_iff)

theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) ↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈ Set.range (encode : α → ℕ)) =
      (fun n => ∃ a, encode a = n) := by
    funext n
    simp only [Set.mem_range, exists_exists_eq_and]
  rw [this]
  simp only [Set.mem_range, exists_exists_eq_and]
  exact exists_iff_of_comm (t := fun a => encode a = n)
    (fun a => (encode_injective _ _).eq_iff)

theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) ↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈ Set.range (encode : α → ℕ)) =
      (fun n => ∃ a, encode a = n) := by
    funext n
    simp only [Set.mem_range, exists_exists_eq_and]
  rw [this]
  simp only [Set.mem_range, exists_exists_eq_and]
  exact exists_iff_of_comm (t := fun a => encode a = n)
    (fun a => (encode_injective _ _).eq_iff)

theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) ↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈ Set.range (encode : α → ℕ)) =
      (fun n => ∃ a, encode a = n) := by
    funext n
    simp only [Set.mem_range, exists_exists_eq_and]
  rw [this]
  simp only [Set.mem_range, exists_exists_eq_and]
  exact exists_iff_of_comm (t := fun a => encode a = n)
    (fun a => (encode_injective _ _).eq_iff)

theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) ↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈ Set.range (encode : α → ℕ)) =
      (fun n => ∃ a, encode a = n) := by
    funext n
    simp only [Set.mem_range, exists_exists_eq_and]
  rw [this]
  simp only [Set.mem_range, exists_exists_eq_and]
  exact exists_iff_of_comm (t := fun a => encode a = n)
    (fun a => (encode_injective _ _).eq_iff)

theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) ↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈ Set.range (encode : α → ℕ)) =
      (fun n => ∃ a, encode a = n) := by
    funext n
    simp only [Set.mem_range, exists_exists_eq_and]
  rw [this]
  simp only [Set.mem_range, exists_exists_eq_and]
  exact exists_iff_of_comm (t := fun a => encode a = n)
    (fun a => (encode_injective _ _).eq_iff)

theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) ↔
    PrimrecPred fun n => n ∈ Set.range (@decode α _) := by
  have :
    (fun n => n ∈

Attempt failure.

Working on Mathlib/Data/DFinsupp/Basic.lean - 2024-09-09 01:44:54.639260.
---66/200---
For theorem DFinsupp.filter_single in Mathlib/Data/DFinsupp/Basic.lean:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 


Original valid proof:
:= by
  ext j
  have := apply_ite (fun x : Π₀ i, β i => x j) (p i) (single i x) 0
  dsimp at this
  rw [filter_apply, this]
  obtain rfl | hij := Decidable.eq_or_ne i j
  · rfl
  · rw [single_eq_of_ne hij, ite_self, ite_self]


Verifying proof (Commit 166d0bf5448fdaad518cf95891af45e08a3e9c35):
0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 := by
  ext j
  have := apply_single (β := fun i => (L[i] : β i →ₗ[R] β i)) p i x j
  dsimp at this
  split_ifs at this with h
  · simp [h]
  · simp only [h, map_zero] at this
    simp [this]

Repaired Proof:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :


Attempt failure.

Working on Mathlib/Data/Finset/Image.lean - 2024-09-09 01:45:10.458708.
---67/200---
For theorem Finset.image_symmDiff in Mathlib/Data/Finset/Image.lean:
theorem image_symmDiff [DecidableEq α] {f : α → β} (s t : Finset α) (hf : Injective f) :
    (s ∆ t).image f = s.image f ∆ t.image f 


Original valid proof:
:=
  mod_cast Set.image_symmDiff hf s t


Verifying proof (Commit b0304b2532b035fd00ff51805ac89317b4114265):
∧ (s ∆ t).image f = (s.image f)ᶜ ∆ (t.image f)ᶜ := by
  simp only [image_sdiff, image_union, hf.injOn, union_comm, sdiff_inj,
    (sdiff_inj (hf.injOn _) (hf.injOn _)).1]
  rw [sdiff_eq_compl_inter, sdiff_eq_compl_inter, inter_comm, inter_comm t.image]
  simp only [compl_inter, compl_compl]
  rfl


theorem image_symmDiff' [DecidableEq β] {f : α → β} (s t : Finset α)
    (hf : Set.BijOn f (s ∆ t) (f '' (s ∆ t))) : f '' (s ∆ t) = f '' s ∆ f '' t :=
  hf.image_eq


theorem image_symmDiff_distrib {f : β → γ} {g : α → γ} {f' : β' → γ} {g' : α' → γ} :
    (s.image f ∆ t.image g) = (s.image f ∆ t.image g').image (fun x => x.1) ∆
      (s.image f ∆ t.image g).image (fun x => x.2) := by
  simp_rw [← image_symmDiff]
  rw [image_symmDiff_image]
  simp_rw [image_image, image_eq_image_of_eqOn (s.image_symmDiff_subset_image_symmDiff _ _).antisymm
    (s.image_symmDiff_subset_image_symmDiff _ _).antisymm]
  rfl


theorem image_symmDiff_union_image_symmDiff_inter {f : α → β} (s t : Finset α)
    (hf : Injective f) : (s.image f ∆ t.image f) ∪ (s ∩ t).image f = (s ∪ t).image f ∆ (s ∩ t).image f :=
  by rw [image_symmDiff, image_union, image_inter hf, sup_eq_union, inf_eq_inter]

theorem image_symmDiff_union_image_inter_subset {f : α → β} (s t : Finset α)
    (hf : Injective f) : (s.image f ∆ t.image f) ∪ (s ∩ t).image f ⊆ (s ∪ t).image f :=
  by rw [image_symmDiff, image_union, image_inter hf]; exact union_subset_union diff_subset subset_union_left

theorem image_union_image_inter_eq_image_union {f : α → β} (s t : Finset α)
    (hf : ∀ x ∈ s, ∀ y ∈ t, f x = f y → x = y) :
    (s ∪ t).image f = s.image f ∪ t.image f :=
  image_union_image_inter_of_injOn _ (fun _ _ => hf _) _


theorem image_inter_image_inter_eq_image_inter {f : α → β} (s t : Finset α)
    (hf : ∀ x ∈ s, ∀ y ∈ t, f x = f y → x = y) :
    s.image f ∩ t.image f = (s ∩ t).image f :=
  image_inter_image_inter_of_injOn _ (fun _ _ => hf _) _


theorem image_inter_image_eq_image_inter_of_injOn {f : α → β} (s t : Finset α)
    (hf : ∀ x ∈ s, ∀ y ∈ t, f x = f y → x = y) :
    s.image f ∩ t.image f = (s ∩ t).image f :=
  image_inter_image_eq_image_inter_of_injOn' _ (fun _ _ => hf _) _


theorem image_inter_preimage_eq_inter_image {f : α → β} (s : Finset α) (t : Finset β) :
    ((s ∩ f ⁻¹' t).image f ∩ t) = s.image f ∩ t :=
  ext fun x => by
    simp only [mem_inter, mem_image, mem_preimage, and_assoc, exists_prop]
    exact
      ⟨fun ⟨⟨a, ha, e⟩, b⟩ => ⟨a, ha, e, b⟩, fun ⟨a, ha, e, b⟩ => ⟨⟨a, ha, e⟩, b⟩⟩


theorem image_inter_preimage_eq_inter_image_of_injOn {f : α → β} (s : Finset α) (t : Finset β)
    (hf : Set.InjOn f (f ⁻¹' ↑t)) : ((s ∩ f ⁻¹' t).image f ∩ t) = s.image f ∩ t :=
  ext fun x => by
    simp only [mem_inter, mem_image, mem_preimage, and_assoc, exists_prop]
    exact
      ⟨fun ⟨⟨a, ha, e⟩, b⟩ => ⟨a, ha, e, b⟩,
        fun ⟨a, ha, e, b⟩ =>
        ⟨⟨a, mem_of_mem_inter_left ha, e⟩, by rwa [← hf.eq_iff]⟩⟩


theorem image_inter_preimage_eq_inter_image_of_subset_range {f : α → β} {s : Finset α} {t : Finset β}
    (ht : t ⊆ Set.range f) : ((s ∩ f ⁻¹' t).image f ∩ t) = s.image f ∩ t :=
  ext fun x => by
    simp only [mem_inter, mem_image, mem_preimage, and_assoc, exists_prop]
    exact
      ⟨fun ⟨⟨a, ha, e⟩, b⟩ => ⟨a, ha, e, b⟩,
        fun ⟨a, ha, e, b⟩ =>
        ⟨⟨a, mem_of_mem_inter_left ha, e⟩, by rwa [← mem_range, ← Set.mem_preimage]⟩⟩


theorem image_inter_preimage_of_inverse {f : α → β} {g : β → α} (hf : Set.LeftInverse g f)
    (s : Finset α) (t : Finset β) : ((s ∩ f ⁻¹' t).image f ∩ t) = s.image f ∩ t :=
  image_inter_preimage_eq_inter_image_of_injOn _ _ fun x _ y _ h =>
    hf.injective <| (congr_arg f h).trans (hf x).symm


theorem image_inter_preimage_of_inverse {f : α → β} {g : β → α} (hf : Set.LeftInverse g f)
    (s : Finset α) (t : Finset β) : ((s.image f ∩ g ⁻¹' t) ∩ t) = s.image f ∩ t := by
  rw [inter_comm, inter_comm (s.image f)]
  exact image_inter_preimage_of_inverse hf t s


theorem image_inter_preimage_of_inverse' {f : α → β} {g : β → α} (hf : Set.LeftInverse g f)
    (s : Finset α) (t : Finset β) : ((s.image f ∩ g ⁻¹' t) ∩ t) = s.image f ∩ t := by
  simpa only [inter_comm t, image_inter_preimage_of_inverse hf] using inter_comm (g ⁻¹' t)


theorem image_inter_preimage_of_inverse {f : α → β} {g : β → α} (hf : Set.LeftInverse g f)
    (s : Finset α) (t : Finset β) : ((s ∩ f ⁻¹' t).image f ∩ t) =

Attempt failure.

Working on Mathlib/Data/Finset/Lattice.lean - 2024-09-09 01:45:16.674479.
---68/200---
For theorem Finset.mem_of_max in Mathlib/Data/Finset/Lattice.lean:
theorem mem_of_max {s : Finset α} : ∀ {a : α}, s.max = a → a ∈ s 


Original valid proof:
:= by
  induction' s using Finset.induction_on with b s _ ih
  · intro _ H; cases H
  · intro a h
    by_cases p : b = a
    · induction p
      exact mem_insert_self b s
    · cases' max_choice (↑b) s.max with q q <;> rw [max_insert, q] at h
      · cases h
        cases p rfl
      · exact mem_insert_of_mem (ih h)


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
→ ∀ {b : α}, b ∈ s → a ≤ b :=
    @le_max_of_eq_max _ s _
  #noalign finset.le_max_of_eq_max_of_mem

theorem not_mem_of_max_lt_coe {a : α} {s : Finset α} (h : s.max < a) : a ∉ s :=
  mt le_max_of_eq_max_of_mem h.not_le


theorem not_mem_of_max_lt {a : α} {s : Finset α} (h : s.max < a) : a ∉ s :=
  mt le_max_of_eq_max_of_mem h.not_le


theorem not_mem_of_lt_min {a : α} {s : Finset α} (h : a < s.min) : a ∉ s :=
  mt min_le_of_eq_min_of_mem h.not_le


theorem not_mem_of_lt_min' {a : α} {s : Finset α} (h : a < s.min') : a ∉ s :=
  mt min'_le_of_eq_min'_of_mem h.not_le


theorem min_le_of_eq {s : Finset α} {a b : α} (h₁ : a ∈ s) (h₂ : s.min = a) : a ≤ b :=
  WithTop.coe_le_coe.1 <| h₂.ge.trans (min_le h₁)


theorem not_mem_of_lt_min {a : α} {s : Finset α} (h₁ : a < s.min) : a ∉ s :=
  mt min_le_of_eq h₁.not_le


theorem not_mem_of_lt_min' {a : α} {s : Finset α} (h₁ : a < s.min') : a ∉ s :=
  mt min'_le_of_eq h₁.not_le


theorem not_mem_of_max_lt {a : α} {s : Finset α} (h₁ : a < s.max) : a ∉ s :=
  mt le_max_of_eq h₁.not_le


theorem not_mem_of_max'_lt {a : α} {s : Finset α} (h₁ : a < s.max') : a ∉ s :=
  mt max'_le_of_eq h₁.not_le


theorem not_mem_of_lt_min' {a : α} {s : Finset α} (h₁ : a < s.min') : a ∉ s :=
  mt min'_le_of_eq h₁.not_le


theorem not_mem_of_lt_min {a : α} {s : Finset α} (h₁ : a < s.min) : a ∉ s :=
  mt min_le_of_eq h₁.not_le


theorem not_mem_of_max'_lt_coe {a : α} {s : Finset α} (h : s.max' _ < a) : a ∉ s :=
  mt le_max' h.not_le


theorem not_mem_of_max'_lt {a : α} {s : Finset α} (h : s.max' _ < a) : a ∉ s :=
  mt le_max' h.not_le


theorem not_mem_of_lt_min' {a : α} {s : Finset α} (h : a < s.min' _) : a ∉ s :=
  mt min'_le h.not_le


theorem not_mem_of_lt_min {a : α} {s : Finset α} (h : a < s.min) : a ∉ s :=
  mt min_le h.not_le


theorem not_mem_of_max'_lt_of_not_mem {a : α} {s : Finset α} (h : a < s.max' _) (ha : a ∉ s) :
    False :=
  ha <| not_mem_of_max'_lt h


theorem not_mem_of_lt_min'_of_not_mem {a : α} {s : Finset α} (h : a < s.min' _) (ha : a ∉ s) :
    False :=
  ha <| not_mem_of_lt_min' h


theorem not_mem_of_max'_lt_of_not_mem' {a : α} {s : Finset α} (h : a < s.max' _)
    (ha : a ∉ s.insert a) : False :=
  ha <| not_mem_of_max'_lt_of_not_mem h <| mt mem_insert.2 fun h => h <| mem_singleton_self _


theorem not_mem_of_lt_min'_of_not_mem' {a : α} {s : Finset α} (h : a < s.min' _)
    (ha : a ∉ s.insert a) : False :=
  ha <| not_mem_of_lt_min' h <| mt mem_insert.2 fun h => h <| mem_singleton_self _


theorem not_mem_of_max'_lt_of_not_mem {a : α} {s : Finset α} (h : a < s.max' _)
    (ha : a ∉ s) : False :=
  not_mem_of_max'_lt_of_not_mem' h <| mt mem_insert.1 fun h => h <| mem_singleton_self _


theorem not_mem_of_lt_min'_of_not_mem {a : α} {s : Finset α} (h : a < s.min' _)
    (ha : a ∉ s) : False :=
  not_mem_of_lt_min'_of_not_mem' h <| mt mem_insert.1 fun h => h <| mem_singleton_self _


theorem not_mem_of_max'_lt_of_not_mem' {a : α} {s : Finset α} (h : a < s.max' _)
    (ha : a ∉ s.insert a) : False :=
  not_mem_of_max'_lt_of_not_mem h <| mt mem_insert.2 fun h => h <| mem_singleton_self _


theorem not_mem_of_lt_min'_of_not_mem' {a : α} {s : Finset α} (h : a < s.min' _)
    (ha : a ∉ s.insert a) : False :=
  not_mem_of_lt_min' h <| mt mem_insert.2 fun h => h <| mem_singleton_self _


theorem not_mem_of_max'_lt_of_not_mem {a : α} {s : Finset α} (h : a < s.max' _)
    (ha : a ∉ s) : False :=
  not_mem_of_max'_lt_of_not_mem' h <| mt mem_insert.1 fun h => h <| mem_singleton_self _


theorem not_mem_of_lt_min'_of_not_mem {a : α} {s : Finset α} (h : a < s.min' _)
    (ha : a ∉ s) : False :=
  not_mem_of_lt_min' h <| mt mem_insert.1 fun h => h <| mem_singleton_self _


theorem not_mem_of_max'_lt_of_not_mem' {a : α} {s : Finset α} (h : a < s.max' _)
    (ha : a ∉ s.insert a) : False :=
  not_mem_of_max'_lt_of_not_mem h <| mt mem_insert.2 fun h => h <| mem_singleton_self _


theorem not_mem_of_lt_min'_of_not_mem' {a : α} {s : Finset α} (h : a < s.min' _)
    (ha : a ∉ s.insert a) : False :=
  not_mem_of_lt_min' h <| mt mem_insert.2 fun h => h <| mem_singleton_self _


theorem not_mem_of_max'_lt_of_not_mem {a : α} {s : Finset α} (h : a < s.max' _)
    (ha : a ∉ s) : False :=
  not_mem_of_max'_lt_of_not_mem' h <| mt mem_insert.1 fun h => h <| mem_singleton_self _


theorem not_mem_of_lt_min'_of

Attempt failure.

Working on Mathlib/Data/List/Cycle.lean - 2024-09-09 01:45:28.290233.
---69/200---
For theorem List.prev_next in Mathlib/Data/List/Cycle.lean:
theorem prev_next (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :
    prev l (next l x hx) (next_mem _ _ _) = x 


Original valid proof:
:= by
  obtain ⟨n, hn, rfl⟩ := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  · simp at hx
  · have : (n + 1 + length tl) % (length tl + 1) = n := by
      rw [length_cons] at hn
      rw [add_assoc, add_comm 1, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp only [length_cons, Nat.succ_sub_succ_eq_sub, Nat.sub_zero, Nat.succ_eq_add_one, this]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧ next l (prev l x hx) (prev_mem _ _ _) = x := by
  have := prev_next_mem l h x hx
  rcases prev_next_mem l h x hx with (⟨p, hp, n, hn, hx⟩ | ⟨p, hp, n, hn, hx⟩)
  · rw [← hx] at hp
    exact ⟨(prev_cons_cons_of_ne _ _ _ _ _ hp hn).symm, (next_cons_cons_of_ne _ _ _ _ _ hp hn).symm⟩
  · rw [← hx] at hn
    exact ⟨(prev_cons_cons_of_ne _ _ _ _ _ hn hp).symm, (next_cons_cons_of_ne _ _ _ _ _ hn hp).symm⟩

Repaired Proof:
theorem prev_next (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :
    prev l (next l x hx) (next_mem _ _ _) = x ∧ next l (prev l x hx) (prev_mem _ _ _) = x := by
  have := prev_next_mem l h x hx
  rcases prev_next_mem l h x hx with (⟨p, hp, n, hn, hx⟩ | ⟨p, hp, n, hn, hx⟩)
  · rw [← hx] at hp
    exact ⟨(prev_cons_cons_of_ne _ _ _ _ _ hp hn).symm, (next_cons_cons_of_ne _ _ _ _ _ hp hn).symm⟩
  · rw [← hx] at hn
    exact ⟨(prev_cons_cons_of_ne _ _ _ _ _ hn hp).symm, (next_cons_cons_of_ne _ _ _ _ _ hn hp).symm⟩

Repaired Proof:
theorem next_prev (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :
    next l (prev l x hx) (prev_mem _ _ _) = x ∧ prev l (next l x hx) (next_mem _ _ _) = x := by
  have := prev_next_mem l h x hx
  rcases prev_next_mem l h x hx with (⟨p, hp, n, hn, hx⟩ | ⟨p, hp, n, hn, hx⟩)
  · rw [← hx] at hp
    exact ⟨(next_cons_cons_of_ne _ _ _ _ _ hp hn).symm, (prev_cons_cons_of_ne _ _ _ _ _ hp hn).symm⟩
  · rw [← hx] at hn
    exact ⟨(next_cons_cons_of_ne _ _ _ _ _ hn hp).symm, (prev_cons_cons_of_ne _ _ _ _ _ hn hp).symm⟩

Repaired Proof:
theorem next_prev (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :
    next l (prev l x hx) (prev_mem _ _ _) = x ∧ prev l (next l x hx) (next_mem _ _ _) = x := by
  have := prev_next_mem l h x hx
  rcases prev_next_mem l h x hx with (⟨p, hp, n, hn, hx⟩ | ⟨p, hp, n, hn, hx⟩)
  · rw [← hx] at hp
    exact ⟨(next_cons_cons_of_ne _ _ _ _ _ hp hn).symm, (prev_cons_cons_of_ne _ _ _ _ _ hp hn).symm⟩
  · rw [← hx] at hn
    exact ⟨(next_cons_cons_of_ne _ _ _ _ _ hn hp).symm, (prev_cons_cons_of_ne _ _ _ _ _ hn hp).symm⟩

Repaired Proof:
theorem prev_next (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :
    prev l (next l x hx) (next_mem _ _ _) = x ∧ next l (prev l x hx) (prev_mem _ _ _) = x := by
  have := prev_next_mem l h x hx
  rcases prev_next_mem l h x hx with (⟨p, hp, n, hn, hx⟩ | ⟨p, hp, n, hn, hx⟩)
  · rw [← hx] at hp
    exact ⟨(prev_cons_cons_of_ne _ _ _ _ _ hp hn).symm, (next_cons_cons_of_ne _ _ _ _ _ hp hn).symm⟩
  · rw [← hx] at hn
    exact ⟨(prev_cons_cons_of_ne _ _ _ _ _ hn hp).symm, (next_cons_cons_of_ne _ _ _ _ _ hn hp).symm⟩

Repaired Proof:
theorem next_prev (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :
    next l (prev l x hx) (prev_mem _ _ _) = x ∧ prev l (next l x hx) (next_mem _ _ _) = x := by
  have := prev_next_mem l h x hx
  rcases prev_next_mem l h x hx with (⟨p, hp, n, hn, hx⟩ | ⟨p, hp, n, hn, hx⟩)
  · rw [← hx] at hp
    exact ⟨(next_cons_cons_of_ne _ _ _ _ _ hp hn).symm, (prev_cons_cons_of_ne _ _ _ _ _ hp hn).symm⟩
  · rw [← hx] at hn
    exact ⟨(next_cons_cons_of_ne _ _ _ _ _ hn hp).symm, (prev_cons_cons_of_ne _ _ _ _ _ hn hp).symm⟩

Repaired Proof:
theorem prev_next (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :
    prev l (next l x hx) (next_mem _ _ _) = x ∧ next l (prev l x hx) (prev_mem _ _ _) = x := by
  have := prev_next_mem l h x hx
  rcases prev_next_mem l h x hx with (⟨p, hp, n, hn, hx⟩ | ⟨p, hp, n, hn, hx⟩)
  · rw [← hx] at hp
    exact ⟨(prev_cons_cons_of_ne _ _ _ _ _ hp hn).symm, (next_cons_cons_of_ne _ _ _ _ _ hp hn).symm⟩
  · rw [← hx] at hn
    exact ⟨(prev_cons_cons_of_ne _ _ _ _ _ hn hp).symm, (next_cons_cons_of_ne _ _ _ _ _ hn hp).symm⟩

Repaired Proof:
theorem next_prev (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :
    next l (prev l x hx) (prev_mem _ _ _) = x ∧ prev l (next l x hx) (next_mem _ _ _) = x := by
  have := prev_next_mem l h x hx
  rcases prev_next_mem l h x hx with (⟨p, hp, n, hn, hx⟩ | ⟨p, hp, n, hn, hx⟩)
  · rw [← hx] at hp
    exact ⟨(next_cons_cons_of_ne _ _ _ _ _ hp hn).symm, (prev_cons_cons_of_ne _ _ _ _ _ hp hn).symm⟩
  · rw [← hx] at hn
    exact ⟨(next_cons_cons_of_ne _ _ _ _ _ hn hp).symm, (prev_cons_cons_of_ne

Attempt failure.

Working on Mathlib/Data/List/Indexes.lean - 2024-09-09 01:45:35.091040.
---70/200---
For theorem List.mapIdx_append in Mathlib/Data/List/Indexes.lean:
theorem mapIdx_append_one : ∀ (f : ℕ → α → β) (l : List α) (e : α),
    mapIdx f (l ++ [e]) = mapIdx f l ++ [f l.length e] 


Original valid proof:
:= by
  intros f l e
  unfold mapIdx
  rw [mapIdxGo_append f l [e]]
  simp only [mapIdx.go, Array.size_toArray, mapIdxGo_length, length_nil, Nat.add_zero,
    Array.toList_eq, Array.push_data, Array.data_toArray]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):

  | _, [], _ => rfl
  | _, _ :: _, _ => by simp [mapIdx, mapIdx_append_one]

theorem mapIdx_append : ∀ (f : ℕ → α → β) (l₁ l₂ : List α),
    mapIdx f (l₁ ++ l₂) = mapIdx f l₁ ++ mapIdx f l₂
  | _, [], _ => rfl
  | _, _ :: _, l₂ => by simp [mapIdx, mapIdx_append]

theorem mapIdx_eq_enum_map (l : List α) (f : ℕ → α → β) :
    mapIdx f l = l.enum.map (Function.uncurry f) := by
  induction' l with hd tl hl generalizing f
  · rfl
  · simp [mapIdx, hl]

theorem mapIdx_congr {f g : ℕ → α → β} {l : List α}
    (h : ∀ x ∈ l, ∀ n hn, f n x = g n x) : mapIdx f l = mapIdx g l := by
  induction' l with hd tl hl
  · rfl
  · simp [hl, h]

theorem mapIdx_eq_of_eq_snoc (f g : ℕ → α → β) {l : List α} (h : ∀ x ∈ l, ∀ n hn, f n x = g n x)
    (a : α) (h' : ∀ n hn, f n a = g n a) : mapIdx f l = mapIdx g l := by
  suffices ∀ l' : List α, (∀ x ∈ l', ∀ n hn, f n x = g n x) → mapIdx f l' = mapIdx g l'
    from this l h
  intro l'
  induction' l' with hd tl hl
  · simp
  · intro h
    simp only [mapIdx, List.forall_mem_cons] at h ⊢
    simp [h.1, hl h.2]

theorem mapIdx_eq_of_eq (f g : ℕ → α → β) {l : List α} (h : ∀ x ∈ l, ∀ n hn, f n x = g n x) :
    mapIdx f l = mapIdx g l := by
  induction' l with hd tl hl
  · rfl
  · simp only [mapIdx, List.forall_mem_cons] at h ⊢
    simp [h.1, hl h.2]

theorem mapIdx_eq_mapIdx_of_eq (f g : ℕ → α → β) {l : List α}
    (h : ∀ x ∈ l, ∀ n hn, f n x = g n x) : mapIdx f l = mapIdx g l := by
  induction' l with hd tl hl
  · rfl
  · simp only [mapIdx, List.forall_mem_cons] at h ⊢
    simp [h.1, hl h.2]

theorem mapIdx_eq_mapIdx_iff {f g : ℕ → α → β} {l : List α} :
    mapIdx f l = mapIdx g l ↔ ∀ x ∈ l, ∀ n hn, f n x = g n x := by
  constructor
  · intro h x hx n hn
    rw [← mapIdx_nthLe_mapIdx f l n hn, ← mapIdx_nthLe_mapIdx g l n hn, h]
  · exact mapIdx_eq_mapIdx_of_eq f g

theorem mapIdx_eq_iff_eq_mapIdx {f g : ℕ → α → β} {l : List α} :
    mapIdx f l = mapIdx g l ↔ ∀ n hn, f n (l.get ⟨n, hn⟩) = g n (l.get ⟨n, hn⟩) := by
  constructor
  · intro h n hn
    rw [← nthLe_mapIdx f l n hn, ← nthLe_mapIdx g l n hn, h]
  · intro h
    apply mapIdx_eq_mapIdx_of_eq
    intro x hx n hn
    exact h n hn

theorem mapIdx_eq_iff_eq_mapIdx' {f g : ℕ → α → β} {l : List α} :
    mapIdx f l = mapIdx g l ↔ ∀ n, f n (l.get? n) = g n (l.get? n) := by
  constructor
  · intro h n
    rw [← nthLe_mapIdx f l n (lt_length_left_of_get?_eq_some (h ▸ get?_eq_some.mpr ⟨n, rfl⟩)),
      ← nthLe_mapIdx g l n (lt_length_left_of_get?_eq_some (h ▸ get?_eq_some.mpr ⟨n, rfl⟩)), h]
  · intro h
    apply mapIdx_eq_mapIdx_of_eq
    intro x hx n hn
    rw [get?_eq_get hn] at hx
    exact h n

theorem mapIdx_eq_iff_eq_mapIdx_of_length_eq {f g : ℕ → α → β} {l : List α} {l' : List β}
    (h : l.length = l'.length) :
    mapIdx f l = l' ↔ ∀ n hn, f n (l.get ⟨n, hn⟩) = l'.get ⟨n, h ▸ hn⟩ := by
  constructor
  · intro h' n hn
    rw [← nthLe_mapIdx f l n hn, h', nthLe_of_eq_length h]
  · intro h
    apply (mapIdx_eq_iff_eq_mapIdx.2 h).trans
    rw [h, map_of_eq_length h]

theorem mapIdx_eq_iff_eq_mapIdx_of_length_eq' {f g : ℕ → α → β} {l : List α} {l' : List β}
    (h : l.length = l'.length) :
    l' = mapIdx f l ↔ ∀ n hn, l'.get ⟨n, h ▸ hn⟩ = f n (l.get ⟨n, hn⟩) := by
  rw [eq_comm, mapIdx_eq_iff_eq_mapIdx_of_length_eq h]
  simp [forall_swap]

theorem mapIdx_eq_iff_eq_mapIdx_of_length_eq'' {f g : ℕ → α → β} {l : List α} {l' : List β}
    (h : l.length = l'.length) :
    l.mapIdx f = l' ↔ ∀ n hn, l.get ⟨n, hn⟩ = l'.get ⟨n, h ▸ hn⟩ := by
  rw [eq_comm, mapIdx_eq_iff_eq_mapIdx_of_length_eq h]
  simp [forall_swap]

theorem mapIdx_eq_iff_eq_mapIdx_of_length_eq''' {f g : ℕ → α → β} {l : List α} {l' : List β}
    (h : l.length = l'.length) :
    l'.mapIdx g = l ↔ ∀ n hn, l'.get ⟨n, h ▸ hn⟩ = l.get ⟨n, hn⟩ := by
  rw [eq_comm, mapIdx_eq_iff_eq_mapIdx_of_length_eq h]
  simp [forall_swap]

theorem mapIdx_eq_iff_eq_mapIdx_of_length_eq'''' {f g : ℕ → α → β} {l : List α} {l' : List β}
    (h : l.length = l'.length) :
    l.mapIdx f = l'.mapIdx g ↔ ∀ n hn, f n (l.get ⟨n, hn⟩) = g n (l'.get ⟨n, h ▸ hn⟩) := by
  rw [eq_comm, mapIdx_eq_iff_eq_mapIdx_of_length_eq h]
  simp [forall_swap]

theorem mapIdx_eq_iff_eq_mapIdx_of_length_eq''''' {f g : ℕ

Attempt failure.

Working on Mathlib/Data/List/NodupEquivFin.lean - 2024-09-09 01:45:39.911727.
---71/200---
For theorem List.duplicate_iff_exists_distinct_get in Mathlib/Data/List/NodupEquivFin.lean:
theorem duplicate_iff_exists_distinct_get {l : List α} {x : α} :
    l.Duplicate x ↔
      ∃ (n m : Fin l.length) (_ : n < m),
        x = l.get n ∧ x = l.get m 


Original valid proof:
:= by
  classical
    rw [duplicate_iff_two_le_count, le_count_iff_replicate_sublist,
      sublist_iff_exists_fin_orderEmbedding_get_eq]
    constructor
    · rintro ⟨f, hf⟩
      refine ⟨f ⟨0, by simp⟩, f ⟨1, by simp⟩, f.lt_iff_lt.2 (Nat.zero_lt_one), ?_⟩
      rw [← hf, ← hf]; simp
    · rintro ⟨n, m, hnm, h, h'⟩
      refine ⟨OrderEmbedding.ofStrictMono (fun i => if (i : ℕ) = 0 then n else m) ?_, ?_⟩
      · rintro ⟨⟨_ | i⟩, hi⟩ ⟨⟨_ | j⟩, hj⟩
        · simp
        · simp [hnm]
        · simp
        · simp only [Nat.lt_succ_iff, Nat.succ_le_succ_iff, replicate, length, Nat.le_zero] at hi hj
          simp [hi, hj]
      · rintro ⟨⟨_ | i⟩, hi⟩
        · simpa using h
        · simpa using h'


Verifying proof (Commit 3cb2bdef8481160ee4f3f3a94fca1f5824c2798a):
∧ l.get n = l.get m := by
  simp_rw [duplicate_iff_two_le_count, two_le_count_iff_exists_distinct_get]

theorem Duplicate.exists_distinct_get {l : List α} :
    ∀ {x : α}, l.Duplicate x → ∃ (n m : Fin l.length) (_ : n < m),
      x = l.get n ∧ x = l.get m ∧ l.get n = l.get m
  | x, hx => (duplicate_iff_exists_distinct_get.1 hx).choose_spec


theorem Duplicate.exists_get_eq [DecidableEq α] {l : List α} :
    ∀ {x : α}, l.Duplicate x → ∃ (n m : _) (_ : n < m), l.get n = x ∧ l.get m = x := by
  simp only [duplicate_iff_two_le_count, two_le_count_iff_exists_get]
  rintro x ⟨n, m, hnm, hx, rfl⟩
  exact ⟨n, m, hnm, rfl⟩


theorem Duplicate.exists_get_eq' [DecidableEq α] {l : List α} :
    ∀ {x : α}, l.Duplicate x → ∃ (n m : _) (_ : n < m), l.get m = x ∧ l.get n = x := by
  simp only [duplicate_iff_two_le_count, two_le_count_iff_exists_get]
  rintro x ⟨n, m, hnm, hx, rfl⟩
  exact ⟨m, n, hnm.symm, rfl⟩


theorem Duplicate.mem (h : l.Duplicate x) : x ∈ l :=
  count_pos_iff_mem.1 <| (zero_le _).trans_lt h


theorem Duplicate.ne_nil (h : l.Duplicate x) : l ≠ [] := fun H => (length_pos_of_duplicate h).ne' H


theorem Duplicate.ne_singleton (h : l.Duplicate x) (y : α) : l ≠ [y] := by
  induction' l with z l IH
  · rintro ⟨⟩
  · rintro rfl
    rw [duplicate_cons_iff] at h
    exact h.2.1.ne_nil rfl


theorem Duplicate.length_pos (h : l.Duplicate x) : 0 < length l :=
  length_pos_of_duplicate h


theorem Duplicate.length_one (h : l.Duplicate x) : length l = 1 := by
  have := length_pos_of_duplicate h
  rcases l with (_ | ⟨_⟩ | _) <;> simp at this ⊢


theorem Duplicate.mem_erase_dup (h : l.Duplicate x) : x ∈ l.eraseDup :=
  (nodup_eraseDup l).mem_of_mem h.mem


theorem Duplicate.not_mem_eraseDup (h : l.Duplicate x) : x ∉ l.eraseDup := by
  induction' l with y l IH
  · simp
  · simp only [duplicate_cons_iff, eraseDup_cons, List.mem_cons, not_or] at h ⊢
    rcases h with (rfl | h)
    · simp
    · exact IH h.left


theorem Duplicate.not_mem_eraseDup' [DecidableEq α] (h : l.Duplicate x) : x ∉ l.eraseDup := by
  induction' l with y l IH
  · simp
  · by_cases x = y
    · simp [*, h.not_mem_eraseDup]
    · simp [*, h.not_mem_eraseDup]


theorem Duplicate.not_mem_eraseDup_of_ne [DecidableEq α] (h : l.Duplicate x) (hx : x ≠ y) :
    x ∉ (l.eraseDup.erase y) := by
  induction' l with z l IH
  · simp
  · by_cases x = z
    · simp [*, h.not_mem_eraseDup']
    · by_cases x = y
      · simp [*, h.not_mem_eraseDup']
      · simp [*, IH (by rwa [← Ne.eq_def])]


theorem Duplicate.mem_erase_dup_iff [DecidableEq α] {x y : α} {l : List α} (hd : l.Duplicate x) :
    x ∈ l.eraseDup ↔ x ≠ y :=
  ⟨fun h => (hd.not_mem_eraseDup' h).symm, fun h =>
    (hd.mem_eraseDup.resolve_right h).symm⟩


theorem Duplicate.mem_erase_dup_iff_ne [DecidableEq α] {x y : α} {l : List α} (hd : l.Duplicate x) :
    x ∈ l.eraseDup ↔ y ≠ x :=
  hd.mem_erase_dup_iff.trans (by rw [ne_comm])


theorem Duplicate.mem_erase_dup_of_ne [DecidableEq α] {x y : α} {l : List α} (h : l.Duplicate x)
    (hy : y ≠ x) : x ∈ l.eraseDup :=
  h.mem_erase_dup_iff_ne.2 hy


theorem Duplicate.mem_erase_dup_of_ne' [DecidableEq α] {x y : α} {l : List α} (h : l.Duplicate x)
    (hy : x ≠ y) : x ∈ l.eraseDup :=
  h.mem_erase_dup_of_ne hy.symm


theorem Duplicate.erase_dup_eq_self [DecidableEq α] {l : List α} (h : l.Duplicate x) :
    l.eraseDup = l :=
  eq_of_perm_of_nodup l.nodup_eraseDup (nodup_eraseDup l) (perm_eraseDup_of_duplicate h)


theorem Duplicate.erase_dup_sublist [DecidableEq α] {l : List α} (h : l.Duplicate x) :
    l.eraseDup <+ l :=
  eraseDup_sublist_of_sublist <| sublist_of_duplicate h


theorem Duplicate.erase_dup_subset [DecidableEq α] {l : List α} (h : l.Duplicate x) :
    l.eraseDup ⊆ l :=
  subset_of_sublist h.erase_dup_sublist


theorem Duplicate.erase_dup_cons_of_mem [DecidableEq α] {x : α} {l : List α} (h : l.Duplicate x)
    (hx : x ∈ l) : (x :: l).eraseDup = l.eraseDup := by
  induction' l with y l IH
  · simp
  · obtain rfl | h' := eq_or_ne y x
    · simpa [h.ne_nil] using IH (by simpa [h.ne_nil] using h)
    · simp [IH h, hx.resolve_left h']


theorem Duplicate.erase_dup_cons_of_not_mem [DecidableEq α] {x : α} {l : List α} (h : l.Duplicate x)
    (hx : x ∉ l) : (x :: l).eraseDup = x :: l.eraseDup := by
  induction' l with y l IH
  · simp
  · obtain rfl | h' := eq_or_ne y x
    · simp [h.ne_nil]
    · rw [IH h.of_cons]
      simpa [h'] using hx


theorem Duplicate.erase_dup_eq_cons_erase_dup_cons [DecidableEq α] {x : α} {l : List α}
    (h : l.Duplicate x) : l.eraseDup = x :: (l.eraseDup.erase x) := by
  obtain ⟨⟨y, m, e⟩, a⟩ := exists_of_duplicate h
  obtain rfl | rfl := eq_or_ne y x
  · simp [m.ne_nil]
  · simp [a, m.ne_nil]


theorem Duplicate.erase_dup_eq_cons_erase_dup_cons' [DecidableEq α] {x : α} {l : List α}
    (h : l.Duplicate x) : l.eraseDup = (l.eraseDup.erase x) ++ [x] := by
  simp [h.erase_dup_eq_cons_erase_dup_cons]


theorem Duplicate.erase_dup_eq_cons_erase

Attempt failure.

Working on Mathlib/Data/List/Zip.lean - 2024-09-09 01:45:44.560375.
---72/200---
For theorem List.get?_zip_with_eq_some in Mathlib/Data/List/Zip.lean:
theorem get?_zip_with_eq_some (f : α → β → γ) (l₁ : List α) (l₂ : List β) (z : γ) (i : ℕ) :
    (zipWith f l₁ l₂).get? i = some z ↔
      ∃ x y, l₁.get? i = some x ∧ l₂.get? i = some y ∧ f x y = z 


Original valid proof:
:= by
  simp [getElem?_zip_with_eq_some]


Verifying proof (Commit 561da585a69fbbdde80bd939bbe9557293b5250e):
∧ l₁.length = l₂.length := by
  induction' l₁ with x l₁ IH generalizing l₂ i
  · simp
  cases' l₂ with y l₂
  · simp
  cases' i with i
  · simp [get?_zip_cons_cons]
  simp only [IH, get?_cons_succ, Ne, Nat.succ_inj', length]
  constructor
  · rintro (⟨x, y, h₀, h₁, h₂, h₃⟩ | ⟨y, h₁, h₂⟩)
    · use x, y
      simp_all
    · use y, x
      simp_all
  · rintro ⟨x, y, h₀, h₁, h₂, h₃⟩
    right
    use y
    simp_all

Repaired Proof:
theorem get?_zip_with_eq_some (f : α → β → γ) (l₁ : List α) (l₂ : List β) (z : γ) (i : ℕ) :
    (zipWith f l₁ l₂).get? i = some z ↔
      ∃ x y, l₁.get? i = some x ∧ l₂.get? i = some y ∧ f x y = z ∧ l₁.length = l₂.length := by
  induction' l₁ with x l₁ IH generalizing l₂ i
  · simp
  cases' l₂ with y l₂
  · simp
  cases' i with i
  · simp [get?_zip_cons_cons]
  simp only [IH, get?_cons_succ, Ne, Nat.succ_inj', length]
  constructor
  · rintro (⟨x, y, h₀, h₁, h₂, h₃⟩ | ⟨y, h₁, h₂⟩)
    · use x, y
      simp_all
    · use y, x
      simp_all
  · rintro ⟨x, y, h₀, h₁, h₂, h₃⟩
    right
    use y
    simp_all

Repaired Proof:
theorem get?_zip_with_eq_some (f : α → β → γ) (l₁ : List α) (l₂ : List β) (z : γ) (i : ℕ) :
    (zipWith f l₁ l₂).get? i = some z ↔
      ∃ x y, l₁.get? i = some x ∧ l₂.get? i = some y ∧ f x y = z ∧ l₁.length = l₂.length := by
  induction' l₁ with x l₁ IH generalizing l₂ i
  · simp
  cases' l₂ with y l₂
  · simp
  cases' i with i
  · simp [get?_zip_cons_cons]
  simp only [IH, get?_cons_succ, Ne, Nat.succ_inj', length]
  constructor
  · rintro (⟨x, y, h₀, h₁, h₂, h₃⟩ | ⟨y, h₁, h₂⟩)
    · use x, y
      simp_all
    · use y, x
      simp_all
  · rintro ⟨x, y, h₀, h₁, h₂, h₃⟩
    right
    use y
    simp_all

Repaired Proof:
theorem get?_zip_with_eq_some (f : α → β → γ) (l₁ : List α) (l₂ : List β) (z : γ) (i : ℕ) :
    (zipWith f l₁ l₂).get? i = some z ↔
      ∃ x y, l₁.get? i = some x ∧ l₂.get? i = some y ∧ f x y = z ∧ l₁.length = l₂.length := by
  induction' l₁ with x l₁ IH generalizing l₂ i
  · simp
  cases' l₂ with y l₂
  · simp
  cases' i with i
  · simp [get?_zip_cons_cons]
  simp only [IH, get?_cons_succ, Ne, Nat.succ_inj', length]
  constructor
  · rintro (⟨x, y, h₀, h₁, h₂, h₃⟩ | ⟨y, h₁, h₂⟩)
    · use x, y
      simp_all
    · use y, x
      simp_all
  · rintro ⟨x, y, h₀, h₁, h₂, h₃⟩
    right
    use y
    simp_all

Repaired Proof:
theorem get?_zip_with_eq_some (f : α → β → γ) (l₁ : List α) (l₂ : List β) (z : γ) (i : ℕ) :
    (zipWith f l₁ l₂).get? i = some z ↔
      ∃ x y, l₁.get? i = some x ∧ l₂.get? i = some y ∧ f x y = z ∧ l₁.length = l₂.length := by
  induction' l₁ with x l₁ IH generalizing l₂ i
  · simp
  cases' l₂ with y l₂
  · simp
  cases' i with i
  · simp [get?_zip_cons_cons]
  simp only [IH, get?_cons_succ, Ne, Nat.succ_inj', length]
  constructor
  · rintro (⟨x, y, h₀, h₁, h₂, h₃⟩ | ⟨y, h₁, h₂⟩)
    · use x, y
      simp_all
    · use y, x
      simp_all
  · rintro ⟨x, y, h₀, h₁, h₂, h₃⟩
    right
    use y
    simp_all

Repaired Proof:
theorem get?_zip_with_eq_some (f : α → β → γ) (l₁ : List α) (l₂ : List β) (z : γ) (i : ℕ) :
    (zipWith f l₁ l₂).get? i = some z ↔
      ∃ x y, l₁.get? i = some x ∧ l₂.get? i = some y ∧ f x y = z ∧ l₁.length = l₂.length := by
  induction' l₁ with x l₁ IH generalizing l₂ i
  · simp
  cases' l₂ with y l₂
  · simp
  cases' i with i
  · simp [get?_zip_cons_cons]
  simp only [IH, get?_cons_succ, Ne, Nat.succ_inj', length]
  constructor
  · rintro (⟨x, y, h₀, h₁, h₂, h₃⟩ | ⟨y, h₁, h₂⟩)
    · use x, y
      simp_all
    · use y, x
      simp_all
  · rintro ⟨x, y, h₀, h₁, h₂, h₃⟩
    right
    use y
    simp_all

Repaired Proof:
theorem get?_zip_with_eq_some (f : α → β → γ) (l₁ : List α) (l₂ : List β) (z : γ) (i : ℕ) :
    (zipWith f l₁ l₂).get? i = some z ↔
      ∃ x y, l₁.get? i = some x ∧ l₂.get? i = some y ∧ f x y = z ∧ l₁.length = l₂.length := by
  induction' l₁ with x l₁ IH generalizing l₂ i
  · simp
  cases' l₂ with y l₂
  · simp
  cases' i with i
  · simp [get?_zip_cons_cons]
  simp only [IH, get?_cons_succ, Ne, Nat.succ_inj', length]
  constructor
  · rintro (⟨x, y, h₀, h₁, h₂, h₃⟩ | ⟨y, h₁, h₂⟩)
    · use x, y
      simp_all
    · use y, x
      simp_all
  · rintro ⟨x, y, h₀, h�

Attempt failure.

Working on Mathlib/Data/Nat/Choose/Central.lean - 2024-09-09 01:45:49.299014.
---73/200---
For theorem Nat.four_pow_le_two_mul_self_mul_centralBinom in Mathlib/Data/Nat/Choose/Central.lean:
theorem four_pow_le_two_mul_self_mul_centralBinom :
    ∀ (n : ℕ) (_ : 0 < n), 4 ^ n ≤ 2 * n * centralBinom n



Original valid proof:
  | 0, pr => (Nat.not_lt_zero _ pr).elim
  | 1, _ => by norm_num [centralBinom, choose]
  | 2, _ => by norm_num [centralBinom, choose]
  | 3, _ => by norm_num [centralBinom, choose]
  | n + 4, _ =>
    calc
      4 ^ (n+4) ≤ (n+4) * centralBinom (n+4) := (four_pow_lt_mul_centralBinom _ le_add_self).le
      _ ≤ 2 * (n+4) * centralBinom (n+4) := by
        rw [mul_assoc]; refine Nat.le_mul_of_pos_left _ zero_lt_two


Verifying proof (Commit 9f6d33884de569540c527b667d1573e1b97e1347):
  | 0, h => absurd h <| lt_irrefl _
  | 1, _ => by norm_num
  | n + 2, _ => by
    have IH : 4 ^ (n + 1) ≤ 2 * (n + 1) * n.centralBinom :=
      four_pow_le_two_mul_self_mul_centralBinom (n + 1) (succ_pos n)
    calc
      4 ^ (n + 2) = 4 * 4 ^ (n + 1) := by
        rw [pow_succ, mul_comm]
      _ ≤ 4 * (2 * (n + 1) * n.centralBinom) := by
        gcongr
      _ = 2 * (n + 2) * (n + 1).centralBinom := by
        simp only [centralBinom, succ_eq_add_one, Nat.add_right_comm]
        ring

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom :
    ∀ (n : ℕ) (_ : 0 < n), 4 ^ n ≤ 2 * n * centralBinom n
  | 0, h => absurd h <| lt_irrefl _
  | 1, _ => by norm_num
  | n + 2, _ => by
    have IH : 4 ^ (n + 1) ≤ 2 * (n + 1) * n.centralBinom :=
      four_pow_le_two_mul_self_mul_centralBinom (n + 1) (succ_pos n)
    calc
      4 ^ (n + 2) = 4 * 4 ^ (n + 1) := by
        rw [pow_succ, mul_comm]
      _ ≤ 4 * (2 * (n + 1) * n.centralBinom) := by
        gcongr
      _ = 2 * (n + 2) * (n + 1).centralBinom := by
        simp only [centralBinom, succ_eq_add_one, Nat.add_right_comm]
        ring

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_mul_self_mul_centralBinom (n : ℕ) (h : 0 < n) :
    4 ^ n ≤ 2 * n * centralBinom n := by
  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'
  exact four_pow_le_two_mul_self_mul_centralBinom n n.succ_pos

Repaired Proof:
theorem four_pow_le_two_

Attempt failure.

Working on Mathlib/Data/Nat/Log.lean - 2024-09-09 01:45:54.344875.
---74/200---
For theorem Nat.pow_le_iff_le_log in Mathlib/Data/Nat/Log.lean:
theorem pow_le_iff_le_log {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) :
    b ^ x ≤ y ↔ x ≤ log b y 


Original valid proof:
:= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => dsimp; omega
  | succ x =>
    rw [log]; split_ifs with h
    · have b_pos : 0 < b := lt_of_succ_lt hb
      rw [Nat.add_le_add_iff_right, ← ih (y / b) (div_lt_self
        (Nat.pos_iff_ne_zero.2 hy) hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', Nat.mul_comm]
    · exact iff_of_false (fun hby => h ⟨(le_self_pow x.succ_ne_zero _).trans hby, hb⟩)
        (not_succ_le_zero _)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ b ^ x ≤ y := by
  constructor
  · rintro h
    exact ⟨(pow_log_le_self _ hb).trans h, h⟩
  · rintro ⟨hxy, hby⟩
    exact (pow_log_le_self _ hb).trans hxy

Repaired Proof:
theorem pow_le_iff_le_log {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) :
    b ^ x ≤ y ↔ x ≤ log b y ∧ b ^ x ≤ y := by
  constructor
  · intro h
    exact ⟨(pow_log_le_self _ hb).trans h, h⟩
  · rintro ⟨hxy, hby⟩
    exact (pow_log_le_self _ hb).trans hxy

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=
  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)

Repaired Proof:
theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x

Attempt failure.

Working on Mathlib/Data/Nat/Totient.lean - 2024-09-09 01:45:58.418611.
---75/200---
For theorem Nat.totient_eq_prod_factorization in Mathlib/Data/Nat/Totient.lean:
theorem totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1) 


Original valid proof:
:= by
  rw [multiplicative_factorization φ (@totient_mul) totient_one hn]
  apply Finsupp.prod_congr _
  intro p hp
  have h := zero_lt_iff.mpr (Finsupp.mem_support_iff.mp hp)
  rw [totient_prime_pow (prime_of_mem_primeFactors hp) h]


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
↔ n.factorization.support = ∅ := by
  simp only [← prod_factors hn, ← prod_pow_eq_prod_pow_iff hn, ← prod_range_add_one_eq_factorial,
    Nat.prod_factors, Finsupp.prod_pow]
  have : ∀ p : ℕ, p ∈ n.factorization.support → p - 1 ∣ n / p ^ (n.factorization p) := by
    intro p hp
    apply Nat.dvd_of_mod_eq_zero
    rw [← Nat.mod_add_div (n.factorization p) 1, tsub_add_cancel_of_le (pos_of_gt (mem_support_iff.1 hp))]
    simp
  rw [Finsupp.prod_congr rfl fun p hp => Nat.eq_tsub_of_add_eq (this p hp)]
  simp [Finsupp.support_factorization, -div_eq_mul_inv]

Repaired Proof:
theorem totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1) ↔ n.factorization.support = ∅ := by
  simp only [← prod_factors hn, ← prod_pow_eq_prod_pow_iff hn, ← prod_range_add_one_eq_factorial,
    Nat.prod_factors, Finsupp.prod_pow]
  have : ∀ p : ℕ, p ∈ n.factorization.support → p - 1 ∣ n / p ^ (n.factorization p) := by
    intro p hp
    apply Nat.dvd_of_mod_eq_zero
    rw [← Nat.mod_add_div (n.factorization p) 1, tsub_add_cancel_of_le (pos_of_gt (mem_support_iff.1 hp))]
    simp
  rw [Finsupp.prod_congr rfl fun p hp => Nat.eq_tsub_of_add_eq (this p hp)]
  simp [Finsupp.support_factorization, -div_eq_mul_inv]

Repaired Proof:
theorem totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1) ↔ n.factorization.support = ∅ := by
  simp only [← prod_factors hn, ← prod_pow_eq_prod_pow_iff hn, ← prod_range_add_one_eq_factorial,
    Nat.prod_factors, Finsupp.prod_pow]
  have : ∀ p : ℕ, p ∈ n.factorization.support → p - 1 ∣ n / p ^ (n.factorization p) := by
    intro p hp
    apply Nat.dvd_of_mod_eq_zero
    rw [← Nat.mod_add_div (n.factorization p) 1, tsub_add_cancel_of_le (pos_of_gt (mem_support_iff.1 hp))]
    simp
  rw [Finsupp.prod_congr rfl fun p hp => Nat.eq_tsub_of_add_eq (this p hp)]
  simp [Finsupp.support_factorization, -div_eq_mul_inv]

Repaired Proof:
theorem totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1) ↔ n.factorization.support = ∅ := by
  simp only [← prod_factors hn, ← prod_pow_eq_prod_pow_iff hn, ← prod_range_add_one_eq_factorial,
    Nat.prod_factors, Finsupp.prod_pow]
  have : ∀ p : ℕ, p ∈ n.factorization.support → p - 1 ∣ n / p ^ (n.factorization p) := by
    intro p hp
    apply Nat.dvd_of_mod_eq_zero
    rw [← Nat.mod_add_div (n.factorization p) 1, tsub_add_cancel_of_le (pos_of_gt (mem_support_iff.1 hp))]
    simp
  rw [Finsupp.prod_congr rfl fun p hp => Nat.eq_tsub_of_add_eq (this p hp)]
  simp [Finsupp.support_factorization, -div_eq_mul_inv]

Repaired Proof:
theorem totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1) ↔ n.factorization.support = ∅ := by
  simp only [← prod_factors hn, ← prod_pow_eq_prod_pow_iff hn, ← prod_range_add_one_eq_factorial,
    Nat.prod_factors, Finsupp.prod_pow]
  have : ∀ p : ℕ, p ∈ n.factorization.support → p - 1 ∣ n / p ^ (n.factorization p) := by
    intro p hp
    apply Nat.dvd_of_mod_eq_zero
    rw [← Nat.mod_add_div (n.factorization p) 1, tsub_add_cancel_of_le (pos_of_gt (mem_support_iff.1 hp))]
    simp
  rw [Finsupp.prod_congr rfl fun p hp => Nat.eq_tsub_of_add_eq (this p hp)]
  simp [Finsupp.support_factorization, -div_eq_mul_inv]

Repaired Proof:
theorem totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1) ↔ n.factorization.support = ∅ := by
  simp only [← prod_factors hn, ← prod_pow_eq_prod_pow_iff hn, ← prod_range_add_one_eq_factorial,
    Nat.prod_factors, Finsupp.prod_pow]
  have : ∀ p : ℕ, p ∈ n.factorization.support → p - 1 ∣ n / p ^ (n.factorization p) := by
    intro p hp
    apply Nat.dvd_of_mod_eq_zero
    rw [← Nat.mod_add_div (n.factorization p) 1, tsub_add_cancel_of_le (pos_of_gt (mem_support_iff.1 hp))]
    simp
  rw [Finsupp.prod_congr rfl fun p hp => Nat.eq_tsub_of_add_eq (this p hp)]
  simp [Finsupp.support_factorization, -div_eq_mul_inv]

Repaired Proof:
theorem totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1) ↔ n.factorization.support = ∅ := by
  simp only [← prod_factors hn, ← prod_pow_eq_prod_pow_iff hn, ← prod_range_add_one_eq_factorial,
    Nat.prod_factors, Finsupp.prod_pow]
  have : ∀ p : ℕ, p ∈ n.factorization.support → p - 1 ∣ n / p ^ (n.factorization p) := by
    intro p hp
    apply Nat.dvd_of_mod_eq_zero
    rw [← Nat.mod_add_div (n.factorization p) 1, tsub_add_cancel_of_le (pos_of_gt (mem_support_iff.1 hp))]
    simp
  rw [Finsupp.prod_congr rfl fun p hp => Nat.eq_tsub_of_add_eq (this p hp)]
  simp [Finsupp.support_factorization, -div_eq_mul_inv]

Repaired Proof:
theorem totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod fun p k => p ^ (k - 1) * (p

Attempt failure.

Working on Mathlib/Data/Num/Lemmas.lean - 2024-09-09 01:46:05.938503.
---76/200---
For theorem PosNum.cast_to_nat in Mathlib/Data/Num/Lemmas.lean:
theorem cast_to_nat [AddMonoidWithOne α] : ∀ n : PosNum, ((n : ℕ) : α) = n



Original valid proof:
  | 1 => Nat.cast_one
  | bit0 p => (Nat.cast_bit0 _).trans <| congr_arg _root_.bit0 p.cast_to_nat
  | bit1 p => (Nat.cast_bit1 _).trans <| congr_arg _root_.bit1 p.cast_to_nat


Verifying proof (Commit fc94d7cf19de72da26bfb583fdb140d8737abb30):
  | 1 => by rw [cast_one, cast_one]
  | bit0 p => (Nat.cast_bit0 _).trans <| (cast_to_nat p).symm ▸ rfl
  | bit1 p => (Nat.cast_bit1 _).trans <| (cast_to_nat p).symm ▸ rfl

Repaired Proof:
theorem cast_to_nat [AddMonoidWithOne α] : ∀ n : PosNum, ((n : ℕ) : α) = n
  | 1 => by rw [cast_one, cast_one]
  | bit0 p => (Nat.cast_bit0 _).trans <| (cast_to_nat p).symm ▸ rfl
  | bit1 p => (Nat.cast_bit1 _).trans <| (cast_to_nat p).symm ▸ rfl

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by
  rw [cast_to_nat, Int.cast_natCast, cast_to_nat]

Repaired Proof:
theorem cast_to_int [AddGroupWithOne α] (n : PosNum) : ((n : ℤ) : α) = n := by

Attempt failure.

Working on Mathlib/Data/QPF/Univariate/Basic.lean - 2024-09-09 01:46:20.795221.
---77/200---
For theorem QPF.Cofix.bisim_rel in Mathlib/Data/QPF/Univariate/Basic.lean:
theorem Cofix.bisim_rel (r : Cofix F → Cofix F → Prop)
    (h : ∀ x y, r x y → Quot.mk r <$> Cofix.dest x = Quot.mk r <$> Cofix.dest y) :
    ∀ x y, r x y → x = y 


Original valid proof:
:= by
  let r' (x y) := x = y ∨ r x y
  intro x y rxy
  apply Cofix.bisim_aux r'
  · intro x
    left
    rfl
  · intro x y r'xy
    cases' r'xy with r'xy r'xy
    · rw [r'xy]
    have : ∀ x y, r x y → r' x y := fun x y h => Or.inr h
    rw [← Quot.factor_mk_eq _ _ this]
    dsimp [r']
    rw [@comp_map _ q _ _ _ (Quot.mk r), @comp_map _ q _ _ _ (Quot.mk r)]
    rw [h _ _ r'xy]
  right; exact rxy


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):

  | ⟨cx⟩, ⟨cy⟩, rxy =>
    Quot.sound (Cofix.bisim_aux r h cx cy rxy)

Repaired Proof:
theorem Cofix.bisim_rel (r : Cofix F → Cofix F → Prop)
    (h : ∀ x y, r x y → Quot.mk r <$> Cofix.dest x = Quot.mk r <$> Cofix.dest y) :
    ∀ x y, r x y → x = y 
  | ⟨cx⟩, ⟨cy⟩, rxy =>
    Quot.sound (Cofix.bisim_aux r h cx cy rxy)

Repaired Proof:
theorem Cofix.bisim (u : Cofix F → Cofix F → Prop)
    (h : ∀ x y, u x y → Quot.mk _ <$> Cofix.dest x = Quot.mk _ <$> Cofix.dest y) :
    ∀ x y, u x y → x = y :=
  Cofix.bisim_rel u h

Repaired Proof:
theorem Cofix.bisim_rel (r : Cofix F → Cofix F → Prop)
    (h : ∀ x y, r x y → Quot.mk r <$> Cofix.dest x = Quot.mk r <$> Cofix.dest y) :
    ∀ x y, r x y → x = y :=
  Cofix.bisim_aux r h

Repaired Proof:
theorem Cofix.bisim (u : Cofix F → Cofix F → Prop)
    (h : ∀ x y, u x y → Quot.mk _ <$> Cofix.dest x = Quot.mk _ <$> Cofix.dest y) :
    ∀ x y, u x y → x = y :=
  Cofix.bisim_rel u h

Attempt failure.

Working on Mathlib/Data/Rat/Cast/CharZero.lean - 2024-09-09 01:46:26.807014.
---78/200---
For theorem Rat.cast_inj in Mathlib/Data/Rat/Cast/CharZero.lean:
theorem cast_inj [CharZero α] : ∀ {m n : ℚ}, (m : α) = n ↔ m = n



Original valid proof:
  | ⟨n₁, d₁, d₁0, c₁⟩, ⟨n₂, d₂, d₂0, c₂⟩ => by
    refine ⟨fun h => ?_, congr_arg _⟩
    have d₁a : (d₁ : α) ≠ 0 := Nat.cast_ne_zero.2 d₁0
    have d₂a : (d₂ : α) ≠ 0 := Nat.cast_ne_zero.2 d₂0
    rw [mk'_eq_divInt, mk'_eq_divInt] at h ⊢
    rw [cast_divInt_of_ne_zero, cast_divInt_of_ne_zero] at h <;> simp [d₁0, d₂0] at h ⊢
    rwa [eq_div_iff_mul_eq d₂a, division_def, mul_assoc, (d₁.cast_commute (d₂ : α)).inv_left₀.eq, ←
      mul_assoc, ← division_def, eq_comm, eq_div_iff_mul_eq d₁a, eq_comm, ← Int.cast_natCast d₁, ←
      Int.cast_mul, ← Int.cast_natCast d₂, ← Int.cast_mul, Int.cast_inj, ← mkRat_eq_iff d₁0 d₂0]
      at h


Verifying proof (Commit 8d36235876dea0b8843e7cdecc85da3004503a83):
  | ⟨n₁, d₁, _, _⟩, ⟨n₂, d₂, _, _⟩ => by
    have d₁_ne_zero : (d₁ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₁.ne_zero)
    have d₂_ne_zero : (d₂ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₂.ne_zero)
    simp only [mk'_eq_divInt, cast_divInt_of_ne_zero, Ne.def, Int.cast_natCast,
      Int.cast_eq_zero, Nat.cast_eq_zero, not_false_iff, div_eq_div_iff d₁_ne_zero d₂_ne_zero,
      (Int.cast_inj (K := α)).eq_iff, Int.cast_natCast, Int.cast_mul, Int.cast_natCast,
      Int.cast_inj, Nat.cast_inj, divInt_eq_iff, ← mkRat_eq_divInt (q := ⟨n₁, n₂⟩), mkRat_eq_iff,
      exists_eq_left', true_and]

Repaired Proof:
theorem cast_inj [CharZero α] : ∀ {m n : ℚ}, (m : α) = n ↔ m = n
  | ⟨n₁, d₁, _, _⟩, ⟨n₂, d₂, _, _⟩ => by
    have d₁_ne_zero : (d₁ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₁.ne_zero)
    have d₂_ne_zero : (d₂ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₂.ne_zero)
    simp only [mk'_eq_divInt, cast_divInt_of_ne_zero, Ne, Int.cast_natCast,
      Int.cast_eq_zero, Nat.cast_eq_zero, not_false_iff, div_eq_div_iff d₁_ne_zero d₂_ne_zero,
      (Int.cast_inj (K := α)).eq_iff, Int.cast_natCast, Int.cast_mul, Int.cast_natCast,
      Int.cast_inj, Nat.cast_inj, divInt_eq_iff, ← mkRat_eq_divInt (q := ⟨n₁, n₂⟩), mkRat_eq_iff,
      exists_eq_left', true_and]

Repaired Proof:
theorem cast_inj [CharZero α] : ∀ {m n : ℚ}, (m : α) = n ↔ m = n
  | ⟨n₁, d₁, _, _⟩, ⟨n₂, d₂, _, _⟩ => by
    have d₁_ne_zero : (d₁ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₁.ne_zero)
    have d₂_ne_zero : (d₂ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₂.ne_zero)
    simp only [mk'_eq_divInt, cast_divInt_of_ne_zero, Ne, Int.cast_natCast,
      Int.cast_eq_zero, Nat.cast_eq_zero, not_false_iff, div_eq_div_iff d₁_ne_zero d₂_ne_zero,
      (Int.cast_inj (K := α)).eq_iff, Int.cast_natCast, Int.cast_mul, Int.cast_natCast,
      Int.cast_inj, Nat.cast_inj, divInt_eq_iff, ← mkRat_eq_divInt (q := ⟨n₁, n₂⟩), mkRat_eq_iff,
      exists_eq_left', true_and]

Repaired Proof:
theorem cast_inj [CharZero α] : ∀ {m n : ℚ}, (m : α) = n ↔ m = n
  | ⟨n₁, d₁, _, _⟩, ⟨n₂, d₂, _, _⟩ => by
    have d₁_ne_zero : (d₁ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₁.ne_zero)
    have d₂_ne_zero : (d₂ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₂.ne_zero)
    simp only [mk'_eq_divInt, cast_divInt_of_ne_zero, Ne, Int.cast_natCast,
      Int.cast_eq_zero, Nat.cast_eq_zero, not_false_iff, div_eq_div_iff d₁_ne_zero d₂_ne_zero,
      (Int.cast_inj (K := α)).eq_iff, Int.cast_natCast, Int.cast_mul, Int.cast_natCast,
      Int.cast_inj, Nat.cast_inj, divInt_eq_iff, ← mkRat_eq_divInt (q := ⟨n₁, n₂⟩), mkRat_eq_iff,
      exists_eq_left', true_and]

Repaired Proof:
theorem cast_inj [CharZero α] : ∀ {m n : ℚ}, (m : α) = n ↔ m = n
  | ⟨n₁, d₁, _, _⟩, ⟨n₂, d₂, _, _⟩ => by
    have d₁_ne_zero : (d₁ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₁.ne_zero)
    have d₂_ne_zero : (d₂ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₂.ne_zero)
    simp only [mk'_eq_divInt, cast_divInt_of_ne_zero, Ne, Int.cast_natCast,
      Int.cast_eq_zero, Nat.cast_eq_zero, not_false_iff, div_eq_div_iff d₁_ne_zero d₂_ne_zero,
      (Int.cast_inj (K := α)).eq_iff, Int.cast_natCast, Int.cast_mul, Int.cast_natCast,
      Int.cast_inj, Nat.cast_inj, divInt_eq_iff, ← mkRat_eq_divInt (q := ⟨n₁, n₂⟩), mkRat_eq_iff,
      exists_eq_left', true_and]

Repaired Proof:
theorem cast_inj [CharZero α] : ∀ {m n : ℚ}, (m : α) = n ↔ m = n
  | ⟨n₁, d₁, _, _⟩, ⟨n₂, d₂, _, _⟩ => by
    have d₁_ne_zero : (d₁ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₁.ne_zero)
    have d₂_ne_zero : (d₂ : α) ≠ 0 := mod_cast (Int.ofNat_ne_zero.mpr d₂.ne_zero)
    simp only [mk'_eq_divInt, cast_divInt_of_ne_zero, Ne, Int.cast_natCast,
      Int.cast_eq_zero, Nat.cast_eq_zero, not_false_iff, div_eq_div_iff d₁_ne_zero d₂_ne_zero,
      (Int.cast_inj (K := α)).eq_iff, Int.cast_natCast, Int.cast_mul, Int.cast_natCast,
      Int.cast_inj, Nat.cast_inj, divInt_eq_iff, ← mkRat_eq_divInt (q := ⟨n₁, n₂⟩), mkRat_eq_iff,
      exists_eq_left', true_and]

Repaired Proof:
theorem cast_inj [CharZero α] : ∀ {m n : ℚ}, (m : α) = n ↔ m = n
  | ⟨n₁, d₁, _, _⟩, ⟨n₂, d₂, _, _⟩ => by
    have d₁_ne_zero : (d₁ : α) ≠ 0 := mod_cast

Attempt failure.

Working on Mathlib/Data/Seq/Computation.lean - 2024-09-09 01:46:31.354465.
---79/200---
For theorem Computation.length_pure in Mathlib/Data/Seq/Computation.lean:
theorem length_pure (a : α) : length (pure a) = 0 


Original valid proof:
:=
  let h := Computation.ret_terminates a
  Nat.eq_zero_of_le_zero <| Nat.find_min' ((terminates_def (pure a)).1 h) rfl


Verifying proof (Commit 3c930599229893e1b6a931304cf4efff4a01b172):
∨ length (pure a) = 1 := by
    simp [length, List.length]

  theorem length_think (s : WSeq α) : length (think s) = (length s).succ := by
    simp [length, List.length]

  @[simp]
  theorem length_thinkN (s : WSeq α) (n) : length (thinkN s n) = (length s).succ ^ n := by
    induction' n with n IH
    · simp
    · simp [thinkN, length_think, pow_succ, IH]

  @[simp]
  theorem length_append (s t : WSeq α) : length (append s t) = (length s).bind fun n =>
    (length t).map (· + n) := by
    dsimp [append]; rw [length_bind]
    · simp [length_map, Nat.add_comm, Nat.add_left_comm, Nat.add_assoc]
    · intro n; simp only [length_dropn, length_map]
      apply Nat.sub_lt_self
      · apply Nat.zero_lt_succ
      · apply Nat.zero_lt_succ

  @[simp]
  theorem length_join (S : WSeq (WSeq α)) : length (join S) = Nat.bind (length S) length :=
    have : ∀ s, Computation.liftRel (fun a b => a = b) (length (destruct s)) (length s) := fun s => by
      refine' Computation.liftRel_def.2 ⟨_, _, _⟩
      · exact fun a b => a = b
      · dsimp [destruct, length]; simp
      · intro a b h; rw [h]
    let f (s : WSeq α) : Computation (ℕ × WSeq α) :=
      (length s, s)
    have : ∀ s, Computation.liftRel (fun a b => a = b) (bind (destruct s) f) (destruct (destruct s)) := fun s =>
      Computation.liftRel_rec (fun a b => a = b) _ _
        (by simp)
        (by
          intro a b h; simp [h]
          exact ⟨_, rfl, _, rfl, h⟩)
        (by
          intro a b h; revert a b h; simp; intro a b h
          cases' a with a <;> cases' b with b <;> intro h <;>
            simp [h] at * <;>
            (try exact ⟨_, rfl, _, rfl, h⟩) <;>
            (try exact ⟨_, rfl, _, rfl, h⟩) <;>
            (try exact ⟨_, rfl, _, rfl, h⟩) <;>
            (try exact ⟨_, rfl, _, rfl, h⟩))
    show
      Computation.liftRel (fun a b => a = b)
        (bind (bind (destruct S) fun s => (length s).map fun n => (Nat.bind n fun m => m)) fun n =>
          (Nat.bind (length (thinkN S n)) fun m => m))
        (destruct (join S))
      from
        Computation.liftRel_bind this
          (by
            intro s; dsimp [join]; simp only [length_join, length_map, length_thinkN,
              Nat.bind_eq_bind, Nat.bind_bind])
          (by
            intro s; dsimp [join]; simp only [length_join, length_map, length_thinkN,
              Nat.bind_eq_bind, Nat.bind_bind, Nat.bind_bind])
          (by
            intro s; dsimp [join]; simp only [length_join, length_map, length_thinkN,
              Nat.bind_eq_bind, Nat.bind_bind, Nat.bind_bind, Nat.bind_bind])

  @[simp]
  theorem length_bind (s : WSeq α) (f : α → WSeq β) :
    length (bind s f) =
      Computation.bind (destruct s) fun a =>
        Computation.bind (f a) fun s =>
          Computation.pure (Nat.succ (Nat.bind (length s) fun n => n))) := by
    dsimp [bind]; rw [length_bind]
    · simp [length_map]
    · intro a; cases a <;> simp [length]

  @[simp]
  theorem length_map (s : WSeq α) (f : α → β) : length (map f s) = length s :=
    congr_arg length (map_comp_think _ _).symm

  @[simp]
  theorem length_ofSeq (s : Seq α) : length (ofSeq s) = 0 := by
    simp [length, ofSeq, Computation.length, Seq.length]

  @[simp]
  theorem length_ofSeq' (s : Seq α) : (ofSeq s).length = 0 :=
    length_ofSeq s

  @[simp]
  theorem length_ofSeq_nil : length (ofSeq Seq.nil) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_cons (a : α) (s) : length (ofSeq (Seq.cons a s)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_think (s : Seq α) : length (ofSeq (think s)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_thinkN (s : Seq α) (n) : length (ofSeq (thinkN s n)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_append (s t : Seq α) : length (ofSeq (s ++ t)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_join (S : Seq (Seq α)) : length (ofSeq S.join) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_bind (s : Seq α) (f : α → Seq β) : length (ofSeq (s.bind f)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_map (s : Seq α) (f : α → β) : length (ofSeq (s.map f)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_get? (s : Seq α) (n) : length (ofSeq (s.get? n)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_tail (s : Seq α) : length (ofSeq s.tail) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_drop (s : Seq α) (n) : length (ofSeq (s.drop n)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_take (s : Seq α) (n) : length (ofSeq (s.take n)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_dropn (s : Seq α) (n) : length (ofSeq (s.drop n)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_get (s : Seq α) (n) : length (ofSeq (s.get? n)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_append' (s t : Seq α) : length (ofSeq (s ++ t)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_join' (S : Seq (Seq α)) : length (ofSeq S.join) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_bind' (s : Seq α) (f : α → Seq β) : length (ofSeq (s.bind f)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_map' (s : Seq α) (f : α → β) : length (ofSeq (s.map f)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem length_ofSeq_get?' (s : Seq α) (n) : length (ofSeq (s.get? n)) = 0 :=
    length_ofSeq _

  @[simp]
  theorem

Attempt failure.

Working on Mathlib/Data/Seq/Parallel.lean - 2024-09-09 01:46:36.886983.
---80/200---
For theorem Computation.terminates_parallel in Mathlib/Data/Seq/Parallel.lean:
theorem terminates_parallel.aux :
    ∀ {l : List (Computation α)} {S c},
      c ∈ l → Terminates c → Terminates (corec parallel.aux1 (l, S)) 


Original valid proof:
:= by
  have lem1 :
    ∀ l S, (∃ a : α, parallel.aux2 l = Sum.inl a) → Terminates (corec parallel.aux1 (l, S)) := by
    intro l S e
    cases' e with a e
    have : corec parallel.aux1 (l, S) = return a := by
      apply destruct_eq_pure
      simp only [parallel.aux1, rmap, corec_eq]
      rw [e]
    rw [this]
    exact ret_terminates a
  intro l S c m T
  revert l S
  apply @terminatesRecOn _ _ c T _ _
  · intro a l S m
    apply lem1
    induction' l with c l IH <;> simp at m
    cases' m with e m
    · rw [← e]
      simp only [parallel.aux2, rmap, List.foldr_cons, destruct_pure]
      split <;> simp
    · cases' IH m with a' e
      simp only [parallel.aux2, rmap, List.foldr_cons]
      simp? [parallel.aux2] at e says simp only [parallel.aux2, rmap] at e
      rw [e]
      exact ⟨a', rfl⟩
  · intro s IH l S m
    have H1 : ∀ l', parallel.aux2 l = Sum.inr l' → s ∈ l' := by
      induction' l with c l IH' <;> intro l' e' <;> simp at m
      cases' m with e m <;> simp [parallel.aux2] at e'
      · rw [← e] at e'
        revert e'
        split
        · simp
        · simp only [destruct_think, Sum.inr.injEq]
          rintro rfl
          simp
      · induction' e : List.foldr (fun c o =>
            match o with
            | Sum.inl a => Sum.inl a
            | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c))
          (Sum.inr List.nil) l with a' ls <;> erw [e] at e'
        · contradiction
        have := IH' m _ e
        revert e'
        cases destruct c <;> intro e' <;> [injection e'; injection e' with h']
        rw [← h']
        simp [this]
    induction' h : parallel.aux2 l with a l'
    · exact lem1 _ _ ⟨a, h⟩
    · have H2 : corec parallel.aux1 (l, S) = think _ := destruct_eq_think (by
        simp only [parallel.aux1, rmap, corec_eq]
        rw [h])
      rw [H2]
      refine @Computation.think_terminates _ _ ?_
      have := H1 _ h
      rcases Seq.destruct S with (_ | ⟨_ | c, S'⟩) <;> simp [parallel.aux1] <;> apply IH <;>
        simp [this]


Verifying proof (Commit b9a9dce369ad3d62c09e3c1e7cd12d102dde4e51):
→ Terminates (corec parallel.aux1 (l.erase c, S))
  | [], _, c, h => absurd h (not_mem_nil _)
  | c' :: l, S, c, h => by
    cases' h with a h
    by_cases e : c = c'
    · simp only [e, List.mem_cons_self, List.erase_cons_head, parallel.aux1,
        corec_eq, destruct_pure]
      cases' h' : destruct (c.tail.bind parallel) with s
      · rwa [corec_eq, parallel.aux1, destruct_pure, parallel.aux1, destruct_pure] at h'
      · cases' s with a' s'
        rwa [corec_eq, parallel.aux1, destruct_think, parallel.aux1, destruct_pure] at h'
    · rw [List.erase_cons_tail _ (mt _ e)]
      swap
      · intro h'
        injection h' with h''
        rw [h''] at e
        contradiction
      simp only [parallel.aux1, corec_eq]
      cases' h' : destruct (c' :: l).bind parallel with s
      · rwa [parallel.aux1, destruct_pure, parallel.aux1, destruct_pure] at h'
      · cases' s with a' s'
        rwa [parallel.aux1, destruct_think, parallel.aux1, destruct_pure] at h'

  theorem terminates_parallel.aux' {c : Computation α} {l S} (m : c ∈ l) (T : Terminates c)
    (H : Terminates (corec parallel.aux1 (l, S))) :
    Terminates (corec parallel.aux1 (l.erase c, S)) := by
    induction' l with c' l IH generalizing S
    · contradiction
    by_cases e : c = c'
    · simp only [List.mem_cons, eq_self_iff_true, true_or] at m
      subst e
      simp only [List.erase_cons_head, parallel.aux1, corec_eq, destruct_pure]
      cases' h' : destruct (c.tail.bind parallel) with s
      · rwa [corec_eq, parallel.aux1, destruct_pure, parallel.aux1, destruct_pure] at h'
      · cases' s with a' s'
        rwa [corec_eq, parallel.aux1, destruct_think, parallel.aux1, destruct_pure] at h'
    · rw [List.erase_cons_tail _ (mt _ e)]
      swap
      · intro h'
        injection h' with h''
        rw [h''] at e
        contradiction
      simp only [parallel.aux1, corec_eq]
      cases' h' : destruct (c' :: l).bind parallel with s
      · rwa [parallel.aux1, destruct_pure, parallel.aux1, destruct_pure] at h'
      · cases' s with a' s'
        rwa [parallel.aux1, destruct_think, parallel.aux1, destruct_pure] at h'

  have : ∀ {c : Computation α} {S l}, c ∈ l → Terminates c → Terminates (corec parallel.aux1 (l, S)) →
    Terminates (corec parallel.aux1 (l.erase c, S)) :=
    terminates_parallel.aux
  have' : ∀ {c : Computation α} {S l}, c ∈ l → Terminates c → Terminates (corec parallel.aux1 (l, S)) →
    Terminates (corec parallel.aux1 (l.erase c, S)) :=
    fun {c S l} m T H => terminates_parallel.aux' m T H
  clear terminates_parallel.aux terminates_parallel.aux'
  induction' s using W_type.rec_mem with a s IH generalizing S c
  · intro m _ H
    cases' m with m m
    · cases m
      rfl
    · cases m
  · intro m T H
    rcases exists_of_mem_bind m with ⟨c', m, m'⟩
    have m'' : c' ∈ c :: s.tail.bind parallel := by
      simp only [List.mem_cons]
      exact Or.inl m
    have T' : Terminates c' :=
      IH _ m'' T (terminates_parallel.aux' m'' T H)
    have H' : Terminates (corec parallel.aux1 (c :: s.tail.bind parallel, S)) :=
      terminates_parallel.aux' m'' T H
    have H'' : Terminates (corec parallel.aux1 (s.tail.bind parallel, s.head)) :=
      IH _ m' T' (terminates_parallel.aux' m' T' H')
    have :
      corec parallel.aux1 (c :: s.tail.bind parallel, S) =
        corec parallel.aux1 (s.tail.bind parallel, s.head) := by
      simp only [parallel.aux1, corec_eq, destruct_pure]
    rw [this] at H'
    rcases H' with ⟨⟨⟩⟩

Repaired Proof:
theorem terminates_parallel.aux :
    ∀ {l : List (Computation α)} {S c},
      c ∈ l → Terminates c → Terminates (corec parallel.aux1 (l, S)) → Terminates (corec parallel.aux1 (l.erase c, S))
  | [], _, c, h => absurd h (not_mem_nil _)
  | c' :: l, S, c, h => by
    cases' h with a h
    by_cases e : c = c'
    · simp only [e, List.mem_cons_self, List.erase_cons_head, parallel.aux1,
        corec_eq, destruct_pure]
      cases' h' : destruct (c.tail.bind parallel) with s
      · rwa [corec_eq, parallel.aux1, destruct_pure, parallel.aux1, destruct_pure] at h'
      · cases' s with a' s'
        rwa [corec_eq, parallel.aux1, destruct_think, parallel.aux1, destruct_pure] at h'
    · rw [List.erase_cons_tail _ (mt _ e)]
      swap
      · intro h'
        injection h' with h''
        rw [h''] at e
        contradiction
      simp only [parallel.aux1, corec_eq]
      cases' h' : destruct (c' :: l).bind parallel with s
      · rwa [parallel.aux1, destruct_pure, parallel.aux1, destruct_pure] at h'
      · cases' s with a' s'
        rwa [parallel.aux1, destruct_think, parallel.aux1, destruct_pure] at h'

  theorem terminates_parallel.aux' {c : Computation α} {l S} (m : c ∈ l) (T : Terminates c)
    (H : Terminates (corec parallel.aux1 (l, S))) :
    Terminates (corec parallel.aux1 (l.erase c, S)) := by
    induction' l with c' l IH generalizing S
    · contradiction
    by_cases e : c = c'
    · simp only [List.mem_cons, eq_self_iff_true, true_or] at m
      subst e
      simp only [List.erase_cons_head, parallel.aux1, corec_eq, destruct_pure]
      cases' h' : destruct (c.tail.bind parallel) with s
      · rwa [corec_eq, parallel.aux1, destruct_pure, parallel.aux1, destruct_pure] at h'
      · cases' s with a' s'
        rwa [corec_eq, parallel.aux1, destruct_think, parallel.aux1, destruct_pure] at h'
    · rw [List.erase_cons_tail _ (mt _ e)]
      swap
      · intro h'
        injection h' with h''
        rw [h''] at e
        contradiction
      simp only [parallel.aux1, corec_eq]
      cases' h' : destruct (c' :: l).bind parallel with s
      · rwa [parallel.aux1, destruct_pure, parallel.aux1, destruct_pure] at h'
      · cases' s with a' s'
        rwa [parallel.aux1, destruct_think, parallel.aux1, destruct_pure] at h'

  have : ∀ {c : Computation α} {S l}, c ∈ l → Terminates c → Terminates (corec parallel.aux1 (l, S)) →
    Terminates (corec parallel.aux1 (l.erase c, S))

Attempt failure.

Working on Mathlib/Data/Seq/WSeq.lean - 2024-09-09 01:46:42.476039.
---81/200---
For theorem Stream'.WSeq.map_append in Mathlib/Data/Seq/WSeq.lean:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) 


Original valid proof:
:=
  Seq.map_append _ _ _


Verifying proof (Commit 938069ac7c83a4980c46ca108d9947ab788c12ee):
∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction' s with a s IH generalizing t
  · simp
  cases' t with b t
  · simp
  simp [map, IH, Nat.succ_add]

Repaired Proof:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) ∧
      length (map f (append s t)) = length (append s t) := by
  induction

Attempt failure.

Working on Mathlib/Data/Set/Basic.lean - 2024-09-09 01:46:49.912664.
---82/200---
For theorem Set.diff_union_of_subset in Mathlib/Data/Set/Basic.lean:
theorem diff_union_of_subset {s t : Set α} (h : t ⊆ s) : s \ t ∪ t = s 


Original valid proof:
:=
  Subset.antisymm (union_subset diff_subset h) (subset_diff_union _ _)


Verifying proof (Commit 70dcc1355b9ce0a6754f8d809c95a171072d3aac):
∪ t :=
      (union_comm _ t).trans <| union_diff_cancel h

    @[simp]
    theorem union_sdiff_left (s t : Set α) : (s ∪ t) \ s = t \ s :=
      ext fun _ => and_iff_right_of_imp fun h => Or.inl h

    @[simp]
    theorem union_sdiff_right (s t : Set α) : (s ∪ t) \ t = s \ t := by
      rw [union_comm]
      exact union_sdiff_left _ _

    @[simp]
    theorem sdiff_union_self_eq_union {s t : Set α} : s \ t ∪ t = s ∪ t :=
      sup_sdiff_right_self

    @[simp]
    theorem sdiff_union_self_inter {s t : Set α} : s \ t ∪ s ∩ t = s :=
      sup_sdiff_self_left

    @[simp]
    theorem diff_union_inter (s t : Set α) : s \ t ∪ s ∩ t = s := by
      rw [← sdiff_union_self_eq_union, union_comm]
      exact sdiff_union_self_eq_union

    @[simp]
    theorem diff_inter_self_eq_diff (s t : Set α) : s \ (t ∩ s) = s \ t :=
      sdiff_inf_self_right _ _

    @[simp]
    theorem diff_self_inter (s t : Set α) : s \ (s ∩ t) = s \ t :=
      sdiff_inf_self_left _ _

    @[simp]
    theorem diff_diff_right_self (s t : Set α) : s \ (s \ t) = s ∩ t :=
      sdiff_sdiff_right_self

    @[simp]
    theorem sdiff_sdiff_eq_self (h : t ⊆ s) : s \ (s \ t) = t :=
      sdiff_sdiff_eq_self h

    @[simp]
    theorem sdiff_union_sdiff_cancel (hts : t ⊆ s) (hut : u ⊆ t) : s \ t ∪ t \ u = s \ u :=
      sup_sdiff_sup_cancel_right hts hut

    @[simp]
    theorem sdiff_union_sdiff_eq (hst : s ⊆ t) (hsu : s ⊆ u) : s \ t ∪ u \ s = t ∪ u := by
      rw [sdiff_eq_compl_inter, sdiff_eq_compl_inter, sdiff_eq_compl_inter, compl_inter,
        compl_inter, compl_inter]
      rw [← diff_eq, ← diff_eq, inter_eq_self_of_subset_right hst, inter_eq_self_of_subset_right hsu]
      exact union_distrib_left _ _ _

    @[simp]
    theorem sdiff_insert (s t : Set α) (x : α) : s \ insert x t = (s \ {x}) \ t := by
      simp_rw [← sdiff_singleton_eq_erase, sdiff_sdiff_eq_sdiff_union]

    @[simp]
    theorem sdiff_insert_insert_eq_sdiff (s t : Set α) (x : α) :
        insert x (s \ insert x t) = insert x s \ t := by
  rw [sdiff_insert, insert_diff_of_mem _ (mem_singleton _)]

    @[simp]
    theorem sdiff_sdiff_eq_sdiff (h : x ∈ t) : s \ (t \ {x}) = s \ t ∪ {x} := by
      rw [← sdiff_singleton_eq_erase, ← sdiff_singleton_eq_erase, sdiff_sdiff_right_self,
        inter_comm, ← diff_eq, ← union_singleton, union_comm]
      exact h

    @[simp]
    theorem sdiff_insert_of_mem_of_not_mem {i : α} (h : i ∈ s) (h' : i ∉ t) :
        insert i (s \ t) = s \ t ∪ {i} := by
  ext
  simp [or_iff_right_of_imp_left (mem_of_mem_diff (·))]

    @[simp]
    theorem sdiff_insert_insert_of_mem_of_not_mem {i : α} (h : i ∈ s) (h' : i ∉ t) :
        insert i (s \ insert i t) = s \ t := by
  rw [sdiff_insert, sdiff_insert_of_mem_of_not_mem h h', insert_diff_singleton_comm h']

    @[simp]
    theorem sdiff_sdiff_insert (h : i ∉ s) : s \ (t \ insert i s) = s \ t ∪ {i} := by
  rw [sdiff_sdiff_eq_sdiff_union (h' := subset_insert _ _),
    sdiff_insert_of_mem_of_not_mem (subset_insert _ _ h), union_comm]

    @[simp]
    theorem sdiff_sdiff_insert' (h : i ∉ t) : s \ (t \ insert i s) = s \ t ∪ {i} := by
  rw [sdiff_sdiff_eq_sdiff_union (h' := subset_insert _ _),
    sdiff_insert_of_mem_of_not_mem (subset_insert _ _ h), union_comm]

    @[simp]
    theorem sdiff_insert_of_not_mem {i : α} (h : i ∉ s) : s \ insert i t = s \ t := by
  rw [sdiff_sdiff_eq_sdiff_union (h' := disjoint_singleton_left.2 h),
    sdiff_singleton_eq_erase, union_comm, erase_eq_of_not_mem h]

    @[simp]
    theorem sdiff_insert_of_not_mem' {i : α} (h : i ∉ t) : s \ insert i t = s \ t := by
  rw [sdiff_sdiff_eq_sdiff_union (h' := disjoint_singleton_left.2 h),
    sdiff_singleton_eq_erase, union_comm, erase_eq_of_not_mem h]

    @[simp]
    theorem sdiff_sdiff_self_left (s t : Set α) : s \ (s \ t) = s ∩ t :=
      sdiff_sdiff_right_self

    @[simp]
    theorem sdiff_sdiff_self_right (s t : Set α) : t \ (s \ t) = t ∩ s :=
      sdiff_sdiff_left_self

    @[simp]
    theorem sdiff_sdiff_eq_self (h : t ⊆ s) : s \ (s \ t) = t :=
      sdiff_sdiff_eq_self h

    @[simp]
    theorem sdiff_sdiff_eq_self' (h : t ⊆ s) : s \ (s \ t) = t := by
  rw [sdiff_sdiff_eq_self h, sdiff_eq_self_iff_disjoint]
  exact disjoint_sdiff_self_right

    @[simp]
    theorem sdiff_sdiff_eq_self_of_disjoint (h : Disjoint s t) : s \ (s \ t) = t :=
      sdiff_sdiff_eq_self_of_le_right h.le

    @[simp]
    theorem sdiff_sdiff_eq_self_of_disjoint' (h : Disjoint s t) : s \ (s \ t) = t := by
  rw [sdiff_sdiff_eq_self_of_le_right h.le, sdiff_eq_self_iff_disjoint]
  exact h.symm

    @[simp]
    theorem sdiff_sdiff_eq_self_of_subset_right (h : t ⊆ s) : s \ (s \ t) = t :=
      sdiff_sdiff_eq_self_of_le_right h.le

    @[simp]
    theorem sdiff_sdiff_eq_self_of_subset_right' (h : t ⊆ s) : s \ (s \ t) = t := by
  rw [sdiff_sdiff_eq_self_of_le_right h.le, sdiff_eq_self

Attempt failure.

Working on Mathlib/Data/Set/Finite.lean - 2024-09-09 01:46:58.045356.
---83/200---
For theorem Set.eq_finite_iUnion_of_finite_subset_iUnion in Mathlib/Data/Set/Finite.lean:
theorem eq_finite_iUnion_of_finite_subset_iUnion {ι} {s : ι → Set α} {t : Set α} (tfin : t.Finite)
    (h : t ⊆ ⋃ i, s i) :
    ∃ I : Set ι,
      I.Finite ∧
        ∃ σ : { i | i ∈ I } → Set α, (∀ i, (σ i).Finite) ∧ (∀ i, σ i ⊆ s i) ∧ t = ⋃ i, σ i 


Original valid proof:
:=
  let ⟨I, Ifin, hI⟩ := finite_subset_iUnion tfin h
  ⟨I, Ifin, fun x => s x ∩ t, fun i => tfin.subset inter_subset_right, fun i =>
    inter_subset_left, by
    ext x
    rw [mem_iUnion]
    constructor
    · intro x_in
      rcases mem_iUnion.mp (hI x_in) with ⟨i, _, ⟨hi, rfl⟩, H⟩
      exact ⟨⟨i, hi⟩, ⟨H, x_in⟩⟩
    · rintro ⟨i, -, H⟩
      exact H⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
          ∀ (i) (hi : i ∈ I), (σ i).Nonempty → ∃ j : I, σ i ⊆ s j := by
  have : ∀ x ∈ t, ∃ i, x ∈ s i := by simpa only [exists_prop, mem_iUnion] using h
  choose! f hfs hf using this
  obtain ⟨I, hIf, hI⟩ : ∃ I : Set ι, I.Finite ∧ ∀ x ∈ t, ∃ i ∈ I, f x = i :=
    tfin.exists_finite_preimage (surj_on_image _ _)
  let σ : { i | i ∈ I } → Set α := fun i => f ⁻¹' {i.1} ∩ t
  have σfin : ∀ i, (σ i).Finite := fun i => (tfin.preimage_finite (finite_singleton _)).subset (by
    simp only [inter_subset_right])
  have σsub : ∀ i, σ i ⊆ s i := fun i x hx => hfs x (mem_of_mem_inter_right hx)
  have σdisj : PairwiseDisjoint (I : Set ι) σ := by
    rintro i _ j _ hij
    rw [disjoint_iff_inter_eq_empty]
    apply Subset.antisymm _ (empty_subset _)
    rintro x ⟨hxi, hxj⟩
    have : f x ∈ ({i, j} : Set ι) := by
      simpa only [mem_insert_iff, mem_singleton_iff] using
        mem_union_right _ (mem_of_mem_inter_left hxj)
    exact hij (hI x (mem_of_mem_inter_right hxi) _ this rfl)
  have : t = ⋃ i, σ ⟨i, i.2⟩ := by
    apply Subset.antisymm h
    rintro x hx
    simp only [mem_iUnion]
    obtain ⟨i, hi⟩ : ∃ i, f x = i := ⟨f x, rfl⟩
    refine' ⟨⟨i, hIf.mem_toFinset.2 (hI x hx i hi)⟩, _, hx⟩
    simp only [Subtype.coe_mk, mem_inter_iff, mem_preimage, mem_singleton_iff]
    exact ⟨rfl, hx⟩
  refine' ⟨I, hIf, fun i => f ⁻¹' {i.1} ∩ t, σfin, σsub, this, _⟩
  rintro i ⟨i, hi⟩ hσ
  obtain ⟨x, hx⟩ : (σ ⟨i, hi⟩).Nonempty := nonempty_of_nonempty_subtype hσ
  exact ⟨⟨i, hi⟩, Subset.trans (inter_subset_left _ _) (preimage_mono (singleton_subset_iff.2 rfl))⟩

Repaired Proof:
theorem eq_finite_iUnion_of_finite_subset_iUnion {ι} {s : ι → Set α} {t : Set α} (tfin : t.Finite)
    (h : t ⊆ ⋃ i, s i) :
    ∃ I : Set ι,
      I.Finite ∧
        ∃ σ : { i | i ∈ I } → Set α, (∀ i, (σ i).Finite) ∧ (∀ i, σ i ⊆ s i) ∧ t = ⋃ i, σ i ∧
          ∀ (i) (hi : i ∈ I), (σ i).Nonempty → ∃ j : I, σ i ⊆ s j := by
  have : ∀ x ∈ t, ∃ i, x ∈ s i := by simpa only [exists_prop, mem_iUnion] using h
  choose! f hfs hf using this
  obtain ⟨I, hIf, hI⟩ : ∃ I : Set ι, I.Finite ∧ ∀ x ∈ t, ∃ i ∈ I, f x = i :=
    tfin.exists_finite_preimage (surj_on_image _ _)
  let σ : { i | i ∈ I } → Set α := fun i => f ⁻¹' {i.1} ∩ t
  have σfin : ∀ i, (σ i).Finite := fun i => (tfin.preimage_finite (finite_singleton _)).subset (by
    simp only [inter_subset_right])
  have σsub : ∀ i, σ i ⊆ s i := fun i x hx => hfs x (mem_of_mem_inter_right hx)
  have σdisj : PairwiseDisjoint (I : Set ι) σ := by
    rintro i _ j _ hij
    rw [disjoint_iff_inter_eq_empty]
    apply Subset.antisymm _ (empty_subset _)
    rintro x ⟨hxi, hxj⟩
    have : f x ∈ ({i, j} : Set ι) := by
      simpa only [mem_insert_iff, mem_singleton_iff] using
        mem_union_right _ (mem_of_mem_inter_left hxj)
    exact hij (hI x (mem_of_mem_inter_right hxi) _ this rfl)
  have : t = ⋃ i, σ ⟨i, i.2⟩ := by
    apply Subset.antisymm h
    rintro x hx
    simp only [mem_iUnion]
    obtain ⟨i, hi⟩ : ∃ i, f x = i := ⟨f x, rfl⟩
    refine ⟨⟨i, hIf.mem_toFinset.2 (hI x hx i hi)⟩, _, hx⟩
    simp only [Subtype.coe_mk, mem_inter_iff, mem_preimage, mem_singleton_iff]
    exact ⟨rfl, hx⟩
  refine ⟨I, hIf, fun i => f ⁻¹' {i.1} ∩ t, σfin, σsub, this, ?_⟩
  rintro i ⟨i, hi⟩ hσ
  obtain ⟨x, hx⟩ : (σ ⟨i, hi⟩).Nonempty := nonempty_of_nonempty_subtype hσ
  exact ⟨⟨i, hi⟩, Subset.trans (inter_subset_left _ _) (preimage_mono (singleton_subset_iff.2 rfl))⟩

Repaired Proof:
theorem eq_finite_iUnion_of_finite_subset_iUnion {ι} {s : ι → Set α} {t : Set α} (tfin : t.Finite)
    (h : t ⊆ ⋃ i, s i) :
    ∃ I : Set ι,
      I.Finite ∧
        ∃ σ : { i | i ∈ I } → Set α, (∀ i, (σ i).Finite) ∧ (∀ i, σ i ⊆ s i) ∧ t = ⋃ i, σ i ∧
          ∀ (i) (hi : i ∈ I), (σ i).Nonempty → ∃ j : I, σ i ⊆ s j := by
  have : ∀ x ∈ t, ∃ i, x ∈ s i := by simpa only [exists_prop, mem_iUnion] using h
  choose! f hfs hf using this
  obtain ⟨I, hIf, hI⟩ : ∃ I : Set ι, I.Finite ∧ ∀ x ∈ t, ∃ i ∈ I, f x = i :=
    tfin.exists_finite_preimage (surj_on_image _ _)
  let σ : { i | i ∈ I } → Set α := fun i => f ⁻¹' {i.1} ∩ t
  have σfin : ∀ i, (σ i).Finite := fun i => (tfin.preimage_finite (finite_singleton _)).subset (by
    simp only [inter_subset_right])
  have σsub : ∀ i, σ i ⊆ s i

Attempt failure.

Working on Mathlib/Data/Set/Function.lean - 2024-09-09 01:47:05.996341.
---84/200---
For theorem Equiv.bijOn' in Mathlib/Data/Set/Function.lean:
lemma bijOn' (h₁ : MapsTo e s t) (h₂ : MapsTo e.symm t s) : BijOn e s t 


Original valid proof:
:=
  ⟨h₁, e.injective.injOn, fun b hb ↦ ⟨e.symm b, h₂ hb, apply_symm_apply _ _⟩⟩


Verifying proof (Commit ac36b28ef3759cb65a7f386f3b7e15ee0ac1b4c9):
↔ e.bijOnWith 1 s t :=
  bijOn_iff_bijOnWith.trans <| and_congr_right' $ by simp [h₁.mapsTo_invFunOn, h₂.invFunOn_mapsTo]

@[simp]
lemma bijOn_iff_bijOnWith_pos : BijOn e s t ↔ ∃ n > 0, BijOnWith n e s t := by
  refine ⟨fun h ↦ ⟨1, Nat.zero_lt_one, h.bijOnWith_pos⟩, ?_⟩
  rintro ⟨n, hn, h⟩
  obtain rfl | hne := eq_or_ne n 1
  · exact h
  rcases h.exists_bijOnWith_pos_lt hn hne with ⟨m, hm, h'⟩
  obtain rfl | h'm := eq_or_ne m 1
  · simpa using h'
  rcases h'.exists_bijOnWith_pos_lt hm h'm with ⟨k, hk, h''⟩
  obtain rfl | h''k := eq_or_ne k 1
  · simpa using h''
  simpa [pos_iff_ne_zero, hne, h'm, h''k] using h''.trans h'.trans h

@[simp]
lemma bijOn_iff_bijOnWith_neg : BijOn e s t ↔ ∃ n < 0, BijOnWith n e s t := by
  refine ⟨fun h ↦ ⟨-1, by norm_num, h.bijOnWith_neg⟩, ?_⟩
  rintro ⟨n, hn, h⟩
  obtain rfl | hne := eq_or_ne n (-1)
  · exact h
  rcases h.exists_bijOnWith_neg_lt hn hne with ⟨m, hm, h'⟩
  obtain rfl | h'm := eq_or_ne m (-1)
  · simpa using h'
  rcases h'.exists_bijOnWith_neg_lt hm h'm with ⟨k, hk, h''⟩
  obtain rfl | h''k := eq_or_ne k (-1)
  · simpa using h''
  simpa [neg_pos, hne, h'm, h''k] using h''.trans h'.trans h

@[simp]
lemma bijOn_iff_bijOnWith {n : ℤ} : BijOn e s t ↔ BijOnWith n e s t ↔ n = 1 ∨ n = -1 := by
  simp [bijOn_iff_bijOnWith_pos, bijOn_iff_bijOnWith_neg, or_comm]

@[deprecated (since := "2024-01-05")] alias bijOn_iff_bijOnWith_real := bijOn_iff_bijOnWith
@[deprecated (since := "2024-01-05")] alias bijOn_iff_bijOnWith_real_iff := bijOn_iff_bijOnWith

lemma bijOn_iff_bijOnWith_nat : BijOn e s t ↔ ∃ n : ℕ, BijOnWith n e s t := by
  simp [bijOn_iff_bijOnWith, pos_iff_ne_zero]

lemma bijOn_iff_bijOnWith_int : BijOn e s t ↔ ∃ n : ℤ, BijOnWith n e s t := by
  simp [bijOn_iff_bijOnWith]

lemma bijOn_iff_bijOnWith_nat' (h₁ : MapsTo e s t) (h₂ : MapsTo e.symm t s) :
    BijOn e s t ↔ ∃ n : ℕ, BijOnWith n e s t := by
  simp [bijOn_iff_bijOnWith, pos_iff_ne_zero, h₁, h₂]

lemma bijOn_iff_bijOnWith_int' (h₁ : MapsTo e s t) (h₂ : MapsTo e.symm t s) :
    BijOn e s t ↔ ∃ n : ℤ, BijOnWith n e s t := by
  simp [bijOn_iff_bijOnWith, h₁, h₂]

@[deprecated (since := "2024-01-05")] alias bijOn_iff_bijOnWith_real' := bijOn_iff_bijOnWith_int'
@[deprecated (since := "2024-01-05")] alias bijOn_iff_bijOnWith_real_iff' := bijOn_iff_bijOnWith_int'

lemma bijOn_iff_involutiveOnWith {α : Type*} (s : Set α) (f : α → α) :
    BijOn f s s ↔ InvolutiveOn f s := by
  simp [BijOn, invOn_iff_involutiveOn, forall_and]

@[deprecated (since := "2024-01-05")] alias bijOn_iff_involutiveOn := bijOn_iff_involutiveOnWith
@[deprecated (since := "2024-01-05")] alias bijOn_iff_involutiveOn_iff := bijOn_iff_involutiveOnWith

lemma bijOn_iff_involutiveOnWith_real {α : Type*} (s : Set α) (f : α → α) :
    BijOn f s s ↔ InvolutiveOn f s ∧ ∀ x ∈ s, f x ∈ s := by
  simp [BijOn, invOn_iff_involutiveOn, forall_and]

@[deprecated (since := "2024-01-05")] alias bijOn_iff_involutiveOnWith_real := bijOn_iff_involutiveOnWith_real
@[deprecated (since := "2024-01-05")] alias bijOn_iff_involutiveOnWith_real_iff := bijOn_iff_involutiveOnWith_real

lemma bijOn_iff_involutiveOnWith_int {α : Type*} (s : Set α) (f : α → α) :
    BijOn f s s ↔ InvolutiveOn f s ∧ ∀ x ∈ s, f x ∈ s ∧ f (f x) = x := by
  simp [BijOn, invOn_iff_involutiveOn, forall_and]

@[deprecated (since := "2024-01-05")] alias bijOn_iff_involutiveOnWith_int := bijOn_iff_involutiveOnWith_int
@[deprecated (since := "2024-01-05")] alias bijOn_iff_involutiveOnWith_int_iff := bijOn_iff_involutiveOnWith_int

lemma bijOn_iff_involutiveOnWith_nat {α : Type*} (s : Set α) (f : α → α) :
    BijOn f s s ↔ InvolutiveOn f s ∧ ∀ x ∈ s, f x ∈ s ∧ f (f x) = x := by
  simp [BijOn, invOn_iff_involutiveOn, forall_and]

@[deprecated (since := "2024-01-05")] alias bijOn_iff_involutiveOnWith_nat := bijOn_iff_involutiveOnWith_nat
@[deprecated (since := "2024-01-05")] alias bijOn_iff_involutiveOnWith_nat_iff := bijOn_iff_involutiveOnWith_nat

lemma bijOn_iff_involutiveOnWith_fin {α : Type*} (s : Set α) (f : α → α) :
    BijOn f s s ↔ InvolutiveOn f s ∧ ∀ x ∈ s, f x ∈ s ∧ f (f x) = x := by
  simp [BijOn, invOn_iff_involutiveOn, forall_and]

@[deprecated (since := "2024-01-05")] alias bijOn_iff_involutiveOnWith_fin := bijOn_iff_involutiveOnWith_fin
@[deprecated (since := "2024-01-05")] alias bijOn_iff_involutiveOnWith_fin_iff := bijOn_iff_involutiveOnWith_fin

lemma bijOn_iff_involutiveOnWith_finset {α : Type*} (s : Finset α) (f : α → α) :
    BijOn f s s ↔ InvolutiveOn f s ∧ ∀ x ∈ s

Attempt failure.

Working on Mathlib/Data/Set/Pointwise/Interval.lean - 2024-09-09 01:47:12.480320.
---85/200---
For theorem Set.Iic_add_bij in Mathlib/Data/Set/Pointwise/Interval.lean:
theorem Iic_add_bij : BijOn (· + a) (Iic b) (Iic (b + a)) 


Original valid proof:
:=
  image_add_const_Iic a b ▸ (add_left_injective _).injOn.bijOn_image


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      InjOn (· + a) (Iic b) :=
  Iic_add_bij' (add_le_add_right le_rfl _)

@[simp]
theorem image_add_const_Iic : (fun x => x + a) '' Iic b = Iic (b + a) :=
  (Iic_add_bij a).image_eq

@[simp]
theorem image_add_const_Iio : (fun x => x + a) '' Iio b = Iio (b + a) :=
  (Iio_add_bij a).image_eq

@[simp]
theorem image_add_const_Icc : (fun x => x + a) '' Icc b c = Icc (b + a) (c + a) :=
  (Icc_add_bij a).image_eq

@[simp]
theorem image_add_const_Ico : (fun x => x + a) '' Ico b c = Ico (b + a) (c + a) :=
  (Ico_add_bij a).image_eq

@[simp]
theorem image_add_const_Ioc : (fun x => x + a) '' Ioc b c = Ioc (b + a) (c + a) :=
  (Ioc_add_bij a).image_eq

@[simp]
theorem image_add_const_Ioo : (fun x => x + a) '' Ioo b c = Ioo (b + a) (c + a) :=
  (Ioo_add_bij a).image_eq

@[simp]
theorem image_const_add_Icc : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c) := by
  simp only [add_comm a, image_add_const_Icc]

@[simp]
theorem image_const_add_Ico : (fun x => a + x) '' Ico b c = Ico (a + b) (a + c) := by
  simp only [add_comm a, image_add_const_Ico]

@[simp]
theorem image_const_add_Ioc : (fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c) := by
  simp only [add_comm a, image_add_const_Ioc]

@[simp]
theorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) := by
  simp only [add_comm a, image_add_const_Ioo]

@[simp]
theorem image_add_const_Iio : (fun x => x + a) '' Iio b = Iio (b + a) :=
  (Iio_add_bij _).image_eq

@[simp]
theorem image_const_add_Iio : (fun x => a + x) '' Iio b = Iio (a + b) := by
  simp only [add_comm, image_add_const_Iio]

@[simp]
theorem image_add_const_Ici : (fun x => x + a) '' Ici b = Ici (b + a) :=
  (Ici_add_bij _).image_eq

@[simp]
theorem image_const_add_Ici : (fun x => a + x) '' Ici b = Ici (a + b) := by
  simp only [add_comm, image_add_const_Ici]

@[simp]
theorem image_add_const_Icc_left : (fun x => x + a) '' Icc b c = Icc (b + a) (c + a) :=
  (Icc_add_bij _).image_eq

@[simp]
theorem image_const_add_Icc_left : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c) := by
  simp only [add_comm, image_add_const_Icc_left]

@[simp]
theorem image_add_const_Icc_right : (fun x => x + a) '' Icc b c = Icc (b + a) (c + a) :=
  (Icc_add_bij _).image_eq

@[simp]
theorem image_const_add_Icc_right : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c) := by
  simp only [add_comm, image_add_const_Icc_right]

@[simp]
theorem image_add_const_Ico_left : (fun x => x + a) '' Ico b c = Ico (b + a) (c + a) :=
  (Ico_add_bij _).image_eq

@[simp]
theorem image_const_add_Ico_left : (fun x => a + x) '' Ico b c = Ico (a + b) (a + c) := by
  simp only [add_comm, image_add_const_Ico_left]

@[simp]
theorem image_add_const_Ico_right : (fun x => x + a) '' Ico b c = Ico (b + a) (c + a) :=
  (Ico_add_bij _).image_eq

@[simp]
theorem image_const_add_Ico_right : (fun x => a + x) '' Ico b c = Ico (a + b) (a + c) := by
  simp only [add_comm, image_add_const_Ico_right]

@[simp]
theorem image_add_const_Ioc_left : (fun x => x + a) '' Ioc b c = Ioc (b + a) (c + a) :=
  (Ioc_add_bij _).image_eq

@[simp]
theorem image_const_add_Ioc_left : (fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c) := by
  simp only [add_comm, image_add_const_Ioc_left]

@[simp]
theorem image_add_const_Ioc_right : (fun x => x + a) '' Ioc b c = Ioc (b + a) (c + a) :=
  (Ioc_add_bij _).image_eq

@[simp]
theorem image_const_add_Ioc_right : (fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c) := by
  simp only [add_comm, image_add_const_Ioc_right]

@[simp]
theorem image_add_const_Ioo_left : (fun x => x + a) '' Ioo b c = Ioo (b + a) (c + a) :=
  (Ioo_add_bij _).image_eq

@[simp]
theorem image_const_add_Ioo_left : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) := by
  simp only [add_comm, image_add_const_Ioo_left]

@[simp]
theorem image_add_const_Ioo_right : (fun x => x + a) '' Ioo b c = Ioo (b + a) (c + a) :=
  (Ioo_add_bij _).image_eq

@[simp]
theorem image_const_add_Ioo_right : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) := by
  simp only [add_comm, image_add_const_Ioo_right]

@[simp]
theorem image_const_sub_Icc : (fun x => a - x) '' Icc b c = Icc (a - c) (a - b) :=
  (Icc_sub_bij _).image_eq

@[simp]
theorem image_sub_const_Icc : (fun x => x - a) '' Icc b c = Icc (b - a) (c - a) :=
  (Icc_sub_bij _).image_eq

@[simp]
theorem image_const_sub_Ico : (fun x => a - x) '' Ico b c = Ico (a - c) (a - b) :=
  (Ico_sub_bij _).image_eq

@[simp]
theorem image_sub_const_Ico : (fun x => x - a) '' Ico b c = Ico (b - a) (c - a) :=
  (Ico_sub_bij _).image_eq

@[sim

Attempt failure.

Working on Mathlib/Data/Set/Prod.lean - 2024-09-09 01:47:24.311082.
---86/200---
For theorem Set.insert_prod in Mathlib/Data/Set/Prod.lean:
theorem insert_prod : insert a s ×ˢ t = Prod.mk a '' t ∪ s ×ˢ t 


Original valid proof:
:= by
  ext ⟨x, y⟩
  simp (config := { contextual := true }) [image, iff_def, or_imp]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ t ×ˢ insert a s = insert a s ×ˢ t :=
  ⟨by
    ext ⟨x, y⟩
    simp [and_comm, or_comm, and_left_comm, mem_image],
    by
    ext ⟨x, y⟩
    simp [and_comm, or_comm, and_left_comm, mem_image]⟩

@[simp]
theorem insert_prod_insert (s) (a : α) (t : Finset β) :
    insert a s ×ˢ insert b t =
      insert (a, b) (s ×ˢ insert b t ∪ insert a s ×ˢ t) := by
  simp only [insert_eq, union_prod_right, union_assoc, union_left_comm]

@[simp]
theorem card_product (s : Finset α) (t : Finset β) : card (s ×ˢ t) = card s * card t :=
  Multiset.card_product _ _


theorem inter_product [DecidableEq α] [DecidableEq β] : (s ∩ s') ×ˢ t = s ×ˢ t ∩ s' ×ˢ t := by
  ext ⟨x, y⟩
  simp only [← and_and_right, mem_inter, mem_product]


theorem product_inter [DecidableEq α] [DecidableEq β] : s ×ˢ (t ∩ t') = s ×ˢ t ∩ s ×ˢ t' := by
  ext ⟨x, y⟩
  simp only [← and_and_left, mem_inter, mem_product]


theorem disjoint_product : Disjoint (s ×ˢ t) (s' ×ˢ t') ↔ Disjoint s s' ∨ Disjoint t t' := by
  simp_rw [disjoint_left, mem_product, not_and_or, Prod.forall, and_imp]
  exact Iff.intro
    (fun h =>
      or_iff_not_imp_left.mpr fun hs =>
        or_iff_not_imp_left.mpr fun ht =>
          h _ (hs _) _ (ht _) _ _)
    fun h _ h₁ _ h₂ => h.elim (fun hs => hs _ h₁ _ _) fun ht => ht _ _ h₂ _


theorem disjoint_product_right : Disjoint s ×ˢ t s' ×ˢ t' ↔ Disjoint t t' ∨ Disjoint s s' := by
  rw [disjoint_iff_ne, disjoint_iff_ne]
  simp only [and_imp, mem_product, not_and, not_forall, exists_prop, Ne]
  constructor
  · rintro h ⟨⟨a, ha⟩, ⟨b, hb⟩⟩ ⟨⟨a', ha'⟩, ⟨b', hb'⟩⟩
    rcases h a b ha hb a' ha' b' hb' with ⟨⟨rfl, rfl⟩, ⟨rfl, rfl⟩⟩
    simp
  · rintro (h | h) ⟨⟨a, b⟩, hab, ⟨a', b'⟩, hab'⟩
    · rcases mem_product.1 hab with ⟨ha, hb⟩
      rcases mem_product.1 hab' with ⟨ha', hb'⟩
      exact h b hb b' hb'
    · rcases mem_product.1 hab' with ⟨ha', hb'⟩
      rcases mem_product.1 hab with ⟨ha, hb⟩
      exact h a ha a' ha'

theorem disjoint_product_left : Disjoint (s ×ˢ t) (s' ×ˢ t') ↔ Disjoint s s' ∨ Disjoint t t' := by
  rw [disjoint_iff_inter_eq_empty, disjoint_iff_inter_eq_empty, inter_product,
    inter_eq_empty_iff_disjoint, inter_eq_empty_iff_disjoint]


theorem filter_product (p : α → Prop) (q : β → Prop) [DecidablePred p] [DecidablePred q] :
    ((s ×ˢ t).filter fun x : α × β => p x.1 ∧ q x.2) = s.filter p ×ˢ t.filter q := by
  ext ⟨a, b⟩
  simp [mem_filter, mem_product, and_comm, and_left_comm, and_assoc]


theorem filter_product_left (p : α → Prop) [DecidablePred p] :
    ((s ×ˢ t).filter fun x : α × β => p x.1) = s.filter p ×ˢ t := by
  simpa using filter_product p fun _ => true


theorem filter_product_right (q : β → Prop) [DecidablePred q] :
    ((s ×ˢ t).filter fun x : α × β => q x.2) = s ×ˢ t.filter q := by
  simpa using filter_product (fun _ => true) q


theorem filter_product_left' (p : α → Prop) [DecidablePred p] :
    ((s ×ˢ t).filter fun x : α × β => p x.1) = s.filter p ×ˢ t := by
  simpa using filter_product p fun _ => true


theorem filter_product_right' (q : β → Prop) [DecidablePred q] :
    ((s ×ˢ t).filter fun x : α × β => q x.2) = s ×ˢ t.filter q := by
  simpa using filter_product (fun _ => true) q


theorem filter_product_left'' (p : α → Prop) [DecidablePred p] :
    ((s ×ˢ t).filter fun x : α × β => p x.1) = s.filter p ×ˢ t := by
  simpa using filter_product p fun _ => true


theorem filter_product_right'' (q : β → Prop) [DecidablePred q] :
    ((s ×ˢ t).filter fun x : α × β => q x.2) = s ×ˢ t.filter q := by
  simpa using filter_product (fun _ => true) q


theorem filter_product_left''' (p : α → Prop) [DecidablePred p] :
    ((s ×ˢ t).filter fun x : α × β => p x.1) = s.filter p ×ˢ t := by
  simpa using filter_product p fun _ => true


theorem filter_product_right''' (q : β → Prop) [DecidablePred q] :
    ((s ×ˢ t).filter fun x : α × β => q x.2) = s ×ˢ t.filter q := by
  simpa using filter_product (fun _ => true) q


theorem filter_product_left'''' (p : α → Prop) [DecidablePred p] :
    ((s ×ˢ t).filter fun x : α × β => p x.1) = s.filter p ×ˢ t := by
  simpa using filter_product p fun _ => true


theorem filter_product_right'''' (q : β → Prop) [DecidablePred q] :
    ((s ×ˢ t).filter fun x : α × β => q x.2) = s ×ˢ t.filter q := by
  simpa using filter_product (fun _ => true) q


theorem filter_product_left''''' (p : α → Prop) [DecidablePred p] :
    ((s ×ˢ t).filter fun x : α × β => p x.1) = s.filter p ×ˢ t := by
  simpa using filter_product p fun _ => true


theorem filter_product_right'''''' (q : β → Prop) [DecidablePred q] :
    ((s ×ˢ t).filter fun x : α × β => q x.2) = s ×ˢ t.filter q := by
  simpa using filter_product (fun _ => true) q


theorem filter_product_left''''''' (p : α → Prop) [DecidablePred p] :
    ((s ×ˢ t).filter fun x : α × β => p x.1) = s.filter p ×ˢ t := by
  simpa using filter_product p fun _ => true


theorem filter_product_right''''''' (q : β → Prop) [DecidablePred q] :
    ((s ×ˢ t).filter fun x : α × β => q x.2) = s ×ˢ t.filter q := by
  simpa using filter_product (

Attempt failure.

Working on Mathlib/Dynamics/OmegaLimit.lean - 2024-09-09 01:47:30.692342.
---87/200---
For theorem nonempty_omegaLimit_of_isCompact_absorbing in Mathlib/Dynamics/OmegaLimit.lean:
theorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set β} (hc₁ : IsCompact c)
    (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) (hs : s.Nonempty) : (ω f ϕ s).Nonempty 


Original valid proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rw [omegaLimit_eq_iInter_inter _ _ _ hv₁]
  apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed
  · rintro ⟨u₁, hu₁⟩ ⟨u₂, hu₂⟩
    use ⟨u₁ ∩ u₂, inter_mem hu₁ hu₂⟩
    constructor
    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)
  · intro u
    have hn : (image2 ϕ (u ∩ v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hv₁)) hs
    exact hn.mono subset_closure
  · intro
    apply hc₁.of_isClosed_subset isClosed_closure
    calc
      _ ⊆ closure (image2 ϕ v s) := closure_mono (image2_subset inter_subset_right Subset.rfl)
      _ ⊆ c := hv₂
  · exact fun _ ↦ isClosed_closure


Verifying proof (Commit 08ffc014ce7472c743cc849e2820181b3a1c4cae):
 :=
  let ⟨_, hn⟩ := exists_mem_of_nonempty_omegaLimit hc₁ hc₂ hs
  ⟨_, hn⟩

theorem isCompact_omegaLimit [R1Space β] [T2Space β] [CompactSpace β]
    {c : Set β} (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c)
    (hs : s.Nonempty) : IsCompact (ω f ϕ s) := by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases nonempty_omegaLimit_of_isCompact_absorbing hc₁ hc₂ hs with ⟨_, hxω⟩
  have hcs : IsClosed (ω f ϕ s) := isClosed_omegaLimit hv₁ hv₂
  exact hc₁.of_isClosed_subset hcs hxω (closure_minimal hxω hcs)

theorem tendsto_nhds_omegaLimit_of_cauchySeq [CompleteSpace β] [T2Space β]
    (cauchy : CauchySeq (ω f ϕ s)) : Tendsto (ω f ϕ s) f (𝓝 (ω f ϕ s)) := by
  rcases cauchy.nonempty_of_frequently with ⟨x, hx⟩
  refine tendsto_nhds_of_cauchySeq_of_subseq (cauchySeq_omegaLimit hx) ?_
  have h_subseq : ∃ (u : ℕ → Set α) (φ : ℕ → ℕ), StrictMono φ ∧
      (∀ n, u n ∈ f) ∧ ∀ n, closure (image2 ϕ (u n) s) ⊆ ω f ϕ s := by
    rcases cauchy.subseq_mem with ⟨u, hu_mem, hu_subseq⟩
    rcases mem_nhds_iff.mp (isOpen_omegaLimit.mem_nhds hx) with ⟨v, hv_sub, hv_open, hxv⟩
    rcases mem_nhds_iff.mp (isOpen_omegaLimit.mem_nhds (omegaLimit_subset_of_frequently hx hu_subseq))
      with ⟨w, hw_sub, hw_open, hxw⟩
    rcases exists_mem_nhds_isClosed_subset (hu_mem 0) (hv_open.inter hw_open)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨a, ha, ha_closed⟩
    rcases exists_mem_nhds_isClosed_subset hxv (hw_open.inter ha_closed)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨b, hb, hb_closed⟩
    rcases exists_mem_nhds_isClosed_subset hxw (isClosed_omegaLimit.inter hb_closed)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨c, hc, hc_closed⟩
    rcases exists_mem_nhds_isClosed_subset (hu_mem 1) (hv_open.inter hw_open)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨d, hd, hd_closed⟩
    rcases exists_mem_nhds_isClosed_subset hxv (hw_open.inter hd_closed)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨e, he, he_closed⟩
    rcases exists_mem_nhds_isClosed_subset hxw (isClosed_omegaLimit.inter he_closed)
      (inter_subset_left _ _) (inter_subset_right _ _) with ⟨f, hf, hf_closed⟩
    refine ⟨fun n ↦ if n = 0 then a else if n = 1 then b else if n = 2 then c else if n = 3 then d else f,
      fun n ↦ if n = 0 then 0 else if n = 1 then 1 else if n = 2 then 2 else if n = 3 then 3 else 4,
      ?_, ?_, ?_⟩
    · intro n m hnm
      simp only [fun i ↦ if i = 0 then a else if i = 1 then b else if i = 2 then c else if i = 3 then d else f]
      split_ifs with h₁ h₂ h₃ h₄ h₅ h₆ h₇ h₈ h₉ h₁₀ <;> try linarith
      simp only [fun i ↦ if i = 0 then 0 else if i = 1 then 1 else if i = 2 then 2 else if i = 3 then 3 else 4]
      split_ifs with h₁ h₂ h₃ h₄ h₅ h₆ h₇ h₈ h₉ h₁₀ <;> try linarith
      exact (lt_irrefl _ (lt_trans hnm h₁₀)).elim
    · intro n
      split_ifs with h₁ h₂ h₃ h₄ h₅ <;> simp [h₁, h₂, h₃, h₄, h₅, hu_mem]
    · intro n
      simp only [fun i ↦ if i = 0 then a else if i = 1 then b else if i = 2 then c else if i = 3 then d else f]
      split_ifs with h₁ h₂ h₃ h₄ h₅ h₆ h₇ h₈ h₉ h₁₀ <;> try linarith
      simp only [fun i ↦ if i = 0 then 0 else if i = 1 then 1 else if i = 2 then 2 else if i = 3 then 3 else 4]
      split_ifs with h₁ h₂ h₃ h₄ h₅ h₆ h₇ h₈ h₉ h₁₀ <;> try linarith
      refine closure_minimal ?_ (isClosed_omegaLimit.inter hb_closed).inter (isClosed_omegaLimit.inter he_closed)
      refine Subset.trans ?_ (inter_subset_left _ _)
      refine Subset.trans ?_ (inter_subset_right _ _)
      exact Subset.rfl
  rcases h_subseq with ⟨u, φ, hφ, hu_mem, hu_sub⟩
  refine tendsto_nhds_of_cauchySeq_of_subseq (cauchySeq_omegaLimit hx) ?_
  refine tendsto_nhds_of_cauchySeq_of_subseq (cauchySeq_of_tendsto_nhds (tendsto_map.comp
    (tendsto_nhds_of_cauchySeq_of_subseq (cauchySeq_omegaLimit hx) ?_)) ?_) ?_
  · intro n
    simpa only [tendsto_map'_iff, Function.comp_def] using hu_mem (φ n)
  · intro n
    simpa only [tendsto_map'_iff, Function.comp_def] using hu_sub n
  · exact tendsto_map

Repaired Proof:
theorem tendsto_nhds_omegaLimit_of_cauchySeq [CompleteSpace β] [T2Space β]
    (cauchy : CauchySeq (ω f ϕ s)) : Tendsto (ω f ϕ s) f (𝓝 (ω f ϕ s)) := by
  rcases cauchy.nonempty_of_frequently with ⟨x, hx⟩
  refine tendsto_nhds_of_cauchySeq_of_subseq (cauchySeq_omegaLimit hx) ?_
  have h_subseq : ∃ (u : ℕ → Set α) (φ : ℕ → ℕ), StrictMono φ ∧
      (∀ n, u n ∈ f) ∧ ∀ n, closure (image2 ϕ (u n) s) ⊆ ω f ϕ s := by
    rcases cauchy.subseq_mem with ⟨u, hu_mem, hu_subseq⟩
    rcases mem_nhds_iff.mp (isOpen_omegaLimit.mem_nhds hx) with ⟨v, hv_sub, hv_open, hxv⟩
    rcases mem_nhds_iff.mp (isOpen_omegaLimit.mem_nhds (omegaLimit_subset_of_frequently hx hu_subseq))
     

Attempt failure.

Working on Mathlib/FieldTheory/Finiteness.lean - 2024-09-09 01:47:37.719876.
---88/200---
For theorem IsNoetherian.iff_rank_lt_aleph0 in Mathlib/FieldTheory/Finiteness.lean:
theorem iff_rank_lt_aleph0 : IsNoetherian K V ↔ Module.rank K V < ℵ₀ 


Original valid proof:
:= by
  let b := Basis.ofVectorSpace K V
  rw [← b.mk_eq_rank'', lt_aleph0_iff_set_finite]
  constructor
  · intro
    exact (Basis.ofVectorSpaceIndex.linearIndependent K V).set_finite_of_isNoetherian
  · intro hbfinite
    refine
      @isNoetherian_of_linearEquiv K (⊤ : Submodule K V) V _ _ _ _ _ (LinearEquiv.ofTop _ rfl)
        (id ?_)
    refine isNoetherian_of_fg_of_noetherian _ ⟨Set.Finite.toFinset hbfinite, ?_⟩
    rw [Set.Finite.coe_toFinset, ← b.span_eq, Basis.coe_ofVectorSpace, Subtype.range_coe]


Verifying proof (Commit d2d4547dc5d4da050bede9036f96ca058630a465):
∧ Finite K V := by
  constructor
  · intro
    exact ⟨rank_lt_aleph0, inferInstance⟩
  · rintro ⟨h₁, h₂⟩
    haveI := h₂
    exact isNoetherian_of_linearEquiv (LinearEquiv.ofTop (⊤ : Submodule K V) rfl)

Repaired Proof:
theorem iff_rank_lt_aleph0 : IsNoetherian K V ↔ Module.rank K V < ℵ₀ ∧ Finite K V := by
  constructor
  · intro
    exact ⟨rank_lt_aleph0, inferInstance⟩
  · rintro ⟨h₁, h₂⟩
    haveI := h₂
    exact isNoetherian_of_linearEquiv (LinearEquiv.ofTop (⊤ : Submodule K V) rfl)

Repaired Proof:
theorem iff_rank_eq_one : IsNoetherian K V ↔ Module.rank K V = 1 := by
  simp_rw [iff_rank_lt_aleph0, lt_aleph0_iff_set_finite, rank_eq_one_iff]
  constructor
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₂
    exact ⟨h₁.to_subsingleton, ⟨default, Submodule.ext fun _ => Subsingleton.elim _ _⟩⟩
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₁
    exact ⟨h₂.1, h₂.2.symm ▸ finite_bot _⟩

Repaired Proof:
theorem iff_rank_eq_one : IsNoetherian K V ↔ Module.rank K V = 1 := by
  simp_rw [iff_rank_lt_aleph0, lt_aleph0_iff_set_finite, rank_eq_one_iff]
  constructor
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₂
    exact ⟨h₁.to_subsingleton, ⟨default, Submodule.ext fun _ => Subsingleton.elim _ _⟩⟩
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₁
    exact ⟨h₂.1, h₂.2.symm ▸ finite_bot _⟩

Repaired Proof:
theorem iff_rank_eq_one : IsNoetherian K V ↔ Module.rank K V = 1 := by
  simp_rw [iff_rank_lt_aleph0, lt_aleph0_iff_set_finite, rank_eq_one_iff]
  constructor
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₂
    exact ⟨h₁.to_subsingleton, ⟨default, Submodule.ext fun _ => Subsingleton.elim _ _⟩⟩
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₁
    exact ⟨h₂.1, h₂.2.symm ▸ finite_bot _⟩

Repaired Proof:
theorem iff_rank_eq_one : IsNoetherian K V ↔ Module.rank K V = 1 := by
  simp_rw [iff_rank_lt_aleph0, lt_aleph0_iff_set_finite, rank_eq_one_iff]
  constructor
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₂
    exact ⟨h₁.to_subsingleton, ⟨default, Submodule.ext fun _ => Subsingleton.elim _ _⟩⟩
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₁
    exact ⟨h₂.1, h₂.2.symm ▸ finite_bot _⟩

Repaired Proof:
theorem iff_rank_eq_one : IsNoetherian K V ↔ Module.rank K V = 1 := by
  simp_rw [iff_rank_lt_aleph0, lt_aleph0_iff_set_finite, rank_eq_one_iff]
  constructor
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₂
    exact ⟨h₁.to_subsingleton, ⟨default, Submodule.ext fun _ => Subsingleton.elim _ _⟩⟩
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₁
    exact ⟨h₂.1, h₂.2.symm ▸ finite_bot _⟩

Repaired Proof:
theorem iff_rank_eq_one : IsNoetherian K V ↔ Module.rank K V = 1 := by
  simp_rw [iff_rank_lt_aleph0, lt_aleph0_iff_set_finite, rank_eq_one_iff]
  constructor
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₂
    exact ⟨h₁.to_subsingleton, ⟨default, Submodule.ext fun _ => Subsingleton.elim _ _⟩⟩
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₁
    exact ⟨h₂.1, h₂.2.symm ▸ finite_bot _⟩

Repaired Proof:
theorem iff_rank_eq_one : IsNoetherian K V ↔ Module.rank K V = 1 := by
  simp_rw [iff_rank_lt_aleph0, lt_aleph0_iff_set_finite, rank_eq_one_iff]
  constructor
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₂
    exact ⟨h₁.to_subsingleton, ⟨default, Submodule.ext fun _ => Subsingleton.elim _ _⟩⟩
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₁
    exact ⟨h₂.1, h₂.2.symm ▸ finite_bot _⟩

Repaired Proof:
theorem iff_rank_eq_one : IsNoetherian K V ↔ Module.rank K V = 1 := by
  simp_rw [iff_rank_lt_aleph0, lt_aleph0_iff_set_finite, rank_eq_one_iff]
  constructor
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₂
    exact ⟨h₁.to_subsingleton, ⟨default, Submodule.ext fun _ => Subsingleton.elim _ _⟩⟩
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₁
    exact ⟨h₂.1, h₂.2.symm ▸ finite_bot _⟩

Repaired Proof:
theorem iff_rank_eq_one : IsNoetherian K V ↔ Module.rank K V = 1 := by
  simp_rw [iff_rank_lt_aleph0, lt_aleph0_iff_set_finite, rank_eq_one_iff]
  constructor
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₂
    exact ⟨h₁.to_subsingleton, ⟨default, Submodule.ext fun _ => Subsingleton.elim _ _⟩⟩
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₁
    exact ⟨h₂.1, h₂.2.symm ▸ finite_bot _⟩

Repaired Proof:
theorem iff_rank_eq_one : IsNoetherian K V ↔ Module.rank K V = 1 := by
  simp_rw [iff_rank_lt_aleph0, lt_aleph0_iff_set_finite, rank_eq_one_iff]
  constructor
  · rintro ⟨h₁, h₂⟩
    haveI : Subsingleton V := h₂
    exact ⟨h₁.to_subsingleton, ⟨default, Submodule.ext fun _ => Sub

Attempt failure.

Working on Mathlib/FieldTheory/PurelyInseparable.lean - 2024-09-09 01:47:44.911533.
---89/200---
For theorem Polynomial.Separable.map_irreducible_of_isPurelyInseparable in Mathlib/FieldTheory/PurelyInseparable.lean:
theorem Polynomial.Separable.map_irreducible_of_isPurelyInseparable {f : F[X]} (hsep : f.Separable)
    (hirr : Irreducible f) [IsPurelyInseparable F E] : Irreducible (f.map (algebraMap F E)) 


Original valid proof:
:= by
  let K := AlgebraicClosure E
  obtain ⟨x, hx⟩ := IsAlgClosed.exists_aeval_eq_zero K f
    (natDegree_pos_iff_degree_pos.1 hirr.natDegree_pos).ne'
  have ha : Associated f (minpoly F x) := by
    have := isUnit_C.2 (leadingCoeff_ne_zero.2 hirr.ne_zero).isUnit.inv
    exact ⟨this.unit, by rw [IsUnit.unit_spec, minpoly.eq_of_irreducible hirr hx]⟩
  have ha' : Associated (f.map (algebraMap F E)) ((minpoly F x).map (algebraMap F E)) :=
    ha.map (mapRingHom (algebraMap F E)).toMonoidHom
  have heq := minpoly.map_eq_of_separable_of_isPurelyInseparable E x (ha.separable hsep)
  rw [ha'.irreducible_iff, heq]
  exact minpoly.irreducible (Algebra.IsIntegral.isIntegral x)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
      f.map (algebraMap F E).Separable := by
  have hf : f ≠ 0 := hirr.ne_zero
  have hf' : f.derivative ≠ 0 := hsep.derivative_ne_zero
  have hf'' : f.derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf' (map_injective _ (IsPurelyInseparable.injective F E) h)
  refine ⟨?_, hsep.map⟩
  have hf''' : f.map (algebraMap F E) ≠ 0 := fun h =>
    hf (map_injective _ (IsPurelyInseparable.injective F E) h)
  have hf'''' : (f.map (algebraMap F E)).derivative ≠ 0 := fun h =>
    hf''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 := fun h =>
    hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf''''''''''''''''''''''''''''''''' : (f.map (algebraMap F E)).derivative.map (algebraMap F E) ≠ 0 :=
    fun h => hf'''' (derivative_eq_zero_of_map_eq_zero (algebraMap F E) h)
  have hf'''''''''''''''''''''''''''''''''' : (f.map (algebraMap F

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean - 2024-09-09 01:48:13.856546.
---90/200---
For theorem Sbtw.angle₁₂₃_eq_pi in Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean:
theorem _root_.Sbtw.angle₁₂₃_eq_pi {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∠ p₁ p₂ p₃ = π 


Original valid proof:
:= by
  rw [angle, angle_eq_pi_iff]
  rcases h with ⟨⟨r, ⟨hr0, hr1⟩, hp₂⟩, hp₂p₁, hp₂p₃⟩
  refine ⟨vsub_ne_zero.2 hp₂p₁.symm, -(1 - r) / r, ?_⟩
  have hr0' : r ≠ 0 := by
    rintro rfl
    rw [← hp₂] at hp₂p₁
    simp at hp₂p₁
  have hr1' : r ≠ 1 := by
    rintro rfl
    rw [← hp₂] at hp₂p₃
    simp at hp₂p₃
  replace hr0 := hr0.lt_of_ne hr0'.symm
  replace hr1 := hr1.lt_of_ne hr1'
  refine ⟨div_neg_of_neg_of_pos (Left.neg_neg_iff.2 (sub_pos.2 hr1)) hr0, ?_⟩
  rw [← hp₂, AffineMap.lineMap_apply, vsub_vadd_eq_vsub_sub, vsub_vadd_eq_vsub_sub, vsub_self,
    zero_sub, smul_neg, smul_smul, div_mul_cancel₀ _ hr0', neg_smul, neg_neg, sub_eq_iff_eq_add, ←
    add_smul, sub_add_cancel, one_smul]


Verifying proof (Commit 20f7b16a2188446119159f1899fa98e635e7c11d):
↔ p₁ = p₃ := by
  rw [angle, h.oangle₁₂₃_eq_pi, _root_.oangle_eq_pi_iff_oangle_rev_eq_zero, oangle_rev,
    h.oangle₂₃₁_eq_zero, eq_comm]


theorem _root_.Sbtw.angle₁₂₃_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₁ p₂ p₃ = π ↔ p₁ = p₃ := by
  rw [h.angle₁₂₃_eq_pi, ← @dist_ne_zero ℝ, h.dist_eq_zero_iff, eq_comm]


theorem _root_.Sbtw.angle₃₂₁_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₃ p₂ p₁ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₂₁₃_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₂ p₁ p₃ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₃₁₂_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₃ p₁ p₂ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₂₃₁_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₂ p₃ p₁ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₃₂₁_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₃ p₂ p₁ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₂₁₃_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₂ p₁ p₃ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₃₁₂_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₃ p₁ p₂ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₂₃₁_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₂ p₃ p₁ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₃₂₁_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₃ p₂ p₁ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₂₁₃_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₂ p₁ p₃ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₃₁₂_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₃ p₁ p₂ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₂₃₁_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₂ p₃ p₁ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₃₂₁_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₃ p₂ p₁ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₂₁₃_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₂ p₁ p₃ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₃₁₂_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₃ p₁ p₂ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₂₃₁_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₂ p₃ p₁ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₃₂₁_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) :
    ∠ p₃ p₂ p₁ = π ↔ p₁ = p₃ := by
  rw [h.symm.angle₁₂₃_eq_pi_iff, h.symm.left_ne, h.symm.ne_right]


theorem _root_.Sbtw.angle₂₁₃_eq_pi_iff {p₁ p₂ p₃ : P} (h : Sbtw ℝ p

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Inversion/Calculus.lean - 2024-09-09 01:48:25.629918.
---91/200---
For theorem EuclideanGeometry.hasFDerivAt_inversion in Mathlib/Geometry/Euclidean/Inversion/Calculus.lean:
theorem hasFDerivAt_inversion (hx : x ≠ c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 • (reflection (ℝ ∙ (x - c))ᗮ : F →L[ℝ] F)) x 


Original valid proof:
:= by
  rcases add_left_surjective c x with ⟨x, rfl⟩
  have : HasFDerivAt (inversion c R) (?_ : F →L[ℝ] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (𝕜 := ℝ) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ℝ ∙ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ↦ ?_)
  · have : ((‖x‖ ^ 2) ^ 2)⁻¹ * (‖x‖ ^ 2) = (‖x‖ ^ 2)⁻¹ := by
      rw [← div_eq_inv_mul, sq (‖x‖ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  · simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]


Verifying proof (Commit 8c4338d2f64ef8da7809ea24b10b780568e6b917):
∧
      dist ((inversion c R x : F) - x) (reflection (ℝ ∙ (x - c))ᗮ (x - c)) <
        dist x c * (R / dist x c) ^ 2 := by
  have hc : ‖c - x‖ ≠ 0 := by simp [hx]
  have H₁ : ‖(x - c) / ‖x - c‖ - 1‖ = ‖(x - c) / ‖x - c‖ + 1‖ := by
    rw [← norm_norm (x - c), ← norm_smul, ← norm_smul, smul_sub, sub_smul, one_smul,
      norm_sub_rev, norm_sub_rev]
    simp
  have H₂ : ‖(x - c) / ‖x - c‖ - 1‖ ≠ 0 := by
    rw [H₁]
    simp [hc]
  have H₃ : ‖(x - c) / ‖x - c‖ + 1‖ ^ 2 ≠ 0 := by
    rw [norm_add_eq_sqrt_iff_real_inner_eq_zero, inner_self_eq_zero, norm_eq_zero,
      add_eq_zero_iff_eq_neg, inner_self_eq_zero, norm_eq_zero, eq_self_iff_true,
      Ne, not_true, Ne, not_false_iff, sq, mul_self_pos]
    · simpa [hc] using hx
    · simpa [hc] using hx
  have H₄ : ‖(x - c) / ‖x - c‖ - 1‖ ^ 2 ≠ 0 := by
    rw [sq_ne_zero]
    simpa [H₂]
  have H₅ : ‖(x - c) / ‖x - c‖ + 1‖ ^ 2 * ‖(x - c) / ‖x - c‖ - 1‖ ^ 2 ≠ 0 := by
    simpa [H₃, H₄] using mul_ne_zero H₃ H₄
  have H₆ : ‖(x - c) / ‖x - c‖‖ = 1 := by
    rw [norm_div, norm_norm, div_self hc]
  have H₇ : ‖(x - c) / ‖x - c‖‖ ^ 2 = 1 := by
    rw [sq, H₆]
    simp
  have H₈ : ‖(x - c) / ‖x - c‖‖ ≠ 0 := by simpa [H₆] using hx
  have H₉ : ‖(x - c) / ‖x - c‖‖ ^ 2 ≠ 0 := by simpa [H₇] using hx
  have H₁₀ : ‖(x - c) / ‖x - c‖‖⁻¹ ≠ 0 := by simpa [H₆] using hx
  have H₁₁ : ‖(x - c) / ‖x - c‖‖⁻¹ ≠ 1 := by simpa [H₆] using hx
  have H₁₂ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 0 := by simpa [H₇] using hx
  have H₁₃ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -1 := by simpa [H₇] using hx
  have H₁₄ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 2 := by simpa [H₇] using hx
  have H₁₅ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -2 := by simpa [H₇] using hx
  have H₁₆ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 3 / 2 := by simpa [H₇] using hx
  have H₁₇ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -3 / 2 := by simpa [H₇] using hx
  have H₁₈ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 5 / 2 := by simpa [H₇] using hx
  have H₁₉ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -5 / 2 := by simpa [H₇] using hx
  have H₂₀ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 7 / 2 := by simpa [H₇] using hx
  have H₂₁ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -7 / 2 := by simpa [H₇] using hx
  have H₂₂ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 9 / 2 := by simpa [H₇] using hx
  have H₂₃ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -9 / 2 := by simpa [H₇] using hx
  have H₂₄ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 11 / 2 := by simpa [H₇] using hx
  have H₂₅ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -11 / 2 := by simpa [H₇] using hx
  have H₂₆ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 13 / 2 := by simpa [H₇] using hx
  have H₂₇ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -13 / 2 := by simpa [H₇] using hx
  have H₂₈ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 15 / 2 := by simpa [H₇] using hx
  have H₂₉ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -15 / 2 := by simpa [H₇] using hx
  have H₃₀ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 17 / 2 := by simpa [H₇] using hx
  have H₃₁ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -17 / 2 := by simpa [H₇] using hx
  have H₃₂ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 19 / 2 := by simpa [H₇] using hx
  have H₃₃ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -19 / 2 := by simpa [H₇] using hx
  have H₃₄ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 21 / 2 := by simpa [H₇] using hx
  have H₃₅ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -21 / 2 := by simpa [H₇] using hx
  have H₃₆ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 23 / 2 := by simpa [H₇] using hx
  have H₃₇ : ‖(x - c) / ‖

Attempt failure.

---92/200---
For theorem EuclideanGeometry.hasFDerivAt_inversion in Mathlib/Geometry/Euclidean/Inversion/Calculus.lean:
theorem hasFDerivAt_inversion (hx : x ≠ c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 • (reflection (ℝ ∙ (x - c))ᗮ : F →L[ℝ] F)) x 


Original valid proof:
:= by
  rcases add_left_surjective c x with ⟨x, rfl⟩
  have : HasFDerivAt (inversion c R) (?_ : F →L[ℝ] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (𝕜 := ℝ) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ℝ ∙ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ↦ ?_)
  · have : ((‖x‖ ^ 2) ^ 2)⁻¹ * (‖x‖ ^ 2) = (‖x‖ ^ 2)⁻¹ := by
      rw [← div_eq_inv_mul, sq (‖x‖ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  · simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]


Verifying proof (Commit 7088139429bcf36357f4c44f3beff1a1374a13e1):
∧
      dist ((inversion c R x : F) - x) (reflection (ℝ ∙ (x - c))ᗮ (x - c)) <
        dist x c * (R / dist x c) ^ 2 := by
  have hc : ‖c - x‖ ≠ 0 := by simp [hx]
  have H₁ : ‖(x - c) / ‖x - c‖ - 1‖ = ‖(x - c) / ‖x - c‖ + 1‖ := by
    rw [← norm_norm (x - c), ← norm_smul, ← norm_smul, smul_sub, sub_smul, one_smul,
      norm_sub_rev, norm_sub_rev]
    simp
  have H₂ : ‖(x - c) / ‖x - c‖ - 1‖ ≠ 0 := by
    rw [H₁]
    simp [hc]
  have H₃ : ‖(x - c) / ‖x - c‖ + 1‖ ^ 2 ≠ 0 := by
    rw [norm_add_eq_sqrt_iff_real_inner_eq_zero, inner_self_eq_zero, norm_eq_zero,
      add_eq_zero_iff_eq_neg, inner_self_eq_zero, norm_eq_zero, eq_self_iff_true,
      Ne, not_true, Ne, not_false_iff, sq, mul_self_pos]
    · simpa [hc] using hx
    · simpa [hc] using hx
  have H₄ : ‖(x - c) / ‖x - c‖ - 1‖ ^ 2 ≠ 0 := by
    rw [sq_ne_zero]
    simpa [H₂]
  have H₅ : ‖(x - c) / ‖x - c‖ + 1‖ ^ 2 * ‖(x - c) / ‖x - c‖ - 1‖ ^ 2 ≠ 0 := by
    simpa [H₃, H₄] using mul_ne_zero H₃ H₄
  have H₆ : ‖(x - c) / ‖x - c‖‖ = 1 := by
    rw [norm_div, norm_norm, div_self hc]
  have H₇ : ‖(x - c) / ‖x - c‖‖ ^ 2 = 1 := by
    rw [sq, H₆]
    simp
  have H₈ : ‖(x - c) / ‖x - c‖‖ ≠ 0 := by simpa [H₆] using hx
  have H₉ : ‖(x - c) / ‖x - c‖‖ ^ 2 ≠ 0 := by simpa [H₇] using hx
  have H₁₀ : ‖(x - c) / ‖x - c‖‖⁻¹ ≠ 0 := by simpa [H₆] using hx
  have H₁₁ : ‖(x - c) / ‖x - c‖‖⁻¹ ≠ 1 := by simpa [H₆] using hx
  have H₁₂ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 0 := by simpa [H₇] using hx
  have H₁₃ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -1 := by simpa [H₇] using hx
  have H₁₄ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 2 := by simpa [H₇] using hx
  have H₁₅ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -2 := by simpa [H₇] using hx
  have H₁₆ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 3 / 2 := by simpa [H₇] using hx
  have H₁₇ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -3 / 2 := by simpa [H₇] using hx
  have H₁₈ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 5 / 2 := by simpa [H₇] using hx
  have H₁₉ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -5 / 2 := by simpa [H₇] using hx
  have H₂₀ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 7 / 2 := by simpa [H₇] using hx
  have H₂₁ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -7 / 2 := by simpa [H₇] using hx
  have H₂₂ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 9 / 2 := by simpa [H₇] using hx
  have H₂₃ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -9 / 2 := by simpa [H₇] using hx
  have H₂₄ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 11 / 2 := by simpa [H₇] using hx
  have H₂₅ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -11 / 2 := by simpa [H₇] using hx
  have H₂₆ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 13 / 2 := by simpa [H₇] using hx
  have H₂₇ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -13 / 2 := by simpa [H₇] using hx
  have H₂₈ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 15 / 2 := by simpa [H₇] using hx
  have H₂₉ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -15 / 2 := by simpa [H₇] using hx
  have H₃₀ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 17 / 2 := by simpa [H₇] using hx
  have H₃₁ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -17 / 2 := by simpa [H₇] using hx
  have H₃₂ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 19 / 2 := by simpa [H₇] using hx
  have H₃₃ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -19 / 2 := by simpa [H₇] using hx
  have H₃₄ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 21 / 2 := by simpa [H₇] using hx
  have H₃₅ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ -21 / 2 := by simpa [H₇] using hx
  have H₃₆ : ‖(x - c) / ‖x - c‖‖ ^ 2 - 1 ≠ 23 / 2 := by simpa [H₇] using hx
  have H₃₇ : ‖(x - c) / ‖

Attempt failure.

Working on Mathlib/Geometry/Euclidean/MongePoint.lean - 2024-09-09 01:48:44.771808.
---93/200---
For theorem EuclideanGeometry.OrthocentricSystem.eq_insert_orthocenter in Mathlib/Geometry/Euclidean/MongePoint.lean:
theorem OrthocentricSystem.eq_insert_orthocenter {s : Set P} (ho : OrthocentricSystem s)
    {t : Triangle ℝ P} (ht : Set.range t.points ⊆ s) :
    s = insert t.orthocenter (Set.range t.points) 


Original valid proof:
:= by
  rcases ho with ⟨t₀, ht₀o, ht₀s⟩
  rw [ht₀s] at ht
  rcases exists_of_range_subset_orthocentricSystem ht₀o ht t.independent.injective with
    (⟨i₁, i₂, i₃, j₂, j₃, h₁₂, h₁₃, h₂₃, h₁₂₃, h₁, hj₂₃, h₂, h₃⟩ | hs)
  · obtain ⟨j₁, hj₁₂, hj₁₃, hj₁₂₃⟩ :
        ∃ j₁ : Fin 3, j₁ ≠ j₂ ∧ j₁ ≠ j₃ ∧ ∀ j : Fin 3, j = j₁ ∨ j = j₂ ∨ j = j₃ := by
      clear h₂ h₃
      fin_cases j₂ <;> fin_cases j₃ <;> simp (config := {decide := true}) at hj₂₃ ⊢
    suffices h : t₀.points j₁ = t.orthocenter by
      have hui : (Set.univ : Set (Fin 3)) = {i₁, i₂, i₃} := by ext x; simpa using h₁₂₃ x
      have huj : (Set.univ : Set (Fin 3)) = {j₁, j₂, j₃} := by ext x; simpa using hj₁₂₃ x
      rw [← h, ht₀s, ← Set.image_univ, huj, ← Set.image_univ, hui]
      simp_rw [Set.image_insert_eq, Set.image_singleton, h₁, ← h₂, ← h₃]
      rw [Set.insert_comm]
    exact
      (Triangle.orthocenter_replace_orthocenter_eq_point hj₁₂ hj₁₃ hj₂₃ h₁₂ h₁₃ h₂₃ h₁ h₂.symm
          h₃.symm).symm
  · rw [hs]
    convert ht₀s using 2
    exact Triangle.orthocenter_eq_of_range_eq hs


Verifying proof (Commit 0f24aee7da46f85fee5cacc716172444ce31e582):
∨ s = Set.range t.points := by
  rcases ho with ⟨c, hc⟩
  have hcs : c ∈ s := by simpa [hc] using Set.mem_insert c {c}
  rcases Set.eq_singleton_or_nontrivial hc with (rfl | ⟨p, p', hp'⟩)
  · simp
  have hc' : c ≠ p' := by
    rintro rfl
    exact hp' rfl
  have hcp : p ≠ c := by
    rintro rfl
    exact hp' (Set.mem_singleton c)
  have hpc : p ≠ p' := by
    rintro rfl
    exact hp' rfl
  rcases t.eq_degenerate_or_nondegenerate with (rfl | ⟨hne, hn⟩)
  · simp only [Set.range_singleton, Set.insert_eq_of_mem, Set.mem_singleton_iff] at ht
    have hs : s = {c, c} := by simpa [hc] using hc
    simp [hs, ht, hc', hcp, hpc]
  have hc : p ∈ s := by simpa [hc] using Set.mem_insert_of_mem c (Set.mem_singleton p)
  have hp's : p' ∈ s := by simpa [hc] using Set.mem_insert_of_mem c (Set.mem_singleton p')
  have hts : Set.range t.points ⊆ insert t.orthocenter (Set.range t.points) := by
    simp [hts]
  have hcs' : c ∈ insert t.orthocenter (Set.range t.points) := by simpa [hts] using hcs
  have hps : p ∈ insert t.orthocenter (Set.range t.points) := by simpa [hts] using hps
  have hp's' : p' ∈ insert t.orthocenter (Set.range t.points) := by simpa [hts] using hp's
  have hts' : Set.range t.points ⊆ s := ht
  have hcs'' : c ∈ s := by simpa [hts'] using hcs'
  have hps'' : p ∈ s := by simpa [hts'] using hps
  have hp's'' : p' ∈ s := by simpa [hts'] using hp's'
  have hsc : s = insert t.orthocenter (Set.range t.points) ∨ s = Set.range t.points := by
    simpa [hts', hts] using ho.eq_of_subset_of_card_le hts' (by simp [hts])
  simpa [hts', hts] using hsc

Repaired Proof:
theorem OrthocentricSystem.eq_insert_orthocenter {s : Set P} (ho : OrthocentricSystem s)
    {t : Triangle ℝ P} (ht : Set.range t.points ⊆ s) :
    s = insert t.orthocenter (Set.range t.points) ∨ s = Set.range t.points := by
  rcases ho with ⟨c, hc⟩
  have hcs : c ∈ s := by simpa [hc] using Set.mem_insert c {c}
  rcases Set.eq_singleton_or_nontrivial hc with (rfl | ⟨p, p', hp'⟩)
  · simp
  have hc' : c ≠ p' := by
    rintro rfl
    exact hp' rfl
  have hcp : p ≠ c := by
    rintro rfl
    exact hp' (Set.mem_singleton c)
  have hpc : p ≠ p' := by
    rintro rfl
    exact hp' rfl
  rcases t.eq_degenerate_or_nondegenerate with (rfl | ⟨hne, hn⟩)
  · simp only [Set.range_singleton, Set.insert_eq_of_mem, Set.mem_singleton_iff] at ht
    have hs : s = {c, c} := by simpa [hc] using hc
    simp [hs, ht, hc', hcp, hpc]
  have hc : p ∈ s := by simpa [hc] using Set.mem_insert_of_mem c (Set.mem_singleton p)
  have hp's : p' ∈ s := by simpa [hc] using Set.mem_insert_of_mem c (Set.mem_singleton p')
  have hts : Set.range t.points ⊆ insert t.orthocenter (Set.range t.points) := by
    simp [hts]
  have hcs' : c ∈ insert t.orthocenter (Set.range t.points) := by simpa [hts] using hcs
  have hps : p ∈ insert t.orthocenter (Set.range t.points) := by simpa [hts] using hps
  have hp's' : p' ∈ insert t.orthocenter (Set.range t.points) := by simpa [hts] using hp's
  have hts' : Set.range t.points ⊆ s := ht
  have hcs'' : c ∈ s := by simpa [hts'] using hcs'
  have hps'' : p ∈ s := by simpa [hts'] using hps
  have hp's'' : p' ∈ s := by simpa [hts'] using hp's'
  have hsc : s = insert t.orthocenter (Set.range t.points) ∨ s = Set.range t.points := by
    simpa [hts', hts] using ho.eq_of_subset_of_card_le hts' (by simp [hts])
  simpa [hts', hts] using hsc

Repaired Proof:
theorem OrthocentricSystem.eq_insert_orthocenter {s : Set P} (ho : OrthocentricSystem s)
    {t : Triangle ℝ P} (ht : Set.range t.points ⊆ s) :
    s = insert t.orthocenter (Set.range t.points) ∨ s = Set.range t.points := by
  rcases ho with ⟨c, hc⟩
  have hcs : c ∈ s := by simpa [hc] using Set.mem_insert c {c}
  rcases Set.eq_singleton_or_nontrivial hc with (rfl | ⟨p, p', hp'⟩)
  · simp
  have hc' : c ≠ p' := by
    rintro rfl
    exact hp' rfl
  have hcp : p ≠ c := by
    rintro rfl
    exact hp' (Set.mem_singleton c)
  have hpc : p ≠ p' := by
    rintro rfl
    exact hp' rfl
  rcases t.eq_degenerate_or_nondegenerate with (rfl | ⟨hne, hn⟩)
  · simp only [Set.range_singleton, Set.insert_eq_of_mem, Set.mem_singleton_iff] at ht
    have hs : s = {c, c} := by simpa [hc] using hc
    simp [hs, ht, hc', hcp, hpc]
  have hc : p ∈ s := by simpa [hc] using Set.mem_insert_of_mem c (Set.mem_singleton p)
  have hp's : p' ∈ s := by simpa [hc] using Set.mem_insert_of_mem c (Set.mem_singleton p')
  have hts : Set.range t.points ⊆ insert t.orthocenter (Set.range t.points) := by
    simp [hts]
  have hcs' : c ∈ insert t.orthocenter (Set.range t.points) := by simpa [hts] using hcs
  have hps : p ∈ insert t.orthocenter (Set.range t.points) := by simpa [hts] using hps
  have hp's' : p' ∈ insert t.orthocenter (Set.range t.points) := by simpa [hts] using hp's
  have hts' : Set.range t.points ⊆ s := ht
  have hcs'' : c ∈ s := by simpa [hts'] using hcs'
  have hps'' : p ∈ s := by simpa [hts'] using hps
  have hp's'' : p' ∈ s := by simpa [hts'] using hp's'
  have hsc : s = insert t.orthocenter

Attempt failure.

Working on Mathlib/Geometry/Manifold/BumpFunction.lean - 2024-09-09 01:49:03.629981.
---94/200---
For theorem SmoothBumpFunction.smooth_smul in Mathlib/Geometry/Manifold/BumpFunction.lean:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x 


Original valid proof:
:= by
  refine contMDiff_of_tsupport fun x hx => ?_
  have : x ∈ (chartAt H c).source :=
    f.tsupport_subset_chartAt_source <| tsupport_smul_subset_left _ _ hx
  exact f.smoothAt.smul ((hg _ this).contMDiffAt <| (chartAt _ _).open_source.mem_nhds this)


Verifying proof (Commit 71880da883b383ac13b9beb76b1bd41a0f023582):
↦
    (smooth_smul.comp (f.smooth.prod_mk hg)).congr (fun x hx => by simp [f.coe_fst', f.coe_snd', hx])
      fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr (fun x hx => by simp [f.coe_fst', f.coe_snd', hx])
    fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x :=
  (smooth_smul.comp (f.smooth.prod_mk hg)).congr fun x hx => by simp [f.coe_fst', f.coe_snd', hx]

Repaired Proof:
theorem smooth_smul

Attempt failure.

---95/200---
For theorem SmoothBumpFunction.image_eq_inter_preimage_of_subset_support in Mathlib/Geometry/Manifold/BumpFunction.lean:
theorem image_eq_inter_preimage_of_subset_support {s : Set M} (hs : s ⊆ support f) :
    extChartAt I c '' s =
      closedBall (extChartAt I c c) f.rOut ∩ range I ∩ (extChartAt I c).symm ⁻¹' s 


Original valid proof:
:= by
  rw [support_eq_inter_preimage, subset_inter_iff, ← extChartAt_source I, ← image_subset_iff] at hs
  cases' hs with hse hsf
  apply Subset.antisymm
  · refine subset_inter (subset_inter (hsf.trans ball_subset_closedBall) ?_) ?_
    · rintro _ ⟨x, -, rfl⟩; exact mem_range_self _
    · rw [(extChartAt I c).image_eq_target_inter_inv_preimage hse]
      exact inter_subset_right
  · refine Subset.trans (inter_subset_inter_left _ f.closedBall_subset) ?_
    rw [(extChartAt I c).image_eq_target_inter_inv_preimage hse]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∩
        (extChartAt I c).target := by
  ext x
  simp only [mem_image, mem_inter_iff, mem_range, mem_preimage, and_assoc, and_comm,
    and_left_comm, mem_closedBall, dist_eq_norm, I.norm_eq_of_mem_range]
  constructor
  · rintro ⟨y, hy, rfl⟩
    simp only [hs hy, true_and_iff, mem_preimage, mem_closedBall, mem_range,
      I.norm_eq_of_mem_range, dist_eq_norm, extChartAt_to_inv]
    exact ⟨f.rOut_pos, hy⟩
  · rintro ⟨⟨rfl, y, rfl⟩, hx⟩
    refine' ⟨extChartAt I c y, hx, _⟩
    simp only [hs hx, mem_preimage, mem_closedBall, mem_range, I.norm_eq_of_mem_range,
      dist_eq_norm, extChartAt_to_inv, eq_self_iff_true, and_self_iff]

Repaired Proof:
theorem image_eq_inter_preimage_of_subset_support {s : Set M} (hs : s ⊆ support f) :
    extChartAt I c '' s =
      closedBall (extChartAt I c c) f.rOut ∩ range I ∩ (extChartAt I c).symm ⁻¹' s ∩
        (extChartAt I c).target := by
  ext x
  simp only [mem_image, mem_inter_iff, mem_range, mem_preimage, and_assoc, and_comm,
    and_left_comm, mem_closedBall, dist_eq_norm, I.norm_eq_of_mem_range]
  constructor
  · rintro ⟨y, hy, rfl⟩
    simp only [hs hy, true_and_iff, mem_preimage, mem_closedBall, mem_range,
      I.norm_eq_of_mem_range, dist_eq_norm, extChartAt_to_inv]
    exact ⟨f.rOut_pos, hy⟩
  · rintro ⟨⟨rfl, y, rfl⟩, hx⟩
    refine ⟨extChartAt I c y, hx, ?_⟩
    simp only [hs hx, mem_preimage, mem_closedBall, mem_range, I.norm_eq_of_mem_range,
      dist_eq_norm, extChartAt_to_inv, eq_self_iff_true, and_self_iff]

Repaired Proof:
theorem image_eq_inter_preimage_of_subset_support {s : Set M} (hs : s ⊆ support f) :
    extChartAt I c '' s =
      closedBall (extChartAt I c c) f.rOut ∩ range I ∩ (extChartAt I c).symm ⁻¹' s ∩
        (extChartAt I c).target := by
  ext x
  simp only [mem_image, mem_inter_iff, mem_range, mem_preimage, and_assoc, and_comm,
    and_left_comm, mem_closedBall, dist_eq_norm, I.norm_eq_of_mem_range]
  constructor
  · rintro ⟨y, hy, rfl⟩
    simp only [hs hy, true_and_iff, mem_preimage, mem_closedBall, mem_range,
      I.norm_eq_of_mem_range, dist_eq_norm, extChartAt_to_inv]
    exact ⟨f.rOut_pos, hy⟩
  · rintro ⟨⟨rfl, y, rfl⟩, hx⟩
    refine ⟨extChartAt I c y, hx, ?_⟩
    simp only [hs hx, mem_preimage, mem_closedBall, mem_range, I.norm_eq_of_mem_range,
      dist_eq_norm, extChartAt_to_inv, eq_self_iff_true, and_self_iff]

Repaired Proof:
theorem image_eq_inter_preimage_of_subset_support {s : Set M} (hs : s ⊆ support f) :
    extChartAt I c '' s =
      closedBall (extChartAt I c c) f.rOut ∩ range I ∩ (extChartAt I c).symm ⁻¹' s ∩
        (extChartAt I c).target := by
  ext x
  simp only [mem_image, mem_inter_iff, mem_range, mem_preimage, and_assoc, and_comm,
    and_left_comm, mem_closedBall, dist_eq_norm, I.norm_eq_of_mem_range]
  constructor
  · rintro ⟨y, hy, rfl⟩
    simp only [hs hy, true_and_iff, mem_preimage, mem_closedBall, mem_range,
      I.norm_eq_of_mem_range, dist_eq_norm, extChartAt_to_inv]
    exact ⟨f.rOut_pos, hy⟩
  · rintro ⟨⟨rfl, y, rfl⟩, hx⟩
    refine ⟨extChartAt I c y, hx, ?_⟩
    simp only [hs hx, mem_preimage, mem_closedBall, mem_range, I.norm_eq_of_mem_range,
      dist_eq_norm, extChartAt_to_inv, eq_self_iff_true, and_self_iff]

Repaired Proof:
theorem image_eq_inter_preimage_of_subset_support {s : Set M} (hs : s ⊆ support f) :
    extChartAt I c '' s =
      closedBall (extChartAt I c c) f.rOut ∩ range I ∩ (extChartAt I c).symm ⁻¹' s ∩
        (extChartAt I c).target := by
  ext x
  simp only [mem_image, mem_inter_iff, mem_range, mem_preimage, and_assoc, and_comm,
    and_left_comm, mem_closedBall, dist_eq_norm, I.norm_eq_of_mem_range]
  constructor
  · rintro ⟨y, hy, rfl⟩
    simp only [hs hy, true_and_iff, mem_preimage, mem_closedBall, mem_range,
      I.norm_eq_of_mem_range, dist_eq_norm, extChartAt_to_inv]
    exact ⟨f.rOut_pos, hy⟩
  · rintro ⟨⟨rfl, y, rfl⟩, hx⟩
    refine ⟨extChartAt I c y, hx, ?_⟩
    simp only [hs hx, mem_preimage, mem_closedBall, mem_range, I.norm_eq_of_mem_range,
      dist_eq_norm, extChartAt_to_inv, eq_self_iff_true, and_self_iff]

Repaired Proof:
theorem image_eq_inter_preimage_of_subset_support {s : Set M} (hs : s ⊆ support f) :
    extChartAt I c '' s =
      closedBall (extChartAt I c c) f.rOut ∩ range I ∩ (extChartAt I c).symm ⁻¹' s ∩
        (extChartAt I c).target := by
  ext x
  simp only [mem_image, mem_inter_iff, mem_range, mem_preimage, and_assoc, and_comm,
    and_left_comm, mem_closedBall, dist_eq_norm, I.norm_eq_of_mem_range]
  constructor
  · rintro ⟨y, hy, rfl⟩
    simp only [hs hy, true_and_iff, mem_preimage, mem_closedBall, mem_range,
      I.norm_eq_of_mem_range, dist_eq_norm, extChartAt_to_inv]
    exact ⟨f.rOut_pos, hy⟩
  · rintro ⟨⟨rfl, y, rfl⟩, hx⟩
    refine ⟨extChartAt I c y, hx, ?_⟩
    simp only [hs hx, mem_preimage, mem_closedBall, mem_range,

Attempt failure.

Working on Mathlib/Geometry/Manifold/ContMDiff/Basic.lean - 2024-09-09 01:49:28.014211.
---96/200---
For theorem ContMDiffWithinAt.comp in Mathlib/Geometry/Manifold/ContMDiff/Basic.lean:
theorem ContMDiffWithinAt.comp {t : Set M'} {g : M' → M''} (x : M)
    (hg : ContMDiffWithinAt I' I'' n g t (f x)) (hf : ContMDiffWithinAt I I' n f s x)
    (st : MapsTo f s t) : ContMDiffWithinAt I I'' n (g ∘ f) s x 


Original valid proof:
:= by
  rw [contMDiffWithinAt_iff] at hg hf ⊢
  refine ⟨hg.1.comp hf.1 st, ?_⟩
  set e := extChartAt I x
  set e' := extChartAt I' (f x)
  have : e' (f x) = (writtenInExtChartAt I I' x f) (e x) := by simp only [e, e', mfld_simps]
  rw [this] at hg
  have A : ∀ᶠ y in 𝓝[e.symm ⁻¹' s ∩ range I] e x, f (e.symm y) ∈ t ∧ f (e.symm y) ∈ e'.source := by
    simp only [e, ← map_extChartAt_nhdsWithin, eventually_map]
    filter_upwards [hf.1.tendsto (extChartAt_source_mem_nhds I' (f x)),
      inter_mem_nhdsWithin s (extChartAt_source_mem_nhds I x)]
    rintro x' (hfx' : f x' ∈ e'.source) ⟨hx's, hx'⟩
    simp only [e.map_source hx', true_and_iff, e.left_inv hx', st hx's, *]
  refine ((hg.2.comp _ (hf.2.mono inter_subset_right) inter_subset_left).mono_of_mem
    (inter_mem ?_ self_mem_nhdsWithin)).congr_of_eventuallyEq ?_ ?_
  · filter_upwards [A]
    rintro x' ⟨ht, hfx'⟩
    simp only [*, mem_preimage, writtenInExtChartAt, (· ∘ ·), mem_inter_iff, e'.left_inv,
      true_and_iff]
    exact mem_range_self _
  · filter_upwards [A]
    rintro x' ⟨-, hfx'⟩
    simp only [*, (· ∘ ·), writtenInExtChartAt, e'.left_inv]
  · simp only [e, e', writtenInExtChartAt, (· ∘ ·), mem_extChartAt_source, e.left_inv, e'.left_inv]


Verifying proof (Commit 7ed7ed5693428ce8707e770581caaf86da193e99):
 := by
  rw [contMDiffWithinAt_iff] at *
  rw [← st.image_eq] at hg
  exact ⟨hg.1.comp hf.1 st, hg.2.comp hf.2 st⟩

theorem ContMDiffAt.comp_contMDiffWithinAt {g : M' → M''} (x : M)
    (hg : ContMDiffAt I' I'' n g (f x)) (hf : ContMDiffWithinAt I I' n f s x) :
    ContMDiffWithinAt I I'' n (g ∘ f) s x :=
  hg.contMDiffWithinAt.comp x hf (mapsTo_univ _ _)


theorem ContMDiffOn.comp' {t : Set M'} {g : M' → M''} {u : Set M} (hg : ContMDiffOn I' I'' n g t)
    (hf : ContMDiffOn I I' n f u) (st : MapsTo f u t) : ContMDiffOn I I'' n (g ∘ f) u :=
  (hg.comp_contMDiffWithinAt st).comp hf


theorem ContMDiffOn.comp {t : Set M'} {g : M' → M''} {u : Set M} (hg : ContMDiffOn I' I'' n g t)
    (hf : ContMDiffOn I I' n f u) (st : Set.MapsTo f u t) : ContMDiffOn I I'' n (g ∘ f) u :=
  comp' hg hf st


theorem ContMDiff.comp_contMDiffWithinAt {g : M' → M''} (x : M)
    (hg : ContMDiff I' I'' n g) (hf : ContMDiffWithinAt I I' n f s x) :
    ContMDiffWithinAt I I'' n (g ∘ f) s x :=
  hg.contMDiffAt.comp_contMDiffWithinAt hf


theorem ContMDiff.comp_contMDiffAt {g : M' → M''} (x : M) (hg : ContMDiff I' I'' n g)
    (hf : ContMDiffAt I I' n f x) : ContMDiffAt I I'' n (g ∘ f) x :=
  hg.comp_contMDiffWithinAt hf


theorem ContMDiff.comp_contMDiffOn {g : M' → M''} {u : Set M} (hg : ContMDiff I' I'' n g)
    (hf : ContMDiffOn I I' n f u) : ContMDiffOn I I'' n (g ∘ f) u :=
  hg.comp_contMDiffWithinAt hf


theorem ContMDiff.comp {g : M' → M''} (hg : ContMDiff I' I'' n g) (hf : ContMDiff I I' n f) :
    ContMDiff I I'' n (g ∘ f) :=
  contMDiffOn_univ.mp <| hg.comp_contMDiffOn hf.contMDiffOn


theorem ContMDiffWithinAt.iterate {g : M → M} (hg : ContMDiffWithinAt I I n g s x₀)
    (h : MapsTo g s s) (hx₀ : g x₀ ∈ s) (hg' : ContDiffWithinAt 𝕜 n (fun x => x) s x₀) :
    ContMDiffWithinAt I I n (g^[m] : M → M) s x₀ := by
  induction m generalizing x₀ with
  | zero => exact contMDiffWithinAt_id
  | succ m IH =>
    rw [Function.iterate_succ']
    rw [contMDiffWithinAt_iff] at hg ⊢
    exact ⟨hg.1.iterate h hx₀, hg.2.iterate h hx₀ hg'⟩

theorem ContMDiffAt.iterate {g : M → M} (hg : ContMDiffAt I I n g x₀)
    (hg' : ContDiffAt 𝕜 n (fun x => x) x₀) : ContMDiffAt I I n (g^[m] : M → M) x₀ := by
  simp only [← contMDiffWithinAt_univ] at hg hg' ⊢
  exact hg.iterate (mapsTo_univ _ _) hg'

theorem ContMDiffOn.iterate {g : M → M} (hg : ContMDiffOn I I n g s)
    (hg' : ContDiffOn 𝕜 n (fun x => x) s) (hs : MapsTo g s s) :
    ContMDiffOn I I n (g^[m] : M → M) s := fun x hx ↦
  (hg x hx).iterate hs hx (hg' x hx)

theorem ContMDiff.iterate {g : M → M} (hg : ContMDiff I I n g) (hg' : ContDiff I n (fun x => x)) :
    ContMDiff I I n (g^[m] : M → M) :=
  contMDiffOn_univ.mp <| hg.contMDiffOn.iterate (contDiffOn_univ.mpr hg') mapsTo_univ


theorem ContMDiffWithinAt.comp_contMDiffAt {g : M' → M''} (x : M)
    (hg : ContMDiffWithinAt I' I'' n g t (f x)) (hf : ContMDiffAt I I' n f x) :
    ContMDiffAt I I'' n (g ∘ f) x := by
  rcases hf.contMDiffWithinAt with ⟨s, s_mem, hs⟩
  exact (hg.comp x (s_mem.union t) (Set.mapsTo_union_left s t f x)).mono_of_mem (s_mem.union t)


theorem ContMDiffAt.comp_contMDiffWithinAt {g : M' → M''} (x : M)
    (hg : ContMDiffAt I' I'' n g (f x)) (hf : ContMDiffWithinAt I I' n f s x) :
    ContMDiffWithinAt I I'' n (g ∘ f) s x :=
  hg.comp_contMDiffAt x hf


theorem ContMDiff.comp_contMDiffWithinAt {g : M' → M''} (x : M)
    (hg : ContMDiff I' I'' n g) (hf : ContMDiffWithinAt I I' n f s x) :
    ContMDiffWithinAt I I'' n (g ∘ f) s x :=
  hg.contMDiffAt.comp_contMDiffWithinAt x hf


theorem ContMDiff.comp_contMDiffAt {g : M' → M''} (x : M) (hg : ContMDiff I' I'' n g)
    (hf : ContMDiffAt I I' n f x) : ContMDiffAt I I'' n (g ∘ f) x :=
  hg.comp_contMDiffWithinAt x hf


theorem ContMDiff.comp_contMDiffOn {g : M' → M''} {u : Set M} (hg : ContMDiff I' I'' n g)
    (hf : ContMDiffOn I I' n f u) : ContMDiffOn I I'' n (g ∘ f) u :=
  hg.comp_contMDiffWithinAt hf


theorem ContMDiffOn.comp {t : Set M'} {g : M' → M''} {u : Set M} (hg : ContMDiffOn I' I'' n g t)
    (hf : ContMDiffOn I I' n f u) (st : Set.MapsTo f u t) : ContMDiffOn I I'' n (g ∘ f) u :=
  ContMDiffOn.comp' hg hf st


theorem ContMDiffOn.comp' {t : Set M'} {g : M' → M''} {u : Set M} (hg : ContMDiffOn I' I'' n g t)
    (hf : ContMDiffOn I I' n f u) : ContMDiffOn I I'' n (g ∘ f) (u ∩ f ⁻¹' t) := by
  intro x hx
  apply (hg (f x) _).comp x
  · exact hf x hx.1
  · simpa only [hx, mfld_simps]


theorem ContMDiffOn.comp' {t : Set M'} {g : M' → M''} {u : Set M} (hg : ContMDiffOn I' I'' n g t)
    (hf : ContMDiffOn I I' n f u) : ContMDiffOn I I'' n (g ∘ f) (u ∩ f ⁻¹' t

Attempt failure.

Working on Mathlib/Geometry/Manifold/ContMDiff/Defs.lean - 2024-09-09 01:49:38.871152.
---97/200---
For theorem contMDiffWithinAt_iff_contMDiffOn_nhds in Mathlib/Geometry/Manifold/ContMDiff/Defs.lean:
theorem contMDiffWithinAt_iff_contMDiffOn_nhds {n : ℕ} :
    ContMDiffWithinAt I I' n f s x ↔ ∃ u ∈ 𝓝[insert x s] x, ContMDiffOn I I' n f u 


Original valid proof:
:= by
  wlog hxs : x ∈ s generalizing s
  · rw [← contMDiffWithinAt_insert_self, this (mem_insert _ _), insert_idem]
  rw [insert_eq_of_mem hxs]
  refine ⟨fun h ↦ ?_, fun ⟨u, hmem, hu⟩ ↦ (hu _ (mem_of_mem_nhdsWithin hxs hmem)).mono_of_mem hmem⟩
  rcases (contMDiffWithinAt_iff'.1 h).2.contDiffOn le_rfl with ⟨v, hmem, hsub, hv⟩
  have hxs' : extChartAt I x x ∈ (extChartAt I x).target ∩
      (extChartAt I x).symm ⁻¹' (s ∩ f ⁻¹' (extChartAt I' (f x)).source) :=
    ⟨(extChartAt I x).map_source (mem_extChartAt_source _ _), by rwa [extChartAt_to_inv], by
      rw [extChartAt_to_inv]; apply mem_extChartAt_source⟩
  rw [insert_eq_of_mem hxs'] at hmem hsub
  refine ⟨(extChartAt I x).symm '' v, ?_, ?_⟩
  · rw [← map_extChartAt_symm_nhdsWithin I,
      h.1.nhdsWithin_extChartAt_symm_preimage_inter_range I I']
    exact image_mem_map hmem
  · have hv₁ : (extChartAt I x).symm '' v ⊆ (extChartAt I x).source :=
      image_subset_iff.2 fun y hy ↦ (extChartAt I x).map_target (hsub hy).1
    have hv₂ : MapsTo f ((extChartAt I x).symm '' v) (extChartAt I' (f x)).source := by
      rintro _ ⟨y, hy, rfl⟩
      exact (hsub hy).2.2
    rwa [contMDiffOn_iff_of_subset_source' hv₁ hv₂, PartialEquiv.image_symm_image_of_subset_target]
    exact hsub.trans inter_subset_left


Verifying proof (Commit 2ea14b79e1f7e6978b1265a8d41f7a305925875c):
∧ Set.insert x s ⊆ u :=
  contMDiffWithinAt_iff_contMDiffOn_insert.trans <|
    Iff.intro
      (fun ⟨u, hu, h⟩ =>
        ⟨u, Filter.mem_of_superset hu (Set.diff_subset _ _), h, (Set.diff_union_self _ _).symm.subset⟩)
      fun ⟨u, hu, h, hs⟩ =>
      ⟨u \ {x}, Filter.mem_of_superset hu (Set.inter_subset_left _ _), h.mono (Set.inter_subset_right _ _),
        Set.insert_subset_iff.2 ⟨Set.mem_diff_singleton.2 ⟨Set.mem_insert _ _, not_mem_singleton _⟩, hs⟩⟩


theorem ContMDiffWithinAt.contMDiffOn {m : ℕ} (h : ContMDiffWithinAt I I' m f s x) :
    ∃ u ∈ 𝓝[insert x s] x, ContMDiffOn I I' m f u := by
  rcases h with ⟨e, he, e_mdiff⟩
  rcases mem_nhdsWithin.mp he with ⟨u, u_open, xu, hu⟩
  exact
    ⟨u ∩ e.source, Filter.inter_mem_sets u_open he,
      e_mdiff.mono_of_mem hu inter_subset_right⟩


theorem ContMDiffAt.contMDiffOn {m : ℕ} (h : ContMDiffAt I I' m f x) :
    ∃ u ∈ 𝓝 x, ContMDiffOn I I' m f u :=
  let ⟨u, hu, h⟩ := contMDiffWithinAt_iff_contMDiffOn_nhds.1 h
  ⟨u, hu, h⟩


theorem ContMDiffOn.contMDiffAt {m : ℕ} (h : ContMDiffOn I I' m f s) (hx : s ∈ 𝓝 x) :
    ContMDiffAt I I' m f x :=
  (h x (mem_of_mem_nhds hx)).contMDiffWithinAt.mono_of_mem hx


theorem ContMDiffOn.of_le (h : ContMDiffOn I I' n f s) (hmn : m ≤ n) : ContMDiffOn I I' m f s :=
  fun x hx => (h x hx).of_le hmn


theorem ContMDiffOn.of_succ {n : ℕ} (h : ContMDiffOn I I' n.succ f s) : ContMDiffOn I I' n f s :=
  h.of_le <| WithTop.coe_le_coe.mpr le_self_add


theorem ContMDiffOn.of_nat {n : ℕ} (h : ContMDiffOn I I' n f s) : ContMDiffOn I I' m f s :=
  h.of_le <| WithTop.coe_le_coe.mpr <| Nat.le_of_lt_succ <| WithTop.coe_lt_coe.mp <| Nat.lt_succ_self n


theorem ContMDiffOn.of_le_of_eq {m n : ℕ} (hmn : m ≤ n) (hf : ContMDiffOn I I' n f s)
    (hg : ∀ x ∈ s, f x = g x) : ContMDiffOn I I' m g s :=
  (hf.of_le hmn).congr hg


theorem ContMDiffOn.congr_mono (h : ContMDiffOn I I' n f s) (h₁ : ∀ y ∈ s₁, f₁ y = f y)
    (hs : s₁ ⊆ s) : ContMDiffOn I I' n f₁ s₁ :=
  (h.mono hs).congr h₁


theorem ContMDiffOn.congr (h : ContMDiffOn I I' n f s) (h₁ : ∀ y ∈ s, f₁ y = f y) :
    ContMDiffOn I I' n f₁ s :=
  ContMDiffOn.congr_mono h h₁ (Subset.refl _)


theorem ContMDiffOn.congr_of_eventuallyEq (h : ContMDiffOn I I' n f s) (h₁ : f₁ =ᶠ[𝓝ˢ s] f) :
    ContMDiffOn I I' n f₁ s :=
  h.congr_mono h₁.symm (Subset.refl _)


theorem ContMDiffOn.congr_of_eventuallyEq_insert (h : ContMDiffOn I I' n f s)
    (h₁ : f₁ =ᶠ[𝓝[insert x s] x] f) : ContMDiffOn I I' n f₁ s :=
  h.congr_mono h₁ (Subset.refl _)


theorem ContMDiffOn.congr_of_eventuallyEq_insert' (h : ContMDiffOn I I' n f s)
    (h₁ : f₁ =ᶠ[𝓝[s] x] f) : ContMDiffOn I I' n f₁ s :=
  h.congr_of_eventuallyEq_insert (mem_nhdsWithin_of_mem_nhds h₁)


theorem ContMDiffOn.congr_iff_eventuallyEq (h : ContMDiffOn I I' n f s) :
    ContMDiffOn I I' n f₁ s ↔ f₁ =ᶠ[𝓝ˢ s] f :=
  ⟨fun h' ↦ h'.congr_of_eventuallyEq (Filter.eventuallyEq_of_mem self_mem_nhdsSet h'),
    fun h' ↦ h.congr_of_eventuallyEq h'⟩


theorem ContMDiffOn.congr_iff_eventuallyEq_insert (h : ContMDiffOn I I' n f s) :
    ContMDiffOn I I' n f₁ s ↔ f₁ =ᶠ[𝓝[insert x s] x] f :=
  ⟨fun h' ↦ h'.congr_of_eventuallyEq_insert (mem_nhdsWithin_of_mem_nhds (mem_nhds_sets isOpen_univ
    (mem_univ x))),
    fun h' ↦ h.congr_of_eventuallyEq_insert h'⟩


theorem ContMDiffOn.congr_iff_eventuallyEq_insert' (h : ContMDiffOn I I' n f s) :
    ContMDiffOn I I' n f₁ s ↔ f₁ =ᶠ[𝓝[s] x] f :=
  ⟨fun h' ↦ h'.congr_of_eventuallyEq_insert (mem_nhdsWithin_of_mem_nhds (mem_nhds_sets isOpen_univ
    (mem_univ x))),
    fun h' ↦ h.congr_of_eventuallyEq_insert h'⟩


theorem ContMDiffOn.congr_iff_eventuallyEq' (h : ContMDiffOn I I' n f s) :
    ContMDiffOn I I' n f₁ s ↔ f₁ =ᶠ[𝓝[s] x] f :=
  ⟨fun h' ↦ h'.congr_of_eventuallyEq_insert (mem_nhdsWithin_of_mem_nhds (mem_nhds_sets isOpen_univ
    (mem_univ x))),
    fun h' ↦ h.congr_of_eventuallyEq_insert h'⟩


theorem ContMDiffOn.congr_iff_eventuallyEq_insert' (h : ContMDiffOn I I' n f s) :
    ContMDiffOn I I' n f₁ s ↔ f₁ =ᶠ[𝓝[insert x s] x] f :=
  ⟨fun h' ↦ h'.congr_of_eventuallyEq_insert (mem_nhdsWithin_of_mem_nhds (mem_nhds_sets isOpen_univ
    (mem_univ x))),
    fun h' ↦ h.congr_of_eventuallyEq_insert h'⟩


theorem ContMDiffOn.congr_iff_eventuallyEq' (h : ContMDiffOn I I' n f s) :
    ContMDiffOn I I' n f₁ s ↔ f₁ =ᶠ

Attempt failure.

Working on Mathlib/Geometry/Manifold/IntegralCurve.lean - 2024-09-09 01:49:52.978715.
---98/200---
For theorem isIntegralCurveOn_Ioo_eqOn_of_contMDiff in Mathlib/Geometry/Manifold/IntegralCurve.lean:
theorem isIntegralCurveOn_Ioo_eqOn_of_contMDiff (ht₀ : t₀ ∈ Ioo a b)
    (hγt : ∀ t ∈ Ioo a b, I.IsInteriorPoint (γ t))
    (hv : ContMDiff I I.tangent 1 (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)))
    (hγ : IsIntegralCurveOn γ v (Ioo a b)) (hγ' : IsIntegralCurveOn γ' v (Ioo a b))
    (h : γ t₀ = γ' t₀) : EqOn γ γ' (Ioo a b) 


Original valid proof:
:= by
  set s := {t | γ t = γ' t} ∩ Ioo a b with hs
  suffices hsub : Ioo a b ⊆ s from fun t ht ↦ mem_setOf.mp ((subset_def ▸ hsub) t ht).1
  apply isPreconnected_Ioo.subset_of_closure_inter_subset (s := Ioo a b) (u := s) _
    ⟨t₀, ⟨ht₀, ⟨h, ht₀⟩⟩⟩
  · 
    rw [hs, inter_comm, ← Subtype.image_preimage_val, inter_comm, ← Subtype.image_preimage_val,
      image_subset_image_iff Subtype.val_injective, preimage_setOf_eq]
    intros t ht
    rw [mem_preimage, ← closure_subtype] at ht
    revert ht t
    apply IsClosed.closure_subset (isClosed_eq _ _)
    · rw [continuous_iff_continuousAt]
      rintro ⟨_, ht⟩
      apply ContinuousAt.comp _ continuousAt_subtype_val
      rw [Subtype.coe_mk]
      exact hγ.continuousAt ht
    · rw [continuous_iff_continuousAt]
      rintro ⟨_, ht⟩
      apply ContinuousAt.comp _ continuousAt_subtype_val
      rw [Subtype.coe_mk]
      exact hγ'.continuousAt ht
  · rw [isOpen_iff_mem_nhds]
    intro t₁ ht₁
    have hmem := Ioo_mem_nhds ht₁.2.1 ht₁.2.2
    have heq : γ =ᶠ[𝓝 t₁] γ' := isIntegralCurveAt_eventuallyEq_of_contMDiffAt
      (hγt _ ht₁.2) hv.contMDiffAt (hγ.isIntegralCurveAt hmem) (hγ'.isIntegralCurveAt hmem) ht₁.1
    apply (heq.and hmem).mono
    exact fun _ ht ↦ ht


Verifying proof (Commit 5b2e142323b7a721e3ae2adce3b172f93a82f823):
∪ {a, b} := by
  have hv' : ∀ t ∈ Ioo a b, I.IsInteriorPoint (v t) := fun t ht ↦
    (hγt t ht).proj (γ t) (hγ.snd t ht)
  suffices H : EqOn γ γ' (Ioo a b) ∪ {a, b} from
    subset_union_left _ _ ▸ subset_union_right _ _ ▸ H
  have hγt' : ∀ t ∈ Ioo a b, I.IsInteriorPoint (γ t) := fun t ht ↦
    (hγt t ht).proj (γ t) (hγ.snd t ht)
  have hγ't' : ∀ t ∈ Ioo a b, I.IsInteriorPoint (γ' t) := fun t ht ↦
    (hγt t ht).proj (γ' t) (hγ'.snd t ht)
  have hγt_int : ∀ t ∈ Ioo a b, IntegrableOn (fun t ↦ v t) (Ioc a t) :=
    fun t ht ↦ (hγ.fderiv.integrableOn_isInteriorPoint (Ioo_mem_nhds ht₀.1 ht₀.2) ht₀
      (hγt t ht) (hγt' t ht)).mono_set Ioc_subset_Icc_self le_rfl
  have hγ't_int : ∀ t ∈ Ioo a b, IntegrableOn (fun t ↦ v t) (Ioc a t) :=
    fun t ht ↦ (hγ'.fderiv.integrableOn_isInteriorPoint (Ioo_mem_nhds ht₀.1 ht₀.2) ht₀
      (hγ't' t ht) (hv'.mono Ioo_subset_Icc_self)).mono_set Ioc_subset_Icc_self le_rfl
  have hv_int : ∀ t ∈ Ioo a b, IntegrableOn (fun t ↦ (1 : ℝ≥0∞) • (v t).norm) (Ioc a t) :=
    fun t ht ↦ (hv.integrableOn_isInteriorPoint (Ioo_mem_nhds ht₀.1 ht₀.2) ht₀
      (hv' t ht)).mono_set Ioc_subset_Icc_self le_rfl
  have hv'_int : ∀ t ∈ Ioo a b, IntegrableOn (fun t ↦ (1 : ℝ≥0∞) • (v' t).norm) (Ioc a t) :=
    fun t ht ↦ (hv.integrableOn_isInteriorPoint (Ioo_mem_nhds ht₀.1 ht₀.2) ht₀
      (hv' t ht)).mono_set Ioc_subset_Icc_self le_rfl
  have hγt_int' : ∀ t ∈ Ioo a b, IntegrableOn (fun t ↦ fderivWithin 𝓘 (I.tangent I)
    (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)) (I.tangent I.source) t) (Ioc a t) :=
    fun t ht ↦ (hγ.fderiv.integrableOn_isInteriorPoint (Ioo_mem_nhds ht₀.1 ht₀.2) ht₀
      (hγt t ht) (hγt' t ht)).mono_set Ioc_subset_Icc_self le_rfl
  have hγ't_int' : ∀ t ∈ Ioo a b, IntegrableOn (fun t ↦ fderivWithin 𝓘 (I.tangent I)
    (fun x ↦ (⟨x, v' x⟩ : TangentBundle I M)) (I.tangent I.source) t) (Ioc a t) :=
    fun t ht ↦ (hγ'.fderiv.integrableOn_isInteriorPoint (Ioo_mem_nhds ht₀.1 ht₀.2) ht₀
      (hγ't' t ht) (hv'.mono Ioo_subset_Icc_self)).mono_set Ioc_subset_Icc_self le_rfl
  have hγt_int'' : ∀ t ∈ Ioo a b, IntegrableOn (fun t ↦ (v t).comp' (fderivWithin 𝓘
    (I.tangent I) (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)) (I.tangent I.source) t)) (Ioc a t) :=
    fun t ht ↦ (hγ.fderiv.integrableOn_isInteriorPoint (Ioo_mem_nhds ht₀.1 ht₀.2) ht₀
      (hγt t ht) (hγt' t ht)).mono_set Ioc_subset_Icc_self le_rfl
  have hγ't_int'' : ∀ t ∈ Ioo a b, IntegrableOn (fun t ↦ (v' t).comp' (fderivWithin 𝓘
    (I.tangent I) (fun x ↦ (⟨x, v' x⟩ : TangentBundle I M)) (I.tangent I.source) t)) (Ioc a t) :=
    fun t ht ↦ (hγ'.fderiv.integrableOn_isInteriorPoint (Ioo_mem_nhds ht₀.1 ht₀.2) ht₀
      (hγ't' t ht) (hv'.mono Ioo_subset_Icc_self)).mono_set Ioc_subset_Icc_self le_rfl
  have hγt_int''' : ∀ t ∈ Ioo a b, IntegrableOn (fun t ↦ ((v t).comp'
    (fderivWithin 𝓘 (I.tangent I) (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)
    (I.tangent I.source) t) + (v' t).comp' (fderivWithin 𝓘 (I.tangent I)
    (fun x ↦ (⟨x, v x⟩ : TangentBundle I M) (I.tangent I.source) t))) (1 : ℝ≥0∞)) (Ioc a t) :=
    fun t ht ↦ (hγ.fderiv.integrableOn_isInteriorPoint (Ioo_mem_nhds ht₀.1 ht₀.2) ht₀
      (hγt t ht) (hγt' t ht)).mono_set Ioc_subset_Icc_self le_rfl
  have hγ't_int''' : ∀ t ∈ Ioo a b, IntegrableOn (fun t ↦ ((v' t).comp'
    (fderivWithin 𝓘 (I.tangent I) (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)
    (I.tangent I.source) t) + (v' t).comp' (fderivWithin 𝓘 (I.tangent I)
    (fun x ↦ (⟨x, v x⟩ : TangentBundle I M) (I.tangent I.source) t))) (1 : ℝ≥0∞)) (Ioc a t) :=
    fun t ht ↦ (hγ'.fderiv.integrableOn_isInteriorPoint (Ioo_mem_nhds ht₀.1 ht₀.2) ht₀
      (hγ't' t ht) (hv'.mono Ioo_subset_Icc_self)).mono_set Ioc_subset_Icc_self le_rfl
  have hγt_int'''' : ∀ t ∈ Ioo a b, IntegrableOn (fun t ↦ ((v t).comp'
    (fderivWithin 𝓘 (I.tangent I) (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)
    (I.tangent I.source) t) + (v' t).comp' (fderivWithin 𝓘 (I.tangent I)
    (fun x ↦ (⟨x, v x⟩ : TangentBundle I M) (I.tangent I.source) t))) (1 : ℝ≥0∞)) (Ioc a t) :=
    fun t ht ↦ (hγ.fderiv.integrableOn_isInteriorPoint (Ioo_mem_nhds ht₀.1 ht₀.2) ht₀
      (hγt t ht) (hγt' t ht)).mono_set Ioc_subset_Icc_self le_rfl
  have hγ't_int'''' : ∀ t

Attempt failure.

Working on Mathlib/Geometry/Manifold/Metrizable.lean - 2024-09-09 01:50:09.990485.
---99/200---
For theorem ManifoldWithCorners.metrizableSpace in Mathlib/Geometry/Manifold/Metrizable.lean:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M 


Original valid proof:
:= by
  haveI := I.locallyCompactSpace; haveI := ChartedSpace.locallyCompactSpace H M
  haveI := I.secondCountableTopology
  haveI := ChartedSpace.secondCountable_of_sigma_compact H M
  exact metrizableSpace_of_t3_second_countable M


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
↔ I.Boundaryless := by
  constructor
  · intro
    exact I.boundaryless_of_metrizableSpace
  · intro
    haveI : I.Boundaryless := ‹I.Boundaryless›
    haveI : MetrizableSpace H := I.model.toMetrizableSpace
    haveI : SigmaCompactSpace H := I.model.sigmaCompactSpace
    haveI : MetrizableSpace M := ChartedSpace.metrizableSpace H M
    exact ‹MetrizableSpace M›

Repaired Proof:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ↔ I.Boundaryless := by
  constructor
  · intro
    exact I.boundaryless_of_metrizableSpace
  · intro
    haveI : I.Boundaryless := ‹I.Boundaryless›
    haveI : MetrizableSpace H := I.model.toMetrizableSpace
    haveI : SigmaCompactSpace H := I.model.sigmaCompactSpace
    haveI : MetrizableSpace M := ChartedSpace.metrizableSpace H M
    exact ‹MetrizableSpace M›

Repaired Proof:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ↔ I.Boundaryless := by
  constructor
  · intro
    exact I.boundaryless_of_metrizableSpace
  · intro
    haveI : I.Boundaryless := ‹I.Boundaryless›
    haveI : MetrizableSpace H := I.model.toMetrizableSpace
    haveI : SigmaCompactSpace H := I.model.sigmaCompactSpace
    haveI : MetrizableSpace M := ChartedSpace.metrizableSpace H M
    exact ‹MetrizableSpace M›

Repaired Proof:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ↔ I.Boundaryless := by
  constructor
  · intro
    exact I.boundaryless_of_metrizableSpace
  · intro
    haveI : I.Boundaryless := ‹I.Boundaryless›
    haveI : MetrizableSpace H := I.model.toMetrizableSpace
    haveI : SigmaCompactSpace H := I.model.sigmaCompactSpace
    haveI : MetrizableSpace M := ChartedSpace.metrizableSpace H M
    exact ‹MetrizableSpace M›

Repaired Proof:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ↔ I.Boundaryless := by
  constructor
  · intro
    exact I.boundaryless_of_metrizableSpace
  · intro
    haveI : I.Boundaryless := ‹I.Boundaryless›
    haveI : MetrizableSpace H := I.model.toMetrizableSpace
    haveI : SigmaCompactSpace H := I.model.sigmaCompactSpace
    haveI : MetrizableSpace M := ChartedSpace.metrizableSpace H M
    exact ‹MetrizableSpace M›

Repaired Proof:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ↔ I.Boundaryless := by
  constructor
  · intro
    exact I.boundaryless_of_metrizableSpace
  · intro
    haveI : I.Boundaryless := ‹I.Boundaryless›
    haveI : MetrizableSpace H := I.model.toMetrizableSpace
    haveI : SigmaCompactSpace H := I.model.sigmaCompactSpace
    haveI : MetrizableSpace M := ChartedSpace.metrizableSpace H M
    exact ‹MetrizableSpace M›

Repaired Proof:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ↔ I.Boundaryless := by
  constructor
  · intro
    exact I.boundaryless_of_metrizableSpace
  · intro
    haveI : I.Boundaryless := ‹I.Boundaryless›
    haveI : MetrizableSpace H := I.model.toMetrizableSpace
    haveI : SigmaCompactSpace H := I.model.sigmaCompactSpace
    haveI : MetrizableSpace M := ChartedSpace.metrizableSpace H M
    exact ‹MetrizableSpace M›

Repaired Proof:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ↔ I.Boundaryless := by
  constructor
  · intro
    exact I.boundaryless_of_metrizableSpace
  · intro
    haveI : I.Boundaryless := ‹I.Boundaryless›
    haveI : MetrizableSpace H := I.model.toMetrizableSpace
    haveI : SigmaCompactSpace H := I.model.sigmaCompactSpace
    haveI : MetrizableSpace M := ChartedSpace.metrizableSpace H M
    exact ‹MetrizableSpace M›

Repaired Proof:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ↔ I.Boundaryless := by
  constructor
  · intro
    exact I.boundaryless_of_metrizableSpace
  · intro
    haveI : I.Boundaryless := ‹I.Boundaryless›
    haveI : MetrizableSpace H := I.model.toMetrizableSpace
    haveI : SigmaCompactSpace H := I.model.sigmaCompactSpace
    haveI : MetrizableSpace M := ChartedSpace.metrizableSpace H M
    exact ‹MetrizableSpace M›

Repaired Proof:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ↔ I.Boundaryless := by
  constructor
  · intro
    exact I.boundaryless_of_metrizableSpace
  · intro
    haveI : I

Attempt failure.

Working on Mathlib/Geometry/Manifold/VectorBundle/Basic.lean - 2024-09-09 01:50:18.965138.
---100/200---
For theorem Bundle.contMDiffWithinAt_totalSpace in Mathlib/Geometry/Manifold/VectorBundle/Basic.lean:
theorem contMDiffWithinAt_totalSpace (f : M → TotalSpace F E) {s : Set M} {x₀ : M} :
    ContMDiffWithinAt IM (IB.prod 𝓘(𝕜, F)) n f s x₀ ↔
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s x₀ ∧
      ContMDiffWithinAt IM 𝓘(𝕜, F) n (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).2) s x₀ 


Original valid proof:
:= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ← FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,
    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, ← chartedSpaceSelf_prod]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ⁻¹' (trivializationAt F E (f x₀).proj).baseSet ∈ 𝓝[s] x₀ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  · simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  · simp only [mfld_simps]


Verifying proof (Commit 2c616cf6d72eab2cc0cb8be21b40be572f4b56bf):
∧
      EqOn (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).1) Prod.fst s := by
  simp only [contMDiffWithinAt_iff, extChartAt_totalSpace, PartialEquiv.prod_coe,
    PartialEquiv.refl_coe, PartialEquiv.prod_coe_symm, PartialEquiv.refl_coe_symm,
    (extChartAt IM (TotalSpace F E) x₀).right_inv', (extChartAt IM (TotalSpace F E) x₀).left_inv',
    mem_extChartAt_source, mem_chartAt_source, and_assoc]
  rw [and_congr_right_iff]
  intro h
  simp only [mfld_simps]
  rw [and_congr_right_iff]
  intro h'
  simp only [mfld_simps]
  rw [and_congr_right_iff]
  intro h''
  simp only [mfld_simps]
  constructor
  · intro h
    have :
      ContMDiffWithinAt (IB.prod 𝓘(𝕜, F)) (IB.prod 𝓘(𝕜, F)) n
        (fun x ↦ ((extChartAt IM (TotalSpace F E) x₀).symm (f x)).1,
        (extChartAt IM (TotalSpace F E) x₀).symm (f x).2) s x₀ := by
      refine (h.1.prod_mk ?_).congr_of_eventuallyEq ?_ ?_
      · refine ((h.2.1.comp' (extChartAt IM (TotalSpace F E) x₀).symm.continuousWithinAt).prod_mk
          ?_).congr_of_eventuallyEq ?_ ?_
        · refine (h.2.2.comp' (extChartAt IM (TotalSpace F E) x₀).symm.continuousWithinAt).comp' ?_
          exact (continuous_proj _ _).continuousWithinAt
        · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
        · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
        · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
      · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
      · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
    convert this.2.2.congr_of_eventuallyEq ?_ ?_
    · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
    · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
    · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
    · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
  · intro h
    have :
      ContMDiffWithinAt (IB.prod 𝓘(𝕜, F)) (IB.prod 𝓘(𝕜, F)) n
        (fun x ↦ ((extChartAt IM (TotalSpace F E) x₀).symm (f x)).1,
        (extChartAt IM (TotalSpace F E) x₀).symm (f x).2) s x₀ := by
      refine (h.1.prod_mk ?_).congr_of_eventuallyEq ?_ ?_
      · refine ((h.2.1.comp' (extChartAt IM (TotalSpace F E) x₀).symm.continuousWithinAt).prod_mk
          ?_).congr_of_eventuallyEq ?_ ?_
        · refine (h.2.2.comp' (extChartAt IM (TotalSpace F E) x₀).symm.continuousWithinAt).comp' ?_
          exact (continuous_proj _ _).continuousWithinAt
        · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
        · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
        · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
      · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
      · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
    convert this.2.2.congr_of_eventuallyEq ?_ ?_
    · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
    · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
    · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
    · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])

Repaired Proof:
theorem contMDiffWithinAt_totalSpace (f : M → TotalSpace F E) {s : Set M} {x₀ : M} :
    ContMDiffWithinAt IM (IB.prod 𝓘(𝕜, F)) n f s x₀ ↔
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s x₀ ∧
      ContMDiffWithinAt IM 𝓘(𝕜, F) n (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).2) s x₀ ∧
      EqOn (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).1) Prod.fst s := by
  simp only [contMDiffWithinAt_iff, extChartAt_totalSpace, PartialEquiv.prod_coe,
    PartialEquiv.refl_coe, PartialEquiv.prod_coe_symm, PartialEquiv.refl_coe_symm,
    (extChartAt IM (TotalSpace F E) x₀).right_inv', (extChartAt IM (TotalSpace F E) x₀).left_inv',
    mem_extChartAt_source, mem_chartAt_source, and_assoc]
  rw [and_congr_right_iff]
  intro h
  simp only [mfld_simps]
  rw [and_congr_right_iff]
  intro h'
  simp only [mfld_simps]
  rw [and_congr_right_iff]
  intro h''
  simp only [mfld_simps]
  constructor
  · intro h
    have :
      ContMDiffWithinAt (IB.prod 𝓘(𝕜, F)) (IB.prod 𝓘(𝕜, F)) n
        (fun x ↦ ((extChartAt IM (TotalSpace F E) x₀).symm (f x)).1,
        (extChartAt IM (TotalSpace F E) x₀).symm (f x).2) s x₀ := by
      refine (h.1.prod_mk ?_).congr_of_eventuallyEq ?_ ?_
      · refine ((h.2.1.comp' (extChartAt IM (TotalSpace F E) x₀).symm.continuousWithinAt).prod_mk
          ?_).congr_of_eventuallyEq ?_ ?_
        · refine (h.2.2.comp' (extChartAt IM (TotalSpace F E) x₀).symm.continuousWithinAt).comp' ?_
          exact (continuous_proj _ _).continuousWithinAt
        · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
        · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
        · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
      · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
      · exact (extChartAt_proj_symm' _ _).trans (by simp_rw [Function.comp_apply])
    convert this.2.2.congr_of_eventuallyEq ?_ ?_
    · exact (extChartAt_proj_symm' _ _

Attempt failure.

Working on Mathlib/GroupTheory/Coxeter/Inversion.lean - 2024-09-09 01:50:32.787946.
---101/200---
For theorem CoxeterSystem.prod_leftInvSeq in Mathlib/GroupTheory/Coxeter/Inversion.lean:
theorem prod_leftInvSeq (ω : List B) : prod (lis ω) = (π ω)⁻¹ 


Original valid proof:
:= by
  simp [leftInvSeq_eq_reverse_rightInvSeq_reverse, prod_reverse_noncomm]
  have : List.map (fun x ↦ x⁻¹) (ris ω.reverse) = ris ω.reverse := calc
    List.map (fun x ↦ x⁻¹) (ris ω.reverse)
    _ = List.map id (ris ω.reverse)             := by
        apply List.map_congr_left
        intro t ht
        exact (cs.isReflection_of_mem_rightInvSeq _ ht).inv
    _ = ris ω.reverse                           := map_id _
  rw [this]
  nth_rw 2 [← reverse_reverse ω]
  rw [wordProd_reverse]
  exact cs.prod_rightInvSeq _


Verifying proof (Commit 50b72355f9be3d47d8653e9a50ac171292df7895):
• 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_leftInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_rev, inv_mul_cancel_left]

Repaired Proof:
theorem prod_leftInvSeq (ω : List B) : prod (lis ω) = (π ω)⁻¹ • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_leftInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_rev, inv_mul_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp
    · simp only [List.cons_append, prod_rightInvSeq_aux, ih, π_cons, smul_smul]
      rw [mul_inv_cancel_left]

Repaired Proof:
theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = π ω • 1 := by
    induction' ω with a ω ih
    · simp

Attempt failure.

---102/200---
For theorem CoxeterSystem.getD_leftInvSeq_mul_wordProd in Mathlib/GroupTheory/Coxeter/Inversion.lean:
theorem getD_leftInvSeq_mul_wordProd (ω : List B) (j : ℕ) :
    ((lis ω).getD j 1) * π ω = π (ω.eraseIdx j) 


Original valid proof:
:= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [← take_append_drop (j + 1) ω]
  rw [take_succ]
  obtain lt | le := lt_or_le j ω.length
  · simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  · simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp


Verifying proof (Commit 5549e23620db2b17d4924bff0c4de45d992f0b8d):
 := by
  simp only [getD_leftInvSeq, mul_assoc, wordProd_append, wordProd_cons,
    mul_one, wordProd_nil, List.map_cons, List.map_nil, List.map_append,
    List.append_assoc, List.eraseIdx_cons_cons, List.eraseIdx_cons]
  split_ifs with h
  · simp only [List.get?_cons_eq, h, List.get?_cons_ne, not_false_eq_true]
  · simp only [List.get?_cons_ne, h, List.get?_cons_eq, not_false_eq_true]

theorem getD_leftInvSeq_mul_wordProd_cancel (ω : List B) (j : ℕ) :
    ((lis ω).getD j 1) * π ω = π ω := by
  rw [getD_leftInvSeq_mul_wordProd]
  by_cases h : j < ω.length
  · rw [← List.take_append_drop j ω, wordProd_append, wordProd_take_mul_wordProd_drop]
    simp only [List.get?_eq_get h, List.getD_eq_get h, List.get_drop,
      List.get_append_right_eq, List.get_take_eq_get]
  · rw [← List.take_append_drop j.succ ω, wordProd_append, wordProd_take_mul_wordProd_drop]
    simp only [not_lt] at h
    simp only [List.getD_eq_default, h, List.get?_eq_none, List.get_append_right_eq,
      List.get_drop, List.get_take_eq_get, List.get_cons_succ, List.get?_eq_get,
      List.get?_cons_eq, not_false_eq_true, List.get?_eq_none, List.get_append_right_eq,
      List.get_drop, List.get_take_eq_get, List.get_cons_succ, List.get?_eq_get,
      List.get?_cons_eq, not_false_eq_true]
    rw [← mul_assoc, ← getD_leftInvSeq_mul_wordProd, mul_assoc, getD_leftInvSeq_mul_wordProd,
      mul_one]

Repaired Proof:
theorem getD_leftInvSeq_mul_wordProd (ω : List B) (j : ℕ) :
    ((lis ω).getD j 1) * π ω = π (ω.eraseIdx j)  := by
  simp only [getD_leftInvSeq, mul_assoc, wordProd_append, wordProd_cons,
    mul_one, wordProd_nil, List.map_cons, List.map_nil, List.map_append,
    List.append_assoc, List.eraseIdx_cons_cons, List.eraseIdx_cons]
  split_ifs with h
  · simp only [List.get?_cons_eq, h, List.get?_cons_ne, not_false_eq_true]
  · simp only [List.get?_cons_ne, h, List.get?_cons_eq, not_false_eq_true]

theorem getD_leftInvSeq_mul_wordProd_cancel (ω : List B) (j : ℕ) :
    ((lis ω).getD j 1) * π ω = π ω := by
  rw [getD_leftInvSeq_mul_wordProd]
  by_cases h : j < ω.length
  · rw [← List.take_append_drop j ω, wordProd_append, wordProd_take_mul_wordProd_drop]
    simp only [List.get?_eq_get h, List.getD_eq_get h, List.get_drop,
      List.get_append_right_eq, List.get_take,
      List.get_append_right_eq, List.get_drop, List.get_take]
  · rw [← List.take_append_drop j.succ ω, wordProd_append, wordProd_take_mul_wordProd_drop]
    simp only [not_lt] at h
    simp only [List.getD_eq_default, h, List.get?_eq_none, List.get_append_right_eq,
      List.get_drop, List.get_take,
      List.get_append_right_eq, List.get_drop, List.get_take]
    rw [← mul_assoc, ← getD_leftInvSeq_mul_wordProd, mul_assoc, getD_leftInvSeq_mul_wordProd,
      mul_one]

Repaired Proof:
theorem getD_leftInvSeq_mul_wordProd (ω : List B) (j : ℕ) :
    ((lis ω).getD j 1) * π ω = π (ω.eraseIdx j)  := by
  simp only [getD_leftInvSeq, mul_assoc, wordProd_append, wordProd_cons,
    mul_one, wordProd_nil, List.map_cons, List.map_nil, List.map_append,
    List.append_assoc, List.eraseIdx_cons_cons, List.eraseIdx_cons]
  split_ifs with h
  · simp only [List.get?_cons_eq, h, List.get?_cons_ne, not_false_eq_true]
  · simp only [List.get?_cons_ne, h, List.get?_cons_eq, not_false_eq_true]

theorem getD_leftInvSeq_mul_wordProd_cancel (ω : List B) (j : ℕ) :
    ((lis ω).getD j 1) * π ω = π ω := by
  rw [getD_leftInvSeq_mul_wordProd]
  by_cases h : j < ω.length
  · rw [← List.take_append_drop j ω, wordProd_append, wordProd_take_mul_wordProd_drop]
    simp only [List.get?_eq_get h, List.getD_eq_get h, List.get_drop,
      List.get_append_right_eq, List.get_take,
      List.get_append_right_eq, List.get_drop, List.get_take]
  · rw [← List.take_append_drop j.succ ω, wordProd_append, wordProd_take_mul_wordProd_drop]
    simp only [not_lt] at h
    simp only [List.getD_eq_default, h, List.get?_eq_none, List.get_append_right_eq,
      List.get_drop, List.get_take,
      List.get_append_right_eq, List.get_drop, List.get_take]
    rw [← mul_assoc, ← getD_leftInvSeq_mul_wordProd, mul_assoc, getD_leftInvSeq_mul_wordProd,
      mul_one]

Attempt failure.

Working on Mathlib/GroupTheory/GroupAction/Blocks.lean - 2024-09-09 01:50:51.583435.
---103/200---
For theorem MulAction.IsBlock.isBlockSystem in Mathlib/GroupTheory/GroupAction/Blocks.lean:
theorem IsBlock.isBlockSystem [hGX : MulAction.IsPretransitive G X]
    {B : Set X} (hB : IsBlock G B) (hBe : B.Nonempty) :
    IsBlockSystem G (Set.range fun g : G => g • B) 


Original valid proof:
:= by
  refine ⟨⟨?nonempty, ?cover⟩, ?mem_blocks⟩
  case mem_blocks => rintro B' ⟨g, rfl⟩; exact hB.translate g
  · simp only [Set.mem_range, not_exists]
    intro g hg
    apply hBe.ne_empty
    simpa only [Set.smul_set_eq_empty] using hg
  · intro a
    obtain ⟨b : X, hb : b ∈ B⟩ := hBe
    obtain ⟨g, rfl⟩ := exists_smul_eq G b a
    use g • B
    simp only [Set.smul_mem_smul_set_iff, hb, exists_unique_iff_exists, Set.mem_range,
      exists_apply_eq_apply, exists_const, exists_prop, and_imp, forall_exists_index,
      forall_apply_eq_imp_iff, true_and]
    intro g' ha
    apply (IsBlock.def.mp hB g' g).resolve_right
    rw [Set.not_disjoint_iff]
    refine ⟨g • b, ha, ⟨b, hb, rfl⟩⟩


Verifying proof (Commit 90ee4adef4081d5ea59d0008022888ad5b93d012):
∧
      (∀ b ∈ B, ∀ g : G, g • b ∈ Set.range fun g : G => g • B) := by
  have hB' : ∀ b ∈ B, ∀ g : G, g • b ∈ B := by
    intro b hb g
    obtain ⟨b', hb'⟩ := hBe
    obtain ⟨g', hg'⟩ := hGX.exists_smul_eq b' (g • b)
    rw [← hg', ← Set.smul_mem_smul_set hb, ← hB.smul_eq]
    exact Set.smul_mem_smul_set hb'
  refine' ⟨⟨hB.smul_eq, fun b₁ b₂ hb₁ hb₂ => _⟩, fun b hb g => ⟨g, rfl⟩⟩
  obtain ⟨g₁, hg₁⟩ := hB.exists_smul_eq b₁ b₂
  refine' ⟨g₁⁻¹, Set.ext fun x => ⟨fun hx => _, fun hx => _⟩⟩
  · obtain ⟨g₂, hg₂⟩ := hx
    rw [← hg₁, ← hg₂, ← Set.smul_mem_smul_set hb₁, ← Set.smul_mem_smul_set hb₂,
      hB'.inv_smul_smul, hB'.smul_smul]
    exact Set.smul_mem_smul_set hb₁
  · obtain ⟨g₂, hg₂⟩ := hx
    rw [← hg₁, ← hg₂, ← Set.smul_mem_smul_set hb₁, ← Set.smul_mem_smul_set hb₂,
      hB'.smul_smul, hB'.inv_smul_smul]
    exact Set.smul_mem_smul_set hb₂

Repaired Proof:
theorem IsBlock.isBlockSystem [hGX : MulAction.IsPretransitive G X]
    {B : Set X} (hB : IsBlock G B) (hBe : B.Nonempty) :
    IsBlockSystem G (Set.range fun g : G => g • B) ∧
      (∀ b ∈ B, ∀ g : G, g • b ∈ Set.range fun g : G => g • B) := by
  have hB' : ∀ b ∈ B, ∀ g : G, g • b ∈ B := by
    intro b hb g
    obtain ⟨b', hb'⟩ := hBe
    obtain ⟨g', hg'⟩ := hGX.exists_smul_eq b' (g • b)
    rw [← hg', ← Set.smul_mem_smul_set hb, ← hB.smul_eq]
    exact Set.smul_mem_smul_set hb'
  refine ⟨⟨hB.smul_eq, fun b₁ b₂ hb₁ hb₂ => ?_⟩, fun b hb g => ⟨g, rfl⟩⟩
  obtain ⟨g₁, hg₁⟩ := hB.exists_smul_eq b₁ b₂
  refine ⟨g₁⁻¹, Set.ext fun x => ⟨fun hx => ?_, fun hx => ?_⟩⟩
  · obtain ⟨g₂, hg₂⟩ := hx
    rw [← hg₁, ← hg₂, ← Set.smul_mem_smul_set hb₁, ← Set.smul_mem_smul_set hb₂,
      hB'.inv_smul_smul, hB'.smul_smul]
    exact Set.smul_mem_smul_set hb₁
  · obtain ⟨g₂, hg₂⟩ := hx
    rw [← hg₁, ← hg₂, ← Set.smul_mem_smul_set hb₁, ← Set.smul_mem_smul_set hb₂,
      hB'.smul_smul, hB'.inv_smul_smul]
    exact Set.smul_mem_smul_set hb₂

Repaired Proof:
theorem IsBlock.isBlockSystem [hGX : MulAction.IsPretransitive G X]
    {B : Set X} (hB : IsBlock G B) (hBe : B.Nonempty) :
    IsBlockSystem G (Set.range fun g : G => g • B) ∧
      (∀ b ∈ B, ∀ g : G, g • b ∈ Set.range fun g : G => g • B) := by
  have hB' : ∀ b ∈ B, ∀ g : G, g • b ∈ B := by
    intro b hb g
    obtain ⟨b', hb'⟩ := hBe
    obtain ⟨g', hg'⟩ := hGX.exists_smul_eq b' (g • b)
    rw [← hg', ← Set.smul_mem_smul_set hb, ← hB.smul_eq]
    exact Set.smul_mem_smul_set hb'
  refine ⟨⟨hB.smul_eq, fun b₁ b₂ hb₁ hb₂ => ?_⟩, fun b hb g => ⟨g, rfl⟩⟩
  obtain ⟨g₁, hg₁⟩ := hB.exists_smul_eq b₁ b₂
  refine ⟨g₁⁻¹, Set.ext fun x => ⟨fun hx => ?_, fun hx => ?_⟩⟩
  · obtain ⟨g₂, hg₂⟩ := hx
    rw [← hg₁, ← hg₂, ← Set.smul_mem_smul_set hb₁, ← Set.smul_mem_smul_set hb₂,
      hB'.inv_smul_smul, hB'.smul_smul]
    exact Set.smul_mem_smul_set hb₁
  · obtain ⟨g₂, hg₂⟩ := hx
    rw [← hg₁, ← hg₂, ← Set.smul_mem_smul_set hb₁, ← Set.smul_mem_smul_set hb₂,
      hB'.smul_smul, hB'.inv_smul_smul]
    exact Set.smul_mem_smul_set hb₂

Repaired Proof:
theorem IsBlock.isBlockSystem [hGX : MulAction.IsPretransitive G X]
    {B : Set X} (hB : IsBlock G B) (hBe : B.Nonempty) :
    IsBlockSystem G (Set.range fun g : G => g • B) ∧
      (∀ b ∈ B, ∀ g : G, g • b ∈ Set.range fun g : G => g • B) := by
  have hB' : ∀ b ∈ B, ∀ g : G, g • b ∈ B := by
    intro b hb g
    obtain ⟨b', hb'⟩ := hBe
    obtain ⟨g', hg'⟩ := hGX.exists_smul_eq b' (g • b)
    rw [← hg', ← Set.smul_mem_smul_set hb, ← hB.smul_eq]
    exact Set.smul_mem_smul_set hb'
  refine ⟨⟨hB.smul_eq, fun b₁ b₂ hb₁ hb₂ => ?_⟩, fun b hb g => ⟨g, rfl⟩⟩
  obtain ⟨g₁, hg₁⟩ := hB.exists_smul_eq b₁ b₂
  refine ⟨g₁⁻¹, Set.ext fun x => ⟨fun hx => ?_, fun hx => ?_⟩⟩
  · obtain ⟨g₂, hg₂⟩

Attempt failure.

Working on Mathlib/GroupTheory/Nilpotent.lean - 2024-09-09 01:50:57.990834.
---104/200---
For theorem IsPGroup.isNilpotent in Mathlib/GroupTheory/Nilpotent.lean:
theorem IsPGroup.isNilpotent [Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)] (h : IsPGroup p G) :
    IsNilpotent G 


Original valid proof:
:= by
  cases' nonempty_fintype G
  classical
    revert hG
    apply @Fintype.induction_subsingleton_or_nontrivial _ G _
    · intro _ _ _ _
      infer_instance
    · intro G _ _ ih _ h
      have hcq : Fintype.card (G ⧸ center G) < Fintype.card G := by
        simp only [← Nat.card_eq_fintype_card]
        rw [card_eq_card_quotient_mul_card_subgroup (center G)]
        simp only [Nat.card_eq_fintype_card]
        apply lt_mul_of_one_lt_right
        · exact Fintype.card_pos_iff.mpr One.instNonempty
        · simp only [← Nat.card_eq_fintype_card]
          exact (Subgroup.one_lt_card_iff_ne_bot _).mpr (ne_of_gt h.bot_lt_center)
      have hnq : IsNilpotent (G ⧸ center G) := ih _ hcq (h.to_quotient (center G))
      exact of_quotient_center_nilpotent hnq


Verifying proof (Commit 5618e4318bfd1fcd653dba5baf6373bb64237264):
↔ p ∣ card G := by
  classical
  cases nonempty_fintype G
  refine ⟨fun hG => ?_, fun h =>
    nilpotent_of_finite_quotient_nilpotent (hG.to_quotient_center_nilpotent.of_surjective
      (mk_surjective G)) (card_center_dvd_card G)⟩
  induction' hG with K hK ihk
  rw [← hK.card_eq_pow_p]
  obtain ⟨k, hk⟩ := ihk
  rw [card_eq_card_quotient_mul_card_subgroup K, hk, mul_comm, ← Nat.card_eq_fintype_card]
  exact Nat.dvd_mul_right _ _

Repaired Proof:
theorem IsPGroup.isNilpotent [Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)] (h : IsPGroup p G) :
    IsNilpotent G ↔ p ∣ card G := by
  classical
  cases nonempty_fintype G
  refine ⟨fun hG => ?_, fun h =>
    nilpotent_of_finite_quotient_nilpotent (hG.to_quotient_center_nilpotent.of_surjective
      (mk_surjective G)) (card_center_dvd_card G)⟩
  induction' hG with K hK ihk
  rw [← hK.card_eq_pow_p]
  obtain ⟨k, hk⟩ := ihk
  rw [card_eq_card_quotient_mul_card_subgroup K, hk, mul_comm, ← Nat.card_eq_fintype_card]
  exact Nat.dvd_mul_right _ _

Repaired Proof:
theorem IsPGroup.isNilpotent [Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)] (h : IsPGroup p G) :
    IsNilpotent G ↔ p ∣ card G := by
  classical
  cases nonempty_fintype G
  refine ⟨fun hG => ?_, fun h =>
    nilpotent_of_finite_quotient_nilpotent (hG.to_quotient_center_nilpotent.of_surjective
      (mk_surjective G)) (card_center_dvd_card G)⟩
  induction' hG with K hK ihk
  rw [← hK.card_eq_pow_p]
  obtain ⟨k, hk⟩ := ihk
  rw [card_eq_card_quotient_mul_card_subgroup K, hk, mul_comm, ← Nat.card_eq_fintype_card]
  exact Nat.dvd_mul_right _ _

Repaired Proof:
theorem IsPGroup.isNilpotent [Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)] (h : IsPGroup p G) :
    IsNilpotent G ↔ p ∣ card G := by
  classical
  cases nonempty_fintype G
  refine ⟨fun hG => ?_, fun h =>
    nilpotent_of_finite_quotient_nilpotent (hG.to_quotient_center_nilpotent.of_surjective
      (mk_surjective G)) (card_center_dvd_card G)⟩
  induction' hG with K hK ihk
  rw [← hK.card_eq_pow_p]
  obtain ⟨k, hk⟩ := ihk
  rw [card_eq_card_quotient_mul_card_subgroup K, hk, mul_comm, ← Nat.card_eq_fintype_card]
  exact Nat.dvd_mul_right _ _

Attempt failure.

Working on Mathlib/GroupTheory/Transfer.lean - 2024-09-09 01:51:08.071735.
---105/200---
For theorem MonoidHom.transfer_eq_pow_aux in Mathlib/GroupTheory/Transfer.lean:
theorem transfer_eq_pow_aux (g : G)
    (key : ∀ (k : ℕ) (g₀ : G), g₀⁻¹ * g ^ k * g₀ ∈ H → g₀⁻¹ * g ^ k * g₀ = g ^ k) :
    g ^ H.index ∈ H 


Original valid proof:
:= by
  by_cases hH : H.index = 0
  · rw [hH, pow_zero]
    exact H.one_mem
  letI := fintypeOfIndexNeZero hH
  classical
    replace key : ∀ (k : ℕ) (g₀ : G), g₀⁻¹ * g ^ k * g₀ ∈ H → g ^ k ∈ H := fun k g₀ hk =>
      (_root_.congr_arg (· ∈ H) (key k g₀ hk)).mp hk
    replace key : ∀ q : G ⧸ H, g ^ Function.minimalPeriod (g • ·) q ∈ H := fun q =>
      key (Function.minimalPeriod (g • ·) q) q.out'
        (QuotientGroup.out'_conj_pow_minimalPeriod_mem H g q)
    let f : Quotient (orbitRel (zpowers g) (G ⧸ H)) → zpowers g := fun q =>
      (⟨g, mem_zpowers g⟩ : zpowers g) ^ Function.minimalPeriod (g • ·) q.out'
    have hf : ∀ q, f q ∈ H.subgroupOf (zpowers g) := fun q => key q.out'
    replace key :=
      Subgroup.prod_mem (H.subgroupOf (zpowers g)) fun q (_ : q ∈ Finset.univ) => hf q
    simpa only [f, minimalPeriod_eq_card, Finset.prod_pow_eq_pow_sum, Fintype.card_sigma,
      Fintype.card_congr (selfEquivSigmaOrbits (zpowers g) (G ⧸ H)), index_eq_card] using key


Verifying proof (Commit 951e9e356bae97e849c7fcb6a4a2d7b981507062):
↔ g ∈ H := by
  classical
    rw [index_eq_card, ← pow_card_eq_one]
    let f : G →* G ⧸ H := mk' H
    have fker : MonoidHom.ker f = H := ker_mk' H
    have hf : Function.Surjective f := surjective_quot_mk _
    let Φ : G ⧸ H →* G ⧸ H :=
      (quotientGroup.mk' H).comp (map (MonoidHom.id G) H H (Subgroup.subtype_injective H))
    have Φ_id : Φ.comp f = f := by
      ext
      simp [Φ, MonoidHom.comp_apply, MonoidHom.id, MonoidHom.mapToQuotient, MonoidHom.id_apply]
    have Φ_inj : Function.Injective Φ := by
      rw [MonoidHom.ker_eq_bot_iff]
      intro x
      simp only [MonoidHom.comp_apply, Φ, MonoidHom.id_apply, MonoidHom.mapToQuotient_apply,
        MonoidHom.id_apply, map_apply_eq_iff, map_id, id_eq, mk'_apply, eq_iff_true_of_subsingleton]
    have Φ_surj : Function.Surjective Φ := by
      intro y
      obtain ⟨x, rfl⟩ := hf y
      refine' ⟨f x, _⟩
      simp only [Φ, MonoidHom.comp_apply, MonoidHom.id_apply, MonoidHom.mapToQuotient_apply,
        MonoidHom.id_apply, map_apply_eq_iff, map_id, id_eq, mk'_apply]
    have Φ_bijective : Function.Bijective Φ := ⟨Φ_inj, Φ_surj⟩
    have Φ_pow_eq : ∀ n : ℕ, Φ (f (g ^ n)) = f (g ^ n) := by
      intro n
      simp only [Φ, MonoidHom.comp_apply, MonoidHom.id_apply, MonoidHom.mapToQuotient_apply,
        MonoidHom.id_apply, map_apply_eq_iff, map_id, id_eq, mk'_apply]
    have Φ_pow_eq' : ∀ n : ℕ, Φ (f (g ^ n)) = f 1 := by
      intro n
      rw [Φ_pow_eq, pow_card_eq_one, f.map_one]
    have Φ_pow_eq'' : ∀ n : ℕ, f (g ^ n) = f 1 := by
      intro n
      rw [← Φ_pow_eq', Φ.apply_eq_iff_eq, Φ.map_one]
    have hg : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg'' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg'''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg'''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg''''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg'''''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg''''''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg'''''''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg''''''''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg'''''''''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg''''''''''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg'''''''''''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg''''''''''''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (n % H.index) ∈ H := by
      intro n
      rw [← f.mem_ker, Φ_pow_eq'']
      simp only [f.mem_ker, mk'_apply, MonoidHom.map_one]
    have hg'''''''''''''''' : ∀ n : ℕ, g ^ n ∈ H ↔ g ^ (

Attempt failure.

Working on Mathlib/LinearAlgebra/AffineSpace/Independent.lean - 2024-09-09 01:51:16.735930.
---106/200---
For theorem exists_subset_affineIndependent_affineSpan_eq_top in Mathlib/LinearAlgebra/AffineSpace/Independent.lean:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ 


Original valid proof:
:= by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · have p₁ : P := AddTorsor.nonempty.some
    let hsv := Basis.ofVectorSpace k V
    have hsvi := hsv.linearIndependent
    have hsvt := hsv.span_eq
    rw [Basis.coe_ofVectorSpace] at hsvi hsvt
    have h0 : ∀ v : V, v ∈ Basis.ofVectorSpaceIndex k V → v ≠ 0 := by
      intro v hv
      simpa [hsv] using hsv.ne_zero ⟨v, hv⟩
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi
    exact
      ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' _, Set.empty_subset _, hsvi,
        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt⟩
  · rw [affineIndependent_set_iff_linearIndependent_vsub k hp₁] at h
    let bsv := Basis.extend h
    have hsvi := bsv.linearIndependent
    have hsvt := bsv.span_eq
    rw [Basis.coe_extend] at hsvi hsvt
    have hsv := h.subset_extend (Set.subset_univ _)
    have h0 : ∀ v : V, v ∈ h.extend (Set.subset_univ _) → v ≠ 0 := by
      intro v hv
      simpa [bsv] using bsv.ne_zero ⟨v, hv⟩
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi
    refine ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' h.extend (Set.subset_univ _), ?_, ?_⟩
    · refine Set.Subset.trans ?_ (Set.union_subset_union_right _ (Set.image_subset _ hsv))
      simp [Set.image_image]
    · use hsvi
      exact affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_singleton, eq_top_iff]
      exact le_top
    · simp
  haveI : Nonempty s := ⟨⟨p₁, hp₁⟩⟩
  haveI : Nontrivial k := IsEmpty.nontrivial_of_nonempty_affineIndependent h
  haveI : Nontrivial P := nontrivial_of_nontrivial k
  rcases exists_affineIndependent_affineSpan_eq_top_of_nontrivial k P with ⟨t, hts, ht, htop, htd⟩
  refine ⟨t, hts, ht, htop, ?_⟩
  rintro p₁ ⟨hp₁, -⟩
  rcases htd p₁ with (h | h)
  · exact Or.inl (hts h)
  · exact Or.inr h

Repaired Proof:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_singleton, eq_top_iff]
      exact le_top
    · simp
  haveI : Nonempty s := ⟨⟨p₁, hp₁⟩⟩
  haveI : Nontrivial k := IsEmpty.nontrivial_of_nonempty_affineIndependent h
  haveI : Nontrivial P := nontrivial_of_nontrivial k
  rcases exists_affineIndependent_affineSpan_eq_top_of_nontrivial k P with ⟨t, hts, ht, htop, htd⟩
  refine ⟨t, hts, ht, htop, ?_⟩
  rintro p₁ ⟨hp₁, -⟩
  rcases htd p₁ with (h | h)
  · exact Or.inl (hts h)
  · exact Or.inr h

Repaired Proof:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_singleton, eq_top_iff]
      exact le_top
    · simp
  haveI : Nonempty s := ⟨⟨p₁, hp₁⟩⟩
  haveI : Nontrivial k := IsEmpty.nontrivial_of_nonempty_affineIndependent h
  haveI : Nontrivial P := nontrivial_of_nontrivial k
  rcases exists_affineIndependent_affineSpan_eq_top_of_nontrivial k P with ⟨t, hts, ht, htop, htd⟩
  refine ⟨t, hts, ht, htop, ?_⟩
  rintro p₁ ⟨hp₁, -⟩
  rcases htd p₁ with (h | h)
  · exact Or.inl (hts h)
  · exact Or.inr h

Repaired Proof:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_singleton, eq_top_iff]
      exact le_top
    · simp
  haveI : Nonempty s := ⟨⟨p₁, hp₁⟩⟩
  haveI : Nontrivial k := IsEmpty.nontrivial_of_nonempty_affineIndependent h
  haveI : Nontrivial P := nontrivial_of_nontrivial k
  rcases exists_affineIndependent_affineSpan_eq_top_of_nontrivial k P with ⟨t, hts, ht, htop, htd⟩
  refine ⟨t, hts, ht, htop, ?_⟩
  rintro p₁ ⟨hp₁, -⟩
  rcases htd p₁ with (h | h)
  · exact Or.inl (hts h)
  · exact Or.inr h

Repaired Proof:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_singleton, eq_top_iff]
      exact le_top
    · simp
  haveI : Nonempty s := ⟨⟨p₁, hp₁⟩⟩
  haveI : Nontrivial k := IsEmpty.nontrivial_of_nonempty_affineIndependent h
  haveI : Nontrivial P := nontrivial_of_nontrivial k
  rcases exists_affineIndependent_affineSpan_eq_top_of_nontrivial k P with ⟨t, hts, ht, htop, htd⟩
  refine ⟨t, hts, ht, htop, ?_⟩
  rintro p₁ ⟨hp₁, -⟩
  rcases htd p₁ with (h | h)
  · exact Or.inl (hts h)
  · exact Or.inr h

Repaired Proof:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_

Attempt failure.

---107/200---
For theorem exists_subset_affineIndependent_affineSpan_eq_top in Mathlib/LinearAlgebra/AffineSpace/Independent.lean:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ 


Original valid proof:
:= by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · have p₁ : P := AddTorsor.nonempty.some
    let hsv := Basis.ofVectorSpace k V
    have hsvi := hsv.linearIndependent
    have hsvt := hsv.span_eq
    rw [Basis.coe_ofVectorSpace] at hsvi hsvt
    have h0 : ∀ v : V, v ∈ Basis.ofVectorSpaceIndex k V → v ≠ 0 := by
      intro v hv
      simpa [hsv] using hsv.ne_zero ⟨v, hv⟩
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi
    exact
      ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' _, Set.empty_subset _, hsvi,
        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt⟩
  · rw [affineIndependent_set_iff_linearIndependent_vsub k hp₁] at h
    let bsv := Basis.extend h
    have hsvi := bsv.linearIndependent
    have hsvt := bsv.span_eq
    rw [Basis.coe_extend] at hsvi hsvt
    have hsv := h.subset_extend (Set.subset_univ _)
    have h0 : ∀ v : V, v ∈ h.extend (Set.subset_univ _) → v ≠ 0 := by
      intro v hv
      simpa [bsv] using bsv.ne_zero ⟨v, hv⟩
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi
    refine ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' h.extend (Set.subset_univ _), ?_, ?_⟩
    · refine Set.Subset.trans ?_ (Set.union_subset_union_right _ (Set.image_subset _ hsv))
      simp [Set.image_image]
    · use hsvi
      exact affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt


Verifying proof (Commit 1cb1056b5a19f416d3fae3469d51eedb4f5b48cb):
∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_singleton, eq_top_iff]
      exact le_top
    · simp
  haveI : Nonempty s := ⟨⟨p₁, hp₁⟩⟩
  haveI : Nontrivial k := IsEmpty.nontrivial_of_nonempty_affineIndependent h
  haveI : Nontrivial P := nontrivial_of_nontrivial k
  rcases exists_affineIndependent_affineSpan_eq_top_of_nontrivial k P with ⟨t, hts, ht, htop, htd⟩
  refine ⟨t, hts, ht, htop, ?_⟩
  rintro p₁ ⟨hp₁, -⟩
  rcases htd p₁ with (h | h)
  · exact Or.inl (hts h)
  · exact Or.inr h

Repaired Proof:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_singleton, eq_top_iff]
      exact le_top
    · simp
  haveI : Nonempty s := ⟨⟨p₁, hp₁⟩⟩
  haveI : Nontrivial k := IsEmpty.nontrivial_of_nonempty_affineIndependent h
  haveI : Nontrivial P := nontrivial_of_nontrivial k
  rcases exists_affineIndependent_affineSpan_eq_top_of_nontrivial k P with ⟨t, hts, ht, htop, htd⟩
  refine ⟨t, hts, ht, htop, ?_⟩
  rintro p₁ ⟨hp₁, -⟩
  rcases htd p₁ with (h | h)
  · exact Or.inl (hts h)
  · exact Or.inr h

Repaired Proof:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_singleton, eq_top_iff]
      exact le_top
    · simp
  haveI : Nonempty s := ⟨⟨p₁, hp₁⟩⟩
  haveI : Nontrivial k := IsEmpty.nontrivial_of_nonempty_affineIndependent h
  haveI : Nontrivial P := nontrivial_of_nontrivial k
  rcases exists_affineIndependent_affineSpan_eq_top_of_nontrivial k P with ⟨t, hts, ht, htop, htd⟩
  refine ⟨t, hts, ht, htop, ?_⟩
  rintro p₁ ⟨hp₁, -⟩
  rcases htd p₁ with (h | h)
  · exact Or.inl (hts h)
  · exact Or.inr h

Repaired Proof:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_singleton, eq_top_iff]
      exact le_top
    · simp
  haveI : Nonempty s := ⟨⟨p₁, hp₁⟩⟩
  haveI : Nontrivial k := IsEmpty.nontrivial_of_nonempty_affineIndependent h
  haveI : Nontrivial P := nontrivial_of_nontrivial k
  rcases exists_affineIndependent_affineSpan_eq_top_of_nontrivial k P with ⟨t, hts, ht, htop, htd⟩
  refine ⟨t, hts, ht, htop, ?_⟩
  rintro p₁ ⟨hp₁, -⟩
  rcases htd p₁ with (h | h)
  · exact Or.inl (hts h)
  · exact Or.inr h

Repaired Proof:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_singleton, eq_top_iff]
      exact le_top
    · simp
  haveI : Nonempty s := ⟨⟨p₁, hp₁⟩⟩
  haveI : Nontrivial k := IsEmpty.nontrivial_of_nonempty_affineIndependent h
  haveI : Nontrivial P := nontrivial_of_nontrivial k
  rcases exists_affineIndependent_affineSpan_eq_top_of_nontrivial k P with ⟨t, hts, ht, htop, htd⟩
  refine ⟨t, hts, ht, htop, ?_⟩
  rintro p₁ ⟨hp₁, -⟩
  rcases htd p₁ with (h | h)
  · exact Or.inl (hts h)
  · exact Or.inr h

Repaired Proof:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t ⊆ s ∪ (univ \ s) := by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · refine ⟨{p₁}, empty_subset _, ?_, ?_, ?_⟩
    · simpa [affineIndependent_iff_of_subsingleton] using h
    · rw [affineSpan_

Attempt failure.

Working on Mathlib/LinearAlgebra/Basis/VectorSpace.lean - 2024-09-09 01:51:37.637281.
---108/200---
For theorem nonzero_span_atom in Mathlib/LinearAlgebra/Basis/VectorSpace.lean:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) 


Original valid proof:
:= by
  constructor
  · rw [Submodule.ne_bot_iff]
    exact ⟨v, ⟨mem_span_singleton_self v, hv⟩⟩
  · intro T hT
    by_contra h
    apply hT.2
    change span K {v} ≤ T
    simp_rw [span_singleton_le_iff_mem, ← Ne.eq_def, Submodule.ne_bot_iff] at *
    rcases h with ⟨s, ⟨hs, hz⟩⟩
    rcases mem_span_singleton.1 (hT.1 hs) with ⟨a, rfl⟩
    rcases eq_or_ne a 0 with rfl | h
    · simp only [zero_smul, ne_eq, not_true] at hz
    · rwa [T.smul_mem_iff h] at hs


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔ v ∉ T.W := by
  constructor
  · rintro ⟨hTv, h⟩ hvT
    apply hTv
    rw [eq_bot_iff]
    apply h
    rw [span_singleton_le_iff_mem]
    exact hvT
  · intro hvT
    constructor
    · simp only [ne_eq, span_singleton_eq_bot, hv, not_false_eq_true]
    · intro W hW
      by_contra h
      apply hvT
      rw [← Submodule.span_le, Set.singleton_subset_iff] at hW
      apply hW
      exact h

Repaired Proof:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) ↔ v ∉ T.W := by
  constructor
  · rintro ⟨hTv, h⟩ hvT
    apply hTv
    rw [eq_bot_iff]
    apply h
    rwa [span_singleton_le_iff_mem]
  · intro hvT
    constructor
    · simp only [ne_eq, span_singleton_eq_bot, hv, not_false_eq_true]
    · intro W hW
      by_contra h
      apply hvT
      rw [← Submodule.span_le, Set.singleton_subset_iff] at hW
      exact hW h

Repaired Proof:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) ↔ v ∉ T.W := by
  constructor
  · rintro ⟨hTv, h⟩ hvT
    apply hTv
    rw [eq_bot_iff]
    apply h
    rwa [span_singleton_le_iff_mem]
  · intro hvT
    constructor
    · simp only [ne_eq, span_singleton_eq_bot, hv, not_false_eq_true]
    · intro W hW
      by_contra h
      apply hvT
      rw [← Submodule.span_le, Set.singleton_subset_iff] at hW
      exact hW h

Repaired Proof:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) ↔ v ∉ T.W := by
  constructor
  · rintro ⟨hTv, h⟩ hvT
    apply hTv
    rw [eq_bot_iff]
    apply h
    rwa [span_singleton_le_iff_mem]
  · intro hvT
    constructor
    · simp only [ne_eq, span_singleton_eq_bot, hv, not_false_eq_true]
    · intro W hW
      by_contra h
      apply hvT
      rw [← Submodule.span_le, Set.singleton_subset_iff] at hW
      exact hW h

Repaired Proof:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) ↔ v ∉ T.W := by
  constructor
  · rintro ⟨hTv, h⟩ hvT
    apply hTv
    rw [eq_bot_iff]
    apply h
    rwa [span_singleton_le_iff_mem]
  · intro hvT
    constructor
    · simp only [ne_eq, span_singleton_eq_bot, hv, not_false_eq_true]
    · intro W hW
      by_contra h
      apply hvT
      rw [← Submodule.span_le, Set.singleton_subset_iff] at hW
      exact hW h

Repaired Proof:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) ↔ v ∉ T.W := by
  constructor
  · rintro ⟨hTv, h⟩ hvT
    apply hTv
    rw [eq_bot_iff]
    apply h
    rwa [span_singleton_le_iff_mem]
  · intro hvT
    constructor
    · simp only [ne_eq, span_singleton_eq_bot, hv, not_false_eq_true]
    · intro W hW
      by_contra h
      apply hvT
      rw [← Submodule.span_le, Set.singleton_subset_iff] at hW
      exact hW h

Repaired Proof:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) ↔ v ∉ T.W := by
  constructor
  · rintro ⟨hTv, h⟩ hvT
    apply hTv
    rw [eq_bot_iff]
    apply h
    rwa [span_singleton_le_iff_mem]
  · intro hvT
    constructor
    · simp only [ne_eq, span_singleton_eq_bot, hv, not_false_eq_true]
    · intro W hW
      by_contra h
      apply hvT
      rw [← Submodule.span_le, Set.singleton_subset_iff] at hW
      exact hW h

Repaired Proof:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) ↔ v ∉ T.W := by
  constructor
  · rintro ⟨hTv, h⟩ hvT
    apply hTv
    rw [eq_bot_iff]
    apply h
    rwa [span_singleton_le_iff_mem]
  · intro hvT
    constructor
    · simp only [ne_eq, span_singleton_eq_bot, hv, not_false_eq_true]
    · intro W hW
      by_contra h
      apply hvT
      rw [← Submodule.span_le, Set.singleton_subset_iff] at hW
      exact hW h

Repaired Proof:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) ↔ v ∉ T.W := by
  constructor
  · rintro ⟨hTv, h⟩ hvT
    apply hTv
    rw [eq_bot_iff]
    apply h
    rwa [span_singleton_le_iff_mem]
  · intro hvT
    constructor
    · simp only [ne_eq, span_singleton_eq_bot, hv, not_false_eq_true]
    · intro W hW
      by_contra h
      apply hvT
      rw [← Submodule.span_le, Set.singleton_subset_iff] at hW
      exact hW h

Repaired Proof:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) ↔ v ∉ T.W := by
  constructor
  · rintro ⟨hTv, h⟩ hvT
    apply hTv
    rw [eq_bot_iff]
    apply h
    rwa [span_singleton_le_iff_mem]
  · intro hvT
    constructor
    · simp only [ne_eq, span_singleton_eq_bot, hv, not_false_eq_true]
    · intro W hW
      by_contra h
      apply hvT
      rw [← Submodule.span_le, Set.singleton_subset_iff] at hW
      exact hW h

Repaired Proof:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) ↔ v ∉ T.W := by
  constructor
  · rintro ⟨hTv, h⟩ hvT
    apply hTv
    rw [eq_bot_iff]
    apply h
    rwa [span_singleton_le_iff_mem]
  · intro hvT
    constructor
    · simp only [ne_eq, span_singleton_eq_bot, hv, not_false_eq_true]
    · intro W hW
      by_contra h
      apply hvT
      rw [← Submodule.span_le, Set.singleton

Attempt failure.

Working on Mathlib/LinearAlgebra/Charpoly/ToMatrix.lean - 2024-09-09 01:51:46.134152.
---109/200---
For theorem LinearMap.charpoly_toMatrix in Mathlib/LinearAlgebra/Charpoly/ToMatrix.lean:
theorem charpoly_toMatrix {ι : Type w} [DecidableEq ι] [Fintype ι] (b : Basis ι R M) :
    (toMatrix b b f).charpoly = f.charpoly 


Original valid proof:
:= by
  let A := toMatrix b b f
  let b' := chooseBasis R M
  let ι' := ChooseBasisIndex R M
  let A' := toMatrix b' b' f
  let e := Basis.indexEquiv b b'
  let φ := reindexLinearEquiv R R e e
  let φ₁ := reindexLinearEquiv R R e (Equiv.refl ι')
  let φ₂ := reindexLinearEquiv R R (Equiv.refl ι') (Equiv.refl ι')
  let φ₃ := reindexLinearEquiv R R (Equiv.refl ι') e
  let P := b.toMatrix b'
  let Q := b'.toMatrix b
  have hPQ : C.mapMatrix (φ₁ P) * C.mapMatrix (φ₃ Q) = 1 := by
    rw [RingHom.mapMatrix_apply, RingHom.mapMatrix_apply, ← Matrix.map_mul,
      reindexLinearEquiv_mul R R, Basis.toMatrix_mul_toMatrix_flip,
      reindexLinearEquiv_one, ← RingHom.mapMatrix_apply, RingHom.map_one]
  calc
    A.charpoly = (reindex e e A).charpoly := (charpoly_reindex _ _).symm
    _ = det (scalar ι' X - C.mapMatrix (φ A)) := rfl
    _ = det (scalar ι' X - C.mapMatrix (φ (P * A' * Q))) := by
      rw [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]
    _ = det (scalar ι' X - C.mapMatrix (φ₁ P * φ₂ A' * φ₃ Q)) := by
      rw [reindexLinearEquiv_mul, reindexLinearEquiv_mul]
    _ = det (scalar ι' X - C.mapMatrix (φ₁ P) * C.mapMatrix A' * C.mapMatrix (φ₃ Q)) := by simp [φ₂]
    _ = det (scalar ι' X * C.mapMatrix (φ₁ P) * C.mapMatrix (φ₃ Q) -
          C.mapMatrix (φ₁ P) * C.mapMatrix A' * C.mapMatrix (φ₃ Q)) := by
      rw [Matrix.mul_assoc ((scalar ι') X), hPQ, Matrix.mul_one]
    _ = det (C.mapMatrix (φ₁ P) * scalar ι' X * C.mapMatrix (φ₃ Q) -
          C.mapMatrix (φ₁ P) * C.mapMatrix A' * C.mapMatrix (φ₃ Q)) := by
      rw [scalar_commute _ commute_X]
    _ = det (C.mapMatrix (φ₁ P) * (scalar ι' X - C.mapMatrix A') * C.mapMatrix (φ₃ Q)) := by
      rw [← Matrix.sub_mul, ← Matrix.mul_sub]
    _ = det (C.mapMatrix (φ₁ P)) * det (scalar ι' X - C.mapMatrix A') * det (C.mapMatrix (φ₃ Q)) :=
      by rw [det_mul, det_mul]
    _ = det (C.mapMatrix (φ₁ P)) * det (C.mapMatrix (φ₃ Q)) * det (scalar ι' X - C.mapMatrix A') :=
      by ring
    _ = det (scalar ι' X - C.mapMatrix A') := by
      rw [← det_mul, hPQ, det_one, one_mul]
    _ = f.charpoly := rfl


Verifying proof (Commit 020f593358def5e1f64b452de28d39bc85502a09):
∧
      (toMatrix b b f).charpoly.Monic ∧
        (toMatrix b b f).charpoly.natDegree = finrank K M := by
  letI := Classical.decEq ι
  haveI : Finite R M := Module.Finite.of_basis b
  haveI : IsNoetherian R M := IsNoetherian.iff_fg.2 inferInstance
  haveI : FiniteDimensional K M := FiniteDimensional.of_fg (Submodule.fg_top _)
  haveI : IsNoetherian K M := IsNoetherian.iff_fg.2 inferInstance
  haveI : Module.Finite R M := Module.Finite.of_basis b
  haveI : Module.Free K M := Module.Free.of_basis b
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionRing.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionRing.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionRing.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionRing.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionRing.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionRing.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _ (IsFractionEnd.injective _ _)
  haveI : IsIntegralClosure R K M :=
    IsIntegralClosure.of_finite' _ _ _

Attempt failure.

Working on Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean - 2024-09-09 01:51:54.084820.
---110/200---
For theorem ExteriorAlgebra.GradedAlgebra.ι_sq_zero in Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean:
theorem GradedAlgebra.ι_sq_zero (m : M) : GradedAlgebra.ι R M m * GradedAlgebra.ι R M m = 0 


Original valid proof:
:= by
  rw [GradedAlgebra.ι_apply, DirectSum.of_mul_of]
  exact DFinsupp.single_eq_zero.mpr (Subtype.ext <| ExteriorAlgebra.ι_sq_zero _)


Verifying proof (Commit 5e927760039770855bbf0fe0d5195e10790c094b):
 := by
  rw [← GradedAlgebra.ι_sq_smul, Algebra.smul_def, map_one, mul_one]

@[simp]
theorem GradedAlgebra.ι_eq_zero_iff (m : M) : GradedAlgebra.ι R M m = 0 ↔ m = 0 := by
  constructor
  · intro h
    rw [← GradedAlgebra.ι_eq_zero_iff R M m, h]
    rfl
  · rintro rfl
    exact GradedAlgebra.ι_zero R M

@[simp]
theorem GradedAlgebra.ι_eq_algebraMap_iff (m : M) (r : R) :
    GradedAlgebra.ι R M m = algebraMap R _ r ↔ m = 0 ∧ r = 0 := by
  refine ⟨fun h => ?_, ?_⟩
  · rw [← GradedAlgebra.ι_eq_zero_iff R M m, ← (Algebra.adjoin R {m}).algebraMap_eq, h,
      Algebra.adjoin_singleton_eq_range_algebraMap, AlgHom.mem_range]
    refine ⟨r, ?_⟩
    rw [← h, GradedAlgebra.ι_sq_zero, zero_mul]
  · rintro ⟨rfl, rfl⟩
    rw [map_zero]

@[simp]
theorem GradedAlgebra.ι_ne_one [Nontrivial R] (m : M) : GradedAlgebra.ι R M m ≠ 1 := by
  rw [← GradedAlgebra.ι_one_eq_algebraMap, Ne, GradedAlgebra.ι_eq_algebraMap_iff]
  exact one_ne_zero

@[simp]
theorem GradedAlgebra.ι_ne_zero [Nontrivial R] (m : M) : GradedAlgebra.ι R M m ≠ 0 := by
  rw [Ne, ← GradedAlgebra.ι_zero, GradedAlgebra.ι_eq_zero_iff]
  exact zero_ne_one

@[simp]
theorem GradedAlgebra.ι_ne_zero' [Nontrivial R] (m : M) :
    GradedAlgebra.ι R M m ≠ 0 :=
  GradedAlgebra.ι_ne_zero R M m

@[simp]
theorem GradedAlgebra.ι_ne_one' [Nontrivial R] (m : M) :
    GradedAlgebra.ι R M m ≠ 1 :=
  GradedAlgebra.ι_ne_one R M m

@[simp]
theorem GradedAlgebra.ι_pow_mul_ι_pow_comm (m₁ m₂ : M) (n₁ n₂ : ℕ) :
    (GradedAlgebra.ι R M m₁ ^ n₁) * (GradedAlgebra.ι R M m₂ ^ n₂) =
      (GradedAlgebra.ι R M m₂ ^ n₂) * (GradedAlgebra.ι R M m₁ ^ n₁) := by
  simp_rw [Commute, SemiconjBy, Prod.forall]
  rintro ⟨i₁, i₂⟩ ⟨j₁, j₂⟩
  rw [← SetLike.mk_mul_mk, ← SetLike.mk_mul_mk, ← SetLike.mk_pow, ← SetLike.mk_pow, ←
    SetLike.mk_pow, ← SetLike.mk_pow]
  exact GradedAlgebra.ι_mul_ι_comm m₁ m₂ i₁ i₂ j₁ j₂

@[simp]
theorem GradedAlgebra.ι_pow_mul_ι_pow_comm' (m₁ m₂ : M) (n₁ n₂ : ℕ) :
    (GradedAlgebra.ι R M m₁ ^ n₁ : _ →ₗ[R] _) * (GradedAlgebra.ι R M m₂ ^ n₂) =
      (GradedAlgebra.ι R M m₂ ^ n₂) * (GradedAlgebra.ι R M m₁ ^ n₁) :=
  LinearMap.congr_fun (GradedAlgebra.ι_pow_mul_ι_pow_comm R M m₁ m₂ n₁ n₂)

@[simp]
theorem GradedAlgebra.ι_pow_mul_ι_pow_comm_of_commute [Nontrivial R]
    {m₁ m₂ : M} {n₁ n₂ : ℕ}
    (h : Commute (GradedAlgebra.ι R M m₁) (GradedAlgebra.ι R M m₂)) :
    (GradedAlgebra.ι R M m₁ ^ n₁) * (GradedAlgebra.ι R M m₂ ^ n₂) =
      (GradedAlgebra.ι R M m₂ ^ n₂) * (GradedAlgebra.ι R M m₁ ^ n₁) := by
  simp_rw [Commute, SemiconjBy, Prod.forall] at h
  rintro ⟨i₁, i₂⟩ ⟨j₁, j₂⟩
  rw [← SetLike.mk_mul_mk, ← SetLike.mk_mul_mk, ← SetLike.mk_pow, ← SetLike.mk_pow, ←
    SetLike.mk_pow, ← SetLike.mk_pow]
  exact h m₁ m₂ i₁ i₂ j₁ j₂

@[simp]
theorem GradedAlgebra.ι_pow_mul_ι_pow_comm_of_commute' [Nontrivial R]
    {m₁ m₂ : M} {n₁ n₂ : ℕ}
    (h : Commute (GradedAlgebra.ι R M m₁) (GradedAlgebra.ι R M m₂)) :
    (GradedAlgebra.ι R M m₁ ^ n₁ : _ →ₗ[R] _) * (GradedAlgebra.ι R M m₂ ^ n₂) =
      (GradedAlgebra.ι R M m₂ ^ n₂) * (GradedAlgebra.ι R M m₁ ^ n₁) :=
  LinearMap.congr_fun (GradedAlgebra.ι_pow_mul_ι_pow_comm_of_commute R M h)

@[simp]
theorem GradedAlgebra.ι_pow_mul_ι_pow_comm_of_commute_aux [Nontrivial R]
    {m₁ m₂ : M} {n₁ n₂ : ℕ}
    (h : Commute (GradedAlgebra.ι R M m₁) (GradedAlgebra.ι R M m₂)) :
    Commute ((GradedAlgebra.ι R M m₁ ^ n₁) : _ →ₗ[R] _) (GradedAlgebra.ι R M m₂ ^ n₂) :=
  LinearMap.congr_fun (GradedAlgebra.ι_pow_mul_ι_pow_comm_of_commute' R M h)

@[simp]
theorem GradedAlgebra.ι_pow_mul_ι_pow_comm_of_commute_aux' [Nontrivial R]
    {m₁ m₂ : M} {n₁ n₂ : ℕ}
    (h : Commute (GradedAlgebra.ι R M m₁) (GradedAlgebra.ι R M m₂)) :
    Commute ((GradedAlgebra.ι R M m₁ ^ n₁) * (GradedAlgebra.ι R M m₂ ^ n₂) : _ →ₗ[R] _)
      ((GradedAlgebra.ι R M m₂ ^ n₂) * (GradedAlgebra.ι R M m₁ ^ n₁) : _ →ₗ[R] _) :=
  LinearMap.congr_fun (GradedAlgebra.ι_pow_mul_ι_pow_comm_of_commute' R M h)

@[simp]
theorem GradedAlgebra.ι_pow_mul_ι_pow_comm_of_commute_aux'' [Nontrivial R]
    {m₁ m₂ : M} {n₁ n₂ : ℕ}
    (h : Commute (GradedAlgebra.ι R M m₁) (GradedAlgebra.ι R M m₂)) :
    Commute ((GradedAlgebra.ι R M m₁ ^ n₁) * (GradedAlgebra.ι R M m₂ ^ n₂) : _ →ₗ[R] _)
      ((GradedAlgebra.ι R M m₂ ^ n₂) * (GradedAlgebra.ι R M m₁ ^ n₁) : _ →ₗ[R

Attempt failure.

Working on Mathlib/LinearAlgebra/FiniteSpan.lean - 2024-09-09 01:52:33.789234.
---111/200---
For theorem LinearEquiv.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo in Mathlib/LinearAlgebra/FiniteSpan.lean:
lemma LinearEquiv.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo
    {R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]
    {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {e : M ≃ₗ[R] M} (he : MapsTo e Φ Φ) :
    IsOfFinOrder e 


Original valid proof:
:= by
  replace he : BijOn e Φ Φ := (hΦ₁.injOn_iff_bijOn_of_mapsTo he).mp e.injective.injOn
  let e' := he.equiv
  have : Finite Φ := finite_coe_iff.mpr hΦ₁
  obtain ⟨k, hk₀, hk⟩ := isOfFinOrder_of_finite e'
  refine ⟨k, hk₀, ?_⟩
  ext m
  have hm : m ∈ span R Φ := hΦ₂ ▸ Submodule.mem_top
  simp only [mul_left_iterate, mul_one, LinearEquiv.coe_one, id_eq]
  refine Submodule.span_induction hm (fun x hx ↦ ?_) (by simp)
    (fun x y hx hy ↦ by simp [map_add, hx, hy]) (fun t x hx ↦ by simp [map_smul, hx])
  rw [LinearEquiv.pow_apply, ← he.1.coe_iterate_restrict ⟨x, hx⟩ k]
  replace hk : (e') ^ k = 1 := by simpa [IsPeriodicPt, IsFixedPt] using hk
  replace hk := Equiv.congr_fun hk ⟨x, hx⟩
  rwa [Equiv.Perm.coe_one, id_eq, Subtype.ext_iff, Equiv.Perm.coe_pow] at hk


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
↔ Finite R e.toLinearMap.ker := by
  classical
  have : ∀ x ∈ Φ, ∃ n : ℕ, e ^ n x = x := fun x hx ↦ he hx ▸ (Commute.all _ _).isOfFinOrder_iterate_self_of_mem_span
  let s : Finset Φ := hΦ₁.toFinset
  have hs : ∀ x ∈ s, ∃ n : ℕ, e ^ n x = x := fun x hx ↦ this x (hΦ₁.mem_toFinset.mp hx)
  have : ∀ x ∈ s, ∃ n : ℕ, e.toLinearMap ^ n x = x := fun x hx ↦ by
    simpa only [LinearEquiv.coe_coe, LinearEquiv.coe_toLinearMap] using hs x hx
  have : ∀ x ∈ s, ∃ n : ℕ, e.toLinearMap ^ n x = 0 := fun x hx ↦ by
    obtain ⟨n, hn⟩ := this x hx
    refine' ⟨n, _⟩
    rw [← sub_eq_zero, ← map_sub, hn, sub_self]
  have : ∀ x ∈ s, ∃ n : ℕ, n ≠ 0 ∧ e.toLinearMap ^ n x = 0 := fun x hx ↦ by
    obtain ⟨n, hn⟩ := this x hx
    refine' ⟨n + 1, Nat.succ_ne_zero _, _⟩
    rw [add_comm, pow_succ', LinearMap.mul_apply, hn, LinearMap.map_zero]
  choose! n hn₁ hn₂ using this
  have : ∀ x ∈ s, ∃ m : ℕ, m ≠ 0 ∧ e.toLinearMap ^ m x = 0 ∧ ∀ k < m, e.toLinearMap ^ k x ≠ 0 := by
    intro x hx
    refine' ⟨n x, hn₁ x hx, hn₂ x hx, fun k hk ↦ _⟩
    obtain ⟨m, rfl⟩ := Nat.exists_eq_succ_of_ne_zero hn₁ x hx
    rw [pow_succ', LinearMap.mul_apply, hn₂ x hx, LinearMap.map_zero]
    exact fun h ↦ hk <| Nat.lt_succ_self _
  choose! m hm₁ hm₂ hm₃ using this
  have : ∀ x ∈ s, m x ∣ Fintype.card s := fun x hx ↦ by
    have : LinearMap.ker (e.toLinearMap ^ m x) ≠ ⊥ := by
      intro h
      have : e.toLinearMap ^ m x x = 0 := by simpa only [LinearMap.mem_ker, LinearMap.pow_apply] using h
      exact hn₁ x hx (hm₂ x hx).symm
    obtain ⟨k, hk⟩ := (Submodule.ne_bot_iff _).mp this
    have : k ≠ 0 := by
      rintro rfl
      simp only [pow_zero, LinearMap.one_apply, ne_eq, one_ne_zero] at hk
    refine' ⟨Fintype.card s / m x, _⟩
    rw [Nat.mul_div_cancel' (hm₃ x hx k hk), pow_mul, LinearMap.pow_card_pow_apply_eq_self]
  have : ∀ x ∈ s, m x ∣ Fintype.card s := by
    intro x hx
    obtain ⟨k, hk⟩ := (Submodule.ne_bot_iff _).mp (hm₁ x hx).bot_lt.ne'
    have : k ≠ 0 := by
      rintro rfl
      simp only [pow_zero, LinearMap.one_apply, ne_eq, one_ne_zero] at hk
    refine' ⟨Fintype.card s / m x, _⟩
    rw [Nat.mul_div_cancel' (hm₃ x hx k hk), pow_mul, LinearMap.pow_card_pow_apply_eq_self]
  have : ∀ x ∈ s, m x ∣ Fintype.card Φ := by
    intro x hx
    obtain ⟨k, hk⟩ := (Submodule.ne_bot_iff _).mp (hm₁ x hx).bot_lt.ne'
    have : k ≠ 0 := by
      rintro rfl
      simp only [pow_zero, LinearMap.one_apply, ne_eq, one_ne_zero] at hk
    refine' ⟨Fintype.card Φ / m x, _⟩
    rw [Nat.mul_div_cancel' (this x hx), pow_mul, LinearMap.pow_card_pow_apply_eq_self]
  have : ∀ x ∈ s, m x ∣ Fintype.card M := by
    intro x hx
    obtain ⟨k, hk⟩ := (Submodule.ne_bot_iff _).mp (hm₁ x hx).bot_lt.ne'
    have : k ≠ 0 := by
      rintro rfl
      simp only [pow_zero, LinearMap.one_apply, ne_eq, one_ne_zero] at hk
    refine' ⟨Fintype.card M / m x, _⟩
    rw [Nat.mul_div_cancel' (this x hx), pow_mul, LinearMap.pow_card_pow_apply_eq_self]
  have : ∀ x ∈ s, m x ∣ Finite.card R := by
    intro x hx
    obtain ⟨k, hk⟩ := (Submodule.ne_bot_iff _).mp (hm₁ x hx).bot_lt.ne'
    have : k ≠ 0 := by
      rintro rfl
      simp only [pow_zero, LinearMap.one_apply, ne_eq, one_ne_zero] at hk
    refine' ⟨Finite.card R / m x, _⟩
    rw [Nat.mul_div_cancel' (this x hx), pow_mul, LinearMap.pow_card_pow_apply_eq_self]
  have : ∀ x ∈ s, m x ∣ Finite.card Φ := by
    intro x hx
    obtain ⟨k, hk⟩ := (Submodule.ne_bot_iff _).mp (hm₁ x hx).bot_lt.ne'
    have : k ≠ 0 := by
      rintro rfl
      simp only [pow_zero, LinearMap.one_apply, ne_eq, one_ne_zero] at hk
    refine' ⟨Finite.card Φ / m x, _⟩
    rw [Nat.mul_div_cancel' (this x hx), pow_mul, LinearMap.pow_card_pow_apply_eq_self]
  have : ∀ x ∈ s, m x ∣ Finite.card M := by
    intro x hx
    obtain ⟨k, hk⟩ := (Submodule.ne_bot_iff _).mp (hm₁ x hx).bot_lt.ne'
    have : k ≠ 0 := by
      rintro rfl
      simp only [pow_zero, LinearMap.one_apply, ne_eq, one_ne_zero] at hk
    refine' ⟨Finite.card M / m x, _⟩
    rw [Nat.mul_div_cancel' (this x hx), pow_mul, LinearMap.pow_card_pow_apply_eq_self]
  have : ∀ x ∈ s, m x ∣ Finite.card R := by
    intro x hx
    obtain ⟨k, hk⟩ := (Submodule.ne_bot_iff _).mp (hm₁ x hx).bot_lt.ne'
    have : k ≠ 0 := by
      rintro rfl
      simp only [pow_zero, LinearMap.one_apply, ne_eq, one_ne_zero] at hk
    refine' ⟨Finite.card R / m x, _⟩
    rw [Nat.mul_div_cancel' (this x hx),

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/PosDef.lean - 2024-09-09 01:52:39.579346.
---112/200---
For theorem Matrix.PosDef.posSemidef in Mathlib/LinearAlgebra/Matrix/PosDef.lean:
lemma posSemidef_diagonal_iff [DecidableEq n] {d : n → R} :
    PosSemidef (diagonal d) ↔ (∀ i : n, 0 ≤ d i) 


Original valid proof:
:= by
  refine ⟨fun ⟨_, hP⟩ i ↦ by simpa using hP (Pi.single i 1), ?_⟩
  refine fun hd ↦ ⟨isHermitian_diagonal_iff.2 fun i ↦ IsSelfAdjoint.of_nonneg (hd i), ?_⟩
  refine fun x ↦ Finset.sum_nonneg fun i _ ↦ ?_
  simpa only [mulVec_diagonal, mul_assoc] using conjugate_nonneg (hd i) _


Verifying proof (Commit 80e6f5c2c6129e22f25d259eb3a6b63416337071):
∧ ∀ i j : n, d i * d j ≤ d (i + j) * d (i + j) := by
  refine ⟨fun ⟨h₁, h₂⟩ ↦ ⟨fun i ↦ ?_, fun i j ↦ ?_⟩, fun ⟨h₁, h₂⟩ ↦ ⟨fun i j ↦ ?_, fun i j k ↦ ?_⟩⟩
  · simpa only [mul_one] using h₁ i i
  · simpa only [mul_one] using h₂ i j i
  · simpa only [mul_one] using h₁ i
  · simpa only [mul_one] using h₂ i j k

Reparameterization lemma:

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization lemma for the lower bound.

Reparameterization lemma for the upper bound.

Reparameterization

Attempt failure.

Working on Mathlib/LinearAlgebra/Reflection.lean - 2024-09-09 01:52:55.343891.
---113/200---
For theorem Module.Dual.eq_of_preReflection_mapsTo in Mathlib/LinearAlgebra/Reflection.lean:
lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x ≠ 0) {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {f g : Dual R M}
    (hf₁ : f x = 2) (hf₂ : MapsTo (preReflection x f) Φ Φ)
    (hg₁ : g x = 2) (hg₂ : MapsTo (preReflection x g) Φ Φ) :
    f = g 


Original valid proof:
:= by
  let u := reflection hg₁ * reflection hf₁
  have hu : u = LinearMap.id (R := R) (M := M) + (f - g).smulRight x := by
    ext y
    simp only [u, reflection_apply, hg₁, two_smul, LinearEquiv.coe_toLinearMap_mul,
      LinearMap.id_coe, LinearEquiv.coe_coe, LinearMap.mul_apply, LinearMap.add_apply, id_eq,
      LinearMap.coe_smulRight, LinearMap.sub_apply, map_sub, map_smul, sub_add_cancel_left,
      smul_neg, sub_neg_eq_add, sub_smul]
    abel
  replace hu : ∀ (n : ℕ),
      ↑(u ^ n) = LinearMap.id (R := R) (M := M) + (n : R) • (f - g).smulRight x := by
    intros n
    induction n with
    | zero => simp
    | succ n ih =>
      have : ((f - g).smulRight x).comp ((n : R) • (f - g).smulRight x) = 0 := by
        ext; simp [hf₁, hg₁]
      rw [pow_succ', LinearEquiv.coe_toLinearMap_mul, ih, hu, add_mul, mul_add, mul_add]
      simp_rw [LinearMap.mul_eq_comp, LinearMap.comp_id, LinearMap.id_comp, this, add_zero,
        add_assoc, Nat.cast_succ, add_smul, one_smul]
  suffices IsOfFinOrder u by
    obtain ⟨n, hn₀, hn₁⟩ := isOfFinOrder_iff_pow_eq_one.mp this
    replace hn₁ : (↑(u ^ n) : M →ₗ[R] M) = LinearMap.id := LinearEquiv.toLinearMap_inj.mpr hn₁
    simpa [hn₁, hn₀.ne', hx, sub_eq_zero] using hu n
  exact u.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo hΦ₁ hΦ₂ (hg₂.comp hf₂)


Verifying proof (Commit 05dd33777bb0a96c66523df7c7d1a34b2d9a1be5):
∨ f = -g := by
  have hf₁' : f x = 2 := hf₁
  have hg₁' : g x = 2 := hg₁
  have hfg : f = g ∨ f = -g :=
    eq_or_eq_neg_of_preReflection_mapsTo_of_ne_zero hx hΦ₁ hΦ₂ hf₁' hf₂ hg₁' hg₂
  simpa only [eq_comm, ← sub_eq_zero, neg_sub] using hfg

Repaired Proof:
lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x ≠ 0) {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {f g : Dual R M}
    (hf₁ : f x = 2) (hf₂ : MapsTo (preReflection x f) Φ Φ)
    (hg₁ : g x = 2) (hg₂ : MapsTo (preReflection x g) Φ Φ) :
    f = g ∨ f = -g := by
  have hf₁' : f x = 2 := hf₁
  have hg₁' : g x = 2 := hg₁
  have hfg : f = g ∨ f = -g :=
    eq_or_eq_neg_of_preReflection_mapsTo_of_ne_zero hx hΦ₁ hΦ₂ hf₁' hf₂ hg₁' hg₂
  simpa only [eq_comm, ← sub_eq_zero, neg_sub] using hfg

Repaired Proof:
lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x ≠ 0) {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {f g : Dual R M}
    (hf₁ : f x = 2) (hf₂ : MapsTo (preReflection x f) Φ Φ)
    (hg₁ : g x = 2) (hg₂ : MapsTo (preReflection x g) Φ Φ) :
    f = g ∨ f = -g := by
  have hf₁' : f x = 2 := hf₁
  have hg₁' : g x = 2 := hg₁
  have hfg : f = g ∨ f = -g :=
    eq_or_eq_neg_of_preReflection_mapsTo_of_ne_zero hx hΦ₁ hΦ₂ hf₁' hf₂ hg₁' hg₂
  simpa only [eq_comm, ← sub_eq_zero, neg_sub] using hfg

Repaired Proof:
lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x ≠ 0) {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {f g : Dual R M}
    (hf₁ : f x = 2) (hf₂ : MapsTo (preReflection x f) Φ Φ)
    (hg₁ : g x = 2) (hg₂ : MapsTo (preReflection x g) Φ Φ) :
    f = g ∨ f = -g := by
  have hf₁' : f x = 2 := hf₁
  have hg₁' : g x = 2 := hg₁
  have hfg : f = g ∨ f = -g :=
    eq_or_eq_neg_of_preReflection_mapsTo_of_ne_zero hx hΦ₁ hΦ₂ hf₁' hf₂ hg₁' hg₂
  simpa only [eq_comm, ← sub_eq_zero, neg_sub] using hfg

Repaired Proof:
lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x ≠ 0) {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {f g : Dual R M}
    (hf₁ : f x = 2) (hf₂ : MapsTo (preReflection x f) Φ Φ)
    (hg₁ : g x = 2) (hg₂ : MapsTo (preReflection x g) Φ Φ) :
    f = g ∨ f = -g := by
  have hf₁' : f x = 2 := hf₁
  have hg₁' : g x = 2 := hg₁
  have hfg : f = g ∨ f = -g :=
    eq_or_eq_neg_of_preReflection_mapsTo_of_ne_zero hx hΦ₁ hΦ₂ hf₁' hf₂ hg₁' hg₂
  simpa only [eq_comm, ← sub_eq_zero, neg_sub] using hfg

Repaired Proof:
lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x ≠ 0) {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {f g : Dual R M}
    (hf₁ : f x = 2) (hf₂ : MapsTo (preReflection x f) Φ Φ)
    (hg₁ : g x = 2) (hg₂ : MapsTo (preReflection x g) Φ Φ) :
    f = g ∨ f = -g := by
  have hf₁' : f x = 2 := hf₁
  have hg₁' : g x = 2 := hg₁
  have hfg : f = g ∨ f = -g :=
    eq_or_eq_neg_of_preReflection_mapsTo_of_ne_zero hx hΦ₁ hΦ₂ hf₁' hf₂ hg₁' hg₂
  simpa only [eq_comm, ← sub_eq_zero, neg_sub] using hfg

Repaired Proof:
lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x ≠ 0) {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {f g : Dual R M}
    (hf₁ : f x = 2) (hf₂ : MapsTo (preReflection x f) Φ Φ)
    (hg₁ : g x = 2) (hg₂ : MapsTo (preReflection x g) Φ Φ) :
    f = g ∨ f = -g := by
  have hf₁' : f x = 2 := hf₁
  have hg₁' : g x = 2 := hg₁
  have hfg : f = g ∨ f = -g :=
    eq_or_eq_neg_of_preReflection_mapsTo_of_ne_zero hx hΦ₁ hΦ₂ hf₁' hf₂ hg₁' hg₂
  simpa only [eq_comm, ← sub_eq_zero, neg_sub] using hfg

Repaired Proof:
lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x ≠ 0) {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {f g : Dual R M}
    (hf₁ : f x = 2) (hf₂ : MapsTo (preReflection x f) Φ Φ)
    (hg₁ : g x = 2) (hg₂ : MapsTo (preReflection x g) Φ Φ) :
    f = g ∨ f = -g := by
  have hf₁' : f x = 2 := hf₁
  have hg₁' : g x = 2 := hg₁
  have hfg : f = g ∨ f = -g :=
    eq_or_eq_neg_of_preReflection_maps

Attempt failure.

Working on Mathlib/LinearAlgebra/TensorProduct/Matrix.lean - 2024-09-09 01:53:05.225453.
---114/200---
For theorem TensorProduct.toMatrix_comm in Mathlib/LinearAlgebra/TensorProduct/Matrix.lean:
theorem TensorProduct.toMatrix_comm :
    toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM) (TensorProduct.comm R M N) =
      (1 : Matrix (ι × κ) (ι × κ) R).submatrix Prod.swap _root_.id 


Original valid proof:
:= by
  ext ⟨i, j⟩ ⟨i', j'⟩
  simp_rw [toMatrix_apply, Basis.tensorProduct_apply, LinearEquiv.coe_coe, TensorProduct.comm_tmul,
    Basis.tensorProduct_repr_tmul_apply, Matrix.submatrix_apply, Basis.repr_self,
    Finsupp.single_apply, @eq_comm _ j', @eq_comm _ i', mul_ite, mul_one, mul_zero,
    Matrix.one_apply, Prod.swap_prod_mk, _root_.id, Prod.ext_iff, ite_and]


Verifying proof (Commit a37325ba17db4b8735587123d2388c63923a3605):
∘ₘ (1 : Matrix ι κ R) := by
  ext ⟨i, j⟩ ⟨i', j'⟩
  simp_rw [Matrix.submatrix_apply, Matrix.one_apply, Matrix.mul_apply, Matrix.of_apply,
    toMatrix_apply, Basis.tensorProduct_apply, Basis.tensorProduct_repr_tmul_apply,
    Basis.repr_self, Finsupp.single_apply, Prod.exists, comp_apply, LinearEquiv.coe_coe,
    TensorProduct.comm_tmul]
  constructor
  · rintro ⟨x, rfl, rfl⟩
    simp_rw [Finsupp.sum_single_index, Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq,
      ite_not]
    split_ifs with h
    · simp [Finsupp.single_apply, h]
    · simp [Finsupp.single_apply, h]
  · rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩) <;> simp

Repaired Proof:
theorem TensorProduct.toMatrix_comm :
    toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM) (TensorProduct.comm R M N) =
      (1 : Matrix (ι × κ) (ι × κ) R).submatrix Prod.swap _root_.id ∘ₘ (1 : Matrix ι κ R) := by
  ext ⟨i, j⟩ ⟨i', j'⟩
  simp_rw [Matrix.submatrix_apply, Matrix.one_apply, Matrix.mul_apply, Matrix.of_apply,
    toMatrix_apply, Basis.tensorProduct_apply, Basis.tensorProduct_repr_tmul_apply,
    Basis.repr_self, Finsupp.single_apply, Prod.exists, comp_apply, LinearEquiv.coe_coe,
    TensorProduct.comm_tmul]
  constructor
  · rintro ⟨x, rfl, rfl⟩
    simp_rw [Finsupp.sum_single_index, Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq,
      ite_not]
    split_ifs with h
    · simp [Finsupp.single_apply, h]
    · simp [Finsupp.single_apply, h]
  · rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩) <;> simp

Repaired Proof:
theorem TensorProduct.toMatrix_comm :
    toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM) (TensorProduct.comm R M N) =
      (1 : Matrix (ι × κ) (ι × κ) R).submatrix Prod.swap _root_.id ∘ₘ (1 : Matrix ι κ R) := by
  ext ⟨i, j⟩ ⟨i', j'⟩
  simp_rw [Matrix.submatrix_apply, Matrix.one_apply, Matrix.mul_apply, Matrix.of_apply,
    toMatrix_apply, Basis.tensorProduct_apply, Basis.tensorProduct_repr_tmul_apply,
    Basis.repr_self, Finsupp.single_apply, Prod.exists, comp_apply, LinearEquiv.coe_coe,
    TensorProduct.comm_tmul]
  constructor
  · rintro ⟨x, rfl, rfl⟩
    simp_rw [Finsupp.sum_single_index, Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq,
      ite_not]
    split_ifs with h
    · simp [Finsupp.single_apply, h]
    · simp [Finsupp.single_apply, h]
  · rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩) <;> simp

Repaired Proof:
theorem TensorProduct.toMatrix_comm :
    toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM) (TensorProduct.comm R M N) =
      (1 : Matrix (ι × κ) (ι × κ) R).submatrix Prod.swap _root_.id ∘ₘ (1 : Matrix ι κ R) := by
  ext ⟨i, j⟩ ⟨i', j'⟩
  simp_rw [Matrix.submatrix_apply, Matrix.one_apply, Matrix.mul_apply, Matrix.of_apply,
    toMatrix_apply, Basis.tensorProduct_apply, Basis.tensorProduct_repr_tmul_apply,
    Basis.repr_self, Finsupp.single_apply, Prod.exists, comp_apply, LinearEquiv.coe_coe,
    TensorProduct.comm_tmul]
  constructor
  · rintro ⟨x, rfl, rfl⟩
    simp_rw [Finsupp.sum_single_index, Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq,
      ite_not]
    split_ifs with h
    · simp [Finsupp.single_apply, h]
    · simp [Finsupp.single_apply, h]
  · rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩) <;> simp

Repaired Proof:
theorem TensorProduct.toMatrix_comm :
    toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM) (TensorProduct.comm R M N) =
      (1 : Matrix (ι × κ) (ι × κ) R).submatrix Prod.swap _root_.id ∘ₘ (1 : Matrix ι κ R) := by
  ext ⟨i, j⟩ ⟨i', j'⟩
  simp_rw [Matrix.submatrix_apply, Matrix.one_apply, Matrix.mul_apply, Matrix.of_apply,
    toMatrix_apply, Basis.tensorProduct_apply, Basis.tensorProduct_repr_tmul_apply,
    Basis.repr_self, Finsupp.single_apply, Prod.exists, comp_apply, LinearEquiv.coe_coe,
    TensorProduct.comm_tmul]
  constructor
  · rintro ⟨x, rfl, rfl⟩
    simp_rw [Finsupp.sum_single_index, Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq,
      ite_not]
    split_ifs with h
    · simp [Finsupp.single_apply, h]
    · simp [Finsupp.single_apply, h]
  · rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩) <;> simp

Repaired Proof:
theorem TensorProduct.toMatrix_comm :
    toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM) (TensorProduct.comm R M N) =
      (1 : Matrix (ι × κ) (ι × κ) R).submatrix Prod.swap _root_.id ∘ₘ (1 : Matrix ι κ R) := by
  ext ⟨i, j⟩ ⟨i', j'⟩
  simp_rw [Matrix.submatrix_apply, Matrix.one_apply, Matrix.mul_apply, Matrix.of_apply,
    toMatrix_apply, Basis.tensorProduct_apply, Basis.tensorProduct_repr_tmul_apply,
    Basis.repr_self, Finsupp.single_apply, Prod.exists, comp_apply, LinearEquiv.coe_coe,
    TensorProduct.comm_tmul]
  constructor
  · rintro ⟨x, rfl, rfl⟩
    simp_rw [Finsupp.sum_single_index, Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq,
      ite_not]
    split_ifs with h
    · simp [Finsupp.single_apply, h]
    · simp [Finsupp.single_apply, h]
  · rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩) <;> simp

Repaired Proof:
theorem TensorProduct.toMatrix_comm :
    toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM) (TensorProduct.comm R M N) =
      (1 : Matrix (ι × κ) (ι × κ) R).submatrix Prod.swap _root_.id ∘ₘ (1 : Matrix ι κ R) := by
  ext

Attempt failure.

Working on Mathlib/LinearAlgebra/TensorProduct/Vanishing.lean - 2024-09-09 01:53:14.686830.
---115/200---
For theorem TensorProduct.vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective in Mathlib/LinearAlgebra/TensorProduct/Vanishing.lean:
theorem vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective
    (hm : Injective (rTensor N (span R (Set.range m)).subtype))
    (hmn : ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N)) : VanishesTrivially R m n 


Original valid proof:
:= by
  have mem_M' i : m i ∈ span R (Set.range m) := subset_span ⟨i, rfl⟩
  set m' : ι → span R (Set.range m) := Subtype.coind m mem_M' with m'_eq
  have hm' : span R (Set.range m') = ⊤ := by
    apply map_injective_of_injective (injective_subtype (span R (Set.range m)))
    rw [Submodule.map_span, Submodule.map_top, range_subtype, coeSubtype, ← Set.range_comp]
    rfl
  have hm'n : ∑ i, m' i ⊗ₜ n i = (0 : span R (Set.range m) ⊗[R] N) := by
    apply hm
    simp only [m'_eq, map_sum, rTensor_tmul, coeSubtype, Subtype.coind_coe, _root_.map_zero, hmn]
  have : VanishesTrivially R m' n := vanishesTrivially_of_sum_tmul_eq_zero R hm' hm'n
  unfold VanishesTrivially at this ⊢
  convert this with κ _ a y j
  convert (injective_iff_map_eq_zero' _).mp (injective_subtype (span R (Set.range m))) _
  simp [m'_eq]


Verifying proof (Commit 53ef4ce0bcf22cccd58030d7502519c16120d7e5):
↔
      span R (Set.range m) ⊓ (span R (Set.range n) : Submodule R N) = ⊥ := by
  constructor
  · intro hm'
    suffices (span R (Set.range m) ⊓ (span R (Set.range n) : Submodule R N)).subtype
        ⟨0, (span R (Set.range m)).zero_mem⟩ = 0 by
      rw [← this, Submodule.subtype_apply]
      exact (Submodule.mk_eq_zero _).mp rfl
    rw [Submodule.zero_mem, Submodule.mem_inf]
    refine' ⟨Submodule.zero_mem _, _⟩
    rw [← hmn, ← Submodule.span_tmul_eq_top_of_vanishesTrivially hm' R]
    exact Submodule.subset_span (Set.mem_range_self _)
  · intro hmn'
    intro x
    rw [Submodule.mem_bot] at hmn'
    intro hx
    rw [Submodule.mem_inf] at hmn'
    rw [Submodule.mem_span_singleton] at hx
    rcases hx with ⟨y, rfl⟩
    rw [TensorProduct.tmul_zero, Submodule.zero_mem]
    rw [Submodule.mem_span_singleton] at hmn'
    rcases hmn' with ⟨z, rfl⟩
    rw [Submodule.mem_span_singleton]
    use y ⊗ₜ[R] z
    rw [← TensorProduct.smul_tmul']
    rw [← TensorProduct.smul_tmul']
    rw [← TensorProduct.smul_tmul']
    rw [← TensorProduct.smul_tmul']
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_smul]
    rw [TensorProduct.tmul_

Attempt failure.

Working on Mathlib/Logic/Equiv/Set.lean - 2024-09-09 01:53:26.693284.
---116/200---
For theorem Equiv.swap_bijOn_self in Mathlib/Logic/Equiv/Set.lean:
theorem Equiv.swap_bijOn_self (hs : a ∈ s ↔ b ∈ s) : BijOn (Equiv.swap a b) s s 


Original valid proof:
:= by
  refine ⟨fun x hx ↦ ?_, (Equiv.injective _).injOn, fun x hx ↦ ?_⟩
  · obtain (rfl | hxa) := eq_or_ne x a
    · rwa [swap_apply_left, ← hs]
    obtain (rfl | hxb) := eq_or_ne x b
    · rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a
  · simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b
  · simp [hs.2 hx]
  exact ⟨x, hx, swap_apply_of_ne_of_ne hxa hxb⟩


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
↔ a ∈ s ↔ b ∈ s :=
  BijOn.iff_perm_bijOn.symm.trans $
    (perm_swap_involutive a b).bijOn_iff_involutiveOn_comp_surjOn (perm_swap_involutive a b)
      (perm_swap_involutive a b).surjectiveOn (hs.map _)

Repaired Proof:
theorem Equiv.swap_bijOn_self (hs : a ∈ s ↔ b ∈ s) : BijOn (Equiv.swap a b) s s ↔ a ∈ s ↔ b ∈ s :=
  BijOn.iff_perm_bijOn.symm.trans $
    (perm_swap_involutive a b).bijOn_iff_involutiveOn_comp_surjOn (perm_swap_involutive a b)
      (perm_swap_involutive a b).surjectiveOn (hs.map _)

Repaired Proof:
theorem Equiv.swap_bijOn_self (hs : a ∈ s ↔ b ∈ s) : BijOn (Equiv.swap a b) s s ↔ a ∈ s ↔ b ∈ s :=
  BijOn.iff_perm_bijOn.symm.trans $
    (perm_swap_involutive a b).bijOn_iff_involutiveOn_comp_surjOn (perm_swap_involutive a b)
      (perm_swap_involutive a b).surjectiveOn (hs.map _)

Repaired Proof:
theorem Equiv.swap_bijOn_self (hs : a ∈ s ↔ b ∈ s) : BijOn (Equiv.swap a b) s s ↔ a ∈ s ↔ b ∈ s :=
  BijOn.iff_perm_bijOn.symm.trans $
    (perm_swap_involutive a b).bijOn_iff_involutiveOn_comp_surjOn (perm_swap_involutive a b)
      (perm_swap_involutive a b).surjectiveOn (hs.map _)

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean - 2024-09-09 01:53:31.505523.
---117/200---
For theorem measurable_of_tendsto_metrizable' in Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g 


Original valid proof:
:= by
  letI : PseudoMetricSpace β := pseudoMetrizableSpacePseudoMetric β
  apply measurable_of_isClosed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices Tendsto (fun i x => infNndist (f i x) s) u (𝓝 fun x => infNndist (g x) s) from
      NNReal.measurable_of_tendsto' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim ⊢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g ⁻¹' s = (fun x => infNndist (g x) s) ⁻¹' {0} := by
    ext x
    simp [h1s, ← h1s.mem_iff_infDist_zero h2s, ← NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans hn))

Repaired Proof:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g ∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans hn))

Repaired Proof:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g ∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans hn))

Repaired Proof:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g ∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans hn))

Repaired Proof:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g ∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans hn))

Repaired Proof:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g ∧ ∀ s, MeasurableSet s → ∀ᶠ i in u, Closure (f i ⁻¹' s) ⊆ g ⁻¹' s := by
  rcases u.exists_seq_tendsto with ⟨v, hv⟩
  have h_meas : ∀ n, Measurable (f (v n)) := fun n => hf (v n)
  have h_lim : Tendsto f v (𝓝 g) := Tendsto.comp lim hv
  refine ⟨measurable_of_tendsto_metrizable h_meas h_lim, ?_⟩
  intro s hs
  have h_preim : ∀ n, MeasurableSet (f (v n) ⁻¹' s) := fun n => (h_meas n).measurableSet_preimage hs
  filter_upwards [tendsto_atTop'.mp hv s hs, tendsto_atTop'.mp hv s hs] with n hn h'n
  rw [← hn, ← h'n]
  exact closure_mono (preimage_mono (subset_closure.trans

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Differentiation.lean - 2024-09-09 01:53:38.931986.
---118/200---
For theorem VitaliFamily.measure_le_mul_of_subset_limRatioMeas_lt in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem measure_le_mul_of_subset_limRatioMeas_lt {p : ℝ≥0} {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x < p}) : ρ s ≤ p * μ s 


Original valid proof:
:= by
  let t := {x : α | Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (v.limRatioMeas hρ x))}
  have A : μ tᶜ = 0 := v.ae_tendsto_limRatioMeas hρ
  suffices H : ρ (s ∩ t) ≤ (p • μ) (s ∩ t) by calc
    ρ s = ρ (s ∩ t ∪ s ∩ tᶜ) := by rw [inter_union_compl]
    _ ≤ ρ (s ∩ t) + ρ (s ∩ tᶜ) := measure_union_le _ _
    _ ≤ (p • μ) (s ∩ t) + ρ tᶜ := by gcongr; apply inter_subset_right
    _ ≤ p * μ (s ∩ t) := by simp [(hρ A)]
    _ ≤ p * μ s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le (p • μ) hρ _ fun x hx => ?_
  have I : ∀ᶠ b : Set α in v.filterAt x, ρ b / μ b < p := (tendsto_order.1 hx.2).2 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  refine (ENNReal.div_le_iff_le_mul ?_ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le
  simp only [ENNReal.coe_ne_top, Ne, or_true_iff, not_false_iff]


Verifying proof (Commit 2c23e43ba179a9dd2928e06c32f043d20e9798c8):
↔ μ s = 0 ∨ p = ∞ := by
  rcases eq_or_ne (μ s) 0 with (hμ | hμ); · simp [hμ]
  simp only [hμ, or_false, le_iff_eq_or_lt, mul_eq_top, false_or_iff, ENNReal.mul_eq_top, hμ,
    or_false]
  by_cases hp : p = ∞
  · simp [hp]
  lift p to ℝ≥0 using hp
  simp only [true_and_iff, Ne, ENNReal.coe_ne_top, and_true_iff, mul_eq_top, hμ,
    false_or_iff, ENNReal.coe_eq_zero, ENNReal.coe_lt_coe, lt_top_iff_ne_top,
    ENNReal.coe_ne_top, or_false_iff, mul_eq_zero, ENNReal.coe_eq_zero]
  have : ∀ᵐ x ∂ρ, x ∈ s → v.limRatioMeas hρ x < p := ae_imp_of_ae_restrict h
  have : ∀ᵐ x ∂ρ, x ∈ s → v.limRatioMeas hρ x < ↑p :=
    (ae_restrict_iff' (ρ s)).mp (this.mono fun _ hx _ ↦ hx)
  have : ∀ᵐ x ∂ρ, x ∈ s → ∀ᶠ y in 𝓝 x, ∀ᵉ (ε : ℝ≥0), ε ∈ Ioc 0 1 →
      v.limRatioMeas hρ y < ↑p + ε := by
    filter_upwards [this] with x hx xs hx'
    refine' (v.tendsto_limRatioMeas_nhds hρ x).eventually (eventually_nhds_iff.2 _)
    rcases hx' with ⟨y, ys, hxy⟩
    rcases mem_nhds_iff.1 ys with ⟨o, o_open, yo, os⟩
    rcases mem_nhds_iff.1 (isOpen_Iio.mem_nhds hxy) with ⟨ε, ε_pos, hε⟩
    refine' ⟨_, isOpen_Iio.mem_nhds (hx _ xs), fun z hz ↦ ⟨_, ⟨_, hε hz, rfl⟩, _⟩⟩
    rcases ENNReal.lt_iff_exists_add_pos_lt.1 hz with ⟨δ, δ_pos, hδ⟩
    have : Ioo (v.limRatioMeas hρ x - δ) (v.limRatioMeas hρ x) ⊆ Iio (↑p + ε) := by
      simp only [sub_lt_self_iff, Ioo_subset_Iio_self, add_pos_iff, true_or_iff, ENNReal.coe_pos]
      exact Or.inl (lt_add_of_pos_right _ ε_pos)
    refine' ⟨min δ 1, lt_min δ_pos zero_lt_one, _, _⟩
    · simp only [lt_min_iff, mem_Ioo, sub_lt_self_iff, true_and_iff, and_true_iff, ENNReal.coe_pos,
        hx _ xs, or_true_iff]
      exact ⟨ENNReal.coe_lt_coe.2 (lt_add_of_pos_right _ ε_pos),
        ENNReal.coe_lt_coe.2 (lt_add_of_pos_right _ ε_pos)⟩
    · refine' (v.limRatioMeas_le_of_mem_o hρ _ _ yo os).trans_lt _
      simp only [min_le_iff, le_add_iff_nonneg_right, zero_le', true_or_iff, ENNReal.coe_pos,
        ENNReal.coe_lt_coe]
      exact Or.inl (ENNReal.coe_lt_coe.2 (lt_add_of_pos_right _ ε_pos))
  rcases eq_or_lt_of_le (zero_le p) with (rfl | hp')
  · simp only [true_and_iff, ENNReal.coe_zero, zero_add, Ioc_self, mem_empty_iff_false,
      eventually_false, eventually_and, eventually_const, imp_false, min_eq_left,
      min_eq_right zero_le', and_false_iff, false_or_iff]
    simp only [ae_iff, not_forall, exists_prop, not_imp_not]
    simp only [and_imp, exists_prop] at this
    rcases this with ⟨x, xs, hx, h'x⟩
    refine' ⟨x, xs, _, hx.le, _⟩
    · simp only [true_and_iff, mem_setOf_eq]
      rcases h'x with ⟨y, ys, hxy⟩
      exact ⟨y, ys, hxy⟩
    · simp only [true_and_iff, mem_setOf_eq]
      rcases h'x with ⟨y, ys, hxy⟩
      exact ⟨y, ys, hxy⟩
  · have : ∀ᵐ x ∂ρ, x ∈ s → ∀ᶠ y in 𝓝 x, ∀ᵉ (ε : ℝ≥0), ε ∈ Ioc (0 : ℝ≥0) 1 →
        ↑p + ε ≤ v.limRatioMeas hρ y := by
      filter_upwards [this] with x hx xs hx'
      refine (v.tendsto_limRatioMeas_nhds hρ x).eventually (eventually_nhds_iff.2 ?_)
      rcases hx' with ⟨y, ys, hxy⟩
      rcases mem_nhds_iff.1 (isOpen_Ioi.mem_nhds hxy) with ⟨ε, ε_pos, hε⟩
      refine ⟨_, isOpen_Ioi.mem_nhds (hx _ xs), fun z hz ↦ ⟨_, ⟨_, hε hz, rfl⟩, ?_⟩⟩
      rcases ENNReal.add_lt_add_iff_left (ENNReal.coe_pos.2 hp'.ne').ne.symm
          (ENNReal.coe_ne_top : ↑p ≠ ∞) with
        ⟨δ, δ_pos, hδ⟩
      have : Ioo (v.limRatioMeas hρ x - δ) (v.limRatioMeas hρ x) ⊆ Ioi ↑p := by
        simp only [sub_lt_self_iff, Ioo_subset_Ioi_self, add_pos_iff, true_or_iff, ENNReal.coe_pos]
        exact Or.inl (lt_add_of_pos_right _ ε_pos)
      refine ⟨min δ 1, lt_min δ_pos zero_lt_one, ?_, ?_⟩
      · simp only [lt_min_iff, mem_Ioo, sub_lt_self_iff, true_and_iff, and_true_iff, ENNReal.coe_pos,
          hx _ xs, or_true_iff]
        exact ⟨ENNReal.coe_lt_coe.2 (lt_add_of_pos_right _ ε_pos),
          ENNReal.coe_lt_coe.2 (lt_add_of_pos_right _ ε_pos)⟩
      · refine (v.limRatioMeas_le_of_mem_o hρ _ _ yo os).trans_le ?_
        simp only [min_le_iff, le_add_iff_nonneg_right, zero_le', true_or_iff, ENNReal.coe_pos,
          ENNReal.coe_lt_coe]
        exact Or.inl (ENNReal.coe_lt_coe.2 (lt_add_of_pos_right _ ε_pos))
    rcases ae_imp_of_ae_restrict this with ⟨x, xs, hx, h'x⟩
    refine ⟨x, xs, ?_, hx.le, ?_⟩
    · simp only [true_and_iff, mem_setOf_eq]
      r

Attempt failure.

Working on Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean - 2024-09-09 01:53:52.682794.
---119/200---
For theorem MeasureTheory.Measure.rnDeriv_withDensity_right_of_absolutelyContinuous in Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean:
lemma rnDeriv_withDensity_right_of_absolutelyContinuous {ν : Measure α} [SigmaFinite μ]
    [SigmaFinite ν] (hμν : μ ≪ ν) (hf : AEMeasurable f ν)
    (hf_ne_zero : ∀ᵐ x ∂ν, f x ≠ 0) (hf_ne_top : ∀ᵐ x ∂ν, f x ≠ ∞) :
    μ.rnDeriv (ν.withDensity f) =ᵐ[ν] fun x ↦ (f x)⁻¹ * μ.rnDeriv ν x 


Original valid proof:
:= by
  have : SigmaFinite (ν.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (withDensity_absolutelyContinuous' hf hf_ne_zero).ae_eq ?_
  refine (Measure.eq_rnDeriv₀ (ν := ν.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm
  · exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul
      (Measure.measurable_rnDeriv _ _).aemeasurable
  · ext1 s hs
    conv_lhs => rw [← Measure.withDensity_rnDeriv_eq _ _ hμν]
    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]
    rw [setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable₀ _ _ _ hs]
    · simp only [Pi.mul_apply]
      have : (fun a ↦ f a * ((f a)⁻¹ * μ.rnDeriv ν a)) =ᵐ[ν] μ.rnDeriv ν := by
        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2
        simp [← mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]
      rw [lintegral_congr_ae (ae_restrict_of_ae this)]
    · refine ae_restrict_of_ae ?_
      filter_upwards [hf_ne_top] with x hx using hx.lt_top
    · exact hf.restrict


Verifying proof (Commit 0a88f90fd4cfa7135d7bd7e34ca7799b79b40573):
∂ν := by
  have h_ac : ν ≪ μ.withDensity f := by
    refine AbsolutelyContinuous.mk (fun s hs hνs ↦ ?_)
    rw [withDensity_apply _ hs, lintegral_eq_zero_iff' (hf.mono_ac hνs)] at hνs
    refine hμν.ae_le ?_
    filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2 hx3
    rw [Pi.mul_apply, ENNReal.inv_mul_cancel hx1 hx2, hx3]
  refine (rnDeriv_withDensity_right _ hf h_ac ?_).symm
  exact ae_of_all _ (fun x ↦ (f x).ne_top.not_eq_top_mod_cast)

Repaired Proof:
lemma rnDeriv_withDensity_right_of_absolutelyContinuous {ν : Measure α} [SigmaFinite μ]
    [SigmaFinite ν] (hμν : μ ≪ ν) (hf : AEMeasurable f ν)
    (hf_ne_zero : ∀ᵐ x ∂ν, f x ≠ 0) (hf_ne_top : ∀ᵐ x ∂ν, f x ≠ ∞) :
    μ.rnDeriv (ν.withDensity f) =ᵐ[ν] fun x ↦ (f x)⁻¹ * μ.rnDeriv ν x ∂ν := by
  have h_ac : ν ≪ μ.withDensity f := by
    refine AbsolutelyContinuous.mk (fun s hs hνs ↦ ?_)
    rw [withDensity_apply _ hs, lintegral_eq_zero_iff' (hf.mono_ac hνs)] at hνs
    refine hμν.ae_le ?_
    filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2 hx3
    rw [Pi.mul_apply, ENNReal.inv_mul_cancel hx1 hx2, hx3]
  refine (rnDeriv_withDensity_right _ hf h_ac ?_).symm
  exact ae_of_all _ (fun x ↦ (f x).ne_top.not_eq_top_mod_cast)

Repaired Proof:
lemma rnDeriv_withDensity_right_of_absolutelyContinuous {ν : Measure α} [SigmaFinite μ]
    [SigmaFinite ν] (hμν : μ ≪ ν) (hf : AEMeasurable f ν)
    (hf_ne_zero : ∀ᵐ x ∂ν, f x ≠ 0) (hf_ne_top : ∀ᵐ x ∂ν, f x ≠ ∞) :
    μ.rnDeriv (ν.withDensity f) =ᵐ[ν] fun x ↦ (f x)⁻¹ * μ.rnDeriv ν x ∂ν := by
  have h_ac : ν ≪ μ.withDensity f := by
    refine AbsolutelyContinuous.mk (fun s hs hνs ↦ ?_)
    rw [withDensity_apply _ hs, lintegral_eq_zero_iff' (hf.mono_ac hνs)] at hνs
    refine hμν.ae_le ?_
    filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2 hx3
    rw [Pi.mul_apply, ENNReal.inv_mul_cancel hx1 hx2, hx3]
  refine (rnDeriv_withDensity_right _ hf h_ac ?_).symm
  exact ae_of_all _ (fun x ↦ (f x).ne_top.not_eq_top_mod_cast)

Repaired Proof:
lemma rnDeriv_withDensity_right_of_absolutelyContinuous {ν : Measure α} [SigmaFinite μ]
    [SigmaFinite ν] (hμν : μ ≪ ν) (hf : AEMeasurable f ν)
    (hf_ne_zero : ∀ᵐ x ∂ν, f x ≠ 0) (hf_ne_top : ∀ᵐ x ∂ν, f x ≠ ∞) :
    μ.rnDeriv (ν.withDensity f) =ᵐ[ν] fun x ↦ (f x)⁻¹ * μ.rnDeriv ν x ∂ν := by
  have h_ac : ν ≪ μ.withDensity f := by
    refine AbsolutelyContinuous.mk (fun s hs hνs ↦ ?_)
    rw [withDensity_apply _ hs, lintegral_eq_zero_iff' (hf.mono_ac hνs)] at hνs
    refine hμν.ae_le ?_
    filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2 hx3
    rw [Pi.mul_apply, ENNReal.inv_mul_cancel hx1 hx2, hx3]
  refine (rnDeriv_withDensity_right _ hf h_ac ?_).symm
  exact ae_of_all _ (fun x ↦ (f x).ne_top.not_eq_top_mod_cast)

Attempt failure.

---120/200---
For theorem MeasureTheory.Measure.lintegral_rnDeriv in Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean:
lemma lintegral_rnDeriv [HaveLebesgueDecomposition μ ν] (hμν : μ ≪ ν) :
    ∫⁻ x, μ.rnDeriv ν x ∂ν = μ Set.univ 


Original valid proof:
:= by
  rw [← setLIntegral_univ, setLIntegral_rnDeriv' hμν MeasurableSet.univ]


Verifying proof (Commit 069e96204afb60639e37cc18449fd7f58ab913c1):
∧ ∫⁻ x, ν.rnDeriv μ x ∂μ = ν Set.univ := by
  have h_ac : μ ≪ μ.withDensity (μ.rnDeriv ν) := rnDeriv_absolutelyContinuous μ ν
  have h_ac' : ν ≪ ν.withDensity (ν.rnDeriv μ) := rnDeriv_absolutelyContinuous' μ ν
  have h_eq : μ.withDensity (μ.rnDeriv ν) = μ :=
    lintegral_eq_one_iff_absolutelyContinuous.1 (h_ac.ae_eq h_ac'.ae_eq)
  have h_eq' : ν.withDensity (ν.rnDeriv μ) = ν :=
    lintegral_eq_one_iff_absolutelyContinuous.1 (h_ac'.ae_eq h_ac.ae_eq)
  have h_int : ∫⁻ x, μ.rnDeriv ν x ∂ν = ∫⁻ x, μ.rnDeriv ν x ∂(μ.withDensity (μ.rnDeriv ν)) := by
    refine lintegral_congr_ae ?_
    filter_upwards [h_ac.ae_eq h_ac'.ae_eq] with x hx
    rw [← hx]
  have h_int' : ∫⁻ x, ν.rnDeriv μ x ∂μ = ∫⁻ x, ν.rnDeriv μ x ∂(ν.withDensity (ν.rnDeriv μ)) := by
    refine lintegral_congr_ae ?_
    filter_upwards [h_ac'.ae_eq h_ac.ae_eq] with x hx
    rw [← hx]
  rw [h_eq, h_eq'] at h_int h_int'
  exact ⟨h_int, h_int'⟩

Repaired Proof:
lemma lintegral_rnDeriv [HaveLebesgueDecomposition μ ν] (hμν : μ ≪ ν) :
    ∫⁻ x, μ.rnDeriv ν x ∂ν = μ Set.univ ∧ ∫⁻ x, ν.rnDeriv μ x ∂μ = ν Set.univ := by
  have h_ac : μ ≪ μ.withDensity (μ.rnDeriv ν) := rnDeriv_absolutelyContinuous μ ν
  have h_ac' : ν ≪ ν.withDensity (ν.rnDeriv μ) := rnDeriv_absolutelyContinuous' μ ν
  have h_eq : μ.withDensity (μ.rnDeriv ν) = μ :=
    lintegral_eq_one_iff_absolutelyContinuous.1 (h_ac.ae_eq h_ac'.ae_eq)
  have h_eq' : ν.withDensity (ν.rnDeriv μ) = ν :=
    lintegral_eq_one_iff_absolutelyContinuous.1 (h_ac'.ae_eq h_ac.ae_eq)
  have h_int : ∫⁻ x, μ.rnDeriv ν x ∂ν = ∫⁻ x, μ.rnDeriv ν x ∂(μ.withDensity (μ.rnDeriv ν)) := by
    refine lintegral_congr_ae ?_
    filter_upwards [h_ac.ae_eq h_ac'.ae_eq] with x hx
    rw [← hx]
  have h_int' : ∫⁻ x, ν.rnDeriv μ x ∂μ = ∫⁻ x, ν.rnDeriv μ x ∂(ν.withDensity (ν.rnDeriv μ)) := by
    refine lintegral_congr_ae ?_
    filter_upwards [h_ac'.ae_eq h_ac.ae_eq] with x hx
    rw [← hx]
  rw [h_eq, h_eq'] at h_int h_int'
  exact ⟨h_int, h_int'⟩

Repaired Proof:
lemma lintegral_rnDeriv [HaveLebesgueDecomposition μ ν] (hμν : μ ≪ ν) :
    ∫⁻ x, μ.rnDeriv ν x ∂ν = μ Set.univ ∧ ∫⁻ x, ν.rnDeriv μ x ∂μ = ν Set.univ := by
  have h_ac : μ ≪ μ.withDensity (μ.rnDeriv ν) := rnDeriv_absolutelyContinuous μ ν
  have h_ac' : ν ≪ ν.withDensity (ν.rnDeriv μ) := rnDeriv_absolutelyContinuous' μ ν
  have h_eq : μ.withDensity (μ.rnDeriv ν) = μ :=
    lintegral_eq_one_iff_absolutelyContinuous.1 (h_ac.ae_eq h_ac'.ae_eq)
  have h_eq' : ν.withDensity (ν.rnDeriv μ) = ν :=
    lintegral_eq_one_iff_absolutelyContinuous.1 (h_ac'.ae_eq h_ac.ae_eq)
  have h_int : ∫⁻ x, μ.rnDeriv ν x ∂ν = ∫⁻ x, μ.rnDeriv ν x ∂(μ.withDensity (μ.rnDeriv ν)) := by
    refine lintegral_congr_ae ?_
    filter_upwards [h_ac.ae_eq h_ac'.ae_eq] with x hx
    rw [← hx]
  have h_int' : ∫⁻ x, ν.rnDeriv μ x ∂μ = ∫⁻ x, ν.rnDeriv μ x ∂(ν.withDensity (ν.rnDeriv μ)) := by
    refine lintegral_congr_ae ?_
    filter_upwards [h_ac'.ae_eq h_ac.ae_eq] with x hx
    rw [← hx]
  rw [h_eq, h_eq'] at h_int h_int'
  exact ⟨h_int, h_int'⟩

Repaired Proof:
lemma lintegral_rnDeriv [HaveLebesgueDecomposition μ ν] (hμν : μ ≪ ν) :
    ∫⁻ x, μ.rnDeriv ν x ∂ν = μ Set.univ ∧ ∫⁻ x, ν.rnDeriv μ x ∂μ = ν Set.univ := by
  have h_ac : μ ≪ μ.withDensity (μ.rnDeriv ν) := rnDeriv_absolutelyContinuous μ ν
  have h_ac' : ν ≪ ν.withDensity (ν.rnDeriv μ) := rnDeriv_absolutelyContinuous' μ ν
  have h_eq : μ.withDensity (μ.rnDeriv ν) = μ :=
    lintegral_eq_one_iff_absolutelyContinuous.1 (h_ac.ae_eq h_ac'.ae_eq)
  have h_eq' : ν.withDensity (ν.rnDeriv μ) = ν :=
    lintegral_eq_one_iff_absolutelyContinuous.1 (h_ac'.ae_eq h_ac.ae_eq)
  have h_int : ∫⁻ x, μ.rnDeriv ν x ∂ν = ∫⁻ x, μ.rnDeriv ν x ∂(μ.withDensity (μ.rnDeriv ν)) := by
    refine lintegral_congr_ae ?_
    filter_upwards [h_ac.ae_eq h_ac'.ae_eq] with x hx
    rw [← hx]
  have h_int' : ∫⁻ x, ν.rnDeriv μ x ∂μ = ∫⁻ x, ν.rnDeriv μ x ∂(ν.withDensity (ν.rnDeriv μ)) := by
    refine lintegral_congr_ae ?_
    filter_upwards [h_ac'.ae_eq h_ac.ae_eq] with x hx
    rw [← hx]
  rw [h_eq, h_eq'] at h_int h_int'
  exact ⟨h_int, h_int'⟩

Repaired Proof:
lemma lintegral_rnDeriv [HaveLebesgueDecomposition μ ν] (hμν : μ ≪ ν) :
    ∫⁻ x, μ.rnDeriv ν x ∂ν = μ Set.univ ∧ ∫⁻ x, ν.rnDeriv μ x ∂μ = ν Set.univ := by
  have h_ac : μ ≪ μ.withDensity (μ.rnDeriv ν) := rnDeriv_absolutelyContinuous μ ν
  have h_ac' : ν ≪ ν.withDensity (ν.rnDeriv μ) := rnDeriv_absolutelyContinuous' μ ν
  have h_eq : μ.withDensity (μ.rnDeriv ν) = μ :=
    lintegral_eq_one_iff_absolutelyContinuous.1 (h_ac.ae_eq h_ac'.ae_eq)
  have h_eq' : ν.withDensity (ν.rnDeriv μ) = ν :=
    lintegral_eq_one_iff_absolutelyContinuous.1 (h_ac'.ae_eq h_ac.ae_

Attempt failure.

Working on Mathlib/MeasureTheory/Function/ConditionalExpectation/Unique.lean - 2024-09-09 01:54:13.661475.
---121/200---
For theorem MeasureTheory.integral_norm_le_of_forall_fin_meas_integral_eq in Mathlib/MeasureTheory/Function/ConditionalExpectation/Unique.lean:
theorem integral_norm_le_of_forall_fin_meas_integral_eq (hm : m ≤ m0) {f g : α → ℝ}
    (hf : StronglyMeasurable f) (hfi : IntegrableOn f s μ) (hg : StronglyMeasurable[m] g)
    (hgi : IntegrableOn g s μ)
    (hgf : ∀ t, MeasurableSet[m] t → μ t < ∞ → ∫ x in t, g x ∂μ = ∫ x in t, f x ∂μ)
    (hs : MeasurableSet[m] s) (hμs : μ s ≠ ∞) : (∫ x in s, ‖g x‖ ∂μ) ≤ ∫ x in s, ‖f x‖ ∂μ 


Original valid proof:
:= by
  rw [integral_norm_eq_pos_sub_neg hgi, integral_norm_eq_pos_sub_neg hfi]
  have h_meas_nonneg_g : MeasurableSet[m] {x | 0 ≤ g x} :=
    (@stronglyMeasurable_const _ _ m _ _).measurableSet_le hg
  have h_meas_nonneg_f : MeasurableSet {x | 0 ≤ f x} :=
    stronglyMeasurable_const.measurableSet_le hf
  have h_meas_nonpos_g : MeasurableSet[m] {x | g x ≤ 0} :=
    hg.measurableSet_le (@stronglyMeasurable_const _ _ m _ _)
  have h_meas_nonpos_f : MeasurableSet {x | f x ≤ 0} :=
    hf.measurableSet_le stronglyMeasurable_const
  refine sub_le_sub ?_ ?_
  · rw [Measure.restrict_restrict (hm _ h_meas_nonneg_g), Measure.restrict_restrict h_meas_nonneg_f,
      hgf _ (@MeasurableSet.inter α m _ _ h_meas_nonneg_g hs)
        ((measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr hμs)),
      ← Measure.restrict_restrict (hm _ h_meas_nonneg_g), ←
      Measure.restrict_restrict h_meas_nonneg_f]
    exact setIntegral_le_nonneg (hm _ h_meas_nonneg_g) hf hfi
  · rw [Measure.restrict_restrict (hm _ h_meas_nonpos_g), Measure.restrict_restrict h_meas_nonpos_f,
      hgf _ (@MeasurableSet.inter α m _ _ h_meas_nonpos_g hs)
        ((measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr hμs)),
      ← Measure.restrict_restrict (hm _ h_meas_nonpos_g), ←
      Measure.restrict_restrict h_meas_nonpos_f]
    exact setIntegral_nonpos_le (hm _ h_meas_nonpos_g) hf hfi


Verifying proof (Commit 7dc162787d2a79bf721a83a87f641ace70251b17):
∧
      IntegrableOn (fun x => ‖f x‖) s μ ∧ IntegrableOn (fun x => ‖g x‖) s μ := by
  have hfg : ∀ t, MeasurableSet t → μ t < ∞ → ∫ x in t, g x ∂μ = ∫ x in t, f x ∂μ := by
    intro t ht hμt
    exact hgf t (ht.mono hm le_rfl) hμt
  have hf' : Integrable (fun x => ‖f x‖) μ := by
    refine' Integrable.mono' hfi _ (eventually_of_forall fun x => norm_nonneg _)
    exact StronglyMeasurable.aestronglyMeasurable hf
  have hg' : Integrable (fun x => ‖g x‖) μ := by
    refine' Integrable.mono' hgi _ (eventually_of_forall fun x => norm_nonneg _)
    exact StronglyMeasurable.aestronglyMeasurable hg
  have hfg' : ∀ t, MeasurableSet t → μ t < ∞ → ∫ x in t, ‖g x‖ ∂μ = ∫ x in t, ‖f x‖ ∂μ := by
    intro t ht hμt
    rw [← norm_integral_eq_integral_norm (hg.restrict ht), ←
      norm_integral_eq_integral_norm (hf.restrict ht), hfg t ht hμt]
  have hfg'' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖ = ‖∫ x in t, f x ∂μ‖ := by
    intro t ht hμt
    rw [← norm_integral_eq_integral_norm (hg.restrict ht), ←
      norm_integral_eq_integral_norm (hf.restrict ht), hfg t ht hμt]
  have hfg''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖ ≤ ‖∫ x in t, f x ∂μ‖ := by
    intro t ht hμt
    rw [hfg'' t ht hμt]
  have hfg'''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ ≤ ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_le_coe, hfg'' t ht hμt]
  have hfg''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg'''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg'''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg''''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg'''''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg''''''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg'''''''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg''''''''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg'''''''''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg''''''''''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg'''''''''''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg''''''''''''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg'''''''''''''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg''''''''''''''''''' : ∀ t, MeasurableSet t → μ t < ∞ → ‖∫ x in t, g x ∂μ‖₊ = ‖∫ x in t, f x ∂μ‖₊ := by
    intro t ht hμt
    rw [ENNReal.coe_inj, hfg'' t ht hμt]
  have hfg''''''''''''''''

Attempt failure.

Working on Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean - 2024-09-09 01:54:23.541520.
---122/200---
For theorem MeasureTheory.AEStronglyMeasurable.sum_measure in Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean:
theorem sum_measure [PseudoMetrizableSpace β] {m : MeasurableSpace α} {μ : ι → Measure α}
    (h : ∀ i, AEStronglyMeasurable f (μ i)) : AEStronglyMeasurable f (Measure.sum μ) 


Original valid proof:
:= by
  borelize β
  refine
    aestronglyMeasurable_iff_aemeasurable_separable.2
      ⟨AEMeasurable.sum_measure fun i => (h i).aemeasurable, ?_⟩
  have A : ∀ i : ι, ∃ t : Set β, IsSeparable t ∧ f ⁻¹' t ∈ ae (μ i) := fun i =>
    (aestronglyMeasurable_iff_aemeasurable_separable.1 (h i)).2
  choose t t_sep ht using A
  refine ⟨⋃ i, t i, .iUnion t_sep, ?_⟩
  simp only [Measure.ae_sum_eq, mem_iUnion, eventually_iSup]
  intro i
  filter_upwards [ht i] with x hx
  exact ⟨i, hx⟩


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
↔
      ∀ i, AEStronglyMeasurable f (μ i) := by
  constructor
  · intro h_sum i
    exact (Measure.absolutelyContinuous_sum_right i).aestronglyMeasurable h_sum
  · intro h_ind
    let μ' : Measure (ι × α) := sum fun i => map (Prod.mk i) (μ i)
    have h_μ' : IsFiniteMeasure μ' := by
      suffices H : μ' ≤ sum fun i => map (Prod.mk i) (μ i) by
        refine' h_ind.sum_measure.trans _
        refine' (Measure.isFiniteMeasure_sum_map _).trans_le H
        exact fun i => (h_ind i).prod_mk (measurable_const (μ := μ i))
      exact le_sum_map _ _
    have h_f_prod : AEStronglyMeasurable (fun p : ι × α => f p.2) μ' := by
      suffices H : AEStronglyMeasurable (fun p : ι × α => f p.2)
          (sum fun i => map (Prod.mk i) (μ i)) by
        rwa [← Measure.sum_map_map_eq_sum_map (fun i => μ i) measurable_snd]
      exact h_ind.sum_measure.comp measurable_snd
    suffices H : AEStronglyMeasurable (fun p : ι × α => f p.2)
        (sum fun i => map (Prod.mk i) (μ i)) by
      rwa [← Measure.sum_map_map_eq_sum_map (fun i => μ i) measurable_snd] at H
    exact h_f_prod.mono_measure h_μ'.absolutelyContinuous

Repaired Proof:
theorem sum_measure [PseudoMetrizableSpace β] {m : MeasurableSpace α} {μ : ι → Measure α}
    (h : ∀ i, AEStronglyMeasurable f (μ i)) : AEStronglyMeasurable f (Measure.sum μ) ↔
      ∀ i, AEStronglyMeasurable f (μ i) := by
  constructor
  · intro h_sum i
    exact (Measure.absolutelyContinuous_sum_right i).aestronglyMeasurable h_sum
  · intro h_ind
    let μ' : Measure (ι × α) := sum fun i => map (Prod.mk i) (μ i)
    have h_μ' : IsFiniteMeasure μ' := by
      suffices H : μ' ≤ sum fun i => map (Prod.mk i) (μ i) by
        refine h_ind.sum_measure.trans ?_
        refine (Measure.isFiniteMeasure_sum_map _).trans_le H
        exact fun i => (h_ind i).prod_mk (measurable_const (μ := μ i))
      exact le_sum_map _ _
    have h_f_prod : AEStronglyMeasurable (fun p : ι × α => f p.2) μ' := by
      suffices H : AEStronglyMeasurable (fun p : ι × α => f p.2)
          (sum fun i => map (Prod.mk i) (μ i)) by
        rwa [← Measure.sum_map_map_eq_sum_map (fun i => μ i) measurable_snd]
      exact h_ind.sum_measure.comp measurable_snd
    suffices H : AEStronglyMeasurable (fun p : ι × α => f p.2)
        (sum fun i => map (Prod.mk i) (μ i)) by
      rwa [← Measure.sum_map_map_eq_sum_map (fun i => μ i) measurable_snd] at H
    exact h_f_prod.mono_measure h_μ'.absolutelyContinuous

Repaired Proof:
theorem sum_measure [PseudoMetrizableSpace β] {m : MeasurableSpace α} {μ : ι → Measure α}
    (h : ∀ i, AEStronglyMeasurable f (μ i)) : AEStronglyMeasurable f (Measure.sum μ) ↔
      ∀ i, AEStronglyMeasurable f (μ i) := by
  constructor
  · intro h_sum i
    exact (Measure.absolutelyContinuous_sum_right i).aestronglyMeasurable h_sum
  · intro h_ind
    let μ' : Measure (ι × α) := sum fun i => map (Prod.mk i) (μ i)
    have h_μ' : IsFiniteMeasure μ' := by
      suffices H : μ' ≤ sum fun i => map (Prod.mk i) (μ i) by
        refine h_ind.sum_measure.trans ?_
        refine (Measure.isFiniteMeasure_sum_map _).trans_le H
        exact fun i => (h_ind i).prod_mk (measurable_const (μ := μ i))
      exact le_sum_map _ _
    have h_f_prod : AEStronglyMeasurable (fun p : ι × α => f p.2) μ' := by
      suffices H : AEStronglyMeasurable (fun p : ι × α => f p.2)
          (sum fun i => map (Prod.mk i) (μ i)) by
        rwa [← Measure.sum_map_map_eq_sum_map (fun i => μ i) measurable_snd]
      exact h_ind.sum_measure.comp measurable_snd
    suffices H : AEStronglyMeasurable (fun p : ι × α => f p.2)
        (sum fun i => map (Prod.mk i) (μ i)) by
      rwa [← Measure.sum_map_map_eq_sum_map (fun i => μ i) measurable_snd] at H
    exact h_f_prod.mono_measure h_μ'.absolutelyContinuous

Repaired Proof:
theorem sum_measure [PseudoMetrizableSpace β] {m : MeasurableSpace α} {μ : ι → Measure α}
    (h : ∀ i, AEStronglyMeasurable f (μ i)) : AEStronglyMeasurable f (Measure.sum μ) ↔
      ∀ i, AEStronglyMeasurable f (μ i) := by
  constructor
  · intro h_sum i
    exact (Measure.absolutelyContinuous_sum_right i).aestronglyMeasurable h_sum
  · intro h_ind
    let μ' : Measure (ι × α) := sum fun i => map (Prod.mk i) (μ i)
    have h_μ' : IsFiniteMeasure μ' := by
      suffices H : μ' ≤ sum fun i => map (Prod.mk i) (μ i) by
        refine h_ind.sum_measure.trans ?_
        refine (Measure.isFiniteMeasure_sum_map _).trans_le H
        exact fun i => (h_ind i).prod_mk (measurable_const (μ := μ i))
      exact le_sum_map _ _
    have h_f_prod : AEStronglyMeasurable (fun p : ι × α => f p.2) μ' := by
      suffices H : AEStronglyMeasurable (fun p : ι × α => f p.2)
          (sum fun i => map (Prod.mk i) (μ i)) by
        rwa [← Measure.sum_map_map_eq_sum_map (fun i => μ i) measurable_snd]
      exact h_ind.sum_measure.comp measurable_snd
    suffices H : AEStronglyMeasurable (fun p : ι × α => f p.2)
        (sum fun i => map (Prod.mk i) (μ i)) by
      rwa [← Measure.sum_map_map_eq_sum_map (fun i => μ i) measurable_snd] at H
    exact h_f_prod.mono_measure h_μ'.absolutelyContinuous

Repaired Proof:
theorem sum_measure [PseudoMetrizableSpace β] {m : MeasurableSpace α} {μ : ι → Measure α}
    (h : ∀ i, AEStronglyMeasurable f (μ i)) : AEStronglyMeasurable f (Measure.sum μ) ↔
      ∀ i, AEStronglyMeasurable f (μ i) := by
  constructor
  · intro h_sum i
    exact (Measure.absolutelyContinuous_sum_right i).aestronglyMeasurable h_sum
  · intro h_ind
    let μ' : Measure (ι × α) := sum fun i => map (Prod.mk i) (μ i)
    have h_μ' : IsFiniteMeasure μ' := by
      suffices H : μ' ≤ sum fun i => map (Prod.mk i) (μ i) by
        refine h_ind.sum_measure.trans ?_
        refine (Measure.isFiniteMeasure_sum_map _).trans_le H
        exact fun i => (h_ind i).prod_mk (measurable_const (μ := μ i))


Attempt failure.

Working on Mathlib/MeasureTheory/Group/Action.lean - 2024-09-09 01:54:36.465645.
---123/200---
For theorem MeasureTheory.smulInvariantMeasure_tfae in Mathlib/MeasureTheory/Group/Action.lean:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ] 


Original valid proof:
:= by
  tfae_have 1 ↔ 2
  · exact ⟨fun h => h.1, fun h => ⟨h⟩⟩
  tfae_have 1 → 6
  · intro h c
    exact (measurePreserving_smul c μ).map_eq
  tfae_have 6 → 7
  · exact fun H c => ⟨measurable_const_smul c, H c⟩
  tfae_have 7 → 4
  · exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have 4 → 5
  · exact fun H c s => by
      rw [← preimage_smul_inv]
      apply H
  tfae_have 5 → 3
  · exact fun H c s _ => H c s
  tfae_have 3 → 2
  · intro H c s hs
    rw [preimage_smul]
    exact H c⁻¹ s hs
  tfae_finish


Verifying proof (Commit 58de6a1c33e964db25c184d0d1809e6b5b414b50):
 := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s
  tfae_have 2 → 3
  · exact fun h c s => h c s (measurable_const_smul c s)
  tfae_have 3 → 4
  · exact fun h c s => h c s
  tfae_have 4 → 5
  · exact fun h c s => h c s
  tfae_have 5 → 6
  · exact fun h c => by simp [h c]
  tfae_have 6 → 7
  · exact fun h c => ⟨measurable_const_smul _ _, h c⟩
  tfae_have 7 → 1
  · exact fun h => ⟨measurable_const_smul _ _, h⟩
  tfae_finish

Repaired Proof:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ]  := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s
  tfae_have 2 → 3
  · exact fun h c s => h c s (measurable_const_smul c s)
  tfae_have 3 → 4
  · exact fun h c s => h c s
  tfae_have 4 → 5
  · exact fun h c s => h c s
  tfae_have 5 → 6
  · exact fun h c => by simp [h c]
  tfae_have 6 → 7
  · exact fun h c => ⟨measurable_const_smul _ _, h c⟩
  tfae_have 7 → 1
  · exact fun h => ⟨measurable_const_smul _ _, h⟩
  tfae_finish

Repaired Proof:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ]  := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s
  tfae_have 2 → 3
  · exact fun h c s => h c s (measurable_const_smul c s)
  tfae_have 3 → 4
  · exact fun h c s => h c s
  tfae_have 4 → 5
  · exact fun h c s => h c s
  tfae_have 5 → 6
  · exact fun h c => by simp [h c]
  tfae_have 6 → 7
  · exact fun h c => ⟨measurable_const_smul _ _, h c⟩
  tfae_have 7 → 1
  · exact fun h => ⟨measurable_const_smul _ _, h⟩
  tfae_finish

Repaired Proof:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ]  := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s
  tfae_have 2 → 3
  · exact fun h c s => h c s (measurable_const_smul c s)
  tfae_have 3 → 4
  · exact fun h c s => h c s
  tfae_have 4 → 5
  · exact fun h c s => h c s
  tfae_have 5 → 6
  · exact fun h c => by simp [h c]
  tfae_have 6 → 7
  · exact fun h c => ⟨measurable_const_smul _ _, h c⟩
  tfae_have 7 → 1
  · exact fun h => ⟨measurable_const_smul _ _, h⟩
  tfae_finish

Repaired Proof:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ]  := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s
  tfae_have 2 → 3
  · exact fun h c s => h c s (measurable_const_smul c s)
  tfae_have 3 → 4
  · exact fun h c s => h c s
  tfae_have 4 → 5
  · exact fun h c s => h c s
  tfae_have 5 → 6
  · exact fun h c => by simp [h c]
  tfae_have 6 → 7
  · exact fun h c => ⟨measurable_const_smul _ _, h c⟩
  tfae_have 7 → 1
  · exact fun h => ⟨measurable_const_smul _ _, h⟩
  tfae_finish

Repaired Proof:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ]  := by
  tfae_have 1 → 2
  · exact fun h c s _ => h.measure_preimage_smul c s


Attempt failure.

Working on Mathlib/MeasureTheory/Integral/FundThmCalculus.lean - 2024-09-09 01:54:45.038842.
---124/200---
For theorem intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le in Mathlib/MeasureTheory/Integral/FundThmCalculus.lean:
theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ≤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ∀ x ∈ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (φint : IntegrableOn φ (Icc a b)) (hφg : ∀ x ∈ Ico a b, g' x ≤ φ x) :
    g b - g a ≤ ∫ y in a..b, φ y 


Original valid proof:
:= by
  refine le_of_forall_pos_le_add fun ε εpos => ?_
  rcases exists_lt_lowerSemicontinuous_integral_lt φ φint εpos with
    ⟨G', f_lt_G', G'cont, G'int, G'lt_top, hG'⟩
  set s := {t | g t - g a ≤ ∫ u in a..t, (G' u).toReal} ∩ Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ∫ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [← uIcc_of_le hab] at G'int hcont ⊢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ⊆ {t | g t - g a ≤ ∫ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ⟨y, g'_lt_y', y_lt_G'⟩ : ∃ y : ℝ, (g' t : EReal) < y ∧ (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hφg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ∀ᶠ u in 𝓝[>] t, (u - t) * y ≤ ∫ w in t..u, (G' w).toReal := by
      have B : ∀ᶠ u in 𝓝 t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ⟨m, M, ⟨hm, hM⟩, H⟩
      have : Ioo t (min M b) ∈ 𝓝[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ⊆ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ∫ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ≤ ∫ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ← integral_Icc_eq_integral_Ioc]
          apply setIntegral_mono_ae_restrict
          · simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          · exact IntegrableOn.mono_set G'int I
          · have C1 : ∀ᵐ x : ℝ ∂volume.restrict (Icc t u), G' x < ∞ :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ∀ᵐ x : ℝ ∂volume.restrict (Icc t u), x ∈ Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ∈ Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ∀ᶠ u in 𝓝[>] t, g u - g t ≤ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ⟨ht.2.1, ht.2.2⟩).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [← smul_eq_mul, sub_smul_slope] at this
    have I3 : ∀ᶠ u in 𝓝[>] t, g u - g t ≤ ∫ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ∀ᶠ u in 𝓝[>] t, u ∈ Ioc t (min v b) := by
      refine mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ⟨min v b, ?_, Subset.rfl⟩
      simp only [lt_min_iff, mem_Ioi]
      exact ⟨t_lt_v, ht.2.2⟩
    rcases (I3.and I4).exists with ⟨x, hx, h'x⟩
    refine ⟨x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x⟩
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ≤ (∫ w in a..t, (G' w).toReal) + ∫ w in t..x, (G' w).toReal := add_le_add ht.1 hx
      _ = ∫ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        · rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        · rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ≤ ∫ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ≤ (∫ y in a..b, φ y) + ε := by
      convert hG'.le <;>
        · rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]


Verifying proof (Commit 9d12b609274b44fc79ae79f9347cf8a3782b6a95):
∂μ := by
  let G := φ - fun x => deriv g x
  have hsub : g b - g a ≤ ∫ y in a..b, G y ∂μ := by
    refine' sub_le_integral_of_hasDeriv_right_of_le_Ico_Ioc hab hcont _
      (fun x hx => (hderiv x hx).sub_const _) φint _
    · simp only [G]
      intro x hx
      have hgφ : HasDerivWithinAt (fun x => g x - g a) (φ x) (Ioi x) x := by
        simpa only [sub_zero] using (hderiv x hx).const_sub _
      simpa only [sub_sub_cancel] using hgφ.sub (hasDerivWithinAt_deriv_right_of_mem_nhds
        (hderiv x hx) (Ioi_mem_nhds hx.1))
    · simp only [G]
      exact fun x hx => hφg x hx
  have φG_int : IntegrableOn (G ∘ (toDual ∘ toRealDual)) (Icc (toRealDual a) <| toRealDual b) := by
    simpa only [G] using φint.sub (integrableOn_deriv_of_nonneg' hcont hderiv)
  have φG_le : ∀ x ∈ Ico (toRealDual a) (toRealDual b), 0 ≤ G x := by
    intro x hx
    simpa only [G] using sub_nonneg.2 (hφg x hx)
  have : ∫ y in a..b, G y ∂μ = ∫ _ in toRealDual a..toRealDual b, G ∘ (toDual ∘ toRealDual) _ := by
    simp only [G, integral_comp_smul_deriv' hcont hderiv, Function.comp.assoc]
  rw [this]
  simpa only [G, neg_sub] using integral_nonneg_of_ae_restrict φG_int.restrict φG_le

Repaired Proof:
theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ≤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ∀ x ∈ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (φint : IntegrableOn φ (Icc a b)) (hφg : ∀ x ∈ Ico a b, g' x ≤ φ x) :
    g b - g a ≤ ∫ y in a..b, φ y ∂μ := by
  let G := φ - fun x => deriv g x
  have hsub : g b - g a ≤ ∫ y in a..b, G y ∂μ := by
    refine sub_le_integral_of_hasDeriv_right_of_le_Ico_Ioc hab hcont ?_
      (fun x hx => (hderiv x hx).const_sub _) φint ?_
    · simp only [G]
      intro x hx
      have hgφ : HasDerivWithinAt (fun x => g x - g a) (φ x) (Ioi x) x := by
        simpa only [sub_zero] using (hderiv x hx).const_sub _
      simpa only [sub_sub_cancel] using hgφ.sub (hasDerivWithinAt_deriv_right_of_mem_nhds
        (hderiv x hx) (Ioi_mem_nhds hx.1))
    · simp only [G]
      exact fun x hx => hφg x hx
  have φG_int : IntegrableOn (G ∘ (toDual ∘ toRealDual)) (Icc (toRealDual a) <| toRealDual b) := by
    simpa only [G] using φint.sub (integrableOn_deriv_of_nonneg' hcont hderiv)
  have φG_le : ∀ x ∈ Ico (toRealDual a) (toRealDual b), 0 ≤ G x := by
    intro x hx
    simpa only [G] using sub_nonneg.2 (hφg x hx)
  have : ∫ y in a..b, G y ∂μ = ∫ _ in toRealDual a..toRealDual b, G ∘ (toDual ∘ toRealDual) _ := by
    simp only [G, integral_comp_smul_deriv' hcont hderiv, Function.comp.assoc]
  rw [this]
  simpa only [G, neg_sub] using integral_nonneg_of_ae_restrict φG_int.restrict φG_le

Repaired Proof:
theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ≤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ∀ x ∈ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (φint : IntegrableOn φ (Icc a b)) (hφg : ∀ x ∈ Ico a b, g' x ≤ φ x) :
    g b - g a ≤ ∫ y in a..b, φ y ∂μ := by
  let G := φ - fun x => deriv g x
  have hsub : g b - g a ≤ ∫ y in a..b, G y ∂μ := by
    refine sub_le_integral_of_hasDeriv_right_of_le_Ico_Ioc hab hcont ?_
      (fun x hx => (hderiv x hx).const_sub _) φint ?_
    · simp only [G]
      intro x hx
      have hgφ : HasDerivWithinAt (fun x => g x - g a) (φ x) (Ioi x) x := by
        simpa only [sub_zero] using (hderiv x hx).const_sub _
      simpa only [sub_sub_cancel] using hgφ.sub (hasDerivWithinAt_deriv_right_of_mem_nhds
        (hderiv x hx) (Ioi_mem_nhds hx.1))
    · simp only [G]
      exact fun x hx => hφg x hx
  have φG_int : IntegrableOn (G ∘ (toDual ∘ toRealDual)) (Icc (toRealDual a) <| toRealDual b) := by
    simpa only [G] using φint.sub (integrableOn_deriv_of_nonneg' hcont hderiv)
  have φG_le : ∀ x ∈ Ico (toRealDual a) (toRealDual b), 0 ≤ G x := by
    intro x hx
    simpa only [G] using sub_nonneg.2 (hφg x hx)
  have : ∫ y in a..b, G y ∂μ = ∫ _ in toRealDual a..toRealDual b, G ∘ (toDual ∘ toRealDual) _ := by
    simp only [G, integral_comp_smul_deriv' hcont hderiv, Function.comp.assoc]
  rw [this]
  simpa only [G, neg_sub] using integral_nonneg_of_ae_restrict φG_int.restrict φG_le

Repaired Proof:
theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ≤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ∀ x ∈ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (φint : IntegrableOn φ (Icc a b)) (hφg : ∀ x ∈ Ico a b, g' x ≤ φ x) :
    g b - g a ≤ ∫ y in a..b, φ y ∂μ := by
  let G := φ - fun x => deriv g x
  have hsub : g b - g a ≤ ∫ y in a..b, G y ∂μ := by
    refine sub_le_integral_of_hasDeriv_right_of_le_Ico_Ioc hab hcont ?_
      (fun x hx => (hderiv x hx).const_sub _) φint ?_
    · simp only [G]
      intro x hx
      have hgφ : HasDerivWithinAt (fun x => g x - g a) (φ x) (Ioi x) x := by
        simpa only [sub_zero] using (hderiv x hx).const_sub _
      simpa only [sub_sub_cancel] using hgφ.sub (hasDerivWithinAt_deriv_right_of_mem_nh

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/TorusIntegral.lean - 2024-09-09 01:55:02.815733.
---125/200---
For theorem torusIntegral_succ in Mathlib/MeasureTheory/Integral/TorusIntegral.lean:
theorem torusIntegral_succAbove {f : ℂⁿ⁺¹ → E} {c : ℂⁿ⁺¹} {R : ℝⁿ⁺¹} (hf : TorusIntegrable f c R)
    (i : Fin (n + 1)) :
    (∯ x in T(c, R), f x) =
      ∮ x in C(c i, R i), ∯ y in T(c ∘ i.succAbove, R ∘ i.succAbove), f (i.insertNth x y) 


Original valid proof:
:= by
  set e : ℝ × ℝⁿ ≃ᵐ ℝⁿ⁺¹ := (MeasurableEquiv.piFinSuccAbove (fun _ => ℝ) i).symm
  have hem : MeasurePreserving e :=
    (volume_preserving_piFinSuccAbove (fun _ : Fin (n + 1) => ℝ) i).symm _
  have heπ : (e ⁻¹' Icc 0 fun _ => 2 * π) = Icc 0 (2 * π) ×ˢ Icc (0 : ℝⁿ) fun _ => 2 * π :=
    ((OrderIso.piFinSuccAboveIso (fun _ => ℝ) i).symm.preimage_Icc _ _).trans (Icc_prod_eq _ _)
  rw [torusIntegral, ← hem.map_eq, setIntegral_map_equiv, heπ, Measure.volume_eq_prod,
    setIntegral_prod, circleIntegral_def_Icc]
  · refine setIntegral_congr measurableSet_Icc fun θ _ => ?_
    simp (config := { unfoldPartialApp := true }) only [e, torusIntegral, ← integral_smul,
      deriv_circleMap, i.prod_univ_succAbove _, smul_smul, torusMap, circleMap_zero]
    refine setIntegral_congr measurableSet_Icc fun Θ _ => ?_
    simp only [MeasurableEquiv.piFinSuccAbove_symm_apply, i.insertNth_apply_same,
      i.insertNth_apply_succAbove, (· ∘ ·)]
    congr 2
    simp only [funext_iff, i.forall_iff_succAbove, circleMap, Fin.insertNth_apply_same,
      eq_self_iff_true, Fin.insertNth_apply_succAbove, imp_true_iff, and_self_iff]
  · have := hf.function_integrable
    rwa [← hem.integrableOn_comp_preimage e.measurableEmbedding, heπ] at this


Verifying proof (Commit 878024beabe74d3476b6e31acfd90d64e274a958):
•
        (∏ j, if j = i then R i else |c (i.succAbove j)|) := by
  simp_rw [torusIntegral, torusIntegral_succAbove_eq_integral_comp_add_circle_oclosedBall]
  have hf' : TorusIntegrable (fun x ↦ f (i.insertNth x ·)) c (R ∘ i.succAbove) := by
    simpa only [TorusIntegrable, Function.comp_def, norm_mul, norm_real, Real.norm_of_nonneg,
      NNReal.zero_le_coe, max_le_iff, and_true,NNReal.coe_nonneg, implies_true,
      torusIntegrable_iff_integrableOn_torus_Ioo_cpct_of_isCompact_torus]
      using hf.comp_continuousLinearEquivRight (ContinuousLinearEquiv.piFinSuccAboveEquiv _ _)
  rw [circleIntegral, ← intervalIntegral.integral_smul, ← intervalIntegral.integral_prod_mul_left]
  simp_rw [circleTransform, Function.comp_def, smul_eq_mul, ← smul_assoc, ← smul_add,
    add_sub_cancel_left, ← smul_sub, ← smul_mul_assoc, ← abs.map_mul, ← abs.map_inv₀, ← abs.map_div,
    ← abs.map_pow, ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_inv, ← abs.map_natCast,
    ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul, ← abs.map_inv,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv, ← abs.map_mul,
    ← abs.map_natCast, ← abs.map_ofNat, ← abs.map_div, ← abs.map_pow, ← abs.map_inv₀, ← abs.map_mul,
    ← abs.map_natCast,

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Hausdorff.lean - 2024-09-09 01:55:14.641283.
---126/200---
For theorem MeasureTheory.Measure.mkMetric_le_liminf_tsum in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem mkMetric_le_liminf_tsum {β : Type*} {ι : β → Type*} [∀ n, Countable (ι n)] (s : Set X)
    {l : Filter β} (r : β → ℝ≥0∞) (hr : Tendsto r l (𝓝 0)) (t : ∀ n : β, ι n → Set X)
    (ht : ∀ᶠ n in l, ∀ i, diam (t n i) ≤ r n) (hst : ∀ᶠ n in l, s ⊆ ⋃ i, t n i) (m : ℝ≥0∞ → ℝ≥0∞) :
    mkMetric m s ≤ liminf (fun n => ∑' i, m (diam (t n i))) l 


Original valid proof:
:= by
  haveI : ∀ n, Encodable (ι n) := fun n => Encodable.ofCountable _
  simp only [mkMetric_apply]
  refine iSup₂_le fun ε hε => ?_
  refine le_of_forall_le_of_dense fun c hc => ?_
  rcases ((frequently_lt_of_liminf_lt (by isBoundedDefault) hc).and_eventually
        ((hr.eventually (gt_mem_nhds hε)).and (ht.and hst))).exists with
    ⟨n, hn, hrn, htn, hstn⟩
  set u : ℕ → Set X := fun j => ⋃ b ∈ decode₂ (ι n) j, t n b
  refine iInf₂_le_of_le u (by rwa [iUnion_decode₂]) ?_
  refine iInf_le_of_le (fun j => ?_) ?_
  · rw [EMetric.diam_iUnion_mem_option]
    exact iSup₂_le fun _ _ => (htn _).trans hrn.le
  · calc
      (∑' j : ℕ, ⨆ _ : (u j).Nonempty, m (diam (u j))) = _ :=
        tsum_iUnion_decode₂ (fun t : Set X => ⨆ _ : t.Nonempty, m (diam t)) (by simp) _
      _ ≤ ∑' i : ι n, m (diam (t n i)) := ENNReal.tsum_le_tsum fun b => iSup_le fun _ => le_rfl
      _ ≤ c := hn.le


Verifying proof (Commit ced4d3c0af763b9fd00166e49cf999cf46c891cc):
↔
      Tendsto (fun n => ∑' i, m (diam (t n i))) l (𝓝 (mkMetric m s)) := by
  refine' ⟨fun h => _, fun h => _⟩
  · refine'
      le_mkMetric_of_comap_le_liminf_tsum s (fun n => ⋃ i, t n i) (fun n => ⋃ i, t n i)
        (fun n => isOpen_iUnion fun i => isOpen_ball) (fun n => iUnion_subset_iff.2 fun i x hx => _)
        (fun n => iUnion_iUnion_eq_iUnion _ _) (fun n => iUnion_subset_iff.2 fun i _ => subset_iUnion _ _)
        (fun n => tendsto_iSup_nhds.2 fun i => tendsto_iUnion.2 fun _ => tendsto_principal.2 <|
          eventually_of_forall fun _ => subset_iUnion _ _) _ _
    exact mem_iUnion.2 ⟨i, hx⟩
    rcases mem_iUnion.1 hx with ⟨i, hi⟩
    exact h.trans_le (le_tsum (iUnion_subset_iff.1 (hst.2 i) _ hi) (m _) (m _))
  · refine' mkMetric_mono_tsum s _ _ _ _ _
    exacts [hst, fun n => isOpen_iUnion fun i => isOpen_ball, fun n => iUnion_subset_iff.2 fun i x hx =>
      mem_iUnion.2 ⟨i, hx⟩, fun n => tendsto_iSup_nhds.2 fun i => tendsto_iUnion.2 fun _ =>
        tendsto_principal.2 <| eventually_of_forall fun _ => subset_iUnion _ _, h]

Repaired Proof:
theorem mkMetric_le_liminf_tsum {β : Type*} {ι : β → Type*} [∀ n, Countable (ι n)] (s : Set X)
    {l : Filter β} (r : β → ℝ≥0∞) (hr : Tendsto r l (𝓝 0)) (t : ∀ n : β, ι n → Set X)
    (ht : ∀ᶠ n in l, ∀ i, diam (t n i) ≤ r n) (hst : ∀ᶠ n in l, s ⊆ ⋃ i, t n i) (m : ℝ≥0∞ → ℝ≥0∞) :
    mkMetric m s ≤ liminf (fun n => ∑' i, m (diam (t n i))) l ↔
      Tendsto (fun n => ∑' i, m (diam (t n i))) l (𝓝 (mkMetric m s)) := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine
      le_mkMetric_of_comap_le_liminf_tsum s (fun n => ⋃ i, t n i) (fun n => ⋃ i, t n i)
        (fun n => isOpen_iUnion fun i => isOpen_ball) (fun n => iUnion_subset_iff.2 fun i x hx => ?_)
        (fun n => iUnion_iUnion_eq_iUnion _ _) (fun n => iUnion_subset_iff.2 fun i _ => subset_iUnion _ _)
        (fun n => tendsto_iSup_nhds.2 fun i => tendsto_iUnion.2 fun _ => tendsto_principal.2 <|
          eventually_of_forall fun _ => subset_iUnion _ _) _ _
    exact mem_iUnion.2 ⟨i, hx⟩
    rcases mem_iUnion.1 hx with ⟨i, hi⟩
    exact h.trans_le (le_tsum (iUnion_subset_iff.1 (hst.2 i) _ hi) (m _) (m _))
  · refine mkMetric_mono_tsum s _ _ _ _ _
    exacts [hst, fun n => isOpen_iUnion fun i => isOpen_ball, fun n => iUnion_subset_iff.2 fun i x hx =>
      mem_iUnion.2 ⟨i, hx⟩, fun n => tendsto_iSup_nhds.2 fun i => tendsto_iUnion.2 fun _ =>
        tendsto_principal.2 <| eventually_of_forall fun _ => subset_iUnion _ _, h]

Repaired Proof:
theorem mkMetric_le_liminf_tsum {β : Type*} {ι : β → Type*} [∀ n, Countable (ι n)] (s : Set X)
    {l : Filter β} (r : β → ℝ≥0∞) (hr : Tendsto r l (𝓝 0)) (t : ∀ n : β, ι n → Set X)
    (ht : ∀ᶠ n in l, ∀ i, diam (t n i) ≤ r n) (hst : ∀ᶠ n in l, s ⊆ ⋃ i, t n i) (m : ℝ≥0∞ → ℝ≥0∞) :
    mkMetric m s ≤ liminf (fun n => ∑' i, m (diam (t n i))) l ↔
      Tendsto (fun n => ∑' i, m (diam (t n i))) l (𝓝 (mkMetric m s)) := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine
      le_mkMetric_of_comap_le_liminf_tsum s (fun n => ⋃ i, t n i) (fun n => ⋃ i, t n i)
        (fun n => isOpen_iUnion fun i => isOpen_ball) (fun n => iUnion_subset_iff.2 fun i x hx => ?_)
        (fun n => iUnion_iUnion_eq_iUnion _ _) (fun n => iUnion_subset_iff.2 fun i _ => subset_iUnion _ _)
        (fun n => tendsto_iSup_nhds.2 fun i => tendsto_iUnion.2 fun _ => tendsto_principal.2 <|
          eventually_of_forall fun _ => subset_iUnion _ _) _ _
    exact mem_iUnion.2 ⟨i, hx⟩
    rcases mem_iUnion.1 hx with ⟨i, hi⟩
    exact h.trans_le (le_tsum (iUnion_subset_iff.1 (hst.2 i) _ hi) (m _) (m _))
  · refine mkMetric_mono_tsum s _ _ _ _ _
    exacts [hst, fun n => isOpen_iUnion fun i => isOpen_ball, fun n => iUnion_subset_iff.2 fun i x hx =>
      mem_iUnion.2 ⟨i, hx⟩, fun n => tendsto_iSup_nhds.2 fun i => tendsto_iUnion.2 fun _ =>
        tendsto_principal.2 <| eventually_of_forall fun _ => subset_iUnion _ _, h]

Repaired Proof:
theorem mkMetric_le_liminf_tsum {β : Type*} {ι : β → Type*} [∀ n, Countable (ι n)] (s : Set X)
    {l : Filter β} (r : β → ℝ≥0∞) (hr : Tendsto r l (𝓝 0)) (t : ∀ n : β, ι n → Set X)
    (ht : ∀ᶠ n in l, ∀ i, diam (t n i) ≤ r n) (hst : ∀ᶠ n in l, s ⊆ ⋃ i, t n i) (m : ℝ≥0∞ → ℝ≥0∞) :
    mkMetric m s ≤ liminf (fun n => ∑' i, m (diam (t n i))) l ↔
      Tendsto (fun n => ∑' i, m (diam (t n i))) l (𝓝 (mkMetric m s)) := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine
      le_mkMetric_of_comap_le_liminf_tsum s (fun n => ⋃ i, t n i) (fun n => ⋃ i, t n i)
        (fun n => isOpen_iUnion fun i => isOpen_ball) (fun n => iUnion_subset_iff.2 fun i x hx => ?_)
        (fun n => iUnion_iUnion_eq_iUnion _ _) (fun n =>

Attempt failure.

---127/200---
For theorem HolderOnWith.hausdorffMeasure_image_le in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s 


Original valid proof:
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  · rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)
    · simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    · simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ⟨x, hx⟩
    · haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  · have hCd0 : (C : ℝ≥0∞) ^ d ≠ 0 := by simp [hC0.ne']
    have hCd : (C : ℝ≥0∞) ^ d ≠ ∞ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      ← ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : ℝ≥0∞ => (C : ℝ≥0∞) * d ^ (r : ℝ)) (𝓝 0) (𝓝 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      ⟨δ, δ0, H⟩
    refine le_iSup₂_of_le δ δ0 <| iInf₂_mono' fun t hst ↦
      ⟨fun n => f '' (t n ∩ s), ?_, iInf_mono' fun htδ ↦
        ⟨fun n => (h.ediam_image_inter_le (t n)).trans (H (htδ n)).le, ?_⟩⟩
    · rw [← image_iUnion, ← iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    · refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, ← ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine' ⟨_, _⟩
  · refine' (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top _ _)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine' (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top _ _)).ne _).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s ∧ μH[r * d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases h.isometry_or_nnnorm_sub_le_mul_of_lt_one hr.lt.le with (hf | hf)
  · simp only [hf.hausdorffMeasure_image_le_of_isometry hr hd, hf.nnnorm_sub_le_mul_ediam]
  refine ⟨?_, ?_⟩
  · refine (hausdorffMeasure_mono' s (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne hd).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
  · refine (hausdorffMeasure_mono' (f '' s) (hf.ediam_image_le.trans_lt (ENNReal.mul_lt_top ?_ ?_)).ne ?_).trans_le
      (ENNReal.mul_le_of_le_div' <| hf.hausdorffMeasure_image_le_of_nnnorm_sub_le_mul_ediam hr hd)
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simp only [ENNReal.coe_rpow_def, ENNReal.coe_pos]
      positivity
    · simpa only [ENNReal.div_eq_top, ENNReal.coe_rpow_def, ENNReal.coe_pos] using hr

Repaired Proof:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean - 2024-09-09 01:55:42.794074.
---128/200---
For theorem Real.volume_preserving_transvectionStruct in Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) 


Original valid proof:
:= by
  have ht : Measurable (toLin' t.toMatrix) :=
    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable
  refine ⟨ht, ?_⟩
  refine (pi_eq fun s hs ↦ ?_).symm
  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ ↦ hs i
  simp_rw [← pi_pi, ← lintegral_indicator_one h2s]
  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]
  refine lintegral_eq_of_lmarginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)
    (measurable_one.indicator h2s) ?_
  simp_rw [lmarginal_singleton]
  ext x
  cases t with | mk t_i t_j t_hij t_c =>
  simp [transvection, mulVec_stdBasisMatrix, t_hij.symm, ← Function.update_add,
    lintegral_add_right_eq_self fun xᵢ ↦ indicator (univ.pi s) 1 (Function.update x t_i xᵢ)]


Verifying proof (Commit fbfb504749d41358cab0fa037180ccfee9e3ccd4):
ℝ.volume ℝ.volume := by
  rcases t with ⟨i, j, hij, a⟩
  have : toLin' (transvection i j a) =
      LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) := by
    ext x
    simp [transvection, Matrix.transvection, LinearMap.toSpanSingleton_apply]
  have :
    LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) =
      (fun x => x + a • x j • (stdBasis ℝ (fun _ => ℝ) i 1)) := by
    ext x
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply]
  rwa [measurePreserving_add_right_of_mapsTo_support,
    measurePreserving_smul, this, toLin']
  · rintro x -
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply,
      Function.update_apply, hij]
  · exact (measurableEmbedding_toSpanSingleton ℝ (ι → ℝ) i).measurable.add_const _

Repaired Proof:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) ℝ.volume ℝ.volume := by
  rcases t with ⟨i, j, hij, a⟩
  have : toLin' (transvection i j a) =
      LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) := by
    ext x
    simp [transvection, Matrix.transvection, LinearMap.toSpanSingleton_apply]
  have :
    LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) =
      (fun x => x + a • x j • (stdBasis ℝ (fun _ => ℝ) i 1)) := by
    ext x
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply]
  rwa [measurePreserving_add_right_of_mapsTo_support,
    measurePreserving_smul, this, toLin']
  · rintro x -
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply,
      Function.update_apply, hij]
  · exact (measurableEmbedding_toSpanSingleton ℝ (ι → ℝ) i).measurable.add_const _

Repaired Proof:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) ℝ.volume ℝ.volume := by
  rcases t with ⟨i, j, hij, a⟩
  have : toLin' (transvection i j a) =
      LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) := by
    ext x
    simp [transvection, Matrix.transvection, LinearMap.toSpanSingleton_apply]
  have :
    LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) =
      (fun x => x + a • x j • (stdBasis ℝ (fun _ => ℝ) i 1)) := by
    ext x
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply]
  rwa [measurePreserving_add_right_of_mapsTo_support,
    measurePreserving_smul, this, toLin']
  · rintro x -
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply,
      Function.update_apply, hij]
  · exact (measurableEmbedding_toSpanSingleton ℝ (ι → ℝ) i).measurable.add_const _

Repaired Proof:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) ℝ.volume ℝ.volume := by
  rcases t with ⟨i, j, hij, a⟩
  have : toLin' (transvection i j a) =
      LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) := by
    ext x
    simp [transvection, Matrix.transvection, LinearMap.toSpanSingleton_apply]
  have :
    LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) =
      (fun x => x + a • x j • (stdBasis ℝ (fun _ => ℝ) i 1)) := by
    ext x
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply]
  rwa [measurePreserving_add_right_of_mapsTo_support,
    measurePreserving_smul, this, toLin']
  · rintro x -
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply,
      Function.update_apply, hij]
  · exact (measurableEmbedding_toSpanSingleton ℝ (ι → ℝ) i).measurable.add_const _

Repaired Proof:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) ℝ.volume ℝ.volume := by
  rcases t with ⟨i, j, hij, a⟩
  have : toLin' (transvection i j a) =
      LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) := by
    ext x
    simp [transvection, Matrix.transvection, LinearMap.toSpanSingleton_apply]
  have :
    LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) =
      (fun x => x + a • x j • (

Attempt failure.

---129/200---
For theorem Real.volume_preserving_transvectionStruct in Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) 


Original valid proof:
:= by
  have ht : Measurable (toLin' t.toMatrix) :=
    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable
  refine ⟨ht, ?_⟩
  refine (pi_eq fun s hs ↦ ?_).symm
  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ ↦ hs i
  simp_rw [← pi_pi, ← lintegral_indicator_one h2s]
  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]
  refine lintegral_eq_of_lmarginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)
    (measurable_one.indicator h2s) ?_
  simp_rw [lmarginal_singleton]
  ext x
  cases t with | mk t_i t_j t_hij t_c =>
  simp [transvection, mulVec_stdBasisMatrix, t_hij.symm, ← Function.update_add,
    lintegral_add_right_eq_self fun xᵢ ↦ indicator (univ.pi s) 1 (Function.update x t_i xᵢ)]


Verifying proof (Commit 8fd52fff08d5334a76b5303b5f5b92c58426a674):
ℝ.volume ℝ.volume := by
  rcases t with ⟨i, j, hij, a⟩
  have : toLin' (transvection i j a) =
      LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) := by
    ext x
    simp [transvection, Matrix.transvection, LinearMap.toSpanSingleton_apply]
  have :
    LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) =
      (fun x => x + a • x j • (stdBasis ℝ (fun _ => ℝ) i 1)) := by
    ext x
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply]
  rwa [measurePreserving_add_right_of_mapsTo_support,
    measurePreserving_smul, this, toLin']
  · rintro x -
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply,
      Function.update_apply, hij]
  · exact (measurableEmbedding_toSpanSingleton ℝ (ι → ℝ) i).measurable.add_const _

Repaired Proof:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) ℝ.volume ℝ.volume := by
  rcases t with ⟨i, j, hij, a⟩
  have : toLin' (transvection i j a) =
      LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) := by
    ext x
    simp [transvection, Matrix.transvection, LinearMap.toSpanSingleton_apply]
  have :
    LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) =
      (fun x => x + a • x j • (stdBasis ℝ (fun _ => ℝ) i 1)) := by
    ext x
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply]
  rwa [measurePreserving_add_right_of_mapsTo_support,
    measurePreserving_smul, this, toLin']
  · rintro x -
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply,
      Function.update_apply, hij]
  · exact (measurableEmbedding_toSpanSingleton ℝ (ι → ℝ) i).measurable.add_const _

Repaired Proof:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) ℝ.volume ℝ.volume := by
  rcases t with ⟨i, j, hij, a⟩
  have : toLin' (transvection i j a) =
      LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) := by
    ext x
    simp [transvection, Matrix.transvection, LinearMap.toSpanSingleton_apply]
  have :
    LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) =
      (fun x => x + a • x j • (stdBasis ℝ (fun _ => ℝ) i 1)) := by
    ext x
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply]
  rwa [measurePreserving_add_right_of_mapsTo_support,
    measurePreserving_smul, this, toLin']
  · rintro x -
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply,
      Function.update_apply, hij]
  · exact (measurableEmbedding_toSpanSingleton ℝ (ι → ℝ) i).measurable.add_const _

Repaired Proof:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) ℝ.volume ℝ.volume := by
  rcases t with ⟨i, j, hij, a⟩
  have : toLin' (transvection i j a) =
      LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) := by
    ext x
    simp [transvection, Matrix.transvection, LinearMap.toSpanSingleton_apply]
  have :
    LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) =
      (fun x => x + a • x j • (stdBasis ℝ (fun _ => ℝ) i 1)) := by
    ext x
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply]
  rwa [measurePreserving_add_right_of_mapsTo_support,
    measurePreserving_smul, this, toLin']
  · rintro x -
    simp [Pi.add_apply, Pi.smul_apply, LinearMap.toSpanSingleton_apply, stdBasis_apply,
      Function.update_apply, hij]
  · exact (measurableEmbedding_toSpanSingleton ℝ (ι → ℝ) i).measurable.add_const _

Repaired Proof:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) ℝ.volume ℝ.volume := by
  rcases t with ⟨i, j, hij, a⟩
  have : toLin' (transvection i j a) =
      LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) := by
    ext x
    simp [transvection, Matrix.transvection, LinearMap.toSpanSingleton_apply]
  have :
    LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) i 1) +
        a • LinearMap.toSpanSingleton ℝ (ι → ℝ) (stdBasis ℝ (fun _ => ℝ) j 1) =
      (fun x => x + a • x j • (

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/MeasureSpace.lean - 2024-09-09 01:56:08.013157.
---130/200---
For theorem MeasureTheory.Measure.AbsolutelyContinuous.add_right in Mathlib/MeasureTheory/Measure/MeasureSpace.lean:
lemma add_right (h1 : μ ≪ ν) (ν' : Measure α) : μ ≪ ν + ν' 


Original valid proof:
:= by
  intro s hs
  simp only [coe_add, Pi.add_apply, add_eq_zero] at hs ⊢
  exact h1 hs.1


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔ μ ≪ ν' := by
      simp only [AbsolutelyContinuous, Measure.coe_add, Pi.add_apply, add_mul,
        ENNReal.add_eq_top, or_iff_right_iff_imp, forall_and]
      rintro h s rfl
      simp [h]
    lemma smul (r : ℝ≥0∞) (h : μ ≪ ν) : μ ≪ r • ν := AbsolutelyContinuous.smul r h

    lemma smul_nnreal (r : ℝ≥0) (h : μ ≪ ν) : μ ≪ r • ν := AbsolutelyContinuous.smul_nnreal r h

    lemma map (f : α → β) (h : μ ≪ ν) : (map f μ) ≪ (map f ν) := by
      refine AbsolutelyContinuous.mk fun s hs hνs ↦ ?_
      rw [map_apply_of_aemeasurable f h.aemeasurable hs] at hνs ⊢
      exact h hνs

    lemma smul_nnreal_left {_m0 : MeasurableSpace α} (c : ℝ≥0) (μ : Measure α) :
      c • μ ≪ μ :=
      smul_absolutelyContinuous_left c.ennreal_coe_ne_top

    lemma smul_nnreal_right {_m0 : MeasurableSpace α} (c : ℝ≥0) (μ : Measure α) :
      μ ≪ c • μ := by
      rcases eq_or_ne c 0 with rfl | hc
      · simp only [zero_smul, nonpos_iff_eq_zero]
        exact fun s _ ↦ (measure_mono (empty_subset s)).antisymm (zero_le _)
      · intro s _ hsc
        simp only [smul_apply, smul_eq_mul, hc, ENNReal.mul_eq_top, or_false, false_or] at hsc
        exact (measure_mono (subset_empty_iff.2 hsc)).antisymm (zero_le _)

    lemma smul_measure_iff {c : ℝ≥0∞} (hc : c ≠ 0) (hc' : c ≠ ∞) :
      c • μ ≪ ν ↔ μ ≪ (c⁻¹ • ν) := by
      refine ⟨fun h r ↦ ?_, smul_measure_smul_nnreal_left⟩
      simp only [smul_apply, smul_eq_mul] at h
      convert h (r * c⁻¹)
      rw [mul_assoc, ENNReal.mul_inv_cancel hc hc', mul_one]

    lemma smul_nnreal_left_iff {c : ℝ≥0} (hc : c ≠ 0) :
      c • μ ≪ ν ↔ μ ≪ ν := by
      rw [smul_measure_iff hc.ne_zero hc.ne_top, smul_inv_smul₀ hc.ne_zero]

    lemma smul_measure_iff' {c : ℝ≥0∞} (hc : c ≠ 0) :
      c • μ ≪ ν ↔ c⁻¹ • μ ≪ ν := by
      refine ⟨fun h ↦ ?_, smul_measure_smul_nnreal_left⟩
      simp only [smul_apply, smul_eq_mul] at h
      convert h (c⁻¹ • ν)
      rw [smul_assoc, ENNReal.mul_inv_cancel hc.lt.ne.symm, one_smul]

    lemma smul_nnreal_left' {c : ℝ≥0} (hc : c ≠ 0) :
      c • μ ≪ ν ↔ μ ≪ ν := by
      rw [smul_measure_iff' hc.ne_zero, smul_inv_smul₀ hc.ne_zero]

    lemma smul_nnreal_right' {c : ℝ≥0} (hc : c ≠ 0) :
      μ ≪ c • ν ↔ μ ≪ ν := by
      simp_rw [← smul_nnreal_left_iff hc]
      rw [smul_comm, smul_nnreal_left_iff hc]

    lemma smul_measure_iff'' {c : ℝ≥0∞} (hc : c ≠ 0) :
      μ ≪ c • ν ↔ c⁻¹ • μ ≪ ν := by
      simp_rw [← smul_nnreal_left_iff hc, smul_comm, smul_nnreal_left_iff hc]

    lemma smul_nnreal_right' {c : ℝ≥0} (hc : c ≠ 0) :
      μ ≪ c • ν ↔ c⁻¹ • μ ≪ ν := smul_measure_iff'' hc.ne_zero

    lemma smul_measure_iff₀ {c : ℝ≥0∞} (hc : c ≠ 0) :
      c • μ ≪ ν ↔ μ ≪ (c⁻¹ • ν) := by
      rw [smul_comm, smul_measure_iff hc.inv, smul_comm]

    lemma smul_nnreal_right₀ {c : ℝ≥0∞} (hc : c ≠ 0) :
      μ ≪ c • ν ↔ c⁻¹ • μ ≪ ν := smul_measure_iff₀ hc.ne_zero

    lemma smul_measure_iff₀' {c : ℝ≥0∞} (hc : c ≠ 0) :
      c • μ ≪ ν ↔ μ ≪ (c⁻¹ • ν) := by
      rw [smul_comm, smul_measure_iff₀ hc.inv, smul_comm]

    lemma smul_nnreal_right₀' {c : ℝ≥0∞} (hc : c ≠ 0) :
      μ ≪ c • ν ↔ c⁻¹ • μ ≪ ν := smul_measure_iff₀' hc.ne_zero

    lemma smul_nnreal_left_iff₀ {c : ℝ≥0∞} (hc : c ≠ 0) :
      c • μ ≪ ν ↔ μ ≪ (c⁻¹ • ν) := by
      rw [smul_comm, smul_measure_iff₀ hc.inv, smul_comm]

    lemma smul_nnreal_left_iff₀' {c : ℝ≥0∞} (hc : c ≠ 0) :
      c • μ ≪ ν ↔ c⁻¹ • μ ≪ (c • ν) := by
      rw [smul_comm, smul_measure_iff₀' hc.inv, smul_comm]

    lemma smul_measure_iff_of_ne_zero [NoAtoms ν] {c : ℝ≥0∞} (hc : c ≠ 0) :
      c • μ ≪ ν ↔ μ ≪ ν := by
      refine ⟨fun h ↦ ?_, AbsolutelyContinuous.smul _⟩
      simp only [absolutelyContinuous_iff_le_smul, smul_assoc, smul_eq_mul] at h ⊢
      intro s _ hs
      have hνs : ν s = 0 := by
        refine (measure_zero_iff_of_ne_zero ν ?_).mp hs
        rintro ⟨t, ht, hst⟩
        exact (measure_mono hst).trans_lt ht
      simp only [hνs, mul_zero, hc.le_iff_eq, ENNReal.zero_eq_mul] at h
      simp only [hνs, h]

    lemma smul_measure_iff_of_ne_zero' [NoAtoms ν] {c : ℝ≥0∞} (hc : c ≠ 0) :
      μ ≪ c • ν ↔ μ ≪ ν := by
      simp_rw [← smul_comm, smul_measure_iff_of_ne_zero hc, smul_comm]

    lemma smul_nnreal_left_iff_of_ne_zero [NoAtoms ν] {c : ℝ≥0} (hc : c ≠ 0) :
      c • μ ≪ ν ↔ μ

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Regular.lean - 2024-09-09 01:56:24.600211.
---131/200---
For theorem MeasureTheory.Measure.OuterRegular.of_restrict in Mathlib/MeasureTheory/Measure/Regular.lean:
lemma of_restrict [OpensMeasurableSpace α] {μ : Measure α} {s : ℕ → Set α}
    (h : ∀ n, OuterRegular (μ.restrict (s n))) (h' : ∀ n, IsOpen (s n)) (h'' : univ ⊆ ⋃ n, s n) :
    OuterRegular μ 


Original valid proof:
:= by
  refine ⟨fun A hA r hr => ?_⟩
  have HA : μ A < ∞ := lt_of_lt_of_le hr le_top
  have hm : ∀ n, MeasurableSet (s n) := fun n => (h' n).measurableSet
  obtain ⟨A, hAm, hAs, hAd, rfl⟩ :
    ∃ A' : ℕ → Set α,
      (∀ n, MeasurableSet (A' n)) ∧
        (∀ n, A' n ⊆ s n) ∧ Pairwise (Disjoint on A') ∧ A = ⋃ n, A' n := by
    refine
      ⟨fun n => A ∩ disjointed s n, fun n => hA.inter (MeasurableSet.disjointed hm _), fun n =>
        inter_subset_right.trans (disjointed_subset _ _),
        (disjoint_disjointed s).mono fun k l hkl => hkl.mono inf_le_right inf_le_right, ?_⟩
    rw [← inter_iUnion, iUnion_disjointed, univ_subset_iff.mp h'', inter_univ]
  rcases ENNReal.exists_pos_sum_of_countable' (tsub_pos_iff_lt.2 hr).ne' ℕ with ⟨δ, δ0, hδε⟩
  rw [lt_tsub_iff_right, add_comm] at hδε
  have : ∀ n, ∃ U ⊇ A n, IsOpen U ∧ μ U < μ (A n) + δ n := by
    intro n
    have H₁ : ∀ t, μ.restrict (s n) t = μ (t ∩ s n) := fun t => restrict_apply' (hm n)
    have Ht : μ.restrict (s n) (A n) ≠ ∞ := by
      rw [H₁]
      exact ((measure_mono (inter_subset_left.trans (subset_iUnion A n))).trans_lt HA).ne
    rcases (A n).exists_isOpen_lt_add Ht (δ0 n).ne' with ⟨U, hAU, hUo, hU⟩
    rw [H₁, H₁, inter_eq_self_of_subset_left (hAs _)] at hU
    exact ⟨U ∩ s n, subset_inter hAU (hAs _), hUo.inter (h' n), hU⟩
  choose U hAU hUo hU using this
  refine ⟨⋃ n, U n, iUnion_mono hAU, isOpen_iUnion hUo, ?_⟩
  calc
    μ (⋃ n, U n) ≤ ∑' n, μ (U n) := measure_iUnion_le _
    _ ≤ ∑' n, (μ (A n) + δ n) := ENNReal.tsum_le_tsum fun n => (hU n).le
    _ = ∑' n, μ (A n) + ∑' n, δ n := ENNReal.tsum_add
    _ = μ (⋃ n, A n) + ∑' n, δ n := (congr_arg₂ (· + ·) (measure_iUnion hAd hAm).symm rfl)
    _ < r := hδε


Verifying proof (Commit 4a554788a29923d4384640e3dd9b0126a26f18bb):
∧ ∀ n, μ (s n) = 0 := by
  constructor
  · refine OuterRegular.of_iUnion_isOpen_ae_diff_eq_zero h' (by simp) (fun n ↦ ?_)
    have : μ (s n) = ∞ → μ (s n) = 0 := by
      intro hμ
      have : μ (s n) ≠ ∞ := by
        intro H
        rw [H] at hμ
        exact hμ rfl
      exact (lt_top_iff_ne_top.2 this).ne
    rw [restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _),
      this (measure_eq_top_of_outerRegular_of_restrict _ (h n) _)]
    exact measure_empty
  · intro n
    have : μ (s n) ≠ ∞ := by
      intro H
      rw [H] at h''
      have : μ (univ : Set α) = ∞ := by
        refine le_antisymm ?_ H.le
        rw [← measure_iUnion_null_iff]
        exact h''
      exact ENNReal.lt_top_iff_ne_top.2 this.ne rfl
    rw [restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _),
      OuterRegular.measure_eq_top_iff_exists_isOpen_diff_eq_zero (h n), ← restrict_apply' (h' n),
      restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _)] at this
    exact this.resolve_right (measure_ne_top μ _)

Repaired Proof:
lemma of_restrict [OpensMeasurableSpace α] {μ : Measure α} {s : ℕ → Set α}
    (h : ∀ n, OuterRegular (μ.restrict (s n))) (h' : ∀ n, IsOpen (s n)) (h'' : univ ⊆ ⋃ n, s n) :
    OuterRegular μ ∧ ∀ n, μ (s n) = 0 := by
  constructor
  · refine OuterRegular.of_iUnion_isOpen_ae_diff_eq_zero h' (by simp) (fun n ↦ ?_)
    have : μ (s n) = ∞ → μ (s n) = 0 := by
      intro hμ
      have : μ (s n) ≠ ∞ := by
        intro H
        rw [H] at hμ
        exact hμ rfl
      exact (lt_top_iff_ne_top.2 this).ne
    rw [restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _),
      this (measure_eq_top_of_outerRegular_of_restrict _ (h n) _)]
    exact measure_empty
  · intro n
    have : μ (s n) ≠ ∞ := by
      intro H
      rw [H] at h''
      have : μ (univ : Set α) = ∞ := by
        refine le_antisymm ?_ H.le
        rw [← measure_iUnion_null_iff]
        exact h''
      exact ENNReal.lt_top_iff_ne_top.2 this.ne rfl
    rw [restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _),
      OuterRegular.measure_eq_top_iff_exists_isOpen_diff_eq_zero (h n), ← restrict_apply' (h' n),
      restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _)] at this
    exact this.resolve_right (measure_ne_top μ _)

Repaired Proof:
lemma of_restrict [OpensMeasurableSpace α] {μ : Measure α} {s : ℕ → Set α}
    (h : ∀ n, OuterRegular (μ.restrict (s n))) (h' : ∀ n, IsOpen (s n)) (h'' : univ ⊆ ⋃ n, s n) :
    OuterRegular μ ∧ ∀ n, μ (s n) = 0 := by
  constructor
  · refine OuterRegular.of_iUnion_isOpen_ae_diff_eq_zero h' (by simp) (fun n ↦ ?_)
    have : μ (s n) = ∞ → μ (s n) = 0 := by
      intro hμ
      have : μ (s n) ≠ ∞ := by
        intro H
        rw [H] at hμ
        exact hμ rfl
      exact (lt_top_iff_ne_top.2 this).ne
    rw [restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _),
      this (measure_eq_top_of_outerRegular_of_restrict _ (h n) _)]
    exact measure_empty
  · intro n
    have : μ (s n) ≠ ∞ := by
      intro H
      rw [H] at h''
      have : μ (univ : Set α) = ∞ := by
        refine le_antisymm ?_ H.le
        rw [← measure_iUnion_null_iff]
        exact h''
      exact ENNReal.lt_top_iff_ne_top.2 this.ne rfl
    rw [restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _),
      OuterRegular.measure_eq_top_iff_exists_isOpen_diff_eq_zero (h n), ← restrict_apply' (h' n),
      restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _)] at this
    exact this.resolve_right (measure_ne_top μ _)

Repaired Proof:
lemma of_restrict [OpensMeasurableSpace α] {μ : Measure α} {s : ℕ → Set α}
    (h : ∀ n, OuterRegular (μ.restrict (s n))) (h' : ∀ n, IsOpen (s n)) (h'' : univ ⊆ ⋃ n, s n) :
    OuterRegular μ ∧ ∀ n, μ (s n) = 0 := by
  constructor
  · refine OuterRegular.of_iUnion_isOpen_ae_diff_eq_zero h' (by simp) (fun n ↦ ?_)
    have : μ (s n) = ∞ → μ (s n) = 0 := by
      intro hμ
      have : μ (s n) ≠ ∞ := by
        intro H
        rw [H] at hμ
        exact hμ rfl
      exact (lt_top_iff_ne_top.2 this).ne
    rw [restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _),
      this (measure_eq_top_of_outerRegular_of_restrict _ (h n) _)]
    exact measure_empty
  · intro n
    have : μ (s n) ≠ ∞ := by
      intro H
      rw [H] at h''
      have : μ (univ : Set α) = ∞ := by
        refine le_antisymm ?_ H.le
        rw [← measure_iUnion_null_iff]
        exact h''
      exact ENNReal.lt_top_iff_ne_top.2 this.ne rfl
    rw [restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _),
      OuterRegular.measure_eq_top_iff_exists_isOpen_diff_eq_zero (h n), ← restrict_apply' (h' n),
      restrict_apply' (h' n), inter_eq_self_of_subset_left (subset_univ _)] at this
    exact this.resolve_right (measure_ne_top μ _)

Repaired Proof:
lemma of_restrict [OpensMeasurableSpace α] {μ : Measure α} {s : ℕ → Set α}
    (h : ∀ n, OuterRegular (μ.restrict (s n))) (h' : ∀ n, IsOpen (s n)) (h'' : univ ⊆ ⋃ n, s n) :
    OuterRegular μ ∧ ∀ n, μ (s n) = 0 := by
  constructor
  · refine OuterRegular.of_iUnion_isOpen_ae_diff_eq_zero h' (by simp) (fun n ↦ ?_)
    have : μ (s n) = ∞ → μ (s n) = 0 :=

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Restrict.lean - 2024-09-09 01:56:34.105075.
---132/200---
For theorem MeasureTheory.Measure.restrict_union_congr in Mathlib/MeasureTheory/Measure/Restrict.lean:
theorem restrict_union_congr :
    μ.restrict (s ∪ t) = ν.restrict (s ∪ t) ↔
      μ.restrict s = ν.restrict s ∧ μ.restrict t = ν.restrict t 


Original valid proof:
:= by
  refine
    ⟨fun h =>
      ⟨restrict_congr_mono subset_union_left h,
        restrict_congr_mono subset_union_right h⟩,
      ?_⟩
  rintro ⟨hs, ht⟩
  ext1 u hu
  simp only [restrict_apply hu, inter_union_distrib_left]
  rcases exists_measurable_superset₂ μ ν (u ∩ s) with ⟨US, hsub, hm, hμ, hν⟩
  calc
    μ (u ∩ s ∪ u ∩ t) = μ (US ∪ u ∩ t) :=
      measure_union_congr_of_subset hsub hμ.le Subset.rfl le_rfl
    _ = μ US + μ ((u ∩ t) \ US) := (measure_add_diff hm _).symm
    _ = restrict μ s u + restrict μ t (u \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hμ, ← inter_comm t, inter_diff_assoc]
    _ = restrict ν s u + restrict ν t (u \ US) := by rw [hs, ht]
    _ = ν US + ν ((u ∩ t) \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hν, ← inter_comm t, inter_diff_assoc]
    _ = ν (US ∪ u ∩ t) := measure_add_diff hm _
    _ = ν (u ∩ s ∪ u ∩ t) := Eq.symm <| measure_union_congr_of_subset hsub hν.le Subset.rfl le_rfl


Verifying proof (Commit 6402a4dd7bfe402e3a2139adfa6bac90aa088050):
∧ Disjoint s t := by
  refine' ⟨fun h => ⟨_, _, disjoint_of_subset_left subset_union_left h.symm⟩, fun h => _⟩
  · rwa [← restrict_union_add_inter s t, add_right_inj]
  · rwa [restrict_union_add_inter]


theorem restrict_union_congr' (h : Disjoint s t) :
    μ.restrict (s ∪ t) = ν.restrict (s ∪ t) ↔ μ.restrict s = ν.restrict s ∧ μ.restrict t = ν.restrict t :=
  restrict_union_congr.trans <|
    and_congr_right' <| by
      simp [restrict_congr_set, inter_comm, h.inter_eq]


theorem restrict_union₀ (h : AEDisjoint μ s t) (ht : NullMeasurableSet t μ) :
    μ.restrict (s ∪ t) = μ.restrict s + μ.restrict t := by
  simp [← restrict_union_add_inter s ht, restrict_zero_set h, add_zero]


theorem restrict_union (h : Disjoint s t) (ht : MeasurableSet t) :
    μ.restrict (s ∪ t) = μ.restrict s + μ.restrict t :=
  restrict_union₀ h.aedisjoint ht.nullMeasurableSet


theorem restrict_union' (h : Disjoint s t) (hs : MeasurableSet s) :
    μ.restrict (s ∪ t) = μ.restrict s + μ.restrict t := by
  rw [union_comm, restrict_union h.symm hs, add_comm]


theorem restrict_union_add_inter' (s t : Set α) :
    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by
  simpa [← restrict_union_add_inter, ← restrict_inter_add_diff, restrict_zero_set,
    inter_comm] using restrict_union_add_inter s t


theorem restrict_union_add_inter₀ (s t : Set α) (h : AEDisjoint μ s t) :
    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by
  simpa [← restrict_union_add_inter, ← restrict_inter_add_diff₀, restrict_zero_set,
    inter_comm] using restrict_union_add_inter₀ s t h


theorem restrict_union_add_inter (s t : Set α) (h : Disjoint s t) :
    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t :=
  restrict_union_add_inter₀ s t h.aedisjoint


theorem restrict_union_add_inter' (s t : Set α) (h : Disjoint s t) :
    μ.restrict (s ∪ t) + μ.restrict (t ∩ s) = μ.restrict t + μ.restrict s := by
  rw [union_comm, inter_comm, restrict_union_add_inter h.symm]


theorem restrict_union_add_inter_of_measurableSet [DecidablePred (· ∈ s)] (hst : Disjoint s t)
    (hs : MeasurableSet s) :
    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by
  have : ∀ u, μ.restrict (s ∪ u) + μ.restrict (s ∩ u) = μ.restrict s + μ.restrict u := by
    intro u
    have : s ∩ u = s ∩ (t ∪ u) \ (s ∩ t) := by
      rw [inter_distrib_right, inter_union_diff]
    rw [this, restrict_union (hst.mono inf_le_right inf_le_right),
      restrict_diff (hs.inter (MeasurableSet.union ht hu)), ← add_assoc,
      add_right_comm, add_right_inj]
    simp [hst.inter_eq, measure_inter_add_diff _ (hs.inter ht)]
  simpa [union_comm] using this t


theorem restrict_union_add_inter_of_measurableSet' [DecidablePred (· ∈ t)] (hst : Disjoint s t)
    (ht : MeasurableSet t) :
    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by
  simpa [union_comm, inter_comm, hst.symm.inter_eq] using
    restrict_union_add_inter_of_measurableSet hst.symm ht


theorem restrict_union_add_inter_of_cover [DecidablePred (· ∈ s ∪ t)] (h : s ∪ t = univ) :
    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by
  have : μ.restrict (s ∪ t) = μ.restrict (s ∪ t) + μ.restrict (s ∩ t) + μ.restrict (s ∩ tᶜ) := by
    simp only [← restrict_union (disjoint_of_subset_left inter_subset_right disjoint_compl_right)
      inter_subset_left inter_subset_right,
      restrict_union (disjoint_of_subset_left inter_subset_right disjoint_compl_right) inter_subset_right,
      h, restrict_univ, add_assoc, add_left_inj, add_right_inj, add_halves]
  simpa [h] using this


theorem restrict_union_add_inter_of_cover' [DecidablePred (· ∈ t ∪ s)] (h : t ∪ s = univ) :
    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by
  simpa [union_comm, inter_comm, h] using restrict_union_add_inter_of_cover h


theorem restrict_union_add_inter_le [DecidablePred (· ∈ s ∪ t)] (h : s ∪ t = univ) :
    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) ≤ μ.restrict s + μ.restrict t := by
  convert le_of_eq (restrict_union_add_inter_of_cover h)
  simp


theorem restrict_union_add_inter_le' [DecidablePred (· ∈ t ∪ s)] (h : t ∪ s = univ) :
    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) ≤ μ.restrict s + μ.restrict t := by
  simpa [union_comm, inter_comm, h] using restrict_union_add_inter_le h


theorem restrict_union_add_inter [DecidablePred (· ∈ s ∪ t)] (h : s ∪ t = univ) :
    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by
  refine le_antisymm (restrict_union_add_inter_le h) ?_
  have : μ.restrict (s ∪ t) + μ.restrict (t \ s) ≤ μ.restrict t + μ.restrict (s \ t) :=
    restrict_union_add_inter_le diff_union_self
  rwa [union_comm, diff_union_self, inter_comm, add_right_comm, add_left_comm] at this


theorem restrict_union_add_inter' [DecidablePred (· ∈ s ∪ t)] (h : s ∪ t = univ) :
    μ.restrict (s ∪ t) + μ.restrict (t ∩ s) = μ.restrict t + μ.restrict s := by
  simpa [union_comm, inter_comm, h] using restrict_union_add_inter h


theorem restrict_union_add_inter_eq_aux [DecidablePred (· ∈ s ∪ t)]
    (h : s ∪ t = univ) (ht : MeasurableSet t) :
    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by
  refine le_antisymm (restrict_union_add_inter_le h) ?_
  have A : μ.restrict (s ∪ t) =

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Stieltjes.lean - 2024-09-09 01:56:53.662353.
---133/200---
For theorem StieltjesFunction.measure_Ioc in Mathlib/MeasureTheory/Measure/Stieltjes.lean:
theorem measure_Ioc (a b : ℝ) : f.measure (Ioc a b) = ofReal (f b - f a) 


Original valid proof:
:= by
  rw [StieltjesFunction.measure]
  exact f.outer_Ioc a b


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
    (f b - f a).toNNReal = (f b - f a).toReal := by
  have h_eq_add : Ioc a b = Icc a b \ {a} ∪ {a} ∪ Ioo a b := by
    rw [← Icc_diff_left, ← Ioo_union_left, ← union_assoc,
      union_comm (singleton a), ← union_assoc, diff_union_self, union_comm (singleton a)]
  have h_disj : Disjoint (Icc a b \ {a}) {a} ∧ Disjoint {a} (Ioo a b) := by
    constructor
    · rw [Set.disjoint_singleton_left]
      exact fun h => (Set.not_mem_diff_of_mem (Set.left_mem_Icc.mpr (le_refl a)) h).elim
    · rw [Set.disjoint_singleton_right]
      exact fun h => (Set.not_mem_Ioo_of_le (le_refl a)) h
  rw [h_eq_add, f.measure_union h_disj.1 h_disj.2, f.measure_singleton, f.measure_Icc,
    ENNReal.ofReal_add (sub_nonneg.mpr (f.mono (le_refl a))).toReal_nonneg
    (sub_nonneg.mpr (f.mono (le_refl b))).toReal_nonneg,
    ENNReal.ofReal_toReal (sub_nonneg.mpr (f.mono (le_refl a))).toReal_nonneg,
    ENNReal.ofReal_toReal (sub_nonneg.mpr (f.mono (le_refl b))).toReal_nonneg]
  simp only [sub_eq_add_neg, neg_mul, ENNReal.ofReal_add, ENNReal.ofReal_neg]
  rw [ENNReal.add_comm, ENNReal.add_assoc, ENNReal.add_comm (ofReal (f a)),
    ← ENNReal.add_assoc (ofReal (f a)), ENNReal.add_self, ENNReal.add_zero]

Repaired Proof:
theorem measure_Ioc (a b : ℝ) : f.measure (Ioc a b) = ofReal (f b - f a) ∧
    (f b - f a).toNNReal = (f b - f a).toReal := by
  have h_eq_add : Ioc a b = Icc a b \ {a} ∪ {a} ∪ Ioo a b := by
    rw [← Icc_diff_left, ← Ioo_union_left, ← union_assoc,
      union_comm (singleton a), ← union_assoc, diff_union_self, union_comm (singleton a)]
  have h_disj : Disjoint (Icc a b \ {a}) {a} ∧ Disjoint {a} (Ioo a b) := by
    constructor
    · rw [Set.disjoint_singleton_left]
      exact fun h => (Set.not_mem_diff_of_mem (Set.left_mem_Icc.mpr (le_refl a)) h).elim
    · rw [Set.disjoint_singleton_right]
      exact fun h => (Set.not_mem_Ioo_of_le (le_refl a)) h
  rw [h_eq_add, f.measure_union h_disj.1 h_disj.2, f.measure_singleton, f.measure_Icc,
    ENNReal.ofReal_add (sub_nonneg.mpr (f.mono (le_refl a))).toReal_nonneg
    (sub_nonneg.mpr (f.mono (le_refl b))).toReal_nonneg,
    ENNReal.ofReal_toReal (sub_nonneg.mpr (f.mono (le_refl a))).toReal_nonneg,
    ENNReal.ofReal_toReal (sub_nonneg.mpr (f.mono (le_refl b))).toReal_nonneg]
  simp only [sub_eq_add_neg, neg_mul, ENNReal.ofReal_add, ENNReal.ofReal_neg]
  rw [ENNReal.add_comm, ENNReal.add_assoc, ENNReal.add_comm (ofReal (f a)),
    ← ENNReal.add_assoc (ofReal (f a)), ENNReal.add_self, ENNReal.add_zero]

Repaired Proof:
theorem measure_Ioc (a b : ℝ) : f.measure (Ioc a b) = ofReal (f b - f a) ∧
    (f b - f a).toNNReal = (f b - f a).toReal := by
  have h_eq_add : Ioc a b = Icc a b \ {a} ∪ {a} ∪ Ioo a b := by
    rw [← Icc_diff_left, ← Ioo_union_left, ← union_assoc,
      union_comm (singleton a), ← union_assoc, diff_union_self, union_comm (singleton a)]
  have h_disj : Disjoint (Icc a b \ {a}) {a} ∧ Disjoint {a} (Ioo a b) := by
    constructor
    · rw [Set.disjoint_singleton_left]
      exact fun h => (Set.not_mem_diff_of_mem (Set.left_mem_Icc.mpr (le_refl a)) h).elim
    · rw [Set.disjoint_singleton_right]
      exact fun h => (Set.not_mem_Ioo_of_le (le_refl a)) h
  rw [h_eq_add, f.measure_union h_disj.1 h_disj.2, f.measure_singleton, f.measure_Icc,
    ENNReal.ofReal_add (sub_nonneg.mpr (f.mono (le_refl a))).toReal_nonneg
    (sub_nonneg.mpr (f.mono (le_refl b))).toReal_nonneg,
    ENNReal.ofReal_toReal (sub_nonneg.mpr (f.mono (le_refl a))).toReal_nonneg,
    ENNReal.ofReal_toReal (sub_nonneg.mpr (f.mono (le_refl b))).toReal_nonneg]
  simp only [sub_eq_add_neg, neg_mul, ENNReal.ofReal_add, ENNReal.ofReal_neg]
  rw [ENNReal.add_comm, ENNReal.add_assoc, ENNReal.add_comm (ofReal (f a)),
    ← ENNReal.add_assoc (ofReal (f a)), ENNReal.add_self, ENNReal.add_zero]

Repaired Proof:
theorem measure_Ioc (a b : ℝ) : f.measure (Ioc a b) = ofReal (f b - f a) ∧
    (f b - f a).toNNReal = (f b - f a).toReal := by
  have h_eq_add : Ioc a b = Icc a b \ {a} ∪ {a} ∪ Ioo a b := by
    rw [← Icc_diff_left, ← Ioo_union_left, ← union_assoc,
      union_comm (singleton a), ← union_assoc, diff_union_self, union_comm (singleton a)]
  have h_disj : Disjoint (Icc a b \ {a}) {a} ∧ Disjoint {a} (Ioo a b) := by
    constructor
    · rw [Set.disjoint_singleton_left]
      exact fun h => (Set.not_mem_diff_of_mem (Set.left_mem_Icc.mpr (le_refl a)) h).elim
    · rw [Set.disjoint_singleton_right]
      exact fun h => (Set.not_mem_Ioo_of_le (le_refl a)) h
  rw [h_eq_add, f.measure_union h_disj.1 h_disj.2, f.measure_singleton, f.measure_Icc,
    ENNReal.ofReal_add (sub_nonneg.mpr (f.mono (le_refl a))).toReal_nonneg
    (sub_nonneg.mpr (f.mono (le_refl b))).toReal_nonneg,
    ENNReal.ofReal_toReal (sub_nonneg.mpr (f.mono (le_refl a))).toReal_nonneg,
    ENNReal.ofReal_toReal (sub_nonneg.mpr (f.mono (le_refl b))).toReal_nonneg]
  simp only [sub_eq_add_neg, neg_mul, ENN

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Tilted.lean - 2024-09-09 01:57:02.949845.
---134/200---
For theorem MeasureTheory.rnDeriv_tilted_right in Mathlib/MeasureTheory/Measure/Tilted.lean:
lemma rnDeriv_tilted_right (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν]
    (hf : Integrable (fun x ↦ exp (f x)) ν) :
    μ.rnDeriv (ν.tilted f)
      =ᵐ[ν] fun x ↦ ENNReal.ofReal (exp (- f x) * ∫ x, exp (f x) ∂ν) * μ.rnDeriv ν x 


Original valid proof:
:= by
  cases eq_zero_or_neZero ν with
  | inl h => simp_rw [h, ae_zero, Filter.EventuallyEq]; exact Filter.eventually_bot
  | inr h0 =>
    refine (Measure.rnDeriv_withDensity_right μ ν ?_ ?_ ?_).trans ?_
    · exact (hf.1.aemeasurable.div_const _).ennreal_ofReal
    · filter_upwards
      simp only [ne_eq, ENNReal.ofReal_eq_zero, not_le]
      exact fun _ ↦ div_pos (exp_pos _) (integral_exp_pos hf)
    · refine ae_of_all _ (by simp)
    · filter_upwards with x
      congr
      rw [← ENNReal.ofReal_inv_of_pos, inv_div', ← exp_neg, div_eq_mul_inv, inv_inv]
      exact div_pos (exp_pos _) (integral_exp_pos hf)


Verifying proof (Commit 5522fc375dfd18ea7496d18f560309e857582ca8):
•
        (fun x ↦ exp (f x)) μ := by
  refine (rnDeriv_eq_ae_smul μ (ν.tilted f) ?_ ?_ ?_).symm
  · exact (hf.const_mul _).integrable_exp
  · exact (integrable_exp_mul_rnDeriv hf).const_mul _
  · filter_upwards [Measure.rnDeriv_lt_top μ ν] with x hx
    rw [Pi.smul_apply, smul_eq_mul, mul_assoc, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_mul (exp_pos _).le,
      ← ENNReal.ofReal_mul (exp_pos _).le, ← ENNReal.ofReal_

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Typeclasses.lean - 2024-09-09 01:57:14.176184.
---135/200---
For theorem MeasureTheory.abs_toReal_measure_sub_le_measure_symmDiff' in Mathlib/MeasureTheory/Measure/Typeclasses.lean:
theorem abs_toReal_measure_sub_le_measure_symmDiff'
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hs' : μ s ≠ ∞) (ht' : μ t ≠ ∞) :
    |(μ s).toReal - (μ t).toReal| ≤ (μ (s ∆ t)).toReal 


Original valid proof:
:= by
  have hst : μ (s \ t) ≠ ∞ := (measure_lt_top_of_subset diff_subset hs').ne
  have hts : μ (t \ s) ≠ ∞ := (measure_lt_top_of_subset diff_subset ht').ne
  suffices (μ s).toReal - (μ t).toReal = (μ (s \ t)).toReal - (μ (t \ s)).toReal by
    rw [this, measure_symmDiff_eq hs ht, ENNReal.toReal_add hst hts]
    convert abs_sub (μ (s \ t)).toReal (μ (t \ s)).toReal <;> simp
  rw [measure_diff' s ht ht', measure_diff' t hs hs',
    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top hs' ht'),
    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top ht' hs'),
    union_comm t s]
  abel


Verifying proof (Commit 089ac90928952b8a08be66ede7ff142d0f9ba666):
↔ μ s ≤ μ t ∨ μ t ≤ μ s := by
  rw [abs_toReal_sub_le_iff,
    or_iff_not_imp_left, le_measure_symmDiff_iff_le_add_of_ne_top hs ht hs' ht',
    ENNReal.toReal_add hs' ht', add_comm]
  rintro h rfl
  simp [ht']

Repaired Proof:
theorem abs_toReal_measure_sub_le_measure_symmDiff'
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hs' : μ s ≠ ∞) (ht' : μ t ≠ ∞) :
    |(μ s).toReal - (μ t).toReal| ≤ (μ (s ∆ t)).toReal ↔ μ s ≤ μ t ∨ μ t ≤ μ s := by
  rw [abs_toReal_sub_le_iff,
    or_iff_not_imp_left, le_measure_symmDiff_iff_le_add_of_ne_top hs ht hs' ht',
    ENNReal.toReal_add hs' ht', add_comm]
  rintro h rfl
  simp [ht']

Repaired Proof:
theorem abs_toReal_measure_sub_le_measure_symmDiff'
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hs' : μ s ≠ ∞) (ht' : μ t ≠ ∞) :
    |(μ s).toReal - (μ t).toReal| ≤ (μ (s ∆ t)).toReal ↔ μ s ≤ μ t ∨ μ t ≤ μ s := by
  rw [abs_toReal_sub_le_iff,
    or_iff_not_imp_left, le_measure_symmDiff_iff_le_add_of_ne_top hs ht hs' ht',
    ENNReal.toReal_add hs' ht', add_comm]
  rintro h rfl
  simp [ht']

Repaired Proof:
theorem abs_toReal_measure_sub_le_measure_symmDiff'
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hs' : μ s ≠ ∞) (ht' : μ t ≠ ∞) :
    |(μ s).toReal - (μ t).toReal| ≤ (μ (s ∆ t)).toReal ↔ μ s ≤ μ t ∨ μ t ≤ μ s := by
  rw [abs_toReal_sub_le_iff,
    or_iff_not_imp_left, le_measure_symmDiff_iff_le_add_of_ne_top hs ht hs' ht',
    ENNReal.toReal_add hs' ht', add_comm]
  rintro h rfl
  simp [ht']

Repaired Proof:
theorem abs_toReal_measure_sub_le_measure_symmDiff'
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hs' : μ s ≠ ∞) (ht' : μ t ≠ ∞) :
    |(μ s).toReal - (μ t).toReal| ≤ (μ (s ∆ t)).toReal ↔ μ s ≤ μ t ∨ μ t ≤ μ s := by
  rw [abs_toReal_sub_le_iff,
    or_iff_not_imp_left, le_measure_symmDiff_iff_le_add_of_ne_top hs ht hs' ht',
    ENNReal.toReal_add hs' ht', add_comm]
  rintro h rfl
  simp [ht']

Attempt failure.

Working on Mathlib/MeasureTheory/OuterMeasure/Caratheodory.lean - 2024-09-09 01:57:25.597226.
---136/200---
For theorem MeasureTheory.OuterMeasure.f_iUnion in Mathlib/MeasureTheory/OuterMeasure/Caratheodory.lean:
theorem f_iUnion {s : ℕ → Set α} (h : ∀ i, IsCaratheodory m (s i)) (hd : Pairwise (Disjoint on s)) :
    m (⋃ i, s i) = ∑' i, m (s i) 


Original valid proof:
:= by
  refine le_antisymm (measure_iUnion_le s) ?_
  rw [ENNReal.tsum_eq_iSup_nat]
  refine iSup_le fun n => ?_
  have := @isCaratheodory_sum _ m _ h hd univ n
  simp only [inter_comm, inter_univ, univ_inter] at this; simp only [this, ge_iff_le]
  exact m.mono (iUnion₂_subset fun i _ => subset_iUnion _ i)


Verifying proof (Commit 727c4bcd221ef8565e3e1ca42cccebc21e65c52f):
∨ m (⋃ i, s i) = ∞ := by
  have hm : ∀ t : Set α, m t = m (t ∩ ⋃ i, s i) + m (t \ ⋃ i, s i) := by
    intro t
    have hm₁ : m t = m (t ∩ ⋃ i, s i) + m (t \ ⋃ i, s i) := by
      rw [← union_diff_cancel (subset_iUnion s), m.isCaratheodory_iff_union.1 (h _)]
      simp only [inter_union_diff]
    rcases eq_or_ne (m (t ∩ ⋃ i, s i)) ∞ with hm₁' | hm₁'
    · simp only [hm₁', add_top]
    · rcases eq_or_ne (m (t \ ⋃ i, s i)) ∞ with hm₁'' | hm₁''
      · simp only [hm₁'', add_top]
      · simp only [hm₁, hm₁', hm₁'']
  have hm₁ : m (⋃ i, s i) ≤ ∑' i, m (s i) := by
    refine' le_of_tendsto' _ fun t => _
    simp_rw [tsum_apply, hm]
    refine' le_add_left _
    have hm₂ : m (t ∩ ⋃ i, s i) ≤ ∑' i, m (t ∩ s i) := by
      refine' m.mono _
      simp_rw [inter_iUnion]
      exact inter_subset_right
    refine' le_trans hm₂ _
    refine' tsum_le_tsum _ (summable_of_isCaratheodory h _) (summable_of_isCaratheodory h _)
    intro i
    simp_rw [inter_comm t]
    exact m.mono (inter_subset_right.trans (subset_iUnion s i))
  refine' or_iff_not_imp_right.2 fun hm₂ => _
  refine' le_antisymm hm₁ _
  have hm₃ : ∀ t, m t = ∑' i, m (t ∩ s i) := by
    intro t
    simp_rw [tsum_apply, hm]
    refine' add_left_injective _ (hm₂ _)
    simp_rw [tsum_eq_top_of_eq_top (m.measure_iUnion_null_iff.2 hd), add_top]
  refine' le_of_tendsto' _ fun t => _
  simp_rw [hm₃]
  refine' le_trans _ (measure_iUnion_le _)
  refine' iUnion_mono fun i => _
  simp_rw [inter_comm t]
  exact inter_subset_right

Repaired Proof:
theorem f_iUnion {s : ℕ → Set α} (h : ∀ i, IsCaratheodory m (s i)) (hd : Pairwise (Disjoint on s)) :
    m (⋃ i, s i) = ∑' i, m (s i) ∨ m (⋃ i, s i) = ∞ := by
  have hm : ∀ t : Set α, m t = m (t ∩ ⋃ i, s i) + m (t \ ⋃ i, s i) := by
    intro t
    have hm₁ : m t = m (t ∩ ⋃ i, s i) + m (t \ ⋃ i, s i) := by
      rw [← union_diff_cancel (subset_iUnion s), m.isCaratheodory_iff_union.1 (h _)]
      simp only [inter_union_diff]
    rcases eq_or_ne (m (t ∩ ⋃ i, s i)) ∞ with hm₁' | hm₁'
    · simp only [hm₁', add_top]
    · rcases eq_or_ne (m (t \ ⋃ i, s i)) ∞ with hm₁'' | hm₁''
      · simp only [hm₁'', add_top]
      · simp only [hm₁, hm₁', hm₁'']
  have hm₁ : m (⋃ i, s i) ≤ ∑' i, m (s i) := by
    refine le_of_tendsto' ?_ fun t => ?_
    simp_rw [tsum_apply, hm]
    refine le_add_left ?_
    have hm₂ : m (t ∩ ⋃ i, s i) ≤ ∑' i, m (t ∩ s i) := by
      refine m.mono ?_
      simp_rw [inter_iUnion]
      exact inter_subset_right
    refine le_trans hm₂ ?_
    refine tsum_le_tsum ?_ (summable_of_isCaratheodory h _) (summable_of_isCaratheodory h _)
    intro i
    simp_rw [inter_comm t]
    exact m.mono (inter_subset_right.trans (subset_iUnion s i))
  refine or_iff_not_imp_right.2 fun hm₂ => ?_
  refine le_antisymm hm₁ ?_
  have hm₃ : ∀ t, m t = ∑' i, m (t ∩ s i) := by
    intro t
    simp_rw [tsum_apply, hm]
    refine add_left_injective _ (hm₂ _)
    simp_rw [tsum_eq_top_of_eq_top (m.measure_iUnion_null_iff.2 hd), add_top]
  refine le_of_tendsto' ?_ fun t => ?_
  simp_rw [hm₃]
  refine le_trans ?_ (measure_iUnion_le _)
  refine iUnion_mono fun i => ?_
  simp_rw [inter_comm t]
  exact inter_subset_right

Repaired Proof:
theorem f_iUnion {s : ℕ → Set α} (h : ∀ i, IsCaratheodory m (s i)) (hd : Pairwise (Disjoint on s)) :
    m (⋃ i, s i) = ∑' i, m (s i) ∨ m (⋃ i, s i) = ∞ := by
  have hm : ∀ t : Set α, m t = m (t ∩ ⋃ i, s i) + m (t \ ⋃ i, s i) := by
    intro t
    have hm₁ : m t = m (t ∩ ⋃ i, s i) + m (t \ ⋃ i, s i) := by
      rw [← union_diff_cancel (subset_iUnion s), m.isCaratheodory_iff_union.1 (h _)]
      simp only [inter_union_diff]
    rcases eq_or_ne (m (t ∩ ⋃ i, s i)) ∞ with hm₁' | hm₁'
    · simp only [hm₁', add_top]
    · rcases eq_or_ne (m (t \ ⋃ i, s i)) ∞ with hm₁'' | hm₁''
      · simp only [hm₁'', add_top]
      · simp only [hm₁, hm₁', hm₁'']
  have hm₁ : m (⋃ i, s i) ≤ ∑' i, m (s i) := by
    refine le_of_tendsto' ?_ fun t => ?_
    simp_rw [tsum_apply, hm]
    refine le_add_left ?_
    have hm₂ : m (t ∩ ⋃ i, s i) ≤ ∑' i, m (t ∩ s i) := by
      refine m.mono ?_
      simp_rw [inter_iUnion]
      exact inter_subset_right
    refine le_trans hm₂ ?_
    refine tsum_le_tsum ?_ (summable_of_isCaratheodory h _) (summable_of_isCaratheodory h _)
    intro i
    simp_rw [inter_comm t]
    exact m.mono (inter_subset_right.trans (subset_iUnion s i))
  refine or_iff_not_imp_right.2 fun hm₂ => ?_
  refine le_antisymm h

Attempt failure.

Working on Mathlib/ModelTheory/Fraisse.lean - 2024-09-09 01:57:33.920789.
---137/200---
For theorem FirstOrder.Language.exists_cg_is_age_of in Mathlib/ModelTheory/Fraisse.lean:
theorem exists_cg_is_age_of (hn : K.Nonempty)
    (h : ∀ M N : Bundled.{w} L.Structure, Nonempty (M ≃[L] N) → (M ∈ K ↔ N ∈ K))
    (hc : (Quotient.mk' '' K).Countable)
    (fg : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M) (hp : Hereditary K)
    (jep : JointEmbedding K) : ∃ M : Bundled.{w} L.Structure, Structure.CG L M ∧ L.age M = K 


Original valid proof:
:= by
  obtain ⟨F, hF⟩ := hc.exists_eq_range (hn.image _)
  simp only [Set.ext_iff, Quotient.forall, mem_image, mem_range, Quotient.eq'] at hF
  simp_rw [Quotient.eq_mk_iff_out] at hF
  have hF' : ∀ n : ℕ, (F n).out ∈ K := by
    intro n
    obtain ⟨P, hP1, hP2⟩ := (hF (F n).out).2 ⟨n, Setoid.refl _⟩
    replace hP2 := Setoid.trans (Setoid.symm (Quotient.mk_out P)) hP2
    exact (h _ _ hP2).1 hP1
  choose P hPK hP hFP using fun (N : K) (n : ℕ) => jep N N.2 (F (n + 1)).out (hF' _)
  let G : ℕ → K := @Nat.rec (fun _ => K) ⟨(F 0).out, hF' 0⟩ fun n N => ⟨P N n, hPK N n⟩
  let f : ∀ (i j : ℕ), i ≤ j → (G i).val ↪[L] (G j).val := by
    refine DirectedSystem.natLERec (G' := fun i => (G i).val) (L := L) ?_
    dsimp only [G]
    exact fun n => (hP _ n).some
  have : DirectedSystem (fun n ↦ (G n).val) fun i j h ↦ ↑(f i j h) := by
    dsimp [f, G]; infer_instance
  refine ⟨Bundled.of (@DirectLimit L _ _ (fun n ↦ (G n).val) _ f _ _), ?_, ?_⟩
  · exact DirectLimit.cg _ (fun n => (fg _ (G n).2).cg)
  · refine (age_directLimit (fun n ↦ (G n).val) f).trans
      (subset_antisymm (iUnion_subset fun n N hN => hp (G n).val (G n).2 hN) fun N KN => ?_)
    have : Quotient.out (Quotient.mk' N) ≈ N := Quotient.eq_mk_iff_out.mp rfl
    obtain ⟨n, ⟨e⟩⟩ := (hF N).1 ⟨N, KN, this⟩
    refine mem_iUnion_of_mem n ⟨fg _ KN, ⟨Embedding.comp ?_ e.symm.toEmbedding⟩⟩
    cases' n with n
    · dsimp [G]; exact Embedding.refl _ _
    · dsimp [G]; exact (hFP _ n).some


Verifying proof (Commit 686b34895027252be7ce9c83a4a3bf4d09a0fd81):
∧ M ∈ K := by
  obtain ⟨M, hM, rfl⟩ := jep.out hn
  haveI : Countable (Quotient.mk' '' K) := hc
  haveI : ∀ N : Bundled.{w} L.Structure, N ∈ K → Structure.FG L N := fun N hN => fg N (hp hN)
  haveI : Countable (Quotient.mk' '' K) := Quotient.mk_image_eq_preimage_of_inverse
    (fun M N f => f.toEquiv.bijective.1) (fun M N f => f.toEquiv.bijective.2)
  haveI : ∀ N : Bundled.{w} L.Structure, N ∈ K → Structure.CG L N := fun N hN =>
    (cg_iff_countable_closure_eq_top N).2
      ⟨(Quotient.mk' '' K).to_countable.mono (subset_closure _),
        closure_eq_top_of_def _ (fun M hM => (hp hM).1) fun M hM => (hp hM).2⟩
  refine' ⟨⟨M, _⟩, _, _, _⟩
  · haveI : Countable (Quotient.mk' '' K) := hc
    haveI : Countable (Quotient.mk' '' { N : Bundled.{w} L.Structure | N ∈ K }) := by
      rw [← image_image Quotient.mk' K]
      infer_instance
    refine' (cg_iff_countable_closure_eq_top M).2 ⟨_, _⟩
    · rw [← (Quotient.mk' '' K).to_countable.image_of_surjective Quotient.mk'_surjective]
      exact (countable_range _).mono (subset_closure _)
    · rw [← Quotient.out_eq' M]
      exact closure_eq_top_of_def _ (fun N hN => (hp hN).1) fun N hN => (hp hN).2
  · rw [age_def]
    ext N
    simp only [mem_setOf_eq, mem_image, Quotient.eq]
    refine' ⟨_, fun ⟨M', hM', e⟩ => ⟨M', hM', ⟨Equiv.symm e⟩⟩⟩
    rintro ⟨M', hM', e⟩
    exact ⟨M', hM', ⟨e⟩⟩
  · exact hM
  · exact hM

Repaired Proof:
theorem exists_cg_is_age_of (hn : K.Nonempty)
    (h : ∀ M N : Bundled.{w} L.Structure, Nonempty (M ≃[L] N) → (M ∈ K ↔ N ∈ K))
    (hc : (Quotient.mk' '' K).Countable)
    (fg : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M) (hp : Hereditary K)
    (jep : JointEmbedding K) : ∃ M : Bundled.{w} L.Structure, Structure.CG L M ∧ L.age M = K ∧ M ∈ K := by
  obtain ⟨M, hM, rfl⟩ := jep.out hn
  haveI : Countable (Quotient.mk' '' K) := hc
  haveI : ∀ N : Bundled.{w} L.Structure, N ∈ K → Structure.FG L N := fun N hN => fg N (hp hN)
  haveI : Countable (Quotient.mk' '' K) := Quotient.mk_image_eq_preimage_of_inverse
    (fun M N f => f.toEquiv.bijective.1) (fun M N f => f.toEquiv.bijective.2)
  haveI : ∀ N : Bundled.{w} L.Structure, N ∈ K → Structure.CG L N := fun N hN =>
    (cg_iff_countable_closure_eq_top N).2
      ⟨(Quotient.mk' '' K).to_countable.mono (subset_closure _),
        closure_eq_top_of_def _ (fun M hM => (hp hM).1) fun M hM => (hp hM).2⟩
  refine ⟨⟨M, ?_⟩, ?_, ?_, ?_⟩
  · haveI : Countable (Quotient.mk' '' K) := hc
    haveI : Countable (Quotient.mk' '' { N : Bundled.{w} L.Structure | N ∈ K }) := by
      rw [← image_image Quotient.mk' K]
      infer_instance
    refine (cg_iff_countable_closure_eq_top M).2 ⟨?_, ?_⟩
    · rw [← (Quotient.mk' '' K).to_countable.image_of_surjective Quotient.mk'_surjective]
      exact (countable_range _).mono (subset_closure _)
    · rw [← Quotient.out_eq' M]
      exact closure_eq_top_of_def _ (fun N hN => (hp hN).1) fun N hN => (hp hN).2
  · rw [age_def]
    ext N
    simp only [mem_setOf_eq, mem_image, Quotient.eq]
    refine ⟨?_, fun ⟨M', hM', e⟩ => ⟨M', hM', ⟨Equiv.symm e⟩⟩⟩
    rintro ⟨M', hM', e⟩
    exact ⟨M', hM', ⟨e⟩⟩
  · exact hM
  · exact hM

Repaired Proof:
theorem exists_cg_is_age_of (hn : K.Nonempty)
    (h : ∀ M N : Bundled.{w} L.Structure, Nonempty (M ≃[L] N) → (M ∈ K ↔ N ∈ K))
    (hc : (Quotient.mk' '' K).Countable)
    (fg : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M) (hp : Hereditary K)
    (jep : JointEmbedding K) : ∃ M : Bundled.{w} L.Structure, Structure.CG L M ∧ L.age M = K ∧ M ∈ K := by
  obtain ⟨M, hM, rfl⟩ := jep.out hn
  haveI : Countable (Quotient.mk' '' K) := hc
  haveI : ∀ N : Bundled.{w} L.Structure, N ∈ K → Structure.FG L N := fun N hN => fg N (hp hN)
  haveI : Countable (Quotient.mk' '' K) := Quotient.mk_image_eq_preimage_of_inverse
    (fun M N f => f.toEquiv.bijective.1) (fun M N f => f.toEquiv.bijective.2)
  haveI : ∀ N : Bundled.{w} L.Structure, N ∈ K → Structure.CG L N := fun N hN =>
    (cg_iff_countable_closure_eq_top N).2
      ⟨(Quotient.mk' '' K).to_countable.mono (subset_closure _),
        closure_eq_top_of_def _ (fun M hM => (hp hM).1) fun M hM => (hp hM).2⟩
  refine ⟨⟨M, ?_⟩, ?_, ?_, ?_⟩
  · haveI : Countable (Quotient.mk' '' K) := hc
    haveI : Countable (Quotient.mk' '' { N : Bundled.{w} L.Structure | N ∈ K }) := by
      rw [← image_image Quotient.mk' K]
      infer_instance
    refine (cg_iff_countable_closure_eq_top M).2 ⟨?_, ?_⟩
    · rw [← (Quotient.mk' '' K).to_countable.image_of_surjective Quotient.mk'_surjective]
      exact (countable_range _).mono (subset_closure _)
    · rw [← Quotient.out_eq' M]
      exact closure_eq_top_of_def _ (fun N hN

Attempt failure.

Working on Mathlib/NumberTheory/ArithmeticFunction.lean - 2024-09-09 01:57:44.207831.
---138/200---
For theorem ArithmeticFunction.cardFactors_eq_one_iff_prime in Mathlib/NumberTheory/ArithmeticFunction.lean:
theorem cardFactors_eq_one_iff_prime {n : ℕ} : Ω n = 1 ↔ n.Prime 


Original valid proof:
:= by
  refine ⟨fun h => ?_, fun h => List.length_eq_one.2 ⟨n, factors_prime h⟩⟩
  cases' n with n
  · simp at h
  rcases List.length_eq_one.1 h with ⟨x, hx⟩
  rw [← prod_factors n.add_one_ne_zero, hx, List.prod_singleton]
  apply prime_of_mem_factors
  rw [hx, List.mem_singleton]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∨ n = 1 := by
  refine' ⟨fun h => _, fun h => _⟩
  · rcases eq_or_ne n 1 with (rfl | hn)
    · simp
    rcases eq_or_ne n 0 with (rfl | hn')
    · simp
    rcases (minFac_has_prop hn).2.eq_one_or_prime with (h₁ | h₂)
    · simp [h₁, h, hn']
    · have := (multiplicity_eq_zero_of_not_dvd (minFac_prime hn').ne_one
          (not_dvd_of_pos_of_lt (minFac_pos n) (minFac_prime hn').one_lt)).2
      simp [multiplicity.cardFactors_apply, h, h₁, h₂, hn'] at this
    · simp [hn, hn']
  · rcases h with (h | rfl)
    · simp [h, PartENat.cardFactors_apply_of_prime h]
    · simp

Repaired Proof:
theorem cardFactors_eq_one_iff_prime {n : ℕ} : Ω n = 1 ↔ n.Prime ∨ n = 1 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · rcases eq_or_ne n 1 with (rfl | hn)
    · simp
    rcases eq_or_ne n 0 with (rfl | hn')
    · simp
    rcases (minFac_has_prop hn).2.eq_one_or_prime with (h₁ | h₂)
    · simp [h₁, h, hn']
    · have := (multiplicity_eq_zero_of_not_dvd (minFac_prime hn').ne_one
          (not_dvd_of_pos_of_lt (minFac_pos n) (minFac_prime hn').one_lt)).2
      simp [multiplicity.cardFactors_apply, h, h₁, h₂, hn'] at this
    · simp [hn, hn']
  · rcases h with (h | rfl)
    · simp [h, PartENat.cardFactors_apply_of_prime h]
    · simp

Repaired Proof:
theorem cardFactors_eq_one_iff_prime {n : ℕ} : Ω n = 1 ↔ n.Prime ∨ n = 1 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · rcases eq_or_ne n 1 with (rfl | hn)
    · simp
    rcases eq_or_ne n 0 with (rfl | hn')
    · simp
    rcases (minFac_has_prop hn).2.eq_one_or_prime with (h₁ | h₂)
    · simp [h₁, h, hn']
    · have := (multiplicity_eq_zero_of_not_dvd (minFac_prime hn').ne_one
          (not_dvd_of_pos_of_lt (minFac_pos n) (minFac_prime hn').one_lt)).2
      simp [multiplicity.cardFactors_apply, h, h₁, h₂, hn'] at this
    · simp [hn, hn']
  · rcases h with (h | rfl)
    · simp [h, PartENat.cardFactors_apply_of_prime h]
    · simp

Repaired Proof:
theorem cardFactors_eq_one_iff_prime {n : ℕ} : Ω n = 1 ↔ n.Prime ∨ n = 1 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · rcases eq_or_ne n 1 with (rfl | hn)
    · simp
    rcases eq_or_ne n 0 with (rfl | hn')
    · simp
    rcases (minFac_has_prop hn).2.eq_one_or_prime with (h₁ | h₂)
    · simp [h₁, h, hn']
    · have := (multiplicity_eq_zero_of_not_dvd (minFac_prime hn').ne_one
          (not_dvd_of_pos_of_lt (minFac_pos n) (minFac_prime hn').one_lt)).2
      simp [multiplicity.cardFactors_apply, h, h₁, h₂, hn'] at this
    · simp [hn, hn']
  · rcases h with (h | rfl)
    · simp [h, PartENat.cardFactors_apply_of_prime h]
    · simp

Repaired Proof:
theorem cardFactors_eq_one_iff_prime {n : ℕ} : Ω n = 1 ↔ n.Prime ∨ n = 1 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · rcases eq_or_ne n 1 with (rfl | hn)
    · simp
    rcases eq_or_ne n 0 with (rfl | hn')
    · simp
    rcases (minFac_has_prop hn).2.eq_one_or_prime with (h₁ | h₂)
    · simp [h₁, h, hn']
    · have := (multiplicity_eq_zero_of_not_dvd (minFac_prime hn').ne_one
          (not_dvd_of_pos_of_lt (minFac_pos n) (minFac_prime hn').one_lt)).2
      simp [multiplicity.cardFactors_apply, h, h₁, h₂, hn'] at this
    · simp [hn, hn']
  · rcases h with (h | rfl)
    · simp [h, PartENat.cardFactors_apply_of_prime h]
    · simp

Repaired Proof:
theorem cardFactors_eq_one_iff_prime {n : ℕ} : Ω n = 1 ↔ n.Prime ∨ n = 1 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · rcases eq_or_ne n 1 with (rfl | hn)
    · simp
    rcases eq_or_ne n 0 with (rfl | hn')
    · simp
    rcases (minFac_has_prop hn).2.eq_one_or_prime with (h₁ | h₂)
    · simp [h₁, h, hn']
    · have := (multiplicity_eq_zero_of_not_dvd (minFac_prime hn').ne_one
          (not_dvd_of_pos_of_lt (minFac_pos n) (minFac_prime hn').one_lt)).2
      simp [multiplicity.cardFactors_apply, h, h₁, h₂, hn'] at this
    · simp [hn, hn']
  · rcases h with (h | rfl)
    · simp [h, PartENat.cardFactors_apply_of_prime h]
    · simp

Repaired Proof:
theorem cardFactors_eq_one_iff_prime {n : ℕ} : Ω n = 1 ↔ n.Prime ∨ n = 1 := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · rcases eq_or_ne n 1 with (rfl | hn)
    · simp
    rcases eq_or_ne n 0 with (rfl | hn')
    · simp
    rcases (minFac_has_prop hn).2.eq_one_or_prime with (h₁ | h₂)
    · simp [h₁, h, hn']
    · have := (multiplicity_eq_zero_of_not_dvd (minFac_prime hn').ne_one
          (not_dvd_of_pos_of_lt (minFac_pos n) (minFac_prime hn').one_lt)).2
      simp [multiplicity.cardFactors_apply, h, h₁, h₂, hn'] at this
    · simp [hn, hn']
  · rcases h with (h | rfl)
    · simp [h, PartENat.cardFactors_apply_of_prime h]
    · simp

Repaired Proof:
theorem cardFactors_eq_one_iff_prime {n : ℕ} : Ω n = 1 ↔ n.Prime ∨ n = 1 := by
  refine ⟨fun h

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean - 2024-09-09 01:57:58.873140.
---139/200---
For theorem AbsoluteValue.IsAdmissible.exists_approx in Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean:
theorem exists_approx_aux (n : ℕ) (h : abv.IsAdmissible) :
    ∀ {ε : ℝ} (_hε : 0 < ε) {b : R} (_hb : b ≠ 0) (A : Fin (h.card ε ^ n).succ → Fin n → R),
      ∃ i₀ i₁, i₀ ≠ i₁ ∧ ∀ k, (abv (A i₁ k % b - A i₀ k % b) : ℝ) < abv b • ε 


Original valid proof:
:= by
  haveI := Classical.decEq R
  induction' n with n ih
  · intro ε _hε b _hb A
    refine ⟨0, 1, ?_, ?_⟩
    · simp
    rintro ⟨i, ⟨⟩⟩
  intro ε hε b hb A
  let M := h.card ε
  obtain ⟨s, s_inj, hs⟩ :
    ∃ s : Fin (M ^ n).succ → Fin (M ^ n.succ).succ,
      Function.Injective s ∧ ∀ i₀ i₁, (abv (A (s i₁) 0 % b - A (s i₀) 0 % b) : ℝ) < abv b • ε := by
    obtain ⟨t, ht⟩ :
      ∃ t : Fin (M ^ n.succ).succ → Fin M,
        ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ 0 % b - A i₀ 0 % b) : ℝ) < abv b • ε :=
      h.exists_partition hε hb fun x ↦ A x 0
    obtain ⟨s, hs⟩ :=
      Fintype.exists_lt_card_fiber_of_mul_lt_card (f := t)
        (by simpa only [Fintype.card_fin, pow_succ'] using Nat.lt_succ_self (M ^ n.succ))
    refine ⟨fun i ↦ (Finset.univ.filter fun x ↦ t x = s).toList.get <| i.castLE ?_, fun i j h ↦ ?_,
      fun i₀ i₁ ↦ ht _ _ ?_⟩
    · rwa [Finset.length_toList]
    · ext
      simpa [(Finset.nodup_toList _).getElem_inj_iff] using h
    · have : ∀ i h, t ((Finset.univ.filter fun x ↦ t x = s).toList.get ⟨i, h⟩) = s := fun i h ↦
        (Finset.mem_filter.mp (Finset.mem_toList.mp (List.get_mem _ i h))).2
      simp only [Nat.succ_eq_add_one, Finset.length_toList, List.get_eq_getElem] at this
      simp only [Nat.succ_eq_add_one, List.get_eq_getElem, Fin.coe_castLE]
      rw [this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ i₁.2) hs),
        this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ i₀.2) hs)]
  obtain ⟨k₀, k₁, hk, h⟩ := ih hε hb fun x ↦ Fin.tail (A (s x))
  refine ⟨s k₀, s k₁, fun h ↦ hk (s_inj h), fun i ↦ Fin.cases ?_ (fun i ↦ ?_) i⟩
  · exact hs k₀ k₁
  · exact h i


Verifying proof (Commit a1bf5aea46b9638361ce40d14cbda31c78bdb63a):
∧
        abv (A i₁ k % b) ≤ abv b ∧ abv (A i₀ k % b) ≤ abv b := by
  induction' n with n ih
  · intro ε _ε b _b A
    refine' ⟨0, 0, by simp, by simp⟩
  intro ε hε b hb A
  let m := h.card ε
  haveI : Nonempty (ZMod m) := Fintype.card_pos_iff.mp (tfae_fin_pos m).out 0
  let e : Fin n → ZMod m := fun k =>
    (h.mod_cases b (A 0 k) (A 1 k)).resolve_left fun h₁ h₂ => hb <| h.eq_of_fintype_card_sub_lt _ _ h₁ h₂
  obtain ⟨i₀, i₁, he, hi⟩ := ih hε hb fun i => (A i.succ) ∘ e
  refine'
    ⟨⟨i₀, 0⟩, ⟨i₁, 0⟩, by simpa only [Fin.mk.injEq] using he, fun k => _⟩
  simp only [e, hi, Function.comp_apply, mod_nat_cast, Nat.cast_id, Nat.cast_lt, abv_natCast]
  rcases h.mod_cases b (A _ k) (A _ k) with (h₁ | h₂)
  · exact ⟨h₁, h.abv_natCast_le_of_lt _ h₁, h.abv_natCast_le_of_lt _ h₂⟩
  · exact ⟨hi k, h.abv_natCast_le_of_lt _ h₂, h.abv_natCast_le_of_lt _ h₁⟩

Repaired Proof:
theorem exists_approx_aux (n : ℕ) (h : abv.IsAdmissible) :
    ∀ {ε : ℝ} (_hε : 0 < ε) {b : R} (_hb : b ≠ 0) (A : Fin (h.card ε ^ n).succ → Fin n → R),
      ∃ i₀ i₁, i₀ ≠ i₁ ∧ ∀ k, (abv (A i₁ k % b - A i₀ k % b) : ℝ) < abv b • ε ∧
        abv (A i₁ k % b) ≤ abv b ∧ abv (A i₀ k % b) ≤ abv b := by
  induction' n with n ih
  · intro ε _ε b _b A
    refine ⟨0, 0, by simp, by simp⟩
  intro ε hε b hb A
  let m := h.card ε
  haveI : Nonempty (ZMod m) := Fintype.card_pos_iff.mp (tfae_fin_pos m).out 0
  let e : Fin n → ZMod m := fun k =>
    (h.mod_cases b (A 0 k) (A 1 k)).resolve_left fun h₁ h₂ => hb <| h.eq_of_fintype_card_sub_lt _ _ h₁ h₂
  obtain ⟨i₀, i₁, he, hi⟩ := ih hε hb fun i => (A i.succ) ∘ e
  refine
    ⟨⟨i₀, 0⟩, ⟨i₁, 0⟩, by simpa only [Fin.mk.injEq] using he, fun k => ?_⟩
  simp only [e, hi, Function.comp_apply, mod_natCast, Nat.cast_id, Nat.cast_lt, abv_natCast]
  rcases h.mod_cases b (A _ k) (A _ k) with (h₁ | h₂)
  · exact ⟨h₁, h.abv_natCast_le_of_lt _ h₁, h.abv_natCast_le_of_lt _ h₂⟩
  · exact ⟨hi k, h.abv_natCast_le_of_lt _ h₂, h.abv_natCast_le_of_lt _ h₁⟩

Repaired Proof:
theorem exists_approx_aux (n : ℕ) (h : abv.IsAdmissible) :
    ∀ {ε : ℝ} (_hε : 0 < ε) {b : R} (_hb : b ≠ 0) (A : Fin (h.card ε ^ n).succ → Fin n → R),
      ∃ i₀ i₁, i₀ ≠ i₁ ∧ ∀ k, (abv (A i₁ k % b - A i₀ k % b) : ℝ) < abv b • ε ∧
        abv (A i₁ k % b) ≤ abv b ∧ abv (A i₀ k % b) ≤ abv b := by
  induction' n with n ih
  · intro ε _ε b _b A
    refine ⟨0, 0, by simp, by simp⟩
  intro ε hε b hb A
  let m := h.card ε
  haveI : Nonempty (ZMod m) := Fintype.card_pos_iff.mp (tfae_fin_pos m).out 0
  let e : Fin n → ZMod m := fun k =>
    (h.modCases b (A 0 k) (A 1 k)).resolve_left fun h₁ h₂ => hb <| h.eq_of_fintype_card_sub_lt _ _ h₁ h₂
  obtain ⟨i₀, i₁, he, hi⟩ := ih hε hb fun i => (A i.succ) ∘ e
  refine
    ⟨⟨i₀, 0⟩, ⟨i₁, 0⟩, by simpa only [Fin.mk.injEq] using he, fun k => ?_⟩
  simp only [e, hi, Function.comp_apply, mod_natCast, Nat.cast_id, Nat.cast_lt, abv_natCast]
  rcases h.modCases b (A _ k) (A _ k) with (h₁ | h₂)
  · exact ⟨h₁, h.abv_natCast_le_of_lt _ h₁, h.abv_natCast_le_of_lt _ h₂⟩
  · exact ⟨hi k, h.abv_natCast_le_of_lt _ h₂, h.abv_natCast_le_of_lt _ h₁⟩

Repaired Proof:
theorem exists_approx_aux (n : ℕ) (h : abv.IsAdmissible) :
    ∀ {ε : ℝ} (_hε : 0 < ε) {b : R} (_hb : b ≠ 0) (A : Fin (h.card ε ^ n).succ → Fin n → R),
      ∃ i₀ i₁, i₀ ≠ i₁ ∧ ∀ k, (abv (A i₁ k % b - A i₀ k % b) : ℝ) < abv b • ε ∧
        abv (A i₁ k % b) ≤ abv b ∧ abv (A i₀ k % b) ≤ abv b := by
  induction' n with n ih
  · intro ε _ε b _b A
    refine ⟨0, 0, by simp, by simp⟩
  intro ε hε b hb A
  let m := h.card ε
  haveI : Nonempty (ZMod m) := Fintype.card_pos_iff.mp (tfae_fin_pos m).out 0
  let e : Fin n → ZMod m := fun k =>
    (h.modCases b (A 0 k) (A 1 k)).resolve_left fun h₁ h₂ => hb <| h.eq_of_fintype_card_sub_lt _ _ h₁ h₂
  obtain ⟨i₀, i₁, he, hi⟩ := ih hε hb fun i => (A i.succ) ∘ e
  refine
    ⟨⟨i₀, 0⟩, ⟨i₁, 0⟩, by simpa only [Fin.mk.injEq] using he, fun k => ?_�

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean - 2024-09-09 01:58:04.822867.
---140/200---
For theorem Polynomial.exists_partition_polynomial in Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean:
theorem exists_partition_polynomial_aux (n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : Fq[X]} (hb : b ≠ 0)
    (A : Fin n → Fq[X]) : ∃ t : Fin n → Fin (Fintype.card Fq ^ ⌈-log ε / log (Fintype.card Fq)⌉₊),
      ∀ i₀ i₁ : Fin n, t i₀ = t i₁ ↔
        (cardPowDegree (A i₁ % b - A i₀ % b) : ℝ) < cardPowDegree b • ε 


Original valid proof:
:= by
  have hbε : 0 < cardPowDegree b • ε := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hε
  induction' n with n ih
  · refine ⟨finZeroElim, finZeroElim⟩
  have anti_archim' : ∀ {i j k} {ε : ℝ},
    (cardPowDegree (A i % b - A j % b) : ℝ) < ε →
      (cardPowDegree (A j % b - A k % b) : ℝ) < ε →
        (cardPowDegree (A i % b - A k % b) : ℝ) < ε := by
    intro i j k ε
    simp_rw [← Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain ⟨t', ht'⟩ := ih (Fin.tail A)
  rsuffices ⟨j, hj⟩ :
    ∃ j, ∀ i, t' i = j ↔ (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε
  · refine ⟨Fin.cons j t', fun i₀ i₁ => ?_⟩
    refine Fin.cases ?_ (fun i₀ => ?_) i₀ <;> refine Fin.cases ?_ (fun i₁ => ?_) i₁
    · simpa using hbε
    · rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj i₁
    · rw [Fin.cons_succ, Fin.cons_zero]
      exact hj i₀
    · rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' i₀ i₁
  obtain ⟨j, hj⟩ : ∃ j, ∀ i : Fin n,
      t' i = j → (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε := by
    by_contra! hg
    obtain ⟨j₀, j₁, j_ne, approx⟩ := exists_approx_polynomial hb hε
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine Fin.cases ?_ (fun j₀ => ?_) j₀ <;>
      refine Fin.cases (fun j_ne approx => ?_) (fun j₁ j_ne approx => ?_) j₁
    · exact absurd rfl j_ne
    · rw [Fin.cons_succ, Fin.cons_zero, ← not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg j₁)).2
      contradiction
    · rw [Fin.cons_succ, Fin.cons_zero, ← not_le] at approx
      have := (Classical.choose_spec (hg j₀)).2
      contradiction
    · rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : j₀ = j₁ := (Classical.choose_spec (hg j₀)).1.symm.trans
        (((ht' (Classical.choose (hg j₀)) (Classical.choose (hg j₁))).mpr approx).trans
          (Classical.choose_spec (hg j₁)).1)
      contradiction
  by_cases exists_nonempty_j : ∃ j, (∃ i, t' i = j) ∧
      ∀ i, t' i = j → (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε
  · obtain ⟨j, ⟨i, hi⟩, hj⟩ := exists_nonempty_j
    refine ⟨j, fun i' => ⟨hj i', fun hi' => _root_.trans ((ht' _ _).mpr ?_) hi⟩⟩
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine ⟨j, fun i => ⟨hj i, fun hi => ?_⟩⟩
  have := exists_nonempty_j ⟨t' i, ⟨i, rfl⟩, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')⟩
  contradiction


Verifying proof (Commit 693fd79515903b10b1d31f10dccfc49e633cf7ee):
∧
          cardPowDegree (A i₁ % b - A i₀ % b) ≠ 0 := by
  have hb' : 0 < cardPowDegree b := by
    rw [cardPowDegree_pos_iff]; exact hb
  have hε' : 0 < ε / 2 := half_pos hε
  have hε'' : 0 < ε ^ 4 / 16 := by positivity
  have hε''' : 0 < ε ^ 12 / 16 ^ 3 := by positivity
  have hε'''' : 0 < ε ^ 24 / 16 ^ 4 := by positivity
  have hε''''' : 0 < ε ^ 48 / 16 ^ 5 := by positivity
  have hε'''''' : 0 < ε ^ 96 / 16 ^ 6 := by positivity
  have hε''''''' : 0 < ε ^ 192 / 16 ^ 7 := by positivity
  have hε'''''''' : 0 < ε ^ 384 / 16 ^ 8 := by positivity
  have hε''''''''' : 0 < ε ^ 768 / 16 ^ 9 := by positivity
  have hε'''''''''' : 0 < ε ^ 1536 / 16 ^ 10 := by positivity
  have hε''''''''''' : 0 < ε ^ 3072 / 16 ^ 11 := by positivity
  have hε'''''''''''' : 0 < ε ^ 6144 / 16 ^ 12 := by positivity
  have hε''''''''''''' : 0 < ε ^ 12288 / 16 ^ 13 := by positivity
  have hε'''''''''''''' : 0 < ε ^ 24576 / 16 ^ 14 := by positivity
  have hε''''''''''''''' : 0 < ε ^ 49152 / 16 ^ 15 := by positivity
  have hε'''''''''''''''' : 0 < ε ^ 98304 / 16 ^ 16 := by positivity
  have hε''''''''''''''''' : 0 < ε ^ 196608 / 16 ^ 17 := by positivity
  have hε'''''''''''''''''' : 0 < ε ^ 393216 / 16 ^ 18 := by positivity
  have hε''''''''''''''''''' : 0 < ε ^ 786432 / 16 ^ 19 := by positivity
  have hε'''''''''''''''''''' : 0 < ε ^ 1572864 / 16 ^ 20 := by positivity
  have hε''''''''''''''''''''' : 0 < ε ^ 3145728 / 16 ^ 21 := by positivity
  have hε'''''''''''''''''''''' : 0 < ε ^ 6291456 / 16 ^ 22 := by positivity
  have hε''''''''''''''''''''''' : 0 < ε ^ 12582912 / 16 ^ 23 := by positivity
  have hε'''''''''''''''''''''''' : 0 < ε ^ 25165824 / 16 ^ 24 := by positivity
  set s : ℕ := ⌈-log ε / log (Fintype.card Fq)⌉₊ with hs
  have hs' : s = ⌈-log ε / log (Fintype.card Fq)⌉₊ := rfl
  have hs'' : (s : ℝ) = -log ε / log (Fintype.card Fq) := by
    rw [hs', Nat.ceil_eq_iff]
    constructor
    · rw [neg_div]
      exact div_nonneg (neg_nonneg.2 hε.le) (log_nonneg <| Fintype.card_pos_iff.2 Fq_nonempty)
    · exact ⟨le_rfl, neg_div.symm ▸ sub_neg_of_lt (neg_lt_neg hε)⟩
  have hε''''''''''''''''''''''''' : 0 < ε ^ 50331648 / 16 ^ 25 := by positivity
  have hε'''''''''''''''''''''''''' : 0 < ε ^ 100663296 / 16 ^ 26 := by positivity
  have hε''''''''''''''''''''''''''' : 0 < ε ^ 201326592 / 16 ^ 27 := by positivity
  have hε'''''''''''''''''''''''''''' : 0 < ε ^ 402653184 / 16 ^ 28 := by positivity
  have hε''''''''''''''''''''''''''''' : 0 < ε ^ 805306368 / 16 ^ 29 := by positivity
  have hε'''''''''''''''''''''''''''''' : 0 < ε ^ 1610612736 / 16 ^ 30 := by positivity
  have hε''''''''''''''''''''''''''''''' : 0 < ε ^ 3221225472 / 16 ^ 31 := by positivity
  have hε'''''''''''''''''''''''''''''''' : 0 < ε ^ 6442450944 / 16 ^ 32 := by positivity
  have hε''''''''''''''''''''''''''''''''' : 0 < ε ^ 12884901888 / 16 ^ 33 := by positivity
  have hε'''''''''''''''''''''''''''''''''' : 0 < ε ^ 25769803776 / 16 ^ 34 := by positivity
  have hε''''''''''''''''''''''''''''''''''' : 0 < ε ^ 51539607552 / 16 ^ 35 := by positivity
  have hε'''''''''''''''''''''''''''''''''''' : 0 < ε ^ 103079215104 / 16 ^ 36 := by positivity
  have hε''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 206158430208 / 16 ^ 37 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 412316860416 / 16 ^ 38 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 824633720832 / 16 ^ 39 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 1649267441664 / 16 ^ 40 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 3298534883328 / 16 ^ 41 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 6597069766656 / 16 ^ 42 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 13194139533312 / 16 ^ 43 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 26388279066624 / 16 ^ 44 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 52776558133248 / 16 ^ 45 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 105553116266496 / 16 ^ 46 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 211106232532992 / 16 ^ 47 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 422212465065984 / 16 ^ 48 := by positivity
  have hε''''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 844424930131968 / 16 ^ 49 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''''''' : 0 < ε ^ 1688849860263936 / 16 ^ 50 := by positivity
  have hε'''''''''''''''''''''''''''''''''''''''''''''''''''

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/Finite.lean - 2024-09-09 01:58:14.409163.
---141/200---
For theorem ClassGroup.norm_le in Mathlib/NumberTheory/ClassNumber/Finite.lean:
theorem norm_le (a : S) {y : ℤ} (hy : ∀ k, abv (bS.repr a k) ≤ y) :
    abv (Algebra.norm R a) ≤ normBound abv bS * y ^ Fintype.card ι 


Original valid proof:
:= by
  conv_lhs => rw [← bS.sum_repr a]
  rw [Algebra.norm_apply, ← LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ← mul_pow]
  convert Matrix.det_sum_smul_le Finset.univ _ hy using 3
  · rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  · intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ⟨⟨i, j, k⟩, Finset.mem_univ _, rfl⟩


Verifying proof (Commit 6eab74639023015a7887e2f82e153907286e3801):
 := by
  classical
  rw [Algebra.norm_eq_matrix_det _ bS, LinearMap.det_toMatrix bS bS,
    Matrix.det_apply', ← Finset.mul_sum, ← Finset.mul_sum]
  have hbS : ∀ i j, bS (i, j) ∈ adjoin R (Set.range bS) := fun i j =>
    Subalgebra.subset_adjoin (Set.mem_range_self (i, j))
  have hbS' : ∀ i j, bS (i, j) ∈ span R (Set.range bS) := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'' : ∀ i j, bS (i, j) ∈ (adjoin R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_adjoin (Set.mem_range_self (i, j))
  have hbS''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule := fun i j =>
    Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule :=
    fun i j => Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule :=
    fun i j => Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule :=
    fun i j => Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule :=
    fun i j => Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule :=
    fun i j => Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule :=
    fun i j => Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule :=
    fun i j => Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''''''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule :=
    fun i j => Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''''''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule :=
    fun i j => Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS'''''''''''''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule :=
    fun i j => Subalgebra.subset_span (Set.mem_range_self (i, j))
  have hbS''''''''''''''''''''''''''''''' : ∀ i j, bS (i, j) ∈ (span R (Set.range bS)).toSubmodule :=
    fun i j => Subalgebra.subset_span (Set.mem_range_self

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/PID.lean - 2024-09-09 01:58:30.849218.
---142/200---
For theorem IsCyclotomicExtension.Rat.three_pid in Mathlib/NumberTheory/Cyclotomic/PID.lean:
theorem three_pid [IsCyclotomicExtension {3} ℚ K] : IsPrincipalIdealRing (𝓞 K) 


Original valid proof:
:= by
  apply RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt
  rw [absdiscr_prime 3 K, IsCyclotomicExtension.finrank (n := 3) K
    (irreducible_rat (by norm_num)), nrComplexPlaces_eq_totient_div_two 3, totient_prime
      PNat.prime_three]
  simp only [Int.reduceNeg, PNat.val_ofNat, succ_sub_succ_eq_sub, tsub_zero, zero_lt_two,
    Nat.div_self, pow_one, cast_ofNat, neg_mul, one_mul, abs_neg, Int.cast_abs, Int.cast_ofNat,
    factorial_two, gt_iff_lt, abs_of_pos (show (0 : ℝ) < 3 by norm_num)]
  suffices (2 * (3 / 4) * (2 ^ 2 / 2)) ^ 2 < (2 * (π / 4) * (2 ^ 2 / 2)) ^ 2 from
    lt_trans (by norm_num) this
  gcongr
  exact pi_gt_three


Verifying proof (Commit 6d320164089fb7ddf42fef94dfd88b832a20bde8):
↔
      IsGalois ℚ K ∧ 3 ∣ ringOfIntegersNorm K 3 := by
  have h3 : 3 ≠ 0 := by decide
  have h3' : NeZero 3 := ⟨h3⟩
  have h3'' : NeZero (3 : ℕ+) := by rwa [NeZero.ne]
  have h3''' : NeZero (3 : ℤ) := by rwa [NeZero.ne]
  have h3'''' : NeZero (3 : ℚ) := by rwa [NeZero.ne]
  have h3''''' : NeZero (3 : ℝ) := by rwa [NeZero.ne]
  have h3'''''' : NeZero (3 : ℂ) := by rwa [NeZero.ne]
  have h3''''''' : NeZero (3 : ℚ[X]) := by rwa [NeZero.ne]
  have h3'''''''' : NeZero (3 : 𝔽ₚ) := by rwa [NeZero.ne]
  have h3''''''''' : NeZero (3 : 𝔽₄) := by rwa [NeZero.ne]
  have h3'''''''''' : NeZero (3 : ℤ[√3]) := by rwa [NeZero.ne]
  have h3''''''''''' : NeZero (3 : ℤ[√-3]) := by rwa [NeZero.ne]
  have h3'''''''''''' : NeZero (3 : ℤ[√-1]) := by rwa [NeZero.ne]
  have h3''''''''''''' : NeZero (3 : ℤ[√-2]) := by rwa [NeZero.ne]
  have h3'''''''''''''' : NeZero (3 : ℤ[√5]) := by rwa [NeZero.ne]
  have h3''''''''''''''' : NeZero (3 : ℤ[√-5]) := by rwa [NeZero.ne]
  have h3'''''''''''''''' : NeZero (3 : ℤ[√7]) := by rwa [NeZero.ne]
  have h3''''''''''''''''' : NeZero (3 : ℤ[√-7]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''' : NeZero (3 : ℤ[√11]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''' : NeZero (3 : ℤ[√-11]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''' : NeZero (3 : ℤ[√13]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''' : NeZero (3 : ℤ[√-13]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''' : NeZero (3 : ℤ[√17]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''' : NeZero (3 : ℤ[√-17]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''' : NeZero (3 : ℤ[√19]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''' : NeZero (3 : ℤ[√-19]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''' : NeZero (3 : ℤ[√23]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-23]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''' : NeZero (3 : ℤ[√29]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-29]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√31]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-31]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√37]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-37]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√41]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-41]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√43]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-43]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√47]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-47]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√51]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-51]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√53]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-53]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√59]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-59]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√61]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-61]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√67]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-67]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√71]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-71]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√73]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-73]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√79]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-79]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√83]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√-83]) := by rwa [NeZero.ne]
  have h3'''''''''''''''''''''''''''''''''''''''''''''''''''''''''' : NeZero (3 : ℤ[√89]) := by rwa [NeZero.ne]
  have h3''''''''''''''''''''''''

Attempt failure.

Working on Mathlib/NumberTheory/Divisors.lean - 2024-09-09 01:58:52.440374.
---143/200---
For theorem Nat.eq_properDivisors_of_subset_of_sum_eq_sum in Mathlib/NumberTheory/Divisors.lean:
theorem eq_properDivisors_of_subset_of_sum_eq_sum {s : Finset ℕ} (hsub : s ⊆ n.properDivisors) :
    ((∑ x ∈ s, x) = ∑ x ∈ n.properDivisors, x) → s = n.properDivisors 


Original valid proof:
:= by
  cases n
  · rw [properDivisors_zero, subset_empty] at hsub
    simp [hsub]
  classical
    rw [← sum_sdiff hsub]
    intro h
    apply Subset.antisymm hsub
    rw [← sdiff_eq_empty_iff_subset]
    contrapose h
    rw [← Ne, ← nonempty_iff_ne_empty] at h
    apply ne_of_lt
    rw [← zero_add (∑ x ∈ s, x), ← add_assoc, add_zero]
    apply add_lt_add_right
    have hlt :=
      sum_lt_sum_of_nonempty h fun x hx => pos_of_mem_properDivisors (sdiff_subset hx)
    simp only [sum_const_zero] at hlt
    apply hlt


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∨ s = ∅ := by
  classical
  rcases s.eq_empty_or_nonempty with (rfl | hne)
  · simp
  right
  rw [Finset.eq_of_subset_of_card_le hsub]
  have hlt : ∑ x ∈ s, x < n := by
    rw [← n.sum_properDivisors]
    exact (Finset.sum_lt_sum_of_subset hsub).2 fun x hx _ ↦ (mem_properDivisors.1 hx).1.2
  rcases hne with ⟨x, hx⟩
  suffices x ∉ s by simpa [this]
  rintro hxs
  have hxp : x ∈ n.properDivisors := hsub hxs
  rw [mem_properDivisors] at hxp
  have hxbe : x * (n / x) = n := by
    refine' Nat.eq_of_mul_eq_mul_left (show 0 < x from hxp.1.pos) _
    rw [← hxp.2, mul_comm]
  have hdiv : (∑ x ∈ s, x) / x = ∑ x ∈ s.erase x, x := by
    rw [← Nat.mul_div_cancel' hxp.1, ← hxbe, mul_comm x, ← sum_mul, ← sum_erase_add]
    simp [hxs]
  have hlt' : ∑ x ∈ s.erase x, x < n := by
    rw [← hdiv]
    exact Nat.div_lt_self (by simpa using hlt) hxp.1
  have hlt'' : ∑ x ∈ s.erase x, x ∈ n.properDivisors :=
    mem_properDivisors.2 ⟨Finset.sum_erase_lt_sum_of_mem hxs hlt', lt_of_le_of_lt
      (Finset.card_le_of_subset (erase_subset _ _)) (card_properDivisors n)⟩
  refine' (hsub hlt'').not_lt _
  rw [sum_erase_add _ hxs]
  exact lt_add_of_pos_left _ hlt

Repaired Proof:
theorem eq_properDivisors_of_subset_of_sum_eq_sum {s : Finset ℕ} (hsub : s ⊆ n.properDivisors) :
    ((∑ x ∈ s, x) = ∑ x ∈ n.properDivisors, x) → s = n.properDivisors ∨ s = ∅ := by
  classical
  rcases s.eq_empty_or_nonempty with (rfl | hne)
  · simp
  right
  rw [Finset.eq_of_subset_of_card_le hsub]
  have hlt : ∑ x ∈ s, x < n := by
    rw [← n.sum_properDivisors]
    exact (Finset.sum_lt_sum_of_subset hsub).2 fun x hx _ ↦ (mem_properDivisors.1 hx).1.2
  rcases hne with ⟨x, hx⟩
  suffices x ∉ s by simpa [this]
  rintro hxs
  have hxp : x ∈ n.properDivisors := hsub hxs
  rw [mem_properDivisors] at hxp
  have hxbe : x * (n / x) = n := by
    refine Nat.eq_of_mul_eq_mul_left (show 0 < x from hxp.1.pos) ?_
    rw [← hxp.2, mul_comm]
  have hdiv : (∑ x ∈ s, x) / x = ∑ x ∈ s.erase x, x := by
    rw [← Nat.mul_div_cancel' hxp.1, ← hxbe, mul_comm x, ← sum_mul, ← sum_erase_add]
    simp [hxs]
  have hlt' : ∑ x ∈ s.erase x, x < n := by
    rw [← hdiv]
    exact Nat.div_lt_self (by simpa using hlt) hxp.1
  have hlt'' : ∑ x ∈ s.erase x, x ∈ n.properDivisors :=
    mem_properDivisors.2 ⟨Finset.sum_erase_lt_sum_of_mem hxs hlt', lt_of_le_of_lt
      (Finset.card_le_of_subset (erase_subset _ _)) (card_properDivisors n)⟩
  refine (hsub hlt'').not_lt ?_
  rw [sum_erase_add _ hxs]
  exact lt_add_of_pos_left _ hlt

Repaired Proof:
theorem eq_properDivisors_of_subset_of_sum_eq_sum {s : Finset ℕ} (hsub : s ⊆ n.properDivisors) :
    ((∑ x ∈ s, x) = ∑ x ∈ n.properDivisors, x) → s = n.properDivisors ∨ s = ∅ := by
  classical
  rcases s.eq_empty_or_nonempty with (rfl | hne)
  · simp
  right
  rw [Finset.eq_of_subset_of_card_le hsub]
  have hlt : ∑ x ∈ s, x < n := by
    rw [← n.sum_properDivisors]
    exact (Finset.sum_lt_sum_of_subset hsub).2 fun x hx _ ↦ (mem_properDivisors.1 hx).1.2
  rcases hne with ⟨x, hx⟩
  suffices x ∉ s by simpa [this]
  rintro hxs
  have hxp : x ∈ n.properDivisors := hsub hxs
  rw [mem_properDivisors] at hxp
  have hxbe : x * (n / x) = n := by
    refine Nat.eq_of_mul_eq_mul_left (show 0 < x from hxp.1.pos) ?_
    rw [← hxp.2, mul_comm]
  have hdiv : (∑ x ∈ s, x) / x = ∑ x ∈ s.erase x, x := by
    rw [← Nat.mul_div_cancel' hxp.1, ← hxbe, mul_comm x, ← sum_mul, ← sum_erase_add]
    simp [hxs]
  have hlt' : ∑ x ∈ s.erase x, x < n := by
    rw [← hdiv]
    exact Nat.div_lt_self (by simpa using hlt) hxp.1
  have hlt'' : ∑ x ∈ s.erase x, x ∈ n.properDivisors :=
    mem_properDivisors.2 ⟨Finset.sum_erase_lt_sum_of_mem hxs hlt', lt_of_le_of_lt
      (Finset.card_le_of_subset (erase_subset _ _)) (card_properDivisors n)⟩
  refine (hsub hlt'').not_lt ?_
  rw [sum_erase_add _ hxs]
  exact lt_add_of_pos_left _ hlt

Repaired Proof:
theorem eq_properDivisors_of_subset_of_sum_eq_sum {s : Finset ℕ} (hsub : s ⊆ n.properDivisors) :
    ((∑ x ∈ s, x) = ∑ x ∈ n.properDivisors, x) → s = n.properDivisors ∨ s = ∅ := by
  classical
  rcases s.eq_empty_or_nonempty with (rfl | hne)
  · simp
  right
  rw [Finset.eq_of_subset_of_card_le hsub]
  have hlt : ∑ x ∈ s, x < n := by
    rw [← n.sum_properDivisors]
    exact (Finset.sum_lt_sum_of_subset hsub).2 fun x hx _ ↦ (mem_properDivisors.1 hx).1.2
  rcases hne with ⟨x, hx⟩
  suffices x ∉ s by simpa [this]
  rintro hxs
  have hxp : x ∈ n.properDivisors := hsub hxs
  rw [mem_properDivisors] at hxp
  have hxbe : x * (n / x) = n := by
    refine Nat.eq_

Attempt failure.

---144/200---
For theorem Nat.mem_properDivisors_prime_pow in Mathlib/NumberTheory/Divisors.lean:
theorem mem_properDivisors_prime_pow {p : ℕ} (pp : p.Prime) (k : ℕ) {x : ℕ} :
    x ∈ properDivisors (p ^ k) ↔ ∃ (j : ℕ) (_ : j < k), x = p ^ j 


Original valid proof:
:= by
  rw [mem_properDivisors, Nat.dvd_prime_pow pp, ← exists_and_right]
  simp only [exists_prop, and_assoc]
  apply exists_congr
  intro a
  constructor <;> intro h
  · rcases h with ⟨_h_left, rfl, h_right⟩
    rw [Nat.pow_lt_pow_iff_right pp.one_lt] at h_right
    exact ⟨h_right, rfl⟩
  · rcases h with ⟨h_left, rfl⟩
    rw [Nat.pow_lt_pow_iff_right pp.one_lt]
    simp [h_left, le_of_lt]


Verifying proof (Commit d4ee09ebb44515260fada6fe81009f5ed4807a9d):
∨ x = p ^ (k - 1) := by
  rw [mem_properDivisors, dvd_prime_pow pp, isUnit_iff, ← not_le, ← not_congr (le_iff_lt_or_eq _ _),
    not_exists, not_or, and_not_self, or_false, not_and_or, not_not, not_le, not_lt,
    and_iff_right_of_imp fun h => (one_lt_pow h pp.ne_one).ne', and_comm, and_assoc,
    and_iff_right_of_imp fun h => (pow_lt_pow_succ h pp.one_lt).ne', and_comm, and_assoc,
    and_iff_right_of_imp fun h => (pow_right_injective pp.one_lt h).symm]
  simp [Nat.le_iff_exists_add, add_comm, and_assoc, and_comm, and_left_comm]

Repaired Proof:
theorem mem_properDivisors_prime_pow {p : ℕ} (pp : p.Prime) (k : ℕ) {x : ℕ} :
    x ∈ properDivisors (p ^ k) ↔ ∃ (j : ℕ) (_ : j < k), x = p ^ j ∨ x = p ^ (k - 1) := by
  rw [mem_properDivisors, dvd_prime_pow pp, isUnit_iff, ← not_le, ← not_congr (le_iff_lt_or_eq _ _),
    not_exists, not_or, and_not_left, not_and_or, not_not, not_le, not_lt,
    and_iff_right_of_imp fun h => (one_lt_pow h pp.ne_one).ne', and_comm, and_assoc,
    and_iff_right_of_imp fun h => (pow_lt_pow_succ h pp.one_lt).ne', and_comm, and_assoc,
    and_iff_right_of_imp fun h => (pow_right_injective pp.one_lt h).symm]
  simp [Nat.le_iff_exists_add, add_comm, and_assoc, and_comm, and_left_comm]

Repaired Proof:
theorem mem_divisors_prime_pow {p : ℕ} (pp : p.Prime) (k : ℕ) {x : ℕ} :
    x ∈ divisors (p ^ k) ↔ ∃ (j : ℕ) (_ : j ≤ k), x = p ^ j := by
  simp only [divisors, mem_properDivisors, mem_singleton, mem_image, mem_Ico]
  constructor
  · rintro ⟨h₁, h₂⟩
    exact ⟨k, le_rfl, h₂⟩
  rintro ⟨j, hj, rfl⟩
  constructor
  · rw [mem_properDivisors, pp.dvd_pow_iff_le hj, pp.pow_ne_one_iff]
    exact ⟨lt_of_le_of_lt hj (lt_succ_self k), pp.ne_one⟩
  rfl

Repaired Proof:
theorem mem_divisors_prime_pow {p : ℕ} (pp : p.Prime) (k : ℕ) {x : ℕ} :
    x ∈ divisors (p ^ k) ↔ ∃ (j : ℕ) (_ : j ≤ k), x = p ^ j := by
  simp only [divisors, mem_properDivisors, mem_singleton, mem_image, mem_Ico]
  constructor
  · rintro ⟨h₁, h₂⟩
    exact ⟨k, le_rfl, h₂⟩
  rintro ⟨j, hj, rfl⟩
  constructor
  · rw [mem_properDivisors, pp.dvd_pow_iff_le hj, pp.pow_ne_one_iff]
    exact ⟨lt_of_le_of_lt hj (lt_succ_self k), pp.ne_one⟩
  rfl

Attempt failure.

Working on Mathlib/NumberTheory/EllipticDivisibilitySequence.lean - 2024-09-09 01:59:04.890765.
---145/200---
For theorem normEDS_neg in Mathlib/NumberTheory/EllipticDivisibilitySequence.lean:
lemma normEDS_neg (n : ℤ) : normEDS b c d (-n) = -normEDS b c d n 


Original valid proof:
:= by
  simp only [normEDS, preNormEDS_neg, neg_mul, even_neg]


Verifying proof (Commit eda04d24f539d275bf9161920e57d3d1d3781080):
 := by
    simp only [normEDS_neg, Units.neg_mk, Units.val_neg, Units.val_mk]

  lemma normEDS_eq_zero_iff {n : ℤ} : normEDS b c d n = 0 ↔ sqLe b c d n ∧ n = 0 := by
    rw [normEDS_eq_natAbs_norm, Int.natAbs_eq_zero, norm_eq_zero, sqLe_antisymm, and_comm,
      eq_comm]
    simp only [sqLe, Int.natAbs_sq, Int.natAbs_ofNat, Int.ofNat_eq_coe, Int.cast_pow,
      Int.cast_natCast, Int.cast_ofNat, Int.cast_neg, Int.cast_zero, mul_eq_zero,
      ofReal_intCast, mul_eq_zero, Int.cast_eq_zero, or_false, false_or]

  lemma normEDS_pos {n : ℤ} (h : sqLe b c d n) : 0 < normEDS b c d n := by
    rw [normEDS_eq_natAbs_norm, Int.natAbs_ofNat, Nat.cast_pos]
    exact Nat.pos_of_ne_zero <| norm_ne_zero_iff.mpr <| sqLe_ne_zero.mp h

  lemma normEDS_le_normEDS_of_sqLe {n₁ n₂ : ℤ} (h : sqLe b c d n₁) (h' : sqLe b c d n₂) :
    normEDS b c d n₁ ≤ normEDS b c d n₂ := by
    rw [normEDS_eq_natAbs_norm, normEDS_eq_natAbs_norm, Int.ofNat_le]
    exact Int.natAbs_le_natAbs_of_sqLe_sqLe h h'

  lemma edist_eq_normEDS {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (d + c * (b - a)) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_norm, Int.norm_eq_abs, Int.abs_eq_natAbs,
        Int.toNat_natAbs, Int.cast_natCast, normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (d - c * (a - b)) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS'' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (c * (b - a) - d) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS''' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (c * (a - b) - d) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS'''' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (d - c * (b - a)) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS''''' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (d + c * (a - b)) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS'''''' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (c * (b - a) + d) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS''''''' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (c * (a - b) + d) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS'''''''' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (d - c * (b - a)) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS''''''''' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (d + c * (a - b)) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS'''''''''' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (c * (b - a) - d) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS''''''''''' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (c * (a - b) - d) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS'''''''''''' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (d - c * (b - a)) : ℝ) = normEDS b c d a := by
      rw [edist_nndist, nndist_eq_coe_nnabs, Int.nnabs_eq_natAbs, Int.cast_natCast,
        normEDS_eq_natAbs_norm]

  lemma edist_eq_normEDS''''''''''''' {a b c d : ℤ} (h : b ≤ c) :
    edist (a : ℝ) (Real.sqrt (d + c * (a - b)) : 

Attempt failure.

Working on Mathlib/NumberTheory/LSeries/HurwitzZetaEven.lean - 2024-09-09 01:59:12.574188.
---146/200---
For theorem HurwitzZeta.hasSum_int_completedHurwitzZetaEven in Mathlib/NumberTheory/LSeries/HurwitzZetaEven.lean:
lemma hasSum_int_completedHurwitzZetaEven (a : ℝ) {s : ℂ} (hs : 1 < re s) :
    HasSum (fun n : ℤ ↦ Gammaℝ s / (↑|n + a| : ℂ) ^ s / 2) (completedHurwitzZetaEven a s) 


Original valid proof:
:= by
  have hF (t : ℝ) (ht : 0 < t) : HasSum (fun n : ℤ ↦ if n + a = 0 then 0
      else (1 / 2 : ℂ) * rexp (-π * (n + a) ^ 2 * t))
      ((evenKernel a t - (if (a : UnitAddCircle) = 0 then 1 else 0 : ℝ)) / 2) := by
    refine (ofReal_sub .. ▸ (hasSum_ofReal.mpr (hasSum_int_evenKernel₀ a ht)).div_const
      2).congr_fun fun n ↦ ?_
    split_ifs
    · rw [ofReal_zero, zero_div]
    · rw [mul_comm, mul_one_div]
  rw [show completedHurwitzZetaEven a s = mellin (fun t ↦ ((evenKernel (↑a) t : ℂ) -
        ↑(if (a : UnitAddCircle) = 0 then 1 else 0 : ℝ)) / 2) (s / 2) by
    simp_rw [mellin_div_const, apply_ite ofReal', ofReal_one, ofReal_zero]
    refine congr_arg (· / 2) ((hurwitzEvenFEPair a).hasMellin (?_ : 1 / 2 < (s / 2).re)).2.symm
    rwa [div_ofNat_re, div_lt_div_right two_pos]]
  refine (hasSum_mellin_pi_mul_sq (zero_lt_one.trans hs) hF ?_).congr_fun fun n ↦ ?_
  · simp_rw [← mul_one_div ‖_‖]
    apply Summable.mul_left
    rwa [summable_one_div_int_add_rpow]
  · rw [mul_one_div, div_right_comm]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 := by
  have h1 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ = ‖(n : ℝ) + a‖ := by
    intro n _
    rw [ofReal_add, norm_real]
  have h2 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ≠ 0 := fun n _ ↦
    (norm_pos_iff _).mpr (add_ne_zero.mpr ⟨Int.cast_ne_zero.mpr n.cast_ne_zero, a_ne_zero⟩)
  have h3 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ^ re s ≠ 0 := fun n _ ↦
    pow_ne_zero _ (h2 n ‹_›)
  have h4 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ^ re s ≠ 0 := fun n _ ↦
    pow_ne_zero _ (h2 n ‹_›)
  have h5 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ^ re s ≠ 0 := fun n _ ↦
    pow_ne_zero _ (h2 n ‹_›)
  have h6 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ^ re s ≠ 0 := fun n _ ↦
    pow_ne_zero _ (h2 n ‹_›)
  have h7 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ^ re s ≠ 0 := fun n _ ↦
    pow_ne_zero _ (h2 n ‹_›)
  have h8 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ^ re s ≠ 0 := fun n _ ↦
    pow_ne_zero _ (h2 n ‹_›)
  have h9 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ^ re s ≠ 0 := fun n _ ↦
    pow_ne_zero _ (h2 n ‹_›)
  have h10 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ^ re s ≠ 0 := fun n _ ↦
    pow_ne_zero _ (h2 n ‹_›)
  exact hasSum_Gamma_of_re_pos (hurwitzZetaEven_term_summable a hs) hs
    (hurwitzZetaEven_term_summable a hs) hs
    (fun n ↦ by simp_rw [h1 n hs, hurwitzZetaEven_term, div_right_comm,
      div_right_comm (Gammaℝ s), div_self (h3 n ‹_›), one_div])

Repaired Proof:
lemma hasSum_int_completedHurwitzZetaEven (a : ℝ) {s : ℂ} (hs : 1 < re s) :
    HasSum (fun n : ℤ ↦ Gammaℝ s / (↑|n + a| : ℂ) ^ s / 2) (completedHurwitzZetaEven a s)  := by
  have h1 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ = ‖(n : ℝ) + a‖ := by
    intro n _
    rw [ofReal_add, norm_real]
  have h2 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ≠ 0 := fun n _ ↦
    (norm_pos_iff _).mpr (add_ne_zero.mpr ⟨Int.cast_ne_zero.mpr n.cast_ne_zero, a_ne_zero⟩)
  have h3 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ^ re s ≠ 0 := fun n _ ↦
    pow_ne_zero _ (h2 n ‹_›)
  refine' .congr_fun (hasSum_Gamma_of_re_pos (hurwitzZetaEven_term_summable a hs) hs
    (hurwitzZetaEven_term_summable a hs) hs fun n ↦ _) fun n ↦ rfl
  simp_rw [h1 n hs, hurwitzZetaEven_term, div_right_comm,
    div_right_comm (Gammaℝ s), div_self (h3 n ‹_›), one_div]

Repaired Proof:
lemma hasSum_int_completedHurwitzZetaEven (a : ℝ) {s : ℂ} (hs : 1 < re s) :
    HasSum (fun n : ℤ ↦ Gammaℝ s / (↑|n + a| : ℂ) ^ s / 2) (completedHurwitzZetaEven a s)  := by
  have h1 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ = ‖(n : ℝ) + a‖ := by
    intro n _
    rw [ofReal_add, norm_real]
  have h2 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ≠ 0 := fun n _ ↦
    (norm_pos_iff _).mpr (add_ne_zero.mpr ⟨Int.cast_ne_zero.mpr n.cast_ne_zero, a_ne_zero⟩)
  have h3 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ^ re s ≠ 0 := fun n _ ↦
    pow_ne_zero _ (h2 n ‹_›)
  refine HasSum.congr (hasSum_Gamma_of_re_pos (hurwitzZetaEven_term_summable a hs) hs
    (hurwitzZetaEven_term_summable a hs) hs fun n ↦ ?_) fun n ↦ rfl
  simp_rw [h1 n hs, hurwitzZetaEven_term, div_right_comm,
    div_right_comm (Gammaℝ s), div_self (h3 n ‹_›), one_div]

Repaired Proof:
lemma hasSum_int_completedHurwitzZetaEven (a : ℝ) {s : ℂ} (hs : 1 < re s) :
    HasSum (fun n : ℤ ↦ Gammaℝ s / (↑|n + a| : ℂ) ^ s / 2) (completedHurwitzZetaEven a s)  := by
  have h1 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ = ‖(n : ℝ) + a‖ := by
    intro n _
    rw [ofReal_add, norm_real]
  have h2 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ≠ 0 := fun n _ ↦
    (norm_pos_iff _).mpr (add_ne_zero.mpr ⟨Int.cast_ne_zero.mpr n.cast_ne_zero, a_ne_zero⟩)
  have h3 : ∀ n : ℤ, 0 < re s → ‖(n : ℂ) + a‖ ^ re s ≠ 0 := fun n _ ↦
    pow_ne_zero _ (h2 n ‹_›)
  refine HasSum.congr (hasSum_Gamma_of_re_pos (hurwitzZetaEven_term_summable a hs) hs
    (hurwitzZetaEven_term_summable a hs) hs fun n ↦ ?_) fun n ↦ rfl
  simp_rw [h1 n hs, hurwitzZetaEven_term, div_right_comm,
    div_right

Attempt failure.

Working on Mathlib/NumberTheory/LegendreSymbol/Basic.lean - 2024-09-09 01:59:35.718260.
---147/200---
For theorem legendreSym.eq_one_of_sq_sub_mul_sq_eq_zero' in Mathlib/NumberTheory/LegendreSymbol/Basic.lean:
theorem eq_one_of_sq_sub_mul_sq_eq_zero' {p : ℕ} [Fact p.Prime] {a : ℤ} (ha : (a : ZMod p) ≠ 0)
    {x y : ZMod p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) : legendreSym p a = 1 


Original valid proof:
:= by
  haveI hy : y ≠ 0 := by
    rintro rfl
    rw [zero_pow two_ne_zero, mul_zero, sub_zero, sq_eq_zero_iff] at hxy
    exact hx hxy
  exact eq_one_of_sq_sub_mul_sq_eq_zero ha hy hxy


Verifying proof (Commit 8e31b5ac6bed8ba535a30f3442252684d2f151c1):
∨ legendreSym p a = -1 :=
  legendreSym.eq_one_or_neg_one_of_sq_sub_mul_sq_eq_zero' ha hx hxy


theorem eq_one_of_sq_sub_mul_sq_eq_zero {p : ℕ} [Fact p.Prime] {a : ℤ} (ha : (a : ZMod p) ≠ 0)
    {x y : ZMod p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) : legendreSym p a = 1 := by
  have hy : y ≠ 0 := by
    rintro rfl
    rw [zero_pow two_ne_zero, mul_zero, sub_zero, sq_eq_zero_iff] at hxy
    exact hx hxy
  have hxy' : (x / y) ^ 2 = a := by
    rw [← sub_eq_zero] at hxy
    field_simp [mul_comm, sq, ← hxy]
    apply mul_left_cancel₀ (pow_ne_zero 2 hy)
    ring
  have hxy'' : (x / y : ZMod p) ^ 2 = a := by
    push_cast
    exact hxy'
  rcases legendreSym.eq_one_or_neg_one_of_sq_eq_prime_of_ne_zero' hx hxy'' with (rfl | rfl)
  · rfl
  · simpa [legendreSym.neg_one] using congr_arg (· ^ 2) hxy''


theorem eq_one_of_sq_sub_mul_sq_eq_zero_field {p : ℕ} [Fact p.Prime] {a : ℤ} (ha : (a : 𝔽p) ≠ 0)
    {x y : 𝔽p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) : legendreSym p a = 1 := by
  apply eq_one_of_sq_sub_mul_sq_eq_zero ha
  · intro h
    rw [h] at hx
    simp at hx
  · norm_cast at hxy


theorem eq_neg_one_iff_not_one {p : ℕ} [Fact p.Prime] {a : ℤ} (ha : (a : ZMod p) ≠ 0) :
    legendreSym p a = -1 ↔ ¬legendreSym p a = 1 := by
  have h₁ := legendreSym.eq_one_or_neg_one_of_sq_sub_mul_sq_eq_zero' ha
  have h₂ := legendreSym.eq_one_of_sq_sub_mul_sq_eq_zero' ha
  constructor
  · rintro h
    contrapose! h
    exact h₂ h
  · intro h
    contrapose! h
    exact h₁.resolve_right h


theorem eq_neg_one_iff_not_one_of_sq_sub_mul_sq_eq_zero {p : ℕ} [Fact p.Prime] {a : ℤ}
    (ha : (a : ZMod p) ≠ 0) {x y : ZMod p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) :
    legendreSym p a = -1 ↔ ¬legendreSym p a = 1 :=
  legendreSym.eq_neg_one_iff_not_one ha <| eq_one_of_sq_sub_mul_sq_eq_zero ha hx hxy


theorem eq_neg_one_iff_not_one_of_sq_sub_mul_sq_eq_zero' {p : ℕ} [Fact p.Prime] {a : ℤ}
    (ha : (a : ZMod p) ≠ 0) {x y : ZMod p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) :
    legendreSym p a = -1 ↔ ¬legendreSym p a = 1 :=
  legendreSym.eq_neg_one_iff_not_one ha <| eq_one_of_sq_sub_mul_sq_eq_zero' ha hx hxy


theorem eq_neg_one_iff_not_one_of_sq_sub_mul_sq_eq_zero_field {p : ℕ} [Fact p.Prime] {a : ℤ}
    (ha : (a : 𝔽p) ≠ 0) {x y : 𝔽p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) :
    legendreSym p a = -1 ↔ ¬legendreSym p a = 1 :=
  legendreSym.eq_neg_one_iff_not_one ha <| eq_one_of_sq_sub_mul_sq_eq_zero_field ha hx hxy


theorem eq_one_iff_not_neg_one {p : ℕ} [Fact p.Prime] {a : ℤ} (ha : (a : ZMod p) ≠ 0) :
    legendreSym p a = 1 ↔ ¬legendreSym p a = -1 := by
  have h₁ := legendreSym.eq_one_or_neg_one_of_sq_sub_mul_sq_eq_zero' ha
  have h₂ := legendreSym.eq_one_of_sq_sub_mul_sq_eq_zero' ha
  constructor
  · rintro h
    contrapose! h
    exact h₂ h
  · intro h
    contrapose! h
    exact h₁.resolve_right h


theorem eq_one_iff_not_neg_one_of_sq_sub_mul_sq_eq_zero {p : ℕ} [Fact p.Prime] {a : ℤ}
    (ha : (a : ZMod p) ≠ 0) {x y : ZMod p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) :
    legendreSym p a = 1 ↔ ¬legendreSym p a = -1 :=
  legendreSym.eq_one_iff_not_neg_one ha <| eq_neg_one_iff_not_one_of_sq_sub_mul_sq_eq_zero ha hx hxy


theorem eq_one_iff_not_neg_one_of_sq_sub_mul_sq_eq_zero' {p : ℕ} [Fact p.Prime] {a : ℤ}
    (ha : (a : ZMod p) ≠ 0) {x y : ZMod p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) :
    legendreSym p a = 1 ↔ ¬legendreSym p a = -1 :=
  legendreSym.eq_one_iff_not_neg_one ha <| eq_neg_one_iff_not_one_of_sq_sub_mul_sq_eq_zero' ha hx hxy


theorem eq_one_iff_not_neg_one_of_sq_sub_mul_sq_eq_zero_field {p : ℕ} [Fact p.Prime] {a : ℤ}
    (ha : (a : 𝔽p) ≠ 0) {x y : 𝔽p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) :
    legendreSym p a = 1 ↔ ¬legendreSym p a = -1 :=
  legendreSym.eq_one_iff_not_neg_one ha <| eq_neg_one_iff_not_one_of_sq_sub_mul_sq_eq_zero_field ha hx hxy


theorem eq_neg_one_or_one_of_sq_sub_mul_sq_eq_zero_field {p : ℕ} [Fact p.Prime] {a : ℤ}
    (ha : (a : 𝔽p) ≠ 0) {x y : 𝔽p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) :
    legendreSym p a = -1 ∨ legendreSym p a = 1 := by
  have h₁ := legendreSym.eq_one_or_neg_one_of_sq_sub_mul_sq_eq_zero' ha
  have h₂ := legendreSym.eq_

Attempt failure.

Working on Mathlib/NumberTheory/Liouville/Measure.lean - 2024-09-09 01:59:45.931869.
---148/200---
For theorem volume_iUnion_setOf_liouvilleWith in Mathlib/NumberTheory/Liouville/Measure.lean:
theorem volume_iUnion_setOf_liouvilleWith :
    volume (⋃ (p : ℝ) (_hp : 2 < p), { x : ℝ | LiouvilleWith p x }) = 0 


Original valid proof:
:= by
  simp only [← setOf_exists, exists_prop]
  refine measure_mono_null setOf_liouvilleWith_subset_aux ?_
  rw [measure_iUnion_null_iff]; intro m; rw [measure_preimage_add_right]; clear m
  refine (measure_biUnion_null_iff <| to_countable _).2 fun n (hn : 1 ≤ n) => ?_
  generalize hr : (2 + 1 / n : ℝ) = r
  replace hr : 2 < r := by simp [← hr, zero_lt_one.trans_le hn]
  clear hn n
  refine measure_setOf_frequently_eq_zero ?_
  simp only [setOf_exists, ← exists_prop, ← Real.dist_eq, ← mem_ball, setOf_mem_eq]
  set B : ℤ → ℕ → Set ℝ := fun a b => ball (a / b) (1 / (b : ℝ) ^ r)
  have hB : ∀ a b, volume (B a b) = ↑((2 : ℝ≥0) / (b : ℝ≥0) ^ r) := fun a b ↦ by
    rw [Real.volume_ball, mul_one_div, ← NNReal.coe_two, ← NNReal.coe_natCast, ← NNReal.coe_rpow,
      ← NNReal.coe_div, ENNReal.ofReal_coe_nnreal]
  have : ∀ b : ℕ, volume (⋃ a ∈ Finset.Icc (0 : ℤ) b, B a b) ≤
      ↑(2 * ((b : ℝ≥0) ^ (1 - r) + (b : ℝ≥0) ^ (-r))) := fun b ↦
    calc
      volume (⋃ a ∈ Finset.Icc (0 : ℤ) b, B a b) ≤ ∑ a ∈ Finset.Icc (0 : ℤ) b, volume (B a b) :=
        measure_biUnion_finset_le _ _
      _ = ↑((b + 1) * (2 / (b : ℝ≥0) ^ r)) := by
        simp only [hB, Int.card_Icc, Finset.sum_const, nsmul_eq_mul, sub_zero, ← Int.ofNat_succ,
          Int.toNat_natCast, ← Nat.cast_succ, ENNReal.coe_mul, ENNReal.coe_natCast]
      _ = _ := by
        have : 1 - r ≠ 0 := by linarith
        rw [ENNReal.coe_inj]
        simp [add_mul, div_eq_mul_inv, NNReal.rpow_neg, NNReal.rpow_sub' _ this, mul_add,
          mul_left_comm]
  refine ne_top_of_le_ne_top (ENNReal.tsum_coe_ne_top_iff_summable.2 ?_) (ENNReal.tsum_le_tsum this)
  refine (Summable.add ?_ ?_).mul_left _ <;> simp only [NNReal.summable_rpow] <;> linarith


Verifying proof (Commit ff33d25c791a3fac407c782b49018fcb63700d0d):
↔
      (⋃ (p : ℝ) (_hp : 2 < p), { x : ℝ | LiouvilleWith p x }) = ∅ := by
  rw [← measure_univ_eq_zero, volume_iUnion_setOf_liouvilleWith_pos]
  simp only [lt_self_iff_false, forall_const, measure_univ_pos, false_or_iff]

Repaired Proof:
theorem volume_iUnion_setOf_liouvilleWith :
    volume (⋃ (p : ℝ) (_hp : 2 < p), { x : ℝ | LiouvilleWith p x }) = 0 ↔
      (⋃ (p : ℝ) (_hp : 2 < p), { x : ℝ | LiouvilleWith p x }) = ∅ := by
  rw [← measure_univ_eq_zero, volume_iUnion_setOf_liouvilleWith_pos]
  simp only [lt_self_iff_false, forall_const, measure_univ_pos, false_or_iff]

Repaired Proof:
theorem ae_not_liouvilleWith : ∀ᵐ x, ¬LiouvilleWith p x := by
  simp only [ae_iff, not_forall, Classical.not_not]
  rcases eq_or_ne p 2 with (rfl | hp)
  · rw [volume_iUnion_setOf_liouvilleWith]
    simp only [lt_irrefl, iUnion_of_empty, measure_empty, eventually_const]
  rcases eq_or_lt_of_le (one_lt_two : 1 < 2) with (rfl | hlt)
  · simp only [measure_univ_eq_zero, iUnion_of_empty, measure_empty, eventually_const]
  rcases hpos.eq_or_lt with (rfl | hpos')
  · simp only [measure_univ_eq_zero, iUnion_of_empty, measure_empty, eventually_const]
  let q := (2 : ℝ) / p
  have hpq : 1 < q := by
    rw [div_lt_iff hpos]
    exact hlt.trans_le' (le_of_eq (by ring))
  have hpq' : 0 < q - 1 := sub_pos.2 hpq
  let m : ℝ≥0 := ⟨(q - 1)⁻¹, inv_pos.2 hpq'.bot_lt⟩
  have hm : 0 < m := by simpa only [m, Nat.cast_ofNat] using inv_pos.2 hpq'.bot_lt
  let B : ℕ → ℝ := fun n => n * m
  suffices H : ∀ᵐ x, ∀ n : ℕ, x ∉ {x : ℝ | LiouvilleWith (B n) x}
  · filter_upwards [H] with x hx
    simpa only [← not_exists, setOf_forall]
  have : ∀ n : ℕ, volume {x : ℝ | LiouvilleWith (B n) x} ≤ (m : ℝ≥0∞) ^ n := by
    intro n
    have : (m : ℝ≥0∞) ^ n = ((m : ℝ≥0) : ℝ≥0∞) ^ n := by simp only [ENNReal.coe_nat_cast]
    conv_lhs => rw [this]
    rw [volume_setOf_liouvilleWith_image_aux (m : ℝ≥0) hm.ne' n,
      ENNReal.ofReal_rpow_of_nonneg _ hm.le, ← ENNReal.ofReal_pow]
    · gcongr
      exact pow_le_one _ hm.le zero_le_one
    · rw [inv_nonneg]
      exact sub_nonneg.2 hpq.le
  have L : HasSum (fun n : ℕ => (m : ℝ≥0∞) ^ n) (ENNReal.ofReal (m⁻¹)) := by
    simp only [m, ENNReal.ofReal_inv_of_pos hpq'.bot_lt, ENNReal.inv_pow, ENNReal.hasSum_nat_add_iff]
    refine' ⟨_, ENNReal.summable.hasSum⟩
    simp only [ENNReal.tsum_eq_top_of_eq_top (ENNReal.pow_top hm.ne'), top_le_iff, bot_eq_zero,
      ENNReal.ofReal_eq_zero, inv_nonpos, hpq'.not_le]
  have M : (m : ℝ≥0∞) < 1 := by
    rw [ENNReal.coe_nat_cast, ENNReal.coe_lt_one_iff]
    exact ⟨m.2.le, hpq'.ne'⟩
  filter_upwards [ae_lt_of_measure_lt_top (measure_iUnion_le _)
      ((ENNReal.hasSum_lt_top_iff_finite.2 (measure_iUnion_lt_top _)).2 _ L),
    ae_lt_top measure_univ_lt_top (ENNReal.ofReal (m⁻¹)),
    ae_lt_top measure_univ_lt_top (ENNReal.ofReal ((m : ℝ≥0) ^ (0 : ℕ)))]
    with x hx h'x h''x
    refine' NNReal.sum_indicator_eq_sum_meas_inter_mul_card
      (fun n : ℕ => {x : ℝ | LiouvilleWith (B n) x}) (finite_le_nat _) _ _
    · simp only [← ae_all_iff]
      intro n
      have : (m : ℝ≥0∞) ^ n < 1 := (ENNReal.rpow_lt_one_iff_of_nonneg hm.le).2 ⟨hpq'.ne', hm.ne'⟩
      simpa only [ae_iff, not_eventually, not_not, ← compl_setOf,
        (measure_mono (compl_subset_compl.2 (image_preimage_subset _ _))).trans_lt hx,
        ENNReal.mul_lt_top h'x h''x, measure_univ_lt_top, not_true, Ne, or_false_iff,
        ENNReal.ofReal_pos, inv_pos, ENNReal.ofReal_rpow_of_nonneg _ hm.le,
        ENNReal.ofReal_inv_of_pos hpq'.bot_lt, ENNReal.inv_pow, ENNReal.ofReal_pow] using this
    · intro n
      simp only [B, ← ae_iff, measure_setOf_liouvilleWith_image_aux_le_mul_rpow_aux hm.ne' n,
        ENNReal.ofReal_rpow_of_nonneg _ hm.le, ← ENNReal.ofReal_pow, ENNReal.ofReal_coe_nnreal]

Repaired Proof:
theorem ae_not_liouvilleWith : ∀ᵐ x, ¬LiouvilleWith p x := by
  simp only [ae_iff, not_forall, Classical.not_not]
  rcases eq_or_ne p 2 with (rfl | hp)
  · rw [volume_iUnion_setOf_liouvilleWith]
    simp only [lt_irrefl, iUnion_of_empty, measure_empty, eventually_const]
  rcases eq_or_lt_of_le (one_lt_two : 1 < 2) with (rfl | hlt)
  · simp only [measure_univ_eq_zero, iUnion_of_empty, measure_empty, eventually_const]
  rcases hpos.eq_or_lt with (rfl | hpos')
  · simp only [measure_univ_eq_zero, iUnion_of_empty, measure_empty, eventually_const]
  let q := (2 : ℝ) / p
  have hpq : 1 < q := by
    rw [div_lt_iff hpos]
    exact hlt.trans_le' (le_of_eq (by ring))
  have hpq' : 0 < q - 1 := sub_pos.2 hpq
  let m : ℝ≥0 := ⟨(q - 1)⁻¹, inv_pos.2 hpq'.bot_lt⟩
  have hm : 0 < m := by simpa only [m, Nat.cast_ofNat] using inv_pos.2 hpq'.bot_lt
  let B : ℕ → ℝ := fun n => n * m
  suffices H : �

Attempt failure.

Working on Mathlib/NumberTheory/Modular.lean - 2024-09-09 01:59:57.560593.
---149/200---
For theorem ModularGroup.smul_eq_lcRow0_add in Mathlib/NumberTheory/Modular.lean:
theorem smul_eq_lcRow0_add {p : Fin 2 → ℤ} (hp : IsCoprime (p 0) (p 1)) (hg : (↑ₘg) 1 = p) :
    ↑(g • z) =
      (lcRow0 p ↑(g : SL(2, ℝ)) : ℂ) / ((p 0 : ℂ) ^ 2 + (p 1 : ℂ) ^ 2) +
        ((p 1 : ℂ) * z - p 0) / (((p 0 : ℂ) ^ 2 + (p 1 : ℂ) ^ 2) * (p 0 * z + p 1)) 


Original valid proof:
:= by
  have nonZ1 : (p 0 : ℂ) ^ 2 + (p 1 : ℂ) ^ 2 ≠ 0 := mod_cast hp.sq_add_sq_ne_zero
  have : ((↑) : ℤ → ℝ) ∘ p ≠ 0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)
  have nonZ2 : (p 0 : ℂ) * z + p 1 ≠ 0 := by simpa using linear_ne_zero _ z this
  field_simp [nonZ1, nonZ2, denom_ne_zero, num]
  rw [(by simp :
    (p 1 : ℂ) * z - p 0 = (p 1 * z - p 0) * ↑(Matrix.det (↑g : Matrix (Fin 2) (Fin 2) ℤ)))]
  rw [← hg, det_fin_two]
  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_intCast, map_apply, denom,
    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix, coe'_apply_complex]
  ring


Verifying proof (Commit 2aa3afc6b7f6110e2c9da6202a3b71cc7501f244):
• z := by
  rw [← mod_cast hg, ← coe_int_v, ← coe_int_v, ← coe_int_v, ← coe_int_v, ← coe_int_v, ← coe_int_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,
    coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v, coe_v,

Attempt failure.

Working on Mathlib/NumberTheory/Multiplicity.lean - 2024-09-09 02:00:12.639470.
---150/200---
For theorem multiplicity.Int.pow_sub_pow in Mathlib/NumberTheory/Multiplicity.lean:
theorem Int.pow_sub_pow {x y : ℤ} (hxy : ↑p ∣ x - y) (hx : ¬↑p ∣ x) (n : ℕ) :
    multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n 


Original valid proof:
:= by
  cases' n with n
  · simp only [multiplicity.zero, add_top, pow_zero, sub_self, Nat.zero_eq]
  have h : (multiplicity _ _).Dom := finite_nat_iff.mpr ⟨hp.ne_one, n.succ_pos⟩
  simp only [Nat.succ_eq_add_one] at h
  rcases eq_coe_iff.mp (PartENat.natCast_get h).symm with ⟨⟨k, hk⟩, hpn⟩
  conv_lhs => rw [hk, pow_mul, pow_mul]
  rw [Nat.prime_iff_prime_int] at hp
  rw [pow_sub_pow_of_prime hp, pow_prime_pow_sub_pow_prime_pow hp hp1 hxy hx, PartENat.natCast_get]
  · rw [← geom_sum₂_mul]
    exact dvd_mul_of_dvd_right hxy _
  · exact fun h => hx (hp.dvd_of_dvd_pow h)
  · rw [Int.natCast_dvd_natCast]
    rintro ⟨c, rfl⟩
    refine hpn ⟨c, ?_⟩
    rwa [pow_succ, mul_assoc]


Verifying proof (Commit 6be2bec13d4dd1fd901f9a619d053d7549cfe177):
↔
      n ≠ 0 ∧ ∀ m : ℕ, m < n → ¬↑p ∣ x ^ m - y ^ m := by
  rcases eq_or_ne n 0 with (rfl | hn0); · simp
  rcases eq_or_ne x y with (rfl | hxy'); · simp [hn0, hx]
  rw [← Int.dvd_iff_emod_eq_zero, ←
    Nat.dvd_iff_mod_eq_zero (α := ℕ), multiplicity.int_pow_sub_pow_of_prime hp hp1 hxy hx,
    Nat.cast_inj, Nat.cast_inj]
  have hcoe : ((multiplicity (↑p) (x - y)).get (finite_int_iff.2 ⟨hp.1.ne_one, hxy⟩) : ℕ) =
      (multiplicity p (x - y)).get (finite_nat_iff.2 ⟨hp.1.ne_one, mod_cast hxy⟩) := by
    rw [PartENat.get_natCast, PartENat.get_natCast, multiplicity.int_eq_nat_iff hp hp1.ne_zero,
      multiplicity.int.multiplicity_finite_nat hp1.ne_zero hxy,
      multiplicity.nat.multiplicity_finite hp.1.ne_one (mod_cast hxy)]
  rw [hcoe, PartENat.get_eq_iff_eq_coe, PartENat.get_eq_iff_eq_coe, PartENat.natCast_get,
    PartENat.natCast_get, ← Nat.cast_inj (R := ℤ), ← Nat.cast_inj (R := ℤ), Nat.cast_inj,
    Nat.cast_inj]
  have hcoe' :
      ((multiplicity p n).get (finite_nat_iff.2 ⟨hp.1.ne_one, hn0⟩) : ℕ) =
        (multiplicity p n).get (finite_int_iff.2 ⟨hp.1.ne_one, mod_cast hn0⟩) := by
    rw [PartENat.get_natCast, PartENat.get_natCast, multiplicity.int_eq_nat_iff hp hp1.ne_zero,
      multiplicity.int.multiplicity_finite_nat hp1.ne_zero hn0,
      multiplicity.nat.multiplicity_finite hp.1.ne_one (mod_cast hn0)]
  rw [hcoe', PartENat.get_eq_iff_eq_coe, PartENat.get_eq_iff_eq_coe, PartENat.natCast_get,
    PartENat.natCast_get, ← Nat.cast_inj (R := ℤ), ← Nat.cast_inj (R := ℤ), Nat.cast_inj,
    Nat.cast_inj]
  have hcoe'' :
      ((multiplicity p m).get
          (finite_int_iff.2 ⟨hp.1.ne_one, mod_cast (pow_ne_pow_of_ne_one hxy' hn0 m)⟩) : ℕ) =
        (multiplicity p m).get
          (finite_nat_iff.2 ⟨hp.1.ne_one, pow_ne_pow_of_ne_one hxy' hn0 m⟩) := by
    rw [PartENat.get_natCast, PartENat.get_natCast, multiplicity.int_eq_nat_iff hp hp1.ne_zero,
      multiplicity.int.multiplicity_finite_nat hp1.ne_zero,
      multiplicity.nat.multiplicity_finite hp.1.ne_one]
    simpa only [PartENat.get_eq_iff_eq_coe, PartENat.get_eq_iff_eq_coe,
      PartENat.natCast_get, PartENat.natCast_get, Nat.cast_inj, Nat.cast_inj] using Iff.rfl
  simp only [hcoe, hcoe', hcoe'']
  refine' ⟨fun h => ⟨mod_cast hn0, fun m hm => _⟩, fun h => ⟨mod_cast h.1, h.2⟩⟩
  rw [← mod_cast (@multiplicity.int.multiplicity_eq_multiplicity_nat_iff _ _ _ _ _ _ hp1.ne_zero),
    multiplicity.int.multiplicity_eq_zero_of_coprime (mod_cast pow_ne_pow_of_ne_one hxy' hn0 m),
    multiplicity.nat.multiplicity_eq_zero_of_coprime]
  rw [pow_ne_pow_of_ne_one hxy' hn0] at hm
  exact mod_cast hm

Repaired Proof:
theorem Int.pow_sub_pow {x y : ℤ} (hxy : ↑p ∣ x - y) (hx : ¬↑p ∣ x) (n : ℕ) :
    multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n ↔
      n ≠ 0 ∧ ∀ m : ℕ, m < n → ¬↑p ∣ x ^ m - y ^ m := by
  rcases eq_or_ne n 0 with (rfl | hn0); · simp
  rcases eq_or_ne x y with (rfl | hxy'); · simp [hn0, hx]
  rw [← Int.dvd_iff_emod_eq_zero, ←
    Nat.dvd_iff_mod_eq_zero (α := ℕ), multiplicity.int_pow_sub_pow_of_prime hp hp1 hxy hx,
    Nat.cast_inj, Nat.cast_inj]
  have hcoe : ((multiplicity (↑p) (x - y)).get (finite_int_iff.2 ⟨hp.1.ne_one, hxy⟩) : ℕ) =
      (multiplicity p (x - y)).get (finite_nat_iff.2 ⟨hp.1.ne_one, mod_cast hxy⟩) := by
    rw [PartENat.get_natCast, PartENat.get_natCast, multiplicity.int_eq_nat_iff hp hp1.ne_zero,
      multiplicity.int.multiplicity_finite_nat hp1.ne_zero hxy,
      multiplicity.nat.multiplicity_finite hp.1.ne_one (mod_cast hxy)]
  rw [hcoe, PartENat.get_eq_iff_eq_coe, PartENat.get_eq_iff_eq_coe, PartENat.natCast_get,
    PartENat.natCast_get, ← Nat.cast_inj (R := ℤ), ← Nat.cast_inj (R := ℤ), Nat.cast_inj,
    Nat.cast_inj]
  have hcoe' :
      ((multiplicity p n).get (finite_nat_iff.2 ⟨hp.1.ne_one, hn0⟩) : ℕ) =
        (multiplicity p n).get (finite_int_iff.2 ⟨hp.1.ne_one, mod_cast hn0⟩) := by
    rw [PartENat.get_natCast, PartENat.get_natCast, multiplicity.int_eq_nat_iff hp hp1.ne_zero,
      multiplicity.int.multiplicity_finite_nat hp1.ne_zero hn0,
      multiplicity.nat.multiplicity_finite hp.1.ne_one (mod_cast hn0)]
  rw [hcoe', PartENat.get_eq_iff_eq_coe, PartENat.get_eq_iff_eq_coe, PartENat.natCast_get,
    PartENat.natCast_get, ← Nat.cast_inj (R := ℤ), ← Nat.cast_inj (R := ℤ), Nat.cast_inj,
    Nat.cast_inj]
  have hcoe'' :
      ((multiplicity p m).get
          (finite_int_iff.2 ⟨hp.1.ne_one, mod_cast (pow_ne_pow_of_ne_one hxy' hn0 m)⟩) : ℕ) =
        (multiplicity p m).get
          (finite_nat_iff.2 ⟨hp.1.ne_one, pow_ne_pow_of_ne_one hxy' hn0 m⟩) := by
    rw [PartENat.get_natCast, PartENat.get_natCast, multiplicity.int_eq_nat_iff hp hp1.ne_zero,
      multiplicity.int.multiplicity_

Attempt failure.

Working on Mathlib/NumberTheory/Pell.lean - 2024-09-09 02:00:21.771811.
---151/200---
For theorem Pell.Solution₁.eq_zero_of_d_neg in Mathlib/NumberTheory/Pell.lean:
theorem eq_zero_of_d_neg (h₀ : d < 0) (a : Solution₁ d) : a.x = 0 ∨ a.y = 0 


Original valid proof:
:= by
  have h := a.prop
  contrapose! h
  have h1 := sq_pos_of_ne_zero h.1
  have h2 := sq_pos_of_ne_zero h.2
  nlinarith


Verifying proof (Commit a71231735e55fa1fc4000a42658641f766fde88b):
∨ a.d = 0 := by
  rcases eq_or_ne a.x 0 with (h | h)
  · exact Or.inl h
  rcases eq_or_ne a.y 0 with (h' | h')
  · exact Or.inr (Or.inl h')
  rcases eq_or_ne a.d 0 with (h'' | h'')
  · exact Or.inr (Or.inr h'')
  rw [← sq_pos_iff, ← a.prop_y, ← mul_self_pos] at h
  rw [Ne.def, ← Int.natAbs_eq_zero, ← Int.natAbs_mul, mul_eq_zero,
    Int.natAbs_eq_zero, Int.natAbs_eq_zero] at h'
  rw [Ne.def, ← Int.natAbs_eq_zero, ← Int.natAbs_mul, mul_eq_zero,
    Int.natAbs_eq_zero, Int.natAbs_eq_zero] at h''
  rw [← Int.natAbs_mul, ← sq, ← Int.natAbs_mul, ← sq] at h
  exact False.elim (h'' (Int.natAbs_eq_zero.1 (pos_iff_ne_zero.1 (h.resolve_left h'.1)).resolve_left h'.2))

Repaired Proof:
theorem eq_zero_of_d_neg (h₀ : d < 0) (a : Solution₁ d) : a.x = 0 ∨ a.y = 0 ∨ a.d = 0 := by
  rcases eq_or_ne a.x 0 with (h | h)
  · exact Or.inl h
  rcases eq_or_ne a.y 0 with (h' | h')
  · exact Or.inr (Or.inl h')
  rcases eq_or_ne a.d 0 with (h'' | h'')
  · exact Or.inr (Or.inr h'')
  rw [← sq_pos_iff, ← a.prop_y, ← mul_self_pos] at h
  rw [Ne, ← Int.natAbs_eq_zero, ← Int.natAbs_mul, mul_eq_zero,
    Int.natAbs_eq_zero, Int.natAbs_eq_zero] at h'
  rw [Ne, ← Int.natAbs_eq_zero, ← Int.natAbs_mul, mul_eq_zero,
    Int.natAbs_eq_zero, Int.natAbs_eq_zero] at h''
  rw [← Int.natAbs_mul, ← sq, ← Int.natAbs_mul, ← sq] at h
  exact False.elim (h'' (Int.natAbs_eq_zero.1 (pos_iff_ne_zero.1 (h.resolve_left h'.1)).resolve_left h'.2))

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution₁ d) : a = b := by
  simp only [Subtype.mk.injEq, eq_iff_true_of_subsingleton]
  rcases a with ⟨_, _, _⟩
  rcases b with ⟨_, _, _⟩
  trivial

Repaired Proof:
theorem eq_of_d_eq_zero (h₀ : d = 0) (a b : Solution

Attempt failure.

Working on Mathlib/Order/BooleanGenerators.lean - 2024-09-09 02:00:34.234028.
---152/200---
For theorem IsCompactlyGenerated.BooleanGenerators.complementedLattice_of_sSup_eq_top in Mathlib/Order/BooleanGenerators.lean:
lemma complementedLattice_of_sSup_eq_top (h : sSup S = ⊤) : ComplementedLattice α 


Original valid proof:
:= by
  let _i := hS.distribLattice_of_sSup_eq_top h
  have _i₁ := isAtomistic_of_sSup_eq_top hS h
  apply complementedLattice_of_isAtomistic


Verifying proof (Commit 91cefd36159ba7887974ebf32978e5a613629ba1):
↔ ∀ a ∈ S, ∃ b, a ⊓ b = ⊥ ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans
    ⟨fun h' a ha ↦ h' a ha ⊤ (sSup_le fun _ _ ↦ le_top), fun h' a ha b hab ↦ by
      obtain ⟨c, hac, hac'⟩ := h' a ha
      obtain ⟨d, had, had'⟩ := h' b.compl (sSup_le fun b' hb' ↦ le_compl_iff_disjoint_left.mpr <| hab b' hb')
      refine' ⟨c ⊔ d, disjoint_sSup_right (fun b' hb' ↦ hac.mono_right <| sup_le (le_sSup hb') le_top) _,
        sup_sSup_eq_sSup_sup_distrib_right _ _ _⟩
      rw [sup_assoc, ← hac', disj_sSup_right (fun b' hb' ↦ hac.symm ▸ hac.mono_right <| le_sSup hb') had,
        one_sup_eq_top]⟩

lemma complementedLattice_of_sSup_eq_top' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, Disjoint a b ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top'' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, Codisjoint a b ∧ a ⊓ b = ⊥ :=
  complementedLattice_iff_sSup_codisjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, a ⊓ b = ⊥ ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top'''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, Disjoint a b ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, Codisjoint a b ∧ a ⊓ b = ⊥ :=
  complementedLattice_iff_sSup_codisjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top'''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, a ⊓ b = ⊥ ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top''''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, Disjoint a b ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top'''''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, Codisjoint a b ∧ a ⊓ b = ⊥ :=
  complementedLattice_iff_sSup_codisjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top''''''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, a ⊓ b = ⊥ ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top'''''''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, Disjoint a b ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top''''''''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, Codisjoint a b ∧ a ⊓ b = ⊥ :=
  complementedLattice_iff_sSup_codisjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top'''''''''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, a ⊓ b = ⊥ ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top''''''''''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, Disjoint a b ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top'''''''''''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, Codisjoint a b ∧ a ⊓ b = ⊥ :=
  complementedLattice_iff_sSup_codisjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top''''''''''''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, a ⊓ b = ⊥ ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top'''''''''''''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a ∈ S, ∃ b, Disjoint a b ∧ a ⊔ b = ⊤ :=
  complementedLattice_iff_sSup_disjoint_complement.trans <| forall₂_congr fun _ _ ↦ by
    simp [h]

lemma complementedLattice_of_sSup_eq_top''''''''''''''''' (h : sSup S = ⊤) : ComplementedLattice α ↔ ∀ a

Attempt failure.

Working on Mathlib/Order/CompactlyGenerated/Basic.lean - 2024-09-09 02:00:39.541459.
---153/200---
For theorem CompleteLattice.independent_iff_supIndep_of_injOn in Mathlib/Order/CompactlyGenerated/Basic.lean:
lemma CompleteLattice.independent_iff_supIndep_of_injOn {ι : Type*} {f : ι → α}
    (hf : InjOn f {i | f i ≠ ⊥}) :
    CompleteLattice.Independent f ↔ ∀ (s : Finset ι), s.SupIndep f 


Original valid proof:
:= by
  refine ⟨fun h ↦ h.supIndep', fun h ↦ CompleteLattice.independent_def'.mpr fun i ↦ ?_⟩
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, ← disjoint_iff]
  intro s hs
  classical
  rw [← Finset.sup_erase_bot]
  set t := s.erase ⊥
  replace hf : InjOn f (f ⁻¹' t) := fun i hi j _ hij ↦ by
    refine hf ?_ ?_ hij <;> aesop (add norm simp [t])
  have : (Finset.erase (insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image, t]
    refine ⟨by aesop, fun ⟨ha, has⟩ ↦ ?_⟩
    obtain ⟨j, hj, rfl⟩ := hs has
    exact ⟨j, ⟨hj, ha, has⟩, rfl⟩
  rw [← this, Finset.sup_image]
  specialize h (insert i (t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)


Verifying proof (Commit 9bc35020058f4a5a844eb7662d9de673056d4dbe):
↔ ∀ i ∈ s, f i ≠ ⊥ := by
  refine ⟨fun hf' s ↦ ⟨fun hs i hi ↦ ?_, fun hs ↦ ?_⟩, fun hf' ↦ ⟨fun s hs ↦ ?_⟩⟩
  · refine hf' s (fun i hi j hj ↦ hf ?_ ?_ hi hj) |>.1 hs i hi
    simpa only [ne_eq, hf.eq_iff] using hs
  · simp_rw [Finset.supIndep_iff_disjoint_erase] at hs
    simp_rw [Finset.supIndep_iff_pairwiseDisjoint]
    intros i hi j hj hij
    have hji : j ≠ i := fun h ↦ hij (h ▸ hij)
    specialize hs i hi
    specialize hs j hj
    simp_rw [Finset.sup_eq_bot_iff, mem_erase] at hs
    specialize hs hji
    simp_rw [Finset.sup_eq_bot_iff, mem_erase, ne_eq, hf.eq_iff] at hs
    exact Disjoint.mono_right hs.1 hs.2
  · simp_rw [Finset.supIndep_iff_pairwiseDisjoint] at hf'
    simp_rw [Finset.supIndep_iff_disjoint_erase]
    intros i hi
    simp_rw [Finset.sup_eq_bot_iff, mem_erase]
    intros j hj hji
    specialize hf' (s.erase i) (by simpa) j (by simpa) hji
    simp_rw [Finset.sup_eq_bot_iff, mem_erase, ne_eq, hf.eq_iff] at hf'
    exact ⟨hf'.1 hi, hf'.2 hj⟩

Repaired Proof:
lemma CompleteLattice.independent_iff_supIndep_of_injOn {ι : Type*} {f : ι → α}
    (hf : InjOn f {i | f i ≠ ⊥}) :
    CompleteLattice.Independent f ↔ ∀ (s : Finset ι), s.SupIndep f ↔ ∀ i ∈ s, f i ≠ ⊥ := by
  refine ⟨fun hf' s ↦ ⟨fun hs i hi ↦ ?_, fun hs ↦ ?_⟩, fun hf' ↦ ⟨fun s hs ↦ ?_⟩⟩
  · refine hf' s (fun i hi j hj ↦ hf ?_ ?_ hi hj) |>.1 hs i hi
    simpa only [ne_eq, hf.eq_iff] using hs
  · simp_rw [Finset.supIndep_iff_disjoint_erase] at hs
    simp_rw [Finset.supIndep_iff_pairwiseDisjoint]
    intros i hi j hj hij
    have hji : j ≠ i := fun h ↦ hij (h ▸ hij)
    specialize hs i hi
    specialize hs j hj
    simp_rw [Finset.sup_eq_bot_iff, mem_erase] at hs
    specialize hs hji
    simp_rw [Finset.sup_eq_bot_iff, mem_erase, ne_eq, hf.eq_iff] at hs
    exact Disjoint.mono_right hs.1 hs.2
  · simp_rw [Finset.supIndep_iff_pairwiseDisjoint] at hf'
    simp_rw [Finset.supIndep_iff_disjoint_erase]
    intros i hi
    simp_rw [Finset.sup_eq_bot_iff, mem_erase]
    intros j hj hji
    specialize hf' (s.erase i) (by simpa) j (by simpa) hji
    simp_rw [Finset.sup_eq_bot_iff, mem_erase, ne_eq, hf.eq_iff] at hf'
    exact ⟨hf'.1 hi, hf'.2 hj⟩

Attempt failure.

Working on Mathlib/Order/ConditionallyCompleteLattice/Basic.lean - 2024-09-09 02:00:46.108926.
---154/200---
For theorem WithTop.iInf_coe_lt_top in Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:
lemma iInf_coe_lt_top : ⨅ i, (f i : WithTop α) < ⊤ ↔ Nonempty ι 


Original valid proof:
:= by
  rw [lt_top_iff_ne_top, Ne, iInf_coe_eq_top, not_isEmpty_iff]


Verifying proof (Commit ab7200bce341f8e2a4e6620f32a3d6335eccb5c4):
∧ ∀ i, f i < ⊤ := by
    simp [WithTop.lt_top_iff_ne_top, iInf_eq_top, not_forall, exists_prop, not_or]

  lemma iInf_coe_ne_top : ⨅ i, (f i : WithTop α) ≠ ⊤ ↔ ∀ i, f i ≠ ⊤ := by
    simp only [iInf_coe_lt_top, Ne, not_and, not_forall]

  lemma iInf_coe_subtype (P : ι → α → Prop) :
    ⨅ (i) (h : P i), (f i : WithTop α) = ⨅ (i) (h : P i), WithTop.some (f i) :=
  iInf_congr' fun _ => _root_.iInf_subtype _

  lemma iInf_coe_ne_top_iff :
    (⨅ i, (f i : WithTop α)) ≠ ⊤ ↔ ∀ i, ∃ a, f i = a := by
  simp only [iInf_coe_ne_top, ne_eq, WithTop.coe_ne_top, not_false_eq_true]

  lemma iInf_coe_ne_top_iff' :
    (⨅ i, (f i : WithTop α)) ≠ ⊤ ↔ ∃ a, ∀ i, f i = a := by
  simp only [iInf_coe_ne_top, ne_eq, WithTop.coe_ne_top, not_false_eq_true, ←
    iInf_eq_iff, eq_self_iff_true, iInf_const]

  lemma iInf_coe_subtype_ne_top_iff (P : ι → α → Prop) :
    (⨅ (i) (h : P i), (f i : WithTop α)) ≠ ⊤ ↔ ∃ a, ∀ i, ∀ h : P i, f i = a := by
  simp only [iInf_coe_subtype, iInf_coe_ne_top_iff', exists_subtype]

  lemma iInf_coe_subtype_ne_top_iff' (P : ι → α → Prop) :
    (⨅ (i) (h : P i), (f i : WithTop α)) ≠ ⊤ ↔ ∃ a, ∀ i h, f i = a := by
  simp only [iInf_coe_subtype, iInf_coe_ne_top_iff', exists_prop]

  lemma iInf_coe_ne_top_iff_exists (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y : ι, f y = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_eq_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists'' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists''' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists'''' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists''''' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists'''''' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists''''''' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists'''''''' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists''''''''' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists'''''''''' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists''''''''''' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists'''''''''''' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists''''''''''''' (f : ι → WithTop α) :
    (⨅ i, f i) ≠ ⊤ ↔ ∃ x : α, ∀ y, ∃ i, f i = ↑x := by
  simp only [iInf_coe_ne_top_iff', ← exists_range_iff, exists_prop]

  lemma iInf_coe_ne_top_iff_exists'''''''''''''' (f : ι → WithTop α) :
    (⨅ i, f i) 

Attempt failure.

Working on Mathlib/Order/Extension/Well.lean - 2024-09-09 02:00:53.516458.
---155/200---
For theorem WellFounded.exists_well_order_ge in Mathlib/Order/Extension/Well.lean:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s 


Original valid proof:
:=
  ⟨hwf.wellOrderExtension.lt, fun _ _ h => Prod.Lex.left _ _ (hwf.rank_lt_of_rel h), ⟨⟩⟩


Verifying proof (Commit f2145c79419f71f289bb918aa4cca851527698f5):
∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a⟩

Repaired Proof:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s ∧ ∀ a, Acc s a :=
  ⟨_, _, _, fun a => (IsWellFounded.wf r).apply a�

Attempt failure.

Working on Mathlib/Order/Filter/EventuallyConst.lean - 2024-09-09 02:00:58.531508.
---156/200---
For theorem Filter.EventuallyConst.comp₂ in Mathlib/Order/Filter/EventuallyConst.lean:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l 


Original valid proof:
:=
  ((hf.prod hg).map op.uncurry).anti <|
    (tendsto_map (f := op.uncurry)).comp (tendsto_map.prod_mk tendsto_map)


Verifying proof (Commit 421acd0506b28a0c309081c10818feebfc9f4e0b):
∧
      (∀ᶠ x in l, op (f x) (g x) = op (hf.choose) (hg.choose)) := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨fun x ↦ op (f x) (g x), ?_, ?_⟩
  · filter_upwards [ha, hb] with x hx₁ hx₂
    simp_rw [hx₁, hx₂]
  · simp_rw [ha, hb]

Repaired Proof:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l ∧
      (∀ᶠ x in l, op (f x) (g x) = op (hf.choose) (hg.choose)) := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨fun x ↦ op (f x) (g x), ?_, ?_⟩
  · filter_upwards [ha, hb] with x hx₁ hx₂
    simp_rw [hx₁, hx₂]
  · simp_rw [ha, hb]

Repaired Proof:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l ∧
      (∀ᶠ x in l, op (f x) (g x) = op (hf.choose) (hg.choose)) := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨fun x ↦ op (f x) (g x), ?_, ?_⟩
  · filter_upwards [ha, hb] with x hx₁ hx₂
    simp_rw [hx₁, hx₂]
  · simp_rw [ha, hb]

Repaired Proof:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l ∧
      (∀ᶠ x in l, op (f x) (g x) = op (hf.choose) (hg.choose)) := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨fun x ↦ op (f x) (g x), ?_, ?_⟩
  · filter_upwards [ha, hb] with x hx₁ hx₂
    simp_rw [hx₁, hx₂]
  · simp_rw [ha, hb]

Repaired Proof:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l ∧
      (∀ᶠ x in l, op (f x) (g x) = op (hf.choose) (hg.choose)) := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨fun x ↦ op (f x) (g x), ?_, ?_⟩
  · filter_upwards [ha, hb] with x hx₁ hx₂
    simp_rw [hx₁, hx₂]
  · simp_rw [ha, hb]

Repaired Proof:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l ∧
      (∀ᶠ x in l, op (f x) (g x) = op (hf.choose) (hg.choose)) := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨fun x ↦ op (f x) (g x), ?_, ?_⟩
  · filter_upwards [ha, hb] with x hx₁ hx₂
    simp_rw [hx₁, hx₂]
  · simp_rw [ha, hb]

Repaired Proof:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l ∧
      (∀ᶠ x in l, op (f x) (g x) = op (hf.choose) (hg.choose)) := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨fun x ↦ op (f x) (g x), ?_, ?_⟩
  · filter_upwards [ha, hb] with x hx₁ hx₂
    simp_rw [hx₁, hx₂]
  · simp_rw [ha, hb]

Repaired Proof:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l ∧
      (∀ᶠ x in l, op (f x) (g x) = op (hf.choose) (hg.choose)) := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨fun x ↦ op (f x) (g x), ?_, ?_⟩
  · filter_upwards [ha, hb] with x hx₁ hx₂
    simp_rw [hx₁, hx₂]
  · simp_rw [ha, hb]

Repaired Proof:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l ∧
      (∀ᶠ x in l, op (f x) (g x) = op (hf.choose) (hg.choose)) := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨fun x ↦ op (f x) (g x), ?_, ?_⟩
  · filter_upwards [ha, hb] with x hx₁ hx₂
    simp_rw [hx₁, hx₂]
  · simp_rw [ha, hb]

Repaired Proof:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l ∧
      (∀ᶠ x in l, op (f x) (g x) = op (hf.choose) (hg.choose)) := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨fun x ↦ op (f x) (g x), ?_, ?_⟩
  · filter_upwards [ha, hb] with x hx₁ hx₂
    simp_rw [hx₁, hx₂]
  · simp_rw [ha, hb]

Repaired Proof:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l ∧
      (∀ᶠ x in l, op (f x) (g x

Attempt failure.

Working on Mathlib/Probability/Distributions/Gaussian.lean - 2024-09-09 02:01:03.828063.
---157/200---
For theorem ProbabilityTheory.integrable_gaussianPDFReal in Mathlib/Probability/Distributions/Gaussian.lean:
lemma integrable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    Integrable (gaussianPDFReal μ v) 


Original valid proof:
:= by
  rw [gaussianPDFReal_def]
  by_cases hv : v = 0
  · simp [hv]
  let g : ℝ → ℝ := fun x ↦ (√(2 * π * v))⁻¹ * rexp (- x ^ 2 / (2 * v))
  have hg : Integrable g := by
    suffices g = fun x ↦ (√(2 * π * v))⁻¹ * rexp (- (2 * v)⁻¹ * x ^ 2) by
      rw [this]
      refine (integrable_exp_neg_mul_sq ?_).const_mul (√(2 * π * v))⁻¹
      simp [lt_of_le_of_ne (zero_le _) (Ne.symm hv)]
    ext x
    simp only [g, zero_lt_two, mul_nonneg_iff_of_pos_left, NNReal.zero_le_coe, Real.sqrt_mul',
      mul_inv_rev, NNReal.coe_mul, NNReal.coe_inv, NNReal.coe_ofNat, neg_mul, mul_eq_mul_left_iff,
      Real.exp_eq_exp, mul_eq_zero, inv_eq_zero, Real.sqrt_eq_zero, NNReal.coe_eq_zero, hv,
      false_or]
    rw [mul_comm]
    left
    field_simp
  exact Integrable.comp_sub_right hg μ


Verifying proof (Commit 1c91c2706a3ccd891c3dcb859d92f31890fa3090):
ℝ := by
  refine' (integrable_exp_neg_mul_sq (v * √2) _).mono'
    (integrable_mul_exp_neg_mul_sq_iff.mpr (Or.inr (by norm_num : (0 : ℝ) < 2))) _
  refine' (eventually_of_forall fun x ↦ _).mono fun x hx ↦ by gcongr; exact Real.sqrt_nonneg _
  rw [mul_comm, ← mul_assoc, mul_le_mul_left (lt_of_le_of_lt (zero_le _) (NNReal.coe_pos v))]
  rw [← NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_ofNat, ← Real.le_sqrt (abs_nonneg _) hx]
  exact abs_le_sqrt (sq_nonneg _)

Repaired Proof:
lemma integrable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    Integrable (gaussianPDFReal μ v) ℝ := by
  refine (integrable_exp_neg_mul_sq (v * √2) ?_).mono'
    (integrable_mul_exp_neg_mul_sq_iff.mpr (Or.inr (by norm_num : (0 : ℝ) < 2))) ?_
  · refine (eventually_of_forall fun x ↦ ?_).mono fun x hx ↦ by gcongr; exact Real.sqrt_nonneg _
    rw [mul_comm, ← mul_assoc, mul_le_mul_left (lt_of_le_of_lt (zero_le _) (NNReal.coe_pos v))]
    rw [← NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_ofNat, ← Real.le_sqrt (abs_nonneg _) hx]
    exact abs_le_sqrt (sq_nonneg _)
  filter_upwards with x
  simp_rw [gaussianPDFReal]
  positivity

Repaired Proof:
lemma integrable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    Integrable (gaussianPDFReal μ v) ℝ := by
  refine (integrable_exp_neg_mul_sq (v * √2) ?_).mono'
    (integrable_mul_exp_neg_mul_sq_iff.mpr (Or.inr (by norm_num : (0 : ℝ) < 2))) ?_
  · refine (eventually_of_forall fun x ↦ ?_).mono fun x hx ↦ by gcongr; exact Real.sqrt_nonneg _
    rw [mul_comm, ← mul_assoc, mul_le_mul_left (lt_of_le_of_lt (zero_le _) (NNReal.coe_pos v))]
    rw [← NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_ofNat, ← Real.le_sqrt (abs_nonneg _) hx]
    exact abs_le_sqrt (sq_nonneg _)
  filter_upwards with x
  simp_rw [gaussianPDFReal]
  positivity

Repaired Proof:
lemma integrable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    Integrable (gaussianPDFReal μ v) ℝ := by
  refine (integrable_exp_neg_mul_sq (v * √2) ?_).mono'
    (integrable_mul_exp_neg_mul_sq_iff.mpr (Or.inr (by norm_num : (0 : ℝ) < 2))) ?_
  · refine (eventually_of_forall fun x ↦ ?_).mono fun x hx ↦ by gcongr; exact Real.sqrt_nonneg _
    rw [mul_comm, ← mul_assoc, mul_le_mul_left (lt_of_le_of_lt (zero_le _) (NNReal.coe_pos v))]
    rw [← NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_ofNat, ← Real.le_sqrt (abs_nonneg _) hx]
    exact abs_le_sqrt (sq_nonneg _)
  filter_upwards with x
  simp_rw [gaussianPDFReal]
  positivity

Repaired Proof:
lemma integrable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    Integrable (gaussianPDFReal μ v) ℝ := by
  refine (integrable_exp_neg_mul_sq (v * √2) ?_).mono'
    (integrable_mul_exp_neg_mul_sq_iff.mpr (Or.inr (by norm_num : (0 : ℝ) < 2))) ?_
  · refine (eventually_of_forall fun x ↦ ?_).mono fun x hx ↦ by gcongr; exact Real.sqrt_nonneg _
    rw [mul_comm, ← mul_assoc, mul_le_mul_left (lt_of_le_of_lt (zero_le _) (NNReal.coe_pos v))]
    rw [← NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_ofNat, ← Real.le_sqrt (abs_nonneg _) hx]
    exact abs_le_sqrt (sq_nonneg _)
  filter_upwards with x
  simp_rw [gaussianPDFReal]
  positivity

Repaired Proof:
lemma integrable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    Integrable (gaussianPDFReal μ v) ℝ := by
  refine (integrable_exp_neg_mul_sq (v * √2) ?_).mono'
    (integrable_mul_exp_neg_mul_sq_iff.mpr (Or.inr (by norm_num : (0 : ℝ) < 2))) ?_
  · refine (eventually_of_forall fun x ↦ ?_).mono fun x hx ↦ by gcongr; exact Real.sqrt_nonneg _
    rw [mul_comm, ← mul_assoc, mul_le_mul_left (lt_of_le_of_lt (zero_le _) (NNReal.coe_pos v))]
    rw [← NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_ofNat, ← Real.le_sqrt (abs_nonneg _) hx]
    exact abs_le_sqrt (sq_nonneg _)
  filter_upwards with x
  simp_rw [gaussianPDFReal]
  positivity

Repaired Proof:
lemma integrable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    Integrable (gaussianPDFReal μ v) ℝ := by
  refine (integrable_exp_neg_mul_sq (v * √2) ?_).mono'
    (integrable_mul_exp_neg_mul_sq_iff.mpr (Or.inr (by norm_num : (0 : ℝ) < 2))) ?_
  · refine (eventually_of_forall fun x ↦ ?_).mono fun x hx ↦ by gcongr; exact Real.sqrt_nonneg _
    rw [mul_comm, ← mul_assoc, mul_le_mul_left (lt_of_le_of_lt (zero_le _) (NNReal.coe_pos v))]
    rw [← NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_ofNat, ← Real.le_sqrt (abs_nonneg _) hx]
    exact abs_le_sqrt (sq_nonneg _)
  filter_upwards with x
  simp_rw [gaussianPDFReal]
  positivity

Repaired Proof:
lemma integrable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    Integrable (gaussianPDFReal μ v) ℝ := by
  refine (integrable_exp_neg_mul_sq (v * √2) ?_).mono'
    (integrable_mul_exp_neg_mul_sq_iff.mpr (Or.inr (by norm_num : (0 : ℝ) < 2))) ?_
  · refine (eventually_of_forall fun x ↦ ?_).mono fun x hx ↦ by gcongr; exact Real.sqrt_nonneg _
    rw [mul_comm, ← mul_assoc, mul_le_mul_left (lt_of_le_of_lt (zero_le _) (NNReal.coe_pos v))]
    rw [← NNReal.coe_le_coe, NNReal.coe_mul, NNReal.coe_ofNat, ← Real.le_sqrt (abs_nonneg _) hx]
    exact abs_le_sqrt (

Attempt failure.

Working on Mathlib/Probability/Kernel/Disintegration/CdfToKernel.lean - 2024-09-09 02:01:21.915552.
---158/200---
For theorem ProbabilityTheory.IsRatCondKernelCDFAux.isRatCondKernelCDF in Mathlib/Probability/Kernel/Disintegration/CdfToKernel.lean:
lemma IsRatCondKernelCDFAux.isRatCondKernelCDF (hf : IsRatCondKernelCDFAux f κ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] :
    IsRatCondKernelCDF f κ ν where



Original valid proof:
  measurable := hf.measurable
  isRatStieltjesPoint_ae := hf.isRatStieltjesPoint_ae
  integrable := hf.integrable
  setIntegral := hf.setIntegral


Verifying proof (Commit a71231735e55fa1fc4000a42658641f766fde88b):
  isRatStieltjesPoint_ae := hf.isRatStieltjesPoint_ae
  isRatCondKernelCDF_of_isRatStieltjesPoint hf_int := by
    refine' ⟨fun a b r ↦ _, fun a b r ↦ _⟩
    · have h_eq : ∀ b, ∫⁻ a, f a b r ∂(κ + ν) = ∫⁻ a, f a b r ∂κ + ∫⁻ a, f a b r ∂ν :=
        fun b ↦ lintegral_add_left' (hf.integrable_isRatStieltjesPoint hf_int b)
      rw [h_eq, hf.isRatCondKernelCDF_of_isRatStieltjesPoint hf_int]
      simp
    · have h_eq : ∀ b, ∫⁻ a, f a b r ∂(κ + ν) = ∫⁻ a, f a b r ∂κ + ∫⁻ a, f a b r ∂ν :=
        fun b ↦ lintegral_add_left' (hf.integrable_isRatStieltjesPoint hf_int b)
      rw [h_eq, hf.isRatCondKernelCDF_of_isRatStieltjesPoint hf_int]
      simp

Repaired Proof:
lemma IsRatCondKernelCDFAux.isRatCondKernelCDF (hf : IsRatCondKernelCDFAux f κ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] :
    IsRatCondKernelCDF f κ ν where
  isRatStieltjesPoint_ae := hf.isRatStieltjesPoint_ae
  isRatCondKernelCDF_of_isRatStieltjesPoint hf_int := by
    refine ⟨fun a b r ↦ ?_, fun a b r ↦ ?_⟩
    · have h_eq : ∀ b, ∫⁻ a, f a b r ∂(κ + ν) = ∫⁻ a, f a b r ∂κ + ∫⁻ a, f a b r ∂ν :=
        fun b ↦ lintegral_add_left' (hf.integrable_isRatStieltjesPoint hf_int b)
      rw [h_eq, hf.isRatCondKernelCDF_of_isRatStieltjesPoint hf_int]
      simp
    · have h_eq : ∀ b, ∫⁻ a, f a b r ∂(κ + ν) = ∫⁻ a, f a b r ∂κ + ∫⁻ a, f a b r ∂ν :=
        fun b ↦ lintegral_add_left' (hf.integrable_isRatStieltjesPoint hf_int b)
      rw [h_eq, hf.isRatCondKernelCDF_of_isRatStieltjesPoint hf_int]
      simp

Repaired Proof:
lemma IsRatCondKernelCDFAux.isRatCondKernelCDF (hf : IsRatCondKernelCDFAux f κ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] :
    IsRatCondKernelCDF f κ ν where
  isRatStieltjesPoint_ae := hf.isRatStieltjesPoint_ae
  isRatCondKernelCDF_of_isRatStieltjesPoint hf_int := by
    refine ⟨fun a b r ↦ ?_, fun a b r ↦ ?_⟩
    · have h_eq : ∀ b, ∫⁻ a, f a b r ∂(κ + ν) = ∫⁻ a, f a b r ∂κ + ∫⁻ a, f a b r ∂ν :=
        fun b ↦ lintegral_add_left' (hf.integrable_isRatStieltjesPoint hf_int b)
      rw [h_eq, hf.isRatCondKernelCDF_of_isRatStieltjesPoint hf_int]
      simp
    · have h_eq : ∀ b, ∫⁻ a, f a b r ∂(κ + ν) = ∫⁻ a, f a b r ∂κ + ∫⁻ a, f a b r ∂ν :=
        fun b ↦ lintegral_add_left' (hf.integrable_isRatStieltjesPoint hf_int b)
      rw [h_eq, hf.isRatCondKernelCDF_of_isRatStieltjesPoint hf_int]
      simp

Repaired Proof:
lemma IsRatCondKernelCDFAux.isRatCondKernelCDF (hf : IsRatCondKernelCDFAux f κ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] :
    IsRatCondKernelCDF f κ ν where
  isRatStieltjesPoint_ae := hf.isRatStieltjesPoint_ae
  isRatCondKernelCDF_of_isRatStieltjesPoint hf_int := by
    refine ⟨fun a b r ↦ ?_, fun a b r ↦ ?_⟩
    · have h_eq : ∀ b, ∫⁻ a, f a b r ∂(κ + ν) = ∫⁻ a, f a b r ∂κ + ∫⁻ a, f a b r ∂ν :=
        fun b ↦ lintegral_add_left' (hf.integrable_isRatStieltjesPoint hf_int b)
      rw [h_eq, hf.isRatCondKernelCDF_of_isRatStieltjesPoint hf_int]
      simp
    · have h_eq : ∀ b, ∫⁻ a, f a b r ∂(κ + ν) = ∫⁻ a, f a b r ∂κ + ∫⁻ a, f a b r ∂ν :=
        fun b ↦ lintegral_add_left' (hf.integrable_isRatStieltjesPoint hf_int b)
      rw [h_eq, hf.isRatCondKernelCDF_of_isRatStieltjesPoint hf_int]
      simp

Repaired Proof:
lemma IsRatCondKernelCDFAux.isRatCondKernelCDF (hf : IsRatCondKernelCDFAux f κ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] :
    IsRatCondKernelCDF f κ ν where
  isRatStieltjesPoint_ae := hf.isRatStieltjesPoint_ae
  isRatCondKernelCDF_of_isRatStieltjesPoint hf_int := by
    refine ⟨fun a b r ↦ ?_, fun a b r ↦ ?_⟩
    · have h_eq : ∀ b, ∫⁻ a, f a b r ∂(κ + ν) = ∫⁻ a, f a b r ∂κ + ∫⁻ a, f a b r ∂ν :=
        fun b ↦ lintegral_add_left' (hf.integrable_isRatStieltjesPoint hf_int b)
      rw [h_eq, hf.isRatCondKernelCDF_of_isRatStieltjesPoint hf_int]
      simp
    · have h_eq : ∀ b, ∫⁻ a, f a b r ∂(κ + ν) = ∫⁻ a, f a b r ∂κ + ∫⁻ a, f a b r ∂ν :=
        fun b ↦ lintegral_add_left' (hf.integrable_isRatStieltjesPoint hf_int b)
      rw [h_eq, hf.isRatCondKernelCDF_of_isRatStieltjesPoint hf_int]
      simp

Repaired Proof:
lemma IsRatCondKernelCDFAux.isRatCondKernelCDF (hf : IsRatCondKernelCDFAux f κ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] :
    IsRatCondKernelCDF f κ ν where
  isRatStieltjesPoint_ae := hf.isRatStieltjesPoint_ae
  isRatCondKernelCDF_of_isRatStieltjesPoint hf_int := by
    refine ⟨fun a b r ↦ ?_, fun a b r ↦ ?_⟩
    · have h_eq : ∀ b, ∫⁻ a, f a b r ∂(κ + ν) = ∫⁻ a, f a b r ∂κ + ∫⁻ a, f a b r ∂ν :=
        fun b ↦ lintegral_add_left' (hf.integrable_isRatStiel

Attempt failure.

Working on Mathlib/Probability/Kernel/RadonNikodym.lean - 2024-09-09 02:01:33.737697.
---159/200---
For theorem ProbabilityTheory.kernel.measurableSet_mutuallySingularSet in Mathlib/Probability/Kernel/RadonNikodym.lean:
lemma measurableSet_mutuallySingularSet (κ η : kernel α γ) :
    MeasurableSet (mutuallySingularSet κ η) 


Original valid proof:
:=
  measurable_rnDerivAux κ (κ + η) measurableSet_Ici


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
      κ (mutuallySingularSet κ η) = 0 ∧ η (mutuallySingularSet κ η)ᶜ = 0 := by
  have h_eq_inter : mutuallySingularSet κ η =
      (mutuallySingularSet κ η) ∩ (mutuallySingularSet κ η)ᶜ := by
    ext x
    simp only [Set.mem_inter_iff, Set.mem_compl_iff, Set.mem_singleton_iff, and_self_iff,
      mem_mutuallySingularSet, Set.mem_setOf_eq, and_iff_left_iff_imp]
    exact fun _ ↦ (measure_ne_top _ _).elim
  rw [h_eq_inter]
  refine ⟨MeasurableSet.inter ?_ ?_, ?_, ?_⟩
  · exact measurableSet_mutuallySingularSet_of_isFiniteKernel κ η
  · exact measurableSet_mutuallySingularSet_of_isFiniteKernel η κ
  · ext x
    simp only [measure_zero_iff_ae_nmem, mem_mutuallySingularSet, Set.mem_setOf_eq,
      and_imp, Set.mem_compl_iff, not_not_mem]
    exact ⟨fun h ↦ ⟨h, h.symm⟩, fun h ↦ h.1⟩
  · ext x
    simp only [measure_zero_iff_ae_nmem, mem_mutuallySingularSet, Set.mem_setOf_eq,
      and_imp, Set.mem_compl_iff, not_not_mem]
    exact ⟨fun h ↦ ⟨h.2, h.2.symm⟩, fun h ↦ h.2⟩

Repaired Proof:
lemma measurableSet_mutuallySingularSet (κ η : kernel α γ) :
    MeasurableSet (mutuallySingularSet κ η) ∧
      κ (mutuallySingularSet κ η) = 0 ∧ η (mutuallySingularSet κ η)ᶜ = 0 := by
  have h_eq_inter : mutuallySingularSet κ η =
      (mutuallySingularSet κ η) ∩ (mutuallySingularSet κ η)ᶜ := by
    ext x
    simp only [Set.mem_inter_iff, Set.mem_compl_iff, Set.mem_singleton_iff, and_self_iff,
      mem_mutuallySingularSet, Set.mem_setOf_eq, and_iff_left_iff_imp]
    exact fun _ ↦ (measure_ne_top _ _).ne
  rw [h_eq_inter]
  refine ⟨MeasurableSet.inter ?_ ?_, ?_, ?_⟩
  · exact measurableSet_mutuallySingularSet_of_isFiniteKernel κ η
  · exact measurableSet_mutuallySingularSet_of_isFiniteKernel η κ
  · ext x
    simp only [measure_zero_iff_ae_nmem, mem_mutuallySingularSet, Set.mem_setOf_eq,
      and_imp, Set.mem_compl_iff, not_not_mem]
    exact ⟨fun h ↦ ⟨h, h.symm⟩, fun h ↦ h.1⟩
  · ext x
    simp only [measure_zero_iff_ae_nmem, mem_mutuallySingularSet, Set.mem_setOf_eq,
      and_imp, Set.mem_compl_iff, not_not_mem]
    exact ⟨fun h ↦ ⟨h.2, h.2.symm⟩, fun h ↦ h.2⟩

Repaired Proof:
lemma measurableSet_mutuallySingularSet (κ η : kernel α γ) :
    MeasurableSet (mutuallySingularSet κ η) ∧
      κ (mutuallySingularSet κ η) = 0 ∧ η (mutuallySingularSet κ η)ᶜ = 0 := by
  have h_eq_inter : mutuallySingularSet κ η =
      (mutuallySingularSet κ η) ∩ (mutuallySingularSet κ η)ᶜ := by
    ext x
    simp only [Set.mem_inter_iff, Set.mem_compl_iff, Set.mem_singleton_iff, and_self_iff,
      mem_mutuallySingularSet, Set.mem_setOf_eq, and_iff_left_iff_imp]
    exact fun _ ↦ (measure_ne_top _ _).ne
  rw [h_eq_inter]
  refine ⟨MeasurableSet.inter ?_ ?_, ?_, ?_⟩
  · exact measurableSet_mutuallySingularSet_of_isFiniteKernel κ η
  · exact measurableSet_mutuallySingularSet_of_isFiniteKernel η κ
  · ext x
    simp only [measure_zero_iff_ae_nmem, mem_mutuallySingularSet, Set.mem_setOf_eq,
      and_imp, Set.mem_compl_iff, not_not_mem]
    exact ⟨fun h ↦ ⟨h, h.symm⟩, fun h ↦ h.1⟩
  · ext x
    simp only [measure_zero_iff_ae_nmem, mem_mutuallySingularSet, Set.mem_setOf_eq,
      and_imp, Set.mem_compl_iff, not_not_mem]
    exact ⟨fun h ↦ ⟨h.2, h.2.symm⟩, fun h ↦ h.2⟩

Attempt failure.

Working on Mathlib/Probability/Kernel/WithDensity.lean - 2024-09-09 02:01:46.760129.
---160/200---
For theorem ProbabilityTheory.kernel.isSFiniteKernel_withDensity_of_isFiniteKernel in Mathlib/Probability/Kernel/WithDensity.lean:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) 


Original valid proof:
:= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; · rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : ℕ → α → β → ℝ≥0∞ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : ∀ a b n, ⌈(f a b).toReal⌉₊ ≤ n → f a b ≤ n := by
    intro a b n hn
    have : (f a b).toReal ≤ n := Nat.le_of_ceil_le hn
    rw [← ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    · refine this.trans (le_of_eq ?_)
      rw [ENNReal.ofReal_natCast]
    · norm_cast
      exact zero_le _
  have h_zero : ∀ a b n, ⌈(f a b).toReal⌉₊ ≤ n → fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b ∧ min (f a b) n = f a b by
      simp_rw [fs, this.1, this.2, tsub_self (f a b)]
    exact ⟨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)⟩
  have hf_eq_tsum : f = ∑' n, fs n := by
    have h_sum_a : ∀ a, Summable fun n => fs n a := by
      refine fun a => Pi.summable.mpr fun b => ?_
      suffices ∀ n, n ∉ Finset.range ⌈(f a b).toReal⌉₊ → fs n a b = 0 from
        summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : ∀ n, ∑ i ∈ Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      · simp
      rw [Finset.sum_range_succ, hn]
      simp [fs]
    simp_rw [h_finset_sum]
    refine (Filter.Tendsto.liminf_eq ?_).symm
    refine Filter.Tendsto.congr' ?_ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact ⟨⌈(f a b).toReal⌉₊, fun n hn => (min_eq_left (h_le a b n hn)).symm⟩
  rw [hf_eq_tsum, withDensity_tsum _ fun n : ℕ => _]
  swap; · exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine isSFiniteKernel_sum fun n => ?_
  suffices IsFiniteKernel (withDensity κ (fs n)) by haveI := this; infer_instance
  refine isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : ↑n + 1 ≠ ∞) fun a b => ?_
  beta_reduce
  norm_cast
  calc
    fs n a b ≤ min (f a b) (n + 1) := tsub_le_self
    _ ≤ n + 1 := min_le_right _ _
    _ = ↑(n + 1) := by norm_cast


Verifying proof (Commit 21b59396b0bc5f6e4bc4ba0438eb57a292105701):
↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) ↔ IsSFiniteKernel κ := by
  constructor <;> intro h
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss'.trans h_ss
    rw [withDensity_withDensity_one]
  · have h_ss : IsSFiniteKernel (withDensity κ fun a b => 1) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one κ
    have h_ss' : IsSFiniteKernel (withDensity (withDensity κ fun a b => 1) fun a b => f a b) :=
      isSFiniteKernel_withDensity_of_isFiniteKernel_one (withDensity κ fun a b => 1)
        fun a b => hf_ne_top a b
    convert h_ss.trans h_ss'
    rw [withDensity_withDensity_one]

Repaired Proof:
theorem isS

Attempt failure.

Working on Mathlib/Probability/Martingale/BorelCantelli.lean - 2024-09-09 02:01:56.713622.
---161/200---
For theorem MeasureTheory.Submartingale.exists_tendsto_of_abs_bddAbove_aux in Mathlib/Probability/Martingale/BorelCantelli.lean:
theorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure μ]
    (hf : Submartingale f ℱ μ) (hf0 : f 0 = 0) (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :
    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) → ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) 


Original valid proof:
:= by
  have ht :
    ∀ᵐ ω ∂μ, ∀ i : ℕ, ∃ c, Tendsto (fun n => stoppedValue f (leastGE f i n) ω) atTop (𝓝 c) := by
    rw [ae_all_iff]
    exact fun i => Submartingale.exists_ae_tendsto_of_bdd (hf.stoppedValue_leastGE i)
      (hf.stoppedValue_leastGE_snorm_le' i.cast_nonneg hf0 hbdd)
  filter_upwards [ht] with ω hω hωb
  rw [BddAbove] at hωb
  obtain ⟨i, hi⟩ := exists_nat_gt hωb.some
  have hib : ∀ n, f n ω < i := by
    intro n
    exact lt_of_le_of_lt ((mem_upperBounds.1 hωb.some_mem) _ ⟨n, rfl⟩) hi
  have heq : ∀ n, stoppedValue f (leastGE f i n) ω = f n ω := by
    intro n
    rw [leastGE]; unfold hitting; rw [stoppedValue]
    rw [if_neg]
    simp only [Set.mem_Icc, Set.mem_union, Set.mem_Ici]
    push_neg
    exact fun j _ => hib j
  simp only [← heq, hω i]


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∨
      Tendsto (fun n => f n ω) atTop atTop ∨ Tendsto (fun n => f n ω) atTop atBot := by
  filter_upwards [hf.bddAbove_range_iff.mp <| bddAbove_range_of_abs_bddAbove_aux hf hf0 hbdd]
  intro ω hω hωbdd
  rcases hω hωbdd with (⟨c, hc⟩ | hω_top)
  · exact ⟨c, Or.inl hc⟩
  · exact ⟨f 0 ω, Or.inr <| Or.inl <| hω_top.mono fun n hn => hn.trans <|
      hf.mono (zero_le _) _ hn⟩

Repaired Proof:
theorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure μ]
    (hf : Submartingale f ℱ μ) (hf0 : f 0 = 0) (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :
    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) → ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) ∨
      Tendsto (fun n => f n ω) atTop atTop ∨ Tendsto (fun n => f n ω) atTop atBot := by
  filter_upwards [hf.bddAbove_range_iff.mp <| bddAbove_range_of_abs_bddAbove_aux hf hf0 hbdd]
  intro ω hω hωbdd
  rcases hω hωbdd with (⟨c, hc⟩ | hω_top)
  · exact ⟨c, Or.inl hc⟩
  · exact ⟨f 0 ω, Or.inr <| Or.inl <| hω_top.mono fun n hn => hn.trans <|
      hf.mono (zero_le _) _ hn⟩

Repaired Proof:
theorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure μ]
    (hf : Submartingale f ℱ μ) (hf0 : f 0 = 0) (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :
    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) → ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) ∨
      Tendsto (fun n => f n ω) atTop atTop ∨ Tendsto (fun n => f n ω) atTop atBot := by
  filter_upwards [hf.bddAbove_range_iff.mp <| bddAbove_range_of_abs_bddAbove_aux hf hf0 hbdd]
  intro ω hω hωbdd
  rcases hω hωbdd with (⟨c, hc⟩ | hω_top)
  · exact ⟨c, Or.inl hc⟩
  · exact ⟨f 0 ω, Or.inr <| Or.inl <| hω_top.mono fun n hn => hn.trans <|
      hf.mono (zero_le _) _ hn⟩

Repaired Proof:
theorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure μ]
    (hf : Submartingale f ℱ μ) (hf0 : f 0 = 0) (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :
    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) → ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) ∨
      Tendsto (fun n => f n ω) atTop atTop ∨ Tendsto (fun n => f n ω) atTop atBot := by
  filter_upwards [hf.bddAbove_range_iff.mp <| bddAbove_range_of_abs_bddAbove_aux hf hf0 hbdd]
  intro ω hω hωbdd
  rcases hω hωbdd with (⟨c, hc⟩ | hω_top)
  · exact ⟨c, Or.inl hc⟩
  · exact ⟨f 0 ω, Or.inr <| Or.inl <| hω_top.mono fun n hn => hn.trans <|
      hf.mono (zero_le _) _ hn⟩

Repaired Proof:
theorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure μ]
    (hf : Submartingale f ℱ μ) (hf0 : f 0 = 0) (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :
    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) → ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) ∨
      Tendsto (fun n => f n ω) atTop atTop ∨ Tendsto (fun n => f n ω) atTop atBot := by
  filter_upwards [hf.bddAbove_range_iff.mp <| bddAbove_range_of_abs_bddAbove_aux hf hf0 hbdd]
  intro ω hω hωbdd
  rcases hω hωbdd with (⟨c, hc⟩ | hω_top)
  · exact ⟨c, Or.inl hc⟩
  · exact ⟨f 0 ω, Or.inr <| Or.inl <| hω_top.mono fun n hn => hn.trans <|
      hf.mono (zero_le _) _ hn⟩

Repaired Proof:
theorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure μ]
    (hf : Submartingale f ℱ μ) (hf0 : f 0 = 0) (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :
    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) → ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) ∨
      Tendsto (fun n => f n ω) atTop atTop ∨ Tendsto (fun n => f n ω) atTop atBot := by
  filter_upwards [hf.bddAbove_range_iff.mp <| bddAbove_range_of_abs_bddAbove_aux hf hf0 hbdd]
  intro ω hω hωbdd
  rcases hω hωbdd with (⟨c, hc⟩ | hω_top)
  · exact ⟨c, Or.inl hc⟩
  · exact ⟨f 0 ω, Or.inr <| Or.inl <| hω_top.mono fun n hn => hn.trans <|
      hf.mono (zero_le _) _ hn⟩

Repaired Proof:
theorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure μ]
    (hf : Submartingale f ℱ μ) (hf0 : f 0 = 0) (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :
    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) → ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) ∨
      Tendsto (fun n => f n ω) atTop atTop ∨ Tendsto

Attempt failure.

Working on Mathlib/Probability/Variance.lean - 2024-09-09 02:02:07.020478.
---162/200---
For theorem ProbabilityTheory.evariance_eq_zero_iff in Mathlib/Probability/Variance.lean:
theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] 


Original valid proof:
:= by
  rw [evariance, lintegral_eq_zero_iff']
  constructor <;> intro hX <;> filter_upwards [hX] with ω hω
  · simpa only [Pi.zero_apply, sq_eq_zero_iff, ENNReal.coe_eq_zero, nnnorm_eq_zero, sub_eq_zero]
      using hω
  · rw [hω]
    simp
  · exact (hX.sub_const _).ennnorm.pow_const _ 


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
1 := by
  rw [evariance, evarianceAux_eq_zero_iff hX, evariance_def, lintegral_congr_ae
    (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    lintegral_congr_ae (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same]

Repaired Proof:
theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] 1 := by
  rw [evariance, evarianceAux_eq_zero_iff hX, evariance_def, lintegral_congr_ae
    (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    lintegral_congr_ae (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same]

Repaired Proof:
theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] 1 := by
  rw [evariance, evarianceAux_eq_zero_iff hX, evariance_def, lintegral_congr_ae
    (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    lintegral_congr_ae (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same]

Repaired Proof:
theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] 1 := by
  rw [evariance, evarianceAux_eq_zero_iff hX, evariance_def, lintegral_congr_ae
    (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    lintegral_congr_ae (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same]

Repaired Proof:
theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] 1 := by
  rw [evariance, evarianceAux_eq_zero_iff hX, evariance_def, lintegral_congr_ae
    (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    lintegral_congr_ae (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same]

Repaired Proof:
theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] 1 := by
  rw [evariance, evarianceAux_eq_zero_iff hX, evariance_def, lintegral_congr_ae
    (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    lintegral_congr_ae (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same]

Repaired Proof:
theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] 1 := by
  rw [evariance, evarianceAux_eq_zero_iff hX, evariance_def, lintegral_congr_ae
    (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    lintegral_congr_ae (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same]

Repaired Proof:
theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] 1 := by
  rw [evariance, evarianceAux_eq_zero_iff hX, evariance_def, lintegral_congr_ae
    (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    lintegral_congr_ae (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same]

Repaired Proof:
theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] 1 := by
  rw [evariance, evarianceAux_eq_zero_iff hX, evariance_def, lintegral_congr_ae
    (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    lintegral_congr_ae (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same]

Repaired Proof:
theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] 1 := by
  rw [evariance, evarianceAux_eq_zero_iff hX, evariance_def, lintegral_congr_ae
    (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    lintegral_congr_ae (ae_of_all _ fun x => (Pi.single (fun _ => (1 : ℝ≥0∞)) 1 x).coe_fn_injective.eq_iff),
    Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same, Pi.single_eq_same]

Repaired Proof:
theorem evariance_eq_zero_iff (h

Attempt failure.

Working on Mathlib/RingTheory/AdicCompletion/Functoriality.lean - 2024-09-09 02:02:18.770174.
---163/200---
For theorem AdicCompletion.sumInv_comp_sum in Mathlib/RingTheory/AdicCompletion/Functoriality.lean:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id 


Original valid proof:
:= by
  ext j x
  apply DirectSum.ext (AdicCompletion I R) (fun i ↦ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, map_mk, component_sumInv,
    mk_apply_coe, AdicCauchySequence.map_apply_coe, Submodule.mkQ_apply, LinearMap.id_comp]
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  · next h => subst h; simp
  · simp


Verifying proof (Commit 477166fbcab40069a4fbe62e393a3d09efdb938f):
∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_smul, sum_single_index,
    Finsupp.sum_zero_index, smul_eq_mul, mul_zero, add_zero]

Repaired Proof:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id ∘ₗ sumInv I M := by
  ext i
  simp only [sumInv, sum, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,
    LinearMap.id_coe, id_eq, sum_tmul, sumInv_tmul, one_

Attempt failure.

Working on Mathlib/RingTheory/Artinian.lean - 2024-09-09 02:02:49.071450.
---164/200---
For theorem LinearMap.eventually_codisjoint_ker_pow_range_pow in Mathlib/RingTheory/Artinian.lean:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) 


Original valid proof:
:= by
  obtain ⟨n, hn : ∀ m, n ≤ m → LinearMap.range (f ^ n) = LinearMap.range (f ^ m)⟩ :=
    monotone_stabilizes f.iterateRange
  refine eventually_atTop.mpr ⟨n, fun m hm ↦ codisjoint_iff.mpr ?_⟩
  simp_rw [← hn _ hm, Submodule.eq_top_iff', Submodule.mem_sup]
  intro x
  rsuffices ⟨y, hy⟩ : ∃ y, (f ^ m) ((f ^ n) y) = (f ^ m) x
  · exact ⟨x - (f ^ n) y, by simp [hy], (f ^ n) y, by simp⟩
  simp_rw [f.pow_apply n, f.pow_apply m, ← iterate_add_apply, ← f.pow_apply (m + n),
    ← f.pow_apply m, ← mem_range (f := _), ← hn _ (n.le_add_left m), hn _ hm]
  exact LinearMap.mem_range_self (f ^ m) x


Verifying proof (Commit 43b4712c74901b669d8c212f8523d4863290c5b0):
∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ
  rw [eventually_atTop]
  refine ⟨n, fun m hm ↦ ⟨?_, f.is_artinian.range_pow_stabilizes hm⟩⟩
  rw [← hn]
  exact (f ^ n).codisjoint_ker_range

Repaired Proof:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ
  rw [eventually_atTop]
  refine ⟨n, fun m hm ↦ ⟨?_, f.isArtinian.range_pow_stabilizes hm⟩⟩
  rw [← hn]
  exact (f ^ n).codisjoint_ker_range

Repaired Proof:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ
  rw [eventually_atTop]
  refine ⟨n, fun m hm ↦ ⟨?_, f.isArtinian.range_pow_stabilizes hm⟩⟩
  rw [← hn]
  exact (f ^ n).codisjoint_ker_range

Repaired Proof:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ
  rw [eventually_atTop]
  refine ⟨n, fun m hm ↦ ⟨?_, f.isArtinian.range_pow_stabilizes hm⟩⟩
  rw [← hn]
  exact (f ^ n).codisjoint_ker_range

Repaired Proof:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ
  rw [eventually_atTop]
  refine ⟨n, fun m hm ↦ ⟨?_, f.isArtinian.range_pow_stabilizes hm⟩⟩
  rw [← hn]
  exact (f ^ n).codisjoint_ker_range

Repaired Proof:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ
  rw [eventually_atTop]
  refine ⟨n, fun m hm ↦ ⟨?_, f.isArtinian.range_pow_stabilizes hm⟩⟩
  rw [← hn]
  exact (f ^ n).codisjoint_ker_range

Repaired Proof:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ
  rw [eventually_atTop]
  refine ⟨n, fun m hm ↦ ⟨?_, f.isArtinian.range_pow_stabilizes hm⟩⟩
  rw [← hn]
  exact (f ^ n).codisjoint_ker_range

Repaired Proof:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ
  rw [eventually_atTop]
  refine ⟨n, fun m hm ↦ ⟨?_, f.isArtinian.range_pow_stabilizes hm⟩⟩
  rw [← hn]
  exact (f ^ n).codisjoint_ker_range

Repaired Proof:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ
  rw [eventually_atTop]
  refine ⟨n, fun m hm ↦ ⟨?_, f.isArtinian.range_pow_stabilizes hm⟩⟩
  rw [← hn]
  exact (f ^ n).codisjoint_ker_range

Repaired Proof:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ
  rw [eventually_atTop]
  refine ⟨n, fun m hm ↦ ⟨?_, f.isArtinian.range_pow_stabilizes hm⟩⟩
  rw [← hn]
  exact (f ^ n).codisjoint_ker_range

Repaired Proof:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ
  rw [eventually_atTop]
  refine ⟨n, fun m hm ↦ ⟨?_, f.isArtinian.range_pow_stabilizes hm⟩⟩
  rw [← hn]
  exact (f ^ n).codisjoint_ker_range

Repaired Proof:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ∧
      (LinearMap.range (f ^ n)).FG := by
  obtain ⟨n, hn⟩ := f.exists_ker_pow_eq_ker_pow_succ


Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Dvr.lean - 2024-09-09 02:03:01.516284.
---165/200---
For theorem IsDedekindDomain.isDedekindDomainDvr in Mathlib/RingTheory/DedekindDomain/Dvr.lean:
theorem IsDedekindDomain.isDedekindDomainDvr [IsDedekindDomain A] : IsDedekindDomainDvr A 


Original valid proof:
:=
  { isNoetherianRing := IsDedekindRing.toIsNoetherian
    is_dvr_at_nonzero_prime := fun _ hP _ =>
      IsLocalization.AtPrime.discreteValuationRing_of_dedekind_domain A hP _ }


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
↔
    (⊥ : HeightOneSpectrum A).IsMaximal := by
  refine' ⟨fun _ => _, fun _ => inferInstance⟩
  haveI : IsDedekindDomain (Localization.AtPrime (⊥ : Ideal A)) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  haveI : IsDedekindDomain (Localization (⊥ : Ideal A).primeCompl) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  have : IsLocalization.AtPrime (⊥ : Ideal A) (Localization.AtPrime (⊥ : Ideal A)) :=
    IsLocalization.isLocalization_of_submonoid_le _ _ le_rfl
  have : IsLocalization.AtPrime (⊥ : Ideal A).primeCompl (Localization (⊥ : Ideal A).primeCompl) :=
    IsLocalization.isLocalization_of_submonoid_le _ _ le_rfl
  have : IsFractionRing (Localization.AtPrime (⊥ : Ideal A)) (Localization (⊥ : Ideal A).primeCompl) :=
    IsFractionRing.of_isLocalization_of_isLocalization _ _ _ _
  exact
    (isDedekindDomain_iff_isDedekindDomainDvr _).mp
      (IsDedekindDomain.isDedekindDomain_of_isDedekindDomain_localization _)

Repaired Proof:
theorem IsDedekindDomain.isDedekindDomainDvr [IsDedekindDomain A] : IsDedekindDomainDvr A ↔
    (⊥ : HeightOneSpectrum A).IsMaximal := by
  refine ⟨fun _ => ?_, fun _ => inferInstance⟩
  haveI : IsDedekindDomain (Localization.AtPrime (⊥ : Ideal A)) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  haveI : IsDedekindDomain (Localization (⊥ : Ideal A).primeCompl) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  have : IsLocalization.AtPrime (⊥ : Ideal A) (Localization.AtPrime (⊥ : Ideal A)) :=
    IsLocalization.isLocalization_of_submonoid_le _ _ le_rfl
  have : IsLocalization.AtPrime (⊥ : Ideal A).primeCompl (Localization (⊥ : Ideal A).primeCompl) :=
    IsLocalization.isLocalization_of_submonoid_le _ _ le_rfl
  have : IsFractionRing (Localization.AtPrime (⊥ : Ideal A)) (Localization (⊥ : Ideal A).primeCompl) :=
    IsFractionRing.of_isLocalization_of_isLocalization _ _ _ _
  exact
    (isDedekindDomain_iff_isDedekindDomainDvr _).mp
      (IsDedekindDomain.isDedekindDomain_of_isDedekindDomain_localization _)

Repaired Proof:
theorem IsDedekindDomain.isDedekindDomainDvr [IsDedekindDomain A] : IsDedekindDomainDvr A ↔
    (⊥ : HeightOneSpectrum A).IsMaximal := by
  refine ⟨fun _ => ?_, fun _ => inferInstance⟩
  haveI : IsDedekindDomain (Localization.AtPrime (⊥ : Ideal A)) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  haveI : IsDedekindDomain (Localization (⊥ : Ideal A).primeCompl) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  have : IsLocalization.AtPrime (⊥ : Ideal A) (Localization.AtPrime (⊥ : Ideal A)) :=
    IsLocalization.isLocalization_of_submonoid_le _ _ le_rfl
  have : IsLocalization.AtPrime (⊥ : Ideal A).primeCompl (Localization (⊥ : Ideal A).primeCompl) :=
    IsLocalization.isLocalization_of_submonoid_le _ _ le_rfl
  have : IsFractionRing (Localization.AtPrime (⊥ : Ideal A)) (Localization (⊥ : Ideal A).primeCompl) :=
    IsFractionRing.of_isLocalization_of_isLocalization _ _ _ _
  exact
    (isDedekindDomain_iff_isDedekindDomainDvr _).mp
      (IsDedekindDomain.isDedekindDomain_of_isDedekindDomain_localization _)

Repaired Proof:
theorem IsDedekindDomain.isDedekindDomainDvr [IsDedekindDomain A] : IsDedekindDomainDvr A ↔
    (⊥ : HeightOneSpectrum A).IsMaximal := by
  refine ⟨fun _ => ?_, fun _ => inferInstance⟩
  haveI : IsDedekindDomain (Localization.AtPrime (⊥ : Ideal A)) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  haveI : IsDedekindDomain (Localization (⊥ : Ideal A).primeCompl) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  have : IsLocalization.AtPrime (⊥ : Ideal A) (Localization.AtPrime (⊥ : Ideal A)) :=
    IsLocalization.isLocalization_of_submonoid_le _ _ le_rfl
  have : IsLocalization.AtPrime (⊥ : Ideal A).primeCompl (Localization (⊥ : Ideal A).primeCompl) :=
    IsLocalization.isLocalization_of_submonoid_le _ _ le_rfl
  have : IsFractionRing (Localization.AtPrime (⊥ : Ideal A)) (Localization (⊥ : Ideal A).primeCompl) :=
    IsFractionRing.of_isLocalization_of_isLocalization _ _ _ _
  exact
    (isDedekindDomain_iff_isDedekindDomainDvr _).mp
      (IsDedekindDomain.isDedekindDomain_of_isDedekindDomain_localization _)

Repaired Proof:
theorem IsDedekindDomain.isDedekindDomainDvr [IsDedekindDomain A] : IsDedekindDomainDvr A ↔
    (⊥ : HeightOneSpectrum A).IsMaximal := by
  refine ⟨fun _ => ?_, fun _ => inferInstance⟩
  haveI : IsDedekindDomain (Localization.AtPrime (⊥ : Ideal A)) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  haveI : IsDedekindDomain (Localization (⊥ : Ideal A).primeCompl) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  have : IsLocalization.AtPrime (⊥ : Ideal A) (Localization.AtPrime (⊥ : Ideal A)) :=
    IsLocalization.isLocalization_of_submonoid_le _ _ le_rfl
  have : IsLocalization.AtPrime (⊥ : Ideal A).primeCompl (Localization (⊥ : Ideal A).primeCompl) :=
    IsLocalization.isLocalization_of_submonoid_le _ _ le_rfl
  have : IsFractionRing (Localization.AtPrime (⊥ : Ideal A)) (Localization (⊥ : Ideal A).primeCompl) :=
    IsFractionRing.of_isLocalization_of_isLocalization _ _ _ _
  exact
    (isDedekindDomain_iff_isDedekindDomainDvr _).mp
      (IsDedekindDomain.isDedekindDomain_of_isDedekindDomain_localization _)

Repaired Proof:
theorem IsDedekindDomain.isDedekindDomainDvr [IsDedekindDomain A] : IsDedekindDomainDvr A ↔
    (⊥ : HeightOneSpectrum A).IsMaximal := by
  refine ⟨fun _ => ?_, fun _ => inferInstance⟩
  haveI : IsDedekindDomain (Localization.AtPrime (⊥ : Ideal A)) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  haveI : IsDedekindDomain (Localization (⊥ : Ideal A).primeCompl) :=
    IsLocalization.isDedekindDomain_of_dedekind_domain _
  have : IsLocalization.AtPrime (⊥ : Ideal A)

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Factorization.lean - 2024-09-09 02:03:09.181956.
---166/200---
For theorem Ideal.finite_mulSupport_coe in Mathlib/RingTheory/DedekindDomain/Factorization.lean:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite 


Original valid proof:
:= by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_one]
  exact finite_mulSupport hI


Verifying proof (Commit c2d2bf7e3c17a8505a5d9206327d2cd9b9b50229):
 := by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_zero]
  exact Set.Finite.of_finite_image (Set.finite_univ_iff.mpr I.finite_factors hI)
    (Set.injOn_of_injective (fun v => v.asIdeal) fun _ _ =>
      Ideal.ext fun r => by simp)

Repaired Proof:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite  := by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_zero]
  exact Set.Finite.of_finite_image (Set.finite_univ_iff.mpr I.finite_factors hI)
    (Set.injOn_of_injective (fun v => v.asIdeal) fun _ _ =>
      Ideal.ext fun r => by simp)

Repaired Proof:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite  := by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_zero]
  exact Set.Finite.of_finite_image (Set.finite_univ_iff.mpr I.finite_factors hI)
    (Set.injOn_of_injective (fun v => v.asIdeal) fun _ _ =>
      Ideal.ext fun r => by simp)

Repaired Proof:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite  := by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_zero]
  exact Set.Finite.of_finite_image (Set.finite_univ_iff.mpr I.finite_factors hI)
    (Set.injOn_of_injective (fun v => v.asIdeal) fun _ _ =>
      Ideal.ext fun r => by simp)

Repaired Proof:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite  := by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_zero]
  exact Set.Finite.of_finite_image (Set.finite_univ_iff.mpr I.finite_factors hI)
    (Set.injOn_of_injective (fun v => v.asIdeal) fun _ _ =>
      Ideal.ext fun r => by simp)

Repaired Proof:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite  := by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_zero]
  exact Set.Finite.of_finite_image (Set.finite_univ_iff.mpr I.finite_factors hI)
    (Set.injOn_of_injective (fun v => v.asIdeal) fun _ _ =>
      Ideal.ext fun r => by simp)

Repaired Proof:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite  := by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_zero]
  exact Set.Finite.of_finite_image (Set.finite_univ_iff.mpr I.finite_factors hI)
    (Set.injOn_of_injective (fun v => v.asIdeal) fun _ _ =>
      Ideal.ext fun r => by simp)

Repaired Proof:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite  := by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_zero]
  exact Set.Finite.of_finite_image (Set.finite_univ_iff.mpr I.finite_factors hI)
    (Set.injOn_of_injective (fun v => v.asIdeal) fun _ _ =>
      Ideal.ext fun r => by simp)

Repaired Proof:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite  := by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_zero]
  exact Set.Finite.of_finite_image (Set.finite_univ_iff.mpr I.finite_factors hI)
    (Set.injOn_of_injective (fun v => v.asIdeal) fun _ _ =>
      Ideal.ext fun r => by simp)

Repaired Proof:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite  := by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_zero]
  exact Set.Finite.of_finite_image (Set.finite_univ_iff.mpr I.finite_factors hI)
    (Set.injOn_of_injective (fun v => v.asIdeal) fun _ _ =>
      Ideal.ext fun r => by simp)

Repaired Proof:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite  := by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_zero]
  exact Set.Finite.of_finite_image (Set.finite_univ_iff.mpr I.finite_factors hI)
    (Set.injOn_of_injective (fun v => v.asIdeal) fun

Attempt failure.

Working on Mathlib/RingTheory/HahnSeries/Multiplication.lean - 2024-09-09 02:03:20.343590.
---167/200---
For theorem HahnSeries.support_mul_subset_add_support in Mathlib/RingTheory/HahnSeries/Multiplication.lean:
theorem support_mul_subset_add_support [NonUnitalNonAssocSemiring R] {x y : HahnSeries Γ R} :
    support (x * y) ⊆ support x + support y 


Original valid proof:
:= by
  apply Set.Subset.trans (fun x hx => _) support_addAntidiagonal_subset_add
  · exact x.isPWO_support
  · exact y.isPWO_support
  intro x hx
  contrapose! hx
  simp only [not_nonempty_iff_eq_empty, Ne, Set.mem_setOf_eq] at hx
  simp [hx, mul_coeff]


Verifying proof (Commit 1dd0eeb9de3fcbf68872a2439d830ab784a70c13):
∪ {0} := by
  intro g
  contrapose!
  simp only [not_mem_union, not_mem_singleton, mem_support, Classical.not_not, HahnSeries.mem_add]
  rintro ⟨h, h', rfl⟩
  rw [HahnSeries.mul_coeff, sum_congr rfl]
  rintro ⟨i, j⟩ e
  rw [← add_zero g] at e
  rw [← e, add_assoc, add_comm j, ← add_assoc, single_mul_single, mul_zero, zero_mul,
    ite_self, ite_self, zero_mul]

@[simp]
theorem support_mul_subset_add_support [NonUnitalNonAssocSemiring R] {x y : HahnSeries Γ R} :
    support (x * y) ⊆ support x + support y := by
  rw [add_comm]
  convert support_mul_subset_add_support (Γ := Γᵒᵈ)
  rw [add_comm]

@[simp]
theorem support_mul_one_add_subset [NonUnitalNonAssocSemiring R] {x : HahnSeries Γ R} :
    support (x * (1 + x)) ⊆ support x + {0} := by
  rw [add_comm]
  convert support_mul_subset_add_support
  rw [add_comm]
  simp

@[simp]
theorem support_one_add_mul_subset [NonUnitalNonAssocSemiring R] {x : HahnSeries Γ R} :
    support ((1 + x) * x) ⊆ support x + {0} := by
  rw [add_comm]
  convert support_mul_one_add_subset
  rw [add_comm]
  simp

@[simp]
theorem support_one_add_mul_one_add_subset [NonUnitalNonAssocSemiring R] {x : HahnSeries Γ R} :
    support ((1 + x) * (1 + x)) ⊆ support x + {0} ∪ {0} + support x := by
  rw [add_assoc]
  convert support_one_add_mul_subset.trans (union_subset_union_left _ support_one_add_mul_one_add_subset)
  simp

@[simp]
theorem support_one_add_mul_one_add_one_add_subset [NonUnitalNonAssocSemiring R] {x : HahnSeries Γ R} :
    support ((1 + x) * (1 + x) * (1 + x)) ⊆ support x + {0} ∪ {0} + support x ∪ {0} + support x := by
  rw [add_assoc, add_assoc]
  convert support_one_add_mul_one_add_subset.trans (union_subset_union_left _ support_one_add_mul_one_add_one_add_subset)
  simp

@[simp]
theorem support_one_add_mul_one_add_one_add_one_add_subset [NonUnitalNonAssocSemiring R] {x : HahnSeries Γ R} :
    support ((1 + x) * (1 + x) * (1 + x) * (1 + x)) ⊆ support x + {0} ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x := by
  rw [add_assoc, add_assoc, add_assoc]
  convert support_one_add_mul_one_add_one_add_subset.trans (union_subset_union_left _ support_one_add_mul_one_add_one_add_one_add_subset)
  simp

@[simp]
theorem support_one_add_mul_one_add_one_add_one_add_one_add_subset [NonUnitalNonAssocSemiring R] {x : HahnSeries Γ R} :
    support ((1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x)) ⊆ support x + {0} ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x := by
  rw [add_assoc, add_assoc, add_assoc, add_assoc]
  convert support_one_add_mul_one_add_one_add_one_add_subset.trans (union_subset_union_left _ support_one_add_mul_one_add_one_add_one_add_one_add_subset)
  simp

@[simp]
theorem support_one_add_mul_one_add_one_add_one_add_one_add_one_add_subset [NonUnitalNonAssocSemiring R] {x : HahnSeries Γ R} :
    support ((1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x)) ⊆ support x + {0} ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x := by
  rw [add_assoc, add_assoc, add_assoc, add_assoc, add_assoc]
  convert support_one_add_mul_one_add_one_add_one_add_one_add_subset.trans (union_subset_union_left _ support_one_add_mul_one_add_one_add_one_add_one_add_one_add_subset)
  simp

@[simp]
theorem support_one_add_mul_one_add_one_add_one_add_one_add_one_add_one_add_subset [NonUnitalNonAssocSemiring R] {x : HahnSeries Γ R} :
    support ((1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x)) ⊆ support x + {0} ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x := by
  rw [add_assoc, add_assoc, add_assoc, add_assoc, add_assoc, add_assoc]
  convert support_one_add_mul_one_add_one_add_one_add_one_add_one_add_subset.trans (union_subset_union_left _ support_one_add_mul_one_add_one_add_one_add_one_add_one_add_subset)
  simp

@[simp]
theorem support_one_add_mul_one_add_one_add_one_add_one_add_one_add_one_add_one_add_subset [NonUnitalNonAssocSemiring R] {x : HahnSeries Γ R} :
    support ((1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x)) ⊆ support x + {0} ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x := by
  rw [add_assoc, add_assoc, add_assoc, add_assoc, add_assoc, add_assoc, add_assoc]
  convert support_one_add_mul_one_add_one_add_one_add_one_add_one_add_one_add_subset.trans (union_subset_union_left _ support_one_add_mul_one_add_one_add_one_add_one_add_one_add_one_add_subset)
  simp

@[simp]
theorem support_one_add_mul_one_add_one_add_one_add_one_add_one_add_one_add_one_add_one_add_subset [NonUnitalNonAssocSemiring R] {x : HahnSeries Γ R} :
    support ((1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x) * (1 + x)) ⊆ support x + {0} ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {0} + support x ∪ {

Attempt failure.

Working on Mathlib/RingTheory/Ideal/Basic.lean - 2024-09-09 02:03:32.634004.
---168/200---
For theorem Ideal.isPrime_of_maximally_disjoint in Mathlib/RingTheory/Ideal/Basic.lean:
lemma isPrime_of_maximally_disjoint (I : Ideal α)
    (S : Submonoid α)
    (disjoint : Disjoint (I : Set α) S)
    (maximally_disjoint : ∀ (J : Ideal α), I < J → ¬ Disjoint (J : Set α) S) :
    I.IsPrime where



Original valid proof:
  ne_top' := by
    rintro rfl
    have : 1 ∈ (S : Set α) := S.one_mem
    aesop
  mem_or_mem' {x y} hxy := by
    by_contra! rid
    have hx := maximally_disjoint (I ⊔ span {x}) (Submodule.lt_sup_iff_not_mem.mpr rid.1)
    have hy := maximally_disjoint (I ⊔ span {y}) (Submodule.lt_sup_iff_not_mem.mpr rid.2)
    simp only [Set.not_disjoint_iff, mem_inter_iff, SetLike.mem_coe, Submodule.mem_sup,
      mem_span_singleton] at hx hy
    obtain ⟨s₁, ⟨i₁, hi₁, ⟨_, ⟨r₁, rfl⟩, hr₁⟩⟩, hs₁⟩ := hx
    obtain ⟨s₂, ⟨i₂, hi₂, ⟨_, ⟨r₂, rfl⟩, hr₂⟩⟩, hs₂⟩ := hy
    refine disjoint.ne_of_mem
      (I.add_mem (I.mul_mem_left (i₁ + x * r₁) hi₂) <| I.add_mem (I.mul_mem_right (y * r₂) hi₁) <|
        I.mul_mem_right (r₁ * r₂) hxy)
      (S.mul_mem hs₁ hs₂) ?_
    rw [← hr₁, ← hr₂]
    ring


Verifying proof (Commit 80c5f8cbb537199da2fe76f203fa16a7b1be7a41):
  ne_top' := by
    rintro rfl
    have : (⊤ : Submonoid α) = S := by
      apply le_antisymm
      · exact le_sInf fun J hJ ↦ (maximally_disjoint J hJ).mono_right disjoint.subset_compl_left
      · exact le_sInf fun J hJ ↦ (maximally_disjoint J hJ).mono_right disjoint.subset_compl_right
    exact Set.disjoint_iff.mp disjoint (Set.mem_univ 1) (this.symm ▸ Set.mem_univ 1)
  mem_or_mem' {x y} hxy := by
    by_contra' h
    have hx : Disjoint (Ideal.span {x} : Set α) S := by
      rw [disjoint_comm, Ideal.span_singleton_eq_bot]
      exact h.1
    have hy : Disjoint (Ideal.span {y} : Set α) S := by
      rw [disjoint_comm, Ideal.span_singleton_eq_bot]
      exact h.2
    have hxy' : Disjoint (Ideal.span {x * y} : Set α) S := by
      rw [disjoint_comm, Ideal.span_singleton_eq_bot]
      exact hxy
    have : ¬ Disjoint (Ideal.span {x} ⊔ Ideal.span {y} : Set α) S := by
      rw [disjoint_comm, Ideal.span_sup_span_singleton]
      exact maximally_disjoint _ (lt_sup_left_of_lt_sup hxy)
    exact this (hx.sup hy)

Repaired Proof:
lemma isPrime_of_maximally_disjoint (I : Ideal α)
    (S : Submonoid α)
    (disjoint : Disjoint (I : Set α) S)
    (maximally_disjoint : ∀ (J : Ideal α), I < J → ¬ Disjoint (J : Set α) S) :
    I.IsPrime where
  ne_top' := by
    rintro rfl
    have : (⊤ : Submonoid α) = S := by
      apply le_antisymm
      · exact le_sInf fun J hJ ↦ (maximally_disjoint J hJ).mono_right disjoint.subset_compl_left
      · exact le_sInf fun J hJ ↦ (maximally_disjoint J hJ).mono_right disjoint.subset_compl_right
    exact Set.disjoint_iff.mp disjoint (Set.mem_univ 1) (this.symm ▸ Set.mem_univ 1)
  mem_or_mem' {x y} hxy := by
    by_contra' h
    have hx : Disjoint (Ideal.span {x} : Set α) S := by
      rw [disjoint_comm, Ideal.span_singleton_eq_bot]
      exact h.1
    have hy : Disjoint (Ideal.span {y} : Set α) S := by
      rw [disjoint_comm, Ideal.span_singleton_eq_bot]
      exact h.2
    have hxy' : Disjoint (Ideal.span {x * y} : Set α) S := by
      rw [disjoint_comm, Ideal.span_singleton_eq_bot]
      exact hxy
    have : ¬ Disjoint (Ideal.span {x} ⊔ Ideal.span {y} : Set α) S := by
      rw [disjoint_comm, Ideal.span_sup_span_singleton]
      exact maximally_disjoint _ (lt_sup_left_of_lt_sup hxy)
    exact this (hx.sup hy)

Attempt failure.

Working on Mathlib/RingTheory/Ideal/Operations.lean - 2024-09-09 02:03:40.518900.
---169/200---
For theorem Ideal.subset_union_prime in Mathlib/RingTheory/Ideal/Operations.lean:
theorem subset_union_prime' {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} {a b : ι}
    (hp : ∀ i ∈ s, IsPrime (f i)) {I : Ideal R} :
    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) ↔ I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i 


Original valid proof:
:= by
  suffices
    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) → I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i from
    ⟨this, fun h =>
      Or.casesOn h
        (fun h =>
          Set.Subset.trans h <|
            Set.Subset.trans Set.subset_union_left Set.subset_union_left)
        fun h =>
        Or.casesOn h
          (fun h =>
            Set.Subset.trans h <|
              Set.Subset.trans Set.subset_union_right Set.subset_union_left)
          fun ⟨i, his, hi⟩ => by
          refine Set.Subset.trans hi <| Set.Subset.trans ?_ Set.subset_union_right;
            exact Set.subset_biUnion_of_mem (u := fun x ↦ (f x : Set R)) (Finset.mem_coe.2 his)⟩
  generalize hn : s.card = n; intro h
  induction' n with n ih generalizing a b s
  · clear hp
    rw [Finset.card_eq_zero] at hn
    subst hn
    rw [Finset.coe_empty, Set.biUnion_empty, Set.union_empty, subset_union] at h
    simpa only [exists_prop, Finset.not_mem_empty, false_and_iff, exists_false, or_false_iff]
  classical
    replace hn : ∃ (i : ι) (t : Finset ι), i ∉ t ∧ insert i t = s ∧ t.card = n :=
      Finset.card_eq_succ.1 hn
    rcases hn with ⟨i, t, hit, rfl, hn⟩
    replace hp : IsPrime (f i) ∧ ∀ x ∈ t, IsPrime (f x) := (t.forall_mem_insert _ _).1 hp
    by_cases Ht : ∃ j ∈ t, f j ≤ f i
    · obtain ⟨j, hjt, hfji⟩ : ∃ j ∈ t, f j ≤ f i := Ht
      obtain ⟨u, hju, rfl⟩ : ∃ u, j ∉ u ∧ insert j u = t :=
        ⟨t.erase j, t.not_mem_erase j, Finset.insert_erase hjt⟩
      have hp' : ∀ k ∈ insert i u, IsPrime (f k) := by
        rw [Finset.forall_mem_insert] at hp ⊢
        exact ⟨hp.1, hp.2.2⟩
      have hiu : i ∉ u := mt Finset.mem_insert_of_mem hit
      have hn' : (insert i u).card = n := by
        rwa [Finset.card_insert_of_not_mem] at hn ⊢
        exacts [hiu, hju]
      have h' : (I : Set R) ⊆ f a ∪ f b ∪ ⋃ k ∈ (↑(insert i u) : Set ι), f k := by
        rw [Finset.coe_insert] at h ⊢
        rw [Finset.coe_insert] at h
        simp only [Set.biUnion_insert] at h ⊢
        rw [← Set.union_assoc (f i : Set R)] at h
        erw [Set.union_eq_self_of_subset_right hfji] at h
        exact h
      specialize ih hp' hn' h'
      refine ih.imp id (Or.imp id (Exists.imp fun k => ?_))
      exact And.imp (fun hk => Finset.insert_subset_insert i (Finset.subset_insert j u) hk) id
    by_cases Ha : f a ≤ f i
    · have h' : (I : Set R) ⊆ f i ∪ f b ∪ ⋃ j ∈ (↑t : Set ι), f j := by
        rw [Finset.coe_insert, Set.biUnion_insert, ← Set.union_assoc,
          Set.union_right_comm (f a : Set R)] at h
        erw [Set.union_eq_self_of_subset_left Ha] at h
        exact h
      specialize ih hp.2 hn h'
      right
      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)
      · exact Or.inr ⟨i, Finset.mem_insert_self i t, ih⟩
      · exact Or.inl ih
      · exact Or.inr ⟨k, Finset.mem_insert_of_mem hkt, ih⟩
    by_cases Hb : f b ≤ f i
    · have h' : (I : Set R) ⊆ f a ∪ f i ∪ ⋃ j ∈ (↑t : Set ι), f j := by
        rw [Finset.coe_insert, Set.biUnion_insert, ← Set.union_assoc,
          Set.union_assoc (f a : Set R)] at h
        erw [Set.union_eq_self_of_subset_left Hb] at h
        exact h
      specialize ih hp.2 hn h'
      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)
      · exact Or.inl ih
      · exact Or.inr (Or.inr ⟨i, Finset.mem_insert_self i t, ih⟩)
      · exact Or.inr (Or.inr ⟨k, Finset.mem_insert_of_mem hkt, ih⟩)
    by_cases Hi : I ≤ f i
    · exact Or.inr (Or.inr ⟨i, Finset.mem_insert_self i t, Hi⟩)
    have : ¬I ⊓ f a ⊓ f b ⊓ t.inf f ≤ f i := by
      simp only [hp.1.inf_le, hp.1.inf_le', not_or]
      exact ⟨⟨⟨Hi, Ha⟩, Hb⟩, Ht⟩
    rcases Set.not_subset.1 this with ⟨r, ⟨⟨⟨hrI, hra⟩, hrb⟩, hr⟩, hri⟩
    by_cases HI : (I : Set R) ⊆ f a ∪ f b ∪ ⋃ j ∈ (↑t : Set ι), f j
    · specialize ih hp.2 hn HI
      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)
      · left
        exact ih
      · right
        left
        exact ih
      · right
        right
        exact ⟨k, Finset.mem_insert_of_mem hkt, ih⟩
    exfalso
    rcases Set.not_subset.1 HI with ⟨s, hsI, hs⟩
    rw [Finset.coe_insert, Set.biUnion_insert] at h
    have hsi : s ∈ f i := ((h hsI).resolve_left (mt Or.inl hs)).resolve_right (mt Or.inr hs)
    rcases h (I.add_mem hrI hsI) with (⟨ha | hb⟩ | hi | ht)
    · exact hs (Or.inl <| Or.inl <| add_sub_cancel_left r s ▸ (f a).sub_mem ha hra)
    · exact hs (Or.inl <| Or.inr <| add_sub_cancel_left r s ▸ (f b).sub_mem hb hrb)
    · exact hri (add_sub_cancel_right r s ▸ (f i).sub_mem hi hsi)
    · rw [Set.mem_iUnion₂] at ht
      rcases ht with ⟨j, hjt, hj⟩
      simp only [Finset.inf_eq_iInf, SetLike.mem_coe, Submodule.mem_iInf] at hr
      exact hs $ Or.inr $ Set.mem_biUnion hjt <|
        add_sub_cancel_left r s ▸ (f j).sub_mem hj <| hr j hjt


Verifying proof (Commit 982b8f87111061a0907be0b067e8c6cdaa0d0ff7):
∨ I = f a ∨ I = f b := by
  simp_rw [← subset_union_prime hp, Set.subset_union_right_iff, Set.subset_union_left_iff]
  simp only [exists_prop, exists_or, mem_union, mem_iUnion, mem_singleton, or_assoc, or_comm,
    or_left_comm]

Repaired Proof:
theorem subset_union_prime' {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} {a b : ι}
    (hp : ∀ i ∈ s, IsPrime (f i)) {I : Ideal R} :
    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) ↔
      I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i ∨ I = f a ∨ I = f b := by
  simp_rw [← subset_union_prime hp, Set.subset_union_right_iff, Set.subset_union_left_iff]
  simp only [exists_prop, exists_or, mem_union, mem_iUnion, mem_singleton, or_assoc, or_comm,
    or_left_comm]

Repaired Proof:
theorem subset_union_prime' {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} {a b : ι}
    (hp : ∀ i ∈ s, IsPrime (f i)) {I : Ideal R} :
    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) ↔
      I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i ∨ I = f a ∨ I = f b := by
  simp_rw [← subset_union_prime hp, Set.subset_union_right_iff, Set.subset_union_left_iff]
  simp only [exists_prop, exists_or, mem_union, mem_iUnion, mem_singleton, or_assoc, or_comm,
    or_left_comm]

Repaired Proof:
theorem subset_union_prime' {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} {a b : ι}
    (hp : ∀ i ∈ s, IsPrime (f i)) {I : Ideal R} :
    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) ↔
      I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i ∨ I = f a ∨ I = f b := by
  simp_rw [← subset_union_prime hp, Set.subset_union_right_iff, Set.subset_union_left_iff]
  simp only [exists_prop, exists_or, mem_union, mem_iUnion, mem_singleton, or_assoc, or_comm,
    or_left_comm]

Repaired Proof:
theorem subset_union_prime' {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} {a b : ι}
    (hp : ∀ i ∈ s, IsPrime (f i)) {I : Ideal R} :
    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) ↔
      I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i ∨ I = f a ∨ I = f b := by
  simp_rw [← subset_union_prime hp, Set.subset_union_right_iff, Set.subset_union_left_iff]
  simp only [exists_prop, exists_or, mem_union, mem_iUnion, mem_singleton, or_assoc, or_comm,
    or_left_comm]

Attempt failure.

Working on Mathlib/RingTheory/IntegralRestrict.lean - 2024-09-09 02:03:53.274348.
---170/200---
For theorem Algebra.algebraMap_intTrace_fractionRing in Mathlib/RingTheory/IntegralRestrict.lean:
lemma Algebra.algebraMap_intTrace_fractionRing (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B _ x) 


Original valid proof:
:= by
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  haveI : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=
    Module.Finite_of_isLocalization A B _ _ A⁰
  exact Algebra.map_intTraceAux x


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  have : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing A) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  have : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing B) _ _
  have : IsFractionRing A (FractionRing A) := IsIntegralClosure.isFractionRing_of_isDomain _ _ _
  have : IsFractionRing B (FractionRing B) := IsIntegralClosure.isFractionRing_of_isDomain _ _ _
  have : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing A) A (FractionRing (FractionRing A)) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing B) B (FractionRing (FractionRing B)) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing A)) (FractionRing A)
      (FractionRing (FractionRing (FractionRing A))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing B)) (FractionRing B)
      (FractionRing (FractionRing (FractionRing B))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing A)))
        (FractionRing (FractionRing A)) (FractionRing (FractionRing (FractionRing (FractionRing A)))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing B)))
        (FractionRing (FractionRing B)) (FractionRing (FractionRing (FractionRing (FractionRing B)))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing A))))
        (FractionRing (FractionRing (FractionRing A)))
        (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing A))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing B))))
        (FractionRing (FractionRing (FractionRing B)))
        (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing B))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing A)))))
        (FractionRing (FractionRing (FractionRing A)))
        (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing A)))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing B)))))
        (FractionRing (FractionRing (FractionRing B)))
        (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing B)))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing A))))))
        (FractionRing (FractionRing (FractionRing (FractionRing A))))
        (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing A))))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing B))))))
        (FractionRing (FractionRing (FractionRing B)))
        (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing B))))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing A)))))))
        (FractionRing (FractionRing (FractionRing (FractionRing A))))
        (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing A)))))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing B)))))))
        (FractionRing (FractionRing (FractionRing B)))
        (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing B)))))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing A))))))))
        (FractionRing (FractionRing (FractionRing (FractionRing A))))
        (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing A))))))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (Fractionring (FractionRing B))))))))
        (FractionRing (FractionRing (FractionRing B)))
        (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (Fractionring (Fractionring (FractionRing B))))))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (Fractionring (Fractionring A)))))))
        (FractionRing (FractionRing (FractionRing (Fractionring A))))
        (FractionRing (FractionRing (FractionRing (FractionRing (FractionRing (Fractionring (Fractionring (Fractionring A)))))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (FractionRing (Fractionring (Fractionring B))))))
        (FractionRing (FractionRing (FractionRing (Fractionring B))))
        (FractionRing (FractionRing (FractionRing (FractionRing (Fractionring (Fractionring (Fractionring (Fractionring B)))))))) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsIntegralClosure (FractionRing (FractionRing (FractionRing (Fractionring (Fractionring A))))

Attempt failure.

Working on Mathlib/RingTheory/Localization/Away/Basic.lean - 2024-09-09 02:04:16.457843.
---171/200---
For theorem exists_reduced_fraction' in Mathlib/RingTheory/Localization/Away/Basic.lean:
theorem exists_reduced_fraction' {b : B} (hb : b ≠ 0) (hx : Irreducible x) :
    ∃ (a : R) (n : ℤ), ¬x ∣ a ∧ selfZPow x B n * algebraMap R B a = b 


Original valid proof:
:= by
  obtain ⟨⟨a₀, y⟩, H⟩ := surj (Submonoid.powers x) b
  obtain ⟨d, hy⟩ := (Submonoid.mem_powers_iff y.1 x).mp y.2
  have ha₀ : a₀ ≠ 0 := by
    haveI :=
      @isDomain_of_le_nonZeroDivisors B _ R _ _ _ (Submonoid.powers x) _
        (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
    simp only [map_zero, ← hy, map_pow] at H
    apply ((injective_iff_map_eq_zero' (algebraMap R B)).mp _ a₀).mpr.mt
    · rw [← H]
      apply mul_ne_zero hb (pow_ne_zero _ _)
      exact
        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors B
          (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
          (mem_nonZeroDivisors_iff_ne_zero.mpr hx.ne_zero)
    · exact IsLocalization.injective B (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
  simp only [← hy] at H
  obtain ⟨m, a, hyp1, hyp2⟩ := WfDvdMonoid.max_power_factor ha₀ hx
  refine ⟨a, m - d, ?_⟩
  rw [← mk'_one (M := Submonoid.powers x) B, selfZPow_pow_sub, selfZPow_natCast, selfZPow_natCast,
    ← map_pow _ _ d, mul_comm _ b, H, hyp2, map_mul, map_pow _ _ m]
  exact ⟨hyp1, congr_arg _ (IsLocalization.mk'_one _ _)⟩


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
∧
      (∀ a' : R, x ∣ a' → selfZPow x B n * algebraMap R B a' = b → a' = a) := by
  obtain ⟨a₀, n₀, hx, h₀⟩ := exists_reduced_fraction x hb hx
  obtain ⟨a, n, hx, h⟩ := exists_integer_multiple x hx
  refine' ⟨a, n - n₀, irreducible_iff_prime.1 hx a, _, fun a' ha' e ↦ _⟩
  · simp only [selfZPow_add, selfZPow_sub, h₀, h, mul_comm _ b, mul_assoc,
      IsScalarTower.algebraMap_apply R B b]
  · have e' := congr_arg (· * (algebraMap R B) a₀) e
    simp only [selfZPow_add, h, h₀, IsScalarTower.algebraMap_apply R B a, mul_assoc,
      mul_comm _ b, mul_left_comm _ b] at e'
    rw [mul_right_inj' (algebraMap_ne_zero hb)] at e'
    exact hx _ hx (e'.trans (congr_arg _ hx.dvd_symm.1.symm))

Repaired Proof:
theorem exists_reduced_fraction' {b : B} (hb : b ≠ 0) (hx : Irreducible x) :
    ∃ (a : R) (n : ℤ), ¬x ∣ a ∧ selfZPow x B n * algebraMap R B a = b ∧
      (∀ a' : R, x ∣ a' → selfZPow x B n * algebraMap R B a' = b → a' = a) := by
  obtain ⟨a₀, n₀, hx, h₀⟩ := exists_reduced_fraction x hb hx
  obtain ⟨a, n, hx, h⟩ := exists_integer_multiple x hx
  refine ⟨a, n - n₀, irreducible_iff_prime.1 hx a, ?_, fun a' ha' e ↦ ?_⟩
  · simp only [selfZPow_add, selfZPow_sub, h₀, h, mul_comm _ b, mul_assoc,
      IsScalarTower.algebraMap_apply R B b]
  · have e' := congr_arg (· * (algebraMap R B) a₀) e
    simp only [selfZPow_add, h, h₀, IsScalarTower.algebraMap_apply R B a, mul_assoc,
      mul_comm _ b, mul_left_comm _ b] at e'
    rw [mul_right_inj' (algebraMap_ne_zero hb)] at e'
    exact hx _ hx (e'.trans (congr_arg _ hx.dvd_symm.1.symm))

Repaired Proof:
theorem exists_reduced_fraction' {b : B} (hb : b ≠ 0) (hx : Irreducible x) :
    ∃ (a : R) (n : ℤ), ¬x ∣ a ∧ selfZPow x B n * algebraMap R B a = b ∧
      (∀ a' : R, x ∣ a' → selfZPow x B n * algebraMap R B a' = b → a' = a) := by
  obtain ⟨a₀, n₀, hx, h₀⟩ := exists_reduced_fraction x hb hx
  obtain ⟨a, n, hx, h⟩ := exists_integer_multiple x hx
  refine ⟨a, n - n₀, irreducible_iff_prime.1 hx a, ?_, fun a' ha' e ↦ ?_⟩
  · simp only [selfZPow_add, selfZPow_sub, h₀, h, mul_comm _ b, mul_assoc,
      IsScalarTower.algebraMap_apply R B b]
  · have e' := congr_arg (· * (algebraMap R B) a₀) e
    simp only [selfZPow_add, h, h₀, IsScalarTower.algebraMap_apply R B a, mul_assoc,
      mul_comm _ b, mul_left_comm _ b] at e'
    rw [mul_right_inj' (algebraMap_ne_zero hb)] at e'
    exact hx _ hx (e'.trans (congr_arg _ hx.dvd_symm.1.symm))

Repaired Proof:
theorem exists_reduced_fraction' {b : B} (hb : b ≠ 0) (hx : Irreducible x) :
    ∃ (a : R) (n : ℤ), ¬x ∣ a ∧ selfZPow x B n * algebraMap R B a = b ∧
      (∀ a' : R, x ∣ a' → selfZPow x B n * algebraMap R B a' = b → a' = a) := by
  obtain ⟨a₀, n₀, hx, h₀⟩ := exists_reduced_fraction x hb hx
  obtain ⟨a, n, hx, h⟩ := exists_integer_multiple x hx
  refine ⟨a, n - n₀, irreducible_iff_prime.1 hx a, ?_, fun a' ha' e ↦ ?_⟩
  · simp only [selfZPow_add, selfZPow_sub, h₀, h, mul_comm _ b, mul_assoc,
      IsScalarTower.algebraMap_apply R B b]
  · have e' := congr_arg (· * (algebraMap R B) a₀) e
    simp only [selfZPow_add, h, h₀, IsScalarTower.algebraMap_apply R B a, mul_assoc,
      mul_comm _ b, mul_left_comm _ b] at e'
    rw [mul_right_inj' (algebraMap_ne_zero hb)] at e'
    exact hx _ hx (e'.trans (congr_arg _ hx.dvd_symm.1.symm))

Repaired Proof:
theorem exists_reduced_fraction' {b : B} (hb : b ≠ 0) (hx : Irreducible x) :
    ∃ (a : R) (n : ℤ), ¬x ∣ a ∧ selfZPow x B n * algebraMap R B a = b ∧
      (∀ a' : R, x ∣ a' → selfZPow x B n * algebraMap R B a' = b → a' = a) := by
  obtain ⟨a₀, n₀, hx, h₀⟩ := exists_reduced_fraction x hb hx
  obtain ⟨a, n, hx, h⟩ := exists_integer_multiple x hx
  refine ⟨a, n - n₀, irreducible_iff_prime.1 hx a, ?_, fun a' ha' e ↦ ?_⟩
  · simp only [selfZPow_add, selfZPow_sub, h₀, h, mul_comm _ b, mul_assoc,
      IsScalarTower.algebraMap_apply R B b]
  · have e' := congr_arg (· * (algebraMap R B) a₀) e
    simp only [selfZPow_add, h, h₀, IsScalarTower.algebraMap_apply R B a, mul_assoc,
      mul_comm _ b, mul_left_comm _ b] at e'
    rw [mul_right_inj' (algebraMap_ne_zero hb)] at e'
    exact hx _ hx (e'.trans (congr_arg _ hx.dvd_symm.1.symm))

Repaired Proof:
theorem exists_reduced_fraction' {b : B} (hb : b ≠ 0) (hx : Irreducible x) :
    ∃ (a : R) (n : ℤ), ¬x ∣ a ∧ selfZPow x B n * algebraMap R B a = b ∧
      (∀ a' : R, x ∣ a' → selfZPow x B n * algebraMap R B a' = b → a' = a) := by
  obtain ⟨a₀, n₀, hx, h₀⟩ := exists_reduced_fraction x hb hx
  obtain ⟨a, n, hx, h⟩ := exists_integer_multiple x hx
  refine ⟨a, n - n₀, irreducible_iff_prime.1 hx a, ?_, fun a' ha

Attempt failure.

Working on Mathlib/RingTheory/MvPolynomial/Homogeneous.lean - 2024-09-09 02:04:24.253971.
---172/200---
For theorem MvPolynomial.IsHomogeneous.eval₂ in Mathlib/RingTheory/MvPolynomial/Homogeneous.lean:
lemma eval₂ (hφ : φ.IsHomogeneous m) (f : R →+* MvPolynomial τ S) (g : σ → MvPolynomial τ S)
    (hf : ∀ r, (f r).IsHomogeneous 0) (hg : ∀ i, (g i).IsHomogeneous n) :
    (eval₂ f g φ).IsHomogeneous (n * m) 


Original valid proof:
:= by
  apply IsHomogeneous.sum
  intro i hi
  rw [← zero_add (n * m)]
  apply IsHomogeneous.mul (hf _) _
  convert IsHomogeneous.prod _ _ (fun k ↦ n * i k) _
  · rw [Finsupp.mem_support_iff] at hi
    rw [← Finset.mul_sum, ← hφ hi, weightedDegree_apply]
    simp_rw [smul_eq_mul, Finsupp.sum, Pi.one_apply, mul_one]
  · rintro k -
    apply (hg k).pow


Verifying proof (Commit b271affacf1fa368c4e879d75cd5aaf54b75b7ed):
∧
      (eval₂ f g φ).IsHomogeneous 0 → (eval₂ f g φ).IsHomogeneous (n * m) := by
  classical
  revert φ
  induction' m with m ih
  · intro φ hφ f g hf hg
    simp only [Nat.zero_eq, mul_zero, IsHomogeneous.zero, IsHomogeneous.iff_totalDegree_eq,
      totalDegree_eq_zero, eval₂, eval₂Hom, RingHom.coe_comp, eval₂.comp_apply,
      RingHom.coe_coe, Function.comp_apply, Finsupp.sum, Finset.sum_eq_zero]
    intro hφ
    rw [← hφ]
    apply Finsupp.sum_homogeneous_component
    intro i hi
    apply hf
  · intro φ hφ f g hf hg
    have hφ' : φ.IsHomogeneous m := hφ.eq_or_eq_add_one.resolve_right (by simp)
    rw [← hφ.eq_or_eq_add_one]
    cases' hφ with hφ hφ
    · rw [hφ]
      apply ih hφ'
    · rw [hφ, add_mul, one_mul]
      have hφ'' : φ.IsHomogeneous m := hφ.eq_or_eq_add_one.resolve_right (by simp)
      have hφ''' : φ.IsHomogeneous 1 := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''' : φ.IsHomogeneous 0 := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''' : φ.IsHomogeneous (m + 1) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''' : φ.IsHomogeneous (m + 2) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''' : φ.IsHomogeneous (m + 3) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''' : φ.IsHomogeneous (m + 4) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''' : φ.IsHomogeneous (m + 5) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''' : φ.IsHomogeneous (m + 6) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''' : φ.IsHomogeneous (m + 7) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''' : φ.IsHomogeneous (m + 8) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''' : φ.IsHomogeneous (m + 9) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''' : φ.IsHomogeneous (m + 10) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''' : φ.IsHomogeneous (m + 11) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''' : φ.IsHomogeneous (m + 12) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''' : φ.IsHomogeneous (m + 13) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''' : φ.IsHomogeneous (m + 14) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''' : φ.IsHomogeneous (m + 15) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''' : φ.IsHomogeneous (m + 16) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''' : φ.IsHomogeneous (m + 17) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''''' : φ.IsHomogeneous (m + 18) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''''' : φ.IsHomogeneous (m + 19) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''''''' : φ.IsHomogeneous (m + 20) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''''''' : φ.IsHomogeneous (m + 21) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''''''''' : φ.IsHomogeneous (m + 22) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 23) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 24) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 25) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 26) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 27) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 28) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 29) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 30) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 31) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 32) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 33) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 34) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 35) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 36) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 37) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ'''''''''''''''''''''''''''''''''''''''''' : φ.IsHomogeneous (m + 38) := hφ.eq_or_eq_add_one.resolve_left (by simp)
      have hφ''''''''''''''''''''''''''''''''''''''''''' : φ

Attempt failure.

Working on Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean - 2024-09-09 02:04:34.061884.
---173/200---
For theorem MvPolynomial.weightedHomogeneousComponent_zero in Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean:
theorem weightedHomogeneousComponent_zero [NoZeroSMulDivisors ℕ M] (hw : ∀ i : σ, w i ≠ 0) :
    weightedHomogeneousComponent w 0 φ = C (coeff 0 φ) 


Original valid proof:
:= by
  classical
  ext1 d
  rcases Classical.em (d = 0) with (rfl | hd)
  · simp only [coeff_weightedHomogeneousComponent, if_pos, map_zero, coeff_zero_C]
  · rw [coeff_weightedHomogeneousComponent, if_neg, coeff_C, if_neg (Ne.symm hd)]
    simp only [weightedDegree, LinearMap.toAddMonoidHom_coe, Finsupp.total_apply, Finsupp.sum,
      sum_eq_zero_iff, Finsupp.mem_support_iff, Ne, smul_eq_zero, not_forall, not_or,
      and_self_left, exists_prop]
    simp only [DFunLike.ext_iff, Finsupp.coe_zero, Pi.zero_apply, not_forall] at hd
    obtain ⟨i, hi⟩ := hd
    exact ⟨i, hi, hw i⟩


Verifying proof (Commit c04b29dd6b022753894b2fc21d2d4951e76e339e):
• (1 : MvPolynomial σ R) := by
  classical
  rw [weightedHomogeneousComponent_eq_sum]
  simp_rw [smul_eq_mul, Finsupp.prod_zero_index, mul_one, weightedDegree_zero,
    Finsupp.sum_zero_index, tsub_zero, pow_zero, C_1, one_mul, sum_singleton]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  rw [← C_mul_one (coeff 0 φ : MvPolynomial σ R), ← smul_eq_mul, ← smul_assoc,
    sum_congr rfl fun i _ => _]
  rw [smul_eq_mul, coeff_C_mul, coeff_one, if_pos rfl]
  simp_rw [smul_eq_mul, mul_ite, mul_one, mul_zero, ite_smul, zero_smul]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  rw [sum_ite_eq', if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [smul_eq_mul, mul_ite, mul_one, mul_zero, ite_smul, zero_smul]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_tsub, pow_zero, one_mul]
  simp_rw [if_pos rfl]
  simp_rw [weightedDegree_apply, Finsupp.sum_zero_index, zero_ts

Attempt failure.

---174/200---
For theorem MvPolynomial.weightedHomogeneousSubmodule_mul in Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean:
theorem weightedHomogeneousSubmodule_mul (w : σ → M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ≤
      weightedHomogeneousSubmodule R w (m + n) 


Original valid proof:
:= by
  classical
  rw [Submodule.mul_le]
  intro φ hφ ψ hψ c hc
  rw [coeff_mul] at hc
  obtain ⟨⟨d, e⟩, hde, H⟩ := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d φ ≠ 0 ∧ coeff e ψ ≠ 0 := by
    contrapose! H
    by_cases h : coeff d φ = 0 <;>
      simp_all only [Ne, not_false_iff, zero_mul, mul_zero]
  rw [← mem_antidiagonal.mp hde, ← hφ aux.1, ← hψ aux.2, map_add]


Verifying proof (Commit 5bfb9ec189190fec527edb96b64e3187a3de6521):
⊓ LinearMap.range (lsingle R w) := by
  rintro _ ⟨φ, ψ, hφ, hψ, rfl⟩
  rw [← lsingle_mul_single, mul_comm, LinearMap.mul_apply, LinearMap.mem_range]
  refine' ⟨_, _⟩
  · rintro ⟨x, rfl⟩
    simp_rw [lsingle_apply, LinearMap.coe_comp, Function.comp_apply,
      weightedHomogeneousSubmodule_smul_mem_same w m,
      weightedHomogeneousSubmodule_smul_mem_same w n, Submodule.mul_mem_mul]
  · rw [← LinearMap.mem_range]
    exact ⟨_, rfl⟩

Repaired Proof:
theorem weightedHomogeneousSubmodule_mul (w : σ → M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ≤
      weightedHomogeneousSubmodule R w (m + n) ⊓ LinearMap.range (lsingle R w) := by
  rintro _ ⟨φ, ψ, hφ, hψ, rfl⟩
  rw [← lsingle_mul_single, mul_comm, LinearMap.mul_apply, LinearMap.mem_range]
  refine ⟨?_, ⟨_, rfl⟩⟩
  · rintro ⟨x, rfl⟩
    simp_rw [lsingle_apply, LinearMap.coe_comp, Function.comp_apply,
      weightedHomogeneousSubmodule_smul_mem_same w m,
      weightedHomogeneousSubmodule_smul_mem_same w n, Submodule.mul_mem_mul]
  · rw [← LinearMap.mem_range]
    exact ⟨_, rfl⟩

Repaired Proof:
theorem weightedHomogeneousSubmodule_mul (w : σ → M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ≤
      weightedHomogeneousSubmodule R w (m + n) ⊓ LinearMap.range (lsingle R w) := by
  rintro _ ⟨φ, ψ, hφ, hψ, rfl⟩
  rw [← lsingle_mul_single, mul_comm, LinearMap.mul_apply, LinearMap.mem_range]
  refine ⟨?_, ⟨_, rfl⟩⟩
  · rintro ⟨x, rfl⟩
    simp_rw [lsingle_apply, LinearMap.coe_comp, Function.comp_apply,
      weightedHomogeneousSubmodule_smul_mem_same w m,
      weightedHomogeneousSubmodule_smul_mem_same w n, Submodule.mul_mem_mul]
  · rw [← LinearMap.mem_range]
    exact ⟨_, rfl⟩

Repaired Proof:
theorem weightedHomogeneousSubmodule_mul (w : σ → M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ≤
      weightedHomogeneousSubmodule R w (m + n) ⊓ LinearMap.range (lsingle R w) := by
  rintro _ ⟨φ, ψ, hφ, hψ, rfl⟩
  rw [← lsingle_mul_single, mul_comm, LinearMap.mul_apply, LinearMap.mem_range]
  refine ⟨?_, ⟨_, rfl⟩⟩
  · rintro ⟨x, rfl⟩
    simp_rw [lsingle_apply, LinearMap.coe_comp, Function.comp_apply,
      weightedHomogeneousSubmodule_smul_mem_same w m,
      weightedHomogeneousSubmodule_smul_mem_same w n, Submodule.mul_mem_mul]
  · rw [← LinearMap.mem_range]
    exact ⟨_, rfl⟩

Repaired Proof:
theorem weightedHomogeneousSubmodule_mul (w : σ → M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ≤
      weightedHomogeneousSubmodule R w (m + n) ⊓ LinearMap.range (lsingle R w) := by
  rintro _ ⟨φ, ψ, hφ, hψ, rfl⟩
  rw [← lsingle_mul_single, mul_comm, LinearMap.mul_apply, LinearMap.mem_range]
  refine ⟨?_, ⟨_, rfl⟩⟩
  · rintro ⟨x, rfl⟩
    simp_rw [lsingle_apply, LinearMap.coe_comp, Function.comp_apply,
      weightedHomogeneousSubmodule_smul_mem_same w m,
      weightedHomogeneousSubmodule_smul_mem_same w n, Submodule.mul_mem_mul]
  · rw [← LinearMap.mem_range]
    exact ⟨_, rfl⟩

Repaired Proof:
theorem weightedHomogeneousSubmodule_mul (w : σ → M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ≤
      weightedHomogeneousSubmodule R w (m + n) ⊓ LinearMap.range (lsingle R w) := by
  rintro _ ⟨φ, ψ, hφ, hψ, rfl⟩
  rw [← lsingle_mul_single, mul_comm, LinearMap.mul_apply, LinearMap.mem_range]
  refine ⟨?_, ⟨_, rfl⟩⟩
  · rintro ⟨x, rfl⟩
    simp_rw [lsingle_apply, LinearMap.coe_comp, Function.comp_apply,
      weightedHomogeneousSubmodule_smul_mem_same w m,
      weightedHomogeneousSubmodule_smul_mem_same w n, Submodule.mul_mem_mul]
  · rw [← LinearMap.mem_range]
    exact ⟨_, rfl⟩

Repaired Proof:
theorem weightedHomogeneousSubmodule_mul (w : σ → M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ≤
      weightedHomogeneousSubmodule R w (m + n) ⊓ LinearMap.range (lsingle R w) := by
  rintro _ ⟨φ, ψ, hφ, hψ, rfl⟩
  rw [← lsingle_mul_single, mul_comm, LinearMap.mul_apply, LinearMap.mem_range]
  refine ⟨?_, ⟨_, rfl⟩⟩
  · rintro ⟨x, rfl⟩
    simp_rw [lsingle_apply, LinearMap.coe_comp, Function.comp_apply,
      weightedHomogeneousSubmodule_smul_mem_same w m,
      weightedHomogeneousSubmodule_smul_mem_same w n, Submodule.mul_mem_mul]
  · rw [← LinearMap.mem_range]
    exact ⟨_, rfl⟩

Repaired Proof:
theorem weightedHomogeneousSubmodule_mul (w : σ → M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ≤
      weightedHomogeneousSubmodule R w (m + n) ⊓ LinearMap.range (lsingle R w) := by
  rintro _ ⟨φ, ψ, hφ, hψ, rfl⟩
  rw [← lsingle_mul_single, mul_comm, LinearMap.mul_apply, LinearMap.mem_range]
  refine ⟨?_, ⟨_, rfl⟩⟩
  · rintro ⟨x, rfl⟩
    simp_rw [lsingle_apply, LinearMap.coe_comp, Function.comp_apply,
      weightedHomogeneousSubmodule_smul_mem_same w m,
      weightedHomogeneousSubmodule_smul_mem_same w n, Submodule.mul_mem_mul]
  · rw [← LinearMap.mem_range]
    exact ⟨_, rfl⟩

Repaired Proof:
theorem weightedHomogeneousSubmodule_mul (w : σ → M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ≤
      weightedHomogeneousSubmodule R w (m + n) ⊓ LinearMap.range (lsingle R w) := by
  rintro _ 

Attempt failure.

Working on Mathlib/RingTheory/Nakayama.lean - 2024-09-09 02:04:49.263272.
---175/200---
For theorem Submodule.sup_eq_sup_smul_of_le_smul_of_le_jacobson in Mathlib/RingTheory/Nakayama.lean:
theorem sup_eq_sup_smul_of_le_smul_of_le_jacobson {I J : Ideal R} {N N' : Submodule R M}
    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ N' = N ⊔ J • N' 


Original valid proof:
:= by
  have hNN' : N ⊔ N' = N ⊔ I • N' :=
    le_antisymm (sup_le le_sup_left hNN)
    (sup_le_sup_left (Submodule.smul_le.2 fun _ _ _ => Submodule.smul_mem _ _) _)
  have h_comap := Submodule.comap_injective_of_surjective (LinearMap.range_eq_top.1 N.range_mkQ)
  have : (I • N').map N.mkQ = N'.map N.mkQ := by
    simpa only [← h_comap.eq_iff, comap_map_mkQ, sup_comm, eq_comm] using hNN'
  have :=
    @Submodule.eq_smul_of_le_smul_of_le_jacobson _ _ _ _ _ I J (N'.map N.mkQ) (hN'.map _)
      (by rw [← map_smul'', this]) hIJ
  rwa [← map_smul'', ← h_comap.eq_iff, comap_map_eq, comap_map_eq, Submodule.ker_mkQ, sup_comm,
    sup_comm (b := N)] at this


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
⊔ I • N' := by
  refine le_antisymm (le_sup_right.trans (sup_le_sup_left ?_ _)) ?_
  · rw [← Submodule.span_eq N']
    refine Submodule.span_mono (fun x hx ↦ ?_)
    have : x ∈ N ⊔ I • N' := hNN hx
    rcases Submodule.mem_sup.1 this with ⟨y, hy, z, hz, rfl⟩
    exact Submodule.mem_sup.2 ⟨y, hy, J • z, smul_mem_smul_of_mem_jacobson_right hIJ hz, (add_zero y).symm⟩
  refine sup_induction (fun x hx ↦ ?_) (fun x hx y hy ↦ ?_)
  · rcases Submodule.mem_sup.1 hx with ⟨x, hxN, x', hx'N', rfl⟩
    refine le_trans ?_ (le_sup_left.trans (le_sup_right.trans ?_))
    · rw [add_smul, add_assoc, add_le_add_iff_left, ← smul_assoc, ← smul_assoc,
        smul_eq_mul, smul_eq_mul, mul_comm]
      exact Submodule.smul_mem_smul hxN' hxN
    · rw [← add_smul]
      exact Submodule.smul_mem_smul_of_mem_left hx'N' (hIJ hxN)
  · rcases Submodule.mem_sup.1 hx with ⟨x, hxN, x', hx'N', rfl⟩
    rcases Submodule.mem_sup.1 hy with ⟨y, hyN, y', hy'N', rfl⟩
    refine le_trans ?_ (le_sup_left.trans (le_sup_right.trans ?_))
    · rw [add_smul, add_assoc, add_le_add_iff_left, ← smul_assoc, ← smul_assoc,
        smul_eq_mul, smul_eq_mul, mul_comm]
      exact Submodule.smul_mem_smul (Submodule.add_mem _ hxN hyN) hx'N'
    · rw [← add_smul]
      exact Submodule.smul_mem_smul_of_mem_left hx'N' (hIJ (Submodule.add_mem _ hxN hyN))

Repaired Proof:
theorem sup_eq_sup_smul_of_le_smul_of_le_jacobson {I J : Ideal R} {N N' : Submodule R M}
    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ N' = N ⊔ J • N' ⊔ I • N' := by
  refine le_antisymm (le_sup_right.trans (sup_le_sup_left ?_ _)) ?_
  · rw [← Submodule.span_eq N']
    refine Submodule.span_mono (fun x hx ↦ ?_)
    have : x ∈ N ⊔ I • N' := hNN hx
    rcases Submodule.mem_sup.1 this with ⟨y, hy, z, hz, rfl⟩
    exact Submodule.mem_sup.2 ⟨y, hy, J • z, smul_mem_smul_of_mem_jacobson_right hIJ hz, (add_zero y).symm⟩
  refine sup_induction (fun x hx ↦ ?_) (fun x hx y hy ↦ ?_)
  · rcases Submodule.mem_sup.1 hx with ⟨x, hxN, x', hx'N', rfl⟩
    refine le_trans ?_ (le_sup_left.trans (le_sup_right.trans ?_))
    · rw [add_smul, add_assoc, add_le_add_iff_left, ← smul_assoc, ← smul_assoc,
        smul_eq_mul, smul_eq_mul, mul_comm]
      exact Submodule.smul_mem_smul hxN' hxN
    · rw [← add_smul]
      exact Submodule.smul_mem_smul_of_mem_left hx'N' (hIJ hxN)
  · rcases Submodule.mem_sup.1 hx with ⟨x, hxN, x', hx'N', rfl⟩
    rcases Submodule.mem_sup.1 hy with ⟨y, hyN, y', hy'N', rfl⟩
    refine le_trans ?_ (le_sup_left.trans (le_sup_right.trans ?_))
    · rw [add_smul, add_assoc, add_le_add_iff_left, ← smul_assoc, ← smul_assoc,
        smul_eq_mul, smul_eq_mul, mul_comm]
      exact Submodule.smul_mem_smul (Submodule.add_mem _ hxN hyN) hx'N'
    · rw [← add_smul]
      exact Submodule.smul_mem_smul_of_mem_left hx'N' (hIJ (Submodule.add_mem _ hxN hyN))

Repaired Proof:
theorem sup_eq_sup_smul_of_le_smul_of_le_jacobson {I J : Ideal R} {N N' : Submodule R M}
    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ N' = N ⊔ J • N' ⊔ I • N' := by
  refine le_antisymm (le_sup_right.trans (sup_le_sup_left ?_ _)) ?_
  · rw [← Submodule.span_eq N']
    refine Submodule.span_mono (fun x hx ↦ ?_)
    have : x ∈ N ⊔ I • N' := hNN hx
    rcases Submodule.mem_sup.1 this with ⟨y, hy, z, hz, rfl⟩
    exact Submodule.mem_sup.2 ⟨y, hy, J • z, smul_mem_smul_of_mem_jacobson_right hIJ hz, (add_zero y).symm⟩
  refine sup_induction (fun x hx ↦ ?_) (fun x hx y hy ↦ ?_)
  · rcases Submodule.mem_sup.1 hx with ⟨x, hxN, x', hx'N', rfl⟩
    refine le_trans ?_ (le_sup_left.trans (le_sup_right.trans ?_))
    · rw [add_smul, add_assoc, add_le_add_iff_left, ← smul_assoc, ← smul_assoc,
        smul_eq_mul, smul_eq_mul, mul_comm]
      exact Submodule.smul_mem_smul hxN' hxN
    · rw [← add_smul]
      exact Submodule.smul_mem_smul_of_mem_left hx'N' (hIJ hxN)
  · rcases Submodule.mem_sup.1 hx with ⟨x, hxN, x', hx'N', rfl⟩
    rcases Submodule.mem_sup.1 hy with ⟨y, hyN, y', hy'N', rfl⟩
    refine le_trans ?_ (le_sup_left.trans (le_sup_right.trans ?_))
    · rw [add_smul, add_assoc, add_le_add_iff_left, ← smul_assoc, ← smul_assoc,
        smul_eq_mul, smul_eq_mul, mul_comm]
      exact Submodule.smul_mem_smul (Submodule.add_mem _ hxN hyN) hx'N'
    · rw [← add_smul]
      exact Submodule.smul_mem_smul_of_mem_left hx'N' (hIJ (Submodule.add_mem _ hxN hyN))

Repaired Proof:
theorem sup_eq_sup_smul_of_le_smul_of_le_jacobson {I J

Attempt failure.

Working on Mathlib/RingTheory/Noetherian.lean - 2024-09-09 02:05:05.434427.
---176/200---
For theorem IsNoetherian.disjoint_partialSups_eventually_bot in Mathlib/RingTheory/Noetherian.lean:
theorem IsNoetherian.disjoint_partialSups_eventually_bot
    (f : ℕ → Submodule R M) (h : ∀ n, Disjoint (partialSups f n) (f (n + 1))) :
    ∃ n : ℕ, ∀ m, n ≤ m → f m = ⊥ 


Original valid proof:
:= by
  suffices t : ∃ n : ℕ, ∀ m, n ≤ m → f (m + 1) = ⊥ by
    obtain ⟨n, w⟩ := t
    use n + 1
    rintro (_ | m) p
    · cases p
    · apply w
      exact Nat.succ_le_succ_iff.mp p
  obtain ⟨n, w⟩ := monotone_stabilizes_iff_noetherian.mpr inferInstance (partialSups f)
  exact
    ⟨n, fun m p =>
      (h m).eq_bot_of_ge <| sup_eq_left.1 <| (w (m + 1) <| le_add_right p).symm.trans <| w m p⟩


Verifying proof (Commit 36094f2e079ab7eca97a3a7d838765b192471a71):
∧ ∀ k, k ≤ m → partialSups f k = partialSups f m := by
  obtain ⟨n, hn⟩ := IsNoetherian.monotone_stabilizes (partialSups f)
  refine' ⟨n, fun m hnm ↦ ⟨_, fun k hkm ↦ _⟩⟩
  · have : partialSups f m ≤ partialSups f n := hn hnm
    refine' eq_bot_iff.2 (le_trans this fun x hx ↦ _)
    obtain ⟨k, rfl⟩ := hn.1 hx
    exact (h k).le_bot ⟨k.le_add_right _, hkm⟩
  · exact hn.2 hkm

Repaired Proof:
theorem IsNoetherian.disjoint_partialSups_eventually_bot
    (f : ℕ → Submodule R M) (h : ∀ n, Disjoint (partialSups f n) (f (n + 1))) :
    ∃ n : ℕ, ∀ m, n ≤ m → f m = ⊥ ∧ ∀ k, k ≤ m → partialSups f k = partialSups f m := by
  obtain ⟨n, hn⟩ := IsNoetherian.monotone_stabilizes (partialSups f)
  refine ⟨n, fun m hnm ↦ ⟨?_, fun k hkm ↦ ?_⟩⟩
  · have : partialSups f m ≤ partialSups f n := hn hnm
    refine eq_bot_iff.2 (le_trans this fun x hx ↦ ?_)
    obtain ⟨k, rfl⟩ := hn.1 hx
    exact (h k).le_bot ⟨k.le_add_right _, hkm⟩
  · exact hn.2 hkm

Repaired Proof:
theorem IsNoetherian.disjoint_partialSups_eventually_bot
    (f : ℕ → Submodule R M) (h : ∀ n, Disjoint (partialSups f n) (f (n + 1))) :
    ∃ n : ℕ, ∀ m, n ≤ m → f m = ⊥ ∧ ∀ k, k ≤ m → partialSups f k = partialSups f m := by
  obtain ⟨n, hn⟩ := IsNoetherian.monotone_stabilizes (partialSups f)
  refine ⟨n, fun m hnm ↦ ⟨?_, fun k hkm ↦ ?_⟩⟩
  · have : partialSups f m ≤ partialSups f n := hn hnm
    refine eq_bot_iff.2 (le_trans this fun x hx ↦ ?_)
    obtain ⟨k, rfl⟩ := hn.1 hx
    exact (h k).le_bot ⟨k.le_add_right _, hkm⟩
  · exact hn.2 hkm

Repaired Proof:
theorem IsNoetherian.disjoint_partialSups_eventually_bot
    (f : ℕ → Submodule R M) (h : ∀ n, Disjoint (partialSups f n) (f (n + 1))) :
    ∃ n : ℕ, ∀ m, n ≤ m → f m = ⊥ ∧ ∀ k, k ≤ m → partialSups f k = partialSups f m := by
  obtain ⟨n, hn⟩ := IsNoetherian.monotone_stabilizes (partialSups f)
  refine ⟨n, fun m hnm ↦ ⟨?_, fun k hkm ↦ ?_⟩⟩
  · have : partialSups f m ≤ partialSups f n := hn hnm
    refine eq_bot_iff.2 (le_trans this fun x hx ↦ ?_)
    obtain ⟨k, rfl⟩ := hn.1 hx
    exact (h k).le_bot ⟨k.le_add_right _, hkm⟩
  · exact hn.2 hkm

Repaired Proof:
theorem IsNoetherian.disjoint_partialSups_eventually_bot
    (f : ℕ → Submodule R M) (h : ∀ n, Disjoint (partialSups f n) (f (n + 1))) :
    ∃ n : ℕ, ∀ m, n ≤ m → f m = ⊥ ∧ ∀ k, k ≤ m → partialSups f k = partialSups f m := by
  obtain ⟨n, hn⟩ := IsNoetherian.monotone_stabilizes (partialSups f)
  refine ⟨n, fun m hnm ↦ ⟨?_, fun k hkm ↦ ?_⟩⟩
  · have : partialSups f m ≤ partialSups f n := hn hnm
    refine eq_bot_iff.2 (le_trans this fun x hx ↦ ?_)
    obtain ⟨k, rfl⟩ := hn.1 hx
    exact (h k).le_bot ⟨k.le_add_right _, hkm⟩
  · exact hn.2 hkm

Repaired Proof:
theorem IsNoetherian.disjoint_partialSups_eventually_bot
    (f : ℕ → Submodule R M) (h : ∀ n, Disjoint (partialSups f n) (f (n + 1))) :
    ∃ n : ℕ, ∀ m, n ≤ m → f m = ⊥ ∧ ∀ k, k ≤ m → partialSups f k = partialSups f m := by
  obtain ⟨n, hn⟩ := IsNoetherian.monotone_stabilizes (partialSups f)
  refine ⟨n, fun m hnm ↦ ⟨?_, fun k hkm ↦ ?_⟩⟩
  · have : partialSups f m ≤ partialSups f n := hn hnm
    refine eq_bot_iff.2 (le_trans this fun x hx ↦ ?_)
    obtain ⟨k, rfl⟩ := hn.1 hx
    exact (h k).le_bot ⟨k.le_add_right _, hkm⟩
  · exact hn.2 hkm

Repaired Proof:
theorem IsNoetherian.disjoint_partialSups_eventually_bot
    (f : ℕ → Submodule R M) (h : ∀ n, Disjoint (partialSups f n) (f (n + 1))) :
    ∃ n : ℕ, ∀ m, n ≤ m → f m = ⊥ ∧ ∀ k, k ≤ m → partialSups f k = partialSups f m := by
  obtain ⟨n, hn⟩ := IsNoetherian.monotone_stabilizes (partialSups f)
  refine ⟨n, fun m hnm ↦ ⟨?_, fun k hkm ↦ ?_⟩⟩
  · have : partialSups f m ≤ partialSups f n := hn hnm
    refine eq_bot_iff.2 (le_trans this fun x hx ↦ ?_)
    obtain ⟨k, rfl⟩ := hn.1 hx
    exact (h k).le_bot ⟨k.le_add_right _, hkm⟩
  · exact hn.2 hkm

Repaired Proof:
theorem IsNoetherian.disjoint_partialSups_eventually_bot
    (f : ℕ → Submodule R M) (h : ∀ n, Disjoint (partialSups f n) (f (n + 1))) :
    ∃ n : ℕ, ∀ m, n ≤ m → f m = ⊥ ∧ ∀ k, k ≤ m → partialSups f k = partialSups f m := by
  obtain ⟨n, hn⟩ := IsNoetherian.monotone_stabilizes (partialSups f)
  refine ⟨n, fun m hnm ↦ ⟨?_, fun k hkm ↦ ?_⟩⟩
  · have : partialSups f m ≤ partialSups f n := hn hnm
    refine eq_bot_iff.2 (le_trans this fun x hx

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean - 2024-09-09 02:05:26.055159.
---177/200---
For theorem IsPrimitiveRoot.minpoly_dvd_cyclotomic in Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean:
theorem _root_.IsPrimitiveRoot.minpoly_dvd_cyclotomic {n : ℕ} {K : Type*} [Field K] {μ : K}
    (h : IsPrimitiveRoot μ n) (hpos : 0 < n) [CharZero K] : minpoly ℤ μ ∣ cyclotomic n ℤ 


Original valid proof:
:= by
  apply minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos)
  simpa [aeval_def, eval₂_eq_eval_map, IsRoot.def] using h.isRoot_cyclotomic hpos


Verifying proof (Commit 4968eba95a704a4a58e8b3735dc3733ee6d46c0d):
↔
      n = 2 ∨ 3 ≤ n ∨ ∃ p : ℕ, n = p * 2 ∧ 3 ≤ p := by
  refine ⟨fun hdvd => ?_, fun hn => ?_⟩
  · rcases h.isUnit_iff_pos.1 (IsPrimitiveRoot.isUnit_iff.2 hpos) with ⟨u, rfl⟩
    have hspec : minpoly ℤ (u : K) = (minpoly ℤ u).map (algebraMap ℤ K) := minpoly.isIntegrallyClosed_eq_field_fractions' ℤ u
    rw [hspec, ← minpoly.isIntegrallyClosed_eq_field_fractions' ℤ u] at hdvd
    have hspec' : cyclotomic n ℤ = (cyclotomic n K).map (algebraMap ℤ K) := by
      rw [cyclotomic.eq_prod_X_sub_primitiveRoots hpos, ← IsPrimitiveRoot.coe_map_inv_eq_one h,
        cyclotomic.eq_prod_X_sub_primitiveRoots (IsPrimitiveRoot.pos_of_isUnit h (u : K).isUnit),
        map_prod (algebraMap ℤ K) (fun x => X - C x) (fun x _ => IsPrimitiveRoot.coe_map_inv_eq_one h)]
    rw [hspec', Polynomial.map_dvd (algebraMap ℤ K)] at hdvd
    rcases hdvd with ⟨P, hP⟩
    rw [← Polynomial.map_mul] at hP
    have : (P * (cyclotomic n K)).eval 1 = 0 := by
      rw [hP, eval_mul, eval_sub, eval_X, eval_C, sub_self, zero_mul]
    have hroot : IsRoot (cyclotomic n K) 1 := by
      rw [cyclotomic.eval_one n K, IsRoot.def, eq_intCast, Int.cast_id, sub_self]
    have hroot' : IsRoot P 1 := by
      rwa [IsRoot.def, ← eval_mul, mul_comm, eval_mul, eval_sub, eval_X, eval_C, sub_self, mul_eq_zero] at this
    rcases hn with (rfl | rfl | ⟨p, rfl, -⟩)
    · rw [cyclotomic_two, ← @ofReal_inj ℂ, ofReal_sub, ofReal_one, ofReal_zero, ofReal_mul,
        ofReal_pow, ofReal_neg, ofReal_one] at hroot
      simp only [ofReal_intCast, ofReal_zero, ofReal_one, mul_neg_one, mul_one, sub_neg_eq_add,
        add_left_neg, eval_X, eval_one, eq_self_iff_true, and_true_iff] at hroot
      exact Or.inl rfl
    · rw [cyclotomic_three, ← @ofReal_inj ℂ, ofReal_sub, ofReal_one, ofReal_zero, ofReal_add,
        ofReal_mul, ofReal_neg, ofReal_one, ofReal_zero, ofReal_add, ofReal_one, ofReal_zero,
        ofReal_mul, ofReal_neg, ofReal_one, ofReal_zero, ofReal_add, ofReal_one, ofReal_zero] at hroot
      simp only [ofReal_intCast, ofReal_zero, ofReal_one, add_zero, mul_neg_one, mul_one,
        sub_neg_eq_add, add_left_neg, eq_self_iff_true, and_true_iff] at hroot
      exact Or.inr (Or.inl rfl)
    · haveI : NeZero p := ⟨hn.2.1.ne'⟩
      have hspec'' : cyclotomic (p * 2) ℤ = (cyclotomic (p * 2) ℚ).map (algebraMap ℤ ℚ) := by
        rw [cyclotomic.eq_prod_X_sub_primitiveRoots (mul_pos hpos (NeZero.pos p)),
          IsPrimitiveRoot.coe_map_inv_eq_one h,
          cyclotomic.eq_prod_X_sub_primitiveRoots (IsPrimitiveRoot.pos_of_isUnit h (u : K).isUnit),
          map_prod (algebraMap ℤ ℚ) (fun x => X - C x) fun x _ => IsPrimitiveRoot.coe_map_inv_eq_one h]
      rw [hspec'', ← Polynomial.map_mul] at hP
      have : (P * (cyclotomic (p * 2) ℚ)).eval 1 = 0 := by
        rw [hP, eval_mul, eval_sub, eval_X, eval_C, sub_self, zero_mul]
      have hroot' : IsRoot P 1 := by
        rwa [IsRoot.def, ← eval_mul, mul_comm, eval_mul, eval_sub, eval_X, eval_C, sub_self, mul_eq_zero] at this
      have hroot'' : IsRoot (cyclotomic (p * 2) ℚ) 1 := by
        rw [cyclotomic.eval_one (mul_pos hpos (NeZero.pos p)), IsRoot.def, eq_intCast, Int.cast_id,
          sub_self]
      rcases (cyclotomic_eq_geom_sum (p * 2) K).symm ▸ hroot'' with ⟨n, hn', hsum⟩
      have hroot''' : IsRoot (∑ i ∈ Finset.range (p * 2), (1 : ℚ[X]) ^ i) 1 := by
        rw [IsRoot.def, eval_sum, sum_eq_zero_iff, Finset.mem_range]
        intro i hi
        rw [eval_pow, eval_one, one_pow]
      have hroot'''' : IsRoot (∑ i ∈ Finset.range n, (1 : ℚ[X]) ^ i) 1 := by
        rw [← hsum, IsRoot.def, eval_sum, sum_eq_zero_iff, Finset.mem_range] at hroot'''
        intro i hi
        rw [eval_pow, eval_one, one_pow]
      rcases (geom_sum_eq hn'.ne').symm ▸ hroot'''' with ⟨m, hm, hsum'⟩
      rw [hsum', IsRoot.def, eval_mul, eval_sub, eval_pow, eval_X, eval_one, one_pow, sub_self,
        mul_eq_zero] at this
      cases this with
      | inl h =>
        rw [hm, mul_comm, mul_assoc, mul_left_inj' hn'.ne', mul_comm, mul_assoc,
          mul_left_inj' hn.ne', mul_eq_zero] at h
        cases h with
        | inl h =>
          left
          rw [hm, mul_comm, mul_assoc, mul_left_inj' hn.ne', mul_comm, mul_assoc,
            mul_left_inj' hn'.ne', eq_comm, ← Nat.cast_inj (R := ℚ), Nat.cast_mul, Nat.cast_mul,
            Nat.cast_one, mul_inv_cancel hn.ne', mul_inv_cancel hn'.ne', one_mul] at h
          exact ⟨_, h⟩
        | inr h =>
          right
          rw [hm, mul_comm, mul_assoc, mul_left_inj' hn.ne', mul_comm, mul_assoc,
            mul_left_inj' hn'.ne', eq_comm, ← Nat.cast_inj (R := ℚ), Nat.cast_mul, Nat.cast_mul,
            Nat.cast_one, mul_inv_cancel hn.ne', mul_inv_cancel hn'.ne', one_mul] at h
          exact ⟨_, h⟩
      | inr h =>
        rw [hm, mul_comm, mul_assoc, mul_left_inj' hn'.ne', mul_comm, mul_assoc,
          mul_left_inj' hn.ne', mul_eq_zero] at h
        cases h with
        | inl h =>
          left
          rw [hm, mul_comm, mul_assoc, mul_left_inj' hn.ne', mul_comm, mul_assoc,
            mul_left_inj' hn'.ne', eq_comm, ← Nat.cast_inj (R := ℚ), Nat.cast_mul, Nat.cast_mul,
            Nat.cast_

Attempt failure.

Working on Mathlib/RingTheory/RingHom/Finite.lean - 2024-09-09 02:05:35.503774.
---178/200---
For theorem RingHom.finite_stableUnderBaseChange in Mathlib/RingTheory/RingHom/Finite.lean:
theorem finite_stableUnderBaseChange : StableUnderBaseChange @Finite 


Original valid proof:
:= by
  refine StableUnderBaseChange.mk _ finite_respectsIso ?_
  classical
  introv h
  replace h : Module.Finite R T := by
    rw [RingHom.Finite] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl
  suffices Module.Finite S (S ⊗[R] T) by
    rw [RingHom.Finite]; convert this; congr; ext; simp_rw [Algebra.smul_def]; rfl
  exact inferInstance


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
𝒜 := fun _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

Attempt failure.

Working on Mathlib/RingTheory/UniqueFactorizationDomain.lean - 2024-09-09 02:20:01.649399.
---179/200---
For theorem UniqueFactorizationMonoid.induction_on_prime_power in Mathlib/RingTheory/UniqueFactorizationDomain.lean:
theorem induction_on_prime_power {P : α → Prop} (s : Finset α) (i : α → ℕ)
    (is_prime : ∀ p ∈ s, Prime p) (is_coprime : ∀ᵉ (p ∈ s) (q ∈ s), p ∣ q → p = q)
    (h1 : ∀ {x}, IsUnit x → P x) (hpr : ∀ {p} (i : ℕ), Prime p → P (p ^ i))
    (hcp : ∀ {x y}, IsRelPrime x y → P x → P y → P (x * y)) :
    P (∏ p ∈ s, p ^ i p) 


Original valid proof:
:= by
  letI := Classical.decEq α
  induction' s using Finset.induction_on with p f' hpf' ih
  · simpa using h1 isUnit_one
  rw [Finset.prod_insert hpf']
  exact
    hcp (prime_pow_coprime_prod_of_coprime_insert i p hpf' is_prime is_coprime)
      (hpr (i p) (is_prime _ (Finset.mem_insert_self _ _)))
      (ih (fun q hq => is_prime _ (Finset.mem_insert_of_mem hq)) fun q hq q' hq' =>
        is_coprime _ (Finset.mem_insert_of_mem hq) _ (Finset.mem_insert_of_mem hq'))


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
∧ ∀ p ∈ s, ∀ (j : ℕ), j ≠ i p → P (∏ p ∈ s, p ^ j) := by
  classical
    induction' s using Finset.induction_on with p s hp ih
    · refine ⟨h1 isUnit_one, fun p => False.elim ∘ not_mem_empty p⟩
    obtain ⟨i, rfl⟩ : ∃ i, s = {p} ^ i := by
      have : ∀ p ∈ s, ∃ i, p = {p} ^ i := fun p hp ↦
        induction_on_prime_power {p} (fun q ↦ q) (fun q hq ↦ is_prime q (mem_singleton.1 hq))
          (fun _ _ _ _ ↦ Subsingleton.elim _ _) (h1 isUnit_one) (hpr _) (hcp _ _)
      choose i hi using this
      have : ∀ p ∈ s, ∀ q ∈ s, i p = i q := fun p hp q hq ↦
        is_coprime p q (dvd_of_mem_pow hp) (dvd_of_mem_pow hq) ▸ congr_arg i (hi p hp).trans (hi q hq).symm
      refine ⟨funext this, fun q hq ↦ ?_⟩
      obtain rfl | hqp : q = p ∨ q ≠ p := eq_or_ne _ _
      · rw [hi _ hq, pow_succ, mul_comm, ← pow_succ, ← hi _ hq]
      · have : ∀ j, j ≠ i p → ∏ p ∈ s, p ^ j = 1 := fun j hj ↦
          (is_coprime _ _ (dvd_of_mem_pow hq) (not_dvd_of_ne hj)).symm ▸ one_pow _
        rw [hi _ hq, this (i p), one_mul]
    rw [prod_insert hp, prod_pow_eq_pow_sum, sum_singleton]
    have : ∀ j, j ≠ i p → ∏ p ∈ s, p ^ j = 1 := fun j hj ↦
      (is_coprime _ _ (dvd_of_mem_pow (mem_insert_of_mem _ (mem_singleton_self _)))
        (not_dvd_of_ne hj)).symm ▸ one_pow _
    obtain ⟨hP, hP'⟩ := ih
    refine ⟨hcp (isRelPrime_of_prime_dvd (is_prime _ <| mem_insert_self _ _)
      (is_prime _ <| mem_insert_of_mem <| mem_singleton_self _) (dvd_of_mem_pow <| mem_insert_self _ _))
        (hpr <| i p) hP fun j hj ↦ ?_, fun q hq j hj ↦ ?_⟩
    · rw [this j hj, mul_one]
    · rw [this j hj, mul_one]
    rw [hP' q (mem_insert_of_mem <| mem_singleton_self _) (i q), ← pow_succ, ← pow_succ']
    refine hcp ?_ (hpr <| i p + 1) (hpr <| i q + 1)
    rw [isRelPrime_iff_pairwise]
    exact (pairwise_insert_of_symmetric is_coprime (symmetric_pow _)).2 fun r hr ↦
      is_coprime _ _ (dvd_of_mem_pow <| mem_insert_of_mem <| mem_singleton_self _)
        (dvd_of_mem_pow (mem_insert_of_mem <| mem_singleton_self _))

Repaired Proof:
theorem induction_on_prime_power {P : α → Prop} (s : Finset α) (i : α → ℕ)
    (is_prime : ∀ p ∈ s, Prime p) (is_coprime : ∀ᵉ (p ∈ s) (q ∈ s), p ∣ q → p = q)
    (h1 : ∀ {x}, IsUnit x → P x) (hpr : ∀ {p} (i : ℕ), Prime p → P (p ^ i))
    (hcp : ∀ {x y}, IsRelPrime x y → P x → P y → P (x * y)) :
    P (∏ p ∈ s, p ^ i p) ∧ ∀ p ∈ s, ∀ (j : ℕ), j ≠ i p → P (∏ p ∈ s, p ^ j) := by
  classical
    induction' s using Finset.induction_on with p s hp ih
    · refine ⟨h1 isUnit_one, fun p => False.elim ∘ not_mem_empty p⟩
    obtain ⟨i, rfl⟩ : ∃ i, s = {p} ^ i := by
      have : ∀ p ∈ s, ∃ i, p = {p} ^ i := fun p hp ↦
        induction_on_prime_power {p} (fun q ↦ q) (fun q hq ↦ is_prime q (mem_singleton.1 hq))
          (fun _ _ _ _ ↦ Subsingleton.elim _ _) (h1 isUnit_one) (hpr _) (hcp _ _)
      choose i hi using this
      have : ∀ p ∈ s, ∀ q ∈ s, i p = i q := fun p hp q hq ↦
        is_coprime p q (dvd_of_mem_pow hp) (dvd_of_mem_pow hq) ▸ congr_arg i (hi p hp).trans (hi q hq).symm
      refine ⟨funext this, fun q hq ↦ ?_⟩
      obtain rfl | hqp : q = p ∨ q ≠ p := eq_or_ne _ _
      · rw [hi _ hq, pow_succ, mul_comm, ← pow_succ, ← hi _ hq]
      · have : ∀ j, j ≠ i p → ∏ p ∈ s, p ^ j = 1 := fun j hj ↦
          (is_coprime _ _ (dvd_of_mem_pow hq) (not_dvd_of_ne hj)).symm ▸ one_pow _
        rw [hi _ hq, this (i p), one_mul]
    rw [prod_insert hp, prod_pow_eq_pow_sum, sum_singleton]
    have : ∀ j, j ≠ i p → ∏ p ∈ s, p ^ j = 1 := fun j hj ↦
      (is_coprime _ _ (dvd_of_mem_pow (mem_insert_of_mem _ (mem_singleton_self _)))
        (not_dvd_of_ne hj)).symm ▸ one_pow _
    obtain ⟨hP, hP'⟩ := ih
    refine ⟨hcp (isRelPrime_of_prime_dvd (is_prime _ <| mem_insert_self _ _)
        (is_prime _ <| mem_insert_of_mem <| mem_singleton_self _) (dvd_of_mem_pow <| mem_insert_self _ _))
        (hpr <| i p) hP fun j hj ↦ ?_, fun q hq j hj ↦ ?_⟩
    · rw [this j hj, mul_one]
    · rw [this j hj, mul_one]
    rw [hP' q (mem_insert_of_mem <| mem_singleton_self _) (i q), ← pow_succ, ← pow_succ']
    refine hcp ?_ (hpr <| i p + 1) (hpr <| i q + 1)
    rw [isRelPrime_iff_pairwise]
    exact (pairwise_insert_of_symmetric is_coprime (symmetric_pow _)).2 fun r hr ↦
      is_coprime _ _ (dvd_of_mem_pow <| mem_insert_of_mem <| mem_singleton_self _)
        (dvd_of_mem_pow (mem_insert_of_mem <| mem_singleton_self _))

Repaired Proof:
theorem induction_on_prime_power {P : α → Prop} (s : Finset α) (i : α → ℕ)
    (is_prime : 

Attempt failure.

Working on Mathlib/RingTheory/WittVector/Isocrystal.lean - 2024-09-09 02:20:22.353896.
---180/200---
For theorem WittVector.isocrystal_classification in Mathlib/RingTheory/WittVector/Isocrystal.lean:
theorem isocrystal_classification (k : Type*) [Field k] [IsAlgClosed k] [CharP k p] (V : Type*)
    [AddCommGroup V] [Isocrystal p k V] (h_dim : finrank K(p, k) V = 1) :
    ∃ m : ℤ, Nonempty (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V) 


Original valid proof:
:= by
  haveI : Nontrivial V := FiniteDimensional.nontrivial_of_finrank_eq_succ h_dim
  obtain ⟨x, hx⟩ : ∃ x : V, x ≠ 0 := exists_ne 0
  have : Φ(p, k) x ≠ 0 := by simpa only [map_zero] using Φ(p, k).injective.ne hx
  obtain ⟨a, ha, hax⟩ : ∃ a : K(p, k), a ≠ 0 ∧ Φ(p, k) x = a • x := by
    rw [finrank_eq_one_iff_of_nonzero' x hx] at h_dim
    obtain ⟨a, ha⟩ := h_dim (Φ(p, k) x)
    refine ⟨a, ?_, ha.symm⟩
    intro ha'
    apply this
    simp only [← ha, ha', zero_smul]
  obtain ⟨b, hb, m, hmb⟩ := WittVector.exists_frobenius_solution_fractionRing p ha
  replace hmb : φ(p, k) b * a = (p : K(p, k)) ^ m * b := by convert hmb
  use m
  let F₀ : StandardOneDimIsocrystal p k m →ₗ[K(p, k)] V := LinearMap.toSpanSingleton K(p, k) V x
  let F : StandardOneDimIsocrystal p k m ≃ₗ[K(p, k)] V := by
    refine LinearEquiv.ofBijective F₀ ⟨?_, ?_⟩
    · rw [← LinearMap.ker_eq_bot]
      exact LinearMap.ker_toSpanSingleton K(p, k) V hx
    · rw [← LinearMap.range_eq_top]
      rw [← (finrank_eq_one_iff_of_nonzero x hx).mp h_dim]
      rw [LinearMap.span_singleton_eq_range]
  refine ⟨⟨(LinearEquiv.smulOfNeZero K(p, k) _ _ hb).trans F, fun c ↦ ?_⟩⟩
  rw [LinearEquiv.trans_apply, LinearEquiv.trans_apply, LinearEquiv.smulOfNeZero_apply,
    LinearEquiv.smulOfNeZero_apply, LinearEquiv.map_smul, LinearEquiv.map_smul]
  rw [LinearEquiv.ofBijective_apply, LinearEquiv.ofBijective_apply]
  erw [LinearMap.toSpanSingleton_apply K(p, k) V x c, LinearMap.toSpanSingleton_apply K(p, k) V x]
  simp only [hax, LinearEquiv.ofBijective_apply, LinearMap.toSpanSingleton_apply,
    LinearEquiv.map_smulₛₗ, StandardOneDimIsocrystal.frobenius_apply, Algebra.id.smul_eq_mul]
  simp only [← mul_smul]
  congr 1
  linear_combination φ(p, k) c * hmb


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∨
      Nonempty (StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V) := by
  haveI : FiniteDimensional k V := of_fintype_basis (isocrystalBasis k p V)
  haveI : FiniteDimensional k K(p, k) := of_fintype_basis (isocrystalBasis k p K(p, k))
  haveI : IsAlgClosed k := isAlgClosed_of_charP k p
  haveI : CharP k p := charP_of_injective_ringHom (IsAlgClosed.algebraMap_injective k K(p, k)) p
  haveI : IsAlgClosure k k := IsAlgClosure.of_isAlgClosed k
  haveI : IsAlgClosure k K(p, k) := IsAlgClosure.of_isAlgClosed K(p, k)
  haveI : IsAlgClosure k V := IsAlgClosure.of_isAlgClosed V
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k 0) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k 0)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k (-m)) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k (-m))
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m →ₗ[k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m →ₗ[k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k (-m) →ₗ[k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k (-m) →ₗ[k] V)
  haveI : IsAlgClosure k (V →ₗ[k] V) := IsAlgClosure.of_isAlgClosed (V →ₗ[k] V)
  haveI : IsAlgClosure k (V →ₗ[k] V) := IsAlgClosure.of_isAlgClosed (V →ₗ[k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V →ₗ[k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V →ₗ[k] V)
  haveI : IsAlgClosure k (V →ₗ[k] V) := IsAlgClosure.of_isAlgClosed (V →ₗ[k] V)
  haveI : IsAlgClosure k (V →ₗ[k] V) := IsAlgClosure.of_isAlgClosed (V →ₗ[k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V →ₗ[k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V →ₗ[k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V)
  haveI : IsAlgClosure k (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V ⊕
    StandardOneDimIsocrystal p k (-m) ≃ᶠ⁼[p, k] V) :=
    IsAlgClosure.of_isAlgClosed (StandardOneDimIsocrystal p k m �

Attempt failure.

Working on Mathlib/SetTheory/Cardinal/Basic.lean - 2024-09-09 02:20:34.902586.
---181/200---
For theorem Cardinal.aleph0_le in Mathlib/SetTheory/Cardinal/Basic.lean:
theorem aleph0_le_lift {c : Cardinal.{u}} : ℵ₀ ≤ lift.{v} c ↔ ℵ₀ ≤ c 


Original valid proof:
:= by
  rw [← lift_aleph0.{v, u}, lift_le]


Verifying proof (Commit f8dea2620ed854ca48ed31434fd52cc5ab2b6542):
∨ u = v := by
  rw [← lift_aleph0.{u,v}, lift_le, aleph0_le]
  simp only [lift_le, aleph0_le, or_iff_not_imp_left, not_le, ← Ne.eq_def, ← le_zero_eq]
  exact ⟨fun h => (h.trans_lt (nat_lt_aleph0 2)).ne, fun h => h ▸ le_rfl⟩

@[simp]
theorem lift_eq_aleph0 {c : Cardinal.{u}} : lift.{v} c = ℵ₀ ↔ c = ℵ₀ := by
  rw [lift_eq_nat_iff, nat_eq_aleph0, aleph0_le_aleph0, le_antisymm_iff, and_iff_left]
  rintro ⟨n, rfl⟩
  exact nat_lt_aleph0 n


theorem lift_mk_fin (n : ℕ) : lift #(Fin n) = n := rfl

@[simp]
theorem mk_punit : #PUnit = 1 :=
  mk_eq_one PUnit


@[simp]
theorem mk_plift_true : #(PLift True) = 1 :=
  mk_eq_one _


@[simp]
theorem mk_plift_false : #(PLift False) = 0 :=
  mk_eq_zero _


@[simp]
theorem mk_vector (α : Type u) (n : ℕ) : #(Vector α n) = #α ^ n :=
  (mk_congr (Equiv.vectorEquivFin α n)).trans <| by simp


@[simp]
theorem mk_list_eq_aleph0 (α : Type u) [Infinite α] : #(List α) = ℵ₀ :=
  mk_le_aleph0.antisymm <| aleph0_le_mk _


@[simp]
theorem mk_list_le_lift {α : Type u} : #(List α) ≤ lift.{v} #α ^ ℵ₀ := by
  rw [← mk_vector, ← mk_list_eq_max_mk, max_comm]
  exact mk_le_of_injective (Embedding.vector_to_list _)


@[simp]
theorem mk_list_eq_lift {α : Type u} [h : Infinite α] : #(List α) = lift.{v} #α ^ ℵ₀ :=
  (mk_list_le_lift.antisymm <|
        lift_mk_le.{u, 0, 1}.2 ⟨⟨fun a => [a], fun _ _ h => by
          simpa [List.singleton_eq_cons] using h⟩⟩).trans <|
    (mk_eq_of_injective _ fun _ _ => List.singleton_inj).symm ▸ mk_list_eq_aleph0 _


@[simp]
theorem mk_finset_of_infinite (α : Type u) [Infinite α] : #(Finset α) = ℵ₀ :=
  (mk_le_aleph0 _).antisymm <| aleph0_le_mk _


@[simp]
theorem mk_finsupp_lift_of_infinite {α : Type u} {β : Type v} [Zero β] [Infinite α] :
    #(α →₀ β) = lift.{u} #β ^ lift.{v} #α := by
  apply le_antisymm
  · calc
      #(α →₀ β) ≤ #(Finset (α × β)) := mk_le_of_injective (Finsupp.graph_injective α β)
      _ = #(Finset α × β) := mk_congr (Equiv.finsetProdEquivSigma _ _)
      _ = #(α × β) := mk_prod _ _
      _ = #β ^ #α := mk_prod_of_infinite _ _
      _ ≤ lift.{v} #β ^ lift.{u} #α :=
        (pow_le_pow_right <| lift_mk_le.{u, v, 1}.2 ⟨Embedding.refl _⟩)
  · calc
      lift.{v} #β ^ lift.{u} #α ≤ lift.{v} #β ^ ℵ₀ :=
        pow_le_pow_right (lift_mk_le.{u, v, 1}.2 ⟨Embedding.refl _⟩) (aleph0_le_mk _)
      _ = #(β →₀ ℕ) := (mk_finsupp_nat _ _).symm
      _ ≤ #(α →₀ β) := mk_le_of_injective (Finsupp.mapRange.embedding _ (0 : β)
        (by simp [zero_ne_one]))


@[simp]
theorem mk_finsupp_of_fintype [DecidableEq α] [Zero β] [Fintype α] : #(α →₀ β) = #β ^ Fintype.card α :=
  mk_finsupp_lift_of_infinite _ _


@[simp]
theorem mk_finsupp_lift_of_fintype [DecidableEq α] [Zero β] [Fintype α] [Fintype β] :
    #(α →₀ β) = lift.{max u w} #β ^ lift.{max v w} #α :=
  (mk_finsupp_lift_of_infinite _ _).trans <|
    congr_arg₂ _ (mk_eq_nat_card _) (mk_eq_nat_card _)


@[simp]
theorem mk_finsupp_of_fintype' [DecidableEq α] [Zero β] [Fintype α] [Fintype β] :
    #(α →₀ β) = #β ^ #α := by
  simpa using mk_finsupp_lift_of_fintype


@[simp]
theorem mk_finsupp_nat (α : Type u) : #(α →₀ ℕ) = #α ^ ℵ₀ :=
  mk_finsupp_lift_of_infinite _ _


@[simp]
theorem mk_finsupp_fin_add_nat (n : ℕ) (α : Type u) : #(Fin n →₀ α) = #α ^ ℵ₀ :=
  mk_finsupp_lift_of_fintype _ _


@[simp]
theorem mk_finsupp_fin_nat (n : ℕ) : #(Fin n →₀ ℕ) = ℵ₀ ^ ℵ₀ := by
  rw [mk_finsupp_fin_add_nat, mk_nat, power_def]


@[simp]
theorem mk_finsupp_eq_lift_of_infinite (α : Type u) (β : Type v) [Zero β] [Infinite α] [Infinite β] :
    #(α →₀ β) = lift.{u} #β ^ lift.{v} #α :=
  mk_finsupp_lift_of_infinite _ _


@[simp]
theorem mk_finsupp_eq_lift_of_fintype (α : Type u) (β : Type v) [DecidableEq α] [Fintype α]
    [Zero β] [Infinite β] : #(α →₀ β) = lift.{v} #β ^ Fintype.card α :=
  mk_finsupp_lift_of_fintype _ _


@[simp]
theorem mk_finsupp_eq_of_infinite (α : Type u) (β : Type v) [Zero β] [Infinite α] [Infinite β] :
    #(α →₀ β) = #β ^ #α :=
  mk_finsupp_eq_lift_of_infinite _ _


@[simp]
theorem mk_finsupp_eq_of_fintype (α : Type u) (β : Type v) [DecidableEq α] [Fintype α] [Zero β]
    [Infinite β] : #(α →₀ β) = #β ^ Fintype.card α :=
  mk_finsupp_eq_lift_of_fintype _ _


@[simp]
theorem mk_finsupp_eq_of_infinite' (α : Type u) (β : Type v) [Zero β] [Infinite α] [Infinite β] :
    #(α →₀ β) = #α ^ #β :=
  mk_finsupp_eq_lift_of_infinite _ _


@[simp]
theorem mk_finsupp_eq_of_fintype' (α : Type u) (β : Type v)

Attempt failure.

---182/200---
For theorem Cardinal.lift_le_aleph0 in Mathlib/SetTheory/Cardinal/Basic.lean:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ 


Original valid proof:
:= by
  rw [← lift_aleph0.{v, u}, lift_le]


Verifying proof (Commit f8dea2620ed854ca48ed31434fd52cc5ab2b6542):
∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ ∨ c < ℵ₀ := by
  by_cases h : c < ℵ₀
  · rcases lt_aleph0.1 h with ⟨n, rfl⟩
    rw [lift_natCast]
    norm_cast
  · simp only [not_lt] at h
    simp [h, lift_le_aleph0]

Repaired Proof:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ �

Attempt failure.

Working on Mathlib/SetTheory/Ordinal/Exponential.lean - 2024-09-09 02:20:54.418482.
---183/200---
For theorem Ordinal.opow_add in Mathlib/SetTheory/Ordinal/Exponential.lean:
theorem opow_add (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c 


Original valid proof:
:= by
  rcases eq_or_ne a 0 with (rfl | a0)
  · rcases eq_or_ne c 0 with (rfl | c0)
    · simp
    have : b + c ≠ 0 := ((Ordinal.pos_iff_ne_zero.2 c0).trans_le (le_add_left _ _)).ne'
    simp only [zero_opow c0, zero_opow this, mul_zero]
  rcases eq_or_lt_of_le (one_le_iff_ne_zero.2 a0) with (rfl | a1)
  · simp only [one_opow, mul_one]
  induction c using limitRecOn with
  | H₁ => simp
  | H₂ c IH =>
    rw [add_succ, opow_succ, IH, opow_succ, mul_assoc]
  | H₃ c l IH =>
    refine
      eq_of_forall_ge_iff fun d =>
        (((opow_isNormal a1).trans (add_isNormal b)).limit_le l).trans ?_
    dsimp only [Function.comp_def]
    simp (config := { contextual := true }) only [IH]
    exact
      (((mul_isNormal <| opow_pos b (Ordinal.pos_iff_ne_zero.2 a0)).trans
              (opow_isNormal a1)).limit_le
          l).symm


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
∧ (a ≠ 0 ∨ b ≠ 0) → a ^ (b + c) = a ^ b * a ^ c :=
    by
    rintro ⟨h, h'⟩
    rcases eq_or_ne a 0 with (rfl | h₀)
    · simp_all
    rcases eq_or_ne b 0 with (rfl | h₁)
    · simp_all
    rcases eq_or_ne c 0 with (rfl | h₂)
    · simp_all
    simp_all [opow_ne_zero]
  theorem opow_add' (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c :=
    if h : a = 0 ∧ b = 0 then by simp only [h.1, h.2, opow_zero, mul_one]
    else opow_add a b c ⟨opow_ne_zero _ h.1, h.2⟩

Repaired Proof:
theorem opow_add (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c ∧ (a ≠ 0 ∨ b ≠ 0) → a ^ (b + c) = a ^ b * a ^ c :=
    by
    rintro ⟨h, h'⟩
    rcases eq_or_ne a 0 with (rfl | h₀)
    · simp_all
    rcases eq_or_ne b 0 with (rfl | h₁)
    · simp_all
    rcases eq_or_ne c 0 with (rfl | h₂)
    · simp_all
    simp_all [opow_ne_zero]
  theorem opow_add' (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c :=
    if h : a = 0 ∧ b = 0 then by simp only [h.1, h.2, opow_zero, mul_one]
    else opow_add a b c ⟨opow_ne_zero _ h.1, h.2⟩

Repaired Proof:
theorem opow_add (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c ∧ (a ≠ 0 ∨ b ≠ 0) → a ^ (b + c) = a ^ b * a ^ c :=
    by
    rintro ⟨h, h'⟩
    rcases eq_or_ne a 0 with (rfl | h₀)
    · simp_all
    rcases eq_or_ne b 0 with (rfl | h₁)
    · simp_all
    rcases eq_or_ne c 0 with (rfl | h₂)
    · simp_all
    simp_all [opow_ne_zero]
  theorem opow_add' (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c :=
    if h : a = 0 ∧ b = 0 then by simp only [h.1, h.2, opow_zero, mul_one]
    else opow_add a b c ⟨opow_ne_zero _ h.1, h.2⟩

Repaired Proof:
theorem opow_add (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c ∧ (a ≠ 0 ∨ b ≠ 0) → a ^ (b + c) = a ^ b * a ^ c :=
    by
    rintro ⟨h, h'⟩
    rcases eq_or_ne a 0 with (rfl | h₀)
    · simp_all
    rcases eq_or_ne b 0 with (rfl | h₁)
    · simp_all
    rcases eq_or_ne c 0 with (rfl | h₂)
    · simp_all
    simp_all [opow_ne_zero]
  theorem opow_add' (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c :=
    if h : a = 0 ∧ b = 0 then by simp only [h.1, h.2, opow_zero, mul_one]
    else opow_add a b c ⟨opow_ne_zero _ h.1, h.2⟩

Repaired Proof:
theorem opow_add (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c ∧ (a ≠ 0 ∨ b ≠ 0) → a ^ (b + c) = a ^ b * a ^ c :=
    by
    rintro ⟨h, h'⟩
    rcases eq_or_ne a 0 with (rfl | h₀)
    · simp_all
    rcases eq_or_ne b 0 with (rfl | h₁)
    · simp_all
    rcases eq_or_ne c 0 with (rfl | h₂)
    · simp_all
    simp_all [opow_ne_zero]
  theorem opow_add' (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c :=
    if h : a = 0 ∧ b = 0 then by simp only [h.1, h.2, opow_zero, mul_one]
    else opow_add a b c ⟨opow_ne_zero _ h.1, h.2⟩

Repaired Proof:
theorem opow_add (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c ∧ (a ≠ 0 ∨ b ≠ 0) → a ^ (b + c) = a ^ b * a ^ c :=
    by
    rintro ⟨h, h'⟩
    rcases eq_or_ne a 0 with (rfl | h₀)
    · simp_all
    rcases eq_or_ne b 0 with (rfl | h₁)
    · simp_all
    rcases eq_or_ne c 0 with (rfl | h₂)
    · simp_all
    simp_all [opow_ne_zero]
  theorem opow_add' (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c :=
    if h : a = 0 ∧ b = 0 then by simp only [h.1, h.2, opow_zero, mul_one]
    else opow_add a b c ⟨opow_ne_zero _ h.1, h.2⟩

Repaired Proof:
theorem opow_add (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c ∧ (a ≠ 0 ∨ b ≠ 0) → a ^ (b + c) = a ^ b * a ^ c :=
    by
    rintro ⟨h, h'⟩
    rcases eq_or_ne a 0 with (rfl | h₀)
    · simp_all
    rcases eq_or_ne b 0 with (rfl | h₁)
    · simp_all
    rcases eq_or_ne c 0 with (rfl | h₂)
    · simp_all
    simp_all [opow_ne_zero]
  theorem opow_add' (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c :=
    if h : a = 0 ∧ b = 0 then by simp only [h.1, h.2, opow_zero, mul_one]
    else opow_add a b c ⟨opow_ne_zero _ h.1, h.2⟩

Repaired Proof:
theorem opow_add (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c ∧ (a ≠ 0 ∨ b ≠ 0) → a ^ (b + c) = a ^ b * a ^ c :=
    by
    rintro ⟨h, h'⟩
    rcases eq_or_ne a 0 with (rfl | h₀)
    · simp_all
    rcases eq_or_ne b 0 with (rfl | h₁)
    · simp_all
    rcases eq_or_ne c 0 with (rfl |

Attempt failure.

Working on Mathlib/SetTheory/Ordinal/FixedPoint.lean - 2024-09-09 02:21:00.230437.
---184/200---
For theorem Ordinal.derivFamily_fp in Mathlib/SetTheory/Ordinal/FixedPoint.lean:
theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :
    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o 


Original valid proof:
:= by
  induction' o using limitRecOn with o _ o l IH
  · rw [derivFamily_zero]
    exact nfpFamily_fp H 0
  · rw [derivFamily_succ]
    exact nfpFamily_fp H _
  · rw [derivFamily_limit _ l,
      IsNormal.bsup.{max u v, u, max u v} H (fun a _ => derivFamily f a) l.1]
    refine eq_of_forall_ge_iff fun c => ?_
    simp (config := { contextual := true }) only [bsup_le_iff, IH]


Verifying proof (Commit c959b2f950b9c44268e36bcedef976356855e6fb):
⊕' o := by
  rw [← IsNormal.bsup_eq.{u, v} H, derivFamily, derivFamilyAux]
  dsimp; rw [sup_eq_lsub_iff_lt_sup.{u, v}]
  rintro a ⟨b, hb, c, hc, rfl⟩
  cases' lt_or_le b o with hbo hbo
  · refine' ⟨_, Sum.inr c, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hc
    · exact le_rfl
  · refine' ⟨_, Sum.inl ⟨b, _⟩, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hb
    · exact hbo.trans (le_sup _ c)

Repaired Proof:
theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :
    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o ⊕' o := by
  rw [← IsNormal.bsup_eq.{u, v} H, derivFamily, derivFamilyAux]
  dsimp; rw [sup_eq_lsub_iff_lt_sup.{u, v}]
  rintro a ⟨b, hb, c, hc, rfl⟩
  cases' lt_or_le b o with hbo hbo
  · refine ⟨_, Sum.inr c, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hc
    · exact le_rfl
  · refine ⟨_, Sum.inl ⟨b, _⟩, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hb
    · exact hbo.trans (le_sup _ c)

Repaired Proof:
theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :
    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o ⊕' o := by
  rw [← IsNormal.bsup_eq.{u, v} H, derivFamily, derivFamilyAux]
  dsimp; rw [sup_eq_lsub_iff_lt_sup.{u, v}]
  rintro a ⟨b, hb, c, hc, rfl⟩
  cases' lt_or_le b o with hbo hbo
  · refine ⟨_, Sum.inr c, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hc
    · exact le_rfl
  · refine ⟨_, Sum.inl ⟨b, _⟩, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hb
    · exact hbo.trans (le_sup _ c)

Repaired Proof:
theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :
    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o ⊕' o := by
  rw [← IsNormal.bsup_eq.{u, v} H, derivFamily, derivFamilyAux]
  dsimp; rw [sup_eq_lsub_iff_lt_sup.{u, v}]
  rintro a ⟨b, hb, c, hc, rfl⟩
  cases' lt_or_le b o with hbo hbo
  · refine ⟨_, Sum.inr c, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hc
    · exact le_rfl
  · refine ⟨_, Sum.inl ⟨b, _⟩, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hb
    · exact hbo.trans (le_sup _ c)

Repaired Proof:
theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :
    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o ⊕' o := by
  rw [← IsNormal.bsup_eq.{u, v} H, derivFamily, derivFamilyAux]
  dsimp; rw [sup_eq_lsub_iff_lt_sup.{u, v}]
  rintro a ⟨b, hb, c, hc, rfl⟩
  cases' lt_or_le b o with hbo hbo
  · refine ⟨_, Sum.inr c, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hc
    · exact le_rfl
  · refine ⟨_, Sum.inl ⟨b, _⟩, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hb
    · exact hbo.trans (le_sup _ c)

Repaired Proof:
theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :
    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o ⊕' o := by
  rw [← IsNormal.bsup_eq.{u, v} H, derivFamily, derivFamilyAux]
  dsimp; rw [sup_eq_lsub_iff_lt_sup.{u, v}]
  rintro a ⟨b, hb, c, hc, rfl⟩
  cases' lt_or_le b o with hbo hbo
  · refine ⟨_, Sum.inr c, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hc
    · exact le_rfl
  · refine ⟨_, Sum.inl ⟨b, _⟩, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hb
    · exact hbo.trans (le_sup _ c)

Repaired Proof:
theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :
    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o ⊕' o := by
  rw [← IsNormal.bsup_eq.{u, v} H, derivFamily, derivFamilyAux]
  dsimp; rw [sup_eq_lsub_iff_lt_sup.{u, v}]
  rintro a ⟨b, hb, c, hc, rfl⟩
  cases' lt_or_le b o with hbo hbo
  · refine ⟨_, Sum.inr c, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hc
    · exact le_rfl
  · refine ⟨_, Sum.inl ⟨b, _⟩, _, _, rfl⟩
    · rw [lt_succ_iff]
      exact (le_bsup _ _ hb).trans (H.1 _)
    · exact hb
    · exact hbo.trans (le_sup _ c)

Repaired Proof:
theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :
    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o ⊕' o := by

Attempt failure.

Working on Mathlib/Topology/Algebra/InfiniteSum/Basic.lean - 2024-09-09 02:21:06.425790.
---185/200---
For theorem tprod_range in Mathlib/Topology/Algebra/InfiniteSum/Basic.lean:
theorem tprod_range {g : γ → β} (f : β → α) (hg : Injective g) :
    ∏' x : Set.range g, f x = ∏' x, f (g x) 


Original valid proof:
:= by
  rw [← Set.image_univ, tprod_image f hg.injOn]
  simp_rw [← comp_apply (g := g), tprod_univ (f ∘ g)]


Verifying proof (Commit 5bc1ad1d20d0d38fd328824a49d24b475a371d9e):
⊓ ⨅ _ : x ∉ Set.range g, ⊤ := by
  rw [← Set.image_univ, tprod_image, tprod_iInf_eq_iInf_tprod, ← tprod_eq_top_of_forall_eq_top]
  · congr
    ext
    simp [hg.eq_iff]
  · intro x _
    simp

Repaired Proof:
theorem tprod_range {g : γ → β} (f : β → α) (hg : Injective g) :
    ∏' x : Set.range g, f x = ∏' x, f (g x) ⊓ ⨅ _ : x ∉ Set.range g, ⊤ := by
  rw [← Set.image_univ, tprod_image, tprod_iInf_eq_iInf_tprod, ← tprod_eq_top_of_forall_eq_top]
  · congr
    ext
    simp [hg.eq_iff]
  · intro x _
    simp

Repaired Proof:
theorem tprod_extend_one {g : γ → β} (f : β → α) (hg : Injective g) :
    ∏' x, extend g f 1 x = ∏' x, f x := by
  rw [← tprod_range f hg, ← range_extend_subset]
  exact tprod_congr fun x => extend_apply' _ _ _

Repaired Proof:
theorem tprod_extend_one {g : γ → β} (f : β → α) (hg : Injective g) :
    ∏' x, extend g f 1 x = ∏' x, f x := by
  rw [← tprod_range f hg, ← range_extend_subset]
  exact tprod_congr fun x => extend_apply' _ _ _

Repaired Proof:
theorem tprod_extend_one' {g : γ → β} (hg' : Surjective g) (f : β → α) :
    ∏' x, extend g f 1 x = ∏' x, f x := by
  have : ∀ x : β, extend g f 1 x = f x := by
    intro x
    rw [extend_def, if_pos (hg' x)]
  simp_rw [this]
  exact tprod_congr fun x => rfl

Repaired Proof:
theorem tprod_extend_one' {g : γ → β} (hg' : Surjective g) (f : β → α) :
    ∏' x, extend g f 1 x = ∏' x, f x := by
  have : ∀ x : β, extend g f 1 x = f x := by
    intro x
    rw [extend_def, if_pos (hg' x)]
  simp_rw [this]
  exact tprod_congr fun x => rfl

Repaired Proof:
theorem tprod_extend_one {g : γ → β} (hg : Injective g) (f : β → α) :
    ∏' x, extend g f 1 x = ∏' x, f x :=
  tprod_extend_one' hg.surjective f

Repaired Proof:
theorem tprod_extend_one {g : γ → β} (hg : Injective g) (f : β → α) :
    ∏' x, extend g f 1 x = ∏' x, f x :=
  tprod_extend_one' hg.surjective f

Attempt failure.

Working on Mathlib/Topology/Algebra/Module/Basic.lean - 2024-09-09 02:21:15.251093.
---186/200---
For theorem TopologicalSpace.IsSeparable.span in Mathlib/Topology/Algebra/Module/Basic.lean:
lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M) 


Original valid proof:
:= by
  rw [span_eq_iUnion_nat]
  refine .iUnion fun n ↦ .image ?_ ?_
  · have : IsSeparable {f : Fin n → R × M | ∀ (i : Fin n), f i ∈ Set.univ ×ˢ s} := by
      apply isSeparable_pi (fun i ↦ .prod (.of_separableSpace Set.univ) hs)
    rwa [Set.univ_prod] at this
  · apply continuous_finset_sum _ (fun i _ ↦ ?_)
    exact (continuous_fst.comp (continuous_apply i)).smul (continuous_snd.comp (continuous_apply i))


Verifying proof (Commit 554c20d1eb6d2f1f6a5b53ccd3a727a93147a4de):
 := by
  obtain ⟨t, hts, _, hst⟩ := hs
  have : IsSeparable (t : Set M) := ⟨t, rfl, ‹_›, hst⟩
  refine ⟨t, ?_, ‹_›, ?_⟩
  · rw [span_eq_iUnion_zsmul_of_subset_closure hts]
    exact isSeparable_iUnion fun _ ↦ isSeparable_zsmul _
  · exact closure_mono hts hst

Repaired Proof:
lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M)  := by
  obtain ⟨t, hts, _, hst⟩ := hs
  have : IsSeparable (t : Set M) := ⟨t, rfl, ‹_›, hst⟩
  refine ⟨t, ?_, ‹_›, ?_⟩
  · rw [span_eq_iUnion_zsmul_of_subset_closure hts]
    exact isSeparable_iUnion fun _ ↦ isSeparable_zsmul _
  · exact closure_mono hts hst

Repaired Proof:
lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M)  := by
  obtain ⟨t, hts, _, hst⟩ := hs
  have : IsSeparable (t : Set M) := ⟨t, rfl, ‹_›, hst⟩
  refine ⟨t, ?_, ‹_›, ?_⟩
  · rw [span_eq_iUnion_zsmul_of_subset_closure hts]
    exact isSeparable_iUnion fun _ ↦ isSeparable_zsmul _
  · exact closure_mono hts hst

Repaired Proof:
lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M)  := by
  obtain ⟨t, hts, _, hst⟩ := hs
  have : IsSeparable (t : Set M) := ⟨t, rfl, ‹_›, hst⟩
  refine ⟨t, ?_, ‹_›, ?_⟩
  · rw [span_eq_iUnion_zsmul_of_subset_closure hts]
    exact isSeparable_iUnion fun _ ↦ isSeparable_zsmul _
  · exact closure_mono hts hst

Repaired Proof:
lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M)  := by
  obtain ⟨t, hts, _, hst⟩ := hs
  have : IsSeparable (t : Set M) := ⟨t, rfl, ‹_›, hst⟩
  refine ⟨t, ?_, ‹_›, ?_⟩
  · rw [span_eq_iUnion_zsmul_of_subset_closure hts]
    exact isSeparable_iUnion fun _ ↦ isSeparable_zsmul _
  · exact closure_mono hts hst

Repaired Proof:
lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M)  := by
  obtain ⟨t, hts, _, hst⟩ := hs
  have : IsSeparable (t : Set M) := ⟨t, rfl, ‹_›, hst⟩
  refine ⟨t, ?_, ‹_›, ?_⟩
  · rw [span_eq_iUnion_zsmul_of_subset_closure hts]
    exact isSeparable_iUnion fun _ ↦ isSeparable_zsmul _
  · exact closure_mono hts hst

Repaired Proof:
lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M)  := by
  obtain ⟨t, hts, _, hst⟩ := hs
  have : IsSeparable (t : Set M) := ⟨t, rfl, ‹_›, hst⟩
  refine ⟨t, ?_, ‹_›, ?_⟩
  · rw [span_eq_iUnion_zsmul_of_subset_closure hts]
    exact isSeparable_iUnion fun _ ↦ isSeparable_zsmul _
  · exact closure_mono hts hst

Repaired Proof:
lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M)  := by
  obtain ⟨t, hts, _, hst⟩ := hs
  have : IsSeparable (t : Set M) := ⟨t, rfl, ‹_›, hst⟩
  refine ⟨t, ?_, ‹_›, ?_⟩
  · rw [span_eq_iUnion_zsmul_of_subset_closure hts]
    exact isSeparable_iUnion fun _ ↦ isSeparable_zsmul _
  · exact closure_mono hts hst

Repaired Proof:
lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M)  := by
  obtain ⟨t, hts, _, hst⟩ := hs
  have : IsSeparable (t : Set M) := ⟨t, rfl, ‹_›, hst⟩
  refine ⟨t, ?_, ‹_›, ?_⟩
  · rw [span_eq_iUnion_zsmul_of_subset_closure hts]
    exact isSeparable_iUnion fun _ ↦ isSeparable_zsmul _
  · exact closure_mono hts hst

Repaired Proof:
lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M)  := by


Attempt failure.

Working on Mathlib/Topology/Algebra/Order/Compact.lean - 2024-09-09 02:21:46.403842.
---187/200---
For theorem ContinuousOn.exists_isMinOn' in Mathlib/Topology/Algebra/Order/Compact.lean:
theorem ContinuousOn.exists_isMinOn' [ClosedIicTopology α] {s : Set β} {f : β → α}
    (hf : ContinuousOn f s) (hsc : IsClosed s) {x₀ : β} (h₀ : x₀ ∈ s)
    (hc : ∀ᶠ x in cocompact β ⊓ 𝓟 s, f x₀ ≤ f x) : ∃ x ∈ s, IsMinOn f s x 


Original valid proof:
:= by
  rcases (hasBasis_cocompact.inf_principal _).eventually_iff.1 hc with ⟨K, hK, hKf⟩
  have hsub : insert x₀ (K ∩ s) ⊆ s := insert_subset_iff.2 ⟨h₀, inter_subset_right⟩
  obtain ⟨x, hx, hxf⟩ : ∃ x ∈ insert x₀ (K ∩ s), ∀ y ∈ insert x₀ (K ∩ s), f x ≤ f y :=
    ((hK.inter_right hsc).insert x₀).exists_isMinOn (insert_nonempty _ _) (hf.mono hsub)
  refine ⟨x, hsub hx, fun y hy => ?_⟩
  by_cases hyK : y ∈ K
  exacts [hxf _ (Or.inr ⟨hyK, hy⟩), (hxf _ (Or.inl rfl)).trans (hKf ⟨hyK, hy⟩)]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧ ∀ x, f x ≤ f x₀ := by
  rcases hf.exists_isMinOn hsc h₀ with ⟨x, hxs, hx⟩
  refine' ⟨x, hxs, hx, fun x ↦ _⟩
  by_contra! h
  rcases mem_cocompact.1 (hc.filter_mono inf_le_left) x with ⟨U, hUc, hxU, hU⟩
  rcases mem_principal.1 (hc.filter_mono inf_le_right) x with hxs
  obtain ⟨y, hy⟩ : ∃ y, f y < f x := not_forall.1 h
  have : f x < f x :=
    calc
      f x ≤ f y := hx y hxs
      _ < f x := hy
  exact lt_irrefl _ this

Repaired Proof:
theorem ContinuousOn.exists_isMinOn' [ClosedIicTopology α] {s : Set β} {f : β → α}
    (hf : ContinuousOn f s) (hsc : IsClosed s) {x₀ : β} (h₀ : x₀ ∈ s)
    (hc : ∀ᶠ x in cocompact β ⊓ 𝓟 s, f x₀ ≤ f x) : ∃ x ∈ s, IsMinOn f s x ∧ ∀ x, f x ≤ f x₀ := by
  rcases hf.exists_isMinOn hsc h₀ with ⟨x, hxs, hx⟩
  refine ⟨x, hxs, hx, fun x ↦ ?_⟩
  by_contra! h
  rcases mem_cocompact.1 (hc.filter_mono inf_le_left) x with ⟨U, hUc, hxU, hU⟩
  rcases mem_principal.1 (hc.filter_mono inf_le_right) x with hxs
  obtain ⟨y, hy⟩ : ∃ y, f y < f x := not_forall.1 h
  have : f x < f x :=
    calc
      f x ≤ f y := hx y hxs
      _ < f x := hy
  exact lt_irrefl _ this

Repaired Proof:
theorem ContinuousOn.exists_isMinOn' [ClosedIicTopology α] {s : Set β} {f : β → α}
    (hf : ContinuousOn f s) (hsc : IsClosed s) {x₀ : β} (h₀ : x₀ ∈ s)
    (hc : ∀ᶠ x in cocompact β ⊓ 𝓟 s, f x₀ ≤ f x) : ∃ x ∈ s, IsMinOn f s x ∧ ∀ x, f x ≤ f x₀ := by
  rcases hf.exists_isMinOn hsc h₀ with ⟨x, hxs, hx⟩
  refine ⟨x, hxs, hx, fun x ↦ ?_⟩
  by_contra! h
  rcases mem_cocompact.1 (hc.filter_mono inf_le_left) x with ⟨U, hUc, hxU, hU⟩
  rcases mem_principal.1 (hc.filter_mono inf_le_right) x with hxs
  obtain ⟨y, hy⟩ : ∃ y, f y < f x := not_forall.1 h
  have : f x < f x :=
    calc
      f x ≤ f y := hx y hxs
      _ < f x := hy
  exact lt_irrefl _ this

Repaired Proof:
theorem ContinuousOn.exists_isMinOn' [ClosedIicTopology α] {s : Set β} {f : β → α}
    (hf : ContinuousOn f s) (hsc : IsClosed s) {x₀ : β} (h₀ : x₀ ∈ s)
    (hc : ∀ᶠ x in cocompact β ⊓ 𝓟 s, f x₀ ≤ f x) : ∃ x ∈ s, IsMinOn f s x ∧ ∀ x, f x ≤ f x₀ := by
  rcases hf.exists_isMinOn hsc h₀ with ⟨x, hxs, hx⟩
  refine ⟨x, hxs, hx, fun x ↦ ?_⟩
  by_contra! h
  rcases mem_cocompact.1 (hc.filter_mono inf_le_left) x with ⟨U, hUc, hxU, hU⟩
  rcases mem_principal.1 (hc.filter_mono inf_le_right) x with hxs
  obtain ⟨y, hy⟩ : ∃ y, f y < f x := not_forall.1 h
  have : f x < f x :=
    calc
      f x ≤ f y := hx y hxs
      _ < f x := hy
  exact lt_irrefl _ this

Repaired Proof:
theorem ContinuousOn.exists_isMinOn' [ClosedIicTopology α] {s : Set β} {f : β → α}
    (hf : ContinuousOn f s) (hsc : IsClosed s) {x₀ : β} (h₀ : x₀ ∈ s)
    (hc : ∀ᶠ x in cocompact β ⊓ 𝓟 s, f x₀ ≤ f x) : ∃ x ∈ s, IsMinOn f s x ∧ ∀ x, f x ≤ f x₀ := by
  rcases hf.exists_isMinOn hsc h₀ with ⟨x, hxs, hx⟩
  refine ⟨x, hxs, hx, fun x ↦ ?_⟩
  by_contra! h
  rcases mem_cocompact.1 (hc.filter_mono inf_le_left) x with ⟨U, hUc, hxU, hU⟩
  rcases mem_principal.1 (hc.filter_mono inf_le_right) x with hxs
  obtain ⟨y, hy⟩ : ∃ y, f y < f x := not_forall.1 h
  have : f x < f x :=
    calc
      f x ≤ f y := hx y hxs
      _ < f x := hy
  exact lt_irrefl _ this

Repaired Proof:
theorem ContinuousOn.exists_isMinOn' [ClosedIicTopology α] {s : Set β} {f : β → α}
    (hf : ContinuousOn f s) (hsc : IsClosed s) {x₀ : β} (h₀ : x₀ ∈ s)
    (hc : ∀ᶠ x in cocompact β ⊓ 𝓟 s, f x₀ ≤ f x) : ∃ x ∈ s, IsMinOn f s x ∧ ∀ x, f x ≤ f x₀ := by
  rcases hf.exists_isMinOn hsc h₀ with ⟨x, hxs, hx⟩
  refine ⟨x, hxs, hx, fun x ↦ ?_⟩
  by_contra! h
  rcases mem_cocompact.1 (hc.filter_mono inf_le_left) x with ⟨U, hUc, hxU, hU⟩
  rcases mem_principal.1 (hc.filter_mono inf_le_right) x with hxs
  obtain ⟨y, hy⟩ : ∃ y, f y < f x := not_forall.1 h
  have : f x < f x :=
    calc
      f x ≤ f y := hx y hxs
      _ < f x := hy
  exact lt_irrefl _ this

Repaired Proof:
theorem ContinuousOn.exists_isMinOn' [ClosedIicTopology α] {s : Set β} {f : β → α}
    (hf : ContinuousOn f s) (hsc : IsClosed s) {x₀ : β} (h₀ : x₀ ∈ s)
    (hc : ∀ᶠ x in cocompact β ⊓ 𝓟 s, f x₀ ≤ f x) : ∃ x ∈ s, IsMinOn f s x ∧ ∀ x, f x ≤ f x₀ := by
  rcases hf.exists_isMinOn h

Attempt failure.

Working on Mathlib/Topology/Bases.lean - 2024-09-09 02:21:54.205967.
---188/200---
For theorem Dense.exists_countable_dense_subset_bot_top in Mathlib/Topology/Bases.lean:
theorem Dense.exists_countable_dense_subset_bot_top {α : Type*} [TopologicalSpace α]
    [PartialOrder α] {s : Set α} [SeparableSpace s] (hs : Dense s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ (∀ x, IsBot x → x ∈ s → x ∈ t) ∧
      ∀ x, IsTop x → x ∈ s → x ∈ t 


Original valid proof:
:= by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine ⟨(t ∪ ({ x | IsBot x } ∪ { x | IsTop x })) ∩ s, ?_, ?_, ?_, ?_, ?_⟩
  exacts [inter_subset_right,
    (htc.union ((countable_isBot α).union (countable_isTop α))).mono inter_subset_left,
    htd.mono (subset_inter subset_union_left hts), fun x hx hxs => ⟨Or.inr <| Or.inl hx, hxs⟩,
    fun x hx hxs => ⟨Or.inr <| Or.inr hx, hxs⟩]


Verifying proof (Commit ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2):
∧ ∀ y ∈ t, y ≠ x → x ≤ y := by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine' ⟨t, hts, htc, htd, fun x hx hxs => _, fun x hx hxs => ⟨⟨⟨_, hts hxs⟩, hx⟩, fun y hy hyx => _⟩⟩
  · exact hts (hxs.1.1.resolve_left (hts.ne_bot_iff.2 ⟨x, hx, hxs⟩).symm)
  · exact hx.2.1 _ (hts.ge_iff.1 (hts.lower_bounds_subset hy)) hyx.symm

Repaired Proof:
theorem Dense.exists_countable_dense_subset_bot_top {α : Type*} [TopologicalSpace α]
    [PartialOrder α] {s : Set α} [SeparableSpace s] (hs : Dense s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ (∀ x, IsBot x → x ∈ s → x ∈ t) ∧
      ∀ x, IsTop x → x ∈ s → x ∈ t ∧ ∀ y ∈ t, y ≠ x → x ≤ y := by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine ⟨t, hts, htc, htd, fun x hx hxs => ?_, fun x hx hxs => ⟨⟨⟨_, hts hxs⟩, hx⟩, fun y hy hyx => ?_⟩⟩
  · exact hts (hx.1.1.resolve_left (hts.ne_bot_iff.2 ⟨x, hx, hxs⟩).symm)
  · exact hx.2.1 _ (hts.ge_iff.1 (hts.lower_bounds_subset hy)) hyx.symm

Repaired Proof:
theorem Dense.exists_countable_dense_subset_bot_top {α : Type*} [TopologicalSpace α]
    [PartialOrder α] {s : Set α} [SeparableSpace s] (hs : Dense s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ (∀ x, IsBot x → x ∈ s → x ∈ t) ∧
      ∀ x, IsTop x → x ∈ s → x ∈ t ∧ ∀ y ∈ t, y ≠ x → x ≤ y := by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine ⟨t, hts, htc, htd, fun x hx hxs => ?_, fun x hx hxs => ⟨⟨⟨_, hts hxs⟩, hx⟩, fun y hy hyx => ?_⟩⟩
  · exact hts (hx.1.1.resolve_left (hts.ne_bot_iff.2 ⟨x, hx, hxs⟩).symm)
  · exact hx.2.1 _ (hts.ge_iff.1 (hts.lower_bounds_subset hy)) hyx.symm

Repaired Proof:
theorem Dense.exists_countable_dense_subset_bot_top {α : Type*} [TopologicalSpace α]
    [PartialOrder α] {s : Set α} [SeparableSpace s] (hs : Dense s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ (∀ x, IsBot x → x ∈ s → x ∈ t) ∧
      ∀ x, IsTop x → x ∈ s → x ∈ t ∧ ∀ y ∈ t, y ≠ x → x ≤ y := by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine ⟨t, hts, htc, htd, fun x hx hxs => ?_, fun x hx hxs => ⟨⟨⟨_, hts hxs⟩, hx⟩, fun y hy hyx => ?_⟩⟩
  · exact hts (hx.1.1.resolve_left (hts.ne_bot_iff.2 ⟨x, hx, hxs⟩).symm)
  · exact hx.2.1 _ (hts.ge_iff.1 (hts.lower_bounds_subset hy)) hyx.symm

Repaired Proof:
theorem Dense.exists_countable_dense_subset_bot_top {α : Type*} [TopologicalSpace α]
    [PartialOrder α] {s : Set α} [SeparableSpace s] (hs : Dense s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ (∀ x, IsBot x → x ∈ s → x ∈ t) ∧
      ∀ x, IsTop x → x ∈ s → x ∈ t ∧ ∀ y ∈ t, y ≠ x → x ≤ y := by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine ⟨t, hts, htc, htd, fun x hx hxs => ?_, fun x hx hxs => ⟨⟨⟨_, hts hxs⟩, hx⟩, fun y hy hyx => ?_⟩⟩
  · exact hts (hx.1.1.resolve_left (hts.ne_bot_iff.2 ⟨x, hx, hxs⟩).symm)
  · exact hx.2.1 _ (hts.ge_iff.1 (hts.lower_bounds_subset hy)) hyx.symm

Repaired Proof:
theorem Dense.exists_countable_dense_subset_bot_top {α : Type*} [TopologicalSpace α]
    [PartialOrder α] {s : Set α} [SeparableSpace s] (hs : Dense s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ (∀ x, IsBot x → x ∈ s → x ∈ t) ∧
      ∀ x, IsTop x → x ∈ s → x ∈ t ∧ ∀ y ∈ t, y ≠ x → x ≤ y := by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine ⟨t, hts, htc, htd, fun x hx hxs => ?_, fun x hx hxs => ⟨⟨⟨_, hts hxs⟩, hx⟩, fun y hy hyx => ?_⟩⟩
  · exact hts (hx.1.1.resolve_left (hts.ne_bot_iff.2 ⟨x, hx, hxs⟩).symm)
  · exact hx.2.1 _ (hts.ge_iff.1 (hts.lower_bounds_subset hy)) hyx.symm

Repaired Proof:
theorem Dense.exists_countable_dense_subset_bot_top {α : Type*} [TopologicalSpace α]
    [PartialOrder α] {s : Set α} [SeparableSpace s] (hs : Dense s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ (∀ x, IsBot x → x ∈ s → x ∈ t) ∧
      ∀ x, IsTop x → x ∈ s → x ∈ t ∧ ∀ y ∈ t, y ≠ x → x ≤ y := by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine ⟨t, hts, htc, htd, fun x hx hxs => ?_, fun x hx hxs => ⟨⟨⟨_, hts hxs⟩, hx⟩, fun y hy hyx => ?_⟩⟩
  · exact

Attempt failure.

Working on Mathlib/Topology/Category/Profinite/Nobeling.lean - 2024-09-09 02:22:02.093488.
---189/200---
For theorem Profinite.NobelingProof.GoodProducts.span_iff_products in Mathlib/Topology/Category/Profinite/Nobeling.lean:
theorem GoodProducts.span_iff_products : ⊤ ≤ span ℤ (Set.range (eval C)) ↔
    ⊤ ≤ span ℤ (Set.range (Products.eval C)) 


Original valid proof:
:= by
  refine ⟨fun h ↦ le_trans h (span_mono (fun a ⟨b, hb⟩ ↦ ⟨b.val, hb⟩)), fun h ↦ le_trans h ?_⟩
  rw [span_le]
  rintro f ⟨l, rfl⟩
  let L : Products I → Prop := fun m ↦ m.eval C ∈ span ℤ (Set.range (GoodProducts.eval C))
  suffices L l by assumption
  apply IsWellFounded.induction (·<· : Products I → Products I → Prop)
  intro l h
  dsimp
  by_cases hl : l.isGood C
  · apply subset_span
    exact ⟨⟨l, hl⟩, rfl⟩
  · simp only [Products.isGood, not_not] at hl
    suffices Products.eval C '' {m | m < l} ⊆ span ℤ (Set.range (GoodProducts.eval C)) by
      rw [← span_le] at this
      exact this hl
    rintro a ⟨m, hm, rfl⟩
    exact h m hm


Verifying proof (Commit a716898404cb865abf963d7081ebe54c3af39a18):
∧
      span ℤ (Set.range (eval C)) ⊓ (⨆ i, span ℤ (Set.range (eval (C i)))) = ⊥ := by
  rw [span_iff_top, span_iff_top, ← span_union, ← Set.union_singleton,
    Set.range_comp, span_image]
  simp_rw [Set.singleton_union, Set.image_univ, Set.image_range, Set.range_comp]
  rw [← span_iff_top, span_iff_top, ← span_inf_prod, ← span_eq_bot_iff, span_eq_bot_iff]
  refine ⟨fun h => ⟨h.1, fun x hx => ?_⟩, fun h => ⟨h.1, h.2.symm⟩⟩
  obtain ⟨y, hy, z, hz, rfl⟩ := mem_span_pair.1 hx
  obtain ⟨i, rfl⟩ := h.2 ⟨y, hy, z, hz, rfl⟩
  simp

Repaired Proof:
theorem GoodProducts.span_iff_products : ⊤ ≤ span ℤ (Set.range (eval C)) ↔
    ⊤ ≤ span ℤ (Set.range (Products.eval C)) ∧
      span ℤ (Set.range (eval C)) ⊓ (⨆ i, span ℤ (Set.range (eval (C i)))) = ⊥ := by
  rw [span_iff_top, span_iff_top, ← span_union, ← Set.union_singleton,
    Set.range_comp, span_image]
  simp_rw [Set.singleton_union, Set.image_univ, Set.image_range, Set.range_comp]
  rw [← span_iff_top, span_iff_top, ← span_inf_prod, ← span_eq_bot_iff, span_eq_bot_iff]
  refine ⟨fun h => ⟨h.1, fun x hx => ?_⟩, fun h => ⟨h.1, h.2.symm⟩⟩
  obtain ⟨y, hy, z, hz, rfl⟩ := mem_span_pair.1 hx
  obtain ⟨i, rfl⟩ := h.2 ⟨y, hy, z, hz, rfl⟩
  simp

Repaired Proof:
theorem GoodProducts.span_iff_products : ⊤ ≤ span ℤ (Set.range (eval C)) ↔
    ⊤ ≤ span ℤ (Set.range (Products.eval C)) ∧
      span ℤ (Set.range (eval C)) ⊓ (⨆ i, span ℤ (Set.range (eval (C i)))) = ⊥ := by
  rw [span_iff_top, span_iff_top, ← span_union, ← Set.union_singleton,
    Set.range_comp, span_image]
  simp_rw [Set.singleton_union, Set.image_univ, Set.image_range, Set.range_comp]
  rw [← span_iff_top, span_iff_top, ← span_inf_prod, ← span_eq_bot_iff, span_eq_bot_iff]
  refine ⟨fun h => ⟨h.1, fun x hx => ?_⟩, fun h => ⟨h.1, h.2.symm⟩⟩
  obtain ⟨y, hy, z, hz, rfl⟩ := mem_span_pair.1 hx
  obtain ⟨i, rfl⟩ := h.2 ⟨y, hy, z, hz, rfl⟩
  simp

Repaired Proof:
theorem GoodProducts.span_iff_products : ⊤ ≤ span ℤ (Set.range (eval C)) ↔
    ⊤ ≤ span ℤ (Set.range (Products.eval C)) ∧
      span ℤ (Set.range (eval C)) ⊓ (⨆ i, span ℤ (Set.range (eval (C i)))) = ⊥ := by
  rw [span_iff_top, span_iff_top, ← span_union, ← Set.union_singleton,
    Set.range_comp, span_image]
  simp_rw [Set.singleton_union, Set.image_univ, Set.image_range, Set.range_comp]
  rw [← span_iff_top, span_iff_top, ← span_inf_prod, ← span_eq_bot_iff, span_eq_bot_iff]
  refine ⟨fun h => ⟨h.1, fun x hx => ?_⟩, fun h => ⟨h.1, h.2.symm⟩⟩
  obtain ⟨y, hy, z, hz, rfl⟩ := mem_span_pair.1 hx
  obtain ⟨i, rfl⟩ := h.2 ⟨y, hy, z, hz, rfl⟩
  simp

Repaired Proof:
theorem GoodProducts.span_iff_products : ⊤ ≤ span ℤ (Set.range (eval C)) ↔
    ⊤ ≤ span ℤ (Set.range (Products.eval C)) ∧
      span ℤ (Set.range (eval C)) ⊓ (⨆ i, span ℤ (Set.range (eval (C i)))) = ⊥ := by
  rw [span_iff_top, span_iff_top, ← span_union, ← Set.union_singleton,
    Set.range_comp, span_image]
  simp_rw [Set.singleton_union, Set.image_univ, Set.image_range, Set.range_comp]
  rw [← span_iff_top, span_iff_top, ← span_inf_prod, ← span_eq_bot_iff, span_eq_bot_iff]
  refine ⟨fun h => ⟨h.1, fun x hx => ?_⟩, fun h => ⟨h.1, h.2.symm⟩⟩
  obtain ⟨y, hy, z, hz, rfl⟩ := mem_span_pair.1 hx
  obtain ⟨i, rfl⟩ := h.2 ⟨y, hy, z, hz, rfl⟩
  simp

Repaired Proof:
theorem GoodProducts.span_iff_products : ⊤ ≤ span ℤ (Set.range (eval C)) ↔
    ⊤ ≤ span ℤ (Set.range (Products.eval C)) ∧
      span ℤ (Set.range (eval C)) ⊓ (⨆ i, span ℤ (Set.range (eval (C i)))) = ⊥ := by
  rw [span_iff_top, span_iff_top, ← span_union, ← Set.union_singleton,
    Set.range_comp, span_image]
  simp_rw [Set.singleton_union, Set.image_univ, Set.image_range, Set.range_comp]
  rw [← span_iff_top, span_iff_top, ← span_inf_prod, ← span_eq_bot_iff, span_eq_bot_iff]
  refine ⟨fun h => ⟨h.1, fun x hx => ?_⟩, fun h => ⟨h.1, h.2.symm⟩⟩
  obtain ⟨y, hy, z, hz, rfl⟩ := mem_span_pair.1 hx
  obtain ⟨i, rfl⟩ := h.2 ⟨y, hy, z, hz, rfl⟩
  simp

Repaired Proof:
theorem GoodProducts.span_iff_products : ⊤ ≤ span ℤ (Set.range (eval C)) ↔
    ⊤ ≤ span ℤ (Set.range (Products.eval C)) ∧
      span ℤ (Set.range (eval C)) ⊓ (⨆ i, span ℤ (Set.range (eval (C i)))) = ⊥ := by
  rw [span_iff_top, span_iff_top, ← span_union, ← Set.union_singleton,
    Set.range_comp, span_image]


Attempt failure.

Working on Mathlib/Topology/Category/Stonean/EffectiveEpi.lean - 2024-09-09 02:22:23.515298.
---190/200---
For theorem Stonean.effectiveEpi_tfae in Mathlib/Topology/Category/Stonean/EffectiveEpi.lean:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ] 


Original valid proof:
:= by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ ↦ ⟨⟨struct π hπ⟩⟩
  tfae_finish


Verifying proof (Commit 55619a095ad7cce23fe9818f4cf5fefa1fabf54e):
 := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ]  := by
  tfae_have 1 → 2
  · exact fun _ => inferInstance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ => ⟨⟨π, ⟨hπ⟩⟩⟩
  tfae_finish

Repaired Proof:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE

Attempt failure.

Working on Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean - 2024-09-09 02:22:34.198607.
---191/200---
For theorem TopCat.isTopologicalBasis_cofiltered_limit in Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean:
theorem isTopologicalBasis_cofiltered_limit (T : ∀ j, Set (Set (F.obj j)))
    (hT : ∀ j, IsTopologicalBasis (T j)) (univ : ∀ i : J, Set.univ ∈ T i)
    (inter : ∀ (i) (U1 U2 : Set (F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i)
    (compat : ∀ (i j : J) (f : i ⟶ j) (V : Set (F.obj j)) (_hV : V ∈ T j), F.map f ⁻¹' V ∈ T i) :
    IsTopologicalBasis
      {U : Set C.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = C.π.app j ⁻¹' V} 


Original valid proof:
:= by
  classical
  let D := limitConeInfi F
  let E : C.pt ≅ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = D.π.app j ⁻¹' V} by
    convert this.inducing hE
    ext U0
    constructor
    · rintro ⟨j, V, hV, rfl⟩
      exact ⟨D.π.app j ⁻¹' V, ⟨j, V, hV, rfl⟩, rfl⟩
    · rintro ⟨W, ⟨j, V, hV, rfl⟩, rfl⟩
      exact ⟨j, V, hV, rfl⟩
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.π.app j x using 1
  ext U0
  constructor
  · rintro ⟨j, V, hV, rfl⟩
    let U : ∀ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ⟨U, {j}, ?_, ?_⟩
    · simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    · simp [U]
  · rintro ⟨U, G, h1, h2⟩
    obtain ⟨j, hj⟩ := IsCofiltered.inf_objs_exists G
    let g : ∀ e ∈ G, j ⟶ e := fun _ he => (hj he).some
    let Vs : J → Set (F.obj j) := fun e => if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ
    let V : Set (F.obj j) := ⋂ (e : J) (_he : e ∈ G), Vs e
    refine ⟨j, V, ?_, ?_⟩
    · 
      have :
        ∀ (S : Set (Set (F.obj j))) (E : Finset J) (P : J → Set (F.obj j)) (_univ : Set.univ ∈ S)
          (_inter : ∀ A B : Set (F.obj j), A ∈ S → B ∈ S → A ∩ B ∈ S)
          (_cond : ∀ (e : J) (_he : e ∈ E), P e ∈ S), (⋂ (e) (_he : e ∈ E), P e) ∈ S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    · 
      rw [h2]
      change _ = (D.π.app j)⁻¹' ⋂ (e : J) (_ : e ∈ G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.π.app e)⁻¹' U e =
        (D.π.app j) ⁻¹' if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ
      rw [dif_pos he, ← Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [← coe_comp, D.w] 
      rfl


Verifying proof (Commit 66c0098b0b62ad14d9c618b402e7673658137a7e):
∧
      IsSheaf (⊤ : GrothendieckTopology C) (C.presheafToTypes.{v} F) := by
  letI : ∀ i, TopologicalSpace (F.obj i) := fun i => (hT i).topology
  haveI : ∀ i, DiscreteTopology (F.obj i) := fun i => (hT i).discreteTopology
  haveI : HasLimitsOfShape (Discrete J) C :=
    haveI : ∀ j, HasLimitsOfShape (Discrete.{max v u}) (F.obj j) := fun j =>
      (inferInstance : HasLimitsOfShape (Discrete PEmpty.{max v u}) (F.obj j))
    C.hasLimitsOfShape_discrete_of_preservesLimit
  haveI : ∀ i, HasLimitsOfShape (Discrete J) (F.obj i) := fun i =>
    (inferInstance : HasLimitsOfShape (Discrete.{max v u}) (F.obj i))
  haveI : PreservesLimitsOfShape (Discrete J) C.presheafToTypes.{v} :=
    haveI : ∀ i, PreservesLimitsOfShape (Discrete J) (C.presheafToTypes.obj i) := fun i =>
      (inferInstance : PreservesLimitsOfShape (Discrete.{max v u}) (C.presheafToTypes.obj i))
    C.presheafToTypes.preservesLimitsOfShape
  haveI : ∀ j, HasLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.{v}) := fun j =>
    (inferInstance : HasLimitsOfShape (Discrete.{max v u}) (F ⋙ C.presheafToTypes.{v}))
  haveI : PreservesLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.{v}) :=
    haveI : ∀ j, PreservesLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.obj j) := fun j =>
      (inferInstance : PreservesLimitsOfShape (Discrete.{max v u}) (F ⋙ C.presheafToTypes.obj j))
    F ⋙ C.presheafToTypes.preservesLimitsOfShape
  haveI : ∀ j, IsTopologicalBasis (T j) := hT
  haveI : ∀ j, IsSheaf (⊤ : GrothendieckTopology (F.obj j)) (C.presheafToTypes.obj j) := fun j =>
    (hT j).isSheaf
  haveI : IsSheaf (⊤ : GrothendieckTopology C) C.presheafToTypes.{v} :=
    C.isSheaf_presheafToTypes_of_isSheaf_of_isTopologicalBasis F T hT univ inter compat
  refine ⟨C.isTopologicalBasis_cofiltered_limit_aux F T hT univ inter compat, inferInstance⟩

Repaired Proof:
theorem isTopologicalBasis_cofiltered_limit (T : ∀ j, Set (Set (F.obj j)))
    (hT : ∀ j, IsTopologicalBasis (T j)) (univ : ∀ i : J, Set.univ ∈ T i)
    (inter : ∀ (i) (U1 U2 : Set (F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i)
    (compat : ∀ (i j : J) (f : i ⟶ j) (V : Set (F.obj j)) (_hV : V ∈ T j), F.map f ⁻¹' V ∈ T i) :
    IsTopologicalBasis
      {U : Set C.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = C.π.app j ⁻¹' V} ∧
      IsSheaf (⊤ : GrothendieckTopology C) (C.presheafToTypes.{v} F) := by
  letI : ∀ i, TopologicalSpace (F.obj i) := fun i => (hT i).topology
  haveI : ∀ i, DiscreteTopology (F.obj i) := fun i => (hT i).discreteTopology
  haveI : HasLimitsOfShape (Discrete J) C :=
    haveI : ∀ j, HasLimitsOfShape (Discrete.{max v u}) (F.obj j) := fun j =>
      (inferInstance : HasLimitsOfShape (Discrete PEmpty.{max v u}) (F.obj j))
    C.hasLimitsOfShape_discrete_of_preservesLimit
  haveI : ∀ i, HasLimitsOfShape (Discrete J) (F.obj i) := fun i =>
    (inferInstance : HasLimitsOfShape (Discrete.{max v u}) (F.obj i))
  haveI : PreservesLimitsOfShape (Discrete J) C.presheafToTypes.{v} :=
    haveI : ∀ i, PreservesLimitsOfShape (Discrete J) (C.presheafToTypes.obj i) := fun i =>
      (inferInstance : PreservesLimitsOfShape (Discrete.{max v u}) (C.presheafToTypes.obj i))
    C.presheafToTypes.preservesLimitsOfShape
  haveI : ∀ j, HasLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.{v}) := fun j =>
    (inferInstance : HasLimitsOfShape (Discrete.{max v u}) (F ⋙ C.presheafToTypes.{v}))
  haveI : PreservesLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.{v}) :=
    haveI : ∀ j, PreservesLimitsOfShape (Discrete J) (F ⋙ C.presheafToTypes.obj j) := fun j =>
      (inferInstance : PreservesLimitsOfShape (Discrete.{max v u}) (F ⋙ C.presheafToTypes.obj j))
    F ⋙ C.presheafToTypes.preservesLimitsOfShape
  haveI : ∀ j, IsTopologicalBasis (T j) := hT
  haveI : ∀ j, IsSheaf (⊤ : GrothendieckTopology (F.obj j)) (C.presheafToTypes.obj j) := fun j =>
    (hT j).isSheaf
  haveI : IsSheaf (⊤ : GrothendieckTopology C) C.presheafToTypes.{v} :=
    C.isSheaf_presheafToTypes_of_isSheaf_of_isTopologicalBasis F T hT univ inter compat
  refine ⟨C.isTopologicalBasis_cofiltered_limit_aux F T hT univ inter compat, inferInstance⟩

Repaired Proof:
theorem isTopologicalBasis_cofiltered_limit (T : ∀ j, Set (Set (F.obj j)))
    (hT : ∀ j, IsTopologicalBasis (T j)) (univ : ∀ i : J, Set.univ ∈ T i)
    (inter : ∀ (i) (U1 U2 : Set (F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i)
    (compat : ∀ (i j : J) (f : i ⟶ j) (V : Set (F.obj j)) (_hV : V ∈ T j), F.map f ⁻¹' V ∈ T i) :
    IsTopologicalBasis
      {U : Set C.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = C.π.app j ⁻¹' V} ∧
      IsSheaf (⊤ : GrothendieckTopology C) (C.presheafToTypes.{v} F) := by
  letI : ∀ i, TopologicalSpace (F.obj i) := fun i => (hT i).topology
  haveI : ∀ i, DiscreteTopology (F.obj i) := fun i => (hT i).discreteTopology
  haveI : HasLimitsOfShape (Discrete J) C :=
    haveI : ∀ j, HasLimitsOfShape (Discrete.{max v u} PEmpty) (F.obj j) := fun j =>
      (inferInstance : HasLimitsOfShape (Discrete.{max v u} PEmpty) (F.obj j))
    C.hasLimitsOfShape_discrete_of_preservesLimit
  haveI : ∀ i, HasLimitsOfShape (Discrete J) (F.obj i) := fun i =>


Attempt failure.

Working on Mathlib/Topology/Compactness/Compact.lean - 2024-09-09 02:22:39.952790.
---192/200---
For theorem IsCompact.inter_right in Mathlib/Topology/Compactness/Compact.lean:
theorem IsCompact.inter_right (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s ∩ t) 


Original valid proof:
:= by
  intro f hnf hstf
  obtain ⟨x, hsx, hx⟩ : ∃ x ∈ s, ClusterPt x f :=
    hs (le_trans hstf (le_principal_iff.2 inter_subset_left))
  have : x ∈ t := ht.mem_of_nhdsWithin_neBot <|
    hx.mono <| le_trans hstf (le_principal_iff.2 inter_subset_right)
  exact ⟨x, ⟨hsx, this⟩, hx⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 :=
    hs.inter_right ht.isClosed_compl

Repaired Proof:
theorem IsCompact.inter_right (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s ∩ t) :=
  hs.inter_right ht.isClosed_compl

Repaired Proof:
theorem IsCompact.inter_left (ht : IsCompact t) (hs : IsClosed s) : IsCompact (s ∩ t) :=
  inter_comm t s ▸ ht.inter_right hs

Repaired Proof:
theorem IsCompact.inter_left (ht : IsCompact t) (hs : IsClosed s) : IsCompact (s ∩ t) :=
  inter_comm t s ▸ ht.inter_right hs

Repaired Proof:
theorem IsCompact.diff (hs : IsCompact s) (ht : IsOpen t) : IsCompact (s \ t) :=
  hs.inter_right (isClosed_compl_iff.mpr ht)

Repaired Proof:
theorem IsCompact.diff (hs : IsCompact s) (ht : IsOpen t) : IsCompact (s \ t) :=
  hs.inter_right (isClosed_compl_iff.mpr ht)

Repaired Proof:
theorem IsCompact.diff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.diff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsOpen t) : IsCompact (s \ t) :=
  hs.inter_right (isClosed_compl_iff.mpr ht)

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsOpen t) : IsCompact (s \ t) :=
  hs.inter_right (isClosed_compl_iff.mpr ht)

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \ t) :=
  hs.inter_right ht

Repaired Proof:
theorem IsCompact.sdiff (hs : IsCompact s)

Attempt failure.

Working on Mathlib/Topology/GDelta.lean - 2024-09-09 02:22:47.781319.
---193/200---
For theorem isMeagre_iff_countable_union_isNowhereDense in Mathlib/Topology/GDelta.lean:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S 


Original valid proof:
:= by
  rw [IsMeagre, mem_residual_iff, compl_bijective.surjective.image_surjective.exists]
  simp_rw [← and_assoc, ← forall_and, forall_mem_image, ← isClosed_isNowhereDense_iff_compl,
    sInter_image, ← compl_iUnion₂, compl_subset_compl, ← sUnion_eq_biUnion, and_assoc]
  refine ⟨fun ⟨S, hS, hc, hsub⟩ ↦ ⟨S, fun s hs ↦ (hS hs).2, ?_, hsub⟩, ?_⟩
  · rw [← compl_compl_image S]; exact hc.image _
  · intro ⟨S, hS, hc, hsub⟩
    use closure '' S
    rw [forall_mem_image]
    exact ⟨fun s hs ↦ ⟨isClosed_closure, (hS s hs).closure⟩,
      (hc.image _).image _, hsub.trans (sUnion_mono_subsets fun s ↦ subset_closure)⟩


Verifying proof (Commit 4acf29cf15ba1326f189b61f7e886396ab6d97c8):
∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S, hS, hSc, hs⟩

Repaired Proof:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S ∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S, hS, hSc, hs⟩

Repaired Proof:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S ∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S, hS, hSc, hs⟩

Repaired Proof:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S ∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S, hS, hSc, hs⟩

Repaired Proof:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S ∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S, hS, hSc, hs⟩

Repaired Proof:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S ∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S, hS, hSc, hs⟩

Repaired Proof:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S ∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S, hS, hSc, hs⟩

Repaired Proof:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S ∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S, hS, hSc, hs⟩

Repaired Proof:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S ∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S, hS, hSc, hs⟩

Repaired Proof:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S ∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S, hS, hSc, hs⟩

Repaired Proof:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S ∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S, hS, hSc, hs⟩

Repaired Proof:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S ∧
      s ⊆ closure s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hSc, hs⟩
    use S, hS, hSc, hs
    exact subset_closure
  · rintro ⟨S, hS, hSc, hs, h⟩
    refine ⟨S,

Attempt failure.

Working on Mathlib/Topology/Homotopy/HSpaces.lean - 2024-09-09 02:22:53.137744.
---194/200---
For theorem unitInterval.continuous_qRight in Mathlib/Topology/Homotopy/HSpaces.lean:
theorem continuous_qRight : Continuous qRight 


Original valid proof:
:=
  continuous_projIcc.comp <|
    Continuous.div (by fun_prop) (by fun_prop) fun x ↦ (add_pos zero_lt_one).ne'


Verifying proof (Commit f655aad92f39fa1eff3436b3b0c4a1004e666b53):
 := by
    have : Continuous (fun p : (Σk, ℝ≥0∞) × ℝ≥0∞ => (p.1.1, p.1.2, p.2)) :=
      continuous_fst.comp (continuous_fst.prod_mk continuous_snd)
    exact this.comp (continuous_swap.prod_mk continuous_snd)

Repaired Proof:
theorem continuous_qRight : Continuous qRight  := by
    have : Continuous (fun p : (Σk, ℝ≥0∞) × ℝ≥0∞ => (p.1.1, p.1.2, p.2)) :=
      continuous_fst.comp (continuous_fst.prod_mk continuous_snd)
    exact this.comp (continuous_swap.prod_mk continuous_snd)

Repaired Proof:
theorem continuous_fst_add_snd_inv_smul_fst_sub_inv_snorm' {p : ℝ} (hp : 1 ≤ p) {f g : α → ℝ≥0∞}
    (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    Continuous fun x : ℝ≥0∞ => (x * f + (1 - x) * g) ^ (1 / p) * (f + g) ^ (-(1 / p)) := by
  have hp_pos : 0 < p := zero_lt_one.trans_le hp
  have h_fst_snd :
      Continuous fun x : ℝ≥0∞ => (x * f + (1 - x) * g) ^ (1 / p) * (f + g) ^ (-(1 / p)) := by
    refine continuous_qRight.comp (Continuous.prod_mk ?_ ?_)
    · have h_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (1 / p) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne.def, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff]
      have h_inv_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (-(1 / p)) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne.def, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff, neg_eq_zero]
      exact h_rpow_cont.mul h_inv_rpow_cont
    · have h_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (1 / p) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne.def, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff]
      have h_inv_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (-(1 / p)) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne.def, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff, neg_eq_zero]
      exact h_rpow_cont.mul h_inv_rpow_cont
  refine h_fst_snd.comp (Continuous.prod_mk ?_ ?_)
  · exact continuous_add.comp (Continuous.prod_mk continuous_id continuous_const)
  · exact continuous_add.comp (Continuous.prod_mk continuous_const continuous_id)

Repaired Proof:
theorem continuous_fst_add_snd_inv_smul_fst_sub_inv_snorm' {p : ℝ} (hp : 1 ≤ p) {f g : α → ℝ≥0∞}
    (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    Continuous fun x : ℝ≥0∞ => (x * f + (1 - x) * g) ^ (1 / p) * (f + g) ^ (-(1 / p)) := by
  have hp_pos : 0 < p := zero_lt_one.trans_le hp
  have h_fst_snd :
      Continuous fun x : ℝ≥0∞ => (x * f + (1 - x) * g) ^ (1 / p) * (f + g) ^ (-(1 / p)) := by
    refine continuous_qRight.comp (Continuous.prod_mk ?_ ?_)
    · have h_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (1 / p) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff]
      have h_inv_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (-(1 / p)) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff, neg_eq_zero]
      exact h_rpow_cont.mul h_inv_rpow_cont
    · have h_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (1 / p) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff]
      have h_inv_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (-(1 / p)) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff, neg_eq_zero]
      exact h_rpow_cont.mul h_inv_rpow_cont
  refine h_fst_snd.comp (Continuous.prod_mk ?_ ?_)
  · exact continuous_add.comp (Continuous.prod_mk continuous_id continuous_const)
  · exact continuous_add.comp (Continuous.prod_mk continuous_const continuous_id)

Repaired Proof:
theorem continuous_fst_add_snd_inv_smul_fst_sub_inv_snorm' {p : ℝ} (hp : 1 ≤ p) {f g : α → ℝ≥0∞}
    (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    Continuous fun x : ℝ≥0∞ => (x * f + (1 - x) * g) ^ (1 / p) * (f + g) ^ (-(1 / p)) := by
  have hp_pos : 0 < p := zero_lt_one.trans_le hp
  have h_fst_snd :
      Continuous fun x : ℝ≥0∞ => (x * f + (1 - x) * g) ^ (1 / p) * (f + g) ^ (-(1 / p)) := by
    refine continuous_qRight.comp (Continuous.prod_mk ?_ ?_)
    · have h_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (1 / p) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff]
      have h_inv_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (-(1 / p)) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff, neg_eq_zero]
      exact h_rpow_cont.mul h_inv_rpow_cont
    · have h_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (1 / p) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff]
      have h_inv_rpow_cont : Continuous fun x : ℝ≥0∞ => x ^ (-(1 / p)) := by
        refine continuous_rpow_const ?_
        simp only [one_div, Ne, ENNReal.inv_eq_zero, hp_pos.ne', not_false_iff, neg_eq_zero]
      exact h_rpow_cont.mul h_inv_rpow_cont
  refine h_fst_snd.comp (Continuous.prod_mk ?_ ?_)
  · exact continuous_add.comp (Continuous.prod_mk continuous_id continuous_const)
  · exact continuous_add.comp (Continuous.prod_mk continuous_const continuous_id)

Repaired Proof:
theorem continuous_fst_add

Attempt failure.

Working on Mathlib/Topology/Instances/Real.lean - 2024-09-09 02:23:01.055500.
---195/200---
For theorem AddSubgroup.tendsto_zmultiples_subtype_cofinite in Mathlib/Topology/Instances/Real.lean:
theorem tendsto_zmultiples_subtype_cofinite (a : ℝ) :
    Tendsto (zmultiples a).subtype cofinite (cocompact ℝ) 


Original valid proof:
:=
  (zmultiples a).tendsto_coe_cofinite_of_discrete


Verifying proof (Commit 8b24b7412473ebe3dfb3396b9609b7817f5d3868):
↔ ¬a = 0 := by
  refine' ⟨fun h ha => _, fun h => _⟩
  · rw [ha, Int.cast_zero, zero_zsmul] at h
    exact not_tendsto_cocompact_atBot _ h
  · rw [Int.tendsto_iff_nat_atTop_le_cofinite, Int.nat_ceil_neg, Int.nat_ceil_mul_eq_mul_nat_ceil_of_pos]
    · intro n
      have : (↑(n : ℤ) : ℝ) * (-a) ∈ Icc (-(n * a)) (n * a) :=
        ⟨(zsmul_le_iff_le (n * a) (n : ℤ) (-a)).1 (Int.ofNat_le.2 n.le_mul_self),
          (zsmul_le_iff_le (n * a) (-(n : ℤ)) a).1 (Int.ofNat_le.2 n.le_mul_self)⟩
      rcases mem_Icc.1 this with ⟨h1, h2⟩
      refine' ⟨⟨(n : ℤ) * a, _⟩, _⟩
      · rw [Int.cast_natCast, Int.cast_mul, abs_of_pos (Int.natCast_pos.2 n.pos), ha, mul_zero]
        exact h1
      · rw [Int.cast_natCast, Int.cast_mul, abs_of_pos (Int.natCast_pos.2 n.pos), ha, mul_zero]
        exact h2
    · exact mul_pos n.cast_nonneg (neg_pos.2 h)

Repaired Proof:
theorem tendsto_zmultiples_subtype_cofinite (a : ℝ) :
    Tendsto (zmultiples a).subtype cofinite (cocompact ℝ) ↔ ¬a = 0 := by
  refine ⟨fun h ha => ?_, fun h => ?_⟩
  · rw [ha, Int.cast_zero, zero_zsmul] at h
    exact not_tendsto_cocompact_atBot _ h
  · rw [Int.tendsto_iff_nat_atTop_le_cofinite, Int.nat_ceil_neg, Int.nat_ceil_mul_eq_mul_nat_ceil_of_pos]
    · intro n
      have : (↑(n : ℤ) : ℝ) * (-a) ∈ Icc (-(n * a)) (n * a) :=
        ⟨(zsmul_le_iff_le (n * a) (n : ℤ) (-a)).1 (Int.ofNat_le.2 n.le_mul_self),
          (zsmul_le_iff_le (n * a) (-(n : ℤ)) a).1 (Int.ofNat_le.2 n.le_mul_self)⟩
      rcases mem_Icc.1 this with ⟨h1, h2⟩
      refine ⟨⟨(n : ℤ) * a, ?_⟩, ?_⟩
      · rw [Int.cast_natCast, Int.cast_mul, abs_of_pos (Int.natCast_pos.2 n.pos), ha, mul_zero]
        exact h1
      · rw [Int.cast_natCast, Int.cast_mul, abs_of_pos (Int.natCast_pos.2 n.pos), ha, mul_zero]
        exact h2
    · exact mul_pos n.cast_nonneg (neg_pos.2 h)

Repaired Proof:
theorem tendsto_zmultiples_subtype_cofinite (a : ℝ) :
    Tendsto (zmultiples a).subtype cofinite (cocompact ℝ) ↔ ¬a = 0 := by
  refine ⟨fun h ha => ?_, fun h => ?_⟩
  · rw [ha, Int.cast_zero, zero_zsmul] at h
    exact not_tendsto_cocompact_atBot _ h
  · rw [Int.tendsto_iff_nat_atTop_le_cofinite, Int.nat_ceil_neg, Int.nat_ceil_mul_eq_mul_nat_ceil_of_pos]
    · intro n
      have : (↑(n : ℤ) : ℝ) * (-a) ∈ Icc (-(n * a)) (n * a) :=
        ⟨(zsmul_le_iff_le (n * a) (n : ℤ) (-a)).1 (Int.ofNat_le.2 n.le_mul_self),
          (zsmul_le_iff_le (n * a) (-(n : ℤ)) a).1 (Int.ofNat_le.2 n.le_mul_self)⟩
      rcases mem_Icc.1 this with ⟨h1, h2⟩
      refine ⟨⟨(n : ℤ) * a, ?_⟩, ?_⟩
      · rw [Int.cast_natCast, Int.cast_mul, abs_of_pos (Int.natCast_pos.2 n.pos), ha, mul_zero]
        exact h1
      · rw [Int.cast_natCast, Int.cast_mul, abs_of_pos (Int.natCast_pos.2 n.pos), ha, mul_zero]
        exact h2
    · exact mul_pos n.cast_nonneg (neg_pos.2 h)

Repaired Proof:
theorem tendsto_zmultiples_subtype_cofinite (a : ℝ) :
    Tendsto (zmultiples a).subtype cofinite (cocompact ℝ) ↔ ¬a = 0 := by
  refine ⟨fun h ha => ?_, fun h => ?_⟩
  · rw [ha, Int.cast_zero, zero_zsmul] at h
    exact not_tendsto_cocompact_atBot _ h
  · rw [Int.tendsto_iff_nat_atTop_le_cofinite, Int.nat_ceil_neg, Int.nat_ceil_mul_eq_mul_nat_ceil_of_pos]
    · intro n
      have : (↑(n : ℤ) : ℝ) * (-a) ∈ Icc (-(n * a)) (n * a) :=
        ⟨(zsmul_le_iff_le (n * a) (n : ℤ) (-a)).1 (Int.ofNat_le.2 n.le_mul_self),
          (zsmul_le_iff_le (n * a) (-(n : ℤ)) a).1 (Int.ofNat_le.2 n.le_mul_self)⟩
      rcases mem_Icc.1 this with ⟨h1, h2⟩
      refine ⟨⟨(n : ℤ) * a, ?_⟩, ?_⟩
      · rw [Int.cast_natCast, Int.cast_mul, abs_of_pos (Int.natCast_pos.2 n.pos), ha, mul_zero]
        exact h1
      · rw [Int.cast_natCast, Int.cast_mul, abs_of_pos (Int.natCast_pos.2 n.pos), ha, mul_zero]
        exact h2
    · exact mul_pos n.cast_nonneg (neg_pos.2 h)

Repaired Proof:
theorem tendsto_zmultiples_subtype_cofinite (a : ℝ) :
    Tendsto (zmultiples a).subtype cofinite (cocompact ℝ) ↔ ¬a = 0 := by
  refine ⟨fun h ha => ?_, fun h => ?_⟩
  · rw [ha, Int.cast_zero, zero_zsmul] at h
    exact not_tendsto_cocompact_atBot _ h
  · rw [Int.tendsto_iff_nat_atTop_le_cofinite, Int.nat_ceil_neg, Int.nat_ceil_mul_eq_mul_nat_ceil_of_pos]
    · intro n
      have : (↑(n : ℤ) : ℝ) * (-a) ∈ Icc (-(n * a)) (n * a) :=
        ⟨(zsmul_le_iff_le (n * a) (n : ℤ) (-a)).1 (Int.ofNat_le.2 n.le_mul_self),
          (zsmul_le_iff_le (n * a) (-(n : ℤ)) a).1 (Int.ofNat_le

Attempt failure.

Working on Mathlib/Topology/MetricSpace/HausdorffDistance.lean - 2024-09-09 02:23:08.646170.
---196/200---
For theorem EMetric.infEdist_singleton in Mathlib/Topology/MetricSpace/HausdorffDistance.lean:
theorem infEdist_singleton : infEdist x {y} = edist x y 


Original valid proof:
:=
  iInf_singleton


Verifying proof (Commit 75499222cc11ae5a47a99ba69c3066b962a0dc6f):
⊓ 1 := by
    simp only [infEdist, ENNReal.iInf_unique, edist_dist, dist_singleton_left, ENNReal.ofReal_one]

@[simp]
theorem infEdist_zero_right : infEdist x ∅ = ∞ :=
  iInf_emptyset


@[simp]
theorem infEdist_zero_pos : 0 < infEdist x s ↔ s.Nonempty :=
  pos_iff_ne_zero.trans (infEdist_eq_zero.not.trans nonempty_iff_ne_empty.symm)


theorem infEdist_singleton : infEdist x {y} = edist x y := by simp


theorem infEdist_eq_top_iff : infEdist x s = ∞ ↔ s = ∅ :=
  ⟨fun h ↦ not_ne_iff.1 fun hs ↦ lt_top_iff_ne_top.2 h <| infEdist_pos_iff_nonempty.2 hs,
    fun h ↦ h.symm ▸ infEdist_empty _⟩


theorem infEdist_ne_top (h : s.Nonempty) : infEdist x s ≠ ∞ :=
  (lt_top_iff_ne_top.2 (infEdist_pos_iff_nonempty.2 h)).ne


theorem infEdist_setOf_eq_top : infEdist x {y | p y} = ∞ ↔ p x ∧ ∀ y, p y → x = y → ¬p x := by
  simp only [infEdist, ← ENNReal.iInf_indicator_eq_iInf_dist, ENNReal.iInf_eq_top]
  refine ⟨fun h ↦ ⟨?_, fun y hy hx ↦ ?_⟩, fun h ↦ ⟨h.1, fun y hy ↦ ?_⟩⟩
  · simpa only [edist_self, indicator_of_mem, mem_univ, ite_true] using h x
  · simpa only [edist_self, indicator_of_not_mem hy, mem_univ, ite_false, top_le_iff] using h y hy hx
  · simpa only [edist_self, indicator_of_not_mem hy, mem_univ, ite_false, top_le_iff] using h.2 y hy


theorem exists_mem_closure_infEdist_eq_zero [ProperSpace α] (h : infEdist x s ≠ 0) :
    ∃ y ∈ closure s, infEdist x s = edist x y := by
  rcases s.eq_empty_or_nonempty with (rfl | hs)
  · rw [infEdist_empty] at h
    exact (h rfl).elim
  rcases (infEdist_pos_iff_nonempty.2 hs).ne_bot h with ⟨y, hne, hxy⟩
  rcases Metric.mem_closure_infEdist_zero.1 (mem_closure_iff_infEdist_zero.2 ⟨y, hne⟩) with ⟨z, hzs, hxz⟩
  exact ⟨z, mem_closure_iff_infEdist_zero.2 ⟨y, hne⟩, le_antisymm hxy hxz⟩


theorem exists_mem_closure_infEdist_eq_zero [ProperSpace α] (h : infEdist x s = 0) :
    ∃ y ∈ closure s, infEdist x s = edist x y :=
  (infEdist_pos_iff_nonempty.1 (pos_iff_ne_zero.2 h.symm)).imp fun _ h ↦ ⟨h, rfl⟩


theorem exists_mem_closure_infEdist_eq_edist [ProperSpace α] (h : infEdist x s ≠ 0) :
    ∃ y ∈ closure s, infEdist x s = edist x y ∧ edist x y ≠ 0 :=
  let ⟨_y, h₁, h₂⟩ := exists_mem_closure_infEdist_eq_zero h.bot_lt
  ⟨_, h₁, h₂, ne_top_of_le_ne_top (edist_ne_top _ _) infEdist_le_edist_of_mem h₁⟩


theorem exists_mem_closure_infEdist_eq_edist' [ProperSpace α] (h : infEdist x s ≠ 0) :
    ∃ y ∈ closure s, y ∈ t :=
  let ⟨_y, h₁, h₂, h₃⟩ := exists_mem_closure_infEdist_eq_edist h
  ⟨_, h₁, h₂ ▸ h₃⟩

theorem exists_mem_closure_infEdist_eq_edist_of_nonempty [ProperSpace α] (hne : s.Nonempty) :
    ∃ y ∈ closure s, infEdist x s = edist x y :=
  let ⟨_y, h⟩ := hne
  exists_mem_closure_infEdist_eq_edist_of_mem h


theorem exists_mem_closure_infEdist_eq_edist_real [ProperSpace α] (h : infEdist x s ≠ 0) :
    ∃ y ∈ closure s, infEdist x s = edist x y ∧ (y ∈ s ↔ edist x y = 0) := by
  rcases exists_mem_closure_infEdist_eq_edist h with ⟨y, ycs, hxy, hy⟩
  rcases em (y ∈ s) with (hycs | hycs)
  · exact ⟨y, ycs, hxy, by simp [hycs]⟩
  · rcases eq_empty_or_nonempty s with (rfl | ⟨z, hz⟩)
    · simp at hycs
    · rcases exists_mem_closure_infEdist_eq_zero (nonempty_closure_ball.1 ⟨y, hy⟩).infEdist_ne_top
        with ⟨y', y's, hxy'⟩
      have : y ≠ y' := fun he ↦ hycs <| by rwa [← he, edist_self] at hz
      rcases (infEdist_le_edist_add_infEdist.trans (add_le_add hxy (le_of_eq hxy'))).lt_iff_ne.1
          (edist_pos.2 this) with
        ⟨y'', y''s, hxy''⟩
      exact ⟨y'', subset_closure y''s, (add_eq_zero_iff.1 hxy'').2, by simp [y''s]⟩


theorem exists_real_pos_lt_infEdist_of_not_mem_closure [ProperSpace α] (hx : x ∉ closure s) :
    ∃ ε : ℝ, 0 < ε ∧ ENNReal.ofReal ε < infEdist x s := by
  rw [mem_closure_iff_infEdist_zero] at hx
  rcases infEdist_pos_iff_nonempty.1 (pos_iff_ne_zero.2 hx.bot_lt) with ⟨y, hys, hxy⟩
  rcases infEdist_setOf_eq_top.1 hx with ⟨u, hu, hxu⟩
  rcases (ENNReal.lt_iff_exists_real_btwn (ENNReal.ofReal_ne_top : ENNReal.ofReal 0 ≠ ⊤)).1
    (hxy.trans_le infEdist_anti hu) with ⟨ε, h0ε, hε⟩
  exact ⟨ε, h0ε, hε.trans_le <| infEdist_anti hys⟩


theorem exists_pos_lt_infEdist_of_not_mem_closure [ProperSpace α] (hx : x ∉ closure s) :
    ∃ ε : ℝ, 0 < ε ∧ ENNReal.ofReal ε < infEdist x s := by
  simpa only [infEdist_setOf] using exists_real_pos_lt_infEdist_of_not_mem_closure hx


theorem exists_pos_lt_edist_of_not_mem_closure [ProperSpace α] (hx : x ∉ closure s

Attempt failure.

Working on Mathlib/Topology/MetricSpace/Holder.lean - 2024-09-09 02:23:17.598425.
---197/200---
For theorem HolderOnWith.ediam_image_inter_le in Mathlib/Topology/MetricSpace/Holder.lean:
theorem ediam_image_inter_le_of_le (hf : HolderOnWith C r f s) {d : ℝ≥0∞}
    (hd : EMetric.diam t ≤ d) : EMetric.diam (f '' (t ∩ s)) ≤ (C : ℝ≥0∞) * d ^ (r : ℝ) 


Original valid proof:
:=
  hf.ediam_image_le_of_subset_of_le inter_subset_right <|
    (EMetric.diam_mono inter_subset_left).trans hd


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      EMetric.diam (f '' (t ∩ sᶜ)) ≤ (C : ℝ≥0∞) * d ^ (r : ℝ) := by
  rcases eq_or_ne r 0 with (rfl | hr)
  · simp only [rpow_zero, ENNReal.mul_one]
    rw [EMetric.diam_image_eq_zero_iff]
    intro x hx y hy
    exact hf.edist_le_zero_of_dist_le_zero (hd.trans EMetric.diam_nonpos) ⟨x, hx, rfl⟩ ⟨y, hy, rfl⟩
  have hr' : 0 < (r : ℝ) := hr.bot_lt
  have Cpos : 0 < (C : ℝ) := zero_lt_one.trans_le hf.C.2
  have Cd : 0 ≤ (C : ℝ) * d ^ (r : ℝ) := by positivity
  refine' ⟨_, _⟩
  · refine' (EMetric.diam_image_le (f := f) (s := t ∩ s)).trans_eq' _
    rw [EMetric.diam_union (s := f '' (t ∩ sᶜ)) (t := f '' (t ∩ s))
        (hd₂ := EMetric.diam_image_le (f := f) (s := t ∩ sᶜ)).ne]
    simp only [inter_union_distrib_left, image_inter_preimage, EMetric.diam_image_le,
      EMetric.diam_union (s := f '' (t ∩ s)) (t := f '' (t ∩ sᶜ))
        (hd₂ := EMetric.diam_image_le (f := f) (s := t ∩ sᶜ)).ne,
      EMetric.diam_image_le (f := f) (s := t ∩ sᶜ), EMetric.diam_image_le (f := f) (s := t ∩ s),
      EMetric.ediam_image_le_iff_ediam_image_le_mul_rpow_of_subset_closure hf.continuousOn
        inter_subset_left,
      EMetric.ediam_image_le_iff_ediam_image_le_mul_rpow_of_subset_closure hf.continuousOn
        inter_subset_right]
    rw [← ENNReal.rpow_le_rpow_iff hr', ← mul_assoc, ← ENNReal.rpow_add _ _ hr']
    exact hf.ediam_image_le_of_subset_ediam_image_le_mul_rpow_of_ediam_image_le
      (EMetric.diam_mono inter_subset_left hd) _
  · refine (EMetric.diam_image_le (f := f) (s := t ∩ sᶜ)).trans_eq' ?_
    rw [EMetric.diam_union (s := f '' (t ∩ s)) (t := f '' (t ∩ sᶜ))
        (hd₂ := EMetric.diam_image_le (f := f) (s := t ∩ sᶜ)).ne]
    simp only [inter_union_distrib_left, image_inter_preimage, EMetric.diam_image_le,
      EMetric.diam_union (s := f '' (t ∩ s)) (t := f '' (t ∩ sᶜ))
        (hd₂ := EMetric.diam_image_le (f := f) (s := t ∩ sᶜ)).ne,
      EMetric.diam_image_le (f := f) (s := t ∩ sᶜ), EMetric.diam_image_le (f := f) (s := t ∩ s),
      EMetric.ediam_image_le_iff_ediam_image_le_mul_rpow_of_subset_closure hf.continuousOn
        inter_subset_left,
      EMetric.ediam_image_le_iff_ediam_image_le_mul_rpow_of_subset_closure hf.continuousOn
        inter_subset_right]
    rw [← ENNReal.rpow_le_rpow_iff hr', ← mul_assoc, ← ENNReal.rpow_add _ _ hr']
    exact hf.ediam_image_le_of_subset_ediam_image_le_mul_rpow_of_ediam_image_le
      (EMetric.diam_mono inter_subset_right hd) _

Repaired Proof:
theorem ediam_image_inter_le_of_le (hf : HolderOnWith C r f s) {d : ℝ≥0∞}
    (hd : EMetric.diam t ≤ d) : EMetric.diam (f '' (t ∩ s)) ≤ (C : ℝ≥0∞) * d ^ (r : ℝ) ∧
      EMetric.diam (f '' (t ∩ sᶜ)) ≤ (C : ℝ≥0∞) * d ^ (r : ℝ) := by
  rcases eq_or_ne r 0 with (rfl | hr)
  · simp only [rpow_zero, ENNReal.mul_one]
    rw [EMetric.diam_image_eq_zero_iff]
    intro x hx y hy
    exact hf.edist_le_zero_of_dist_le_zero (hd.trans EMetric.diam_nonpos) ⟨x, hx, rfl⟩ ⟨y, hy, rfl⟩
  have hr' : 0 < (r : ℝ) := hr.bot_lt
  have Cpos : 0 < (C : ℝ) := zero_lt_one.trans_le hf.C.2
  have Cd : 0 ≤ (C : ℝ) * d ^ (r : ℝ) := by positivity
  refine ⟨?_, ?_⟩
  · refine (EMetric.diam_image_le (f := f) (s := t ∩ s)).trans_eq' ?_
    rw [EMetric.diam_union (s := f '' (t ∩ sᶜ)) (t := f '' (t ∩ s))
        (hd₂ := EMetric.diam_image_le (f := f) (s := t ∩ sᶜ)).ne]
    simp only [inter_union_distrib_left, image_inter_preimage, EMetric.diam_image_le,
      EMetric.diam_union (s := f '' (t ∩ s)) (t := f '' (t ∩ sᶜ))
        (hd₂ := EMetric.diam_image_le (f := f) (s := t ∩ sᶜ)).ne,
      EMetric.diam_image_le (f := f) (s := t ∩ sᶜ), EMetric.diam_image_le (f := f) (s := t ∩ s),
      EMetric.ediam_image_le_iff_ediam_image_le_mul_rpow_of_subset_closure hf.continuousOn
        inter_subset_left,
      EMetric.ediam_image_le_iff_ediam_image_le_mul_rpow_of_subset_closure hf.continuousOn
        inter_subset_right]
    rw [← ENNReal.rpow_le_rpow_iff hr', ← mul_assoc, ← ENNReal.rpow_add _ _ hr']
    exact hf.ediam_image_le_of_subset_ediam_image_le_mul_rpow_of_ediam_image_le
      (EMetric.diam_mono inter_subset_left hd) _
  · refine (EMetric.diam_image_le (f := f) (s := t ∩ sᶜ)).trans_eq' ?_
    rw [EMetric.diam_union (s := f '' (t ∩ s)) (t := f '' (t ∩ sᶜ))
        (hd₂ := EMetric.diam_image_le (f := f) (s := t ∩ sᶜ)).ne]
    simp only [inter_union_distrib_left, image_inter_preimage, EMetric.diam_image_le,
      EMetric.diam_union (s := f '' (t ∩ s)) (t := f '' (t ∩ sᶜ))
        (hd₂ := EMetric.diam_image_le (f := f) (s := t ∩ sᶜ)).ne,
      EMetric.diam_image_le (f := f) (s := t ∩ sᶜ), EMetric.diam_image_le (f := f) (s :=

Attempt failure.

Working on Mathlib/Topology/OmegaCompletePartialOrder.lean - 2024-09-09 02:23:25.749353.
---198/200---
For theorem notBelow_isOpen in Mathlib/Topology/OmegaCompletePartialOrder.lean:
theorem notBelow_isOpen : IsOpen (notBelow y) 


Original valid proof:
:= by
  have h : Monotone (notBelow y) := fun x z hle ↦ mt hle.trans
  refine ⟨h, fun c ↦ eq_of_forall_ge_iff fun z ↦ ?_⟩
  simp only [ωSup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]


Verifying proof (Commit 4fafac3c913ccc407e26d1bc00d7f75cec309030):
∧ IsClosed (notBelow y) := by
  refine' ⟨isOpen_iff_mem_nhds.2 fun x hx => _, _⟩
  · obtain ⟨z, hz₁, hz₂⟩ := hx
    obtain ⟨u, v, hu, hv, xu, zv, uv⟩ := exists_pair_mem_nhds (hz₂.trans_le hz₁)
    exact ⟨v, mem_nhds_iff.2 ⟨v, Subset.rfl, hv, zv⟩, u, mem_nhds_iff.2 ⟨u, Subset.rfl, hu, xu⟩, uv⟩
  · refine' isClosed_iff_nhds.2 fun x hx => _
    obtain ⟨z, hz₁, hz₂⟩ := hx
    obtain ⟨u, v, hu, hv, xu, zv, uv⟩ := exists_pair_mem_nhds (hz₂.trans_le hz₁)
    exact ⟨v, mem_nhds_iff.2 ⟨v, Subset.rfl, hv, zv⟩, u, mem_nhds_iff.2 ⟨u, Subset.rfl, hu, xu⟩, uv⟩

Repaired Proof:
theorem notBelow_isOpen : IsOpen (notBelow y) ∧ IsClosed (notBelow y) := by
  refine ⟨isOpen_iff_mem_nhds.2 fun x hx => ?_, isClosed_iff_nhds.2 fun x hx => ?_⟩
  · obtain ⟨z, hz₁, hz₂⟩ := hx
    obtain ⟨u, v, hu, hv, xu, zv, uv⟩ := exists_pair_mem_nhds (hz₂.trans_le hz₁)
    exact ⟨v, mem_nhds_iff.2 ⟨v, Subset.rfl, hv, zv⟩, u,
      mem_nhds_iff.2 ⟨u, Subset.rfl, hu, xu⟩, uv⟩
  · obtain ⟨z, hz₁, hz₂⟩ := hx
    obtain ⟨u, v, hu, hv, xu, zv, uv⟩ := exists_pair_mem_nhds (hz₂.trans_le hz₁)
    exact ⟨v, mem_nhds_iff.2 ⟨v, Subset.rfl, hv, zv⟩, u,
      mem_nhds_iff.2 ⟨u, Subset.rfl, hu, xu⟩, uv⟩

Repaired Proof:
theorem notBelow_isOpen : IsOpen (notBelow y) ∧ IsClosed (notBelow y) := by
  refine ⟨isOpen_iff_mem_nhds.2 fun x hx => ?_, isClosed_iff_nhds.2 fun x hx => ?_⟩
  · obtain ⟨z, hz₁, hz₂⟩ := hx
    obtain ⟨u, v, hu, hv, xu, zv, uv⟩ := exists_pair_mem_nhds (hz₂.trans_le hz₁)
    exact ⟨v, mem_nhds_iff.2 ⟨v, Subset.rfl, hv, zv⟩, u,
      mem_nhds_iff.2 ⟨u, Subset.rfl, hu, xu⟩, uv⟩
  · obtain ⟨z, hz₁, hz₂⟩ := hx
    obtain ⟨u, v, hu, hv, xu, zv, uv⟩ := exists_pair_mem_nhds (hz₂.trans_le hz₁)
    exact ⟨v, mem_nhds_iff.2 ⟨v, Subset.rfl, hv, zv⟩, u,
      mem_nhds_iff.2 ⟨u, Subset.rfl, hu, xu⟩, uv⟩

Repaired Proof:
theorem notBelow_isOpen : IsOpen (notBelow y) ∧ IsClosed (notBelow y) := by
  refine ⟨isOpen_iff_mem_nhds.2 fun x hx => ?_, isClosed_iff_nhds.2 fun x hx => ?_⟩
  · obtain ⟨z, hz₁, hz₂⟩ := hx
    obtain ⟨u, v, hu, hv, xu, zv, uv⟩ := exists_pair_mem_nhds (hz₂.trans_le hz₁)
    exact ⟨v, mem_nhds_iff.2 ⟨v, Subset.rfl, hv, zv⟩, u,
      mem_nhds_iff.2 ⟨u, Subset.rfl, hu, xu⟩, uv⟩
  · obtain ⟨z, hz₁, hz₂⟩ := hx
    obtain ⟨u, v, hu, hv, xu, zv, uv⟩ := exists_pair_mem_nhds (hz₂.trans_le hz₁)
    exact ⟨v, mem_nhds_iff.2 ⟨v, Subset.rfl, hv, zv⟩, u,
      mem_nhds_iff.2 ⟨u, Subset.rfl, hu, xu⟩, uv⟩

Attempt failure.

Working on Mathlib/Topology/Order/IsLUB.lean - 2024-09-09 02:23:31.527341.
---199/200---
For theorem IsLUB.mem_upperBounds_of_tendsto in Mathlib/Topology/Order/IsLUB.lean:
theorem IsLUB.mem_upperBounds_of_tendsto [Preorder γ] [TopologicalSpace γ] [OrderClosedTopology γ]
    {f : α → γ} {s : Set α} {a : α} {b : γ} (hf : MonotoneOn f s) (ha : IsLUB s a)
    (hb : Tendsto f (𝓝[s] a) (𝓝 b)) : b ∈ upperBounds (f '' s) 


Original valid proof:
:= by
  rintro _ ⟨x, hx, rfl⟩
  replace ha := ha.inter_Ici_of_mem hx
  haveI := ha.nhdsWithin_neBot ⟨x, hx, le_rfl⟩
  refine ge_of_tendsto (hb.mono_left (nhdsWithin_mono a (inter_subset_left (t := Ici x)))) ?_
  exact mem_of_superset self_mem_nhdsWithin fun y hy => hf hx hy.1 hy.2


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ f a = b := by
  have h : s.Nonempty → ∃ y, y ∈ s ∧ a = y := by
    rintro ⟨y, hy⟩
    exact ⟨y, hy, ha.1 hy⟩
  have ha' : a ∈ s ∨ a ∉ s := em _
  cases' ha' with ha' ha'
  · have h₁ : f a = b := by
      apply le_antisymm
      · exact hb.eventually (eventually_ge_of_mem (Ici_mem_nhdsWithin_Ici ⟨ha'⟩) fun x => hf ha' le_rfl)
      · exact hb.eventually (eventually_le_of_mem (Iic_mem_nhdsWithin_Iic ⟨ha'⟩) fun x => hf ha' le_rfl)
    refine ⟨fun _ ⟨y, _, hy⟩ => hy ▸ hf ha' le_rfl, h₁⟩
  · have h₁ : ∀ᶠ y in 𝓝[s] a, y ≠ a := by
      apply (ha.nhdsWithin_neBot ⟨ha'⟩).mono
      intro y hy
      exact hy
    have h₂ : ∀ᶠ y in 𝓝[s] a, f y ≤ b := by
      apply hb.eventually
      apply eventually_nhdsWithin_of_eventually_nhds
      exact eventually_le_of_tendsto_lt (ha.isLUB.1 ⟨ha'⟩) h₁
    have h₃ : ∀ᶠ y in 𝓝[s] a, b ≤ f y := by
      apply hb.eventually
      apply eventually_nhdsWithin_of_eventually_nhds
      exact eventually_ge_of_tendsto_gt (ha.isLUB.1 ⟨ha'⟩) h₁
    have hb' : b ∈ upperBounds (f '' s) := fun _ ⟨y, hy₁, hy₂⟩ => by
      rw [← hy₂]
      exact hf ha' le_rfl hy₁
    exact ⟨hb', tendsto_nhds_unique hb (h₂.mono fun y hy => hy.trans h₃.self_of_nhds)⟩

Repaired Proof:
theorem IsLUB.mem_upperBounds_of_tendsto [Preorder γ] [TopologicalSpace γ] [OrderClosedTopology γ]
    {f : α → γ} {s : Set α} {a : α} {b : γ} (hf : MonotoneOn f s) (ha : IsLUB s a)
    (hb : Tendsto f (𝓝[s] a) (𝓝 b)) : b ∈ upperBounds (f '' s) ∧ f a = b := by
  have h : s.Nonempty → ∃ y, y ∈ s ∧ a = y := by
    rintro ⟨y, hy⟩
    exact ⟨y, hy, ha.1 hy⟩
  have ha' : a ∈ s ∨ a ∉ s := em _
  cases' ha' with ha' ha'
  · have h₁ : f a = b := by
      apply le_antisymm
      · exact hb.eventually (eventually_ge_of_mem (Ici_mem_nhdsWithin_Ici ⟨ha'⟩) fun x => hf ha' le_rfl)
      · exact hb.eventually (eventually_le_of_mem (Iic_mem_nhdsWithin_Iic ⟨ha'⟩) fun x => hf ha' le_rfl)
    refine ⟨fun _ ⟨y, _, hy⟩ => hy ▸ hf ha' le_rfl, h₁⟩
  · have h₁ : ∀ᶠ y in 𝓝[s] a, y ≠ a := by
      apply (ha.nhdsWithin_neBot ⟨ha'⟩).mono
      intro y hy
      exact hy
    have h₂ : ∀ᶠ y in 𝓝[s] a, f y ≤ b := by
      apply hb.eventually
      apply eventually_nhdsWithin_of_eventually_nhds
      exact eventually_le_of_tendsto_lt (ha.isLUB.1 ⟨ha'⟩) h₁
    have h₃ : ∀ᶠ y in 𝓝[s] a, b ≤ f y := by
      apply hb.eventually
      apply eventually_nhdsWithin_of_eventually_nhds
      exact eventually_ge_of_tendsto_gt (ha.isLUB.1 ⟨ha'⟩) h₁
    have hb' : b ∈ upperBounds (f '' s) := fun _ ⟨y, hy₁, hy₂⟩ => by
      rw [← hy₂]
      exact hf ha' le_rfl hy₁
    exact ⟨hb', tendsto_nhds_unique hb (h₂.mono fun y hy => hy.trans h₃.self_of_nhds)⟩

Repaired Proof:
theorem IsLUB.mem_upperBounds_of_tendsto [Preorder γ] [TopologicalSpace γ] [OrderClosedTopology γ]
    {f : α → γ} {s : Set α} {a : α} {b : γ} (hf : MonotoneOn f s) (ha : IsLUB s a)
    (hb : Tendsto f (𝓝[s] a) (𝓝 b)) : b ∈ upperBounds (f '' s) ∧ f a = b := by
  have h : s.Nonempty → ∃ y, y ∈ s ∧ a = y := by
    rintro ⟨y, hy⟩
    exact ⟨y, hy, ha.1 hy⟩
  have ha' : a ∈ s ∨ a ∉ s := em _
  cases' ha' with ha' ha'
  · have h₁ : f a = b := by
      apply le_antisymm
      · exact hb.eventually (eventually_ge_of_mem (Ici_mem_nhdsWithin_Ici ⟨ha'⟩) fun x => hf ha' le_rfl)
      · exact hb.eventually (eventually_le_of_mem (Iic_mem_nhdsWithin_Iic ⟨ha'⟩) fun x => hf ha' le_rfl)
    refine ⟨fun _ ⟨y, _, hy⟩ => hy ▸ hf ha' le_rfl, h₁⟩
  · have h₁ : ∀ᶠ y in 𝓝[s] a, y ≠ a := by
      apply (ha.nhdsWithin_neBot ⟨ha'⟩).mono
      intro y hy
      exact hy
    have h₂ : ∀ᶠ y in 𝓝[s] a, f y ≤ b := by
      apply hb.eventually
      apply eventually_nhdsWithin_of_eventually_nhds
      exact eventually_le_of_tendsto_lt (ha.isLUB.1 ⟨ha'⟩) h₁
    have h₃ : ∀ᶠ y in 𝓝[s] a, b ≤ f y := by
      apply hb.eventually
      apply eventually_nhdsWithin_of_eventually_nhds
      exact eventually_ge_of_tendsto_gt (ha.isLUB.1 ⟨ha'⟩) h₁
    have hb' : b ∈ upperBounds (f '' s) := fun _ ⟨y, hy₁, hy₂⟩ => by
      rw [← hy₂]
      exact hf ha' le_rfl hy₁
    exact ⟨hb', tendsto_nhds_unique hb (h₂.mono fun y hy => hy.trans h₃.self_of_nhds)⟩

Repaired Proof:
theorem IsLUB.mem_upperBounds_of_tendsto [Preorder γ] [TopologicalSpace γ] [OrderClosedTopology γ]
    {f : α → γ} {s : Set α} {a : α} {b : γ} (hf : MonotoneOn f s) (ha : IsLUB s a)
    (hb : Tendsto f (𝓝[s] a) (

Attempt failure.

Working on Mathlib/Topology/ProperMap.lean - 2024-09-09 02:23:38.231936.
---200/200---
For theorem isProperMap_iff_isClosedMap_and_tendsto_cofinite in Mathlib/Topology/ProperMap.lean:
lemma isProperMap_iff_isClosedMap_and_tendsto_cofinite [T1Space Y] :
    IsProperMap f ↔ Continuous f ∧ IsClosedMap f ∧ Tendsto f (cocompact X) cofinite 


Original valid proof:
:= by
  simp_rw [isProperMap_iff_isClosedMap_and_compact_fibers, Tendsto,
    le_cofinite_iff_compl_singleton_mem, mem_map, preimage_compl]
  refine and_congr_right fun f_cont ↦ and_congr_right fun _ ↦
    ⟨fun H y ↦ (H y).compl_mem_cocompact, fun H y ↦ ?_⟩
  rcases mem_cocompact.mp (H y) with ⟨K, hK, hKy⟩
  exact hK.of_isClosed_subset (isClosed_singleton.preimage f_cont)
    (compl_le_compl_iff_le.mp hKy)


Verifying proof (Commit 8c47c4038ef15eef85511d722c657967f031d078):
∧
      Tendsto f (cocompact X) (𝓝 ⊥) := by
  constructor
  · intro h
    exact ⟨h.continuous, h.isClosedMap, h.tendsto_cocompact, h.tendsto_cocompact_nhdsBot⟩
  · rintro ⟨h₁, h₂, h₃, h₄⟩
    refine' ⟨h₁, fun s hs ↦ _⟩
    obtain ⟨U, hU₁, hU₂⟩ : ∃ U, IsOpen U ∧ f ⁻¹' U = s := h₂ hs
    have : IsClosed (f '' s)ᶜ := by
      rw [← hU₂, ← preimage_compl, isClosed_preimage, isOpen_compl_iff]
      exact hU₁
    obtain ⟨K, hK₁, hK₂⟩ : ∃ K, IsCompact K ∧ f '' s ⊆ interior K :=
      this.exists_isCompact_isClosed_subset isOpen_interior ⟨_, mem_image_of_mem _ (hs.isClosed.isOpen_compl.mem_nhds
        (compl_subset_compl.mpr hK₂)), subset_interior_iff_isOpen.mpr hU₁⟩
    obtain ⟨F, hF₁, hF₂⟩ : ∃ F, IsClosed F ∧ f ⁻¹' F = Kᶜ := by
      have : IsClosed (Kᶜ)ᶜ := by
        rw [compl_compl]
        exact hK₁.isClosed
      obtain ⟨F, hF₁, hF₂⟩ : ∃ F, IsClosed F ∧ f ⁻¹' F = (Kᶜ)ᶜ := h₂ this
      exact ⟨F, hF₁, by rw [preimage_compl, hF₂, compl_compl]⟩
    have : f '' s ⊆ interior F := by
      rw [← hF₂, image_subset_iff]
      exact subset_compl_comm.mp hK₂
    rw [hU₂]
    exact ⟨s, Subset.rfl, h₁.isOpen_preimage _ isOpen_interior, this⟩

Repaired Proof:
lemma isProperMap_iff_isClosedMap_and_tendsto_cofinite [T1Space Y] :
    IsProperMap f ↔ Continuous f ∧ IsClosedMap f ∧ Tendsto f (cocompact X) cofinite ∧
      Tendsto f (cocompact X) (𝓝 ⊥) := by
  constructor
  · intro h
    exact ⟨h.continuous, h.isClosedMap, h.tendsto_cocompact, h.tendsto_cocompact_nhdsBot⟩
  · rintro ⟨h₁, h₂, h₃, h₄⟩
    refine ⟨h₁, fun s hs ↦ ?_⟩
    obtain ⟨U, hU₁, hU₂⟩ : ∃ U, IsOpen U ∧ f ⁻¹' U = s := h₂ hs
    have : IsClosed (f '' s)ᶜ := by
      rw [← hU₂, ← preimage_compl, isClosed_preimage, isOpen_compl_iff]
      exact hU₁
    obtain ⟨K, hK₁, hK₂⟩ : ∃ K, IsCompact K ∧ f '' s ⊆ interior K :=
      this.exists_isCompact_isClosed_subset isOpen_interior ⟨_, mem_image_of_mem _ (hs.isClosed.isOpen_compl.mem_nhds
        (compl_subset_compl.mpr hK₂)), subset_interior_iff_isOpen.mpr hU₁⟩
    obtain ⟨F, hF₁, hF₂⟩ : ∃ F, IsClosed F ∧ f ⁻¹' F = Kᶜ := by
      have : IsClosed (Kᶜ)ᶜ := by
        rw [compl_compl]
        exact hK₁.isClosed
      obtain ⟨F, hF₁, hF₂⟩ : ∃ F, IsClosed F ∧ f ⁻¹' F = (Kᶜ)ᶜ := h₂ this
      exact ⟨F, hF₁, by rw [preimage_compl, hF₂, compl_compl]⟩
    have : f '' s ⊆ interior F := by
      rw [← hF₂, image_subset_iff]
      exact subset_compl_comm.mp hK₂
    rw [hU₂]
    exact ⟨s, Subset.rfl, h₁.isOpen_preimage _ isOpen_interior, this⟩

Repaired Proof:
lemma isProperMap_iff_isClosedMap_and_tendsto_cofinite [T1Space Y] :
    IsProperMap f ↔ Continuous f ∧ IsClosedMap f ∧ Tendsto f (cocompact X) cofinite ∧
      Tendsto f (cocompact X) (𝓝 ⊥) := by
  constructor
  · intro h
    exact ⟨h.continuous, h.isClosedMap, h.tendsto_cocompact, h.tendsto_cocompact_nhdsBot⟩
  · rintro ⟨h₁, h₂, h₃, h₄⟩
    refine ⟨h₁, fun s hs ↦ ?_⟩
    obtain ⟨U, hU₁, hU₂⟩ : ∃ U, IsOpen U ∧ f ⁻¹' U = s := h₂ hs
    have : IsClosed (f '' s)ᶜ := by
      rw [← hU₂, ← preimage_compl, isClosed_preimage, isOpen_compl_iff]
      exact hU₁
    obtain ⟨K, hK₁, hK₂⟩ : ∃ K, IsCompact K ∧ f '' s ⊆ interior K :=
      this.exists_isCompact_isClosed_subset isOpen_interior ⟨_, mem_image_of_mem _ (hs.isClosed.isOpen_compl.mem_nhds
        (compl_subset_compl.mpr hK₂)), subset_interior_iff_isOpen.mpr hU₁⟩
    obtain ⟨F, hF₁, hF₂⟩ : ∃ F, IsClosed F ∧ f ⁻¹' F = Kᶜ := by
      have : IsClosed (Kᶜ)ᶜ := by
        rw [compl_compl]
        exact hK₁.isClosed
      obtain ⟨F, hF₁, hF₂⟩ : ∃ F, IsClosed F ∧ f ⁻¹' F = (Kᶜ)ᶜ := h₂ this
      exact ⟨F, hF₁, by rw [preimage_compl, hF₂, compl_compl]⟩
    have : f '' s ⊆ interior F := by
      rw [← hF₂, image_subset_iff]
      exact subset_compl_comm.mp hK₂
    rw [hU₂]
    exact ⟨s, Subset.rfl, h₁.isOpen_preimage _ isOpen_interior, this⟩

Repaired Proof:
lemma isProperMap_iff_isClosedMap_and_tendsto_cofinite [T1Space Y] :
    IsProperMap f ↔ Continuous f ∧ IsClosedMap f ∧ Tendsto f (cocompact X) cofinite ∧
      Tendsto f (cocompact X) (𝓝 ⊥) := by
  constructor
  · intro h
    exact ⟨h.continuous, h.isClosedMap, h.tendsto_cocompact, h.tendsto_cocompact_nhdsBot⟩
  · rintro ⟨h₁, h₂, h₃, h₄⟩
    refine ⟨h₁, fun s hs ↦ ?_⟩
    obtain ⟨U, hU₁, hU₂⟩ : ∃ U, IsOpen U ∧ f ⁻¹' U = s := h₂ hs
    have : IsClosed (f '' s)ᶜ := by
      rw [← hU₂, ← preimage_compl

Attempt failure.

STARTING: Lean repo copy removal
DONE: Lean repo copy removal
Among 200 proof attempts, there were 0 successful and 200 failed attempts at proving their respect theorems.
The rate of successful proof = 0.0.
