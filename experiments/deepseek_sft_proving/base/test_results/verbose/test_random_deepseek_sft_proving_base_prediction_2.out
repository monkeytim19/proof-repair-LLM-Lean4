STARTING: verification of proofs from predicted_proof column in dataset from models/deepseek_sft_proving/base/test_random_deepseek_sft_proving_base_prediction.csv - 2024-09-08 17:38:55.351715
STARTING: Lean repo copy creation
DONE: Lean repo copy creation
STARTING: retrieve cache
installing leantar 0.1.13
Attempting to download 4738 file(s)
Decompressing 4738 file(s)
Unpacked in 279348 ms
Completed successfully!
DONE: retrieved cache
Working on Mathlib/Algebra/Associated.lean - 2024-09-08 18:05:59.256676.
---1/200---
For theorem prime_pow_iff in Mathlib/Algebra/Associated.lean:
lemma prime_pow_iff [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ Prime p ∧ n = 1 


Original valid proof:
:= by
  refine ⟨fun hp ↦ ?_, fun ⟨hp, hn⟩ ↦ by simpa [hn]⟩
  suffices n = 1 by aesop
  cases' n with n
  · simp at hp
  · rw [Nat.succ.injEq]
    rw [pow_succ', prime_mul_iff] at hp
    rcases hp with ⟨hp, hpn⟩ | ⟨hp, hpn⟩
    · by_contra contra
      rw [isUnit_pow_iff contra] at hpn
      exact hp.not_unit hpn
    · exfalso
      exact hpn.not_unit (hp.pow n)


Verifying proof (Commit 3bb2cb9fea0fbb1bf6bf2e7773ba73b51952e9e5):
∨ p = 0 ∧ n ≠ 0 := by
  constructor
  · intro h
    cases' n with n
    · simp only [Nat.zero_eq, pow_zero, true_and, eq_self_iff_true, zero_ne_one, false_or]
      exact ⟨h.1, one_ne_zero⟩
    · cases' n with n
      · simp only [eq_self_iff_true, true_and, Nat.one_eq_succ_zero, pow_one, zero_ne_one,
          false_or]
        exact ⟨h.1, one_ne_zero⟩
      · cases' n with n
        · simp only [eq_self_iff_true, true_and, Nat.succ_add_eq_succ_add,
            Nat.one_eq_succ_zero, pow_one, zero_ne_one, false_or]
          exact ⟨h.1, one_ne_zero⟩
        · exfalso
          have : p ^ (n + 3) = 0 := by
            have : n + 3 ≠ 0 := by omega
            rw [pow_eq_zero_iff this]
            exact h.2.2 _ (dvd_pow_self p (by omega))
          exact h.1.ne_zero this
  · rintro (⟨hp, rfl⟩ | ⟨rfl, hn⟩)
    · simp only [pow_one, hp, true_and]
    · simp only [pow_zero, one_ne_zero, false_or, zero_ne_one]
      exact ⟨hp, hn⟩

lemma prime_pow_iff' [CancelCommMonoidWithZero α] {p : α} {n : ℕ} :
    Prime (p ^ n) ↔ n = 1 ∧ Prime p ∨ p = 0 ∧ n ≠ 0 := by
  rw [prime_pow_iff, and_comm, or_comm, and_or_left, and_or_left, and_or_left]
  simp only [and_true, or_false, and_false, or_true, and_true_iff, and_false_iff,
    or_false_iff, and_or_left, and_or_right, and_self_iff, or_self_iff]
  tauto
```

Attempt failure.

Working on Mathlib/Algebra/CharP/CharAndCard.lean - 2024-09-08 18:06:38.766938.
---2/200---
For theorem isUnit_iff_not_dvd_char in Mathlib/Algebra/CharP/CharAndCard.lean:
theorem isUnit_iff_not_dvd_char_of_ringChar_ne_zero (R : Type*) [CommRing R] (p : ℕ) [Fact p.Prime]
    (hR : ringChar R ≠ 0) : IsUnit (p : R) ↔ ¬p ∣ ringChar R 


Original valid proof:
:= by
  have hch := CharP.cast_eq_zero R (ringChar R)
  have hp : p.Prime := Fact.out
  constructor
  · rintro h₁ ⟨q, hq⟩
    rcases IsUnit.exists_left_inv h₁ with ⟨a, ha⟩
    have h₃ : ¬ringChar R ∣ q := by
      rintro ⟨r, hr⟩
      rw [hr, ← mul_assoc, mul_comm p, mul_assoc] at hq
      nth_rw 1 [← mul_one (ringChar R)] at hq
      exact Nat.Prime.not_dvd_one hp ⟨r, mul_left_cancel₀ hR hq⟩
    have h₄ := mt (CharP.intCast_eq_zero_iff R (ringChar R) q).mp
    apply_fun ((↑) : ℕ → R) at hq
    apply_fun (· * ·) a at hq
    rw [Nat.cast_mul, hch, mul_zero, ← mul_assoc, ha, one_mul] at hq
    norm_cast at h₄
    exact h₄ h₃ hq.symm
  · intro h
    rcases (hp.coprime_iff_not_dvd.mpr h).isCoprime with ⟨a, b, hab⟩
    apply_fun ((↑) : ℤ → R) at hab
    push_cast at hab
    rw [hch, mul_zero, add_zero, mul_comm] at hab
    exact isUnit_of_mul_eq_one (p : R) a hab


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∧ ringChar R ≠ 0 := by
  rw [isUnit_iff_not_dvd_of_char_ne_zero hR]
  exact ⟨fun h => ⟨h, hR⟩, fun h => h.2⟩


theorem isUnit_iff_not_dvd_char_of_ringChar_ne_zero' (R : Type*) [CommRing R] (p : ℕ) [Fact p.Prime]
    (hR : ringChar R ≠ 0) : IsUnit (p : R) ↔ ¬p ∣ ringChar R := by
  rw [isUnit_iff_not_dvd_char_of_ringChar_ne_zero R p hR]
  exact ⟨fun h => h.1, fun h => ⟨h, hR⟩⟩


theorem isUnit_iff_not_dvd_char_of_ringChar_ne_zero'' (R : Type*) [CommRing R] (p : ℕ) [Fact p.Prime]
    (hR : ringChar R ≠ 0) : IsUnit (p : R) ↔ ringChar R ≠ 0 := by
  rw [isUnit_iff_not_dvd_char_of_ringChar_ne_zero R p hR]
  exact ⟨fun h => h.2, fun h => ⟨fun h' => h (h' ▸ hR), hR⟩⟩
```

Attempt failure.

Working on Mathlib/Algebra/FreeAlgebra.lean - 2024-09-08 18:07:09.903284.
---3/200---
For theorem FreeAlgebra.induction in Mathlib/Algebra/FreeAlgebra.lean:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a 


Original valid proof:
:= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X → s := Subtype.coind (ι R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a


Verifying proof (Commit 0bcbc985a529d2af125537fab684cb3a98de2f6f):
→ C (ι R a) := by
  intro h
  have h1 : C (ι R a) := by
    have h2 : C (ι R a * ι R (0 : X)) := h_mul _ _ (h_grade1 a) (h_grade0 0)
    simpa using h2
  exact h1

/-- The left-inverse of `algebraMap`. -/
def algebraMapInv : FreeAlgebra R X →ₐ[R] R :=
  Algebra.ofId R (FreeAlgebra R X)

/-- The right-inverse of `algebraMap`. -/
def algebraMapInv' : FreeAlgebra R X →ₐ[R] R :=
  Algebra.ofId R (FreeAlgebra R X)

/-- The left-inverse of `ι`. -/
def ιInv : FreeAlgebra R X →ₐ[R] FreeAlgebra R X :=
  FreeAlgebra.lift R fun x => algebraMapInv (ι R x)

/-- The right-inverse of `ι`. -/
def ιInv' : FreeAlgebra R X →ₐ[R] FreeAlgebra R X :=
  FreeAlgebra.lift R fun x => algebraMapInv' (ι R x)

/-- The two inverses are in fact equal. -/
theorem ιInv_eq_ιInv' : ιInv = ιInv' := by
  ext
  simp [ιInv, ιInv', FreeAlgebra.lift_ι_apply, algebraMapInv, algebraMapInv']

/-- The free algebra over `R` is a `R`-algebra. -/
instance : Algebra R (FreeAlgebra R X) where
  -- We need the `Algebra.ofId` function, which is just `algebraMap`.
  -- This is defined in `Mathlib/Algebra/Algebra/Defs.lean`.
  toRingHom := algebraMap
  commutes' := by
    intro r x
    dsimp [algebraMap]
    rw [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ←

Attempt failure.

Working on Mathlib/Algebra/Group/Hom/Defs.lean - 2024-09-08 18:07:36.338657.
---4/200---
For theorem Subsingleton.of_oneHomClass in Mathlib/Algebra/Group/Hom/Defs.lean:
theorem Subsingleton.of_oneHomClass [Subsingleton M] [OneHomClass F M N] :
    Subsingleton F where



Original valid proof:
  allEq f g := DFunLike.ext _ _ fun x ↦ by simp [Subsingleton.elim x 1]


Verifying proof (Commit 650b48365a265f18ee37b34dfd26cc8d9de5d6d7):
  allEq f g := DFunLike.ext _ _ fun x ↦ by
    rw [Subsingleton.elim x 1, map_one, map_one]


theorem Subsingleton.of_mulHomClass [MulOneClass M] [Subsingleton M] [MulHomClass F M N] :
    Subsingleton F where
  allEq f g := DFunLike.ext _ _ fun x ↦ by
    rw [Subsingleton.elim x 1, map_one, map_one]


theorem Subsingleton.of_monoidHomClass [MulOneClass M] [Subsingleton M]
    [MonoidHomClass F M N] : Subsingleton F where
  allEq f g := DFunLike.ext _ _ fun x ↦ by
    rw [Subsingleton.elim x 1, map_one, map_one]


instance [Subsingleton M] [Subsingleton N] [OneHomClass F M N] : Subsingleton F where
  allEq f g := DFunLike.ext _ _ fun x ↦ by simp only [Subsingleton.elim x 1, map_one, Subsingleton.elim_eq]

instance [Subsingleton M] [Subsingleton N] [MulHomClass F M N] : Subsingleton F where
  allEq f g := DFunLike.ext _ _ fun x ↦ by simp only [Subsingleton.elim x 1, map_one, Subsingleton.elim_eq]

instance [Subsingleton M] [Subsingleton N] [MonoidHomClass F M N] : Subsingleton F where
  allEq f g := DFunLike.ext _ _ fun x ↦ by simp only [Subsingleton.elim x 1, map_one, Subsingleton.elim_eq]

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N]
    [MulHomClass F M N] : Subsingleton (M →ₙ* N) :=
  .of_oneHomClass

instance [Subsingleton M] [Subsingleton N] [Monoid M] [Monoid N] [MonoidHomClass F M N] :
    Subsingleton (M →* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [Add M] [Add N] [AddHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [Add M] [Add N] [AddEquivClass F M N] :
    Subsingleton (M ≃+ N) :=
  .of_addHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddEquivClass F M N] :
    Subsingleton (M ≃+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MulEquivClass F M N] :
    Subsingleton (M ≃* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddEquivClass F M N] :
    Subsingleton (M ≃+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddEquivClass F M N] :
    Subsingleton (M ≃+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MonoidHomClass F M N] :
    Subsingleton (M →* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MulEquivClass F M N] :
    Subsingleton (M ≃* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddEquivClass F M N] :
    Subsingleton (M ≃+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddEquivClass F M N] :
    Subsingleton (M ≃+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MonoidHomClass F M N] :
    Subsingleton (M →* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MulEquivClass F M N] :
    Subsingleton (M ≃* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddEquivClass F M N] :
    Subsingleton (M ≃+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddEquivClass F M N] :
    Subsingleton (M ≃+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MonoidHomClass F M N] :
    Subsingleton (M →* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MulEquivClass F M N] :
    Subsingleton (M ≃* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddEquivClass F M N] :
    Subsingleton (M ≃+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddEquivClass F M N] :
    Subsingleton (M ≃+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MonoidHomClass F M N] :
    Subsingleton (M →* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MonoidHomClass F M N] :
    Subsingleton (M →* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MonoidHomClass F M N] :
    Subsingleton (M →* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MonoidHomClass F M N] :
    Subsingleton (M →* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZeroClass M] [AddZeroClass N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddCommMonoid M] [AddCommMonoid N] [AddMonoidHomClass F M N] :
    Subsingleton (M →+ N) :=
  .of_addMonoidHomClass

instance [Subsingleton M] [Subsingleton N] [MulOneClass M] [MulOneClass N] [MonoidHomClass F M N] :
    Subsingleton (M →* N) :=
  .of_monoidHomClass

instance [Subsingleton M] [Subsingleton N] [AddZero

Attempt failure.

Working on Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean - 2024-09-08 18:08:03.666283.
---5/200---
For theorem CochainComplex.HomComplex.δ_shape in Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean:
lemma δ_shape (hnm : ¬ n + 1 = m) (z : Cochain F G n) : δ n m z = 0 


Original valid proof:
:= by
  ext p q hpq
  dsimp only [δ]
  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  all_goals
    simp only [ComplexShape.up_Rel]
    exact fun _ => hnm (by omega)


Verifying proof (Commit fc5d3dffc7c439022141babb13bcb52a72d9f631):
 := by
  by_cases h : n < m
  · exact δ_shape' h z
  · simp only [not_lt] at h
    have h' : m < n := lt_of_le_of_ne h (ne_of_not_eq hnm)
    rw [δ_shape' h']

The proof of the lemma `δ_shape` is a part of the `cochain_complex` namespace, which is a collection of definitions, theorems, and lemmas related to cochain complexes in homological algebra. The lemma `δ_shape` is a fundamental property of the cochain complex, stating that the differential `δ n m` is zero when `n + 1 ≠ m`. This property is essential for the definition and computation of cohomology groups in homological algebra.

Attempt failure.

---6/200---
For theorem CochainComplex.HomComplex.Cocycle.coe_sub in Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean:
lemma coe_sub (z₁ z₂ : Cocycle F G n) :
    (↑(z₁ - z₂) : Cochain F G n) = (z₁ : Cochain F G n) - (z₂ : Cochain F G n) 


Original valid proof:
:= rfl


Verifying proof (Commit 9072ff84a0d139a344bf9eed4a00c4cd27596c79):
 := rfl

@[simp]
lemma sub_v (z₁ z₂ : Cocycle F G n) (p : Σ i, P i) :
    (z₁ - z₂).v p = z₁.v p - z₂.v p := rfl

instance : AddCommGroup (Cocycle F G n) :=
{ add_assoc := fun _ _ _ => Cochain.ext _ _ (add_assoc _ _ _)
  zero_add := fun _ => Cochain.ext _ _ (zero_add _)
  add_left_neg := fun _ => Cochain.ext _ _ (add_left_neg _)
  add_comm := fun _ _ => Cochain.ext _ _ (add_comm _ _)
  sub_eq_add_neg := fun _ _ => Cochain.ext _ _ (sub_eq_add_neg _ _)
  nsmul := nsmulRec
  zsmul := zsmulRec }

instance : Module R (Cocycle F G n) :=
{ smul_add := fun r _ _ => Cochain.ext _ _ (smul_add r _ _)
  add_smul := fun r s _ => Cochain.ext _ _ (add_smul r s _)
  mul_smul := fun r s _ => Cochain.ext _ _ (mul_smul r s _)
  one_smul := fun _ => Cochain.ext _ _ (one_smul _ _)
  zero_smul := fun _ => Cochain.ext _ _ (zero_smul _ _)
  smul_zero := fun _ => Cochain.ext _ _ (smul_zero _ _) }

instance : Inhabited (Cocycle F G n) :=
  ⟨0⟩

/-- The composition of morphisms of complexes. -/
def comp (z₁ : Cocycle F G n) (z₂ : Cocycle G H n) : Cocycle F H n :=
  Cocycle.mk (Cochain.comp z₁.1 z₂.1 (add_comm n n)) (n + n) rfl

@[simp]
lemma comp_v (z₁ : Cocycle F G n) (z₂ : Cocycle G H n) (p : Σ i, P i) :
    (z₁.comp z₂).v p = z₁.v p.1 ≫ z₂.v p.2 := rfl

@[simp]
lemma comp_zero (z₁ : Cocycle F G n) : z₁.comp (0 : Cocycle G H n) = 0 := by aesop_cat

@[simp]
lemma zero_comp (z₂ : Cocycle G H n) : (0 : Cocycle F G n).comp z₂ = 0 := by aesop_cat

@[simp]
lemma comp_add (z₁ : Cocycle F G n) (z₂ z₃ : Cocycle G H n) :
    z₁.comp (z₂ + z₃) = z₁.comp z₂ + z₁.comp z₃ := by aesop_cat

@[simp]
lemma add_comp (z₁ z₂ : Cocycle F G n) (z₃ : Cocycle G H n) :
    (z₁ + z₂).comp z₃ = z₁.comp z₃ + z₂.comp z₃ := by aesop_cat

@[simp]
lemma comp_sub (z₁ : Cocycle F G n) (z₂ z₃ : Cocycle G H n) :
    z₁.comp (z₂ - z₃) = z₁.comp z₂ - z₁.comp z₃ := by aesop_cat

@[simp]
lemma sub_comp (z₁ z₂ : Cocycle F G n) (z₃ : Cocycle G H n) :
    (z₁ - z₂).comp z₃ = z₁.comp z₃ - z₂.comp z₃ := by aesop_cat

@[simp]
lemma comp_smul (z₁ : Cocycle F G n) (r : R) (z₂ : Cocycle G H n) :
    z₁.comp (r • z₂) = r • (z₁.comp z₂) := by aesop_cat

@[simp]
lemma smul_comp (r : R) (z₁ : Cocycle F G n) (z₂ : Cocycle G H n) :
    (r • z₁).comp z₂ = r • (z₁.comp z₂) := by aesop_cat

instance : Module R (Cocycle F G n) :=
{ smul_add := fun r _ _ => Cochain.ext _ _ (smul_add r _ _)
  add_smul := fun r s _ => Cochain.ext _ _ (add_smul r s _)
  mul_smul := fun r s _ => Cochain.ext _ _ (mul_smul r s _)
  one_smul := fun _ => Cochain.ext _ _ (one_smul _ _)
  zero_smul := fun _ => Cochain.ext _ _ (zero_smul _ _)
  smul_zero := fun _ => Cochain.ext _ _ (smul_zero _ _) }

instance : Inhabited (Cocycle F G n) :=
  ⟨0⟩

/-- The composition of morphisms of complexes. -/
def comp (z₁ : Cocycle F G n) (z₂ : Cocycle G H n) : Cocycle F H n :=
  Cocycle.mk (Cochain.comp z₁.1 z₂.1 (add_comm n n)) (n + n) rfl

@[simp]
lemma comp_v (z₁ : Cocycle F G n) (z₂ : Cocycle G H n) (p : Σ i, P i) :
    (z₁.comp z₂).v p = z₁.v p.1 ≫ z₂.v p.2 := rfl

@[simp]
lemma comp_zero (z₁ : Cocycle F G n) : z₁.comp (0 : Cocycle G H n) = 0 := by aesop_cat

@[simp]
lemma zero_comp (z₂ : Cocycle G H n) : (0 : Cocycle F G n).comp z₂ = 0 := by aesop_cat

@[simp]
lemma comp_add (z₁ : Cocycle F G n) (z₂ z₃ : Cocycle G H n) :
    z₁.comp (z₂ + z₃) = z₁.comp z₂ + z₁.comp z₃ := by aesop_cat

@[simp]
lemma add_comp (z₁ z₂ : Cocycle F G n) (z₃ : Cocycle G H n) :
    (z₁ + z₂).comp z₃ = z₁.comp z₃ + z₂.comp z₃ := by aesop_cat

@[simp]
lemma comp_sub (z₁ : Cocycle F G n) (z₂ z₃ : Cocycle G H n) :
    z₁.comp (z₂ - z₃) = z₁.comp z₂ - z₁.comp z₃ := by aesop_cat

@[simp]
lemma sub_comp (z₁ z₂ : Cocycle F G n) (z₃ : Cocycle G H n) :
    (z₁ - z₂).comp z₃ = z₁.comp z₃ - z₂.comp z₃ := by aesop_cat

@[simp]
lemma comp_smul (z₁ : Cocycle F G n) (r : R) (z₂ : Cocycle G H n) :
    z₁.comp (r • z₂) = r • (z₁.comp z₂) := by aesop_cat

@[simp]
lemma smul_comp (r : R) (z₁ : Cocycle F G n) (z₂ : Cocycle G H n) :
    (r • z₁).comp z₂ = r • (z₁.comp z₂) := by aesop_cat

instance : Module R (Cocycle F G n) :=
{ smul_add := fun r _ _ => Cochain.ext _ _ (smul_add r _ _)
  add_smul := fun r s _ => Cochain.ext _ _ (add_smul r s _)
  mul_smul := fun r s _ => Cochain.ext _ _ (mul_smul r s _)
  one_smul := fun _ => Cochain.ext _ _ (one_smul _ _)
  zero_smul := fun _ => Cochain.ext _ _ (zero_smul _ _)
  smul_zero := fun _ => Cochain.ext _ _ (smul_zero _ _) }

instance : Inhabited (Cocycle F G n) :=
  ⟨0⟩

/-- The composition of morphisms of complexes. -/
def comp (z₁ : Cocycle F G n) (z₂ : Cocycle G H n) : Cocycle F H n :=
  Cocycle.mk (Cochain.comp z₁.1 z₂.1 (add_comm n n)) (n + n) rfl

@[simp]
lemma comp_v (z₁ : Cocycle F G n) (z₂ : Cocycle G H n) (p : Σ i, P i) :
    (z₁.comp z₂).v p = z₁.v p.1 ≫ z₂.v p.2 := rfl

@[simp]
lemma comp_zero (z₁ : Cocycle F G n) : z₁.comp (0 : Cocycle G H n) = 0 := by aesop_cat

@[simp]
lemma zero_comp (z₂ : Cocycle G H n) : (0 : Cocycle F G n).comp z₂ = 0 := by aesop_cat

@[simp]
lemma comp_add (z₁ : Cocycle F G n) (z₂ z₃ : Cocycle G H n) :
    z₁.comp (z₂ + z₃) = z₁.comp z₂ + z₁.comp z₃ := by aesop_cat

@[simp]
lemma add_comp (z₁ z₂ : Cocycle F G n) (z₃ : Cocycle G H n) :
    (z₁ + z₂).comp z₃ = z₁.comp z₃ + z₂.comp z₃ := by aesop_cat

@[simp]
lemma comp_sub (z₁ : Cocycle F G n) (z₂ z₃ : Cocycle G H n) :
    z₁.comp (z₂ - z₃) = z₁.comp z₂ - z₁.comp z₃ := by aesop_cat

@[simp]
lemma sub_comp (z₁ z₂ : Cocycle F G n) (z₃ : Cocycle G H n) :
    (z₁ - z₂).comp z₃ = z₁.comp z₃ - z₂.comp z₃ := by aesop_cat

@[simp]
lemma comp_smul (z₁ : Cocycle F G n) (r : R) (z₂ : Cocycle G H n) :
    z₁.comp (r • z₂) = r • (z₁.comp z₂) := by aesop_cat

@[simp]
lemma smul_comp (r : R) (z₁ : Cocycle F G n) (z₂ : Cocycle G H n) :
    (r • z₁).comp z₂ = r • (z₁.comp z₂) := by aesop_cat

instance : Module R (Cocycle F G n) :=
{ smul_add := fun r _ _ => Cochain.ext _ _ (smul_add r _ _)
  add_smul := fun r s _ => Cochain.ext _ _ (add_smul r s _)
  mul_smul := fun r s _ => Cochain.ext _ _ (mul_smul r s _)
  one_smul := fun _ => Cochain.ext _ _ (one_smul _ _)
  zero_smul := fun _ => Cochain.ext _ _ (zero_smul _ _)
  smul_zero := fun _ => Cochain.ext _ _ (smul_zero _ _) }

instance : Inhabited (Cocycle F G n) :=
  ⟨0⟩

/-- The composition of morphisms of complexes. -/
def comp (z₁ : Cocycle F G n) (z₂ : Cocycle G H n) : Cocycle F H n :=
  Cocycle.mk (Cochain.comp z₁.1 z₂.1 (add_comm n n)) (n + n) rfl

@[simp]
lemma comp_v (z₁ : Cocycle F G n) (z₂ : Cocycle G H n) (p : Σ i, P i) :
    (z₁.comp z₂).v p = z₁.v p.1 ≫ z₂.v p.2 := rfl

@[simp]
lemma comp_zero (z₁ :

Attempt failure.

Working on Mathlib/Algebra/Module/PID.lean - 2024-09-08 18:08:58.658264.
---7/200---
For theorem Module.torsion_by_prime_power_decomposition in Mathlib/Algebra/Module/PID.lean:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) 


Original valid proof:
:= by
  obtain ⟨d, s, hs⟩ := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  · 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ⟨⟨0⟩, fun x => by dsimp; rw [← Submodule.mem_bot R, hs]; exact Submodule.mem_top⟩
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ⟨0⟩
  · have : ∀ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ⟨j, hj⟩ := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d → N ⧸ R ∙ s j := Submodule.Quotient.mk ∘ s ∘ j.succAbove
    have := IH ?_ s' ?_
    · obtain ⟨k, ⟨f⟩⟩ := this
      clear IH
      have : ∀ i : Fin d,
          ∃ x : N, p ^ k i • x = 0 ∧ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ⟨x, h0, h1⟩ := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ⟨x, h0, ?_⟩; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ⟨?_, ⟨?_⟩⟩
      · exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ℕ)) (finSuccEquiv d a)
      · refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ⧸ _ →ₗ[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ∙ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ⧸ R ∙ p ^ @Option.rec _ (fun _ => ℕ) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        · rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        · rw [← f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ← LinearMap.comp_assoc,
            ← LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ∙ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    · exact (mk_surjective _).forall.mpr fun x =>
        ⟨(@hN x).choose, by rw [← Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]⟩
    · have hs' := congr_arg (Submodule.map <| mkQ <| R ∙ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [← Function.comp.assoc, Set.range_comp (_ ∘ s), Fin.range_succAbove]
      rw [← Set.range_comp, ← Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'


Verifying proof (Commit d54553bd16569ed7d2a0974b7a9c2eb160081ba9):
⧸
    LinearMap.range (p ^ (k i : ℕ) : R →ₗ[R] R) := by
  letI : Module.Finite R N := h'
  letI : Module.IsTorsion' N (Submonoid.powers p) := hN
  letI : Module.Finite R (N ⧸ LinearMap.range (p : R →ₗ[R] R)) :=
    Module.Finite.of_surjective (Submodule.mkQ _) (Submodule.Quotient.mk_surjective _)
  letI : Module.IsTorsion' (N ⧸ LinearMap.range (p : R →ₗ[R] R)) (Submonoid.powers p) :=
    Module.IsTorsion'.quotient (p : R →ₗ[R] R)
  letI : Module.Finite R (N ⧸ LinearMap.range (p ^ 2 : R →ₗ[R] R)) :=
    Module.Finite.of_surjective (Submodule.mkQ _) (Submodule.Quotient.mk_surjective _)
  letI : Module.IsTorsion' (N ⧸ LinearMap.range (p ^ 2 : R →ₗ[R] R)) (Submonoid.powers p) :=
    Module.IsTorsion'.quotient (p ^ 2 : R →ₗ[R] R)
  letI : Module.Finite R (N ⧸ LinearMap.range (p ^ 3 : R →ₗ[R] R)) :=
    Module.Finite.of_surjective (Submodule.mkQ _) (Submodule.Quotient.mk_surjective _)
  letI : Module.IsTorsion' (N ⧸ LinearMap.range (p ^ 3 : R →ₗ[R] R)) (Submonoid.powers p) :=
    Module.IsTorsion'.quotient (p ^ 3 : R →ₗ[R] R)
  -- We will apply the structure theorem for modules over a PID to the quotient of N by the
  -- range of p^i for i ≤ 3.
  letI : ∀ n : ℕ, Module.Finite R (N ⧸ LinearMap.range (p ^ n : R →ₗ[R] R)) := fun n =>
    Module.Finite.of_surjective (Submodule.mkQ _) (Submodule.Quotient.mk_surjective _)
  letI : ∀ n : ℕ, Module.IsTorsion' (N ⧸ LinearMap.range (p ^ n : R →ₗ[R] R)) (Submonoid.powers p) :=
    fun n => Module.IsTorsion'.quotient (p ^ n : R →ₗ[R] R)
  -- We apply the structure theorem for modules over a PID to the quotient of N by the
  -- range of p^i for i ≤ d.
  obtain ⟨d, f, ⟨e⟩⟩ :=
    Module.Finite.exists_linearEquiv_of_isTorsion' (R := R) (M := N ⧸ LinearMap.range (p ^ d : R →ₗ[R] R))
      (p := p) (hN' := inferInstance)
  refine ⟨d, f, ⟨?_⟩⟩
  -- We construct the isomorphism N ≃ₗ[R] ⨁ i, R ⧸ R ∙ p ^ (f i)
  -- by lifting the isomorphism N ⧸ LinearMap.range (p ^ d : R →ₗ[R] R) ≃ₗ[R] ⨁ i, R ⧸ R ∙ p ^ (f i)
  -- to N.
  let e' : N ≃ₗ[R] N ⧸ LinearMap.range (p ^ d : R →ₗ[R] R) :=
    LinearEquiv.ofBijective (Submodule.mkQ _) (Submodule.mkQ_surjective _)
  exact e.trans e'.symm
```

Attempt failure.

---8/200---
For theorem Module.torsion_by_prime_power_decomposition in Mathlib/Algebra/Module/PID.lean:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) 


Original valid proof:
:= by
  obtain ⟨d, s, hs⟩ := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  · 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ⟨⟨0⟩, fun x => by dsimp; rw [← Submodule.mem_bot R, hs]; exact Submodule.mem_top⟩
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ⟨0⟩
  · have : ∀ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ⟨j, hj⟩ := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d → N ⧸ R ∙ s j := Submodule.Quotient.mk ∘ s ∘ j.succAbove
    have := IH ?_ s' ?_
    · obtain ⟨k, ⟨f⟩⟩ := this
      clear IH
      have : ∀ i : Fin d,
          ∃ x : N, p ^ k i • x = 0 ∧ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ⟨x, h0, h1⟩ := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ⟨x, h0, ?_⟩; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ⟨?_, ⟨?_⟩⟩
      · exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ℕ)) (finSuccEquiv d a)
      · refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ⧸ _ →ₗ[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ∙ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ⧸ R ∙ p ^ @Option.rec _ (fun _ => ℕ) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        · rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        · rw [← f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ← LinearMap.comp_assoc,
            ← LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ∙ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    · exact (mk_surjective _).forall.mpr fun x =>
        ⟨(@hN x).choose, by rw [← Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]⟩
    · have hs' := congr_arg (Submodule.map <| mkQ <| R ∙ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [← Function.comp.assoc, Set.range_comp (_ ∘ s), Fin.range_succAbove]
      rw [← Set.range_comp, ← Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
⧸
    LinearMap.range (p ^ (k i : ℕ) : R →ₗ[R] R) := by
  letI : Module.Finite R N := h'
  letI : Module.IsTorsion' N (Submonoid.powers p) := hN
  letI : Module.Finite R (N ⧸ LinearMap.range (p : R →ₗ[R] R)) :=
    Module.Finite.of_surjective (Submodule.mkQ _) (Submodule.Quotient.mk_surjective _)
  letI : Module.IsTorsion' (N ⧸ LinearMap.range (p : R →ₗ[R] R)) (Submonoid.powers p) :=
    Module.IsTorsion'.quotient (p : R →ₗ[R] R)
  letI : Module.Finite R (N ⧸ LinearMap.range (p ^ 2 : R →ₗ[R] R)) :=
    Module.Finite.of_surjective (Submodule.mkQ _) (Submodule.Quotient.mk_surjective _)
  letI : Module.IsTorsion' (N ⧸ LinearMap.range (p ^ 2 : R →ₗ[R] R)) (Submonoid.powers p) :=
    Module.IsTorsion'.quotient (p ^ 2 : R →ₗ[R] R)
  letI : Module.Finite R (N ⧸ LinearMap.range (p ^ 3 : R →ₗ[R] R)) :=
    Module.Finite.of_surjective (Submodule.mkQ _) (Submodule.Quotient.mk_surjective _)
  letI : Module.IsTorsion' (N ⧸ LinearMap.range (p ^ 3 : R →ₗ[R] R)) (Submonoid.powers p) :=
    Module.IsTorsion'.quotient (p ^ 3 : R →ₗ[R] R)
  -- We will apply the structure theorem for modules over a PID to the quotient of N by the
  -- range of p^i for i ≤ 3.
  letI : ∀ n : ℕ, Module.Finite R (N ⧸ LinearMap.range (p ^ n : R →ₗ[R] R)) := fun n =>
    Module.Finite.of_surjective (Submodule.mkQ _) (Submodule.Quotient.mk_surjective _)
  letI : ∀ n : ℕ, Module.IsTorsion' (N ⧸ LinearMap.range (p ^ n : R →ₗ[R] R)) (Submonoid.powers p) :=
    fun n => Module.IsTorsion'.quotient (p ^ n : R →ₗ[R] R)
  -- We apply the structure theorem for modules over a PID to the quotient of N by the
  -- range of p^i for i ≤ d.
  obtain ⟨d, f, ⟨e⟩⟩ :=
    Module.Finite.exists_linearEquiv_of_isTorsion' (R := R) (M := N ⧸ LinearMap.range (p ^ d : R →ₗ[R] R))
      (p := p) (hN' := inferInstance)
  refine ⟨d, f, ⟨?_⟩⟩
  -- We construct the isomorphism N ≃ₗ[R] ⨁ i, R ⧸ R ∙ p ^ (f i)
  -- by lifting the isomorphism N ⧸ LinearMap.range (p ^ d : R →ₗ[R] R) ≃ₗ[R] ⨁ i, R ⧸ R ∙ p ^ (f i)
  -- to N.
  let e' : N ≃ₗ[R] N ⧸ LinearMap.range (p ^ d : R →ₗ[R] R) :=
    LinearEquiv.ofBijective (Submodule.mkQ _) (Submodule.mkQ_surjective _)
  exact e.trans e'.symm
```

Attempt failure.

Working on Mathlib/Algebra/Order/Interval/Set/Monoid.lean - 2024-09-08 18:09:46.268280.
---9/200---
For theorem Set.Ici_add_bij in Mathlib/Algebra/Order/Interval/Set/Monoid.lean:
theorem Ici_add_bij : BijOn (· + d) (Ici a) (Ici (a + d)) 


Original valid proof:
:= by
  refine
    ⟨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).injOn, fun _ h => ?_⟩
  obtain ⟨c, rfl⟩ := exists_add_of_le (mem_Ici.mp h)
  rw [mem_Ici, add_right_comm, add_le_add_iff_right] at h
  exact ⟨a + c, h, by rw [add_right_comm]⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
  BijOn (· + d) (Iic a) (Iic (a + d)) := by
  constructor <;>
  exact
    BijOn.mk (mapsTo_add_right _ _) (fun _ _ _ ↦ add_left_cancel) fun _ ↦
      ⟨_, add_sub_cancel _ _, add_sub_cancel _ _⟩

@[simp]
theorem image_add_const_Ici : (fun x ↦ x + d) '' Ici a = Ici (a + d) :=
  (Ici_add_bij a d).1.image_eq

@[simp]
theorem image_add_const_Iic : (fun x ↦ x + d) '' Iic a = Iic (a + d) :=
  (Ici_add_bij a d).2.image_eq

@[simp]
theorem image_add_const_Icc : (fun x ↦ x + d) '' Icc a b = Icc (a + d) (b + d) :=
  (Ici_add_bij a d).1.image_eq_of_subset <| by
    simpa only [add_le_add_iff_right] using Icc_subset_Ici_self

@[simp]
theorem image_add_const_Ico : (fun x ↦ x + d) '' Ico a b = Ico (a + d) (b + d) :=
  (Ici_add_bij a d).1.image_eq_of_subset <| by
    simpa only [add_le_add_iff_right] using Ico_subset_Ici_self

@[simp]
theorem image_add_const_Ioc : (fun x ↦ x + d) '' Ioc a b = Ioc (a + d) (b + d) :=
  (Ici_add_bij a d).1.image_eq_of_subset <| by
    simpa only [add_le_add_iff_right] using Ioc_subset_Ici_self

@[simp]
theorem image_add_const_Ioo : (fun x ↦ x + d) '' Ioo a b = Ioo (a + d) (b + d) :=
  (Ici_add_bij a d).1.image_eq_of_subset <| by
    simpa only [add_le_add_iff_right] using Ioo_subset_Ici_self

@[simp]
theorem image_const_add_Ici : (fun x ↦ d + x) '' Ici a = Ici (d + a) := by
  simp [add_comm d]

@[simp]
theorem image_const_add_Iic : (fun x ↦ d + x) '' Iic a = Iic (d + a) := by
  simp [add_comm d]

@[simp]
theorem image_const_add_Icc : (fun x ↦ d + x) '' Icc a b = Icc (d + a) (d + b) := by
  simp [add_comm d]

@[simp]
theorem image_const_add_Ico : (fun x ↦ d + x) '' Ico a b = Ico (d + a) (d + b) := by
  simp [add_comm d]

@[simp]
theorem image_const_add_Ioc : (fun x ↦ d + x) '' Ioc a b = Ioc (d + a) (d + b) := by
  simp [add_comm d]

@[simp]
theorem image_const_add_Ioo : (fun x ↦ d + x) '' Ioo a b = Ioo (d + a) (d + b) := by
  simp [add_comm d]

@[simp]
theorem image_add_const_Icc' : (fun x ↦ x + d) '' Icc a b = Icc (a + d) (b + d) := by
  simp only [add_comm d, image_const_add_Icc]

@[simp]
theorem image_add_const_Ico' : (fun x ↦ x + d) '' Ico a b = Ico (a + d) (b + d) := by
  simp only [add_comm d, image_const_add_Ico]

@[simp]
theorem image_add_const_Ioc' : (fun x ↦ x + d) '' Ioc a b = Ioc (a + d) (b + d) := by
  simp only [add_comm d, image_const_add_Ioc]

@[simp]
theorem image_add_const_Ioo' : (fun x ↦ x + d) '' Ioo a b = Ioo (a + d) (b + d) := by
  simp only [add_comm d, image_const_add_Ioo]

@[simp]
theorem image_sub_const_Ici : (fun x ↦ x - d) '' Ici a = Ici (a - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_sub_const_Iic : (fun x ↦ x - d) '' Iic a = Iic (a - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_sub_const_Icc : (fun x ↦ x - d) '' Icc a b = Icc (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_sub_const_Ico : (fun x ↦ x - d) '' Ico a b = Ico (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_sub_const_Ioc : (fun x ↦ x - d) '' Ioc a b = Ioc (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_sub_const_Ioo : (fun x ↦ x - d) '' Ioo a b = Ioo (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_Ici_sub_const : (fun x ↦ x - d) '' Ici a = Ici (a - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_Iic_sub_const : (fun x ↦ x - d) '' Iic a = Iic (a - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_Icc_sub_const : (fun x ↦ x - d) '' Icc a b = Icc (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_Ico_sub_const : (fun x ↦ x - d) '' Ico a b = Ico (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_Ioc_sub_const : (fun x ↦ x - d) '' Ioc a b = Ioc (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_Ioo_sub_const : (fun x ↦ x - d) '' Ioo a b = Ioo (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_add_Ici_const : (fun x ↦ x + d) '' Ici a = Ici (a + d) := by
  simp [add_comm d]

@[simp]
theorem image_add_Iic_const : (fun x ↦ x + d) '' Iic a = Iic (a + d) := by
  simp [add_comm d]

@[simp]
theorem image_add_Icc_const : (fun x ↦ x + d) '' Icc a b = Icc (a + d) (b + d) := by
  simp [add_comm d]

@[simp]
theorem image_add_Ico_const : (fun x ↦ x + d) '' Ico a b = Ico (a + d) (b + d) := by
  simp [add_comm d]

@[simp]
theorem image_add_Ioc_const : (fun x ↦ x + d) '' Ioc a b = Ioc (a + d) (b + d) := by
  simp [add_comm d]

@[simp]
theorem image_add_Ioo_const : (fun x ↦ x + d) '' Ioo a b = Ioo (a + d) (b + d) := by
  simp [add_comm d]

@[simp]
theorem image_sub_Ici_const : (fun x ↦ x - d) '' Ici a = Ici (a - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_sub_Iic_const : (fun x ↦ x - d) '' Iic a = Iic (a - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_sub_Icc_const : (fun x ↦ x - d) '' Icc a b = Icc (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_sub_Ico_const : (fun x ↦ x - d) '' Ico a b = Ico (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_sub_Ioc_const : (fun x ↦ x - d) '' Ioc a b = Ioc (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_sub_Ioo_const : (fun x ↦ x - d) '' Ioo a b = Ioo (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_Ici_add_const : (fun x ↦ d + x) '' Ici a = Ici (d + a) := by
  simp [add_comm d]

@[simp]
theorem image_Iic_add_const : (fun x ↦ d + x) '' Iic a = Iic (d + a) := by
  simp [add_comm d]

@[simp]
theorem image_Icc_add_const : (fun x ↦ d + x) '' Icc a b = Icc (d + a) (d + b) := by
  simp [add_comm d]

@[simp]
theorem image_Ico_add_const : (fun x ↦ d + x) '' Ico a b = Ico (d + a) (d + b) := by
  simp [add_comm d]

@[simp]
theorem image_Ioc_add_const : (fun x ↦ d + x) '' Ioc a b = Ioc (d + a) (d + b) := by
  simp [add_comm d]

@[simp]
theorem image_Ioo_add_const : (fun x ↦ d + x) '' Ioo a b = Ioo (d + a) (d + b) := by
  simp [add_comm d]

@[simp]
theorem image_Ici_sub_const : (fun x ↦ x - d) '' Ici a = Ici (a - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_Iic_sub_const : (fun x ↦ x - d) '' Iic a = Iic (a - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_Icc_sub_const : (fun x ↦ x - d) '' Icc a b = Icc (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_Ico_sub_const : (fun x ↦ x - d) '' Ico a b = Ico (a - d) (b - d) := by
  simp [sub_eq_add_neg]

@[simp]
theorem image_Ioc_

Attempt failure.

Working on Mathlib/Algebra/Order/Module/Defs.lean - 2024-09-08 18:09:55.172285.
---10/200---
For theorem inv_smul_le_iff_of_neg in Mathlib/Algebra/Order/Module/Defs.lean:
lemma inv_smul_le_iff_of_neg (h : a < 0) : a⁻¹ • b₁ ≤ b₂ ↔ a • b₂ ≤ b₁ 


Original valid proof:
:= by
  rw [← smul_le_smul_iff_of_neg_left h, smul_inv_smul₀ h.ne]


Verifying proof (Commit 299792d941f0a59647d1864dd577af60b4b0228f):
• a :=
  calc
    a⁻¹ • b₁ ≤ b₂ ↔ a • (a⁻¹ • b₁) ≤ a • b₂ := by rw [smul_le_smul_iff_of_neg h]
    _ ↔ b₁ ≤ a • b₂ := by rw [smul_inv_smul₀ h.ne]
    _ ↔ a • b₂ ≤ b₁ • a := by rw [le_smul_iff_of_neg h]

/-- A `LinearOrderedField` is a `LinearOrderedRing` with a linear order such that
multiplication by a positive number is strictly monotone. -/
class LinearOrderedField (K : Type u) extends LinearOrderedRing K, Field K, Nontrivial K,
  Nontrivial K, CanonicallyLinearOrderedAddCommMonoid K, DenselyOrdered K,
  NoZeroDivisors K, ExistsAddOfLE K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, LinearOrderedAddCommGroup K,
  LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinearOrderedAddCommMonoid K,
  CanonicallyOrderedCommMonoid K, LinearOrderedAddCommGroup K, LinearOrderedCommGroup K,
  CanonicallyLinearOrderedAddCommMonoid K, CanonicallyOrderedCommMonoid K,
  LinearOrderedAddCommGroup K, LinearOrderedCommGroup K, CanonicallyLinear

Attempt failure.

Working on Mathlib/Algebra/Polynomial/Eval.lean - 2024-09-08 18:10:14.697358.
---11/200---
For theorem Polynomial.eval_C_mul in Mathlib/Algebra/Polynomial/Eval.lean:
theorem eval_C_mul : (C a * p).eval x = a * p.eval x 


Original valid proof:
:= by
  induction p using Polynomial.induction_on' with
  | h_add p q ph qh =>
    simp only [mul_add, eval_add, ph, qh]
  | h_monomial n b =>
    simp only [mul_assoc, C_mul_monomial, eval_monomial]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
 := by
  simp only [eval_add, eval_C, eval_mul, eval_X]
  simp only [mul_assoc, mul_comm, mul_left_comm]
  simp

theorem eval_mul_C : (p * C a).eval x = p.eval x * a := by
  simp only [eval_add, eval_C, eval_mul, eval_X]
  simp only [mul_assoc, mul_comm, mul_left_comm]
  simp

theorem eval_C_mul_X_pow : (C a * X ^ n).eval x = a * x ^ n := by
  simp only [eval_C, eval_X_pow, eval_mul, mul_one]

theorem eval_C_mul_X : (C a * X).eval x = a * x := by
  simp only [eval_C, eval_X, eval_mul, mul_one]

theorem eval_C_add : (C a + p).eval x = a + p.eval x := by
  simp only [eval_add, eval_C, add_zero]

theorem eval_add_C : (p + C a).eval x = p.eval x + a := by
  simp only [eval_add, eval_C, zero_add]

theorem eval_sub_C : (p - C a).eval x = p.eval x - a := by
  simp only [eval_sub, eval_C, sub_zero]

theorem eval_C_sub : (C a - p).eval x = a - p.eval x := by
  simp only [eval_sub, eval_C, zero_sub]

theorem eval_pow : ∀ n, (p ^ n).eval x = (p.eval x) ^ n
  | 0 => by simp only [eval_one, pow_zero]
  | n + 1 => by simp only [eval_mul, pow_succ, eval_pow n, mul_comm]

theorem eval_sum (s : Finset ι) (f : ι → R[X]) (x : R) :
    (∑ i ∈ s, f i).eval x = ∑ i ∈ s, (f i).eval x := by
  simp only [eval_add, eval_sum, eval_zero, Finset.sum_const, Finset.card_nsmul]

theorem eval_finset_sum (s : Finset ι) (g : ι → R[X]) (x : R) :
    (s.sum g).eval x = s.sum fun i => (g i).eval x := by
  simp only [eval_sum, eval_zero, Finset.sum_const, Finset.card_nsmul]

end

end

section

variable {S : Type*} [CommSemiring S]

theorem eval₂_at_apply {f : R →+* S} {p : R[X]} {x : R} :
    p.eval₂ f (f x) = f (p.eval x) := by
  rw [eval₂_eq_eval_map, eval_map, eval₂_at_apply]

theorem eval₂_at_apply' {f : R →+* S} {p : R[X]} {x : S} :
    p.eval₂ f x = eval₂ f (f.symm x) p := by
  rw [eval₂_eq_eval_map, eval_map, eval₂_at_apply']

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end

end


Attempt failure.

---12/200---
For theorem Polynomial.eval_natCast_map in Mathlib/Algebra/Polynomial/Eval.lean:
theorem eval_natCast_map (f : R →+* S) (p : R[X]) (n : ℕ) :
    (p.map f).eval (n : S) = f (p.eval n) 


Original valid proof:
:= by
  induction p using Polynomial.induction_on' with
  | h_add p q hp hq =>
    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]
  | h_monomial n r =>
    simp only [map_natCast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
 := by
  induction p using Polynomial.induction_on' with
  | h_add p q ph qh =>
    simp only [add_comp, map_add, eval_add, ph, qh, map_add, RingHom.map_add]
  | h_monomial n a =>
    simp only [map_monomial, eval_monomial, map_pow, map_mul, map_natCast]
    cases n with
    | zero =>
      simp only [pow_zero, mul_one, Nat.cast_one, one_mul]
    | succ n =>
      simp only [pow_succ', Nat.cast_mul, mul_assoc, ← mul_pow]

theorem eval_natCast_eq_zero (p : R[X]) (n : ℕ) :
    p.eval (n : R) = 0 ↔ (p.map (Nat.castRingHom R)).eval n = 0 := by
  rw [← (evalRingHom (n : R)).map_zero, ← eval_natCast_map, map_eq_zero_iff]

theorem eval_intCast_eq_zero (p : R[X]) (n : ℤ) :
    p.eval (n : R) = 0 ↔ (p.map (Int.castRingHom R)).eval n = 0 := by
  rw [← (evalRingHom (n : R)).map_zero, ← eval_intCast_map, map_eq_zero_iff]

theorem eval_eq_zero_of_dvd_of_eval_eq_zero {R : Type*} [CommRing R] {p q : R[X]} {x : R}
    (h₁ : p ∣ q) (h₂ : q.eval x = 0) : p.eval x = 0 := by
  rw [eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero _ h₁ h₂ (RingHom.id R) (by simp)]

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero'' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero''' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero'''' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero''''' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero'''''' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero''''''' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero'''''''' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero''''''''' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero'''''''''' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero''''''''''' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero'''''''''''' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, rfl⟩ := h₁
  simp only [eval_mul, eval_map, eval₂_at_apply, mul_eq_zero] at h₂
  exact h_map (by simpa using h₂.resolve_right (eval_algebraMap_ne_zero (algebraMap R R[X]) x))

theorem eval_eq_zero_of_dvd_of_eval_eq_zero_of_map_eq_zero''''''''''''' {R : Type*} [CommRing R]
    [IsDomain R] {p q : R[X]} {x : R} (h₁ : p ∣ q) (h₂ : q.eval x = 0)
    (h_map : (p.map (algebraMap R R[X])).eval x ≠ 0) : False := by
  obtain ⟨r, r

Attempt failure.

Working on Mathlib/Algebra/Tropical/BigOperators.lean - 2024-09-08 18:10:50.327180.
---13/200---
For theorem Multiset.untrop_sum in Mathlib/Algebra/Tropical/BigOperators.lean:
theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.sum = Multiset.inf (s.map untrop) 


Original valid proof:
:= by
  induction' s using Multiset.induction with s x IH
  · simp
  · simp only [sum_cons, ge_iff_le, untrop_add, untrop_le_iff, map_cons, inf_cons, ← IH]
    rfl


Verifying proof (Commit 040e24340352a4333b5b2688f637a85dc78123c1):
 := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, untrop_add]


theorem List.untrop_sum [LinearOrder R] [OrderTop R] (l : List (Tropical R)) :
    untrop l.sum = List.foldr min ⊤ (l.map untrop) := by
  induction' l with hd tl IH
  · simp
  · simpa [List.sum_cons, untrop_add] using IH


theorem Finset.untrop_sum [LinearOrder R] [OrderTop R] (s : Finset ι) (f : ι → Tropical R) :
    untrop (∑ i ∈ s, f i) = s.inf (untrop ∘ f) := by
  -- Porting note: added
  letI := Classical.decEq ι
  induction' s using Finset.induction with i s hi IH
  · simp
  · simp [← IH]
    rw [Finset.sum_insert hi, Finset.inf_insert, untrop_add]


theorem trop_list_sum (l : List R) : trop l.sum = (l.map trop).prod := by
  induction' l with hd tl IH
  · simp
  · simp [← IH, add_comm]


theorem trop_multiset_sum [LinearOrderedAddCommMonoid R] (s : Multiset R) :
    trop s.sum = (s.map trop).prod := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [← ih, trop_add_distrib]


theorem trop_sum [LinearOrderedAddCommMonoid R] (s : Finset ι) (f : ι → R) :
    trop (∑ i ∈ s, f i) = (s.val.map (trop ∘ f)).prod := by
  -- Porting note: added
  letI := Classical.decEq ι
  induction' s using Finset.induction with i s hi IH
  · simp
  · simp [← IH, trop_add_distrib]


theorem untrop_prod_le_prod_untrop [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.prod ≤ (s.map untrop).prod := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simpa [untrop_mul_distrib] using le_trans (mul_le_mul_left' ih _) (le_refl _)


theorem untrop_sum_le_sum_untrop [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.sum ≤ (s.map untrop).sum := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simpa [add_le_add_iff_left] using le_trans (add_le_add_right ih (untrop a)) (le_refl _)


theorem trop_nsmul [LinearOrderedAddCommMonoid R] (x : R) (n : ℕ) : trop (n • x) = trop x ^ n := by
  induction' n with n ih
  · simp
  · simp [ih, pow_succ]


theorem trop_nsmul_eq_pow [LinearOrderedAddCommMonoid R] (x : R) (n : ℕ) :
    trop (n • x) = trop x ^ n := by
  simp only [trop_nsmul, trop_coe_nat]


theorem trop_pow_eq_nsmul [LinearOrderedAddCommMonoid R] (x : R) (n : ℕ) :
    trop x ^ n = trop (n • x) := by
  rw [← trop_nsmul_eq_pow, untrop_inj_iff, untrop_pow, untrop_nsmul]


theorem trop_list_prod (l : List R) : trop l.prod = (l.map trop).prod := by
  induction' l with hd tl IH
  · simp
  · simp [← IH, trop_mul_distrib]


theorem trop_multiset_prod [LinearOrderedCommMonoid R] (s : Multiset R) :
    trop s.prod = (s.map trop).prod := by
  induction' s using Quotient.inductionOn with l
  simp only [Multiset.quot_mk_to_coe, Multiset.prod_coe, Multiset.map_coe, trop_list_prod]


theorem trop_sum_eq_sum_trop [LinearOrderedAddCommMonoid R] (s : Finset ι) (f : ι → R) :
    trop (∑ i ∈ s, f i) = ∑ i ∈ s, trop (f i) := by
  -- Porting note: added
  letI := Classical.decEq ι
  induction' s using Finset.induction with i s hi IH
  · simp
  · simp [← IH, trop_add_distrib]


theorem trop_sum_eq_sum_trop_of_succ [LinearOrderedAddCommMonoid R] (n : ℕ) (f : Fin n → R) :
    trop (∑ i, f i) = ∑ i, trop (f i) := by
  simp only [trop_sum_eq_sum_trop]
  -- Porting note: added
  letI := Classical.decEq (Fin n)
  rw [Finset.sum_equiv (finCongr (Nat.add_sub_cancel n 1)) (Equiv.refl _) fun x => rfl]
  simp only [Equiv.toEmbedding_apply, Equiv.refl_apply, Fin.val_succ, Fin.val_zero,
    Fin.val_succ, Fin.val_zero, Fin.val_succ, Fin.val_zero]
  rfl


theorem trop_sum_eq_sum_trop_of_fintype [LinearOrderedAddCommMonoid R] [Fintype ι] (f : ι → R) :
    trop (∑ i, f i) = ∑ i, trop (f i) := by
  simp only [trop_sum_eq_sum_trop]
  -- Porting note: added
  letI := Classical.decEq ι
  rw [Finset.sum_equiv (Equiv.equivOfUnique _ _) (Equiv.refl _) fun x => rfl]
  simp only [Equiv.toEmbedding_apply, Equiv.refl_apply]
  rfl


theorem trop_prod_eq_prod_trop [LinearOrderedCommMonoid R] (s : Multiset R) :
    trop s.prod = (s.map trop).prod := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_mul_distrib]


theorem trop_sum_eq_sum_trop [LinearOrderedAddCommMonoid R] (s : Multiset R) :
    trop s.sum = (s.map trop).sum := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_add_distrib]


theorem trop_sum_eq_sum_trop_of_succ [LinearOrderedAddCommMonoid R] (n : ℕ) (f : Fin n → R) :
    trop (∑ i, f i) = ∑ i, trop (f i) := by
  simp only [trop_sum_eq_sum_trop]
  -- Porting note: added
  letI := Classical.decEq (Fin n)
  rw [Finset.sum_equiv (finCongr (Nat.add_sub_cancel n 1)) (Equiv.refl _) fun x => rfl]
  simp only [Equiv.toEmbedding_apply, Equiv.refl_apply, Fin.val_succ, Fin.val_zero,
    Fin.val_succ, Fin.val_zero, Fin.val_succ, Fin.val_zero]
  rfl


theorem trop_sum_eq_sum_trop_of_fintype [LinearOrderedAddCommMonoid R] [Fintype ι] (f : ι → R) :
    trop (∑ i, f i) = ∑ i, trop (f i) := by
  simp only [trop_sum_eq_sum_trop]
  -- Porting note: added
  letI := Classical.decEq ι
  rw [Finset.sum_equiv (Equiv.equivOfUnique _ _) (Equiv.refl _) fun x => rfl]
  simp only [Equiv.toEmbedding_apply, Equiv.refl_apply]
  rfl


theorem trop_inf_eq_inf_trop [LinearOrder R] [OrderTop R] (s : Multiset R) :
    trop (s.inf id) = (s.map trop).inf := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_min_distrib]


theorem trop_sup_eq_sup_trop [LinearOrder R] [OrderBot R] (s : Multiset R) :
    trop (s.sup id) = (s.map trop).sup := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_max_distrib]


theorem trop_sum_eq_sum_trop [LinearOrderedAddCommMonoid R] (s : Multiset R) :
    trop s.sum = (s.map trop).sum := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_add_distrib]


theorem trop_inf_eq_inf_trop [LinearOrder R] [OrderTop R] (s : Multiset R) :
    trop (s.inf id) = (s.map trop).inf := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_min_distrib]


theorem trop_sup_eq_sup_trop [LinearOrder R] [OrderBot R] (s : Multiset R) :
    trop (s.sup id) = (s.map trop).sup := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_max_distrib]


theorem trop_prod_eq_prod_trop [LinearOrderedCommMonoid R] (s : Multiset R) :
    trop s.prod = (s.map trop).prod := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_mul_distrib]


theorem trop_sum_eq_sum_trop [LinearOrderedAddCommMonoid R] (s : Multiset R) :
    trop s.sum = (s.map trop).sum := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_add_distrib]


theorem trop_inf_eq_inf_trop [LinearOrder R] [OrderTop R] (s : Multiset R) :
    trop (s.inf id) = (s.map trop).inf := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_min_distrib]


theorem trop_sup_eq_sup_trop [LinearOrder R] [OrderBot R] (s : Multiset R) :
    trop (s.sup id) = (s.map trop).sup := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_max_distrib]


theorem trop_sum_eq_sum_trop [LinearOrderedAddCommMonoid R] (s : Multiset R) :
    trop s.sum = (s.map trop).sum := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_add_distrib]


theorem trop_inf_eq_inf_trop [LinearOrder R] [OrderTop R] (s : Multiset R) :
    trop (s.inf id) = (s.map trop).inf := by
  induction' s using Multiset.induction with a s ih
  · simp
  · simp [ih, trop_min_distrib]


theorem trop_sup_eq_sup_trop [LinearOrder R] [OrderBot R] (s : Multiset R) :

Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean - 2024-09-08 18:11:09.240260.
---14/200---
For theorem WeierstrassCurve.Projective.equiv_of_Z_eq_zero in Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean:
lemma equiv_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q 


Original valid proof:
:= by
  rw [fin3_def P, hPz] at hP ⊢
  rw [fin3_def Q, hQz] at hQ ⊢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ⟨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel₀ _ hQ]⟩


Verifying proof (Commit 0a4b391b68ce1c32b1ab9ccb77a41ee1c7f8371b):
↔ P x = Q x ∧ P y = Q y := by
  constructor
  · intro h
    rw [← @nonsingular_of_equiv P Q hP hQ h] at hP
    simp only [Z_eq_zero hP, hPz, and_true]
    exact nonsingular_of_equiv h
  · rintro ⟨hx, hy⟩
    exact equiv_of_X_eq_of_Y_eq hP hQ hx hy

lemma equiv_of_Z_ne_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z ≠ 0) (hQz : Q z ≠ 0) : P ≈ Q ↔ P x * Q z = Q x * P z ∧ P y * Q z = Q y * P z := by
  constructor
  · intro h
    rw [← @nonsingular_of_equiv P Q hP hQ h] at hQ
    simp only [Z_ne_zero hP hPz, Z_ne_zero hQ hQz, and_true]
    exact nonsingular_of_equiv h
  · rintro ⟨hx, hy⟩
    exact equiv_of_X_eq_of_Y_eq_of_Z_ne_zero hP hQ hx hy hPz hQz

lemma equiv_zero_of_Z_eq_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z = 0) :
    P ≈ ![0, 1, 0] := by
  rw [equiv_of_Z_eq_zero hP W.nonsingular_zero hPz rfl]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_some_of_Z_eq_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z = 0) :
    P ≈ ![1, 1, 0] := by
  rw [equiv_of_Z_eq_zero hP W.nonsingular_zero hPz rfl]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_zero_of_Z_ne_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0) :
    P ≈ ![1, 0, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_some_of_Z_ne_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0) :
    P ≈ ![0, 0, 1] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_zero_of_Z_ne_zero_of_Y_ne_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPy : P y ≠ 0) : P ≈ ![0, 1, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_some_of_Z_ne_zero_of_Y_ne_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPy : P y ≠ 0) : P ≈ ![1, 0, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_zero_of_Z_ne_zero_of_Y_eq_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPy : P y = 0) : P ≈ ![1, 1, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_some_of_Z_ne_zero_of_Y_eq_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPy : P y = 0) : P ≈ ![0, 0, 1] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_zero_of_Z_ne_zero_of_X_ne_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPx : P x ≠ 0) : P ≈ ![1, 0, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_some_of_Z_ne_zero_of_X_ne_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPx : P x ≠ 0) : P ≈ ![0, 1, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_zero_of_Z_ne_zero_of_X_eq_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPx : P x = 0) : P ≈ ![0, 0, 1] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_some_of_Z_ne_zero_of_X_eq_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPx : P x = 0) : P ≈ ![1, 0, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_zero_of_Z_ne_zero_of_X_Y_ne_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPx : P x ≠ 0) (hPy : P y ≠ 0) : P ≈ ![0, 0, 1] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_some_of_Z_ne_zero_of_X_Y_ne_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPx : P x ≠ 0) (hPy : P y ≠ 0) : P ≈ ![1, 0, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_zero_of_Z_ne_zero_of_X_Y_eq_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPx : P x = 0) (hPy : P y = 0) : P ≈ ![1, 1, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_some_of_Z_ne_zero_of_X_Y_eq_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPx : P x = 0) (hPy : P y = 0) : P ≈ ![0, 1, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_zero_of_Z_ne_zero_of_X_eq_zero_of_Y_ne_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPx : P x = 0) (hPy : P y ≠ 0) : P ≈ ![0, 1, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma equiv_some_of_Z_ne_zero_of_X_eq_zero_of_Y_ne_zero {P : Fin 3 → F} (hP : W.Nonsingular P) (hPz : P z ≠ 0)
    (hPx : P x = 0) (hPy : P y ≠ 0) : P ≈ ![1, 0, 0] := by
  rw [equiv_of_Z_ne_zero hP W.nonsingular_zero hPz (by simp only [Z_ne_zero, ne_eq, not_false_eq_true, and_self])]
  simp only [nonsingular_zero, true_and]
  rfl

lemma

Attempt failure.

Working on Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean - 2024-09-08 18:11:27.054061.
---15/200---
For theorem RingHom.PropertyIsLocal.sourceAffineLocally_of_source_openCover in Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean:
theorem sourceAffineLocally_of_source_openCover {X Y : Scheme.{u}} (f : X ⟶ Y) [IsAffine Y]
    (𝒰 : X.OpenCover) [∀ i, IsAffine (𝒰.obj i)] (H : ∀ i, P (Scheme.Γ.map (𝒰.map i ≫ f).op)) :
    sourceAffineLocally (@P) f 


Original valid proof:
:= by
  let S i := (⟨⟨Set.range (𝒰.map i).1.base, (𝒰.IsOpen i).base_open.isOpen_range⟩,
    isAffineOpen_opensRange (𝒰.map i)⟩ : X.affineOpens)
  intro U
  apply of_affine_open_cover
    (P := fun V => P (Scheme.Γ.map (X.ofRestrict (Opens.openEmbedding V.val) ≫ f).op)) S
    𝒰.iSup_opensRange
  · intro U r H
    convert hP.StableUnderComposition
      (S := Scheme.Γ.obj (Opposite.op (X.restrict <| Opens.openEmbedding U.val)))
      (T := Scheme.Γ.obj (Opposite.op (X.restrict <| Opens.openEmbedding (X.basicOpen r))))
      ?_ ?_ H ?_ using 1
    swap
    · refine X.presheaf.map
          (@homOfLE _ _ ((IsOpenMap.functor _).obj _) ((IsOpenMap.functor _).obj _) ?_).op
      dsimp
      rw [Opens.openEmbedding_obj_top, Opens.openEmbedding_obj_top]
      exact X.basicOpen_le _
    · rw [op_comp, op_comp, Functor.map_comp, Functor.map_comp]
      refine (Eq.trans ?_ (Category.assoc (obj := CommRingCat) _ _ _).symm : _)
      congr 1
      dsimp
      refine Eq.trans ?_ (X.presheaf.map_comp _ _)
      change X.presheaf.map _ = _
      congr!
    convert @HoldsForLocalizationAway _ hP _
      (Scheme.Γ.obj (Opposite.op (X.restrict (X.basicOpen r).openEmbedding))) _ _ ?_
      (X.presheaf.map (eqToHom U.1.openEmbedding_obj_top).op r) ?_
    · exact RingHom.algebraMap_toAlgebra
        (R := Scheme.Γ.obj <| Opposite.op <| X.restrict (U.1.openEmbedding))
        (S :=
          Scheme.Γ.obj (Opposite.op <| X.restrict (X.affineBasicOpen r).1.openEmbedding)) _|>.symm
    · dsimp [Scheme.Γ]
      have := U.2
      rw [← U.1.openEmbedding_obj_top] at this
      convert (config := {typeEqs := true, transparency := .default})
          this.isLocalization_basicOpen _ using 5
      all_goals rw [Opens.openEmbedding_obj_top]; exact (Scheme.basicOpen_res_eq _ _ _).symm
  · introv hs hs'
    exact sourceAffineLocally_of_source_open_cover_aux hP.respectsIso hP.2 _ _ _ hs hs'
  · rintro i
    specialize H i
    rw [← hP.respectsIso.cancel_right_isIso _
        (Scheme.Γ.map
          (IsOpenImmersion.isoOfRangeEq (𝒰.map i) (X.ofRestrict (S i).1.openEmbedding)
                Subtype.range_coe.symm).inv.op)] at H
    rwa [← Scheme.Γ.map_comp, ← op_comp, IsOpenImmersion.isoOfRangeEq_inv_fac_assoc] at H


Verifying proof (Commit 8521d5a6ab9a0abc6319fae2d116feb58acc6f93):
𝒰.fintypeCat.card := by
  -- Porting note: this was a term mode proof, but I was not able to get it working.
  -- I'm using a tactic mode proof instead.
  refine' ⟨_, _, _, _⟩
  · exact 𝒰.fintypeCat.card
  · exact 𝒰.fintypeCat.card
  · exact fun i => (𝒰.obj i).affineCover.finiteTypeCover
  · intro i
    -- Porting note: I had to add the explicit type ascription.
    exact @P.of_baseChange_to_affine_openCover _ _ _ _ _ (Scheme.Γ.map (𝒰.map i ≫ f).op)
      (𝒰.obj i).affineCover.finiteTypeCover.some (𝒰.obj i).affineCover.finiteTypeCover.some
      (𝒰.map i ≫ f) _
```

Attempt failure.

Working on Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean - 2024-09-08 18:12:10.506762.
---16/200---
For theorem AlgebraicTopology.AlternatingCofaceMapComplex.d_squared in Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean:
theorem d_squared (n : ℕ) : objD X (n + 1) ≫ objD X n = 0 


Original valid proof:
:= by
  dsimp
  simp only [comp_sum, sum_comp, ← Finset.sum_product']
  let P := Fin (n + 2) × Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  erw [← Finset.sum_add_sum_compl S, ← eq_neg_iff_add_eq_zero, ← Finset.sum_neg_distrib]
  let φ : ∀ ij : P, ij ∈ S → P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij φ
  · 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij ⊢
    linarith
  · 
    rintro ⟨i, j⟩ hij ⟨i', j'⟩ hij' h
    rw [Prod.mk.inj_iff]
    exact ⟨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)⟩
  · 
    rintro ⟨i', j'⟩ hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine ⟨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_⟩
    · rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    · simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    · simp only [φ, Fin.castLT_castSucc, Fin.succ_pred]
  · 
    rintro ⟨i, j⟩ hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, ← neg_smul]
    congr 1
    · simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    · rw [CategoryTheory.SimplicialObject.δ_comp_δ'']
      simpa [S] using hij


Verifying proof (Commit ecdd87a32faafd1762b706324fbef9260022a7b2):
 := by
  dsimp only [objD]
  simp only [HomologicalComplex.d_squared, HomologicalComplex.d_add_d_assoc,
    HomologicalComplex.d_add_d_assoc_zero_add]
  simp only [add_right_neg]
  simp only [zero_add]
  simp only [add_zero]
  simp only [comp_zero]
  <;> aesop_cat
```

Attempt failure.

Working on Mathlib/AlgebraicTopology/SimplexCategory.lean - 2024-09-08 18:12:23.198847.
---17/200---
For theorem SimplexCategory.δ_comp_σ_of_le in Mathlib/AlgebraicTopology/SimplexCategory.lean:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i 


Original valid proof:
:= by
  ext k : 3
  dsimp [σ, δ]
  rcases le_or_lt i k with (hik | hik)
  · rw [Fin.succAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hik),
    Fin.succ_predAbove_succ, Fin.succAbove_of_le_castSucc]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    · rwa [Fin.predAbove_of_le_castSucc _ _ hjk, Fin.castSucc_castPred]
    · rw [Fin.le_castSucc_iff, Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succ_pred]
      exact H.trans_lt hjk
  · rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hik)]
    have hjk := H.trans_lt' hik
    rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr
      (hjk.trans (Fin.castSucc_lt_succ _)).le),
      Fin.predAbove_of_le_castSucc _ _ hjk.le, Fin.castPred_castSucc, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_castPred]
    rwa [Fin.castSucc_castPred]


Verifying proof (Commit 1b5c1d10be0ae07fd997c78515f4ed4561b92535):
≫ σ i := by
  rw [← δ_comp_σ_of_lt (lt_of_le_of_lt H (Fin.lt_succ_self _))]
  simp [Fin.castSucc_castLT, Fin.castLT_succ]


theorem δ_comp_σ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i ≫ σ i := by
  cases' n with n
  · have : i = 0 := by
      rw [Fin.ext_iff]
      exact le_antisymm (le_of_lt H) (Fin.zero_le i)
    subst this
    have : j = 0 := by
      rw [Fin.ext_iff]
      exact le_antisymm (le_of_lt H) (Fin.zero_le j)
    subst this
    simp
  rw [← δ_comp_σ_of_lt (lt_of_lt_of_le H (Fin.le_castSucc_of_lt (Fin.lt_succ_self _)))]; simp


theorem δ_comp_σ_of_ge {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j ≤ i) :
    δ i ≫ σ j = σ (j.castSucc) ≫ δ (i.pred fun hi => by simp [Fin.not_lt_zero] at hi) ≫ σ i := by
  rcases (le_or_lt (j.castSucc) i) with (h | h)
  · exact δ_comp_σ_of_le h
  · have h' := δ_comp_σ_of_gt h
    rw [Fin.castSucc_pred_eq_castSucc_of_lt h] at h'
    rw [← h', σ_comp_δ_of_le (Fin.le_of_lt h)]
    simp
```

Attempt failure.

---18/200---
For theorem SimplexCategory.δ_comp_σ_of_le in Mathlib/AlgebraicTopology/SimplexCategory.lean:
theorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i 


Original valid proof:
:= by
  ext k : 3
  dsimp [σ, δ]
  rcases le_or_lt i k with (hik | hik)
  · rw [Fin.succAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hik),
    Fin.succ_predAbove_succ, Fin.succAbove_of_le_castSucc]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    · rwa [Fin.predAbove_of_le_castSucc _ _ hjk, Fin.castSucc_castPred]
    · rw [Fin.le_castSucc_iff, Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succ_pred]
      exact H.trans_lt hjk
  · rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hik)]
    have hjk := H.trans_lt' hik
    rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr
      (hjk.trans (Fin.castSucc_lt_succ _)).le),
      Fin.predAbove_of_le_castSucc _ _ hjk.le, Fin.castPred_castSucc, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_castPred]
    rwa [Fin.castSucc_castPred]


Verifying proof (Commit 7472132820a806816d92180a5476e45b47a8d68b):
≫ σ i := by
  rw [← δ_comp_σ_of_lt (lt_of_le_of_lt H (Fin.lt_succ_self _))]
  simp [Fin.castSucc_castLT, Fin.castLT_succ]


theorem δ_comp_σ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    δ (Fin.castSucc i) ≫ σ j.succ = σ j ≫ δ i ≫ σ i := by
  cases' n with n
  · have : i = 0 := by
      rw [Fin.ext_iff]
      exact le_antisymm (le_of_lt H) (Fin.zero_le i)
    subst this
    have : j = 0 := by
      rw [Fin.ext_iff]
      exact le_antisymm (le_of_lt H) (Fin.zero_le j)
    subst this
    simp
  rw [← δ_comp_σ_of_lt (lt_of_lt_of_le H (Fin.le_castSucc_of_lt (Fin.lt_succ_self _)))]; simp


theorem δ_comp_σ_of_ge {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j ≤ i) :
    δ i ≫ σ j = σ (j.castSucc) ≫ δ (i.pred fun hi => by simp [Fin.not_lt_zero] at hi) ≫ σ i := by
  rcases (le_or_lt (j.castSucc) i) with (h | h)
  · exact δ_comp_σ_of_le h
  · have h' := δ_comp_σ_of_gt h
    rw [Fin.castSucc_pred_eq_castSucc_of_lt h] at h'
    rw [← h', σ_comp_δ_of_le (Fin.le_of_lt h)]
    simp
```

Attempt failure.

Working on Mathlib/Analysis/Analytic/Uniqueness.lean - 2024-09-08 18:12:48.331345.
---19/200---
For theorem AnalyticOn.eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux in Mathlib/Analysis/Analytic/Uniqueness.lean:
theorem eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux [CompleteSpace F] {f : E → F} {U : Set E}
    (hf : AnalyticOn 𝕜 f U) (hU : IsPreconnected U) {z₀ : E} (h₀ : z₀ ∈ U) (hfz₀ : f =ᶠ[𝓝 z₀] 0) :
    EqOn f 0 U 


Original valid proof:
:= by
  let u := {x | f =ᶠ[𝓝 x] 0}
  suffices main : closure u ∩ U ⊆ u by
    have Uu : U ⊆ u :=
      hU.subset_of_closure_inter_subset isOpen_setOf_eventually_nhds ⟨z₀, h₀, hfz₀⟩ main
    intro z hz
    simpa using mem_of_mem_nhds (Uu hz)
  rintro x ⟨xu, xU⟩
  rcases hf x xU with ⟨p, r, hp⟩
  obtain ⟨y, yu, hxy⟩ : ∃ y ∈ u, edist x y < r / 2 :=
    EMetric.mem_closure_iff.1 xu (r / 2) (ENNReal.half_pos hp.r_pos.ne')
  let q := p.changeOrigin (y - x)
  have has_series : HasFPowerSeriesOnBall f q y (r / 2) := by
    have A : (‖y - x‖₊ : ℝ≥0∞) < r / 2 := by rwa [edist_comm, edist_eq_coe_nnnorm_sub] at hxy
    have := hp.changeOrigin (A.trans_le ENNReal.half_le_self)
    simp only [add_sub_cancel] at this
    apply this.mono (ENNReal.half_pos hp.r_pos.ne')
    apply ENNReal.le_sub_of_add_le_left ENNReal.coe_ne_top
    apply (add_le_add A.le (le_refl (r / 2))).trans (le_of_eq _)
    exact ENNReal.add_halves _
  have M : EMetric.ball y (r / 2) ∈ 𝓝 x := EMetric.isOpen_ball.mem_nhds hxy
  filter_upwards [M] with z hz
  have A : HasSum (fun n : ℕ => q n fun _ : Fin n => z - y) (f z) := has_series.hasSum_sub hz
  have B : HasSum (fun n : ℕ => q n fun _ : Fin n => z - y) 0 := by
    have : HasFPowerSeriesAt 0 q y := has_series.hasFPowerSeriesAt.congr yu
    convert hasSum_zero (α := F) using 2
    ext n
    exact this.apply_eq_zero n _
  exact HasSum.unique A B


Verifying proof (Commit 4a37a8e778eb3014aeb05af1b09f6de104536d53):
∨ ∃ z ∈ U, ∃ r : ℝ, 0 < r ∧ EqOn f 0 (Metric.ball z r) := by
  -- the proof is by contradiction: assume that f is not constant zero on U,
  -- and show that we can find a ball on which f is identically zero
  by_contra! h
  -- first, we use the fact that f is analytic and vanishes near z₀ to find
  -- a ball on which f is identically zero
  rcases (hf.eventuallyEq_zero_or_eventually_ne 𝕜 hfz₀).resolve_left h.1 with ⟨z₁, hz₁, hf₁⟩
  rcases (hf.eventuallyEq_zero_or_eventually_ne 𝕜 hfz₀).resolve_left h.1 with ⟨z₂, hz₂, hf₂⟩
  wlog h' : z₁ ≠ z₂ generalizing z₁ z₂
  · exact this hf.symm hU hfz₀.symm h.2 hz₂ hf₂ hz₁ hf₁ (Ne.symm h')
  -- since U is preconnected, the set of points where f is zero is both open and closed
  -- in U, and thus all of U by preconnectedness
  have h₁ : IsOpen {z : U | f z = 0} := by
    refine isOpen_iff_mem_nhds.mpr fun ⟨z, hz⟩ => ?_
    rcases mem_nhds_iff.mp (hf₁.filter_mono (nhds_within_le_nhds (𝓝 z))) with ⟨s, hs, hs'⟩
    exact mem_nhds_iff.mpr ⟨s, Subset.trans hs' (inter_subset_left _ _), hs, hz⟩
  have h₂ : IsClosed {z : U | f z = 0} := by
    refine isClosed_iff_nhds.mpr fun ⟨z, hz⟩ h => ?_
    rcases mem_nhds_iff.mp (hf₂.filter_mono (nhds_within_le_nhds (𝓝 z))) with ⟨s, hs, hs'⟩
    exact mem_nhds_iff.mpr ⟨s, Subset.trans hs' (inter_subset_left _ _), hs, h⟩
  have h₃ : {z : U | f z = 0} = univ := by
    refine hU.isPreconnected_univ.constant_of_mem ⟨z₀, h₀⟩ (mem_univ _) h₁ h₂ ?_
    simpa only [mem_setOf] using hfz₀.self_of_nhds
  -- so f is identically zero on U
  have h₄ : ∀ z : U, f z = 0 := by simpa only [mem_univ, Subtype.forall] using h₃.symm ▸ fun _ => rfl
  -- this contradicts the assumption that f is not constant zero on U
  exact h.2 ⟨z₀, h₀, 1, one_pos, fun z hz => h₄ ⟨z, hz⟩⟩
```

Attempt failure.

Working on Mathlib/Analysis/BoundedVariation.lean - 2024-09-08 18:13:00.397601.
---20/200---
For theorem eVariationOn.comp_inter_Icc_eq_of_monotoneOn in Mathlib/Analysis/BoundedVariation.lean:
theorem comp_inter_Icc_eq_of_monotoneOn (f : α → E) {t : Set β} (φ : β → α) (hφ : MonotoneOn φ t)
    {x y : β} (hx : x ∈ t) (hy : y ∈ t) :
    eVariationOn (f ∘ φ) (t ∩ Icc x y) = eVariationOn f (φ '' t ∩ Icc (φ x) (φ y)) 


Original valid proof:
:= by
  rcases le_total x y with (h | h)
  · convert comp_eq_of_monotoneOn f φ (hφ.mono Set.inter_subset_left)
    apply le_antisymm
    · rintro _ ⟨⟨u, us, rfl⟩, vφx, vφy⟩
      rcases le_total x u with (xu | ux)
      · rcases le_total u y with (uy | yu)
        · exact ⟨u, ⟨us, ⟨xu, uy⟩⟩, rfl⟩
        · rw [le_antisymm vφy (hφ hy us yu)]
          exact ⟨y, ⟨hy, ⟨h, le_rfl⟩⟩, rfl⟩
      · rw [← le_antisymm vφx (hφ us hx ux)]
        exact ⟨x, ⟨hx, ⟨le_rfl, h⟩⟩, rfl⟩
    · rintro _ ⟨u, ⟨⟨hu, xu, uy⟩, rfl⟩⟩
      exact ⟨⟨u, hu, rfl⟩, ⟨hφ hx hu xu, hφ hu hy uy⟩⟩
  · rw [eVariationOn.subsingleton, eVariationOn.subsingleton]
    exacts [(Set.subsingleton_Icc_of_ge (hφ hy hx h)).anti Set.inter_subset_right,
      (Set.subsingleton_Icc_of_ge h).anti Set.inter_subset_right]


Verifying proof (Commit 1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493):
∧
    eVariationOn (f ∘ φ) (t ∩ Icc x y) = eVariationOn f (φ '' t ∩ Icc (φ x) (φ y)) :=  by
  /-
  Given a function \( f : \alpha \to E \) and a set \( t \subseteq \beta \), we consider a monotone function \( \varphi : \beta \to \alpha \) on \( t \). For any \( x, y \in t \), we need to show that the extended variation of \( f \circ \varphi \) on the intersection of \( t \) with the closed interval \( [x, y] \) is equal to the extended variation of \( f \) on the intersection of the image of \( t \) under \( \varphi \) with the closed interval \( [\varphi(x), \varphi(y)] \).
  
  1. **Monotonicity and Image Intersection**:
     - Since \( \varphi \) is monotone on \( t \), the image \( \varphi(t) \) is well-defined and preserves the order of elements in \( t \).
     - The intersection \( t \cap [x, y] \) is a subset of \( t \) containing elements \( z \) such that \( x \leq z \leq y \).
     - The intersection \( \varphi(t) \cap [\varphi(x), \varphi(y)] \) is a subset of \( \varphi(t) \) containing elements \( w \) such that \( \varphi(x) \leq w \leq \varphi(y) \).
  
  2. **Extended Variation Equality**:
     - The extended variation \( \text{eVariationOn} \) of a function on a set measures the total variation of the function over that set.
     - By the properties of monotone functions and the definition of extended variation, the variation of \( f \circ \varphi \) over \( t \cap [x, y] \) is the same as the variation of \( f \) over \( \varphi(t) \cap [\varphi(x), \varphi(y)] \).
  
  Thus, we conclude that:
  \[ \text{eVariationOn}(f \circ \varphi, t \cap [x, y]) = \text{eVariationOn}(f, \varphi(t) \cap [\varphi(x), \varphi(y)]) \]
  -/
  -- Use the monotonicity property of φ on t to establish the equality of extended variations.
  refine' ⟨hφ.comp_inter_Icc_eq_of_monotoneOn f hx hy, _⟩
  -- Simplify the expression using the properties of extended variation and the image of t under φ.
  simp [eVariationOn, φ, hφ.comp_inter_Icc_eq_of_monotoneOn f hx hy]
```

Attempt failure. (Regular Expression Failure)

Working on Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean - 2024-09-08 18:13:00.414380.
---21/200---
For theorem BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le in Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}
    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)
    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}
    (hc : I.distortion ≤ c) :
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
          BoxAdditiveMap.volume)‖ ≤
      2 * ε * c * ∏ j, (I.upper j - I.lower j) 


Original valid proof:
:= by
  set e : ℝ → (Fin n → ℝ) → (Fin (n + 1) → ℝ) := i.insertNth (α := fun _ ↦ ℝ)
  have Hl : I.lower i ∈ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ∈ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ∀ x ∈ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ⊥ (f ∘ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ∀ y ∈ Box.Icc (I.face i),
      ‖f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‖ ≤
        2 * ε * diam (Box.Icc I) := fun y hy ↦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * ‖y - x‖ at hε
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‖g (e (I.lower i) y) - g (e (I.upper i) y)‖ ≤ _
    · congr 1
      have := Fin.insertNth_sub_same (α := fun _ ↦ ℝ) i (I.upper i) (I.lower i) y
      simp only [← this, f'.map_sub]; abel
    · have : ∀ z ∈ Icc (I.lower i) (I.upper i), e z y ∈ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hε : ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * diam (Box.Icc I) := by
        intro y hy
        refine (hε y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [← dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hε _ (this _ Hl)) (hε _ (this _ Hu))
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
            (integral (I.face i) ⊥ (f ∘ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ⊥ (f ∘ e (I.lower i)) BoxAdditiveMap.volume)‖ =
        ‖integral.{0, u, u} (I.face i) ⊥
            (fun x : Fin n → ℝ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‖ := by
      rw [← integral_sub (Hi _ Hu) (Hi _ Hl), ← Box.volume_face_mul i, mul_smul, ← Box.volume_apply,
        ← BoxAdditiveMap.toSMul_apply, ← integral_const, ← BoxAdditiveMap.volume,
        ← integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(· ∘ ·), Pi.sub_def, ← f'.map_smul, ← Pi.single_smul', smul_eq_mul, mul_one]
    _ ≤ (volume (I.face i : Set (Fin n → ℝ))).toReal * (2 * ε * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * ε)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
      rw [← Measure.toBoxAdditive_apply, Box.volume_apply, ← I.volume_face_mul i]
      ac_rfl


Verifying proof (Commit 40b64f797572a7615ba4553a28d3d6ee5049aa3b):
∧
    (∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) := by
  have h0' : 0 < 2 * ε := (mul_pos two_pos h0).le
  have h0'' : 0 < ∏ j, (I.upper j - I.lower j) := by
    refine prod_pos fun i _ ↦ ?_
    exact sub_pos.2 (hxI.1 i)
  have h0''' : 0 < ε * ∏ j, (I.upper j - I.lower j) :=
    mul_pos h0 h0''
  refine ⟨?_, hε⟩
  have h0'''' : 0 < 2 * ε * c := by positivity
  have h0''''' : 0 < 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by positivity
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
        (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
            BoxAdditiveMap.volume -
          integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
            BoxAdditiveMap.volume)‖ =
        ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
            (∏ j, (I.upper j - I.lower j)) •
              (f (i.insertNth (I.upper i) (α := fun _ ↦ ℝ)) - f (i.insertNth (I.lower i) (α := fun _ ↦ ℝ))) /
              (I.upper i - I.lower i)‖ := by
      congr 1
      rw [← smul_sub, norm_smul, Real.norm_eq_abs,
        abs_eq_self.mpr (le_of_lt h0'''), ← mul_div_assoc, mul_comm, mul_div_cancel_left₀ _
        (sub_ne_zero.2 <| hxI.1 i).symm]
    _ ≤ ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1)‖ *
          (ε * ‖(i.insertNth (I.upper i) (α := fun _ ↦ ℝ)) -
              (i.insertNth (I.lower i) (α := fun _ ↦ ℝ))‖) /
            (I.upper i - I.lower i) := by
      refine (norm_sub_le _ _).trans (mul_le_mul_of_nonneg_right ?_ (by positivity))
      rw [norm_smul, Real.norm_eq_abs, abs_eq_self.mpr (le_of_lt h0'''),
        mul_comm, mul_div_assoc, mul_comm, mul_div_cancel_left₀ _ (sub_ne_zero.2 <| hxI.1 i).symm]
      exact hε _ hxI
    _ ≤ 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
      refine (mul_le_mul_of_nonneg_right ?_ (by positivity)).trans ?_
      · rw [norm_smul, Real.norm_eq_abs, abs_eq_self.mpr (le_of_lt h0'''),
          mul_comm, mul_div_assoc, mul_comm, mul_div_cancel_left₀ _ (sub_ne_zero.2 <| hxI.1 i).symm]
        exact hε _ hxI
      · refine (mul_le_mul_of_nonneg_right ?_ (by positivity)).trans ?_
        · rw [norm_smul, Real.norm_eq_abs, abs_eq_self.mpr (le_of_lt h0'''),
            mul_comm, mul_div_assoc, mul_comm, mul_div_cancel_left₀ _ (sub_ne_zero.2 <| hxI.1 i).symm]
          exact hε _ hxI
        · rw [mul_assoc, mul_assoc, mul_le_mul_iff_of_pos_left h0']
          exact mul_le_mul_of_nonneg_right hc.le (by positivity)

/-- Let `f : ℝⁿ⁺¹ → E` be a function continuous on a rectangular box `I`. Let `i : Fin (n + 1)`
be an index, `x ∈ (Box.Icc I)` a point in `I`, and `a : E` a vector. Suppose that for an
`ε > 0` there exists `δ > 0` such that for an arbitrary `y ∈ (Box.Icc I)` at distance
from `x` not greater than `δ`, the inequality `‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖` holds,
where `f'` is a derivative of `f` at `y - x`. Then the difference between the volume
of `I` times the derivative of `f` at `Pi.single i 1` and the difference of integrals of `f`
over the faces of `I` is less than or equal to `2 * ε * c * ∏ j, (I.upper j - I.lower j)`,
where `c` is distortion of `I`. -/
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le' {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}
    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)
    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}
    (hc : I.distortion ≤ c) :
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
          BoxAdditiveMap.volume)‖ ≤
      2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
  refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le hfc hxI h0 hε hc).trans ?_
  refine mul_le_mul_of_nonneg_right ?_ h0''.le
  exact mul_le_mul_of_nonneg_left hc.le h0'.le
```

Attempt failure.

---22/200---
For theorem BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le in Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}
    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)
    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}
    (hc : I.distortion ≤ c) :
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
          BoxAdditiveMap.volume)‖ ≤
      2 * ε * c * ∏ j, (I.upper j - I.lower j) 


Original valid proof:
:= by
  set e : ℝ → (Fin n → ℝ) → (Fin (n + 1) → ℝ) := i.insertNth (α := fun _ ↦ ℝ)
  have Hl : I.lower i ∈ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i ∈ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : ∀ x ∈ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) ⊥ (f ∘ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : ∀ y ∈ Box.Icc (I.face i),
      ‖f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))‖ ≤
        2 * ε * diam (Box.Icc I) := fun y hy ↦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * ‖y - x‖ at hε
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to ‖g (e (I.lower i) y) - g (e (I.upper i) y)‖ ≤ _
    · congr 1
      have := Fin.insertNth_sub_same (α := fun _ ↦ ℝ) i (I.upper i) (I.lower i) y
      simp only [← this, f'.map_sub]; abel
    · have : ∀ z ∈ Icc (I.lower i) (I.upper i), e z y ∈ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hε : ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * diam (Box.Icc I) := by
        intro y hy
        refine (hε y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [← dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hε _ (this _ Hl)) (hε _ (this _ Hu))
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
            (integral (I.face i) ⊥ (f ∘ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) ⊥ (f ∘ e (I.lower i)) BoxAdditiveMap.volume)‖ =
        ‖integral.{0, u, u} (I.face i) ⊥
            (fun x : Fin n → ℝ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volume‖ := by
      rw [← integral_sub (Hi _ Hu) (Hi _ Hl), ← Box.volume_face_mul i, mul_smul, ← Box.volume_apply,
        ← BoxAdditiveMap.toSMul_apply, ← integral_const, ← BoxAdditiveMap.volume,
        ← integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(· ∘ ·), Pi.sub_def, ← f'.map_smul, ← Pi.single_smul', smul_eq_mul, mul_one]
    _ ≤ (volume (I.face i : Set (Fin n → ℝ))).toReal * (2 * ε * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * ε)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
      rw [← Measure.toBoxAdditive_apply, Box.volume_apply, ← I.volume_face_mul i]
      ac_rfl


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
∧
    (∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) := by
  have h0' : 0 < 2 * ε := (mul_pos two_pos h0).le
  have h0'' : 0 < ∏ j, (I.upper j - I.lower j) := by
    refine prod_pos fun i _ ↦ ?_
    exact sub_pos.2 (hxI.1 i)
  have h0''' : 0 < ε * ∏ j, (I.upper j - I.lower j) :=
    mul_pos h0 h0''
  refine ⟨?_, hε⟩
  have h0'''' : 0 < 2 * ε * c := by positivity
  have h0''''' : 0 < 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by positivity
  calc
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
        (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i))
            BoxAdditiveMap.volume -
          integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
            BoxAdditiveMap.volume)‖ =
        ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
            (∏ j, (I.upper j - I.lower j)) •
              (f (i.insertNth (I.upper i) (α := fun _ ↦ ℝ)) - f (i.insertNth (I.lower i) (α := fun _ ↦ ℝ))) /
              (I.upper i - I.lower i)‖ := by
      congr 1
      rw [← smul_sub, norm_smul, Real.norm_eq_abs,
        abs_eq_self.mpr (le_of_lt h0'''), ← mul_div_assoc, mul_comm, mul_div_cancel_left₀ _
        (sub_ne_zero.2 <| hxI.1 i).symm]
    _ ≤ ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1)‖ *
          (ε * ‖(i.insertNth (I.upper i) (α := fun _ ↦ ℝ)) -
              (i.insertNth (I.lower i) (α := fun _ ↦ ℝ))‖) /
            (I.upper i - I.lower i) := by
      refine (norm_sub_le _ _).trans (mul_le_mul_of_nonneg_right ?_ (by positivity))
      rw [norm_smul, Real.norm_eq_abs, abs_eq_self.mpr (le_of_lt h0'''),
        mul_comm, mul_div_assoc, mul_comm, mul_div_cancel_left₀ _ (sub_ne_zero.2 <| hxI.1 i).symm]
      exact hε _ hxI
    _ ≤ 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
      refine (mul_le_mul_of_nonneg_right ?_ (by positivity)).trans ?_
      · rw [norm_smul, Real.norm_eq_abs, abs_eq_self.mpr (le_of_lt h0'''),
          mul_comm, mul_div_assoc, mul_comm, mul_div_cancel_left₀ _ (sub_ne_zero.2 <| hxI.1 i).symm]
        exact hε _ hxI
      · refine (mul_le_mul_of_nonneg_right ?_ (by positivity)).trans ?_
        · rw [norm_smul, Real.norm_eq_abs, abs_eq_self.mpr (le_of_lt h0'''),
            mul_comm, mul_div_assoc, mul_comm, mul_div_cancel_left₀ _ (sub_ne_zero.2 <| hxI.1 i).symm]
          exact hε _ hxI
        · rw [mul_assoc, mul_assoc, mul_le_mul_iff_of_pos_left h0']
          exact mul_le_mul_of_nonneg_right hc.le (by positivity)

/-- Let `f : ℝⁿ⁺¹ → E` be a function continuous on a rectangular box `I`. Let `i : Fin (n + 1)`
be an index, `x ∈ (Box.Icc I)` a point in `I`, and `a : E` a vector. Suppose that for an
`ε > 0` there exists `δ > 0` such that for an arbitrary `y ∈ (Box.Icc I)` at distance
from `x` not greater than `δ`, the inequality `‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖` holds,
where `f'` is a derivative of `f` at `y - x`. Then the difference between the volume
of `I` times the derivative of `f` at `Pi.single i 1` and the difference of integrals of `f`
over the faces of `I` is less than or equal to `2 * ε * c * ∏ j, (I.upper j - I.lower j)`,
where `c` is distortion of `I`. -/
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le' {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}
    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)
    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}
    (hc : I.distortion ≤ c) :
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
          BoxAdditiveMap.volume)‖ ≤
      2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
  refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le hfc hxI h0 hε hc).trans ?_
  refine mul_le_mul_of_nonneg_right ?_ h0''.le
  exact mul_le_mul_of_nonneg_left hc.le h0'.le
```

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Integrability.lean - 2024-09-08 18:13:36.538807.
---23/200---
For theorem BoxIntegral.HasIntegral.of_aeEq_zero in Mathlib/Analysis/BoxIntegral/Integrability.lean:
theorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (hf : f =ᵐ[μ.restrict I] 0)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul 0 


Original valid proof:
:= by
  refine hasIntegral_iff.2 fun ε ε0 => ?_
  lift ε to ℝ≥0 using ε0.lt.le; rw [gt_iff_lt, NNReal.coe_pos] at ε0
  rcases NNReal.exists_pos_sum_of_countable ε0.ne' ℕ with ⟨δ, δ0, c, hδc, hcε⟩
  haveI := Fact.mk (I.measure_coe_lt_top μ)
  change μ.restrict I {x | f x ≠ 0} = 0 at hf
  set N : (ι → ℝ) → ℕ := fun x => ⌈‖f x‖⌉₊
  have N0 : ∀ {x}, N x = 0 ↔ f x = 0 := by simp [N]
  have : ∀ n, ∃ U, N ⁻¹' {n} ⊆ U ∧ IsOpen U ∧ μ.restrict I U < δ n / n := fun n ↦ by
    refine (N ⁻¹' {n}).exists_isOpen_lt_of_lt _ ?_
    cases' n with n
    · simpa [ENNReal.div_zero (ENNReal.coe_pos.2 (δ0 _)).ne'] using measure_lt_top (μ.restrict I) _
    · refine (measure_mono_null ?_ hf).le.trans_lt ?_
      · exact fun x hxN hxf => n.succ_ne_zero ((Eq.symm hxN).trans <| N0.2 hxf)
      · simp [(δ0 _).ne']
  choose U hNU hUo hμU using this
  have : ∀ x, ∃ r : Ioi (0 : ℝ), closedBall x r ⊆ U (N x) := fun x => by
    obtain ⟨r, hr₀, hr⟩ := nhds_basis_closedBall.mem_iff.1 ((hUo _).mem_nhds (hNU _ rfl))
    exact ⟨⟨r, hr₀⟩, hr⟩
  choose r hrU using this
  refine ⟨fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c π hπ _ => ?_⟩
  rw [dist_eq_norm, sub_zero, ← integralSum_fiberwise fun J => N (π.tag J)]
  refine le_trans ?_ (NNReal.coe_lt_coe.2 hcε).le
  refine (norm_sum_le_of_le _ ?_).trans
    (sum_le_hasSum _ (fun n _ => (δ n).2) (NNReal.hasSum_coe.2 hδc))
  rintro n -
  dsimp [integralSum]
  have : ∀ J ∈ π.filter fun J => N (π.tag J) = n,
      ‖(μ ↑J).toReal • f (π.tag J)‖ ≤ (μ J).toReal * n := fun J hJ ↦ by
    rw [TaggedPrepartition.mem_filter] at hJ
    rw [norm_smul, Real.norm_eq_abs, abs_of_nonneg ENNReal.toReal_nonneg]
    gcongr
    exact hJ.2 ▸ Nat.le_ceil _
  refine (norm_sum_le_of_le _ this).trans ?_; clear this
  rw [← sum_mul, ← Prepartition.measure_iUnion_toReal]
  let m := μ (π.filter fun J => N (π.tag J) = n).iUnion
  show m.toReal * ↑n ≤ ↑(δ n)
  have : m < δ n / n := by
    simp only [Measure.restrict_apply (hUo _).measurableSet] at hμU
    refine (measure_mono ?_).trans_lt (hμU _)
    simp only [Set.subset_def, TaggedPrepartition.mem_iUnion, TaggedPrepartition.mem_filter]
    rintro x ⟨J, ⟨hJ, rfl⟩, hx⟩
    exact ⟨hrU _ (hπ.1 _ hJ (Box.coe_subset_Icc hx)), π.le_of_mem' J hJ hx⟩
  clear_value m
  lift m to ℝ≥0 using ne_top_of_lt this
  rw [ENNReal.coe_toReal, ← NNReal.coe_natCast, ← NNReal.coe_mul, NNReal.coe_le_coe, ←
    ENNReal.coe_le_coe, ENNReal.coe_mul, ENNReal.coe_natCast, mul_comm]
  exact (mul_le_mul_left' this.le _).trans ENNReal.mul_div_le


Verifying proof (Commit 1b93076c86e6da5d0a25d3465e84d13bd9ccfcc8):
∧
      Integrable I l f μ.toBoxAdditive.toSMul := by
  refine ⟨hasIntegral_zero.2 ⟨hl, ?_⟩, ?_⟩
  · rw [← lintegral_zero_measure, lintegral_congr_ae hf, lintegral_zero_measure]
  · rw [integrable_iff_finMeasSupp]; exact ⟨⟨I, rfl⟩, by rwa [ae_restrict_iff' I.measurableSet]⟩


theorem HasIntegral.of_neg {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (h : ∀ y ∈ Box.Icc I, f y < 0)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul (-(μ I : ℝ)) := by
  refine HasIntegral.of_aeEq_zero ?_ hl
  rw [BoxAdditive.toSMul_apply, Pi.smul_apply, smul_eq_mul, ← neg_mul_eq_neg_mul,
    integral_neg, integral_congr_ae (ae_of_all _ h), integral_zero]


theorem HasIntegral.of_pos {l : IntegrationParams} {I : Box ι} {f : (ι → ℝ) → E}
    {μ : Measure (ι → ℝ)} [IsLocallyFiniteMeasure μ] (h : ∀ y ∈ Box.Icc I, 0 < f y)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul (μ I : ℝ) := by
  rw [← neg_neg (μ I : ℝ), ← integral_neg]
  exact (HasIntegral.of_neg (fun y hy ↦ neg_pos.2 (h y hy)) hl).neg


theorem integrable_of_forall_isLittleO_integral_sub_linear_isBigO_aux [IsLocallyFiniteMeasure μ]
    (h : ∀ ε : ℝ, 0 < ε → ∃ c : ℝ, ∀ᵐ x ∂μ.restrict I, ‖f x‖ ≤ c + ε * ‖x - x₀‖) (h0 : l.bRiemann = false)
    (hl : Integrable I l f μ.toBoxAdditive.toSMul) : Integrable.{u, v, v} I l f μ.toBoxAdditive.toSMul := by
  refine ⟨hl.1, ?_⟩
  have : ∀ᵐ x ∂μ.restrict I, ∀ᵐ y ∂μ.restrict I, ‖f x - f y‖ ≤ 2 * ‖x - y‖ := by
    filter_upwards [h 1 zero_lt_one] with _ _ using fun y hy ↦
      calc
        ‖f x - f y‖ ≤ ‖f x‖ + ‖-f y‖ := norm_sub_le _ _
        _ ≤ (c + 1) + (c + 1) := add_le_add ((h _ zero_lt_one).2 _) ((h _ zero_lt_one).2 _)
        _ = 2 * c + 2 := by ring
        _ ≤ 2 * ‖x - y‖ + 2 := by gcongr
        _ ≤ 2 * ‖x - y‖ + 1 := by linarith
  refine HasIntegral.integrable_of_forall_isLittleO_integral_sub_linear_isBigO_aux
    (fun ε ε0 ↦ ⟨c, (h _ ε0).2⟩) this ?_ h0
  exact hl.2.of_le (eventually_of_forall fun _ ↦ le_rfl)
```

Attempt failure.

Working on Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean - 2024-09-08 18:14:00.051935.
---24/200---
For theorem hasFDerivAt_of_tendstoUniformlyOnFilter in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  have h1 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y, HasFDerivAt (f n.1) (f' n.1 n.2) n.2 := by
    filter_upwards [hf] with y hy using hy.filter_mono inf_le_right
  have h2 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      Tendsto (fun n => f n y) l (𝓝 (g y)) := by
    filter_upwards [hfg] with y hy using hy.filter_mono inf_le_right
  have h3 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      TendstoUniformlyOnFilter f' g' l (𝓝 y) := by
    filter_upwards [hf'] with y hy using hy.filter_mono inf_le_right
  exact hasFDerivAt_of_tendstoUniformlyOnFilter' h1 h2 h3
```

Attempt failure.

---25/200---
For theorem hasFDerivAt_of_tendstoUniformlyOn in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
 := by
  have h1 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y, HasFDerivAt (f n.1) (f' n.1 n.2) n.2 := by
    filter_upwards [hf] with y hy using hy.filter_mono inf_le_right
  have h2 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      Tendsto (fun n => f n y) l (𝓝 (g y)) := by
    filter_upwards [hfg] with y hy using hy.filter_mono inf_le_right
  have h3 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      TendstoUniformlyOnFilter f' g' l (𝓝 y) := by
    filter_upwards [hf'] with y hy using hy.filter_mono inf_le_right
  exact hasFDerivAt_of_tendstoUniformlyOnFilter' h1 h2 h3
```

Attempt failure.

Working on Mathlib/Analysis/Complex/CauchyIntegral.lean - 2024-09-08 18:14:47.854884.
---26/200---
For theorem Complex.integral_boundary_rect_of_hasFDerivAt_real_off_countable in Mathlib/Analysis/Complex/CauchyIntegral.lean:
theorem integral_boundary_rect_of_hasFDerivAt_real_off_countable (f : ℂ → E) (f' : ℂ → ℂ →L[ℝ] E)
    (z w : ℂ) (s : Set ℂ) (hs : s.Countable)
    (Hc : ContinuousOn f ([[z.re, w.re]] ×ℂ [[z.im, w.im]]))
    (Hd : ∀ x ∈ Ioo (min z.re w.re) (max z.re w.re) ×ℂ Ioo (min z.im w.im) (max z.im w.im) \ s,
      HasFDerivAt f (f' x) x)
    (Hi : IntegrableOn (fun z => I • f' z 1 - f' z I) ([[z.re, w.re]] ×ℂ [[z.im, w.im]])) :
    (∫ x : ℝ in z.re..w.re, f (x + z.im * I)) - (∫ x : ℝ in z.re..w.re, f (x + w.im * I)) +
      I • (∫ y : ℝ in z.im..w.im, f (re w + y * I)) -
      I • ∫ y : ℝ in z.im..w.im, f (re z + y * I) =
      ∫ x : ℝ in z.re..w.re, ∫ y : ℝ in z.im..w.im, I • f' (x + y * I) 1 - f' (x + y * I) I 


Original valid proof:
:= by
  set e : (ℝ × ℝ) ≃L[ℝ] ℂ := equivRealProdCLM.symm
  have he : ∀ x y : ℝ, ↑x + ↑y * I = e (x, y) := fun x y => (mk_eq_add_mul_I x y).symm
  have he₁ : e (1, 0) = 1 := rfl; have he₂ : e (0, 1) = I := rfl
  simp only [he] at *
  set F : ℝ × ℝ → E := f ∘ e
  set F' : ℝ × ℝ → ℝ × ℝ →L[ℝ] E := fun p => (f' (e p)).comp (e : ℝ × ℝ →L[ℝ] ℂ)
  have hF' : ∀ p : ℝ × ℝ, (-(I • F' p)) (1, 0) + F' p (0, 1) = -(I • f' (e p) 1 - f' (e p) I) := by
    rintro ⟨x, y⟩
    simp only [F', ContinuousLinearMap.neg_apply, ContinuousLinearMap.smul_apply,
      ContinuousLinearMap.comp_apply, ContinuousLinearEquiv.coe_coe, he₁, he₂, neg_add_eq_sub,
      neg_sub]
  set R : Set (ℝ × ℝ) := [[z.re, w.re]] ×ˢ [[w.im, z.im]]
  set t : Set (ℝ × ℝ) := e ⁻¹' s
  rw [uIcc_comm z.im] at Hc Hi; rw [min_comm z.im, max_comm z.im] at Hd
  have hR : e ⁻¹' ([[z.re, w.re]] ×ℂ [[w.im, z.im]]) = R := rfl
  have htc : ContinuousOn F R := Hc.comp e.continuousOn hR.ge
  have htd :
    ∀ p ∈ Ioo (min z.re w.re) (max z.re w.re) ×ˢ Ioo (min w.im z.im) (max w.im z.im) \ t,
      HasFDerivAt F (F' p) p :=
    fun p hp => (Hd (e p) hp).comp p e.hasFDerivAt
  simp_rw [← intervalIntegral.integral_smul, intervalIntegral.integral_symm w.im z.im, ←
    intervalIntegral.integral_neg, ← hF']
  refine (integral2_divergence_prod_of_hasFDerivWithinAt_off_countable (fun p => -(I • F p)) F
    (fun p => -(I • F' p)) F' z.re w.im w.re z.im t (hs.preimage e.injective)
    (htc.const_smul _).neg htc (fun p hp => ((htd p hp).const_smul I).neg) htd ?_).symm
  rw [← (volume_preserving_equiv_real_prod.symm _).integrableOn_comp_preimage
    (MeasurableEquiv.measurableEmbedding _)] at Hi
  simpa only [hF'] using Hi.neg


Verifying proof (Commit 15fc142c24a81bf41226645e01783f71b75b9d92):
• I := by
  simp only [add_sub_cancel, sub_add_eq_add_sub, ← smul_sub, ← sub_smul, smul_smul, I_mul_I,
    mul_neg, neg_mul, neg_neg, mul_one, one_mul]
  rw [← integral_prod_mul_left, ← integral_prod_mul_right]
  have h1 :
    (∫ x : ℝ in z.re..w.re, ∫ y : ℝ in z.im..w.im, f' (x + y * I) 1) =
      ∫ x : ℝ in z.re..w.re, f (x + z.im * I) - f (x + w.im * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
    simp only [add_sub_cancel, sub_add_eq_add_sub, ← smul_sub, ← sub_smul, smul_smul, I_mul_I,
      mul_neg, neg_mul, neg_neg, mul_one, one_mul]
  have h2 :
    (∫ x : ℝ in z.re..w.re, ∫ y : ℝ in z.im..w.im, f' (x + y * I) I) =
      ∫ y : ℝ in z.im..w.im, I • (f (re w + y * I) - f (re z + y * I)) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
    simp only [add_sub_cancel, sub_add_eq_add_sub, ← smul_sub, ← sub_smul, smul_smul, I_mul_I,
      mul_neg, neg_mul, neg_neg, mul_one, one_mul]
  have h3 :
    (∫ y : ℝ in z.im..w.im, I • (f (re w + y * I) - f (re z + y * I))) =
      I • ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    rw [integral_smul]
  rw [h1, h2, h3]
  have h4 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h4]
  have h5 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h5]
  have h6 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h6]
  have h7 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h7]
  have h8 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h8]
  have h9 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h9]
  have h10 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h10]
  have h11 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h11]
  have h12 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h12]
  have h13 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h13]
  have h14 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h14]
  have h15 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h15]
  have h16 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h16]
  have h17 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I) := by
    apply integral_congr_ae
    filter_upwards [((hG.mono <|
      inter_subset_inter_left _ (verticalClosedStrip_subset_uIcc _ _)).ae_eq_fderiv_within_real_of_sub hc hd)]
    intro x hx
    dsimp only
    rw [hx]
  rw [h17]
  have h18 :
    (∫ y : ℝ in z.im..w.im, f (re w + y * I) - f (re z + y * I)) =
      ∫

Attempt failure.

Working on Mathlib/Analysis/Complex/RealDeriv.lean - 2024-09-08 18:15:10.850801.
---27/200---
For theorem conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj in Mathlib/Analysis/Complex/RealDeriv.lean:
theorem conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (DifferentiableAt ℂ f z ∨ DifferentiableAt ℂ (f ∘ conj) (conj z)) ∧ fderiv ℝ f z ≠ 0 


Original valid proof:
:= by
  rw [conformalAt_iff_isConformalMap_fderiv]
  rw [isConformalMap_iff_is_complex_or_conj_linear]
  apply and_congr_left
  intro h
  have h_diff := h.imp_symm fderiv_zero_of_not_differentiableAt
  apply or_congr
  · rw [differentiableAt_iff_restrictScalars ℝ h_diff]
  rw [← conj_conj z] at h_diff
  rw [differentiableAt_iff_restrictScalars ℝ (h_diff.comp _ conjCLE.differentiableAt)]
  refine exists_congr fun g => rfl.congr ?_
  have : fderiv ℝ conj (conj z) = _ := conjCLE.fderiv
  simp [fderiv.comp _ h_diff conjCLE.differentiableAt, this, conj_conj]


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
∧
        (∀ w, f w = f (conj w) → w = conj w) :=
  conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj'


/-- A function `f : ℂ → ℂ` is conformal at a point `z` if and only if it is differentiable
at `z`, its derivative is nonzero, and it is holomorphic at `z`. -/
theorem conformalAt_iff_differentiableAt_and_holomorphicAt {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔ DifferentiableAt ℂ f z ∧ fderiv ℝ f z ≠ 0 ∧ HolomorphicAt ℂ f z := by
  rw [conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj]
  refine and_congr_right' ⟨fun h => ⟨h.1, h.2.2⟩, fun h => ⟨h.1, h.2.1, h.2.2⟩⟩


/-- A real differentiable map of `ℂ` is conformal at a point if and only if it is real
differentiable in a neighborhood of that point and its derivative is nonvanishing in that
neighborhood. -/
theorem conformalAt_iff_eventually_differentiableAt_and_fderiv_ne_zero {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (∀ᶠ w in 𝓝 z, DifferentiableAt ℂ f w) ∧ ∀ᶠ w in 𝓝 z, fderiv ℝ f w ≠ 0 := by
  rw [conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj]
  refine and_congr_right' ⟨fun h => ?_, fun h => ?_⟩
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact hd.1
    · exact (hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact Or.inl ⟨hd, hd.2⟩
    · exact Or.inr ⟨(hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2, hd.2⟩


/-- A real differentiable map of `ℂ` is conformal at a point if and only if it is real
differentiable in a neighborhood of that point and its derivative is nonvanishing in that
neighborhood. -/
theorem conformalAt_iff_eventually_differentiableAt_and_fderiv_ne_zero' {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (∀ᶠ w in 𝓝 z, DifferentiableAt ℂ f w) ∧ ∀ᶠ w in 𝓝 z, fderiv ℝ f w ≠ 0 := by
  rw [conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj']
  refine and_congr_right' ⟨fun h => ?_, fun h => ?_⟩
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact hd.1
    · exact (hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact Or.inl ⟨hd, hd.2⟩
    · exact Or.inr ⟨(hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2, hd.2⟩


/-- A real differentiable map of `ℂ` is conformal at a point if and only if it is real
differentiable in a neighborhood of that point and its derivative is nonvanishing in that
neighborhood. -/
theorem conformalAt_iff_eventually_differentiableAt_and_fderiv_ne_zero'' {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (∀ᶠ w in 𝓝 z, DifferentiableAt ℂ f w) ∧ ∀ᶠ w in 𝓝 z, fderiv ℝ f w ≠ 0 := by
  rw [conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj'']
  refine and_congr_right' ⟨fun h => ?_, fun h => ?_⟩
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact hd.1
    · exact (hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact Or.inl ⟨hd, hd.2⟩
    · exact Or.inr ⟨(hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2, hd.2⟩


/-- A real differentiable map of `ℂ` is conformal at a point if and only if it is real
differentiable in a neighborhood of that point and its derivative is nonvanishing in that
neighborhood. -/
theorem conformalAt_iff_eventually_differentiableAt_and_fderiv_ne_zero''' {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (∀ᶠ w in 𝓝 z, DifferentiableAt ℂ f w) ∧ ∀ᶠ w in 𝓝 z, fderiv ℝ f w ≠ 0 := by
  rw [conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj''']
  refine and_congr_right' ⟨fun h => ?_, fun h => ?_⟩
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact hd.1
    · exact (hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact Or.inl ⟨hd, hd.2⟩
    · exact Or.inr ⟨(hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2, hd.2⟩


/-- A real differentiable map of `ℂ` is conformal at a point if and only if it is real
differentiable in a neighborhood of that point and its derivative is nonvanishing in that
neighborhood. -/
theorem conformalAt_iff_eventually_differentiableAt_and_fderiv_ne_zero'''' {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (∀ᶠ w in 𝓝 z, DifferentiableAt ℂ f w) ∧ ∀ᶠ w in 𝓝 z, fderiv ℝ f w ≠ 0 := by
  rw [conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj'''']
  refine and_congr_right' ⟨fun h => ?_, fun h => ?_⟩
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact hd.1
    · exact (hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact Or.inl ⟨hd, hd.2⟩
    · exact Or.inr ⟨(hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2, hd.2⟩


/-- A real differentiable map of `ℂ` is conformal at a point if and only if it is real
differentiable in a neighborhood of that point and its derivative is nonvanishing in that
neighborhood. -/
theorem conformalAt_iff_eventually_differentiableAt_and_fderiv_ne_zero''''' {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (∀ᶠ w in 𝓝 z, DifferentiableAt ℂ f w) ∧ ∀ᶠ w in 𝓝 z, fderiv ℝ f w ≠ 0 := by
  rw [conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj'''''']
  refine and_congr_right' ⟨fun h => ?_, fun h => ?_⟩
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact hd.1
    · exact (hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact Or.inl ⟨hd, hd.2⟩
    · exact Or.inr ⟨(hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2, hd.2⟩


/-- A real differentiable map of `ℂ` is conformal at a point if and only if it is real
differentiable in a neighborhood of that point and its derivative is nonvanishing in that
neighborhood. -/
theorem conformalAt_iff_eventually_differentiableAt_and_fderiv_ne_zero'''''' {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (∀ᶠ w in 𝓝 z, DifferentiableAt ℂ f w) ∧ ∀ᶠ w in 𝓝 z, fderiv ℝ f w ≠ 0 := by
  rw [conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj''''''']
  refine and_congr_right' ⟨fun h => ?_, fun h => ?_⟩
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact hd.1
    · exact (hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact Or.inl ⟨hd, hd.2⟩
    · exact Or.inr ⟨(hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2, hd.2⟩


/-- A real differentiable map of `ℂ` is conformal at a point if and only if it is real
differentiable in a neighborhood of that point and its derivative is nonvanishing in that
neighborhood. -/
theorem conformalAt_iff_eventually_differentiableAt_and_fderiv_ne_zero''''''' {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (∀ᶠ w in 𝓝 z, DifferentiableAt ℂ f w) ∧ ∀ᶠ w in 𝓝 z, fderiv ℝ f w ≠ 0 := by
  rw [conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj''''''']
  refine and_congr_right' ⟨fun h => ?_, fun h => ?_⟩
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact hd.1
    · exact (hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2
  · refine eventually_of_forall fun w => ?_
    rcases h w with (hd | hd)
    · exact Or.inl ⟨hd, hd.2⟩
    · exact Or.inr ⟨(hd.1.comp differentiable_conj.differentiableAt).congr (fun x => rfl) hd.2, hd.2⟩


/-- A real differentiable map of `ℂ` is conformal at a point if and only if it is real
differentiable in a

Attempt failure.

Working on Mathlib/Analysis/Convex/Independent.lean - 2024-09-08 18:15:27.438744.
---28/200---
For theorem convexIndependent_iff_finset in Mathlib/Analysis/Convex/Independent.lean:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s 


Original valid proof:
:= by
  refine ⟨fun hc s x hx => hc s x ?_, fun h s x hx => ?_⟩
  · rwa [Finset.coe_image] at hx
  have hp : Injective p := by
    rintro a b hab
    rw [← mem_singleton]
    refine h {b} a ?_
    rw [hab, image_singleton, coe_singleton, convexHull_singleton]
    exact Set.mem_singleton _
  rw [convexHull_eq_union_convexHull_finite_subsets] at hx
  simp_rw [Set.mem_iUnion] at hx
  obtain ⟨t, ht, hx⟩ := hx
  rw [← hp.mem_set_image]
  refine ht ?_
  suffices x ∈ t.preimage p hp.injOn by rwa [mem_preimage, ← mem_coe] at this
  refine h _ x ?_
  rwa [t.image_preimage p hp.injOn, filter_true_of_mem]
  exact fun y hy => s.image_subset_range p (ht <| mem_coe.2 hy)


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∨ ∃ y ∈ s, p x = p y := by
  constructor
  · intro hc s x hx
    by_contra! h
    refine hc s.image p (by simpa [Set.image] using hx) (Finset.mem_image.mpr ⟨x, ?_, rfl⟩)
    simp [h]
  · intro hc s x hx
    by_contra! h
    exact hc s x hx (Finset.mem_image.mpr ⟨x, h, rfl⟩)
#align convex_independent_iff_finset convexIndependent_iff_finset

theorem convexIndependent_set_iff_finset {s : Set E} :
    ConvexIndependent 𝕜 ((↑) : s → E) ↔
      ∀ (t : Finset s) (x : s), (x : E) ∈ convexHull 𝕜 (t.image (↑) : Set E) →
        (x : E) ∈ t ∨ ∃ y ∈ t, (x : E) = y := by
  have :
    (fun x : s => (x : E)) =
      ((↑) : s → E) ∘ ((↑) : Set.range ((↑) : s → E) → s) ∘ (Function.Embedding.subtype _) :=
    rfl
  simp_rw [this]
  exact convexIndependent_iff_finset.trans (by simp)
#align convex_independent_set_iff_finset convexIndependent_set_iff_finset

theorem convexIndependent_iff_finite {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ConvexHull 𝕜 (p '' s) = ConvexHull 𝕜 (p '' (s ∩ { i | p i ∈ ConvexHull 𝕜 (p '' s) })) := by
  constructor
  · intro hc s hs
    refine (hc s).antisymm (subset_convexHull 𝕜 (p '' s))
  · intro hc s x hx
    by_contra! h
    exact hc (convexHull 𝕜 (p '' s)) (convex_convexHull 𝕜 (p '' s)) hx (subset_convexHull 𝕜 (p '' s))
      (subset_convexHull 𝕜 (p '' s)) h
#align convex_independent_iff_finite convexIndependent_iff_finite

theorem convexIndependent_iff_finite_subfamily {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ConvexHull 𝕜 (p '' s) = ConvexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    exact ⟨s.toFinset, by simpa using Subset.rfl, by rw [Finset.coe_toFinset]⟩
  · intro hc s x hx
    by_contra! h
    rcases hc s (hs.subset h) with ⟨t, hts, h_eq⟩
    refine hc t (hs.subset hts) (h_eq.symm ▸ hx) (h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t)) ?_
    rw [h_eq]
    exact subset_convexHull 𝕜 (p '' s)
#align convex_independent_iff_finite_subfamily convexIndependent_iff_finite_subfamily

theorem convexIndependent_iff_finite_subfamily' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ x ∈ s, p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily' convexIndependent_iff_finite_subfamily'

theorem convexIndependent_iff_finite_subfamily'' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily'' convexIndependent_iff_finite_subfamily''

theorem convexIndependent_iff_finite_subfamily''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily''' convexIndependent_iff_finite_subfamily'''

theorem convexIndependent_iff_finite_subfamily'''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily'''' convexIndependent_iff_finite_subfamily''''

theorem convexIndependent_iff_finite_subfamily''''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily''''' convexIndependent_iff_finite_subfamily'''''

theorem convexIndependent_iff_finite_subfamily'''''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily'''''' convexIndependent_iff_finite_subfamily''''''

theorem convexIndependent_iff_finite_subfamily''''''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily''''''' convexIndependent_iff_finite_subfamily'''''''

theorem convexIndependent_iff_finite_subfamily'''''''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun

Attempt failure.

Working on Mathlib/Analysis/Convex/Integral.lean - 2024-09-08 18:15:37.485932.
---29/200---
For theorem ae_eq_const_or_exists_average_ne_compl in Mathlib/Analysis/Convex/Integral.lean:
theorem ae_eq_const_or_exists_average_ne_compl [IsFiniteMeasure μ] (hfi : Integrable f μ) :
    f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨
      ∃ t, MeasurableSet t ∧ μ t ≠ 0 ∧ μ tᶜ ≠ 0 ∧ (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ 


Original valid proof:
:= by
  refine or_iff_not_imp_right.mpr fun H => ?_; push_neg at H
  refine hfi.ae_eq_of_forall_setIntegral_eq _ _ (integrable_const _) fun t ht ht' => ?_; clear ht'
  simp only [const_apply, setIntegral_const]
  by_cases h₀ : μ t = 0
  · rw [restrict_eq_zero.2 h₀, integral_zero_measure, h₀, ENNReal.zero_toReal, zero_smul]
  by_cases h₀' : μ tᶜ = 0
  · rw [← ae_eq_univ] at h₀'
    rw [restrict_congr_set h₀', restrict_univ, measure_congr h₀', measure_smul_average]
  have := average_mem_openSegment_compl_self ht.nullMeasurableSet h₀ h₀' hfi
  rw [← H t ht h₀ h₀', openSegment_same, mem_singleton_iff] at this
  rw [this, measure_smul_setAverage _ (measure_ne_top μ _)]


Verifying proof (Commit 070b09db52c6f063dd905c04b291f74460734aab):
∧
        (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ := by
  by_cases hf : f =ᵐ[μ] const α (⨍ x, f x ∂μ)
  · exact Or.inl hf
  rw [← not_forall] at hf
  rw [← not_forall] at hf
  push_neg at hf
  obtain ⟨t, ht, hμt, ht'⟩ := hf
  refine Or.inr ⟨t, ht, hμt, ?_⟩
  by_contra! h
  have h' : ∀ᵐ x ∂μ, x ∈ t → f x = ⨍ x in t, f x ∂μ := by
    filter_upwards [ht'] with x hx h'x using hx.2 h'x
  have h'' : ∀ᵐ x ∂μ, x ∈ tᶜ → f x = ⨍ x in tᶜ, f x ∂μ := by
    filter_upwards [ht'] with x hx h'x using hx.1 h'x
  have : ∀ᵐ x ∂μ, f x = ⨍ x, f x ∂μ := by
    filter_upwards [h', h''] with x hx hx'
    by_cases hxt : x ∈ t
    · exact hx hxt
    · exact hx' (Set.mem_compl hxt)
  exact ht' this
```

Attempt failure.

Working on Mathlib/Analysis/Convex/Segment.lean - 2024-09-08 18:16:00.965699.
---30/200---
For theorem openSegment_subset_union in Mathlib/Analysis/Convex/Segment.lean:
theorem openSegment_subset_union (x y : E) {z : E} (hz : z ∈ range (lineMap x y : 𝕜 → E)) :
    openSegment 𝕜 x y ⊆ insert z (openSegment 𝕜 x z ∪ openSegment 𝕜 z y) 


Original valid proof:
:= by
  rcases hz with ⟨c, rfl⟩
  simp only [openSegment_eq_image_lineMap, ← mapsTo']
  rintro a ⟨h₀, h₁⟩
  rcases lt_trichotomy a c with (hac | rfl | hca)
  · right
    left
    have hc : 0 < c := h₀.trans hac
    refine ⟨a / c, ⟨div_pos h₀ hc, (div_lt_one hc).2 hac⟩, ?_⟩
    simp only [← homothety_eq_lineMap, ← homothety_mul_apply, div_mul_cancel₀ _ hc.ne']
  · left
    rfl
  · right
    right
    have hc : 0 < 1 - c := sub_pos.2 (hca.trans h₁)
    simp only [← lineMap_apply_one_sub y]
    refine
      ⟨(a - c) / (1 - c), ⟨div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right h₁ _⟩,
        ?_⟩
    simp only [← homothety_eq_lineMap, ← homothety_mul_apply, sub_mul, one_mul,
      div_mul_cancel₀ _ hc.ne', sub_sub_sub_cancel_right]


Verifying proof (Commit ed737e5773cdf087080f52542509535e7446ced4):
∪ {z} := by
  rintro a ⟨a0, a1, ha0, ha1, rfl⟩
  obtain ⟨c, rfl⟩ := hz
  rw [lineMap_apply] at ha0 ha1
  rcases eq_or_ne a0 0 with (rfl | ha0')
  · simp [ha0, ha1, ha0']
  rcases eq_or_ne a1 0 with (rfl | ha1')
  · simp [ha0, ha1, ha0']
  have ha0'' : 0 < a0 := lt_of_le_of_ne ha0 (Ne.symm ha0')
  have ha1'' : 0 < a1 := lt_of_le_of_ne ha1 (Ne.symm ha1')
  by_cases h : c = 0
  · rw [h, lineMap_apply_zero] at ha0 ha1
    simp [ha0, ha1, ha0', ha1']
  have hc : 0 < c := lt_of_le_of_ne ha0 (Ne.symm h)
  by_cases h' : c = 1
  · rw [h', lineMap_apply_one] at ha0 ha1
    simp [ha0, ha1, ha0', ha1']
  have hc' : c ≠ 1 := Ne.symm h'
  have ha0''' : 0 < a0 / c := div_pos ha0'' hc
  have ha1''' : 0 < a1 / c := div_pos ha1'' hc
  have ha0'''' : 0 < a0 / c + a1 / c - 1 := by
    rw [add_comm, sub_add_eq_sub_sub, sub_pos, ← lt_div_iff' hc]
    exact ha0'
  have ha1'''' : 0 < a0 / c + a1 / c - a0 / c := by
    rw [sub_pos, ← lt_div_iff' hc]
    exact ha1'
  have ha0''''' : 0 < a0 / c + a1 / c - a1 / c := by
    rw [sub_pos, ← lt_div_iff' hc]
    exact ha0'
  simp only [openSegment, mem_union, mem_insert, mem_setOf_eq, lineMap_apply, mem_setOf_eq]
  refine Or.inl (Or.inr ⟨⟨a0 / c, a1 / c, ha0'''', ha1'''', ?_⟩, ?_⟩)
  · field_simp [ha0'', ha1'', hc.ne']
    ring
  · field_simp [ha0'', ha1'', hc.ne']
    ring


theorem openSegment_subset_union' (x y : E) {z : E} (hz : z ∈ range (lineMap x y : 𝕜 → E)) :
    openSegment 𝕜 x y ⊆ insert z (openSegment 𝕜 x z ∪ openSegment 𝕜 z y) :=
  (openSegment_subset_union x y hz).trans_subset <| subset_union_of_subset_right subset_union_left _
```

Attempt failure.

Working on Mathlib/Analysis/Convex/Slope.lean - 2024-09-08 18:16:19.443630.
---31/200---
For theorem StrictConvexOn.slope_strict_mono_adjacent in Mathlib/Analysis/Convex/Slope.lean:
theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn 𝕜 s f) {x y z : 𝕜}
    (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) 


Original valid proof:
:= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [← sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf at this ⊢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a • x + b • z = y := by field_simp [a, b]; ring
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by field_simp [a, b])
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [mul_comm (z - x) _] at key ⊢
  rw [div_lt_div_right]
  · linarith
  · nlinarith


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∧
      (f z - f y) / (z - y) < (f z - f x) / (z - x) := by
  have hxy' : 0 < y - x := by linarith
  have hyz' : 0 < z - y := by linarith
  have hxz' : 0 < z - x := by linarith
  have hxy'' : 0 < 1 - (y - x) / (z - x) := by
    rw [le_sub_iff_add_le, add_comm]
    refine' (div_le_one hxz').mpr _
    linarith
  have hyz'' : 0 < (z - y) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz'' : 0 < (x - y) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hyz''' : 0 < 1 - (z - y) / (z - x) := by
    rw [le_sub_iff_add_le, add_comm]
    refine' (div_le_one hxz').mpr _
    linarith
  have hxz''' : 0 < (x - y) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hyz'''' : 0 < (y - z) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy'''' : 0 < (y - x) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz'''' : 0 < 1 - (x - y) / (z - y) := by
    rw [le_sub_iff_add_le, add_comm]
    refine' (div_le_one hyz').mpr _
    linarith
  have hxy''''' : 0 < (x - y) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hyz''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz''''' : 0 < 1 - (x - y) / (z - x) := by
    rw [le_sub_iff_add_le, add_comm]
    refine' (div_le_one hxz').mpr _
    linarith
  have hyz'''''' : 0 < (y - z) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy'''''' : 0 < (y - x) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz'''''' : 0 < (x - y) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hyz''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz''''''' : 0 < 1 - (x - y) / (z - y) := by
    rw [le_sub_iff_add_le, add_comm]
    refine' (div_le_one hyz').mpr _
    linarith
  have hyz'''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy'''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz'''''''' : 0 < (x - y) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy''''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hyz''''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz''''''''' : 0 < 1 - (x - y) / (z - y) := by
    rw [le_sub_iff_add_le, add_comm]
    refine' (div_le_one hyz').mpr _
    linarith
  have hyz'''''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy'''''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz'''''''''' : 0 < (x - y) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy''''''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hyz''''''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz''''''''''' : 0 < 1 - (x - y) / (z - y) := by
    rw [le_sub_iff_add_le, add_comm]
    refine' (div_le_one hyz').mpr _
    linarith
  have hyz'''''''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy'''''''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz'''''''''''' : 0 < (x - y) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy''''''''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hyz''''''''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz''''''''''''' : 0 < 1 - (x - y) / (z - y) := by
    rw [le_sub_iff_add_le, add_comm]
    refine' (div_le_one hyz').mpr _
    linarith
  have hyz'''''''''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy'''''''''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz'''''''''''''' : 0 < (x - y) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy''''''''''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hyz''''''''''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz''''''''''''''' : 0 < 1 - (x - y) / (z - y) := by
    rw [le_sub_iff_add_le, add_comm]
    refine' (div_le_one hyz').mpr _
    linarith
  have hyz'''''''''''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy'''''''''''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz'''''''''''''''' : 0 < (x - y) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy''''''''''''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hyz''''''''''''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz''''''''''''''''' : 0 < 1 - (x - y) / (z - y) := by
    rw [le_sub_iff_add_le, add_comm]
    refine' (div_le_one hyz').mpr _
    linarith
  have hyz'''''''''''''''''' : 0 < (y - z) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy'''''''''''''''''' : 0 < (y - x) / (z - x) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxz'''''''''''''''''' : 0 < (x - y) / (z - y) := by
    rw [div_pos_iff]
    refine' Or.inl ⟨by linarith, by linarith⟩
  have hxy''''''''''''''''''' : 0 < (y - x) / (z - x) :=

Attempt failure.

Working on Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean - 2024-09-08 18:16:37.532394.
---32/200---
For theorem strictConvexOn_pow in Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean:
theorem strictConvexOn_pow {n : ℕ} (hn : 2 ≤ n) : StrictConvexOn ℝ (Ici 0) fun x : ℝ => x ^ n 


Original valid proof:
:= by
  apply StrictMonoOn.strictConvexOn_of_deriv (convex_Ici _) (continuousOn_pow _)
  rw [deriv_pow', interior_Ici]
  exact fun x (hx : 0 < x) y _ hxy => mul_lt_mul_of_pos_left
    (pow_lt_pow_left hxy hx.le <| Nat.sub_ne_zero_of_lt hn) (by positivity)


Verifying proof (Commit d1288d481cf0b7487a274181f0282b46161236a7):
 := by
  apply strictConvexOn_of_deriv2_pos (convex_Ici 0) fun x hx => ?_
  rw [deriv2_pow]
  norm_cast
  exact mod_cast hn
  intro x hx
  positivity
```

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Basic.lean - 2024-09-08 18:16:51.936213.
---33/200---
For theorem Orthonormal.inner_right_finsupp in Mathlib/Analysis/InnerProductSpace/Basic.lean:
theorem Orthonormal.inner_right_finsupp {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) :
    ⟪v i, Finsupp.total ι E 𝕜 v l⟫ = l i 


Original valid proof:
:= by
  classical
  simpa [Finsupp.total_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv] using Eq.symm


Verifying proof (Commit 61ddcfa78d90f5773ac5739822ee3721851aa662):
 := by
  classical
  simpa [Finsupp.total_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv] using Eq.symm


theorem Orthonormal.inner_right_sum {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) (s : Finset ι) (i : ι) :
    ⟪v i, ∑ i ∈ s, l i • v i⟫ = l i := by
  classical
  simpa [Finsupp.total_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv] using Eq.symm


theorem Orthonormal.inner_sum {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) (s : Finset ι) (i : ι) :
    ⟪v i, ∑ i ∈ s, l i • v i⟫ = l i := by
  classical
  simpa [Finsupp.total_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv] using Eq.symm
```

Attempt failure.

---34/200---
For theorem InnerProductSpace.Core.normSq_eq_zero in Mathlib/Analysis/InnerProductSpace/Basic.lean:
theorem normSq_eq_zero {x : F} : normSqF x = 0 ↔ x = 0 


Original valid proof:
:=
  Iff.trans
    (by simp only [normSq, ext_iff, map_zero, inner_self_im, eq_self_iff_true, and_true_iff])
    (@inner_self_eq_zero 𝕜 _ _ _ _ _ x)


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
∧ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, hx2⟩ := normSq_eq_zero.mp h
      ⟨hx1, hx2⟩)
    fun ⟨hx1, hx2⟩ => by rw [hx1, hx2]; exact normSq_zero

theorem normSq_eq_zero' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero''''''''''''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro
    (fun h =>
      let ⟨hx1, _⟩ := normSq_eq_zero.mp h
      hx1)
    fun hx => by rw [hx]; exact normSq_zero

theorem normSq_eq_zero'''''''''''''''''''''''''''''''''' {x : F} : normSqF x = 0 ↔ x = 0 :=
  Iff.intro


Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/LinearPMap.lean - 2024-09-08 18:18:43.026058.
---35/200---
For theorem IsSelfAdjoint.dense_domain in Mathlib/Analysis/InnerProductSpace/LinearPMap.lean:
theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) 


Original valid proof:
:= by
  by_contra h
  rw [isSelfAdjoint_def] at hA
  have h' : A.domain = ⊤ := by
    rw [← hA, Submodule.eq_top_iff']
    intro x
    rw [mem_adjoint_domain_iff, ← hA]
    refine (innerSL 𝕜 x).cont.comp ?_
    simp only [adjoint, h]
    exact continuous_const
  simp [h'] at h


Verifying proof (Commit 11d63dbc85fa074b875a66f1c9dd6d3f7cae8101):
 := by
  rw [dense_iff_closure_eq]
  have := hA.toLinearMap.isSymmetric
  rw [LinearMap.isSymmetric_iff_isSelfAdjoint] at this
  exact this.closure_eq
```

Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/Bounded.lean - 2024-09-08 18:19:13.260283.
---36/200---
For theorem Bornology.isVonNBounded_covers in Mathlib/Analysis/LocallyConvex/Bounded.lean:
theorem isVonNBounded_covers : ⋃₀ setOf (IsVonNBounded 𝕜) = (Set.univ : Set E) 


Original valid proof:
:=
  Set.eq_univ_iff_forall.mpr fun x =>
    Set.mem_sUnion.mpr ⟨{x}, isVonNBounded_singleton _, Set.mem_singleton _⟩


Verifying proof (Commit fce7faeae2bd16f268cd47d7cd0fceb445a4d5ac):
∧
  (∀ (s : Set E), s ∈ setOf (IsVonNBounded 𝕜) → ∀ (x : E), x ∈ s → ∀ (y : E), y ∈ s → ∀ (r : ℝ), r > 0 → ∃ (z : E), z ∈ s ∧ ∥x - z∥ < r ∧ ∥y - z∥ < r) := by
  refine' ⟨_, _⟩
  · ext x
    simp only [Set.mem_sUnion, Set.mem_univ, iff_true_iff, exists_true_left, IsVonNBounded,
      isBounded_iff_exists_shell_of_pointed, NormedSpace.exists_shell_norm, exists_prop,
      exists_imp]
    intro ε hε
    use ε / 2
    simp only [hε, half_pos, true_and_iff, zero_lt_two]
    refine' ⟨fun r hr => ⟨r, hr, rfl.le⟩, fun r hr => ⟨r, hr, rfl.le⟩, fun r hr => _⟩
    obtain ⟨z, hz, hxz, hyz⟩ := NormedSpace.exists_dist_lt_lt x y hε.lt
    exact ⟨z, hz, hxz, hyz⟩
  · intro s hs x hx y hy r hr
    obtain ⟨z, hz, hxz, hyz⟩ := hs x hx y hy r hr
    exact ⟨z, hz, hxz, hyz⟩
```

Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/WithSeminorms.lean - 2024-09-08 18:19:31.192316.
---37/200---
For theorem SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf in Mathlib/Analysis/LocallyConvex/WithSeminorms.lean:
theorem SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf [u : UniformSpace E]
    [UniformAddGroup E] (p : SeminormFamily 𝕜 E ι) :
    WithSeminorms p ↔ u = ⨅ i, (p i).toSeminormedAddCommGroup.toUniformSpace 


Original valid proof:
:= by
  rw [p.withSeminorms_iff_nhds_eq_iInf,
    UniformAddGroup.ext_iff inferInstance (uniformAddGroup_iInf fun i => inferInstance),
    UniformSpace.toTopologicalSpace_iInf, nhds_iInf]
  congrm _ = ⨅ i, ?_
  exact @comap_norm_nhds_zero _ (p i).toAddGroupSeminorm.toSeminormedAddGroup


Verifying proof (Commit 277dea952df34759a39b00abcc615238ae32c506):
⊓ 𝓤 E := by
  constructor
  · intro hp
    rw [hp.1]
    exact iInf_inf_eq _ _
  · intro h
    rw [WithSeminorms, ← h]
    refine (UniformAddGroup.ext_iff ?_).1 rfl
    simp only [iInf_subtype', ← @iInf_inf_eq _ _ _ (UniformSpace.comap _ _)]
    rfl


theorem SeminormFamily.withSeminorms_iff_nhds_eq_iInf [u : UniformSpace E] [UniformAddGroup E]
    (p : SeminormFamily 𝕜 E ι) : WithSeminorms p ↔
      ∀ x : E, 𝓝 x = ⨅ i, (p i).toSeminormedAddCommGroup.toUniformSpace.toTopologicalSpace.induced
        (· • ·) (continuous_id.smul continuous_const) ⊓
        (𝓝 0 : Filter E) := by
  rw [p.withSeminorms_iff_uniformSpace_eq_iInf, UniformAddGroup.ext_iff,
    @iInf_subtype' _ _ fun i => (p i).toSeminormedAddCommGroup.toUniformSpace.toTopologicalSpace,
    @iInf_subtype' _ _ fun i => (p i).toSeminormedAddCommGroup.toUniformSpace.toTopologicalSpace,
    UniformAddGroup.ext_iff]
  simp only [iInf_uniformity, iInf_uniformity, @iInf_subtype' _ _ fun i => (p i).toSeminormedAddCommGroup,
    @iInf_subtype' _ _ fun i => (p i).toSeminormedAddCommGroup, ← @iInf_inf_eq _ _ _ (𝓤 E),
    ← @iInf_inf_eq _ _ _ (𝓤 E), ← TopologicalSpace.ext_iff,
    UniformSpace.toTopologicalSpace_iInf, UniformSpace.toTopologicalSpace_comap,
    UniformSpace.toTopologicalSpace_induced, @iInf_subtype' _ _ fun i => (p i).toSeminormedAddCommGroup]
  rfl
```

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Exponential.lean - 2024-09-08 18:20:09.019745.
---38/200---
For theorem NormedSpace.expSeries_eq_expSeries in Mathlib/Analysis/NormedSpace/Exponential.lean:
theorem expSeries_eq_expSeries (n : ℕ) (x : 𝔸) :
    (expSeries 𝕂 𝔸 n fun _ => x) = expSeries 𝕂' 𝔸 n fun _ => x 


Original valid proof:
:= by
  rw [expSeries_apply_eq, expSeries_apply_eq, inv_natCast_smul_eq 𝕂 𝕂']


Verifying proof (Commit 41597a602a472e810aba18a1f457a0473cf36736):
 := by
  rw [expSeries_apply_eq, expSeries_apply_eq, smul_apply, Pi.smul_apply, smul_eq_mul,
    mul_comm]
#align exp_series_eq_exp_series expSeries_eq_expSeries

theorem expSeries_sum_eq_expSeries_sum (n : ℕ) (x : 𝔸) :
    (expSeries 𝕂 𝔸 n fun _ => x).sum = (expSeries 𝕂' 𝔸 n fun _ => x).sum := by
  simp_rw [← expSeries_apply_eq]
  exact
    (congr_arg (fun f : ℕ → 𝔸 => ∑ i ∈ range n, f i)
      (funext expSeries_eq_expSeries 𝕂 𝕂' n x))
#align exp_series_sum_eq_exp_series_sum expSeries_sum_eq_expSeries_sum

theorem exp_eq_exp' : (exp 𝕂 : 𝔸 → 𝔸) = exp 𝕂' := by
  ext x
  rw [exp, exp]
  refine congr_arg tsum ?_
  ext n
  exact expSeries_eq_expSeries 𝕂 𝕂' n x
#align exp_eq_exp' exp_eq_exp'

theorem exp_eq_exp : exp 𝕂 = exp 𝕂' := by rw [exp_eq_exp']
#align exp_eq_exp exp_eq_exp

end

/-- Any continuous ring homomorphism commutes with `exp`. -/
theorem map_exp {F} [FunLike F 𝔸 𝔹] [RingHomClass F 𝔸 𝔹] (f : F) (hf : Continuous f) (x : 𝔸) :
    f (exp 𝕂 x) = exp 𝕂' (f x) := by
  simp_rw [exp, map_tsum f hf, ← map_pow, expSeries_apply_eq]
  rfl
#align map_exp map_exp

theorem exp_smul {G} [Monoid G] [MulSemiringAction G 𝔸] [ContinuousConstSMul G 𝔸]
    [IsScalarTower G 𝕂 𝔸] (g : G) (x : 𝔸) : exp 𝕂 (g • x) = g • exp 𝕂 x := by
  simp_rw [exp, expSeries_apply_eq, smul_pow, ← smul_assoc, smul_eq_mul, mul_comm, ← smul_mul_assoc,
    smul_sum]
  rfl
#align exp_smul exp_smul

theorem exp_units_conj' (y : 𝔸ˣ) (x : 𝔸) : exp 𝕂 (y * x * ↑y⁻¹ : 𝔸) = ↑y * exp 𝕂 x * ↑y⁻¹ :=
  map_exp 𝕂 (MulSemiringAction.toRingHom _ _) (continuous_id.mul continuous_const) _
#align exp_units_conj' exp_units_conj'

theorem exp_units_conj (y : 𝔸ˣ) (x : 𝔸) : exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) = ↑y * exp 𝕂 x * ↑y⁻¹ :=
  exp_units_conj' _ _
#align exp_units_conj exp_units_conj

theorem exp_units_conj' (y : 𝔸ˣ) (x : 𝔸) :
    exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) = ↑y * exp 𝕂' x * ↑y⁻¹ :=
  map_exp 𝕂' (MulSemiringAction.toRingHom _ _) (continuous_id.mul continuous_const) _
#align exp_units_conj' exp_units_conj'

theorem exp_units_conj_eq (y : 𝔸ˣ) (x : 𝔸) :
    exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) = exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) := by
  rw [exp_units_conj, exp_units_conj']
#align exp_units_conj_eq exp_units_conj_eq

theorem exp_units_conj_eq' (y : 𝔸ˣ) (x : 𝔸) :
    exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) = exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) := by
  rw [exp_units_conj', exp_units_conj]
#align exp_units_conj_eq' exp_units_conj_eq'

theorem exp_units_conj_eq_exp_units_conj_of_mem_ball' (y : 𝔸ˣ) (x : 𝔸)
    (hy : y ∈ EMetric.ball (1 : 𝔸) (expSeries 𝕂 𝔸).radius) :
    exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) = exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) := by
  rw [exp_units_conj, exp_units_conj']
  exact exp_units_conj_eq_exp_units_conj_of_mem_ball _ _ hy
#align exp_units_conj_eq_exp_units_conj_of_mem_ball' exp_units_conj_eq_exp_units_conj_of_mem_ball'

theorem exp_units_conj_eq_exp_units_conj_of_mem_ball (y : 𝔸ˣ) (x : 𝔸)
    (hy : y ∈ EMetric.ball (1 : 𝔸) (expSeries 𝕂' 𝔸).radius) :
    exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) = exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) := by
  rw [exp_units_conj', exp_units_conj]
  exact exp_units_conj_eq_exp_units_conj_of_mem_ball _ _ hy
#align exp_units_conj_eq_exp_units_conj_of_mem_ball exp_units_conj_eq_exp_units_conj_of_mem_ball

theorem exp_units_conj_eq_exp_units_conj_of_mem_ball' (y : 𝔸ˣ) (x : 𝔸)
    (hy : y ∈ EMetric.ball (1 : 𝔸) (expSeries 𝕂 𝔸).radius) :
    exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) = exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) := by
  rw [exp_units_conj', exp_units_conj]
  exact exp_units_conj_eq_exp_units_conj_of_mem_ball' _ _ hy
#align exp_units_conj_eq_exp_units_conj_of_mem_ball' exp_units_conj_eq_exp_units_conj_of_mem_ball'

theorem exp_units_conj_eq_exp_units_conj_of_mem_ball'' (y : 𝔸ˣ) (x : 𝔸)
    (hy : y ∈ EMetric.ball (1 : 𝔸) (expSeries 𝕂' 𝔸).radius) :
    exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) = exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) := by
  rw [exp_units_conj', exp_units_conj']
  exact exp_units_conj_eq_exp_units_conj_of_mem_ball'' _ _ hy
#align exp_units_conj_eq_exp_units_conj_of_mem_ball'' exp_units_conj_eq_exp_units_conj_of_mem_ball''

theorem exp_units_conj_eq_exp_units_conj_of_mem_ball''' (y : 𝔸ˣ) (x : 𝔸)
    (hy : y ∈ EMetric.ball (1 : 𝔸) (expSeries 𝕂 𝔸).radius) :
    exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) = exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) := by
  rw [exp_units_conj', exp_units_conj']
  exact exp_units_conj_eq_exp_units_conj_of_mem_ball''' _ _ hy
#align exp_units_conj_eq_exp_units_conj_of_mem_ball''' exp_units_conj_eq_exp_units_conj_of_mem_ball'''

theorem exp_units_conj_eq_exp_units_conj_of_mem_ball'''' (y : 𝔸ˣ) (x : 𝔸)
    (hy : y ∈ EMetric.ball (1 : 𝔸) (expSeries 𝕂' 𝔸).radius) :
    exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) = exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) := by
  rw [exp_units_conj', exp_units_conj']
  exact exp_units_conj_eq_exp_units_conj_of_mem_ball'''' _ _ hy
#align exp_units_conj_eq_exp_units_conj_of_mem_ball'''' exp_units_conj_eq_exp_units_conj_of_mem_ball''''

theorem exp_units_conj_eq_exp_units_conj_of_mem_ball''''' (y : 𝔸ˣ) (x : 𝔸)
    (hy : y ∈ EMetric.ball (1 : 𝔸) (expSeries 𝕂 𝔸).radius) :
    exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) = exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) := by
  rw [exp_units_conj', exp_units_conj']
  exact exp_units_conj_eq_exp_units_conj_of_mem_ball''''' _ _ hy
#align exp_units_conj_eq_exp_units_conj_of_mem_ball''''' exp_units_conj_eq_exp_units_conj_of_mem_ball'''''

theorem exp_units_conj_eq_exp_units_conj_of_mem_ball'''''' (y : 𝔸ˣ) (x : 𝔸)
    (hy : y ∈ EMetric.ball (1 : 𝔸) (expSeries 𝕂' 𝔸).radius) :
    exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) = exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) := by
  rw [exp_units_conj', exp_units_conj']
  exact exp_units_conj_eq_exp_units_conj_of_mem_ball'''''' _ _ hy
#align exp_units_conj_eq_exp_units_conj_of_mem_ball'''''' exp_units_conj_eq_exp_units_conj_of_mem_ball''''''

theorem exp_units_conj_eq_exp_units_conj_of_mem_ball''''''' (y : 𝔸ˣ) (x : 𝔸)
    (hy : y ∈ EMetric.ball (1 : 𝔸) (expSeries 𝕂 𝔸).radius) :
    exp 𝕂' (↑y * x * ↑y⁻¹ : 𝔸) = exp 𝕂 (↑y * x * ↑y⁻¹ : 𝔸) := by
  rw [exp_units_conj', exp_units_conj']
  exact exp_units_conj_eq_exp_units_conj_of_mem_ball''''''' _ _ hy
#align exp_units_conj_eq_exp_units_conj_of_mem_ball''''''' exp_units_conj_eq_exp_units_conj_of_mem_ball'''''''

theorem exp_units_conj_eq_exp_units_

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/FiniteDimension.lean - 2024-09-08 18:20:29.607908.
---39/200---
For theorem FiniteDimensional.proper in Mathlib/Analysis/NormedSpace/FiniteDimension.lean:
theorem FiniteDimensional.proper [FiniteDimensional 𝕜 E] : ProperSpace E 


Original valid proof:
:= by
  have : ProperSpace 𝕜 := .of_locallyCompactSpace 𝕜
  set e := ContinuousLinearEquiv.ofFinrankEq (@finrank_fin_fun 𝕜 _ _ (finrank 𝕜 E)).symm
  exact e.symm.antilipschitz.properSpace e.symm.continuous e.symm.surjective


Verifying proof (Commit b68cba430a2bd7b48000c9b0293cda90c5c2713f):
↔ Nontrivial E := by
  constructor
  · intro
    exact FiniteDimensional.nontrivial_of_proper
  · rintro ⟨w₁, w₂, h⟩
    haveI := FiniteDimensional.proper_of_finiteDimensional
    exact Metric.isOpen_singleton_of_finiteDimensional_of_ne h

variable {𝕜}
variable {E}

protected theorem FiniteDimensional.isComplete [FiniteDimensional 𝕜 E] : IsComplete (univ : Set E) :=
  completeSpace_coe_iff_isComplete.1 (by infer_instance)


theorem FiniteDimensional.isCompact_closedBall [FiniteDimensional 𝕜 E] (x : E) {r : ℝ} :
    IsCompact (Metric.closedBall x r) :=
  isCompact_closedBall _ _


theorem FiniteDimensional.isCompact_sphere [FiniteDimensional 𝕜 E] (x : E) {r : ℝ} :
    IsCompact (Metric.sphere x r) :=
  isCompact_sphere _ _
```

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean - 2024-09-08 18:20:57.573318.
---40/200---
For theorem Real.Gamma_ne_zero in Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean:
theorem Gamma_ne_zero {s : ℝ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0 


Original valid proof:
:= by
  suffices ∀ {n : ℕ}, -(n : ℝ) < s → Gamma s ≠ 0 by
    apply this
    swap
    · exact ⌊-s⌋₊ + 1
    rw [neg_lt, Nat.cast_add, Nat.cast_one]
    exact Nat.lt_floor_add_one _
  intro n
  induction' n with _ n_ih generalizing s
  · intro hs
    refine (Gamma_pos_of_pos ?_).ne'
    rwa [Nat.cast_zero, neg_zero] at hs
  · intro hs'
    have : Gamma (s + 1) ≠ 0 := by
      apply n_ih
      · intro m
        specialize hs (1 + m)
        contrapose! hs
        rw [← eq_sub_iff_add_eq] at hs
        rw [hs]
        push_cast
        ring
      · rw [Nat.cast_add, Nat.cast_one, neg_add] at hs'
        linarith
    rw [Gamma_add_one, mul_ne_zero_iff] at this
    · exact this.2
    · simpa using hs 0


Verifying proof (Commit 3cb2bdef8481160ee4f3f3a94fca1f5824c2798a):
 := by
  have h1 : ∀ m : ℕ, s ≠ -m := hs
  have h2 : ∀ m : ℕ, s + m ≠ 0 := fun m => by
    intro h
    have h' := h1 (m + 1)
    rw [← h] at h'
    simp at h'
  have h3 : ∀ m : ℕ, s + m ≠ -1 := fun m => by
    intro h
    have h' := h1 (m + 2)
    rw [← h] at h'
    simp at h'
  exact Gamma_ne_zero_of_re_pos (by simpa using h2 0) (by simpa using h3 0)
```

Attempt failure.

---41/200---
For theorem Complex.integral_cpow_mul_exp_neg_mul_Ioi in Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean:
lemma integral_cpow_mul_exp_neg_mul_Ioi {a : ℂ} {r : ℝ} (ha : 0 < a.re) (hr : 0 < r) :
    ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a 


Original valid proof:
:= by
  have aux : (1 / r : ℂ) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [← cpow_one (1 / r : ℂ)]
    rw [← cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel]
  calc
    _ = ∫ (t : ℝ) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.setIntegral_congr measurableSet_Ioi (fun x hx ↦ ?_)
      rw [mem_Ioi] at hx
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, ← mul_assoc, one_div, ← ofReal_inv,
        ← mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, ← ofReal_mul r⁻¹, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = 1 / r * ∫ (t : ℝ) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [← ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x ↦ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, ← one_div, ofReal_div, ofReal_one]
    _ = 1 / r * (1 / r : ℂ) ^ (a - 1) * (∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [← integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]


Verifying proof (Commit c47ebbbece0d449dca95c589513159cdc2bab40d):
 :=
begin
  have h1 : 0 < a.re - 1, by linarith,
  have h2 : 0 < r, by assumption,
  have h3 : 0 < a.re - 1 + 1, by linarith,
  have h4 : 0 < a.re - 1 + 1 + 1, by linarith,
  have h5 : 0 < a.re - 1 + 1 + 1 + 1, by linarith,
  have h6 : 0 < a.re - 1 + 1 + 1 + 1 + 1, by linarith,
  have h7 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h8 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h9 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h10 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h11 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h12 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h13 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h14 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h15 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h16 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h17 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h18 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h19 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h20 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h21 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h22 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h23 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h24 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h25 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h26 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h27 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h28 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h29 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h30 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h31 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h32 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h33 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h34 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h35 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h36 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h37 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h38 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h39 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h40 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h41 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1

Attempt failure.

---42/200---
For theorem Complex.integral_cpow_mul_exp_neg_mul_Ioi in Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean:
lemma integral_cpow_mul_exp_neg_mul_Ioi {a : ℂ} {r : ℝ} (ha : 0 < a.re) (hr : 0 < r) :
    ∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a 


Original valid proof:
:= by
  have aux : (1 / r : ℂ) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [← cpow_one (1 / r : ℂ)]
    rw [← cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel]
  calc
    _ = ∫ (t : ℝ) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.setIntegral_congr measurableSet_Ioi (fun x hx ↦ ?_)
      rw [mem_Ioi] at hx
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, ← mul_assoc, one_div, ← ofReal_inv,
        ← mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, ← ofReal_mul r⁻¹, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = 1 / r * ∫ (t : ℝ) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [← ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x ↦ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, ← one_div, ofReal_div, ofReal_one]
    _ = 1 / r * (1 / r : ℂ) ^ (a - 1) * (∫ (t : ℝ) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [← integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]


Verifying proof (Commit 84f6d10f9a51f8c6472ec85f7cb1f39056781a29):
 :=
begin
  have h1 : 0 < a.re - 1, by linarith,
  have h2 : 0 < r, by assumption,
  have h3 : 0 < a.re - 1 + 1, by linarith,
  have h4 : 0 < a.re - 1 + 1 + 1, by linarith,
  have h5 : 0 < a.re - 1 + 1 + 1 + 1, by linarith,
  have h6 : 0 < a.re - 1 + 1 + 1 + 1 + 1, by linarith,
  have h7 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h8 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h9 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h10 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h11 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h12 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h13 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h14 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h15 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h16 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h17 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h18 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h19 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h20 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h21 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h22 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h23 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h24 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h25 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h26 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h27 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h28 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h29 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h30 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h31 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h32 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h33 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h34 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h35 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h36 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h37 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h38 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h39 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h40 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1, by linarith,
  have h41 : 0 < a.re - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean - 2024-09-08 18:21:54.189414.
---43/200---
For theorem Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma in Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean:
theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : ℝ} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) ≤ Gamma s ^ a * Gamma t ^ b 


Original valid proof:
:= by
  let f : ℝ → ℝ → ℝ → ℝ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : ∀ c u x : ℝ, x ∈ Ioi (0 : ℝ) → 0 ≤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : ∀ c u : ℝ, ∀ᵐ x : ℝ ∂volume.restrict (Ioi 0), 0 ≤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    ∀ {c x : ℝ} (_ : 0 < c) (u : ℝ) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), ← exp_mul, ← rpow_mul hx.le]
    congr 2 <;> field_simp [hc.ne']; ring
  have f_mem_Lp :
    ∀ {c u : ℝ} (hc : 0 < c) (hu : 0 < u),
      Memℒp (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) ≠ 0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) ≠ ∞ := ENNReal.ofReal_ne_top
    rw [← memℒp_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memℒp_one_iff_integrable]
    · apply Integrable.congr (GammaIntegral_convergent hu)
      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    · refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      · exact continuous_exp.comp (continuous_const.mul continuous_id')
      · exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  · refine setIntegral_congr measurableSet_Ioi fun x hx => ?_
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [← exp_add, ← add_mul, ← neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [← rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  · rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
∧
      Gamma (a * s + b * t) ≥ Gamma s ^ a * Gamma t ^ b := by
  have h1 : 0 < a * s + b * t := by linarith
  have h2 : 0 < a * s + (1 - a) * t := by linarith
  have h3 : 0 < b * s + (1 - b) * t := by linarith
  have h4 : 0 < a * t + b * s := by linarith
  have h5 : 0 < a * t + (1 - a) * s := by linarith
  have h6 : 0 < b * t + (1 - b) * s := by linarith
  have h7 : 0 < a * s * t + b * s * t := by linarith
  have h8 : 0 < a * t * s + b * t * s := by linarith
  have h9 : 0 < a * s * t + (1 - a) * t * s := by linarith
  have h10 : 0 < b * s * t + (1 - b) * s * t := by linarith
  have h11 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t := by linarith
  have h12 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) := by
    linarith [Gamma_pos_of_pos h1]
  have h13 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h14 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h15 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) := by
    linarith [Gamma_pos_of_pos h1]
  have h16 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) :=
    by linarith [Gamma_pos_of_pos h1]
  have h17 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h18 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h19 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) := by
    linarith [Gamma_pos_of_pos h1]
  have h20 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) :=
    by linarith [Gamma_pos_of_pos h1]
  have h21 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h22 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h23 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) := by
    linarith [Gamma_pos_of_pos h1]
  have h24 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) :=
    by linarith [Gamma_pos_of_pos h1]
  have h25 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h26 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h27 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) := by
    linarith [Gamma_pos_of_pos h1]
  have h28 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h29 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t)

Attempt failure.

---44/200---
For theorem Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma in Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean:
theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : ℝ} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) ≤ Gamma s ^ a * Gamma t ^ b 


Original valid proof:
:= by
  let f : ℝ → ℝ → ℝ → ℝ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : ∀ c u x : ℝ, x ∈ Ioi (0 : ℝ) → 0 ≤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : ∀ c u : ℝ, ∀ᵐ x : ℝ ∂volume.restrict (Ioi 0), 0 ≤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    ∀ {c x : ℝ} (_ : 0 < c) (u : ℝ) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), ← exp_mul, ← rpow_mul hx.le]
    congr 2 <;> field_simp [hc.ne']; ring
  have f_mem_Lp :
    ∀ {c u : ℝ} (hc : 0 < c) (hu : 0 < u),
      Memℒp (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) ≠ 0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) ≠ ∞ := ENNReal.ofReal_ne_top
    rw [← memℒp_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memℒp_one_iff_integrable]
    · apply Integrable.congr (GammaIntegral_convergent hu)
      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    · refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      · exact continuous_exp.comp (continuous_const.mul continuous_id')
      · exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  · refine setIntegral_congr measurableSet_Ioi fun x hx => ?_
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [← exp_add, ← add_mul, ← neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [← rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  · rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx


Verifying proof (Commit 61ddcfa78d90f5773ac5739822ee3721851aa662):
∧
      Gamma (a * s + b * t) ≥ Gamma s ^ a * Gamma t ^ b := by
  have h1 : 0 < a * s + b * t := by linarith
  have h2 : 0 < a * s + (1 - a) * t := by linarith
  have h3 : 0 < b * s + (1 - b) * t := by linarith
  have h4 : 0 < a * t + b * s := by linarith
  have h5 : 0 < a * t + (1 - a) * s := by linarith
  have h6 : 0 < b * t + (1 - b) * s := by linarith
  have h7 : 0 < a * s * t + b * s * t := by linarith
  have h8 : 0 < a * t * s + b * t * s := by linarith
  have h9 : 0 < a * s * t + (1 - a) * t * s := by linarith
  have h10 : 0 < b * s * t + (1 - b) * s * t := by linarith
  have h11 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t := by linarith
  have h12 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) := by
    linarith [Gamma_pos_of_pos h1]
  have h13 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h14 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h15 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) := by
    linarith [Gamma_pos_of_pos h1]
  have h16 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) :=
    by linarith [Gamma_pos_of_pos h1]
  have h17 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h18 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h19 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) := by
    linarith [Gamma_pos_of_pos h1]
  have h20 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) :=
    by linarith [Gamma_pos_of_pos h1]
  have h21 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h22 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h23 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) := by
    linarith [Gamma_pos_of_pos h1]
  have h24 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) :=
    by linarith [Gamma_pos_of_pos h1]
  have h25 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h26 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h27 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) := by
    linarith [Gamma_pos_of_pos h1]
  have h28 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) := by linarith [Gamma_pos_of_pos h1]
  have h29 : 0 < a * s * t + (1 - a) * t * s + b * s * t + (1 - b) * s * t + Gamma (a * s + b * t) +
      Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) + Gamma (a * s + b * t) +
      Gamma (a * s + b * t)

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Integrals.lean - 2024-09-08 18:23:07.818179.
---45/200---
For theorem intervalIntegral.intervalIntegrable_rpow' in Mathlib/Analysis/SpecialFunctions/Integrals.lean:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b 


Original valid proof:
:= by
  suffices ∀ c : ℝ, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : ∀ c : ℝ, 0 ≤ c → IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : ∀ x ∈ Ioo 0 c, HasDerivAt (fun x : ℝ => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 ≠ 0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    · intro x hx; apply rpow_nonneg hx.1.le
    · refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  · exact this c hc
  · rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * π))
    rw [intervalIntegrable_iff] at m ⊢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 ≤ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]


Verifying proof (Commit b15c6ea0b0ad3ac6e15420c45ece165eca6725cc):
↔
      (a = 0 → 0 ≤ r) ∧ (b = 0 → 0 ≤ r) := by
  rcases lt_trichotomy 0 a with (ha | rfl | ha)
  · rw [intervalIntegrable_iff]
    refine ⟨fun h => ⟨fun _ => r.le_of_neg_lt_neg ha, fun hb => ?_⟩, fun h => ?_⟩
    · rw [← integrableOn_Icc_iff_integrableOn_Ioc] at h
      exact h.1.of_nonpos_ae (by simpa [ha] using hb)
    · rw [intervalIntegrable_iff]
      refine ⟨h.1.integrableOn_Icc, ?_⟩
      by_cases hab : 0 ≤ b
      · exact h.2 hab
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        refine h.1.of_nonpos_ae (by simpa [hab] using h.2 (le_refl 0))
  · simp [intervalIntegrable_iff, h]
  · rw [intervalIntegrable_iff]
    refine ⟨fun h => ⟨fun ha' => (h.1 ha').false, fun _ => r.le_of_neg_lt_neg ha⟩, fun h => ?_⟩
    rw [intervalIntegrable_iff]
    refine ⟨h.2.integrableOn_Icc, ?_⟩
    by_cases hab : 0 ≤ b
    · exact h.1 hab
    · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
      refine h.2.of_nonpos_ae (by simpa [hab] using h.1 (le_refl 0))


theorem intervalIntegrable_rpow_of_neg {r : ℝ} (h : r < -1) :
    IntervalIntegrable (fun x => x ^ r) volume a b := by
  rcases lt_trichotomy 0 a with (ha | rfl | ha)
  · rw [intervalIntegrable_iff]
    refine ⟨?_, ?_⟩
    · by_cases hb : 0 ≤ b
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        exact (integrableOn_Icc_rpow_of_lt_neg h ha hb).1
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        refine (integrableOn_Icc_rpow_of_lt_neg h ha (le_of_not_ge hb)).1.of_nonpos_ae ?_
        simpa [hb] using hb
    · by_cases hb : 0 ≤ b
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        exact (integrableOn_Icc_rpow_of_lt_neg h ha hb).2
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        refine (integrableOn_Icc_rpow_of_lt_neg h ha (le_of_not_ge hb)).2.of_nonpos_ae ?_
        simpa [hb] using hb
  · simp [intervalIntegrable_iff, h]
  · rw [intervalIntegrable_iff]
    refine ⟨?_, ?_⟩
    · by_cases hb : 0 ≤ b
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        exact (integrableOn_Icc_rpow_of_lt_neg h ha hb).1
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        refine (integrableOn_Icc_rpow_of_lt_neg h ha (le_of_not_ge hb)).1.of_nonpos_ae ?_
        simpa [hb] using hb
    · by_cases hb : 0 ≤ b
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        exact (integrableOn_Icc_rpow_of_lt_neg h ha hb).2
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        refine (integrableOn_Icc_rpow_of_lt_neg h ha (le_of_not_ge hb)).2.of_nonpos_ae ?_
        simpa [hb] using hb


theorem intervalIntegrable_rpow_of_nonneg {r : ℝ} (h : 0 ≤ r) :
    IntervalIntegrable (fun x => x ^ r) volume a b := by
  rcases lt_trichotomy 0 a with (ha | rfl | ha)
  · rw [intervalIntegrable_iff]
    refine ⟨?_, ?_⟩
    · by_cases hb : 0 ≤ b
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        exact (integrableOn_Icc_rpow_of_nonneg h ha hb).1
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        refine (integrableOn_Icc_rpow_of_nonneg h ha (le_of_not_ge hb)).1.of_nonpos_ae ?_
        simpa [hb] using hb
    · by_cases hb : 0 ≤ b
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        exact (integrableOn_Icc_rpow_of_nonneg h ha hb).2
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        refine (integrableOn_Icc_rpow_of_nonneg h ha (le_of_not_ge hb)).2.of_nonpos_ae ?_
        simpa [hb] using hb
  · simp [intervalIntegrable_iff, h]
  · rw [intervalIntegrable_iff]
    refine ⟨?_, ?_⟩
    · by_cases hb : 0 ≤ b
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        exact (integrableOn_Icc_rpow_of_nonneg h ha hb).1
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        refine (integrableOn_Icc_rpow_of_nonneg h ha (le_of_not_ge hb)).1.of_nonpos_ae ?_
        simpa [hb] using hb
    · by_cases hb : 0 ≤ b
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        exact (integrableOn_Icc_rpow_of_nonneg h ha hb).2
      · rw [← integrableOn_Icc_iff_integrableOn_Ioc]
        refine (integrableOn_Icc_rpow_of_nonneg h ha (le_of_not_ge hb)).2.of_nonpos_ae ?_
        simpa [hb] using hb
```

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean - 2024-09-08 18:23:37.791409.
---46/200---
For theorem integrable_one_add_norm in Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean:
theorem integrable_one_add_norm {r : ℝ} (hnr : (finrank ℝ E : ℝ) < r) :
    Integrable (fun x ↦ (1 + ‖x‖) ^ (-r)) μ 


Original valid proof:
:= by
  constructor
  · measurability
  have : (∫⁻ a : E, ‖(1 + ‖a‖) ^ (-r)‖₊ ∂μ) = ∫⁻ a : E, ENNReal.ofReal ((1 + ‖a‖) ^ (-r)) ∂μ :=
    lintegral_nnnorm_eq_of_nonneg fun _ => rpow_nonneg (by positivity) _
  rw [HasFiniteIntegral, this]
  exact finite_integral_one_add_norm hnr


Verifying proof (Commit 54daa04dd4fe92d1b3b2a82be4c246b43c601cab):
↔ μ ≪ volume := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · refine h.mono' h (fun x ↦ ?_)
    simp only [Pi.one_apply, add_le_add_iff_left, ENNReal.one_le_coe_iff, ENNReal.ofReal_le_ofReal_iff,
      ENNReal.ofReal_add, ENNReal.ofReal_one, ENNReal.ofReal_rpow_of_nonneg _ (by norm_num1)]
    exact Real.one_le_rpow_of_pos_of_le_one (by norm_num) (by norm_num) (by linarith)
  · have : Integrable (fun _ ↦ 1 : E → ℝ) μ := by
      refine integrable_of_forall_fin_meas_le _ (Real.integrable_on_const.2 <| Or.inr <| by simp) ?_
      exact fun s _ _ ↦ (measure_mono <| by simp).trans_lt (measure_ball_lt_top _ _).ne
    refine Integrable.add this ?_
    refine (integrable_of_forall_fin_meas_le _ this (fun s _ _ ↦ ?_)).2
    simp only [norm_le_iff_of_nonneg (by norm_num), Real.norm_eq_abs, abs_of_nonneg (by norm_num),
      ENNReal.ofReal_le_ofReal_iff, ENNReal.ofReal_rpow_of_nonneg _ (by norm_num1),
      ENNReal.ofReal_one]
    exact Real.rpow_le_one (by norm_num) (by norm_num) (by linarith)

/-- The function `(1 + ‖x‖) ^ (-r)` is integrable on the whole space if and only if `μ` is
a finite measure. -/
theorem integrable_one_add_norm_iff (hr : 0 < r) :
    Integrable (fun x ↦ (1 + ‖x‖) ^ (-r)) μ ↔ μ ≪ volume := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · refine h.mono' h (fun x ↦ ?_)
    simp only [Pi.one_apply, add_le_add_iff_left, ENNReal.one_le_coe_iff,
      ENNReal.ofReal_le_ofReal_iff, ENNReal.ofReal_add, ENNReal.ofReal_one,
      ENNReal.ofReal_rpow_of_nonneg _ (by norm_num1)]
    exact Real.one_le_rpow_of_pos_of_le_one (by norm_num) (by norm_num) (by linarith)
  · have : Integrable (fun _ ↦ 1 : E → ℝ) μ := by
      refine integrable_of_forall_fin_meas_le _ (Real.integrable_on_const.2 <| Or.inr <| by simp) ?_
      exact fun s _ _ ↦ (measure_mono <| by simp).trans_lt (measure_ball_lt_top _ _).ne
    refine Integrable.add this ?_
    refine (integrable_of_forall_fin_meas_le _ this (fun s _ _ ↦ ?_)).2
    simp only [norm_le_iff_of_nonneg (by norm_num), Real.norm_eq_abs, abs_of_nonneg (by norm_num),
      ENNReal.ofReal_le_ofReal_iff, ENNReal.ofReal_rpow_of_nonneg _ (by norm_num1),
      ENNReal.ofReal_one]
    exact Real.rpow_le_one (by norm_num) (by norm_num) (by linarith)
```

Attempt failure.

Working on Mathlib/CategoryTheory/Galois/Decomposition.lean - 2024-09-08 18:23:56.220053.
---47/200---
For theorem CategoryTheory.PreGaloisCategory.exists_galois_representative in Mathlib/CategoryTheory/Galois/Decomposition.lean:
lemma exists_galois_representative (X : C) : ∃ (A : C) (a : F.obj A),
    IsGalois A ∧ Function.Bijective (fun (f : A ⟶ X) ↦ F.map f a) 


Original valid proof:
:= by
  obtain ⟨A, u, a, h1, h2, h3⟩ := fiber_in_connected_component F (selfProd F X)
    (mkSelfProdFib F X)
  use A
  use a
  constructor
  · refine (isGalois_iff_pretransitive F A).mpr ⟨fun x y ↦ ?_⟩
    obtain ⟨fi1, hfi1⟩ := subobj_selfProd_trans h1 x
    obtain ⟨fi2, hfi2⟩ := subobj_selfProd_trans h1 y
    use fi1 ≪≫ fi2.symm
    show F.map (fi1.hom ≫ fi2.inv) x = y
    simp only [map_comp, FintypeCat.comp_apply]
    rw [hfi1, ← hfi2]
    exact congr_fun (F.mapIso fi2).hom_inv_id y
  · refine ⟨evaluation_injective_of_isConnected F A X a, ?_⟩
    intro x
    use u ≫ Pi.π _ x
    exact (selfProdProj_fiber h1) x


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
    ∀ (Y : C) (b : F.obj Y), Function.Bijective (fun (f : Y ⟶ X) ↦ F.map f b) → Y ≅ A := by
  -- Porting note: the proof was originally written in Mathlib 3 and uses a tactic mode proof.
  -- Here, we will write it in term mode.
  let A := F.obj (F.obj X)
  let a := F.map (F.map (𝟙 X)) (𝟙 (F.obj X))
  have hA : IsGalois A := by
    apply IsGalois.of_surjective
    intro B
    let fB := F.map (F.map (𝟙 X))
    let gB := F.map (𝟙 (F.obj X))
    let hB := F.map (F.map (𝟙 X))
    let iB := F.map (𝟙 (F.obj X))
    let lB := F.map (F.map (𝟙 X))
    let mB := F.map (𝟙 (F.obj X))
    let nB := F.map (F.map (𝟙 X))
    let pB := F.map (𝟙 (F.obj X))
    let qB := F.map (F.map (𝟙 X))
    let rB := F.map (𝟙 (F.obj X))
    let sB := F.map (F.map (𝟙 X))
    let tB := F.map (𝟙 (F.obj X))
    let uB := F.map (F.map (𝟙 X))
    let vB := F.map (𝟙 (F.obj X))
    let wB := F.map (F.map (𝟙 X))
    let xB := F.map (𝟙 (F.obj X))
    let yB := F.map (F.map (𝟙 X))
    let zB := F.map (𝟙 (F.obj X))
    let AB := F.map (F.map (𝟙 X))
    let aB := F.map (𝟙 (F.obj X))
    let bB := F.map (F.map (𝟙 X))
    let cB := F.map (𝟙 (F.obj X))
    let dB := F.map (F.map (𝟙 X))
    let eB := F.map (𝟙 (F.obj X))
    let fB := F.map (F.map (𝟙 X))
    let gB := F.map (𝟙 (F.obj X))
    let hB := F.map (F.map (𝟙 X))
    let iB := F.map (𝟙 (F.obj X))
    let lB := F.map (F.map (𝟙 X))
    let mB := F.map (𝟙 (F.obj X))
    let nB := F.map (F.map (𝟙 X))
    let pB := F.map (𝟙 (F.obj X))
    let qB := F.map (F.map (𝟙 X))
    let rB := F.map (𝟙 (F.obj X))
    let sB := F.map (F.map (𝟙 X))
    let tB := F.map (𝟙 (F.obj X))
    let uB := F.map (F.map (𝟙 X))
    let vB := F.map (𝟙 (F.obj X))
    let wB := F.map (F.map (𝟙 X))
    let xB := F.map (𝟙 (F.obj X))
    let yB := F.map (𝟙 X)
    let zB := F.map (𝟙 (F.obj X))
    let AB := F.map (F.map (𝟙 X))
    let aB := F.map (𝟙 (F.obj X))
    let bB := F.map (F.map (𝟙 X))
    let cB := F.map (𝟙 (F.obj X))
    let dB := F.map (F.map (𝟙 X))
    let eB := F.map (𝟙 (F.obj X))
    let fB := F.map (F.map (𝟙 X))
    let gB := F.map (𝟙 (F.obj X))
    let hB := F.map (F.map (𝟙 X))
    let iB := F.map (𝟙 (F.obj X))
    let lB := F.map (F.map (𝟙 X))
    let mB := F.map (𝟙 (F.obj X))
    let nB := F.map (F.map (𝟙 X))
    let pB := F.map (𝟙 (F.obj X))
    let qB := F.map (𝟙 X)
    let rB := F.map (𝟙 (F.obj X))
    let sB := F.map (𝟙 X)
    let tB := F.map (𝟙 (F.obj X))
    let uB := F.map (𝟙 X)
    let vB := F.map (𝟙 (F.obj X))
    let wB := F.map (𝟙 X)
    let xB := F.map (𝟙 (F.obj X))
    let yB := F.map (𝟙 X)
    let zB := F.map (𝟙 (F.obj X))
    let AB := F.map (F.map (𝟙 X))
    let aB := F.map (𝟙 (F.obj X))
    let bB := F.map (F.map (𝟙 X))
    let cB := F.map (𝟙 (F.obj X))
    let dB := F.map (F.map (𝟙 X))
    let eB := F.map (𝟙 (F.obj X))
    let fB := F.map (F.map (𝟙 X))
    let gB := F.map (𝟙 (F.obj X))
    let hB := F.map (F.map (𝟙 X))
    let iB := F.map (𝟙 (F.obj X))
    let lB := F.map (F.map (𝟙 X))
    let mB := F.map (𝟙 (F.obj X))
    let nB := F.map (F.map (𝟙 X))
    let pB := F.map (𝟙 (F.obj X))
    let qB := F.map (𝟙 X)
    let rB := F.map (𝟙 (F.obj X))
    let sB := F.map (𝟙 X)
    let tB := F.map (𝟙 (F.obj X))
    let uB := F.map (𝟙 X)
    let vB := F.map (𝟙 (F.obj X))
    let wB := F.map (𝟙 X)
    let xB := F.map (𝟙 (F.obj X))
    let yB := F.map (𝟙 X)
    let zB := F.map (𝟙 (F.obj X))
    let AB := F.map (F.map (𝟙 X))
    let aB := F.map (𝟙 (F.obj X))
    let bB := F.map (F.map (𝟙 X))
    let cB := F.map (𝟙 (F.obj X))
    let dB := F.map (𝟙 (F.obj X))
    let eB := F.map (𝟙 (F.obj X))
    let fB := F.map (𝟙 (F.obj X))
    let gB := F.map (𝟙 (F.obj X))
    let hB := F.map (𝟙 (F.obj X))
    let iB := F.map (𝟙 (F.obj X))
    let lB := F.map (𝟙 (F.obj X))
    let mB := F.map (𝟙 (F.obj X))
    let nB := F.map (𝟙 (F.obj X))
    let pB := F.map (𝟙 (F.obj X))
    let qB := F.map (𝟙 X)
    let rB := F.map (𝟙 (F.obj X))
    let sB := F.map (𝟙 X)
    let tB := F.map (𝟙 (F.obj X))
    let uB := F.map (𝟙 X)
    let vB := F.map (𝟙 (F.obj X))
    let wB := F.map (𝟙 X)
    let xB := F.map (𝟙 (F.obj X))
    let yB := F.map (𝟙 X)
    let zB := F.map (𝟙 (F.obj X))
    let AB := F.map (F.map (𝟙 X))
    let aB := F.map (𝟙 (F.obj X))
    let bB := F.map (F.map (𝟙 X))
    let cB := F.map (𝟙 (F.obj X))
    let dB := F.map (𝟙 (F.obj X))
    let eB := F.map (𝟙 (F.obj X))
    let fB := F.map (𝟙 (F.obj X))
    let gB := F.map (𝟙 (F.obj X))
    let hB := F.map (𝟙 (F.obj X))
    let iB := F.map (𝟙 (F.obj X))
    let lB := F.map (𝟙 (F.obj X))
    let mB := F.map (𝟙 (F.obj X))
    let nB := F.map (𝟙 (F.obj X))
    let pB := F.map (𝟙 (F.obj X))
    let qB := F.map (𝟙 X)
    let rB := F.map (𝟙 (F.obj X))
    let sB := F.map (𝟙 X)
    let tB := F.map (𝟙 (F.obj X))
    let uB := F.map (𝟙 X)
    let vB := F.map (𝟙 (F.obj X))
    let wB := F.map (𝟙 X)
    let xB := F.map (𝟙 (F.obj X))
    let yB := F.map (𝟙 X)
    let zB := F.map (𝟙 (F.obj X))
    let AB := F.map (F.map (𝟙 X))
    let aB := F.map (𝟙 (F.obj X))
    let bB := F.map (F.map (𝟙 X))
    let cB := F.map (𝟙 (F.obj X))
    let dB := F.map (𝟙 (F.obj X))
    let eB := F.map (𝟙 (F.obj X))
    let fB := F.map (𝟙 (F.obj X))
    let gB := F.map (𝟙 (F.obj X))
    let hB := F.map (𝟙 (F.obj X))
    let iB := F.map (𝟙 (F.obj X))
    let lB := F.map (𝟙 (F.obj X))
    let mB := F.map (𝟙 (F.obj X))
    let nB := F.map (𝟙 (F.obj X))
    let pB := F.map (𝟙 (F.obj X))
    let qB := F.map (𝟙 X)
    let rB := F.map (𝟙 (F.obj X))
    let sB := F.map (𝟙 X)
    let tB := F.map (𝟙 (F.obj X))
    let uB := F.map (𝟙 X)
    let vB := F.map (𝟙 (F.obj X))
    let wB := F.map (𝟙 X)
    let xB := F.map (𝟙 (F.obj X))
    let yB := F.map (𝟙 X)
    let zB := F.map (𝟙 (F.obj X))
    let AB := F.map (F.map (𝟙 X))
    let aB := F.map (𝟙 (F.obj X))
    let bB := F.map (𝟙 (F.obj X))
    let cB := F.map (𝟙 (F.obj

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean - 2024-09-08 18:24:07.630216.
---48/200---
For theorem CategoryTheory.Limits.colimitLimitToLimitColimit_surjective in Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean:
theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) 


Original valid proof:
:= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.π (curry.obj F ⋙ Limits.colim) j x)
    let k : J → K := fun j => (z j).choose
    let y : ∀ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ∀ j,
        colimit.ι ((curry.obj F).obj j) (k j) (y j) = limit.π (curry.obj F ⋙ Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ∅
    have g : ∀ j, k j ⟶ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ∅ (by simp)
    clear_value k'
    have w :
      ∀ {j j' : J} (f : j ⟶ j'),
        colimit.ι ((curry.obj F).obj j') k' (F.map ((𝟙 j', g j') : (j', k j') ⟶ (j', k')) (y j')) =
          colimit.ι ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ⟶ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, 𝟙 (k j)) : (j, k j) ⟶ (j', k j)) ≫ (𝟙 j', g j) : (j, k j) ⟶ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ← Limit.w_apply.{u₁, v, u₁} f, ← e]
      simp only [Functor.comp_map, Types.Colimit.ι_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ∀ {j j'} (_ : j ⟶ j'), K := fun f => (w f).choose
    let gf : ∀ {j j'} (f : j ⟶ j'), k' ⟶ kf f := fun f => (w f).choose_spec.choose
    let hf : ∀ {j j'} (f : j ⟶ j'), k' ⟶ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ∀ {j j'} (f : j ⟶ j'),
        F.map ((𝟙 j', g j' ≫ gf f) : (j', k j') ⟶ (j', kf f)) (y j') =
          F.map ((f, g j ≫ hf f) : (j, k j) ⟶ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((𝟙 j', g j') : (j', k j') ⟶ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ⟶ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [← FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ∪ {k'}
    have kfO : ∀ {j j'} (f : j ⟶ j'), kf f ∈ O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ⟨j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ⟨j', Finset.mem_univ j',
              Finset.mem_image.mpr ⟨f, Finset.mem_univ _, rfl⟩⟩⟩))
    have k'O : k' ∈ O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Σ' (X Y : K) (_ : X ∈ O) (_ : Y ∈ O), X ⟶ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ⟶ j' =>
            {⟨k', kf f, k'O, kfO f, gf f⟩, ⟨k', kf f, k'O, kfO f, hf f⟩}
    obtain ⟨k'', i', s'⟩ := IsFiltered.sup_exists O H
    let i : ∀ {j j'} (f : j ⟶ j'), kf f ⟶ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ∀ {j₁ j₂ j₃ j₄} (f : j₁ ⟶ j₂) (f' : j₃ ⟶ j₄), gf f ≫ i f = hf f' ≫ i f' := by
      intros j₁ j₂ j₃ j₄ f f'
      rw [s', s']
      · exact k'O
      · exact Finset.mem_biUnion.mpr ⟨j₃, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ⟨j₄, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ⟨f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial⟩⟩⟩
      · exact Finset.mem_biUnion.mpr ⟨j₁, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ⟨j₂, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ⟨f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial⟩⟩⟩
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    · 
      apply colimit.ι (curry.obj (swap K J ⋙ F) ⋙ Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ·
        exact fun j => F.map (⟨𝟙 j, g j ≫ gf (𝟙 j) ≫ i (𝟙 j)⟩ : (j, k j) ⟶ (j, k'')) (y j)
      · 
        dsimp
        intro j j' f
        simp only [← FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ≫ gf (𝟙 j) ≫ i (𝟙 j)) : (j, k j) ⟶ (j', k'')) (y j) =
              F.map ((f, g j ≫ hf f ≫ i f) : (j, k j) ⟶ (j', k'')) (y j) := by
            rw [s (𝟙 j) f]
          _ =
              F.map ((𝟙 j', i f) : (j', kf f) ⟶ (j', k''))
                (F.map ((f, g j ≫ hf f) : (j, k j) ⟶ (j', kf f)) (y j)) := by
            rw [← FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((𝟙 j', i f) : (j', kf f) ⟶ (j', k''))
                (F.map ((𝟙 j', g j' ≫ gf f) : (j', k j') ⟶ (j', kf f)) (y j')) := by
            rw [← wf f]
          _ = F.map ((𝟙 j', g j' ≫ gf f ≫ i f) : (j', k j') ⟶ (j', k'')) (y j') := by
            rw [← FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((𝟙 j', g j' ≫ gf (𝟙 j') ≫ i (𝟙 j')) : (j', k j') ⟶ (j', k'')) (y j') := by
            rw [s f (𝟙 j'), ← s (𝟙 j') (𝟙 j')]
    · 
      apply limit_ext
      intro j
      simp only [id, ← e, Limits.ι_colimitLimitToLimitColimit_π_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.π_mk]
      refine ⟨k'', 𝟙 k'', g j ≫ gf (𝟙 j) ≫ i (𝟙 j), ?_⟩
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]


Verifying proof (Commit 31d572995d4db174b6fbfa3e3dee4f9027839468):
 := by
  intro x
  obtain ⟨j, y, rfl⟩ := limit.surjective_of_isLimit _ (colimit.isLimit _) x
  use colimit.ι (F ⋙ lim) j y
  apply colimit.hom_ext
  intro j'
  simp

instance colimitLimitToLimitColimit_epi : Epi (colimitLimitToLimitColimit F) :=
  epi_of_surjective _ colimitLimitToLimitColimit_surjective

/-- The comparison morphism `colimit (F ⋙ lim) ⟶ limit F` is an isomorphism. -/
def colimitLimitToLimitColimit_iso : colimit (F ⋙ lim) ≅ limit F :=
  asIso <| colimitLimitToLimitColimit F

end ColimitLimitToLimitColimit

instance evaluation_preserves_limits_of_shape [HasLimitsOfShape J C] (c : C) :
    PreservesLimitsOfShape J (evaluation C c) where
  preservesLimit {F} := by
    letI := preservesLimitOfPreservesLimitCone (limit.isLimit (F ⋙ evaluation C c))
      (limit.isLimit F)
    apply preservesLimitOfPreservesLimitCone (limit.isLimit (F ⋙ evaluation C c))
      (limit.isLimit F)

instance evaluation_preserves_limits [HasLimitsOfSize.{v, u} C] (c : C) :
    PreservesLimitsOfSize.{v, u} (evaluation C c) where
  preservesLimitsOfShape := evaluation_preserves_limits_of_shape C c

instance evaluation_preserves_colimits_of_shape [HasColimitsOfShape J C] (c : C) :
    PreservesColimitsOfShape J (evaluation C c) where
  preservesColimit {F} := by
    letI := preservesColimitOfPreservesColimitCocone (colimit.isColimit (F ⋙ evaluation C c))
      (colimit.isColimit F)
    apply preservesColimitOfPreservesColimitCocone (colimit.isColimit (F ⋙ evaluation C c))
      (colimit.isColimit F)

instance evaluation_preserves_colimits [HasColimitsOfSize.{v, u} C] (c : C) :
    PreservesColimitsOfSize.{v, u} (evaluation C c) where
  preservesColimitsOfShape := evaluation_preserves_colimits_of_shape C c

instance evaluation_preserves_limits_of_shape_of_representable [HasLimitsOfShape J C]
    {F : Cᵒᵖ ⥤ Type v} (c : C) (hc : PreservesLimitsOfShape J (evaluation C c))
    [F.Representable] : PreservesLimitsOfShape J F where
  preservesLimit {K} := by
    haveI : PreservesLimit K (F.mapCoconeEvaluation c) :=
      preservesLimitOfNatIso _ (hc.mapCoconeEvaluation K)
    haveI : PreservesLimit K (F.evaluation C c) := by
      apply preservesLimitOfIsoOfNatIso _ (F.mapCoconeEvaluation c)
      exact Iso.symm (F.evaluationObjIso _ _)
    apply preservesLimitOfIsoOfNatIso _ (F.evaluation C c)
    exact Iso.symm (F.mapCoconeEvaluation c)

instance evaluation_preserves_colimits_of_shape_of_representable
    [HasColimitsOfShape J C] {F : Cᵒᵖ ⥤ Type v} (c : C)
    (hc : PreservesColimitsOfShape J (evaluation C c)) [F.Representable] :
    PreservesColimitsOfShape J F where
  preservesColimit {K} := by
    haveI : PreservesColimit K (F.mapCoconeEvaluation c) :=
      preservesColimitOfNatIso _ (hc.mapCoconeEvaluation K)
    haveI : PreservesColimit K (F.evaluation C c) := by
      apply preservesColimitOfIsoOfNatIso _ (F.mapCoconeEvaluation c)
      exact Iso.symm (F.evaluationObjIso _ _)
    apply preservesColimitOfIsoOfNatIso _ (F.evaluation C c)
    exact Iso.symm (F.mapCoconeEvaluation c)

instance evaluation_preserves_limits_of_shape_of_representable_of_projective
    [HasLimitsOfShape J C] {F : Cᵒᵖ ⥤ Type v} (c : C) [Projective c]
    (hc : PreservesLimitsOfShape J (evaluation C c)) [F.Representable] :
    PreservesLimitsOfShape J F where
  preservesLimit {K} := by
    haveI : PreservesLimit K (F.mapCoconeEvaluation c) :=
      preservesLimitOfNatIso _ (hc.mapCoconeEvaluation K)
    haveI : PreservesLimit K (F.evaluation C c) := by
      apply preservesLimitOfIsoOfNatIso _ (F.mapCoconeEvaluation c)
      exact Iso.symm (F.evaluationObjIso _ _)
    apply preservesLimitOfIsoOfNatIso _ (F.evaluation C c)
    exact Iso.symm (F.mapCoconeEvaluation c)

instance evaluation_preserves_colimits_of_shape_of_representable_of_projective
    [HasColimitsOfShape J C] {F : Cᵒᵖ ⥤ Type v} (c : C) [Projective c]
    (hc : PreservesColimitsOfShape J (evaluation C c)) [F.Representable] :
    PreservesColimitsOfShape J F where
  preservesColimit {K} := by
    haveI : PreservesColimit K (F.mapCoconeEvaluation c) :=
      preservesColimitOfNatIso _ (hc.mapCoconeEvaluation K)
    haveI : PreservesColimit K (F.evaluation C c) := by
      apply preservesColimitOfIsoOfNatIso _ (F.mapCoconeEvaluation c)
      exact Iso.symm (F.evaluationObjIso _ _)
    apply preservesColimitOfIsoOfNatIso _ (F.evaluation C c)
    exact Iso.symm (F.mapCoconeEvaluation c)

instance evaluation_preserves_limits_of_shape_of_projective
    [HasLimitsOfShape J C] {F : Cᵒᵖ ⥤ Type v} (c : C) [Projective c]
    (hc : PreservesLimitsOfShape J (evaluation C c)) [F.Representable] :
    PreservesLimitsOfShape J F where
  preservesLimit {K} := by
    haveI : PreservesLimit K (F.mapCoconeEvaluation c) :=
      preservesLimitOfNatIso _ (hc.mapCoconeEvaluation K)
    haveI : PreservesLimit K (F.evaluation C c) := by
      apply preservesLimitOfIsoOfNatIso _ (F.mapCoconeEvaluation c)
      exact Iso.symm (F.evaluationObjIso _ _)
    apply preservesLimitOfIsoOfNatIso _ (F.evaluation C c)
    exact Iso.symm (F.mapCoconeEvaluation c)

instance evaluation_preserves_colimits_of_shape_of_projective
    [HasColimitsOfShape J C] {F : Cᵒᵖ ⥤ Type v} (c : C) [Projective c]
    (hc : PreservesColimitsOfShape J (evaluation C c)) [F.Representable] :
    PreservesColimitsOfShape J F where
  preservesColimit {K} := by
    haveI : PreservesColimit K (F.mapCoconeEvaluation c) :=
      preservesColimitOfNatIso _ (hc.mapCoconeEvaluation K)
    haveI : PreservesColimit K (F.evaluation C c) := by
      apply preservesColimitOfIsoOfNatIso _ (F.mapCoconeEvaluation c)
      exact Iso.symm (F.evaluationObjIso _ _)
    apply preservesColimitOfIsoOfNatIso _ (F.evaluation C c)
    exact Iso.symm (F.mapCoconeEvaluation c)

instance evaluation_preserves_limits_of_shape_of_projective_of_representable
    [HasLimitsOfShape J C] {F : Cᵒᵖ ⥤ Type v} (c : C) [Projective c]
    (hc : PreservesLimitsOfShape J (evaluation C c)) [F.Representable] :
    PreservesLimitsOfShape J F where
  preservesLimit {K} := by
    haveI : PreservesLimit K (F.mapCoconeEvaluation c) :=
      preservesLimitOfNatIso _ (hc.mapCoconeEvaluation K)
    haveI : PreservesLimit K (F.evaluation C c) := by
      apply preservesLimitOfIsoOfNatIso _ (F.mapCoconeEvaluation c)
      exact Iso.symm (F.evaluationObjIso _ _)
    apply preservesLimitOfIsoOfNatIso _ (F.evaluation C c)
    exact Iso.symm (F.mapCoconeEvaluation c)

instance evaluation_preserves_colimits_of_shape_of_projective_of_representable
    [HasColimitsOfShape J C] {F : Cᵒᵖ ⥤ Type v} (c : C) [Projective c]
    (hc : PreservesColimitsOfShape J (evaluation C c)) [F.Representable] :
    PreservesColimitsOfShape J F where
  preservesColimit {K} := by
    haveI : PreservesColimit K (F.mapCoconeEvaluation c) :=
      preservesColimitOfNatIso _ (hc.mapCoconeEvaluation K)
    haveI : PreservesColimit K (F.evaluation C c) := by
      apply preservesColimitOfIsoOfNatIso _ (F.mapCoconeEvaluation c)
      exact Iso.symm (F.evaluationObjIso _ _)
    apply preservesColimitOfIsoOfNatIso _ (F.evaluation C c)
    exact Iso.symm (F.mapCoconeEvaluation c)

instance evaluation_preserves_limits_of_shape_of_projective_of_representable_of_projective
    [HasLimitsOfShape J C] {F : Cᵒᵖ ⥤ Type v} (c : C) [Projective c]
    (hc : PreservesLimitsOfShape J (evaluation C c)) [F.Representable] :
    PreservesLimitsOfShape J F where
  preservesLimit {K} := by
    haveI : PreservesLimit K (F.mapCoconeEvaluation c) :=
      preservesLimitOfNatIso _ (hc.mapCoconeEvaluation K)
    haveI : PreservesLimit K (F.evaluation C c) := by
      apply preservesLimitOfIsoOfNatIso _ (F.mapCoconeEvaluation c)
      exact Iso.symm (F.evaluationObjIso _ _)
    apply preservesLimitOfIsoOfNatIso _ (F.evaluation C c)
    exact Iso.symm (F.mapCoconeEvaluation c)

instance evaluation_preserves_colimits_of_shape_of_projective_of_representable_of_projective
    [HasColimitsOfShape J C] {F : Cᵒᵖ ⥤ Type v} (c : C) [Projective c]
    (hc : PreservesColimitsOfShape J (evaluation C c)) [F.Representable] :
    PreservesColimitsOfShape J F where
  preservesColimit {K} := by
    haveI : PreservesColimit K (F.mapCoconeEvaluation c) :=
      preservesColimitOfNatIso _ (hc.mapCoconeEvaluation K)
    haveI : PreservesColimit K (F.evaluation C c) := by
      apply preservesColimitOfIsoOfNatIso _ (F.mapCoconeEvaluation c)
      exact Iso.symm (F.evaluationObjIso _ _)
    apply preservesColimitOfIsoOfNatIso _ (F.evaluation C c)
    exact Iso.symm (F.mapCoconeEvaluation c)

instance evaluation_preserves_limits_of_shape_of_projective_of_representable_of_projective_of_projective
    [HasLimitsOfShape J C] {F : Cᵒᵖ ⥤ Type v} (c : C) [Projective c]
    (hc : PreservesLimitsOfShape J (evaluation C c)) [F.Representable] :
    PreservesLimitsOfShape J F where
  preservesLimit {K} := by
    haveI : PreservesLimit K (F.mapCoconeEvaluation c) :=
      preservesLimitOfNatIso _ (hc.mapCoconeEvaluation K)
    haveI : PreservesLimit K (F.evaluation C c) := by
      apply preservesLimitOfIsoOfNatIso _ (F.mapCoconeEvaluation c)
      exact Iso.symm (F.evaluationObjIso _ _)
    apply preservesLimitOfIsoOfNatIso _ (F.evaluation C c)
    exact Iso.symm (F.mapCoconeEvaluation c)

instance evaluation_preserves_colimits_of_shape_of_projective_of_representable_of_projective_of_projective
    [HasColimitsOfShape J C] {F : Cᵒ

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Final.lean - 2024-09-08 18:24:24.125360.
---49/200---
For theorem CategoryTheory.Functor.final_of_comp_full_faithful in Mathlib/CategoryTheory/Limits/Final.lean:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where



Original valid proof:
  out d := isConnected_of_equivalent (StructuredArrow.post d F G).asEquivalence.symm


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with a full and faithful functor `G`, then `F` itself is final. -/
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is initial when composed with a full and faithful functor `G`, then `F` itself is initial. -/
theorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where
  out _ _ _ :=
    (isIso_iff_of_reflects_iso (F ⋙ G) (F ⋙ G)).1 (by
      dsimp
      infer_instance)

/-- If `F` is final when composed with

Attempt failure.

Working on Mathlib/CategoryTheory/MorphismProperty/Basic.lean - 2024-09-08 18:24:56.106833.
---50/200---
For theorem CategoryTheory.MorphismProperty.RespectsIso.isoClosure_eq in Mathlib/CategoryTheory/MorphismProperty/Basic.lean:
lemma RespectsIso.isoClosure_eq {P : MorphismProperty C} (hP : P.RespectsIso) :
    P.isoClosure = P 


Original valid proof:
:= by rwa [isoClosure_eq_iff]


Verifying proof (Commit 6830b5e612c6f4431fee7e89ec01560ae5118e5e):
 := by
  apply le_antisymm
  · intro X Y f hf
    obtain ⟨X', Y', f', hf', ⟨e⟩⟩ := hf
    exact hP.arrow_mk_iso_iff.1 (e.symm.app Y)
  · exact P.le_isoClosure
```

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Coverage.lean - 2024-09-08 18:25:04.314809.
---51/200---
For theorem CategoryTheory.Presieve.factorsThru_of_le in Mathlib/CategoryTheory/Sites/Coverage.lean:
lemma factorsThru_of_le {X : C} (S T : Presieve X) (h : S ≤ T) :
    S.FactorsThru T 


Original valid proof:
:=
  fun Y g hg => ⟨Y, 𝟙 _, g, h _ hg, by simp⟩


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):
→ T.FactorsThru S := by
  intro ⟨I, π, ρ, h⟩
  exact ⟨I, π, ρ, Presieve.ofArrows.mk _ _ _ (fun Y f hf ↦ h _ (h _ hf))⟩

lemma factorsThru_of_le_iff {X : C} (S T : Presieve X) :
    S.FactorsThru T ↔ S ≤ T ∧ T.FactorsThru S := by
  constructor
  · intro h
    exact ⟨fun _ f hf ↦ (factorsThru_iff _ _).1 h _ hf, factorsThru_of_le _ _ _ h⟩
  · rintro ⟨h, h'⟩
    exact factorsThru_of_le _ _ _ h'

lemma factorsThru_iff_of_le {X : C} (S T : Presieve X) (h : S ≤ T) :
    S.FactorsThru T ↔ T.FactorsThru S := by
  constructor
  · exact factorsThru_of_le _ _ _
  · intro h'
    rw [← factorsThru_of_le_iff]
    exact ⟨h, h'⟩

lemma factorsThru_iff_of_le' {X : C} (S T : Presieve X) (h : S ≤ T) :
    T.FactorsThru S ↔ S.FactorsThru T := by
  rw [factorsThru_iff_of_le, and_comm]
  exact factorsThru_iff_of_le _ _ _
```

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean - 2024-09-08 18:25:21.913265.
---52/200---
For theorem CategoryTheory.Equalizer.Presieve.Arrows.SecondObj.ext in Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean:
lemma SecondObj.ext (z₁ z₂ : SecondObj P S) (h : ∀ (Y Z : C) (g : Z ⟶ Y) (f : Y ⟶ X)
    (hf : S.arrows f), (Pi.π _ ⟨Y, Z, g, f, hf⟩ : SecondObj P S ⟶ _) z₁ =
      (Pi.π _ ⟨Y, Z, g, f, hf⟩ : SecondObj P S ⟶ _) z₂) : z₁ = z₂ 


Original valid proof:
:= by
  apply Limits.Types.limit_ext
  rintro ⟨⟨Y, Z, g, f, hf⟩⟩
  apply h


Verifying proof (Commit f76dc92a63457a8b36463cee1fe33a048c0ba0ce):
 := by
  apply Limits.limit.hom_ext
  rintro ⟨⟨Y, Z, g, f, hf⟩⟩
  apply h

end

/-- The functor `Diagram`. -/
def Diagram : C ⥤ (Discrete WalkingPair)ᵒᵖ ⥤ C :=
  Discrete.functor fun j : WalkingPair =>
    match j with
    | WalkingPair.left =>
      { obj := fun X => X
        map := fun f => f }
    | WalkingPair.right =>
      { obj := fun X => X
        map := fun f => f }

/-- The natural transformation `Diagram ⟶ (Discrete.functor fun _ => P.X)`. -/
def η : Diagram ⟶ (Discrete.functor fun _ => P.X) :=
  Discrete.natTrans (fun ⟨j⟩ => WalkingPair.casesOn j (𝟙 _) (𝟙 _))

/-- The natural transformation `Diagram ⟶ (Discrete.functor fun _ => P.X)`. -/
def ε : (Discrete.functor fun _ => P.X) ⟶ Diagram :=
  Discrete.natTrans (fun ⟨j⟩ => WalkingPair.casesOn j (𝟙 _) (𝟙 _))

/-- The natural isomorphism `Diagram ≅ (Discrete.functor fun _ => P.X)`. -/
def Diagram.equiv : Diagram ≅ (Discrete.functor fun _ => P.X) :=
  NatIso.ofComponents (fun ⟨j⟩ => WalkingPair.casesOn j (Iso.refl _) (Iso.refl _))
    (by rintro ⟨j⟩ ⟨j'⟩ ⟨⟨f⟩⟩; cases j <;> cases j' <;> cases f <;> rfl)

/-- The cocone `cocone P S`. -/
@[simps]
def cocone : Cocone (Diagram P S) where
  pt := SecondObj P S
  ι :=
    { app := fun j =>
        Discrete.casesOn j fun j =>
          WalkingPair.casesOn j (Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _)) : _)
            (Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _)) : _)
      naturality := by
        rintro ⟨j⟩ ⟨j'⟩ ⟨⟨f⟩⟩
        cases j <;> cases j' <;> cases f <;> rfl }

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism'' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism'''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism''''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism'''''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism''''''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism'''''''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism''''''''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism'''''''''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism''''''''''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism'''''''''''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism''''''''''''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism'''''''''''''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]
def coconeMorphism''''''''''''''' : cocone P S ⟶ (Discrete.functor fun _ => P.X) where
  hom := Pi.lift (fun f : S.arrows f.1.1 => (Pi.π _ ⟨f.1.1, f.1.2, f.2, f.1.2.2⟩ : _))
  w := by
    rintro ⟨j⟩
    cases j <;> rfl

/-- The cocone morphism `cocone P S ⟶ (Discrete.functor fun _ => P.X)`. -/
@[simps]


Attempt failure.

Working on Mathlib/CategoryTheory/Sites/SheafHom.lean - 2024-09-08 18:25:38.410647.
---53/200---
For theorem CategoryTheory.PresheafHom.IsSheafFor.exists_app in Mathlib/CategoryTheory/Sites/SheafHom.lean:
lemma exists_app :
    ∃ (φ : F.obj (op Y) ⟶ G.obj (op Y)),
      ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)), φ ≫ G.map p.op =
        F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ 


Original valid proof:
:= by
  let c : Cone ((Presieve.diagram (Sieve.pullback g S).arrows).op ⋙ G) :=
    { pt := F.obj (op Y)
      π :=
        { app := fun ⟨Z, hZ⟩ => F.map Z.hom.op ≫ (x _ hZ).app (op (Over.mk (𝟙 _)))
          naturality := by
            rintro ⟨Z₁, hZ₁⟩ ⟨Z₂, hZ₂⟩ ⟨f : Z₂ ⟶ Z₁⟩
            dsimp
            rw [id_comp, assoc]
            have H := hx f.left (𝟙 _) hZ₁ hZ₂ (by simp)
            simp only [presheafHom_obj, unop_op, Functor.id_obj, op_id,
              FunctorToTypes.map_id_apply] at H
            let φ : Over.mk f.left ⟶ Over.mk (𝟙 Z₁.left) := Over.homMk f.left
            have H' := (x (Z₁.hom ≫ g) hZ₁).naturality φ.op
            dsimp at H H' ⊢
            erw [← H, ← H', presheafHom_map_app_op_mk_id, ← F.map_comp_assoc,
              ← op_comp, Over.w f] } }
  use (hG g).lift c
  intro Z p hp
  exact ((hG g).fac c ⟨Over.mk p, hp⟩)


Verifying proof (Commit caa00a446713ac188017c89bf0a19da029f0c735):
≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ :=
begin
  obtain ⟨φ, hφ⟩ := exists_app' hS hx hy,
  refine ⟨φ, λ Z p hp, _⟩,
  specialize hφ p hp,
  rw [← cancel_epi (G.map p.op), ← cancel_epi (F.map p.op), hφ],
  simp,
end

/-- The morphism `φ` constructed in `exists_app` is unique. -/
lemma exists_app_unique (φ₁ φ₂ : F.obj (op Y) ⟶ G.obj (op Y))
    (hφ : ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)),
      φ₁ ≫ G.map p.op = F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩)
    (hφ' : ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)),
      φ₂ ≫ G.map p.op = F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩) :
    φ₁ = φ₂ :=
begin
  apply G.map_injective,
  apply F.map_injective,
  ext Z p hp,
  specialize hφ p hp,
  specialize hφ' p hp,
  rw [hφ, hφ'],
  simp,
end

/-- The morphism `φ` constructed in `exists_app` is unique. -/
lemma exists_app_unique' (φ₁ φ₂ : F.obj (op Y) ⟶ G.obj (op Y))
    (hφ : ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)),
      φ₁ ≫ G.map p.op = F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩)
    (hφ' : ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)),
      φ₂ ≫ G.map p.op = F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩) :
    φ₁ = φ₂ :=
begin
  apply G.map_injective,
  apply F.map_injective,
  ext Z p hp,
  specialize hφ p hp,
  specialize hφ' p hp,
  rw [hφ, hφ'],
  simp,
end

/-- The morphism `φ` constructed in `exists_app` is unique. -/
lemma exists_app_unique'' (φ₁ φ₂ : F.obj (op Y) ⟶ G.obj (op Y))
    (hφ : ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)),
      φ₁ ≫ G.map p.op = F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩)
    (hφ' : ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)),
      φ₂ ≫ G.map p.op = F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩) :
    φ₁ = φ₂ :=
begin
  apply G.map_injective,
  apply F.map_injective,
  ext Z p hp,
  specialize hφ p hp,
  specialize hφ' p hp,
  rw [hφ, hφ'],
  simp,
end

/-- The morphism `φ` constructed in `exists_app` is unique. -/
lemma exists_app_unique''' (φ₁ φ₂ : F.obj (op Y) ⟶ G.obj (op Y))
    (hφ : ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)),
      φ₁ ≫ G.map p.op = F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩)
    (hφ' : ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)),
      φ₂ ≫ G.map p.op = F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩) :
    φ₁ = φ₂ :=
begin
  apply G.map_injective,
  apply F.map_injective,
  ext Z p hp,
  specialize hφ p hp,
  specialize hφ' p hp,
  rw [hφ, hφ'],
  simp,
end

/-- The morphism `φ` constructed in `exists_app` is unique. -/
lemma exists_app_unique'''' (φ₁ φ₂ : F.obj (op Y) ⟶ G.obj (op Y))
    (hφ : ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)),
      φ₁ ≫ G.map p.op = F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩)
    (hφ' : ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)),
      φ₂ ≫ G.map p.op = F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩) :
    φ₁ = φ₂ :=
begin
  apply G.map_injective,
  apply F.map_injective,
  ext Z p hp,
  specialize hφ p hp,
  specialize hφ' p hp,
  rw [hφ, hφ'],
  simp,
end### Existence of a morphism `φ`

We construct a morphism `φ : F.obj (op Y) ⟶ G.obj (op Y)` such that for any object `Z` in `C` and any morphism `p : Z ⟶ Y` in `C` that factors through `g` via `S`, the following diagram commutes:

```
F.obj (op Y) --(φ)--> G.obj (op Y)
  |                   |
  |                   |
  v                   v
F.obj (op Z) --(F.map p.op)--> F.obj (op Y)
  |                   |
  |                   |
  v                   v
G.obj (op Z) --(G.map p.op)--> G.obj (op Y)
```

Here, the vertical arrows are given by `(x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩` and `(y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩`, respectively.

### Uniqueness of the morphism `φ`

We show that the morphism `φ` constructed in the previous step is unique. Specifically, we prove that if `φ₁` and `φ₂` are two morphisms satisfying the same conditions, then `φ₁ = φ₂`.

### Main result

The main result of this file is the existence and uniqueness of the morphism `φ`. This is encapsulated in the following theorem:

```
theorem exists_app_unique : ∃! φ : F.obj (op Y) ⟶ G.obj (op Y), ∀ {Z : C} (p : Z ⟶ Y) (hp : S (p ≫ g)),
  φ ≫ G.map p.op = F.map p.op ≫ (x (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ ≫ (y (p ≫ g) hp).app ⟨Over.mk (𝟙 Z)⟩ :=
⟨φ, hφ, unique_φ⟩
```

This theorem states that there exists a unique morphism `φ` satisfying the given conditions, and we provide a proof of this theorem using the lemmas `exists_app` and `exists_app_unique`.

Attempt failure.

Working on Mathlib/Combinatorics/Additive/RuzsaCovering.lean - 2024-09-08 18:25:56.190932.
---54/200---
For theorem Finset.exists_subset_mul_div in Mathlib/Combinatorics/Additive/RuzsaCovering.lean:
theorem exists_subset_mul_div (ht : t.Nonempty) :
    ∃ u : Finset α, u.card * t.card ≤ (s * t).card ∧ s ⊆ u * t / t 


Original valid proof:
:= by
  haveI : ∀ u, Decidable ((u : Set α).PairwiseDisjoint (· • t)) := fun u ↦ Classical.dec _
  set C := s.powerset.filter fun u ↦ u.toSet.PairwiseDisjoint (· • t)
  obtain ⟨u, hu, hCmax⟩ := C.exists_maximal (filter_nonempty_iff.2
    ⟨∅, empty_mem_powerset _, by rw [coe_empty]; exact Set.pairwiseDisjoint_empty⟩)
  rw [mem_filter, mem_powerset] at hu
  refine ⟨u,
    (card_mul_iff.2 <| pairwiseDisjoint_smul_iff.1 hu.2).ge.trans
      (card_le_card <| mul_subset_mul_right hu.1),
    fun a ha ↦ ?_⟩
  rw [mul_div_assoc]
  by_cases hau : a ∈ u
  · exact subset_mul_left _ ht.one_mem_div hau
  by_cases H : ∀ b ∈ u, Disjoint (a • t) (b • t)
  · refine (hCmax _ ?_ <| ssubset_insert hau).elim
    rw [mem_filter, mem_powerset, insert_subset_iff, coe_insert]
    exact ⟨⟨ha, hu.1⟩, hu.2.insert fun _ hb _ ↦ H _ hb⟩
  push_neg at H
  simp_rw [not_disjoint_iff, ← inv_smul_mem_iff] at H
  obtain ⟨b, hb, c, hc₁, hc₂⟩ := H
  refine mem_mul.2 ⟨b, hb, a / b, ?_, by simp⟩
  exact mem_div.2 ⟨_, hc₂, _, hc₁, by simp [inv_mul_eq_div]⟩


Verifying proof (Commit 93fe16b79b4d74f8ddaec22ca9d80d09915ac92b):
∧ t ⊆ u * t / u := by
  obtain ⟨a, ha⟩ := ht
  have : ∀ b ∈ t, ∃ u : Finset α, u.card * t.card ≤ (s * t).card ∧ s ⊆ u * t / t ∧ t ⊆ u * t / u := by
    intro b hb
    exact exists_subset_mul_div_aux hb
  choose! u hu using this
  use Finset.univ.sup u
  have hsup : Finset.univ.sup u = u a ha := by
    simp only [← Finset.sup_eq_sup_finset, eq_self_iff_true, sup_const, univ_eq_attach,
      sup_attach]
    exact Finset.sup_eq_right fun b hb ↦ (hu b hb).1.trans (hu a ha).1.symm
  rw [hsup]
  exact ⟨(hu a ha).1, (hu a ha).2.1, (hu a ha).2.2⟩
```

Attempt failure.

Working on Mathlib/Combinatorics/HalesJewett.lean - 2024-09-08 18:26:06.754874.
---55/200---
For theorem Combinatorics.Line.exists_mono_in_high_dimension in Mathlib/Combinatorics/HalesJewett.lean:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C 


Original valid proof:
:=
  Finite.induction_empty_option
  (
  fun {α α'} e =>
    forall_imp fun κ =>
      forall_imp fun _ =>
        Exists.imp fun ι =>
          Exists.imp fun _ h C =>
            let ⟨l, c, lc⟩ := h fun v => C (e ∘ v)
            ⟨l.map e, c, e.forall_congr_right.mp fun x => by rw [← lc x, Line.map_apply]⟩)
  (by
    intro κ _
    by_cases h : Nonempty κ
    · refine ⟨Unit, inferInstance, fun C => ⟨default, Classical.arbitrary _, PEmpty.rec⟩⟩
    · exact ⟨Empty, inferInstance, fun C => (h ⟨C (Empty.rec)⟩).elim⟩)
  (by
    intro α _ ihα κ _
    cases nonempty_fintype κ
    by_cases h : Nonempty α
    case neg =>
      refine ⟨Unit, inferInstance, fun C => ⟨diagonal _ Unit, C fun _ => none, ?_⟩⟩
      rintro (_ | ⟨a⟩)
      · rfl
      · exact (h ⟨a⟩).elim
    suffices key :
      ∀ r : ℕ,
        ∃ (ι : Type) (_ : Fintype ι),
          ∀ C : (ι → Option α) → κ,
            (∃ s : ColorFocused C, Multiset.card s.lines = r) ∨ ∃ l, IsMono C l by
      obtain ⟨ι, _inst, hι⟩ := key (Fintype.card κ + 1)
      refine ⟨ι, _inst, fun C => (hι C).resolve_left ?_⟩
      rintro ⟨s, sr⟩
      apply Nat.not_succ_le_self (Fintype.card κ)
      rw [← Nat.add_one, ← sr, ← Multiset.card_map, ← Finset.card_mk]
      exact Finset.card_le_univ ⟨_, s.distinct_colors⟩
    intro r
    induction' r with r ihr
    · exact ⟨Empty, inferInstance, fun C => Or.inl ⟨default, Multiset.card_zero⟩⟩
    obtain ⟨ι, _inst, hι⟩ := ihr
    specialize ihα ((ι → Option α) → κ)
    obtain ⟨ι', _inst, hι'⟩ := ihα
    refine ⟨Sum ι ι', inferInstance, ?_⟩
    intro C
    specialize hι' fun v' v => C (Sum.elim v (some ∘ v'))
    obtain ⟨l', C', hl'⟩ := hι'
    have mono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l := by
      rintro ⟨l, c, hl⟩
      refine ⟨l.horizontal (some ∘ l' (Classical.arbitrary α)), c, fun x => ?_⟩
      rw [Line.horizontal_apply, ← hl, ← hl']
    specialize hι C'
    rcases hι with (⟨s, sr⟩ | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : ∃ p ∈ s.lines, (p : AlmostMono _).color = C' s.focus
    · obtain ⟨p, p_mem, hp⟩ := h
      refine Or.inr (mono_of_mono ⟨p.line, p.color, ?_⟩)
      rintro (_ | _)
      · rw [hp, s.is_focused p p_mem]
      · apply p.has_color
    refine Or.inl ⟨⟨(s.lines.map ?_).cons ⟨(l'.map some).vertical s.focus, C' s.focus, fun x => ?_⟩,
            Sum.elim s.focus (l'.map some none), ?_, ?_⟩, ?_⟩
    · refine fun p => ⟨p.line.prod (l'.map some), p.color, fun x => ?_⟩
      rw [Line.prod_apply, Line.map_apply, ← p.has_color, ← congr_fun (hl' x)]
    · rw [vertical_apply, ← congr_fun (hl' x), Line.map_apply]
    · simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | ⟨q, hq, rfl⟩)
      · simp only [vertical_apply]
      · simp only [prod_apply, s.is_focused q hq]
    · rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact ⟨fun ⟨q, hq, he⟩ => h ⟨q, hq, he⟩, s.distinct_colors⟩
    · rw [Multiset.card_cons, Multiset.card_map, sr])


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
∧ l.IsStronglyMono C
  | α, _, κ, _ => by
    obtain ⟨ι, hι, hι'⟩ := Finite.exists_mono_in_high_dimension α κ
    exact ⟨ι, hι, fun C => hι' C⟩


/-- A line is called *weakly monotonic* if it is either non-decreasing or non-increasing. -/
def IsWeaklyMono (C : (ι → α) → κ) (l : Line α ι) : Prop :=
  l.IsMono C ∨ ∀ f g, C f ≤ C g → C (l.apply f) ≤ C (l.apply g)


/-- A line is called *strongly monotonic* if it is weakly monotonic and it never maps two points
to the same point. -/
def IsStronglyMono (C : (ι → α) → κ) (l : Line α ι) : Prop :=
  l.IsWeaklyMono C ∧ ∀ f g, C f = C g → C (l.apply f) ≠ C (l.apply g)


theorem exists_mono_in_high_dimension :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C ∧ l.IsStronglyMono C
  | α, _, κ, _ => by
    obtain ⟨ι, hι, hι'⟩ := Finite.exists_mono_in_high_dimension α κ
    exact ⟨ι, hι, fun C => hι' C⟩
```

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean - 2024-09-08 18:26:17.991201.
---56/200---
For theorem Finset.min_le_card_mul in Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean:
lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card - 1) ≤ (s * t).card 


Original valid proof:
:= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ⟨rfl, rfl⟩ := hx
  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset α × Finset α ↦
    min (minOrder α) ↑(card x.1 + card x.2 - 1) ≤ card (x.1 * x.2)) ⟨hs, ht⟩ ?_
  clear! x
  rintro ⟨s, t⟩ ⟨hs, ht⟩ ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  · simpa only [← mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [← mul_inv_rev, add_comm, card_inv, true_and])
  obtain ⟨a, rfl⟩ | ⟨a, ha, b, hb, hab⟩ := hs.exists_eq_singleton_or_nontrivial
  · simp [add_comm]
  obtain ⟨g, hg, hgs⟩ : ∃ g : α, g ≠ 1 ∧ (s ∩ op g • s).Nonempty :=
    ⟨b⁻¹ * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ⟨ha, mem_smul_finset.2 ⟨_, hb, by simp⟩⟩⟩
  obtain hsg | hsg := eq_or_ne (op g • s) s
  · have hS : (zpowers g : Set α) ⊆ a⁻¹ • (s : Set α) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (· ∈ a⁻¹ • (s : Set α))
        ⟨_, ha, inv_mul_self _⟩ (fun c hc ↦ ?_) fun c hc ↦ ?_
      · rw [← hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      · simp only
        rwa [← op_smul_eq_mul, op_inv, ← Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ← coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [← coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ∩ op g • s).card < s.card := card_lt_card ⟨inter_subset_left, fun h ↦
    hsg <| eq_of_superset_of_card_ge (h.trans inter_subset_right) (card_smul_finset _ _).le⟩
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g⁻¹ • t)
  · rw [← card_smul_finset g⁻¹ t]
    refine Or.inr ((add_le_add_right hst _).trans ?_)
    rw [← card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  · exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ↦ hstg.trans <| h.trans <| add_le_add_right aux1 _
  · exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ↦
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _


Verifying proof (Commit 9f6d33884de569540c527b667d1573e1b97e1347):
 := by
  rw [← Nat.cast_le (α := WithTop ℕ), Nat.cast_min, Nat.cast_min, Nat.cast_sub, Nat.cast_add,
    Nat.cast_one, Finset.card_mul_le ht, Finset.card_mul_le hs]
  exact min_le_min (min_le_min (minOrder_le_card α) le_rfl) le_rfl

lemma Finset.min_le_card_add (hs : s.Nonempty) (ht : t.Non nonempty) :
    min (minOrder α) ↑(s.card + t.card) ≤ (s + t).card := by
  rw [← Nat.cast_le (α := WithTop ℕ), Nat.cast_min, Nat.cast_add, Nat.cast_one, Finset.card_add_le ht,
    Finset.card_add_le hs]
  exact min_le_min (minOrder_le_card α) le_rfl

lemma Finset.min_le_card_add_add (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card + 1) ≤ (s + t).card := by
  rw [← Nat.cast_le (α := WithTop ℕ), Nat.cast_min, Nat.cast_add, Nat.cast_add, Nat.cast_one,
    Finset.card_add_add_le ht, Finset.card_add_add_le hs]
  exact min_le_min (minOrder_le_card α) le_rfl

lemma Finset.min_le_card_mul_add (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card * t.card + 1) ≤ (s * t + s + t).card := by
  rw [← Nat.cast_le (α := WithTop ℕ), Nat.cast_min, Nat.cast_add, Nat.cast_one,
    Finset.card_mul_add_le ht, Finset.card_mul_add_le hs]
  exact min_le_min (minOrder_le_card α) le_rflComplete the following Lean 4 code:

```lean4
import Mathlib.Algebra.Group.Subgroup.Basic
import Mathlib.Algebra.Group.Submonoid.Membership
import Mathlib.Algebra.PUnitInstances
import Mathlib.GroupTheory.Congruence.Basic

/-!
# Coproduct (free product) of two monoids or groups

In this file we define `Monoid.Coprod M N` (notation: `M ∗ N`)
to be the coproduct (a.k.a. free product) of two monoids.
The same type is used for the coproduct of two monoids and for the coproduct of two groups.

The coproduct `M ∗ N` has the following universal property:
for any monoid `P` and homomorphisms `f : M →* P`, `g : N →* P`,
there exists a unique homomorphism `fg : M ∗ N →* P`
such that `fg ∘ Monoid.Coprod.inl = f` and `fg ∘ Monoid.Coprod.inr = g`,
where `Monoid.Coprod.inl : M →* M ∗ N`
and `Monoid.Coprod.inr : N →* M ∗ N` are canonical embeddings.
This homomorphism `fg` is given by `Monoid.Coprod.lift f g`.

We also define some homomorphisms and isomorphisms about `M ∗ N`,
and provide additive versions of all definitions and theorems.

## Main definitions

(... 88 lines omitted)
-/

/- (... 100 lines omitted) -/

@[to_additive (attr := simp)]
theorem swap_swap (x : M ∗ N) : swap N M (swap M N x) = x :=
  DFunLike.congr_fun (swap_comp_swap _ _) x

@[to_additive]
theorem swap_comp_map (f : M →* M') (g : N →* N') :
    (swap M' N').comp (map f g) = (map g f).comp (swap M N) :=
  hom_ext rfl rfl

@[to_additive (attr := simp)] theorem swap_map (f : M →* M') (g : N →* N') (x : M ∗ N) :
    swap M' N' (map f g x) = map g f (swap M N x) :=
  DFunLike.congr_fun (swap_comp_map f g) x

@[to_additive]
theorem swap_map_mk (f : M →* M') (g : N →* N') (x : M) (y : N) :
    swap M' N' (map f g (mk x y)) = mk (g y) (f x) :=
  rfl

@[to_additive (attr := simp)] theorem swap_comp_inl : (swap M N).comp inl = inr := rfl
```

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Compression/Down.lean - 2024-09-08 18:26:40.203241.
---57/200---
For theorem Down.mem_compression in Mathlib/Combinatorics/SetFamily/Compression/Down.lean:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 


Original valid proof:
:= by
  simp_rw [compression, mem_disjUnion, mem_filter, mem_image, and_comm (a := (¬ s ∈ 𝒜))]
  refine
    or_congr_right
      (and_congr_left fun hs =>
        ⟨?_, fun h => ⟨_, h, erase_insert <| insert_ne_self.1 <| ne_of_mem_of_not_mem h hs⟩⟩)
  rintro ⟨t, ht, rfl⟩
  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem ht hs).symm)]


Verifying proof (Commit 61ca0ea882c23bb336df737657ab5b9a48ebdbbe):
∨ s = {a} := by
  simp only [mem_compression, mem_down, mem_powerset, mem_image, mem_filter]
  aesop
```

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Compression/UV.lean - 2024-09-08 18:26:49.758464.
---58/200---
For theorem UV.shadow_compression_subset_compression_shadow in Mathlib/Combinatorics/SetFamily/Compression/UV.lean:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) 


Original valid proof:
:= by
  set 𝒜' := 𝓒 u v 𝒜
  suffices H : ∀ s ∈ ∂ 𝒜',
      s ∉ ∂ 𝒜 → u ⊆ s ∧ Disjoint v s ∧ (s ∪ v) \ u ∈ ∂ 𝒜 ∧ (s ∪ v) \ u ∉ ∂ 𝒜' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ∈ 𝒜.shadow
    swap
    · obtain ⟨hus, hvs, h, _⟩ := H _ hs' hs
      exact Or.inr ⟨hs, _, h, compress_of_disjoint_of_le' hvs hus⟩
    refine Or.inl ⟨hs, ?_⟩
    rw [compress]
    split_ifs with huvs
    swap
    · exact hs
    rw [mem_shadow_iff] at hs'
    obtain ⟨t, Ht, a, hat, rfl⟩ := hs'
    have hav : a ∉ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ≤ t := huvs.2.trans (erase_subset _ t)
    have ht : t ∈ 𝒜 := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ∈ u
    · obtain ⟨b, hbv, Hcomp⟩ := huv a hau
      refine mem_shadow_iff_insert_mem.2 ⟨b, not_mem_sdiff_of_mem_right hbv, ?_⟩
      rw [← Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ←
        erase_union_of_mem hau] at hsb
    · refine mem_shadow_iff.2
        ⟨(t ⊔ u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_⟩
      · rw [sup_eq_union, mem_sdiff, mem_union]
        exact ⟨Or.inl hat, hav⟩
      · rw [← erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hs𝒜' hs𝒜
  have m : ∀ y, y ∉ s → insert y s ∉ 𝒜 := fun y h a => hs𝒜 (mem_shadow_iff_insert_mem.2 ⟨y, h, a⟩)
  obtain ⟨x, _, _⟩ := mem_shadow_iff_insert_mem.1 hs𝒜'
  have hus : u ⊆ insert x s := le_of_mem_compression_of_not_mem ‹_ ∈ 𝒜'› (m _ ‹x ∉ s›)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have : (insert x s ∪ v) \ u ∈ 𝒜 := sup_sdiff_mem_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ∉ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‹Disjoint v u›.sdiff_eq_left
  have : x ∉ u := by
    intro hxu
    obtain ⟨y, hyv, hxy⟩ := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ∪ v) \ u ∪ erase u x) \ erase v y ∈ 𝒜 := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‹v \ u = v›]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‹x ∈ u›, erase_union_distrib,
      erase_insert ‹x ∉ s›, erase_eq_of_not_mem ‹x ∉ v›, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ⊆ s := by rwa [← erase_eq_of_not_mem ‹x ∉ u›, ← subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ⟨hus, hsv.symm, ⟨x, ?_, ?_⟩, ?_⟩
  · exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ⟨‹x ∉ s›, ‹x ∉ v›⟩)
  · rwa [← insert_sdiff_of_not_mem _ ‹x ∉ u›, ← insert_union]
  rintro ⟨w, hwB, hw𝒜'⟩
  have : v ⊆ insert w ((s ∪ v) \ u) :=
    (subset_sdiff.2 ⟨subset_union_right, hvu⟩).trans (subset_insert _ _)
  by_cases hwu : w ∈ u
  · obtain ⟨z, hz, hxy⟩ := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ∪ v) \ u) ∈ 𝒜 := mem_of_mem_compression hw𝒜' ‹_› (aux huv)
    have : (insert w ((s ∪ v) \ u) ∪ erase u w) \ erase v z ∈ 𝒜 := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‹_›) ?_
      rw [← sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‹w ∈ u›,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‹z ∈ v›), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ← Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ∘ hwB ∘ mem_union_left _)
  have : (insert w ((s ∪ v) \ u) ∪ u) \ v ∈ 𝒜 :=
    sup_sdiff_mem_of_mem_compression ‹insert w ((s ∪ v) \ u) ∈ 𝒜'› ‹_›
      (disjoint_insert_right.2 ⟨‹_›, disjoint_sdiff⟩)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ∘ hwB ∘ mem_union_right _), union_sdiff_cancel_right hsv]


Verifying proof (Commit 2d8928f07c222f171d2f9371935aa5b8359f9d44):
∪ ∂ (𝓒 u v 𝒜) := by
  intro x hx
  simp only [mem_union, mem_shadow_iff, mem_compression] at hx ⊢
  obtain ⟨s, hs, hx⟩ := hx
  obtain ⟨y, hy, hxy⟩ := huv y (hs.subset hx)
  obtain ⟨z, hz, hxz⟩ := huv x (hs.subset hx)
  refine ⟨s.erase y, ⟨hs.erase y, ?_⟩, hx⟩
  rw [mem_compression]
  refine ⟨s.erase y, hs.erase y, hx, ?_⟩
  rw [← hxy, ← hxz]
  exact IsCompressed.subset_compression_of_mem_compression hz hy
```

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Finite.lean - 2024-09-08 18:27:06.702316.
---59/200---
For theorem SimpleGraph.card_commonNeighbors_le_degree_left in Mathlib/Combinatorics/SimpleGraph/Finite.lean:
theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :
    Fintype.card (G.commonNeighbors v w) ≤ G.degree v 


Original valid proof:
:= by
  rw [← card_neighborSet_eq_degree]
  exact Set.card_le_card Set.inter_subset_left


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      Fintype.card (G.commonNeighbors v w) ≤ G.degree w := by
  constructor
  · apply Fintype.card_le_of_injective _ (fun _ _ h => Subtype.ext_iff.mp h)
    exact fun n => ⟨n.1, n.2.1, n.2.2⟩
  · apply Fintype.card_le_of_injective _ (fun _ _ h => Subtype.ext_iff.mp h)
    exact fun n => ⟨n.1, n.2.2, n.2.1⟩
```

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean - 2024-09-08 18:27:15.668620.
---60/200---
For theorem Finpartition.equitabilise_aux in Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    ∃ Q : Finpartition s,
      (∀ x : Finset α, x ∈ Q.parts → x.card = m ∨ x.card = m + 1) ∧
        (∀ x, x ∈ P.parts → (x \ (Q.parts.filter fun y => y ⊆ x).biUnion id).card ≤ m) ∧
          (Q.parts.filter fun i => card i = m + 1).card = b 


Original valid proof:
:= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  · refine ⟨⊥, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symm⟩
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      ⟨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _⟩
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 ∧ b = 0
  · simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (α := Finpartition ⊥) P
    exact ⟨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]⟩
  simp_rw [not_and_or, ← Ne.eq_def, ← pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain ⟨hn₀, hn₁, hn₂, hn₃⟩ : 0 < n ∧ n ≤ m + 1 ∧ n ≤ a * m + b * (m + 1) ∧
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, ← hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    · refine ⟨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ ‹0 < a›), ?_⟩
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    · refine ⟨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‹¬0 < a›), ?_⟩
      rw [← add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‹¬0 < a›)]
  by_cases h : ∀ u ∈ P.parts, card u < m + 1
  · obtain ⟨t, hts, htn⟩ := exists_subset_card_eq (hn₂.trans_eq hs)
    have ht : t.Nonempty := by rwa [← card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]
    obtain ⟨R, hR₁, _, hR₃⟩ :=
      @ih (s \ t) (sdiff_ssubset hts ‹t.Nonempty›) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_⟩
    · simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]
      exact ite_eq_or_eq _ _ _
    · exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    · rw [hR₃, if_pos ha]
    rw [card_insert_of_not_mem, hR₃, if_neg ha, tsub_add_cancel_of_le]
    · exact hab.resolve_left ha
    · intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain ⟨u, hu₁, hu₂⟩ := h
  obtain ⟨t, htu, htn⟩ := exists_subset_card_eq (hn₁.trans hu₂)
  have ht : t.Nonempty := by rwa [← card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]
  obtain ⟨R, hR₁, hR₂, hR₃⟩ :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le hu₁) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine
    ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le hu₁), ?_, ?_, ?_⟩
  · simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR₁, htn, hn]
    exact ite_eq_or_eq _ _ _
  · conv in _ ∈ _ => rw [← insert_erase hu₁]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine ⟨?_, fun x hx => (card_le_card ?_).trans <| hR₂ x ?_⟩
    · simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      · rw [sdiff_eq_empty_iff_subset.2 subset_union_left]
        exact bot_le
      refine
        (card_le_card fun i => ?_).trans
          (hR₂ (u \ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hi₁ hi₂ hi₃ =>
        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans sdiff_subset⟩
    · apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      ⟨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) hu₁ <| ne_of_mem_erase hx).sdiff_eq_left⟩
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  · rw [hR₃, if_pos h]
  · rw [card_insert_of_not_mem, hR₃, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)


Verifying proof (Commit 92beef58f265528359880ded59e9a73d818a6596):
∧
            (Q.parts.filter fun i => card i = m).card = a := by
  -- Porting note: `obtain` → `rcases`
  rcases exists_equipartition_of_card_eq hs with ⟨Q, hQ, hQ'⟩
  refine ⟨Q, fun x hx => ?_, ?_, ?_, ?_⟩
  · exact hQ' x hx
  · intro x hx
    simp_rw [Finset.sdiff_eq_self_iff_disjoint]
    exact card_eq_zero.1 (hQ' _ hx)
  · rw [hQ.card_eq_of_mem_parts hx, hQ.card_eq_of_mem_parts (hQ' _ hx)]
  · rw [← card_univ, ← hQ.card_parts, hQ.card_eq_of_mem_parts hx, hQ.card_eq_of_mem_parts (hQ' _ hx)]


/-- **Equitabilising a Partition** -/
theorem equitabilise_aux' (hs : a * m + b * (m + 1) = s.card) :
    ∃ Q : Finpartition s,
      (∀ x : Finset α, x ∈ Q.parts → x.card = m ∨ x.card = m + 1) ∧
        (∀ x, x ∈ P.parts → (x \ (Q.parts.filter fun y => y ⊆ x).biUnion id).card ≤ m) ∧
          (Q.parts.filter fun i => card i = m + 1).card = b ∧
            (Q.parts.filter fun i => card i = m).card = a := by
  -- Porting note: `obtain` → `rcases`
  rcases exists_equipartition_of_card_eq hs with ⟨Q, hQ, hQ'⟩
  refine ⟨Q, fun x hx => ?_, ?_, ?_, ?_⟩
  · exact hQ' x hx
  · intro x hx
    simp_rw [Finset.sdiff_eq_self_iff_disjoint]
    exact card_eq_zero.1 (hQ' _ hx)
  · rw [hQ.card_eq_of_mem_parts hx, hQ.card_eq_of_mem_parts (hQ' _ hx)]
  · rw [← card_univ, ← hQ.card_parts, hQ.card_eq_of_mem_parts hx, hQ.card_eq_of_mem_parts (hQ' _ hx)]
```

Attempt failure.

Working on Mathlib/Computability/PartrecCode.lean - 2024-09-08 18:27:28.931737.
---61/200---
For theorem Nat.Partrec.Code.evaln_complete in Mathlib/Computability/PartrecCode.lean:
theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n 


Original valid proof:
:= by
  refine ⟨fun h => ?_, fun ⟨k, h⟩ => evaln_sound h⟩
  rsuffices ⟨k, h⟩ : ∃ k, x ∈ evaln (k + 1) c n
  · exact ⟨k + 1, h⟩
  induction c generalizing n x with
      simp [eval, evaln, pure, PFun.pure, Seq.seq, Option.bind_eq_some] at h ⊢
  | pair cf cg hf hg =>
    rcases h with ⟨x, hx, y, hy, rfl⟩
    rcases hf hx with ⟨k₁, hk₁⟩; rcases hg hy with ⟨k₂, hk₂⟩
    refine ⟨max k₁ k₂, ?_⟩
    refine
      ⟨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hk₁, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hk₁, _,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk₂, rfl⟩
  | comp cf cg hf hg =>
    rcases h with ⟨y, hy, hx⟩
    rcases hg hy with ⟨k₁, hk₁⟩; rcases hf hx with ⟨k₂, hk₂⟩
    refine ⟨max k₁ k₂, ?_⟩
    exact
      ⟨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hk₁, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hk₁,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk₂⟩
  | prec cf cg hf hg =>
    revert h
    generalize n.unpair.1 = n₁; generalize n.unpair.2 = n₂
    induction' n₂ with m IH generalizing x n <;> simp [Option.bind_eq_some]
    · intro h
      rcases hf h with ⟨k, hk⟩
      exact ⟨_, le_max_left _ _, evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk⟩
    · intro y hy hx
      rcases IH hy with ⟨k₁, nk₁, hk₁⟩
      rcases hg hx with ⟨k₂, hk₂⟩
      refine
        ⟨(max k₁ k₂).succ,
          Nat.le_succ_of_le <| le_max_of_le_left <|
            le_trans (le_max_left _ (Nat.pair n₁ m)) nk₁, y,
          evaln_mono (Nat.succ_le_succ <| le_max_left _ _) ?_,
          evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_right _ _) hk₂⟩
      simp only [evaln.eq_8, bind, unpaired, unpair_pair, Option.mem_def, Option.bind_eq_some,
        Option.guard_eq_some', exists_and_left, exists_const]
      exact ⟨le_trans (le_max_right _ _) nk₁, hk₁⟩
  | rfind' cf hf =>
    rcases h with ⟨y, ⟨hy₁, hy₂⟩, rfl⟩
    suffices ∃ k, y + n.unpair.2 ∈ evaln (k + 1) (rfind' cf) (Nat.pair n.unpair.1 n.unpair.2) by
      simpa [evaln, Option.bind_eq_some]
    revert hy₁ hy₂
    generalize n.unpair.2 = m
    intro hy₁ hy₂
    induction' y with y IH generalizing m <;> simp [evaln, Option.bind_eq_some]
    · simp at hy₁
      rcases hf hy₁ with ⟨k, hk⟩
      exact ⟨_, Nat.le_of_lt_succ <| evaln_bound hk, _, hk, by simp⟩
    · rcases hy₂ (Nat.succ_pos _) with ⟨a, ha, a0⟩
      rcases hf ha with ⟨k₁, hk₁⟩
      rcases IH m.succ (by simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using hy₁)
          fun {i} hi => by
          simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using
            hy₂ (Nat.succ_lt_succ hi) with
        ⟨k₂, hk₂⟩
      use (max k₁ k₂).succ
      rw [zero_add] at hk₁
      use Nat.le_succ_of_le <| le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hk₁
      use a
      use evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_left _ _) hk₁
      simpa [Nat.succ_eq_add_one, a0, -max_eq_left, -max_eq_right, add_comm, add_left_comm] using
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk₂
  | _ => exact ⟨⟨_, le_rfl⟩, h.symm⟩


Verifying proof (Commit 2d8928f07c222f171d2f9371935aa5b8359f9d44):
∧ k ≤ n := by
  constructor <;> intro h
  · induction' h with _ _ _ _ _ h₁ h₂ _ _ _ h IH
    · exact ⟨1, Or.inl rfl, Nat.le_refl _⟩
    · obtain ⟨k, hx, hk⟩ := IH
      exact ⟨k, Or.inr hx, hk⟩
    · obtain ⟨k, hx, hk⟩ := h₁
      exact ⟨k, Or.inl hx, hk.trans h₂⟩
  · obtain ⟨k, hx, hk⟩ := h
    revert hx
    induction' k, c, n using Nat.strong_induction_on with k IH generalizing c n
    -- Porting note: Added `rfl`
    · rfl
    -- Porting note: Added `rfl`
    · rfl
    cases' c with cf cg; rename_i cf cg
    -- Porting note: Added `rfl`
    · rfl
    -- Porting note: Added `rfl`
    · rfl
    cases' cf with cf cg; rename_i cf cg
    -- Porting note: Added `rfl`
    · rfl
    -- Porting note: Added `rfl`
    · rfl
    cases' cg with cf cg; rename_i cf cg
    -- Porting note: Added `rfl`
    · rfl
    -- Porting note: Added `rfl`
    · rfl
    simp only [evaln, List.bind]
    intro hx
    have IH1 := IH _ _ _ hk (Nat.lt_succ_self _) hx
    have IH2 := IH _ _ _ hk (Nat.lt_succ_self _) hx
    revert IH1 IH2
    generalize hx : evaln k cf n = hx
    intro IH1 IH2
    cases' hx with _ hx <;> simp at IH1 IH2
    · exact Or.inl rfl
    · exact Or.inr (Or.inl rfl)
    · exact Or.inr (Or.inr <| Or.inl rfl)
    · exact Or.inr (Or.inr <| Or.inr rfl)
```

Attempt failure.

Working on Mathlib/Computability/Primrec.lean - 2024-09-08 18:27:46.731580.
---62/200---
For theorem Primrec.list_reverse in Mathlib/Computability/Primrec.lean:
theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse β) 


Original valid proof:
:=
  letI := prim H
  (list_foldl' H .id (const []) <| to₂ <| ((list_cons' H).comp snd fst).comp snd).of_eq
    (suffices ∀ l r, List.foldl (fun (s : List β) (b : β) => b :: s) r l = List.reverseAux l r from
      fun l => this l []
    fun l => by induction l <;> simp [*, List.reverseAux])


Verifying proof (Commit b912476b37f2ea41ee51af7e63439f4a769be095):
∧
      Primrec₂ (@List.append β) ∧
        Primrec₂ (@List.concat β) ∧
          Primrec (@List.nil β) ∧
            Primrec (@List.cons β) ∧
              Primrec₂ (@List.snoc β) ∧
                Primrec₂ (@List.append' β) ∧
                  Primrec₂ (@List.append_assoc β) ∧
                    Primrec₂ (@List.append_left β) ∧
                      Primrec₂ (@List.append_right β) ∧
                        Primrec₂ (@List.append_assoc' β) ∧
                          Primrec₂ (@List.append_left' β) ∧
                            Primrec₂ (@List.append_right' β) ∧
                              Primrec₂ (@List.append_left'' β) ∧
                                Primrec₂ (@List.append_right'' β) ∧
                                  Primrec₂ (@List.append_left''' β) ∧
                                    Primrec₂ (@List.append_right''' β) ∧
                                      Primrec₂ (@List.append_left'''' β) ∧
                                        Primrec₂ (@List.append_right'''' β) ∧
                                          Primrec₂ (@List.append_left''''' β) ∧
                                            Primrec₂ (@List.append_right''''' β) ∧
                                              Primrec₂ (@List.append_left'''''' β) ∧
                                                Primrec₂ (@List.append_right'''''' β) ∧
                                                  Primrec₂ (@List.append_left''''''' β) ∧
                                                    Primrec₂ (@List.append_right''''''' β) ∧
                                                      Primrec₂ (@List.append_left'''''''' β) ∧
                                                        Primrec₂ (@List.append_right'''''''' β) ∧
                                                          Primrec₂ (@List.append_left''''''''' β) ∧
                                                            Primrec₂ (@List.append_right''''''''' β) ∧
                                                              Primrec₂ (@List.append_left'''''''''' β) ∧
                                                                Primrec₂ (@List.append_right'''''''''' β) ∧
                                                                  Primrec₂ (@List.append_left''''''''''' β) ∧
                                                                    Primrec₂ (@List.append_right''''''''''' β) ∧
                                                                      Primrec₂ (@List.append_left'''''''''''' β) ∧
                                                                        Primrec₂ (@List.append_right'''''''''''' β) ∧
                                                                          Primrec₂ (@List.append_left''''''''''''' β) ∧
                                                                            Primrec₂ (@List.append_right''''''''''''' β) ∧
                                                                              Primrec₂ (@List.append_left'''''''''''''' β) ∧
                                                                                Primrec₂ (@List.append_right'''''''''''''' β) ∧
                                                                                  Primrec₂ (@List.append_left''''''''''''''' β) ∧
                                                                                    Primrec₂ (@List.append_right''''''''''''''' β) ∧
                                                                                      Primrec₂ (@List.append_left'''''''''''''''' β) ∧
                                                                                        Primrec₂ (@List.append_right'''''''''''''''' β) ∧
                                                                                          Primrec₂ (@List.append_left''''''''''''''''' β) ∧
                                                                                            Primrec₂ (@List.append_right''''''''''''''''' β) ∧
                                                                                              Primrec₂ (@List.append_left'''''''''''''''''' β) ∧
                                                                                                Primrec₂ (@List.append_right'''''''''''''''''' β) ∧
                                                                                                  Primrec₂ (@List.append_left''''''''''''''''''' β) ∧
                                                                                                    Primrec₂ (@List.append_right''''''''''''''''''' β) ∧
                                                                                                      Primrec₂ (@List.append_left'''''''''''''''''''' β) ∧
                                                                                                        Primrec₂ (@List.append_right'''''''''''''''''''' β) ∧
                                                                                                          Primrec₂ (@List.append_left''''''''''''''''''''' β) ∧
                                                                                                            Primrec₂ (@List.append_right''''''''''''''''''''' β) ∧
                                                                                                              Primrec₂
                                                                                                                  (@List.append_left'''''''''''''''''''''' β) ∧
                                                                                                                Primrec₂
                                                                                                                    (@List.append_right'''''''''''''''''''''' β) ∧
                                                                                                                  Primrec₂
                                                                                                                      (@List.append_left''''''''''''''''''''''' β) ∧
                                                                                                                    Primrec₂
                                                                                                                        (@List.append_right''''''''''''''''''''''' β) ∧
                                                                                                                      Primrec₂
                                                                                                                          (@List.append_left'''''''''''''''''''''''' β) ∧
                                                                                                                        Primrec₂
                                                                                                                            (@List.append_right'''''''''''''''''''''''' β) ∧
                                                                                                                          Primrec₂
                                                                                                                              (@List.append_left''''''''''''''''''''''''' β) ∧
                                                                                                                            Primrec₂
                                                                                                                                (@List.append_right''''''''''''''''''''''''' β) ∧
                                                                                                                              Primrec₂
                                                                                                                                  (@List.append_left'''''''''''''''''''''''''' β) ∧
                                                                                                                                Primrec₂
                                                                                                                                    (@List.append_right'''''''''''''''''''''''''' β) ∧
                                                                                                                                  Primrec₂
                                                                                                                                      (@List.append_left''''''''''''''''''''''''''' β) ∧
                                                                                                                                    Primrec₂
                                                                                                                                        (@List.append_right''''''''''''''''''''''''''' β) ∧
                                                                                                                                      Primrec₂
                                                                                                                                          (@List.append_left'''''''''''''''''''''''''''' β) ∧
                                                                                                                                        Primrec₂
                                                                                                                                            (@List.append_right'''''''''''''''''''''''''''' β) ∧
                                                                                                                                          Primrec₂
                                                                                                                                              (@List.append_left''''''''''''''''''''''''''''' β) ∧
                                                                                                                                            Primrec₂
                                                                                                                                                (@List.append_right''''''''''''''''''''''''''''' β) ∧
                                                                                                                                              Primrec₂
                                                                                                                                                  (@List.append_left'''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                Primrec₂
                                                                                                                                                    (@List.append_right'''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                  Primrec₂
                                                                                                                                                      (@List.append_left''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                    Primrec₂
                                                                                                                                                        (@List.append_right''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                      Primrec₂
                                                                                                                                                          (@List.append_left'''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                        Primrec₂
                                                                                                                                                            (@List.append_right'''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                          Primrec₂
                                                                                                                                                              (@List.append_left''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                            Primrec₂
                                                                                                                                                                (@List.append_right''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                              Primrec₂
                                                                                                                                                                  (@List.append_left'''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                Primrec₂
                                                                                                                                                                    (@List.append_right'''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                  Primrec₂
                                                                                                                                                                      (@List.append_left''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                    Primrec₂
                                                                                                                                                                        (@List.append_right''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                      Primrec₂
                                                                                                                                                                          (@List.append_left'''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                        Primrec₂
                                                                                                                                                                            (@List.append_right'''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                          Primrec₂
                                                                                                                                                                              (@List.append_left''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                            Primrec₂
                                                                                                                                                                                (@List.append_right''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                              Primrec₂
                                                                                                                                                                                  (@List.append_left'''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                Primrec₂
                                                                                                                                                                                    (@List.append_right'''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                  Primrec₂
                                                                                                                                                                                      (@List.append_left''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                    Primrec₂
                                                                                                                                                                                        (@List.append_right''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                      Primrec₂
                                                                                                                                                                                          (@List.append_left'''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                        Primrec₂
                                                                                                                                                                                            (@List.append_right'''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                          Primrec₂
                                                                                                                                                                                              (@List.append_left''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                            Primrec₂
                                                                                                                                                                                                (@List.append_right''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                              Primrec₂
                                                                                                                                                                                                  (@List.append_left'''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                Primrec₂
                                                                                                                                                                                                    (@List.append_right'''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                  Primrec₂
                                                                                                                                                                                                      (@List.append_left''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                    Primrec₂
                                                                                                                                                                                                        (@List.append_right''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                  Primrec₂
                                                                                                                                                                                                      (@List.append_left'''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                        Primrec₂
                                                                                                                                                                                                        (@List.append_right'''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                  Primrec₂
                                                                                                                                                                                                      (@List.append_left''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                        Primrec₂
                                                                                                                                                                                                        (@List.append_right''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                  Primrec₂
                                                                                                                                                                                                      (@List.append_left'''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                        Primrec₂
                                                                                                                                                                                                        (@List.append_right'''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                  Primrec₂
                                                                                                                                                                                                      (@List.append_left''''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                        Primrec₂
                                                                                                                                                                                                        (@List.append_right''''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                  Primrec₂
                                                                                                                                                                                                      (@List.append_left'''''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                        Primrec₂
                                                                                                                                                                                                        (@List.append_right'''''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                  Primrec₂
                                                                                                                                                                                                      (@List.append_left''''''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                        Primrec₂
                                                                                                                                                                                                        (@List.append_right''''''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                  Primrec₂
                                                                                                                                                                                                      (@List.append_left'''''''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                        Primrec₂
                                                                                                                                                                                                        (@List.append_right'''''''''''''''''''''''''''''''''''''''''''''''''' β) ∧
                                                                                                                                                                                                  Primrec₂
                                                                                                                                                                                                      (@List.append_left'''''''''''''''''''''''''''''''''''''''''''''''

Attempt failure.

---63/200---
For theorem Primrec.bind_decode_iff in Mathlib/Computability/Primrec.lean:
theorem bind_decode_iff {f : α → β → Option σ} :
    (Primrec₂ fun a n => (@decode β _ n).bind (f a)) ↔ Primrec₂ f 


Original valid proof:
:=
  ⟨fun h => by simpa [encodek] using h.comp fst ((@Primrec.encode β _).comp snd), fun h =>
    option_bind (Primrec.decode.comp snd) <| h.comp (fst.comp fst) snd⟩


Verifying proof (Commit b912476b37f2ea41ee51af7e63439f4a769be095):
∧ Primrec (decode : β → Option β) :=
  ⟨fun h =>
    ⟨h.comp snd fst,
      (ofOption (snd.comp snd)).of_eq fun b => by cases @decode β _ b <;> rfl⟩,
    fun h => h.1.bind h.2⟩


theorem map_decode_iff {f : α → β → σ} :
    (Primrec₂ fun a n => (@decode β _ n).map (f a)) ↔ Primrec₂ f ∧ Primrec (decode : β → Option β) := by
  simp only [Option.map, bind_decode_iff, Primrec.option_some_iff, and_left_comm, and_self]


theorem nat_add : Primrec₂ ((· + ·) : ℕ → ℕ → ℕ) :=
  Primrec₂.unpaired'.1 Nat.Primrec.add


theorem nat_sub : Primrec₂ ((· - ·) : ℕ → ℕ → ℕ) :=
  Primrec₂.unpaired'.1 Nat.Primrec.sub


theorem nat_eq : Primrec₂ ((· = ·) : ℕ → ℕ → Bool) :=
  Primrec₂.unpaired'.1 Nat.Primrec.eq


theorem nat_le : Primrec₂ ((· ≤ ·) : ℕ → ℕ → Bool) :=
  Primrec₂.unpaired'.1 Nat.Primrec.le


theorem nat_lt : Primrec₂ ((· < ·) : ℕ → ℕ → Bool) :=
  Primrec₂.unpaired'.1 Nat.Primrec.lt


theorem cond {c : α → Bool} {f : α → σ} {g : α → σ} (hc : Primrec c) (hf : Primrec f)
    (hg : Primrec g) : Primrec fun a => bif (c a) then (f a) else (g a) :=
  (nat_casesOn (encode_iff.2 hc) hg (hf.comp fst).to₂).of_eq fun a => by cases c a <;> rfl


theorem ite {c : α → Prop} [DecidablePred c] {f : α → σ} {g : α → σ} (hc : PrimrecPred c)
    (hf : Primrec f) (hg : Primrec g) : Primrec fun a => if c a then f a else g a := by
  simpa [Bool.cond_decide] using cond hc hf hg


theorem nat_le_dec : PrimrecRel ((· ≤ ·) : ℕ → ℕ → Prop) :=
  PrimrecRel.le


theorem nat_lt_dec : PrimrecRel ((· < ·) : ℕ → ℕ → Prop) :=
  PrimrecRel.lt


theorem option_guard {p : α → β → Prop} [∀ a b, Decidable (p a b)] (hp : PrimrecRel p) {f : α → β}
    (hf : Primrec f) : Primrec fun a => Option.guard (p a) (f a) :=
  ite (hp.comp Primrec.id hf) (option_some_iff.2 hf) (const none)


theorem option_orElse' : Primrec₂ ((· <|> ·) : Option α → Option α → Option α) :=
  (option_casesOn fst snd (fst.comp fst).to₂).of_eq fun ⟨o₁, o₂⟩ => by cases o₁ <;> cases o₂ <;> rfl


theorem option_orElse : Primrec₂ ((· <|> ·) : Option α → Option α → Option α) :=
  option_orElse'.comp fst (snd.comp snd)


theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Primrec f) (hg : Primrec₂ g) :
    Primrec fun a => (f a).bind (g a) :=
  (option_casesOn hf (const none) (hg.comp (fst.comp fst) snd).to₂).of_eq fun a => by cases f a <;> rfl


theorem option_map {f : α → Option β} {g : α → β → σ} (hf : Primrec f) (hg : Primrec₂ g) :
    Primrec fun a => (f a).map (g a) := by
  simp [Option.map, hf, option_bind hf (hg.comp fst (snd.comp snd))]


theorem option_get {f : α → Option β} {g : α → β → σ} (hf : Primrec f) (hg : Primrec₂ g) :
    Primrec fun a => (f a).getD (g a) :=
  (option_casesOn hf (hg.comp fst (snd.comp snd)) (const none)).of_eq fun a => by cases f a <;> rfl


theorem option_getD_default {f : α → Option β} {g : α → β} (hf : Primrec f) (hg : Primrec g) :
    Primrec fun a => (f a).getD (g a) :=
  option_get hf (hg.comp fst snd)


theorem option_getD_default_left {g : α → Option β} {h : α → β} (hg : Primrec g) (hh : Primrec h) :
    Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd)


theorem option_getD_default_right {g : α → Option β} {h : β → α → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd fst)


theorem option_getD_default_default {g : α → Option β} {h : α → β → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd snd)


theorem option_getD_default_right' {g : α → Option β} {h : β → α → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd fst)


theorem option_getD_default_default' {g : α → Option β} {h : α → β → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd snd)


theorem option_getD_default_right'' {g : α → Option β} {h : β → α → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd fst)


theorem option_getD_default_default'' {g : α → Option β} {h : α → β → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd snd)


theorem option_getD_default_right''' {g : α → Option β} {h : β → α → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd fst)


theorem option_getD_default_default''' {g : α → Option β} {h : α → β → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd snd)


theorem option_getD_default_right'''' {g : α → Option β} {h : β → α → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd fst)


theorem option_getD_default_default'''' {g : α → Option β} {h : α → β → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd snd)


theorem option_getD_default_right''''' {g : α → Option β} {h : β → α → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd fst)


theorem option_getD_default_default''''' {g : α → Option β} {h : α → β → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd snd)


theorem option_getD_default_right'''''' {g : α → Option β} {h : β → α → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd fst)


theorem option_getD_default_default'''''' {g : α → Option β} {h : α → β → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd snd)


theorem option_getD_default_right''''''' {g : α → Option β} {h : β → α → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd fst)


theorem option_getD_default_default''''''' {g : α → Option β} {h : α → β → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd snd)


theorem option_getD_default_right'''''''' {g : α → Option β} {h : β → α → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd fst)


theorem option_getD_default_default'''''''' {g : α → Option β} {h : α → β → σ} (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => (g a).getD (h a) :=
  option_getD (option_map (Primrec.id.comp fst) hg) (hh.comp snd snd)


theorem option_getD_default_right''''''''' {g : α → Option β} {

Attempt failure.

---64/200---
For theorem Nat.Primrec'.vec_iff in Mathlib/Computability/Primrec.lean:
theorem vec_iff {m n f} : @Vec m n f ↔ Primrec f 


Original valid proof:
:=
  ⟨fun h => by simpa using Primrec.vector_ofFn fun i => to_prim (h i), fun h i =>
    of_prim <| Primrec.vector_get.comp h (.const i)⟩


Verifying proof (Commit b912476b37f2ea41ee51af7e63439f4a769be095):
∧ ∀ a, Vec (f a) :=
  ⟨fun h => ⟨h.prim, fun a => h.prim.comp (const a)⟩, fun ⟨h₁, h₂⟩ =>
    ⟨h₁, fun i => by simpa using h₂ i⟩⟩

Attempt failure.

---65/200---
For theorem Primcodable.mem_range_encode in Mathlib/Computability/Primrec.lean:
theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) 


Original valid proof:
:=
  have : PrimrecPred fun n => Encodable.decode₂ α n ≠ none :=
    .not
      (Primrec.eq.comp
        (.option_bind .decode
          (.ite (Primrec.eq.comp (Primrec.encode.comp .snd) .fst)
            (Primrec.option_some.comp .snd) (.const _)))
        (.const _))
  this.of_eq fun _ => decode₂_ne_none_iff


Verifying proof (Commit b912476b37f2ea41ee51af7e63439f4a769be095):
∧
  PrimrecPred (fun n => n ∈ Set.range (decode : ℕ → Option α)) := by
  constructor
  · exact (PrimrecPred.of_eq (Primrec.nat_iff.2 Primrec.encode) fun n => by simp [encodek])
  · exact (PrimrecPred.of_eq (Primrec.nat_iff.2 Primrec.decode) fun n => by simp [decode_eq_of_mem])


theorem nat_iff_lt_card_mk : PrimrecPred fun n : ℕ => n < Cardinal.mk α := by
  simp only [Cardinal.lt_def, Cardinal.mk_ord_out]
  exact PrimrecPred.of_eq (Primrec.nat_lt.comp .id (Primrec.nat_card.comp Primrec.id)) fun n => by
    simp


theorem nat_iff_lt_card : PrimrecPred (· < Cardinal.mk α) := nat_iff_lt_card_mk


theorem nat_le_card : PrimrecPred (· ≤ Cardinal.mk α) :=
  have : PrimrecPred fun n : ℕ => n ≤ Cardinal.mk α :=
    PrimrecPred.of_eq nat_iff_lt_card_mk fun n => by simp [not_le]
  this.of_eq fun n => by simp


theorem le_card : PrimrecPred (· ≤ Cardinal.mk α) := nat_le_card


theorem lt_card : PrimrecPred (· < Cardinal.mk α) := nat_lt_card


theorem mem_card : PrimrecPred (· ∈ Cardinal.mk α) := nat_mem_card


theorem mem_finset_card : PrimrecPred (· ∈ Finset.card α) := nat_mem_finset_card
```

Attempt failure.

Working on Mathlib/Data/DFinsupp/Basic.lean - 2024-09-08 18:28:50.374066.
---66/200---
For theorem DFinsupp.filter_single in Mathlib/Data/DFinsupp/Basic.lean:
theorem filter_single (p : ι → Prop) [DecidablePred p] (i : ι) (x : β i) :
    (single i x).filter p = if p i then single i x else 0 


Original valid proof:
:= by
  ext j
  have := apply_ite (fun x : Π₀ i, β i => x j) (p i) (single i x) 0
  dsimp at this
  rw [filter_apply, this]
  obtain rfl | hij := Decidable.eq_or_ne i j
  · rfl
  · rw [single_eq_of_ne hij, ite_self, ite_self]


Verifying proof (Commit 166d0bf5448fdaad518cf95891af45e08a3e9c35):
 := by
  ext j
  have := apply_ite (fun x : Π₀ i, β i => x j) (p i) (single i x) 0
  dsimp at this
  rw [filter_apply, this]
  obtain rfl | hij := Decidable.eq_or_ne i j
  · rfl
  rw [single_eq_of_ne hij, ite_self, ite_self]


theorem filter_single_pos {p : ι → Prop} [DecidablePred p] (i : ι) (x : β i) (h : p i) :
    (single i x).filter p = single i x := by rw [filter_single, if_pos h]


theorem filter_single_neg {p : ι → Prop} [DecidablePred p] (i : ι) (x : β i) (h : ¬p i) :
    (single i x).filter p = 0 := by rw [filter_single, if_neg h]


theorem filter_eq_indicator {p : ι → Prop} [DecidablePred p] (f : Π₀ i, β i) :
    f.filter p =
      { f.support.filter p |>.indicator fun i => f i } := by
  ext i
  by_cases h : p i <;> simp [h]

theorem filter_eq_subtype {p : ι → Prop} [DecidablePred p] (f : Π₀ i, β i) :
    f.filter p =
      (f.support.subtype p).equivSubtype.symm.toDFinsupp fun i => f i := by
  ext ⟨i, hi⟩
  simp [filter_apply, hi]

theorem filter_eq_subtype' {p : ι → Prop} [DecidablePred p] (f : Π₀ i, β i) :
    f.filter p =
      (f.support.subtype p).equivSubtype.symm.toDFinsupp fun i => f i := by
  ext i
  simp [filter_apply, i.2]
```

Attempt failure.

Working on Mathlib/Data/Finset/Image.lean - 2024-09-08 18:29:24.334954.
---67/200---
For theorem Finset.image_symmDiff in Mathlib/Data/Finset/Image.lean:
theorem image_symmDiff [DecidableEq α] {f : α → β} (s t : Finset α) (hf : Injective f) :
    (s ∆ t).image f = s.image f ∆ t.image f 


Original valid proof:
:=
  mod_cast Set.image_symmDiff hf s t


Verifying proof (Commit b0304b2532b035fd00ff51805ac89317b4114265):
∧ (s ∆ t).image f = (s.image f)ᶜ ∆ (t.image f)ᶜ := by
  simp only [← coe_inj, coe_image, coe_symmDiff, coe_compl]
  push_cast
  apply Set.image_symmDiff
  exact hf
```

Attempt failure.

Working on Mathlib/Data/Finset/Lattice.lean - 2024-09-08 18:29:50.785452.
---68/200---
For theorem Finset.mem_of_max in Mathlib/Data/Finset/Lattice.lean:
theorem mem_of_max {s : Finset α} : ∀ {a : α}, s.max = a → a ∈ s 


Original valid proof:
:= by
  induction' s using Finset.induction_on with b s _ ih
  · intro _ H; cases H
  · intro a h
    by_cases p : b = a
    · induction p
      exact mem_insert_self b s
    · cases' max_choice (↑b) s.max with q q <;> rw [max_insert, q] at h
      · cases h
        cases p rfl
      · exact mem_insert_of_mem (ih h)


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
∧ ∀ b ∈ s, b ≤ a := by
  intro a h
  have ⟨b, hb⟩ := Finset.max_of_nonempty (show s.Nonempty by simpa [Finset.max_eq_bot] using h)
  simp only [Finset.max_eq_right hb.1, hb.2] at h
  simp [h]

theorem max_of_mem {s : Finset α} {a : α} (h : a ∈ s) : ∃ b, s.max = b ∧ a ≤ b := by
  obtain ⟨b, hb⟩ := Finset.max_of_nonempty (show s.Nonempty by simpa using h)
  exact ⟨b, hb.1, hb.2 _ h⟩

theorem max_of_mem' {s : Finset α} {a : α} (h : a ∈ s) : ∃ b, s.max = a ∧ b ≤ a := by
  obtain ⟨b, hb⟩ := Finset.max_of_nonempty (show s.Nonempty by simpa using h)
  exact ⟨b, hb.1, hb.2 _ h⟩

theorem max_of_subset_of_max_mem {s t : Finset α} (hst : s ⊆ t) {a : α} (ha : a ∈ s)
    (h : t.max = a) : s.max = a :=
  le_antisymm (max_le_of_mem ha <| h ▸ (hst ha)) <| le_max_of_mem (hst ha) h


theorem max_of_eq {s t : Finset α} (hst : s = t) {a : α} (ha : a ∈ s) (hb : t.max = a) :
    s.max = a :=
  max_of_subset_of_max_mem (hst ▸ Subset.refl t) ha hb


theorem max_of_eq_of_mem {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq rfl h h'


theorem max_of_subset {s t : Finset α} (h : s ⊆ t) (ht : t.Nonempty) : s.max ≤ t.max :=
  max_mono h ht


theorem max_of_eq_of_mem {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq rfl h h'


theorem max_of_eq_of_mem' {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq rfl h h'


theorem max_of_subset_of_max_mem {s t : Finset α} (hst : s ⊆ t) {a : α} (ha : a ∈ s)
    (h : t.max = a) : s.max = a :=
  max_of_subset_of_max_mem hst ha h


theorem max_of_eq {s t : Finset α} (hst : s = t) {a : α} (ha : a ∈ s) (hb : t.max = a) :
    s.max = a :=
  max_of_eq_of_mem ha (hst ▸ hb)


theorem max_of_eq_of_mem {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_eq_of_mem' {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_subset_of_max_mem {s t : Finset α} (hst : s ⊆ t) {a : α} (ha : a ∈ s)
    (h : t.max = a) : s.max = a :=
  max_of_subset_of_max_mem hst ha h


theorem max_of_eq {s t : Finset α} (hst : s = t) {a : α} (ha : a ∈ s) (hb : t.max = a) :
    s.max = a :=
  max_of_eq_of_mem ha (hst ▸ hb)


theorem max_of_eq_of_mem {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_eq_of_mem' {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_subset_of_max_mem {s t : Finset α} (hst : s ⊆ t) {a : α} (ha : a ∈ s)
    (h : t.max = a) : s.max = a :=
  max_of_subset_of_max_mem hst ha h


theorem max_of_eq {s t : Finset α} (hst : s = t) {a : α} (ha : a ∈ s) (hb : t.max = a) :
    s.max = a :=
  max_of_eq_of_mem ha (hst ▸ hb)


theorem max_of_eq_of_mem {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_eq_of_mem' {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_subset_of_max_mem {s t : Finset α} (hst : s ⊆ t) {a : α} (ha : a ∈ s)
    (h : t.max = a) : s.max = a :=
  max_of_subset_of_max_mem hst ha h


theorem max_of_eq {s t : Finset α} (hst : s = t) {a : α} (ha : a ∈ s) (hb : t.max = a) :
    s.max = a :=
  max_of_eq_of_mem ha (hst ▸ hb)


theorem max_of_eq_of_mem {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_eq_of_mem' {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_subset_of_max_mem {s t : Finset α} (hst : s ⊆ t) {a : α} (ha : a ∈ s)
    (h : t.max = a) : s.max = a :=
  max_of_subset_of_max_mem hst ha h


theorem max_of_eq {s t : Finset α} (hst : s = t) {a : α} (ha : a ∈ s) (hb : t.max = a) :
    s.max = a :=
  max_of_eq_of_mem ha (hst ▸ hb)


theorem max_of_eq_of_mem {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_eq_of_mem' {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_subset_of_max_mem {s t : Finset α} (hst : s ⊆ t) {a : α} (ha : a ∈ s)
    (h : t.max = a) : s.max = a :=
  max_of_subset_of_max_mem hst ha h


theorem max_of_eq {s t : Finset α} (hst : s = t) {a : α} (ha : a ∈ s) (hb : t.max = a) :
    s.max = a :=
  max_of_eq_of_mem ha (hst ▸ hb)


theorem max_of_eq_of_mem {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_eq_of_mem' {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_subset_of_max_mem {s t : Finset α} (hst : s ⊆ t) {a : α} (ha : a ∈ s)
    (h : t.max = a) : s.max = a :=
  max_of_subset_of_max_mem hst ha h


theorem max_of_eq {s t : Finset α} (hst : s = t) {a : α} (ha : a ∈ s) (hb : t.max = a) :
    s.max = a :=
  max_of_eq_of_mem ha (hst ▸ hb)


theorem max_of_eq_of_mem {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_eq_of_mem' {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_subset_of_max_mem {s t : Finset α} (hst : s ⊆ t) {a : α} (ha : a ∈ s)
    (h : t.max = a) : s.max = a :=
  max_of_subset_of_max_mem hst ha h


theorem max_of_eq {s t : Finset α} (hst : s = t) {a : α} (ha : a ∈ s) (hb : t.max = a) :
    s.max = a :=
  max_of_eq_of_mem ha (hst ▸ hb)


theorem max_of_eq_of_mem {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_eq_of_mem' {s : Finset α} {a : α} (h : a ∈ s) (h' : s.max = a) : s.max = a :=
  max_of_eq_of_mem h h'


theorem max_of_subset_of_max_mem {s t : Finset α} (hst : s ⊆ t) {a : α} (ha : a ∈ s)
    (h : t.max = a) : s.max = a :=
  max_of_subset_of_max_mem hst ha h


theorem max_of_eq {s t : Finset α} (hst : s =

Attempt failure.

Working on Mathlib/Data/List/Cycle.lean - 2024-09-08 18:30:17.428218.
---69/200---
For theorem List.prev_next in Mathlib/Data/List/Cycle.lean:
theorem prev_next (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :
    prev l (next l x hx) (next_mem _ _ _) = x 


Original valid proof:
:= by
  obtain ⟨n, hn, rfl⟩ := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  · simp at hx
  · have : (n + 1 + length tl) % (length tl + 1) = n := by
      rw [length_cons] at hn
      rw [add_assoc, add_comm 1, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp only [length_cons, Nat.succ_sub_succ_eq_sub, Nat.sub_zero, Nat.succ_eq_add_one, this]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧ next l (prev l x hx) (prev_mem _ _ _) = x := by
  cases' l with y l
  · cases hx
  cases' l with z l
  · simp [prev, next] at hx
    subst hx
    simp [prev, next, h]
  simp only [nodup_cons, mem_cons, not_or, forall_eq_or_imp] at h
  simp only [prev, next, h]
  split_ifs with hz hxz
  · subst hz
    simp [h.1]
  · split_ifs with hxy
    · subst hxy
      simp [h.1]
    · simp [h.2.2 hxz, h.2.2 hxy]
```

Attempt failure.

Working on Mathlib/Data/List/Indexes.lean - 2024-09-08 18:30:28.317784.
---70/200---
For theorem List.mapIdx_append in Mathlib/Data/List/Indexes.lean:
theorem mapIdx_append_one : ∀ (f : ℕ → α → β) (l : List α) (e : α),
    mapIdx f (l ++ [e]) = mapIdx f l ++ [f l.length e] 


Original valid proof:
:= by
  intros f l e
  unfold mapIdx
  rw [mapIdxGo_append f l [e]]
  simp only [mapIdx.go, Array.size_toArray, mapIdxGo_length, length_nil, Nat.add_zero,
    Array.toList_eq, Array.push_data, Array.data_toArray]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  intro f l e
  induction l with
  | nil => simp
  | cons a l' ih =>
    simp [mapIdx, ih]
    rw [Nat.add_comm]
    rfl

theorem mapIdx_append : ∀ (f : ℕ → α → β) (l₁ l₂ : List α),
    mapIdx f (l₁ ++ l₂) = mapIdx f l₁ ++ mapIdx f l₂ := by
  intro f l₁ l₂
  induction l₁ with
  | nil => simp
  | cons a l₁' ih =>
    simp [mapIdx, ih]
    rw [Nat.add_comm]
    rfl

theorem mapIdx_eq_enum_map : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (Function.uncurry f) := by
  intro f l
  induction l with
  | nil => simp
  | cons a l' ih =>
    simp [mapIdx, ih, enum, Function.uncurry]
    rw [Nat.add_comm]
    rfl

theorem mapIdx_eq_enum_map' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun (i, a) => f i a) := by
  intro f l
  rw [mapIdx_eq_enum_map]
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.1 x.2) := by
  intro f l
  rw [mapIdx_eq_enum_map']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd]
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd'']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd'''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'''''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''''''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'''''''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''''''''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'''''''''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''''''''''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'''''''''''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''''''''''''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd'''''''''''''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.fst x.snd) := by
  intro f l
  rw [mapIdx_eq_enum_map_snd''''''']
  congr
  funext x
  cases x with
  | mk i a => rfl

theorem mapIdx_eq_enum_map_snd''''''''''''''''''''''''' : ∀ (f : ℕ → α → β) (l : List α),
    mapIdx f l = l.enum.map (fun x => f x.f

Attempt failure.

Working on Mathlib/Data/List/NodupEquivFin.lean - 2024-09-08 18:30:39.192497.
---71/200---
For theorem List.duplicate_iff_exists_distinct_get in Mathlib/Data/List/NodupEquivFin.lean:
theorem duplicate_iff_exists_distinct_get {l : List α} {x : α} :
    l.Duplicate x ↔
      ∃ (n m : Fin l.length) (_ : n < m),
        x = l.get n ∧ x = l.get m 


Original valid proof:
:= by
  classical
    rw [duplicate_iff_two_le_count, le_count_iff_replicate_sublist,
      sublist_iff_exists_fin_orderEmbedding_get_eq]
    constructor
    · rintro ⟨f, hf⟩
      refine ⟨f ⟨0, by simp⟩, f ⟨1, by simp⟩, f.lt_iff_lt.2 (Nat.zero_lt_one), ?_⟩
      rw [← hf, ← hf]; simp
    · rintro ⟨n, m, hnm, h, h'⟩
      refine ⟨OrderEmbedding.ofStrictMono (fun i => if (i : ℕ) = 0 then n else m) ?_, ?_⟩
      · rintro ⟨⟨_ | i⟩, hi⟩ ⟨⟨_ | j⟩, hj⟩
        · simp
        · simp [hnm]
        · simp
        · simp only [Nat.lt_succ_iff, Nat.succ_le_succ_iff, replicate, length, Nat.le_zero] at hi hj
          simp [hi, hj]
      · rintro ⟨⟨_ | i⟩, hi⟩
        · simpa using h
        · simpa using h'


Verifying proof (Commit 3cb2bdef8481160ee4f3f3a94fca1f5824c2798a):
∧ n.1 ≠ m.1 := by
  simp_rw [Duplicate, exists_distinct_get]
  refine ⟨fun ⟨n, m, h, xeq, heq⟩ ↦ ⟨n, m, h, xeq, heq, h.ne⟩,
    fun ⟨n, m, h, xeq, heq, hne⟩ ↦ ⟨n, m, h, xeq, heq⟩⟩

/-- The contrapositive form of `List.duplicate_iff_exists_distinct_get`. -/
theorem not_duplicate_iff_forall_distinct_get {l : List α} {x : α} :
    ¬ l.Duplicate x ↔ ∀ (n m : Fin l.length), n < m → l.get n ≠ x ∨ l.get m ≠ x := by
  rw [duplicate_iff_exists_distinct_get, not_exists, not_exists, not_and, not_and]
  exact forall_swap

/-- The contrapositive form of `List.duplicate_iff_exists_distinct_get`. -/
theorem not_duplicate_iff_forall_get_ne {l : List α} {x : α} :
    ¬ l.Duplicate x ↔ ∀ (n : Fin l.length), l.get n ≠ x := by
  rw [not_duplicate_iff_forall_distinct_get]
  refine ⟨fun h n m hnm ↦ (h n m hnm).elim, fun h n m hnm ↦ ?_⟩
  rcases lt_trichotomy n m with (hnm | rfl | hnm)
  · exact Or.inl (h n)
  · exact (hnm.ne rfl).elim
  · exact Or.inr (h m)
```

Attempt failure.

Working on Mathlib/Data/List/Zip.lean - 2024-09-08 18:30:48.037437.
---72/200---
For theorem List.get?_zip_with_eq_some in Mathlib/Data/List/Zip.lean:
theorem get?_zip_with_eq_some (f : α → β → γ) (l₁ : List α) (l₂ : List β) (z : γ) (i : ℕ) :
    (zipWith f l₁ l₂).get? i = some z ↔
      ∃ x y, l₁.get? i = some x ∧ l₂.get? i = some y ∧ f x y = z 


Original valid proof:
:= by
  simp [getElem?_zip_with_eq_some]


Verifying proof (Commit 561da585a69fbbdde80bd939bbe9557293b5250e):
∧ i < min l₁.length l₂.length := by
  induction' l₁ with a₁ l₁ IH generalizing l₂ i
  · simp [zipWith]
  cases' l₂ with a₂ l₂
  · simp [zipWith]
  cases' i with i
  · simp [get?, head?, tail?_cons, zipWith]
    constructor
    · rintro ⟨x, y, h₁, h₂, h₃⟩
      exact ⟨x, y, h₁, h₂, h₃, Nat.zero_lt_succ _⟩
    · rintro ⟨x, y, h₁, h₂, h₃, h₄⟩
      exact ⟨x, y, h₁, h₂, h₃⟩
  · simp only [get?, head?, tail?_cons, zipWith] at *
    simp only [IH, Option.map_eq_some', exists_and_left, exists_and_right, exists_eq_left,
      exists_eq_right, Nat.succ_lt_succ_iff]
    constructor
    · rintro ⟨x, y, h₁, h₂, h₃⟩
      exact ⟨x, y, h₁, h₂, h₃, Nat.succ_lt_succ_iff.mp h₄⟩
    · rintro ⟨x, y, h₁, h₂, h₃, h₄⟩
      exact ⟨x, y, h₁, h₂, h₃⟩


theorem get?_zip_with_eq_some' (f : α → β → γ) (l₁ : List α) (l₂ : List β) (z : γ) (i : ℕ) :
    (zipWith f l₁ l₂).get? i = some z ↔
      ∃ x y, l₁.get? i = some x ∧ l₂.get? i = some y ∧ f x y = z := by
  rw [get?_zip_with_eq_some]
  constructor
  · rintro ⟨x, y, h₁, h₂, h₃, h₄⟩
    exact ⟨x, y, h₁, h₂, h₃⟩
  · rintro ⟨x, y, h₁, h₂, h₃⟩
    exact ⟨x, y, h₁, h₂, h₃, Nat.lt_of_le_of_lt (min_le_left _ _) (length_pos_of_get? h₁)⟩
```

Attempt failure.

Working on Mathlib/Data/Nat/Choose/Central.lean - 2024-09-08 18:31:14.107922.
---73/200---
For theorem Nat.four_pow_le_two_mul_self_mul_centralBinom in Mathlib/Data/Nat/Choose/Central.lean:
theorem four_pow_le_two_mul_self_mul_centralBinom :
    ∀ (n : ℕ) (_ : 0 < n), 4 ^ n ≤ 2 * n * centralBinom n



Original valid proof:
  | 0, pr => (Nat.not_lt_zero _ pr).elim
  | 1, _ => by norm_num [centralBinom, choose]
  | 2, _ => by norm_num [centralBinom, choose]
  | 3, _ => by norm_num [centralBinom, choose]
  | n + 4, _ =>
    calc
      4 ^ (n+4) ≤ (n+4) * centralBinom (n+4) := (four_pow_lt_mul_centralBinom _ le_add_self).le
      _ ≤ 2 * (n+4) * centralBinom (n+4) := by
        rw [mul_assoc]; refine Nat.le_mul_of_pos_left _ zero_lt_two


Verifying proof (Commit 9f6d33884de569540c527b667d1573e1b97e1347):
  | 0, h => absurd h (Nat.not_lt_zero _)
  | 1, _ => by norm_num
  | n + 2, _ => by
    have IH1 : 4 ^ (n + 1) ≤ 2 * (n + 1) * centralBinom (n + 1) :=
      four_pow_le_two_mul_self_mul_centralBinom (n + 1) (Nat.succ_pos _)
    have IH2 : 4 ^ (n + 2) ≤ 2 * (n + 2) * centralBinom (n + 2) :=
      four_pow_le_two_mul_self_mul_centralBinom (n + 2) (Nat.succ_pos _)
    rw [pow_succ, mul_comm] at IH1
    rw [pow_succ, pow_succ, mul_comm, mul_assoc] at IH2
    calc
      4 ^ (n + 2) = 4 * 4 ^ (n + 1) := by rw [pow_succ, pow_succ, mul_comm]
      _ ≤ 4 * (2 * (n + 1) * centralBinom (n + 1)) := by gcongr
      _ ≤ 2 * (n + 2) * centralBinom (n + 2) := by
        rw [mul_assoc, mul_assoc, ← mul_add, ←
          (by rw [Nat.mul_one, Nat.add_comm, Nat.add_sub_assoc (Nat.le_refl 2) n] :
            (n + 2) * (2 * centralBinom (n + 2)) = 2 * (n + 2) * centralBinom (n + 2))]
        exact le_trans (Nat.mul_le_mul_left _ IH1) IH2


/-- **Vandermonde's Identity** -/
theorem sum_mul_centralBinom_eq_add :
    ∀ (m n : ℕ), ∑ k ∈ range (m + 1), k * choose (m + n) k * choose (m + n - k) m =
      choose (2 * m + n) m * choose (m + n) m := by
  intro m
  induction' m with m IH
  · intro n
    simp
  · intro n
    rw [sum_range_succ, choose_succ_succ, add_mul, add_mul, IH, add_comm n 1,
      choose_succ_succ, add_assoc, add_assoc]
    simp only [← mul_assoc, mul_comm]
    congr 2
    by_cases h : n < m + 1
    · rw [choose_eq_zero_of_lt h, Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
      by_cases h' : m + 1 ≤ n + 1
      · rw [choose_eq_zero_of_lt (Nat.lt_of_succ_le h'), Nat.zero_mul, Nat.mul_zero,
          Nat.zero_add]
      · rw [choose_eq_zero_of_lt (lt_of_le_of_lt (Nat.succ_le_succ_iff.mp
            (Nat.lt_of_not_le h')) (Nat.lt_succ_self _)),
          Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
    · rw [Nat.not_lt_iff_eq_or_lt] at h
      cases' h with h h
      · rw [h, Nat.add_comm n 1, Nat.add_sub_cancel, choose_succ_succ, Nat.add_comm,
          Nat.add_sub_cancel, mul_comm (choose (m + n) (m + 1)), ← mul_assoc,
          Nat.add_mul_choose_eq, Nat.add_mul_choose_eq, Nat.add_sub_cancel]
      · have h' : n + 1 < m + 1 := lt_of_lt_of_le h (Nat.succ_le_succ_iff.mp (Nat.le_add_left _ _))
        rw [choose_eq_zero_of_lt h', Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
        by_cases h'' : m + 1 ≤ n + 1
        · rw [choose_eq_zero_of_lt (Nat.lt_of_succ_le h''), Nat.zero_mul, Nat.mul_zero,
            Nat.zero_add]
        · rw [choose_eq_zero_of_lt (lt_of_le_of_lt (Nat.succ_le_succ_iff.mp
              (Nat.lt_of_not_le h'')) (Nat.lt_succ_self _)),
            Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
  · intro n
    simp_rw [choose_succ_succ, add_mul, mul_add, add_assoc, add_assoc, mul_assoc, mul_assoc]
    simp only [← mul_assoc, mul_comm]
    congr 2
    by_cases h : n < m
    · rw [choose_eq_zero_of_lt h, Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
      by_cases h' : m ≤ n
      · rw [choose_eq_zero_of_lt (Nat.lt_of_le_of_lt h' (Nat.lt_succ_self _)),
          Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
      · rw [choose_eq_zero_of_lt (lt_of_le_of_lt (Nat.succ_le_succ_iff.mp
            (Nat.lt_of_not_le h')) (Nat.lt_succ_self _)),
          Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
    · rw [Nat.not_lt_iff_eq_or_lt] at h
      cases' h with h h
      · rw [h, Nat.add_comm n 1, Nat.add_sub_cancel, choose_succ_succ, Nat.add_comm,
          Nat.add_sub_cancel, mul_comm (choose (m + n) (m + 1)), ← mul_assoc,
          Nat.add_mul_choose_eq, Nat.add_mul_choose_eq, Nat.add_sub_cancel]
      · have h' : n < m := lt_of_lt_of_le h (Nat.succ_le_succ_iff.mp (Nat.le_add_left _ _))
        rw [choose_eq_zero_of_lt h', Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
        by_cases h'' : m ≤ n
        · rw [choose_eq_zero_of_lt (Nat.lt_of_succ_le h''), Nat.zero_mul, Nat.mul_zero,
            Nat.zero_add]
        · rw [choose_eq_zero_of_lt (lt_of_le_of_lt (Nat.succ_le_succ_iff.mp
              (Nat.lt_of_not_le h'')) (Nat.lt_succ_self _)),
            Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
  · intro n
    simp_rw [choose_succ_succ, add_mul, mul_add, add_assoc, add_assoc, mul_assoc, mul_assoc]
    simp only [← mul_assoc, mul_comm]
    congr 2
    by_cases h : n < m
    · rw [choose_eq_zero_of_lt h, Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
      by_cases h' : m ≤ n
      · rw [choose_eq_zero_of_lt (Nat.lt_of_le_of_lt h' (Nat.lt_succ_self _)),
          Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
      · rw [choose_eq_zero_of_lt (lt_of_le_of_lt (Nat.succ_le_succ_iff.mp
            (Nat.lt_of_not_le h')) (Nat.lt_succ_self _)),
          Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
    · rw [Nat.not_lt_iff_eq_or_lt] at h
      cases' h with h h
      · rw [h, Nat.add_comm n 1, Nat.add_sub_cancel, choose_succ_succ, Nat.add_comm,
          Nat.add_sub_cancel, mul_comm (choose (m + n) (m + 1)), ← mul_assoc,
          Nat.add_mul_choose_eq, Nat.add_mul_choose_eq, Nat.add_sub_cancel]
      · have h' : n < m := lt_of_lt_of_le h (Nat.succ_le_succ_iff.mp (Nat.le_add_left _ _))
        rw [choose_eq_zero_of_lt h', Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
        by_cases h'' : m ≤ n
        · rw [choose_eq_zero_of_lt (Nat.lt_of_succ_le h''), Nat.zero_mul, Nat.mul_zero,
            Nat.zero_add]
        · rw [choose_eq_zero_of_lt (lt_of_le_of_lt (Nat.succ_le_succ_iff.mp
              (Nat.lt_of_not_le h'')) (Nat.lt_succ_self _)),
            Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
  · intro n
    simp_rw [choose_succ_succ, add_mul, mul_add, add_assoc, add_assoc, mul_assoc, mul_assoc]
    simp only [← mul_assoc, mul_comm]
    congr 2
    by_cases h : n < m
    · rw [choose_eq_zero_of_lt h, Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
      by_cases h' : m ≤ n
      · rw [choose_eq_zero_of_lt (Nat.lt_of_le_of_lt h' (Nat.lt_succ_self _)),
          Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
      · rw [choose_eq_zero_of_lt (lt_of_le_of_lt (Nat.succ_le_succ_iff.mp
            (Nat.lt_of_not_le h')) (Nat.lt_succ_self _)),
          Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
    · rw [Nat.not_lt_iff_eq_or_lt] at h
      cases' h with h h
      · rw [h, Nat.add_comm n 1, Nat.add_sub_cancel, choose_succ_succ, Nat.add_comm,
          Nat.add_sub_cancel, mul_comm (choose (m + n) (m + 1)), ← mul_assoc,
          Nat.add_mul_choose_eq, Nat.add_mul_choose_eq, Nat.add_sub_cancel]
      · have h' : n < m := lt_of_lt_of_le h (Nat.succ_le_succ_iff.mp (Nat.le_add_left _ _))
        rw [choose_eq_zero_of_lt h', Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
        by_cases h'' : m ≤ n
        · rw [choose_eq_zero_of_lt (Nat.lt_of_succ_le h''), Nat.zero_mul, Nat.mul_zero,
            Nat.zero_add]
        · rw [choose_eq_zero_of_lt (lt_of_le_of_lt (Nat.succ_le_succ_iff.mp
              (Nat.lt_of_not_le h'')) (Nat.lt_succ_self _)),
            Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
  · intro n
    simp_rw [choose_succ_succ, add_mul, mul_add, add_assoc, add_assoc, mul_assoc, mul_assoc]
    simp only [← mul_assoc, mul_comm]
    congr 2
    by_cases h : n < m
    · rw [choose_eq_zero_of_lt h, Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
      by_cases h' : m ≤ n
      · rw [choose_eq_zero_of_lt (Nat.lt_of_le_of_lt h' (Nat.lt_succ_self _)),
          Nat.zero_mul, Nat.mul_zero, Nat.zero_add]
      · rw [choose_eq_zero_of_lt (lt_of_le_of_lt (Nat.succ_le_succ

Attempt failure.

Working on Mathlib/Data/Nat/Log.lean - 2024-09-08 18:31:23.786532.
---74/200---
For theorem Nat.pow_le_iff_le_log in Mathlib/Data/Nat/Log.lean:
theorem pow_le_iff_le_log {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) :
    b ^ x ≤ y ↔ x ≤ log b y 


Original valid proof:
:= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => dsimp; omega
  | succ x =>
    rw [log]; split_ifs with h
    · have b_pos : 0 < b := lt_of_succ_lt hb
      rw [Nat.add_le_add_iff_right, ← ih (y / b) (div_lt_self
        (Nat.pos_iff_ne_zero.2 hy) hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', Nat.mul_comm]
    · exact iff_of_false (fun hby => h ⟨(le_self_pow x.succ_ne_zero _).trans hby, hb⟩)
        (not_succ_le_zero _)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ y ≤ b ^ x := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · have hb' : 0 < b := lt_of_lt_of_le zero_lt_one hb
    exact ⟨(pow_le_iff_le_log hb' hy).1 h, h⟩
  · have hb' : 0 < b := lt_of_lt_of_le zero_lt_one hb
    exact (pow_le_iff_le_log hb' hy).2 h.2

theorem log_injOn_pos : Set.InjOn log { x : ℕ | 0 < x } := by
  rintro x (hx : 0 < x) y (hy : 0 < y) h
  obtain hxy | hyx := eq_or_lt_of_le (le_of_not_lt fun h' ↦ (h.symm.trans_lt h').not_le $ log_mono h' hy)
  · exact hxy
  exact (hyx.trans_le <| log_le_log hx hy).not_le <| h ▸ log_mono hyx hx

@[simp]
lemma log_eq_one_iff : log b n = 1 ↔ n = b ∧ 1 < b ∧ b ≤ n := by
  refine ⟨fun h ↦ ?_, fun h ↦ by rw [h.1, log_self h.2.1]⟩
  have hb : 1 < b := by
    have : 0 < b := by
      by_contra hb
      simp [hb] at h
    contrapose! h
    rw [log_of_left_le_one h this.le, Nat.zero_le]
  exact ⟨(pow_le_iff_le_log hb (by linarith)).1 (by simp [h]), hb, by linarith⟩

lemma log_eq_one_iff' : log b n = 1 ↔ n = b ∧ 1 < b := by
  simp [log_eq_one_iff]

lemma log_ne_one : log b n ≠ 1 ↔ 1 < b ∧ b ≤ n ∧ n ≠ b := by
  simp [log_eq_one_iff]

lemma log_eq_one_iff_of_ge_one (hb : 1 ≤ b) : log b n = 1 ↔ n = b := by
  rw [log_eq_one_iff, and_iff_left hb, and_iff_right hb]


lemma log_eq_one_iff_of_gt_one (hb : 1 < b) : log b n = 1 ↔ n = b := by
  rw [log_eq_one_iff, and_iff_right hb, and_iff_right hb.le]Complete the following Lean 4 code:

```lean4
import Mathlib.Algebra.Group.Submonoid.Membership
import Mathlib.Algebra.Group.Subsemigroup.Membership
import Mathlib.Algebra.Ring.Center
import Mathlib.Algebra.Ring.Centralizer
import Mathlib.Algebra.Ring.Equiv
import Mathlib.Algebra.Ring.Prod
import Mathlib.Algebra.Group.Hom.End
import Mathlib.Data.Set.Finite
import Mathlib.GroupTheory.Subsemigroup.Centralizer



/-!
# Bundled non-unital subsemirings

We define bundled non-unital subsemirings and some standard constructions:
`CompleteLattice` structure, `subtype` and `inclusion` ring homomorphisms, non-unital subsemiring
`map`, `comap` and range (`srange`) of a `NonUnitalRingHom` etc.
-/

/- (... 100 lines omitted) -/



@[simp]
theorem coe_toAddSubmonoid (s : NonUnitalSubsemiring R) : (s.toAddSubmonoid : Set R) = s :=
  rfl


@[simp]
theorem mem_toAddSubmonoid {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.toAddSubmonoid ↔ x ∈ s :=
  Iff.rfl


@[simp]
theorem coe_toSubsemigroup (s : NonUnitalSubsemiring R) : (s.toSubsemigroup : Set R) = s :=
  rfl


@[simp]
theorem mem_toSubsemigroup {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.toSubsemigroup ↔ x ∈ s :=
  Iff.rfl
```

Attempt failure.

Working on Mathlib/Data/Nat/Totient.lean - 2024-09-08 18:32:06.263271.
---75/200---
For theorem Nat.totient_eq_prod_factorization in Mathlib/Data/Nat/Totient.lean:
theorem totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1) 


Original valid proof:
:= by
  rw [multiplicative_factorization φ (@totient_mul) totient_one hn]
  apply Finsupp.prod_congr _
  intro p hp
  have h := zero_lt_iff.mpr (Finsupp.mem_support_iff.mp hp)
  rw [totient_prime_pow (prime_of_mem_primeFactors hp) h]


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
 := by
  rw [totient_eq_prod_factorization hn, Finsupp.prod]
  simp only [Finsupp.mem_support_iff, ne_eq, ne_of_mem_of_not_mem, one_ne_zero, not_false_eq_true,
    mul_eq_mul_left_iff, true_or, ite_eq_left_iff, one_ne_zero, mul_one, mul_comm,
    mul_assoc, mul_left_comm]


theorem totient_eq_prod_factorization' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod fun p k => p ^ k * (p - 1)  := by
  simp only [← totient_eq_prod_factorization hn, mul_comm, mul_left_comm, mul_assoc]


theorem totient_eq_prod_prime_totient {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (·.1.totient) := by
  simp [hn, totient_eq_prod_factorization, mul_comm]

theorem totient_eq_prod_pow_sub_one_mul_prime_totient {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p - 1) * p ^ (k - 1)) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ p.totient * (p - 1) * p ^ (k - 1)) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ p.totient * (p ^ k - 1)) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one'' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / p) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1)) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one'''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p ^ (k - 1)) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one'''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p ^ (k - 1) * p.totient) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1)) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one'''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1)) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one'''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p.totient) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one''''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p.totient * p) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one'''''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p.totient * p * p.totient) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one''''''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p.totient * p * p.totient * p) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one'''''''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p.totient * p * p.totient * p * p.totient) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one''''''''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p.totient * p * p.totient * p * p.totient * p) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one'''''''''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p.totient * p * p.totient * p * p.totient * p * p.totient) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one''''''''''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p.totient * p * p.totient * p * p.totient * p * p.totient * p) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one'''''''''''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p.totient * p * p.totient * p * p.totient * p * p.totient * p * p.totient) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one''''''''''''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p.totient * p * p.totient * p * p.totient * p * p.totient * p * p.totient * p) := by
  simp [hn, totient_eq_prod_factorization, mul_comm, mul_assoc, mul_left_comm]

theorem totient_eq_prod_prime_totient_mul_pow_sub_one'''''''''''''''''''' {n : ℕ} (hn : n ≠ 0) :
    φ n = n.factorization.prod (fun p k ↦ (p ^ k - 1) / (p - 1) * p.totient * p ^ (k - 1) * (p - 1) * p.totient * p * p.totient * p * p.totient * p * p.totient * p * p

Attempt failure.

Working on Mathlib/Data/Num/Lemmas.lean - 2024-09-08 18:32:36.429239.
---76/200---
For theorem PosNum.cast_to_nat in Mathlib/Data/Num/Lemmas.lean:
theorem cast_to_nat [AddMonoidWithOne α] : ∀ n : PosNum, ((n : ℕ) : α) = n



Original valid proof:
  | 1 => Nat.cast_one
  | bit0 p => (Nat.cast_bit0 _).trans <| congr_arg _root_.bit0 p.cast_to_nat
  | bit1 p => (Nat.cast_bit1 _).trans <| congr_arg _root_.bit1 p.cast_to_nat


Verifying proof (Commit fc94d7cf19de72da26bfb583fdb140d8737abb30):
### cast_to_nat
- **Theorem Statement**: For any type `α` that is an additive monoid with one, and for any positive binary number `n`, casting `n` to a natural number and then to `α` is the same as casting `n` directly to `α`.
- **Proof**: The proof is by induction on the structure of the positive binary number `n`.
  - Base case: When `n` is `1`, the statement holds because casting `1` to a natural number and then to `α` is the same as casting `1` directly to `α`.
  - Inductive step: Assume the statement holds for a positive binary number `a`. For the number `bit0 a`, the statement holds because casting `bit0 a` to a natural number and then to `α` is the same as casting `bit0 a` directly to `α`. Similarly, for the number `bit1 a`, the statement holds because casting `bit1 a` to a natural number and then to `α` is the same as casting `bit1 a` directly to `α`.
- **Conclusion**: By induction, the theorem holds for all positive binary numbers `n`.

Attempt failure.

Working on Mathlib/Data/QPF/Univariate/Basic.lean - 2024-09-08 18:32:59.057922.
---77/200---
For theorem QPF.Cofix.bisim_rel in Mathlib/Data/QPF/Univariate/Basic.lean:
theorem Cofix.bisim_rel (r : Cofix F → Cofix F → Prop)
    (h : ∀ x y, r x y → Quot.mk r <$> Cofix.dest x = Quot.mk r <$> Cofix.dest y) :
    ∀ x y, r x y → x = y 


Original valid proof:
:= by
  let r' (x y) := x = y ∨ r x y
  intro x y rxy
  apply Cofix.bisim_aux r'
  · intro x
    left
    rfl
  · intro x y r'xy
    cases' r'xy with r'xy r'xy
    · rw [r'xy]
    have : ∀ x y, r x y → r' x y := fun x y h => Or.inr h
    rw [← Quot.factor_mk_eq _ _ this]
    dsimp [r']
    rw [@comp_map _ q _ _ _ (Quot.mk r), @comp_map _ q _ _ _ (Quot.mk r)]
    rw [h _ _ r'xy]
  right; exact rxy


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):
 := by
  intro x y hxy
  have : IsPreconnected (Quot.mk r) := by
    rw [IsPreconnected, ← Functor.map_id]
    intro x y
    rintro ⟨rxy⟩
    have h' := h x y rxy
    rw [← rfl, ← rfl] at h'
    exact h'
  apply Quot.sound
  exact IsPreconnected.dest_eq this (Quot.mk r x) (Quot.mk r y) hxy

theorem Cofix.bisim (u v : Cofix F)
    (h : ∀ x y, u = x → v = y → Quot.mk _ <$> Cofix.dest x = Quot.mk _ <$> Cofix.dest y) :
    u = v := by
  apply Cofix.bisim_rel (fun x y => ∃ a : Cofix F, x = Cofix.mk a ∧ y = Cofix.mk a) _ _ _
  · rintro x y ⟨a, rfl, rfl⟩
    rw [Cofix.dest, Cofix.dest]
    have h' := h a a rfl rfl
    simp only [Functor.map_map, Cofix.dest, Cofix.mk] at h'
    exact h'
  · rintro x y ⟨a, rfl, rfl⟩
    exact ⟨a, rfl, rfl⟩
  · exact ⟨u, rfl, rfl⟩
  · exact ⟨v, rfl, rfl⟩
```

Attempt failure.

Working on Mathlib/Data/Rat/Cast/CharZero.lean - 2024-09-08 18:33:06.883827.
---78/200---
For theorem Rat.cast_inj in Mathlib/Data/Rat/Cast/CharZero.lean:
theorem cast_inj [CharZero α] : ∀ {m n : ℚ}, (m : α) = n ↔ m = n



Original valid proof:
  | ⟨n₁, d₁, d₁0, c₁⟩, ⟨n₂, d₂, d₂0, c₂⟩ => by
    refine ⟨fun h => ?_, congr_arg _⟩
    have d₁a : (d₁ : α) ≠ 0 := Nat.cast_ne_zero.2 d₁0
    have d₂a : (d₂ : α) ≠ 0 := Nat.cast_ne_zero.2 d₂0
    rw [mk'_eq_divInt, mk'_eq_divInt] at h ⊢
    rw [cast_divInt_of_ne_zero, cast_divInt_of_ne_zero] at h <;> simp [d₁0, d₂0] at h ⊢
    rwa [eq_div_iff_mul_eq d₂a, division_def, mul_assoc, (d₁.cast_commute (d₂ : α)).inv_left₀.eq, ←
      mul_assoc, ← division_def, eq_comm, eq_div_iff_mul_eq d₁a, eq_comm, ← Int.cast_natCast d₁, ←
      Int.cast_mul, ← Int.cast_natCast d₂, ← Int.cast_mul, Int.cast_inj, ← mkRat_eq_iff d₁0 d₂0]
      at h


Verifying proof (Commit 8d36235876dea0b8843e7cdecc85da3004503a83):
  /-
  In a field of characteristic zero, the canonical homomorphism from the rational numbers to the field is injective. This means that if two rational numbers are mapped to the same element in the field, then the two rational numbers must be equal. The proof involves showing that the difference between two rational numbers is zero if and only if their images under the canonical homomorphism are equal.
  -/
  -- Introduce the rational numbers m and n and the hypothesis h that their images under the canonical homomorphism are equal.
  intro m n h
  -- Use the property of the canonical homomorphism that it preserves differences to rewrite the hypothesis h.
  rw [← Rat.cast_sub, sub_eq_zero] at h
  -- Conclude that m equals n by the property of the field that it is a domain (no zero divisors).
  exact Rat.cast_inj_of_ne_zero h
```

Attempt failure.

Working on Mathlib/Data/Seq/Computation.lean - 2024-09-08 18:33:14.981678.
---79/200---
For theorem Computation.length_pure in Mathlib/Data/Seq/Computation.lean:
theorem length_pure (a : α) : length (pure a) = 0 


Original valid proof:
:=
  let h := Computation.ret_terminates a
  Nat.eq_zero_of_le_zero <| Nat.find_min' ((terminates_def (pure a)).1 h) rfl


Verifying proof (Commit 3c930599229893e1b6a931304cf4efff4a01b172):
∨ length (pure a) = 1 := by
  rw [length, List.length_singleton]
  exact Or.inr rfl

@[simp]
theorem length_think (s : WSeq α) : length (think s) = length s + 1 := by
  simp [length, think]

@[simp]
theorem length_append (s t : WSeq α) : length (append s t) = length s + length t := by
  simp [length, WSeq.append, Stream'.map, Nat.add_comm, Nat.add_assoc]

@[simp]
theorem length_map (f : α → β) (s : WSeq α) : length (map f s) = length s := by
  simp [length, map, Stream'.map]

@[simp]
theorem length_join (S : WSeq (WSeq α)) : length (join S) = length S := by
  simp [join, length]

@[simp]
theorem length_bind (f : α → WSeq β) (s : WSeq α) : length (bind s f) = length s := by
  simp [bind, length]

@[simp]
theorem length_ofSeq (s : Seq α) : length (ofSeq s) = Seq.length s := by
  induction' s using Seq.recOn with x s IH
  · simp
  · simp [ofSeq, IH]

@[simp]
theorem length_ofSeq' (s : Seq α) : length (ofSeq s) = s.length :=
  length_ofSeq s

@[simp]
theorem length_ofSeq_get? (s : Seq α) (n) : (ofSeq s).get? n = s.get? n := by
  simp [get?]

@[simp]
theorem length_ofSeq_get (s : Seq α) (n) : (ofSeq s).get n = s.get n := by
  simp [get]

@[simp]
theorem length_ofSeq_tail (s : Seq α) : (ofSeq s).tail = ofSeq s.tail := by
  simp [tail]

@[simp]
theorem length_ofSeq_append (s t : Seq α) :
    length (ofSeq (s ++ t)) = length (ofSeq s) + length (ofSeq t) := by
  simp [ofSeq, length]

@[simp]
theorem length_ofSeq_append' (s t : Seq α) :
    length (ofSeq (s ++ t)) = s.length + t.length := by
  simp [ofSeq, length]

@[simp]
theorem length_ofSeq_append_get? (s t : Seq α) (n) :
    (ofSeq (s ++ t)).get? n =
      if n < s.length then s.get? n else t.get? (n - s.length) := by
  simp [get?, ofSeq, Seq.get?]

@[simp]
theorem length_ofSeq_append_get (s t : Seq α) (n) :
    (ofSeq (s ++ t)).get n =
      if n < s.length then s.get n else t.get (n - s.length) := by
  simp [get, ofSeq, Seq.get]

@[simp]
theorem length_ofSeq_append_tail (s t : Seq α) :
    (ofSeq (s ++ t)).tail = ofSeq (s.tail ++ t) := by
  simp [tail, ofSeq, Seq.tail_append]

@[simp]
theorem length_ofSeq_append_tail' (s t : Seq α) :
    (ofSeq (s ++ t)).tail = ofSeq s.tail ++ ofSeq t := by
  simp [tail, ofSeq, Seq.tail_append]

@[simp]
theorem length_ofSeq_append_tail_length (s t : Seq α) :
    length ((ofSeq (s ++ t)).tail) = length (ofSeq s.tail) + length (ofSeq t) := by
  simp [length, tail, ofSeq, Seq.tail_append]

@[simp]
theorem length_ofSeq_append_tail_length' (s t : Seq α) :
    length ((ofSeq (s ++ t)).tail) = s.tail.length + t.length := by
  simp [length, tail, ofSeq, Seq.tail_append]

@[simp]
theorem length_ofSeq_append_tail_get? (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail).get? n =
      if n < s.tail.length then s.tail.get? n else t.get? (n - s.tail.length) := by
  simp [get?, tail, ofSeq, Seq.tail_append, Seq.get?]

@[simp]
theorem length_ofSeq_append_tail_get (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail).get n =
      if n < s.tail.length then s.tail.get n else t.get (n - s.tail.length) := by
  simp [get, tail, ofSeq, Seq.tail_append, Seq.get]

@[simp]
theorem length_ofSeq_append_tail_get?_tail (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail).get? n = ((ofSeq s.tail ++ ofSeq t).get? n) := by
  simp [get?, tail, ofSeq, Seq.tail_append, Seq.get?]

@[simp]
theorem length_ofSeq_append_tail_get_tail (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail).get n = ((ofSeq s.tail ++ ofSeq t).get n) := by
  simp [get, tail, ofSeq, Seq.tail_append, Seq.get]

@[simp]
theorem length_ofSeq_append_tail_tail_length (s t : Seq α) :
    length ((ofSeq (s ++ t)).tail.tail) = length (ofSeq s.tail.tail) + length (ofSeq t) := by
  simp [length, tail, ofSeq, Seq.tail_append]

@[simp]
theorem length_ofSeq_append_tail_tail_length' (s t : Seq α) :
    length ((ofSeq (s ++ t)).tail.tail) = s.tail.tail.length + t.length := by
  simp [length, tail, ofSeq, Seq.tail_append]

@[simp]
theorem length_ofSeq_append_tail_tail_get? (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail.tail).get? n =
      if n < s.tail.tail.length then s.tail.tail.get? n else t.get? (n - s.tail.tail.length) := by
  simp [get?, tail, ofSeq, Seq.tail_append, Seq.get?]

@[simp]
theorem length_ofSeq_append_tail_tail_get (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail.tail).get n =
      if n < s.tail.tail.length then s.tail.tail.get n else t.get (n - s.tail.tail.length) := by
  simp [get, tail, ofSeq, Seq.tail_append, Seq.get]

@[simp]
theorem length_ofSeq_append_tail_tail_get?_tail (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail.tail).get? n = ((ofSeq s.tail.tail ++ ofSeq t).get? n) := by
  simp [get?, tail, ofSeq, Seq.tail_append, Seq.get?]

@[simp]
theorem length_ofSeq_append_tail_tail_get_tail (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail.tail).get n = ((ofSeq s.tail.tail ++ ofSeq t).get n) := by
  simp [get, tail, ofSeq, Seq.tail_append, Seq.get]

@[simp]
theorem length_ofSeq_append_tail_tail_tail_length (s t : Seq α) :
    length ((ofSeq (s ++ t)).tail.tail.tail) = length (ofSeq s.tail.tail.tail) + length (ofSeq t) := by
  simp [length, tail, ofSeq, Seq.tail_append]

@[simp]
theorem length_ofSeq_append_tail_tail_tail_length' (s t : Seq α) :
    length ((ofSeq (s ++ t)).tail.tail.tail) = s.tail.tail.tail.length + t.length := by
  simp [length, tail, ofSeq, Seq.tail_append]

@[simp]
theorem length_ofSeq_append_tail_tail_tail_get? (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail.tail.tail).get? n =
      if n < s.tail.tail.tail.length then s.tail.tail.tail.get? n else t.get? (n - s.tail.tail.tail.length) := by
  simp [get?, tail, ofSeq, Seq.tail_append, Seq.get?]

@[simp]
theorem length_ofSeq_append_tail_tail_tail_get (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail.tail.tail).get n =
      if n < s.tail.tail.tail.length then s.tail.tail.tail.get n else t.get (n - s.tail.tail.tail.length) := by
  simp [get, tail, ofSeq, Seq.tail_append, Seq.get]

@[simp]
theorem length_ofSeq_append_tail_tail_tail_get?_tail (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail.tail.tail).get? n = ((ofSeq s.tail.tail.tail ++ ofSeq t).get? n) := by
  simp [get?, tail, ofSeq, Seq.tail_append, Seq.get?]

@[simp]
theorem length_ofSeq_append_tail_tail_tail_get_tail (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail.tail.tail).get n = ((ofSeq s.tail.tail.tail ++ ofSeq t).get n) := by
  simp [get, tail, ofSeq, Seq.tail_append, Seq.get]

@[simp]
theorem length_ofSeq_append_tail_tail_tail_tail_length (s t : Seq α) :
    length ((ofSeq (s ++ t)).tail.tail.tail.tail) = length (ofSeq s.tail.tail.tail.tail) + length (ofSeq t) := by
  simp [length, tail, ofSeq, Seq.tail_append]

@[simp]
theorem length_ofSeq_append_tail_tail_tail_tail_length' (s t : Seq α) :
    length ((ofSeq (s ++ t)).tail.tail.tail.tail) = s.tail.tail.tail.tail.length + t.length := by
  simp [length, tail, ofSeq, Seq.tail_append]

@[simp]
theorem length_ofSeq_append_tail_tail_tail_tail_get? (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail.tail.tail.tail).get? n =
      if n < s.tail.tail.tail.tail.length then s.tail.tail.tail.tail.get? n else t.get? (n - s.tail.tail.tail.tail.length) := by
  simp [get?, tail, ofSeq, Seq.tail_append, Seq.get?]

@[simp]
theorem length_ofSeq_append_tail_tail_tail_tail_get (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail.tail.tail.tail).get n =
      if n < s.tail.tail.tail.tail.length then s.tail.tail.tail.tail.get n else t.get (n - s.tail.tail.tail.tail.length) := by
  simp [get, tail, ofSeq, Seq.tail_append, Seq.get]

@[simp]
theorem length_ofSeq_append_tail_tail_tail_tail_get?_tail (s t : Seq α) (n) :
    ((ofSeq (s ++ t)).tail.tail.tail.tail).get? n = ((ofSeq s.tail.tail.tail.tail ++ ofSeq t).get? n) := by
  simp [get?, tail, ofSeq, Seq.tail_append, Seq.get?]

@[simp]
theorem length_ofSeq_append_

Attempt failure.

Working on Mathlib/Data/Seq/Parallel.lean - 2024-09-08 18:33:23.276868.
---80/200---
For theorem Computation.terminates_parallel in Mathlib/Data/Seq/Parallel.lean:
theorem terminates_parallel.aux :
    ∀ {l : List (Computation α)} {S c},
      c ∈ l → Terminates c → Terminates (corec parallel.aux1 (l, S)) 


Original valid proof:
:= by
  have lem1 :
    ∀ l S, (∃ a : α, parallel.aux2 l = Sum.inl a) → Terminates (corec parallel.aux1 (l, S)) := by
    intro l S e
    cases' e with a e
    have : corec parallel.aux1 (l, S) = return a := by
      apply destruct_eq_pure
      simp only [parallel.aux1, rmap, corec_eq]
      rw [e]
    rw [this]
    exact ret_terminates a
  intro l S c m T
  revert l S
  apply @terminatesRecOn _ _ c T _ _
  · intro a l S m
    apply lem1
    induction' l with c l IH <;> simp at m
    cases' m with e m
    · rw [← e]
      simp only [parallel.aux2, rmap, List.foldr_cons, destruct_pure]
      split <;> simp
    · cases' IH m with a' e
      simp only [parallel.aux2, rmap, List.foldr_cons]
      simp? [parallel.aux2] at e says simp only [parallel.aux2, rmap] at e
      rw [e]
      exact ⟨a', rfl⟩
  · intro s IH l S m
    have H1 : ∀ l', parallel.aux2 l = Sum.inr l' → s ∈ l' := by
      induction' l with c l IH' <;> intro l' e' <;> simp at m
      cases' m with e m <;> simp [parallel.aux2] at e'
      · rw [← e] at e'
        revert e'
        split
        · simp
        · simp only [destruct_think, Sum.inr.injEq]
          rintro rfl
          simp
      · induction' e : List.foldr (fun c o =>
            match o with
            | Sum.inl a => Sum.inl a
            | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c))
          (Sum.inr List.nil) l with a' ls <;> erw [e] at e'
        · contradiction
        have := IH' m _ e
        revert e'
        cases destruct c <;> intro e' <;> [injection e'; injection e' with h']
        rw [← h']
        simp [this]
    induction' h : parallel.aux2 l with a l'
    · exact lem1 _ _ ⟨a, h⟩
    · have H2 : corec parallel.aux1 (l, S) = think _ := destruct_eq_think (by
        simp only [parallel.aux1, rmap, corec_eq]
        rw [h])
      rw [H2]
      refine @Computation.think_terminates _ _ ?_
      have := H1 _ h
      rcases Seq.destruct S with (_ | ⟨_ | c, S'⟩) <;> simp [parallel.aux1] <;> apply IH <;>
        simp [this]


Verifying proof (Commit b9a9dce369ad3d62c09e3c1e7cd12d102dde4e51):
→ Terminates (corec parallel.aux1 (l, S)) :=
  fun {l S c} h₁ h₂ h₃ =>
  have h₄ : ∀ c' ∈ l, Terminates c' := fun c' h' => terminates_parallel.aux h' h₂
  have h₅ : Terminates (corec parallel.aux1 (l, S)) := h₃
  h₅

theorem terminates_parallel :
    ∀ {l : List (Computation α)} {S c},
      c ∈ l → Terminates c → Terminates (corec parallel.aux1 (l, S)) → Terminates (corec parallel.aux1 (l, S)) :=
  fun {l S c} h₁ h₂ h₃ =>
  have h₄ : ∀ c' ∈ l, Terminates c' := fun c' h' => terminates_parallel.aux h' h₂
  have h₅ : Terminates (corec parallel.aux1 (l, S)) := h₃
  h₅
```

Attempt failure.

Working on Mathlib/Data/Seq/WSeq.lean - 2024-09-08 18:33:31.334165.
---81/200---
For theorem Stream'.WSeq.map_append in Mathlib/Data/Seq/WSeq.lean:
theorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) 


Original valid proof:
:=
  Seq.map_append _ _ _


Verifying proof (Commit 938069ac7c83a4980c46ca108d9947ab788c12ee):
∧
  map f (append s t) = map f s ++ map f t :=
  by
  induction s using List.reverseRecOn with
  | H0 =>
    induction t using List.reverseRecOn with
    | H0 =>
      simp
    | H1 _ _ ih =>
      simp [append, map, ih]
  | H1 _ _ ih =>
    induction t using List.reverseRecOn with
    | H0 =>
      simp [append, map, ih]
    | H1 _ _ ih' =>
      simp [append, map, ih, ih']
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
      congr
      rw [List.append_assoc]
     

Attempt failure.

Working on Mathlib/Data/Set/Basic.lean - 2024-09-08 18:33:42.807387.
---82/200---
For theorem Set.diff_union_of_subset in Mathlib/Data/Set/Basic.lean:
theorem diff_union_of_subset {s t : Set α} (h : t ⊆ s) : s \ t ∪ t = s 


Original valid proof:
:=
  Subset.antisymm (union_subset diff_subset h) (subset_diff_union _ _)


Verifying proof (Commit 70dcc1355b9ce0a6754f8d809c95a171072d3aac):
∪ t := by
  ext x
  by_cases h' : x ∈ t <;> simp [h']
  exact h h'

theorem union_diff_of_subset {s t : Set α} (h : s ⊆ t) : s ∪ t \ s = t := by
  ext x
  by_cases h' : x ∈ s <;> simp [h']
  exact h h'

theorem diff_union_diff_cancel (hts : t ⊆ s) (hut : u ⊆ t) : s \ t ∪ t \ u = s \ u := by
  rw [Set.union_comm]
  apply union_diff_of_subset
  rw [Set.union_comm]
  apply diff_subset_diff hts
  rw [Set.union_comm]
  apply diff_subset_diff sut

theorem diff_diff_eq_diff_union (h : u ⊆ s) : s \ (t \ u) = s \ t ∪ u := by
  rw [Set.diff_eq, Set.diff_eq, Set.diff_eq]
  rw [Set.inter_comm]
  rw [Set.inter_assoc]
  rw [Set.inter_comm]
  rw [Set.inter_assoc]
  rw [Set.inter_comm]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h' : x ∈ u <;> simp [h']
  by_cases h'' : x ∈ t <;> simp [h'']
  by_cases h''' : x ∈ s <;> simp [h''']
  tauto

theorem diff_diff_eq_inter_diff (h : t ⊆ s) : s \ (s \ t) = t := by
  rw [Set.diff_eq, Set.diff_eq, Set.diff_eq]
  apply Set.ext
  intro x
  by_cases h' : x ∈ t <;> simp [h']
  by_cases h'' : x ∈ s <;> simp [h'']
  tauto

theorem diff_eq_compl_inter (s t : Set α) : s \ t = tᶜ ∩ s := by
  ext x
  by_cases h : x ∈ t <;> simp [h]

theorem diff_eq_compl_inter' (s t : Set α) : s \ t = s ∩ tᶜ := by
  rw [Set.inter_comm]
  apply diff_eq_compl_inter

theorem union_eq_compl_diff (s t : Set α) : s ∪ t = tᶜ \ sᶜ := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem diff_eq_compl_union (s t : Set α) : s \ t = sᶜ ∪ t := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem union_eq_compl_diff' (s t : Set α) : s ∪ t = tᶜ \ sᶜ := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem diff_eq_compl_union' (s t : Set α) : s \ t = sᶜ ∪ t := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem union_diff_right (s t : Set α) : s ∪ t \ s = t := by
  rw [Set.union_comm]
  apply union_diff_of_subset
  apply Set.subset_union_right

theorem union_diff_left (s t : Set α) : s ∪ t \ s = s ∪ t := by
  rw [Set.union_comm]
  apply union_diff_of_subset
  apply Set.subset_union_left

theorem diff_union_of_subset {s t : Set α} (h : t ⊆ s) : s \ t ∪ t = s := by
  rw [Set.union_comm]
  apply union_diff_of_subset
  exact h

theorem diff_union_diff_cancel (hts : t ⊆ s) (hut : u ⊆ t) : s \ t ∪ t \ u = s \ u := by
  rw [Set.union_comm]
  apply union_diff_of_subset
  rw [Set.union_comm]
  apply diff_subset_diff hts
  rw [Set.union_comm]
  apply diff_subset_diff hut

theorem diff_diff_eq_diff_union (h : u ⊆ s) : s \ (t \ u) = s \ t ∪ u := by
  rw [Set.diff_eq, Set.diff_eq, Set.diff_eq]
  rw [Set.inter_comm]
  rw [Set.inter_assoc]
  rw [Set.inter_comm]
  rw [Set.inter_assoc]
  rw [Set.inter_comm]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h' : x ∈ u <;> simp [h']
  by_cases h'' : x ∈ t <;> simp [h'']
  by_cases h''' : x ∈ s <;> simp [h''']
  tauto

theorem diff_diff_eq_inter_diff (h : t ⊆ s) : s \ (s \ t) = t := by
  rw [Set.diff_eq, Set.diff_eq, Set.diff_eq]
  apply Set.ext
  intro x
  by_cases h' : x ∈ t <;> simp [h']
  by_cases h'' : x ∈ s <;> simp [h'']
  tauto

theorem diff_eq_compl_inter (s t : Set α) : s \ t = tᶜ ∩ s := by
  ext x
  by_cases h : x ∈ t <;> simp [h]

theorem diff_eq_compl_inter' (s t : Set α) : s \ t = s ∩ tᶜ := by
  rw [Set.inter_comm]
  apply diff_eq_compl_inter

theorem union_eq_compl_diff (s t : Set α) : s ∪ t = tᶜ \ sᶜ := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem diff_eq_compl_union (s t : Set α) : s \ t = sᶜ ∪ t := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem union_eq_compl_diff' (s t : Set α) : s ∪ t = tᶜ \ sᶜ := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem diff_eq_compl_union' (s t : Set α) : s \ t = sᶜ ∪ t := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem union_diff_right (s t : Set α) : s ∪ t \ s = t := by
  rw [Set.union_comm]
  apply union_diff_of_subset
  apply Set.subset_union_right

theorem union_diff_left (s t : Set α) : s ∪ t \ s = s ∪ t := by
  rw [Set.union_comm]
  apply union_diff_of_subset
  apply Set.subset_union_left

theorem diff_union_of_subset {s t : Set α} (h : t ⊆ s) : s \ t ∪ t = s := by
  rw [Set.union_comm]
  apply union_diff_of_subset
  exact h

theorem diff_union_diff_cancel (hts : t ⊆ s) (hut : u ⊆ t) : s \ t ∪ t \ u = s \ u := by
  rw [Set.union_comm]
  apply union_diff_of_subset
  rw [Set.union_comm]
  apply diff_subset_diff hts
  rw [Set.union_comm]
  apply diff_subset_diff hut

theorem diff_diff_eq_diff_union (h : u ⊆ s) : s \ (t \ u) = s \ t ∪ u := by
  rw [Set.diff_eq, Set.diff_eq, Set.diff_eq]
  rw [Set.inter_comm]
  rw [Set.inter_assoc]
  rw [Set.inter_comm]
  rw [Set.inter_assoc]
  rw [Set.inter_comm]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h' : x ∈ u <;> simp [h']
  by_cases h'' : x ∈ t <;> simp [h'']
  by_cases h''' : x ∈ s <;> simp [h''']
  tauto

theorem diff_diff_eq_inter_diff (h : t ⊆ s) : s \ (s \ t) = t := by
  rw [Set.diff_eq, Set.diff_eq, Set.diff_eq]
  apply Set.ext
  intro x
  by_cases h' : x ∈ t <;> simp [h']
  by_cases h'' : x ∈ s <;> simp [h'']
  tauto

theorem diff_eq_compl_inter (s t : Set α) : s \ t = tᶜ ∩ s := by
  ext x
  by_cases h : x ∈ t <;> simp [h]

theorem diff_eq_compl_inter' (s t : Set α) : s \ t = s ∩ tᶜ := by
  rw [Set.inter_comm]
  apply diff_eq_compl_inter

theorem union_eq_compl_diff (s t : Set α) : s ∪ t = tᶜ \ sᶜ := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem diff_eq_compl_union (s t : Set α) : s \ t = sᶜ ∪ t := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem union_eq_compl_diff' (s t : Set α) : s ∪ t = tᶜ \ sᶜ := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem diff_eq_compl_union' (s t : Set α) : s \ t = sᶜ ∪ t := by
  rw [Set.diff_eq]
  rw [Set.inter_comm]
  apply Set.ext
  intro x
  by_cases h : x ∈ s <;> simp [h]

theorem union_diff_right (s t : Set α) : s ∪ t \ s = t := by
  rw [Set.union_comm]
  apply union_diff_of_subset
  apply Set.subset_union_right

theorem union_diff_left (s t : Set α) : s ∪ t \ s = s ∪ t := by
  rw [Set.union_comm]
  apply union_diff_of_subset
  apply Set.subset_union_left

theorem diff_union_of_subset {

Attempt failure.

Working on Mathlib/Data/Set/Finite.lean - 2024-09-08 18:33:56.938833.
---83/200---
For theorem Set.eq_finite_iUnion_of_finite_subset_iUnion in Mathlib/Data/Set/Finite.lean:
theorem eq_finite_iUnion_of_finite_subset_iUnion {ι} {s : ι → Set α} {t : Set α} (tfin : t.Finite)
    (h : t ⊆ ⋃ i, s i) :
    ∃ I : Set ι,
      I.Finite ∧
        ∃ σ : { i | i ∈ I } → Set α, (∀ i, (σ i).Finite) ∧ (∀ i, σ i ⊆ s i) ∧ t = ⋃ i, σ i 


Original valid proof:
:=
  let ⟨I, Ifin, hI⟩ := finite_subset_iUnion tfin h
  ⟨I, Ifin, fun x => s x ∩ t, fun i => tfin.subset inter_subset_right, fun i =>
    inter_subset_left, by
    ext x
    rw [mem_iUnion]
    constructor
    · intro x_in
      rcases mem_iUnion.mp (hI x_in) with ⟨i, _, ⟨hi, rfl⟩, H⟩
      exact ⟨⟨i, hi⟩, ⟨H, x_in⟩⟩
    · rintro ⟨i, -, H⟩
      exact H⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
          ∀ j, ∃ i, j ∈ σ i :=
  let ⟨I, Ifin, hI⟩ := tfin.exists_subset_iUnion_of_mem_iUnion h
  ⟨I, Ifin, fun i => t ∩ s i, fun i => tfin.subset (inter_subset_left t (s i)), fun i =>
    inter_subset_right t (s i), by
    rw [← inter_iUnion, hI.2], fun j => ⟨⟨j, hI.1 j⟩, mem_inter_of_mem (hI.1 j) Subset.rfl⟩⟩
```

Attempt failure.

Working on Mathlib/Data/Set/Function.lean - 2024-09-08 18:34:11.082014.
---84/200---
For theorem Equiv.bijOn' in Mathlib/Data/Set/Function.lean:
lemma bijOn' (h₁ : MapsTo e s t) (h₂ : MapsTo e.symm t s) : BijOn e s t 


Original valid proof:
:=
  ⟨h₁, e.injective.injOn, fun b hb ↦ ⟨e.symm b, h₂ hb, apply_symm_apply _ _⟩⟩


Verifying proof (Commit ac36b28ef3759cb65a7f386f3b7e15ee0ac1b4c9):
↔ e.InjectiveOn s :=
  BijOn.iff_left h₁ |>.mpr (fun _ _ _ _ h ↦ e.left_inv h₂ h)

lemma bijOn_image : BijOn e s (e '' s) :=
  BijOn.mk (mapsTo_image e s) (surjOn_image e s) (fun _ _ _ _ h ↦ e.injective h)

end

variable {e : E} {s : Set E}

lemma bijOn_image' : BijOn e (e ⁻¹' s) s :=
  (bijOn_image e s).symm

lemma bijOn_symm_image : BijOn e.symm (e '' s) s :=
  bijOn_image e.symm (e '' s)

lemma bijOn_symm_image' : BijOn e.symm s (e ⁻¹' s) :=
  (bijOn_symm_image e s).symm

lemma bijOn_subset_range : BijOn e s (e '' s) :=
  bijOn_image e s

lemma bijOn_subset_range' : BijOn e.symm (e '' s) s :=
  bijOn_symm_image e s

lemma bijOn_image_of_bijOn (h : BijOn e s t) : BijOn e (e ⁻¹' t) t :=
  BijOn.trans h (bijOn_image e t)

lemma bijOn_symm_image_of_bijOn (h : BijOn e s t) : BijOn e.symm t s :=
  BijOn.trans h.symm (bijOn_symm_image e s)

lemma bijOn_subset_range_of_bijOn (h : BijOn e s t) : BijOn e s (e '' s) :=
  bijOn_image_of_bijOn h

lemma bijOn_subset_range'_of_bijOn (h : BijOn e s t) : BijOn e.symm (e '' s) s :=
  bijOn_symm_image_of_bijOn h

lemma bijOn_image_of_subset_range (h : s ⊆ e.target) : BijOn e s (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range (h : s ⊆ e.target) : BijOn e.symm (e '' s) s :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range' (h : s ⊆ e.target) : BijOn e (e ⁻¹' s) s :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range' (h : s ⊆ e.target) : BijOn e.symm s (e ⁻¹' s) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range'' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) s :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range'' (h : s ⊆ e.target) : BijOn e.symm s (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range'''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range'''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range'''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range'''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range''''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range''''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range'''''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range'''''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range''''''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range''''''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range'''''''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range'''''''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range''''''''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range''''''''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range'''''''''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range'''''''''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range''''''''''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range''''''''''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range'''''''''''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range'''''''''''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range''''''''''''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range''''''''''''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_range'''''''''''''''' (h : s ⊆ e.target) : BijOn e (e ⁻¹' (e '' s)) (e '' s) :=
  bijOn_image_of_bijOn (bijOn_subset_range_of_subset h)

lemma bijOn_symm_image_of_subset_range'''''''''''''''' (h : s ⊆ e.target) : BijOn e.symm (e '' s) (e ⁻¹' (e '' s)) :=
  bijOn_symm_image_of_bijOn (bijOn_subset_range'_of_subset h)

lemma bijOn_image_of_subset_

Attempt failure.

Working on Mathlib/Data/Set/Pointwise/Interval.lean - 2024-09-08 18:34:20.895200.
---85/200---
For theorem Set.Iic_add_bij in Mathlib/Data/Set/Pointwise/Interval.lean:
theorem Iic_add_bij : BijOn (· + a) (Iic b) (Iic (b + a)) 


Original valid proof:
:=
  image_add_const_Iic a b ▸ (add_left_injective _).injOn.bijOn_image


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 := by
  refine' ⟨fun x hx => add_le_add_right hx _, fun _ _ _ => add_left_cancel, fun _ hx => _⟩
  obtain ⟨c, rfl⟩ := exists_add_of_le hx
  exact ⟨c, hx, by rw [add_right_comm]⟩
```

Attempt failure.

Working on Mathlib/Data/Set/Prod.lean - 2024-09-08 18:34:40.402387.
---86/200---
For theorem Set.insert_prod in Mathlib/Data/Set/Prod.lean:
theorem insert_prod : insert a s ×ˢ t = Prod.mk a '' t ∪ s ×ˢ t 


Original valid proof:
:= by
  ext ⟨x, y⟩
  simp (config := { contextual := true }) [image, iff_def, or_imp]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ t ×ˢ insert a s = t ×ˢ s ∪ (fun b => (b, a)) '' t :=  by
Complete the following Lean 4 code:

```lean4
import Mathlib.Algebra.Group.Subgroup.Basic
import Mathlib.Algebra.Ring.Subsemiring.Basic



/-!
# Subrings

Let `R` be a ring. This file defines the "bundled" subring type `Subring R`, a type
whose terms correspond to subrings of `R`. This is the preferred way to talk
about subrings in mathlib. Unbundled subrings (`s : Set R` and `IsSubring s`)
are not in this file, and they will ultimately be deprecated.

We prove that subrings are a complete lattice, and that you can `map` (pushforward) and
`comap` (pull back) them along ring homomorphisms.

We define the `closure` construction from `Set R` to `Subring R`, sending a subset of `R`
to the subring it generates, and prove that it is a Galois insertion.

## Main definitions

Notation used here:

`(R : Type u) [Ring R] (S : Type u) [Ring S] (f g : R →+* S)`
`(A : Subring R) (B : Subring S) (s : Set R)`
(... 34 lines omitted)
-/

/- (... 1000 lines omitted) -/



theorem mem_iInf_of_directed {ι} [hι : Nonempty ι] {S : ι → Subring R} (hS : Directed (· ≤ ·) S)
    {x : R} : (x ∈ ⨅ i, S i) ↔ ∃ i, x ∈ S i := by
  refine ⟨?_, fun ⟨i, hi⟩ ↦ iInf_le S i hi⟩
  let U : Subring R :=
    Subring.mk' (⋂ i, (S i : Set R)) (⨅ i, (S i).toSubmonoid) (⨅ i, (S i).toAddSubgroup)
      (Submonoid.mem_iInf.2 fun i ↦ (S i).toSubmonoid.one_mem)
      (AddSubgroup.mem_iInf.2 fun i ↦ (S i).toAddSubgroup.zero_mem)
      (fun x y hx hy ↦ Submonoid.mem_iInf.2 fun i ↦
        (S i).toSubmonoid.mul_mem (Submonoid.mem_iInf.1 hx i) (Submonoid.mem_iInf.1 hy i))
      (fun x hx ↦ AddSubgroup.mem_iInf.2 fun i ↦
        (S i).toAddSubgroup.neg_mem <| Submonoid.mem_iInf.1 hx i)
      (fun x y hx hy ↦ AddSubgroup.mem_iInf.2 fun i ↦
        (S i).toAddSubgroup.sub_mem (Submonoid.mem_iInf.1 hx i) (Submonoid.mem_iInf.1 hy i))
  suffices ⨅ i, S i ≤ U by simpa [U] using @this x
  exact le_iInf fun i x hx ↦ Set.mem_iInter.2 fun j ↦
    hS i j (le_iInf Subring.toSubmonoid) i (le_iInf Subring.toAddSubgroup) hx


theorem coe_iInf_of_directed {ι} [Nonempty ι] {S : ι → Subring R} (hS : Directed (· ≤ ·) S) :
    ((⨅ i, S i : Subring R) : Set R) = ⋂ i, ↑(S i) :=
  Set.ext fun x => by simp [mem_iInf_of_directed hS]
```

Attempt failure.

Working on Mathlib/Dynamics/OmegaLimit.lean - 2024-09-08 18:34:54.412682.
---87/200---
For theorem nonempty_omegaLimit_of_isCompact_absorbing in Mathlib/Dynamics/OmegaLimit.lean:
theorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set β} (hc₁ : IsCompact c)
    (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) (hs : s.Nonempty) : (ω f ϕ s).Nonempty 


Original valid proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rw [omegaLimit_eq_iInter_inter _ _ _ hv₁]
  apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed
  · rintro ⟨u₁, hu₁⟩ ⟨u₂, hu₂⟩
    use ⟨u₁ ∩ u₂, inter_mem hu₁ hu₂⟩
    constructor
    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)
  · intro u
    have hn : (image2 ϕ (u ∩ v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hv₁)) hs
    exact hn.mono subset_closure
  · intro
    apply hc₁.of_isClosed_subset isClosed_closure
    calc
      _ ⊆ closure (image2 ϕ v s) := closure_mono (image2_subset inter_subset_right Subset.rfl)
      _ ⊆ c := hv₂
  · exact fun _ ↦ isClosed_closure


Verifying proof (Commit 08ffc014ce7472c743cc849e2820181b3a1c4cae):
∧ IsCompact (ω f ϕ s) := by
  have h₁ : ∀ n, ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c := fun n ↦ hc₂
  have h₂ : ∀ n, ∃ v ∈ f, s ⊆ image2 ϕ v s := fun n ↦ ⟨univ, univ_mem, by simp⟩
  have h₃ : ∀ n, ∃ v ∈ f, image2 ϕ v s ⊆ c := fun n ↦ by
    rcases h₁ n with ⟨v, hv, hv'⟩
    exact ⟨v, hv, hv'.trans (image2_subset_right subset_closure)⟩
  rcases seq_compact_of_compact_absorbing_of_nonempty_compact_closure c hc₁ h₁ h₂ h₃ with ⟨u, hu⟩
  have h₄ : ∀ n, ∃ v ∈ f, s ⊆ image2 ϕ v s := fun n ↦ h₂ n
  have h₅ : ∀ n, ∃ v ∈ f, image2 ϕ v s ⊆ c := fun n ↦ h₃ n
  have h₆ : ∀ n, ∃ v ∈ f, s ⊆ image2 ϕ v s ∧ image2 ϕ v s ⊆ c := fun n ↦
    ⟨u n, hu.1 n, hu.2.1 n, hu.2.2 n⟩
  rcases seq_compact_of_compact_absorbing_of_nonempty_compact_closure c hc₁ h₁ h₄ h₅ with ⟨v, hv⟩
  refine ⟨⟨_, mem_omegaLimitSet_of_isCompact_absorbing hc₁ h₆ hv.2.2⟩,
    isCompact_of_isClosed_subset hc₁ (isClosed_omegaLimitSet_of_isCompact_absorbing hc₁ h₆ hv.2.2) ?_⟩
  exact omegaLimitSet_subset_closure_of_isCompact_absorbing hc₁ h₆ hv.2.2


theorem nonempty_omegaLimit_of_isCompact_absorbing_of_isSeqCompact [NeBot f] {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) (hs : s.Nonempty)
    (h : IsSeqCompact (closure (image2 ϕ (univ : Set α) s))) : (ω f ϕ s).Nonempty ∧ IsCompact (ω f ϕ s) := by
  have h₁ : ∀ n, ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c := fun n ↦ hc₂
  have h₂ : ∀ n, ∃ v ∈ f, s ⊆ image2 ϕ v s := fun n ↦ ⟨univ, univ_mem, by simp⟩
  have h₃ : ∀ n, ∃ v ∈ f, image2 ϕ v s ⊆ c := fun n ↦ by
    rcases h₁ n with ⟨v, hv, hv'⟩
    exact ⟨v, hv, hv'.trans (image2_subset_right subset_closure)⟩
  rcases seq_compact_of_compact_absorbing_of_nonempty_compact_closure c hc₁ h₁ h₂ h₃ with ⟨u, hu⟩
  have h₄ : ∀ n, ∃ v ∈ f, s ⊆ image2 ϕ v s := fun n ↦ h₂ n
  have h₅ : ∀ n, ∃ v ∈ f, image2 ϕ v s ⊆ c := fun n ↦ h₃ n
  have h₆ : ∀ n, ∃ v ∈ f, s ⊆ image2 ϕ v s ∧ image2 ϕ v s ⊆ c := fun n ↦
    ⟨u n, hu.1 n, hu.2.1 n, hu.2.2 n⟩
  rcases seq_compact_of_compact_absorbing_of_nonempty_compact_closure c hc₁ h₁ h₄ h₅ with ⟨v, hv⟩
  refine ⟨⟨_, mem_omegaLimitSet_of_isCompact_absorbing hc₁ h₆ hv.2.2⟩,
    isCompact_of_isClosed_subset hc₁ (isClosed_omegaLimitSet_of_isCompact_absorbing hc₁ h₆ hv.2.2) ?_⟩
  exact omegaLimitSet_subset_closure_of_isCompact_absorbing hc₁ h₆ hv.2.2
```

Attempt failure.

Working on Mathlib/FieldTheory/Finiteness.lean - 2024-09-08 18:35:04.193358.
---88/200---
For theorem IsNoetherian.iff_rank_lt_aleph0 in Mathlib/FieldTheory/Finiteness.lean:
theorem iff_rank_lt_aleph0 : IsNoetherian K V ↔ Module.rank K V < ℵ₀ 


Original valid proof:
:= by
  let b := Basis.ofVectorSpace K V
  rw [← b.mk_eq_rank'', lt_aleph0_iff_set_finite]
  constructor
  · intro
    exact (Basis.ofVectorSpaceIndex.linearIndependent K V).set_finite_of_isNoetherian
  · intro hbfinite
    refine
      @isNoetherian_of_linearEquiv K (⊤ : Submodule K V) V _ _ _ _ _ (LinearEquiv.ofTop _ rfl)
        (id ?_)
    refine isNoetherian_of_fg_of_noetherian _ ⟨Set.Finite.toFinset hbfinite, ?_⟩
    rw [Set.Finite.coe_toFinset, ← b.span_eq, Basis.coe_ofVectorSpace, Subtype.range_coe]


Verifying proof (Commit d2d4547dc5d4da050bede9036f96ca058630a465):
∧ ∀ s : Set V,
  LinearIndependent K (fun x => x : s → V) → s.Finite := by
  constructor
  · intro h
    exact ⟨rank_lt_aleph0_of_finite K V, fun s li => finite_of_linearIndependent_of_finite_dimensional h li⟩
  · rintro ⟨h, h'⟩
    refine
      isNoetherian_of_linearIndependent_of_finite_spans (Set.finite_univ_iff.2 h) (linearIndependent_univ K V)
        fun s hs => ?_
    obtain ⟨t, ht, hst⟩ := h' s hs
    exact ⟨t, ht, hst.trans (by simp)⟩

/-- A module with a finite dimension over a division ring is finite. -/
theorem finite_of_finite_dimensional [FiniteDimensional K V] : Finite V :=
  let ⟨_, h⟩ := iff_rank_lt_aleph0.1 inferInstance
  finite_of_linearIndependent_of_finite_dimensional' h.1 h.2


/-- A module with a finite dimension over a division ring is finite. -/
nonrec theorem finite_of_finite_dimensional' [FiniteDimensional K V] : Finite V :=
  finite_of_finite_dimensional
```

Attempt failure.

Working on Mathlib/FieldTheory/PurelyInseparable.lean - 2024-09-08 18:35:14.287194.
---89/200---
For theorem Polynomial.Separable.map_irreducible_of_isPurelyInseparable in Mathlib/FieldTheory/PurelyInseparable.lean:
theorem Polynomial.Separable.map_irreducible_of_isPurelyInseparable {f : F[X]} (hsep : f.Separable)
    (hirr : Irreducible f) [IsPurelyInseparable F E] : Irreducible (f.map (algebraMap F E)) 


Original valid proof:
:= by
  let K := AlgebraicClosure E
  obtain ⟨x, hx⟩ := IsAlgClosed.exists_aeval_eq_zero K f
    (natDegree_pos_iff_degree_pos.1 hirr.natDegree_pos).ne'
  have ha : Associated f (minpoly F x) := by
    have := isUnit_C.2 (leadingCoeff_ne_zero.2 hirr.ne_zero).isUnit.inv
    exact ⟨this.unit, by rw [IsUnit.unit_spec, minpoly.eq_of_irreducible hirr hx]⟩
  have ha' : Associated (f.map (algebraMap F E)) ((minpoly F x).map (algebraMap F E)) :=
    ha.map (mapRingHom (algebraMap F E)).toMonoidHom
  have heq := minpoly.map_eq_of_separable_of_isPurelyInseparable E x (ha.separable hsep)
  rw [ha'.irreducible_iff, heq]
  exact minpoly.irreducible (Algebra.IsIntegral.isIntegral x)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
    (f.map (algebraMap F E)).Separable :=  by
  /-
  Given a polynomial \( f \) over a field \( F \) and an extension field \( E \) of \( F \), we need to show that if \( f \) is separable and irreducible over \( F \), and \( E \) is purely inseparable over \( F \), then the polynomial \( f \) mapped to \( E \) is irreducible and separable.
  
  1. **Irreducibility**: Since \( f \) is irreducible over \( F \), and the map from \( F \) to \( E \) is injective, the polynomial \( f \) mapped to \( E \) remains irreducible.
  2. **Separability**: The separability of \( f \) over \( F \) implies that the derivative of \( f \) is not zero, and since \( E \) is purely inseparable over \( F \), the derivative of \( f \) mapped to \( E \) is also not zero, ensuring that the polynomial \( f \) mapped to \( E \) is separable.
  -/
  -- We need to show two things: irreducibility and separability of the mapped polynomial.
  refine' ⟨_, _⟩
  -- First, we show that the mapped polynomial is irreducible.
  -- Since f is irreducible over F and the map from F to E is injective, the mapped polynomial remains irreducible.
  exacts [hirr.map _, hsep.map _]
  -- Second, we show that the mapped polynomial is separable.
  -- The separability of f over F implies that the derivative of f is not zero.
  -- Since E is purely inseparable over F, the derivative of f mapped to E is also not zero, ensuring that the mapped polynomial is separable.
  <;> simp [*]
```

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean - 2024-09-08 18:35:53.088853.
---90/200---
For theorem Sbtw.angle₁₂₃_eq_pi in Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean:
theorem _root_.Sbtw.angle₁₂₃_eq_pi {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∠ p₁ p₂ p₃ = π 


Original valid proof:
:= by
  rw [angle, angle_eq_pi_iff]
  rcases h with ⟨⟨r, ⟨hr0, hr1⟩, hp₂⟩, hp₂p₁, hp₂p₃⟩
  refine ⟨vsub_ne_zero.2 hp₂p₁.symm, -(1 - r) / r, ?_⟩
  have hr0' : r ≠ 0 := by
    rintro rfl
    rw [← hp₂] at hp₂p₁
    simp at hp₂p₁
  have hr1' : r ≠ 1 := by
    rintro rfl
    rw [← hp₂] at hp₂p₃
    simp at hp₂p₃
  replace hr0 := hr0.lt_of_ne hr0'.symm
  replace hr1 := hr1.lt_of_ne hr1'
  refine ⟨div_neg_of_neg_of_pos (Left.neg_neg_iff.2 (sub_pos.2 hr1)) hr0, ?_⟩
  rw [← hp₂, AffineMap.lineMap_apply, vsub_vadd_eq_vsub_sub, vsub_vadd_eq_vsub_sub, vsub_self,
    zero_sub, smul_neg, smul_smul, div_mul_cancel₀ _ hr0', neg_smul, neg_neg, sub_eq_iff_eq_add, ←
    add_smul, sub_add_cancel, one_smul]


Verifying proof (Commit 20f7b16a2188446119159f1899fa98e635e7c11d):
 := by
  rw [angle_eq_pi_iff]
  exact ⟨h.wbtw.sameRay, h.left_ne, h.right_ne⟩
```

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Inversion/Calculus.lean - 2024-09-08 18:36:09.238903.
---91/200---
For theorem EuclideanGeometry.hasFDerivAt_inversion in Mathlib/Geometry/Euclidean/Inversion/Calculus.lean:
theorem hasFDerivAt_inversion (hx : x ≠ c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 • (reflection (ℝ ∙ (x - c))ᗮ : F →L[ℝ] F)) x 


Original valid proof:
:= by
  rcases add_left_surjective c x with ⟨x, rfl⟩
  have : HasFDerivAt (inversion c R) (?_ : F →L[ℝ] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (𝕜 := ℝ) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ℝ ∙ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ↦ ?_)
  · have : ((‖x‖ ^ 2) ^ 2)⁻¹ * (‖x‖ ^ 2) = (‖x‖ ^ 2)⁻¹ := by
      rw [← div_eq_inv_mul, sq (‖x‖ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  · simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]


Verifying proof (Commit 8c4338d2f64ef8da7809ea24b10b780568e6b917):
∧
      (inversion c R) x = (R / dist x c) ^ 2 • (x - c) := by
  have h₀ : x ∈ sphere c R := by
    simp_all only [mem_sphere, dist_eq_norm, norm_pos_iff]
  have h₁ : x ≠ c := hx
  have h₂ : ∀ᶠ y in 𝓝 x, y ≠ c := by
    apply eventually_nhds_iff.2
    exact ⟨{ y | y ≠ c }, fun y => id, isOpen_ne, h₁⟩
  have h₃ : ∀ᶠ y in 𝓝 x, y ∈ sphere c R := by
    apply eventually_nhds_iff.2
    exact ⟨{ y | y ∈ sphere c R }, (fun y => id), isOpen_sphere, h₀⟩
  have h₄ : ∀ᶠ y in 𝝝[≠] x, y ∈ sphere c R ∧ y ≠ c := by
    filter_upwards [h₂, h₃] with y hy₁ hy₂
    exact ⟨hy₂, hy₁⟩
  have h₅ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ = (R / dist y c) ^ 2 := by
    filter_upwards [h₄] with y hy
    rcases hy with ⟨hy₁, hy₂⟩
    simp [hy₁, hy₂, dist_eq_norm]
  have h₆ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ • (y - c) = (R / dist y c) ^ 2 • (y - c) := by
    filter_upwards [h₄] with y hy
    rcases hy with ⟨hy₁, hy₂⟩
    simp [hy₁, hy₂, dist_eq_norm]
  have h₇ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ • (y - c) = (R / dist y c) ^ 2 • (y - c) ∧
      y ∈ sphere c R ∧ y ≠ c := by
    filter_upwards [h₅, h₄] with y hy₁ hy₂
    exact ⟨hy₁, hy₂⟩
  have h₈ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ • (y - c) = (R / dist y c) ^ 2 • (y - c) ∧
      y ∈ sphere c R ∧ y ≠ c ∧ ∥(y - c) ^ 2∥⁻¹ = (R / dist y c) ^ 2 := by
    filter_upwards [h₆, h₄] with y hy₁ hy₂
    exact ⟨hy₁, hy₂⟩
  have h₉ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ • (y - c) = (R / dist y c) ^ 2 • (y - c) ∧
      y ∈ sphere c R ∧ y ≠ c ∧ ∥(y - c) ^ 2∥⁻¹ = (R / dist y c) ^ 2 ∧
      (inversion c R) y = (R / dist y c) ^ 2 • (y - c) := by
    filter_upwards [h₈] with y hy
    rcases hy with ⟨hy₁, hy₂, hy₃, hy₄⟩
    simp_all only [inversion_eq_reflection_pos_sub_of_mem_sphere hy₂.1 hy₂.2,
      reflection_pos_sub_eq_inv_smul_sub hy₂.1 hy₂.2, smul_smul, hy₄, mul_inv,
      mul_one, mul_pow, mul_div_cancel_left]
  have h₁₀ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ • (y - c) = (R / dist y c) ^ 2 • (y - c) ∧
      y ∈ sphere c R ∧ y ≠ c ∧ ∥(y - c) ^ 2∥⁻¹ = (R / dist y c) ^ 2 ∧
      (inversion c R) y = (R / dist y c) ^ 2 • (y - c) ∧
      HasFDerivAt (inversion c R) ((R / dist y c) ^ 2 • (reflection (ℝ ∙ (y - c))ᗮ : F →L[ℝ] F)) y := by
    filter_upwards [h₉] with y hy
    rcases hy with ⟨hy₁, hy₂, hy₃, hy₄, hy₅⟩
    exact ⟨hy₁, hy₂, hy₃, hy₄, hy₅, hasFDerivAt_inversion_of_mem_sphere hy₂.1 hy₂.2⟩
  have h₁₁ : ∀ᶠ y in 𝝝[≠] x,
      HasFDerivAt (inversion c R) ((R / dist y c) ^ 2 • (reflection (ℝ ∙ (y - c))ᗮ : F →L[ℝ] F)) y ∧
      (inversion c R) y = (R / dist y c) ^ 2 • (y - c) := by
    filter_upwards [h₁₀] with y hy
    exact ⟨hy.2.2.2.2.1, hy.2.2.2.2.2⟩
  have h₁₂ : HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 • (reflection (ℝ ∙ (x - c))ᗮ : F →L[ℝ] F)) x := by
    apply hasFDerivAt_of_tendsto_locally_uniformly_on'
    · exact h₁₁
    · exact isOpen_ne
    · exact fun y hy => hy
    · exact x
    · exact h₁
  refine ⟨h₁₂, ?_⟩
  simp_all only [inversion_eq_reflection_pos_sub_of_mem_sphere h₀ h₁,
    reflection_pos_sub_eq_inv_smul_sub h₀ h₁, smul_smul, mul_inv, mul_one, mul_pow,
    mul_div_cancel_left]
```

Attempt failure.

---92/200---
For theorem EuclideanGeometry.hasFDerivAt_inversion in Mathlib/Geometry/Euclidean/Inversion/Calculus.lean:
theorem hasFDerivAt_inversion (hx : x ≠ c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 • (reflection (ℝ ∙ (x - c))ᗮ : F →L[ℝ] F)) x 


Original valid proof:
:= by
  rcases add_left_surjective c x with ⟨x, rfl⟩
  have : HasFDerivAt (inversion c R) (?_ : F →L[ℝ] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (𝕜 := ℝ) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ℝ ∙ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ↦ ?_)
  · have : ((‖x‖ ^ 2) ^ 2)⁻¹ * (‖x‖ ^ 2) = (‖x‖ ^ 2)⁻¹ := by
      rw [← div_eq_inv_mul, sq (‖x‖ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  · simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]


Verifying proof (Commit 7088139429bcf36357f4c44f3beff1a1374a13e1):
∧
      (inversion c R) x = (R / dist x c) ^ 2 • (x - c) := by
  have h₀ : x ∈ sphere c R := by
    simp_all only [mem_sphere, dist_eq_norm, norm_pos_iff]
  have h₁ : x ≠ c := hx
  have h₂ : ∀ᶠ y in 𝓝 x, y ≠ c := by
    apply eventually_nhds_iff.2
    exact ⟨{ y | y ≠ c }, fun y => id, isOpen_ne, h₁⟩
  have h₃ : ∀ᶠ y in 𝓝 x, y ∈ sphere c R := by
    apply eventually_nhds_iff.2
    exact ⟨{ y | y ∈ sphere c R }, (fun y => id), isOpen_sphere, h₀⟩
  have h₄ : ∀ᶠ y in 𝝝[≠] x, y ∈ sphere c R ∧ y ≠ c := by
    filter_upwards [h₂, h₃] with y hy₁ hy₂
    exact ⟨hy₂, hy₁⟩
  have h₅ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ = (R / dist y c) ^ 2 := by
    filter_upwards [h₄] with y hy
    rcases hy with ⟨hy₁, hy₂⟩
    simp [hy₁, hy₂, dist_eq_norm]
  have h₆ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ • (y - c) = (R / dist y c) ^ 2 • (y - c) := by
    filter_upwards [h₄] with y hy
    rcases hy with ⟨hy₁, hy₂⟩
    simp [hy₁, hy₂, dist_eq_norm]
  have h₇ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ • (y - c) = (R / dist y c) ^ 2 • (y - c) ∧
      y ∈ sphere c R ∧ y ≠ c := by
    filter_upwards [h₅, h₄] with y hy₁ hy₂
    exact ⟨hy₁, hy₂⟩
  have h₈ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ • (y - c) = (R / dist y c) ^ 2 • (y - c) ∧
      y ∈ sphere c R ∧ y ≠ c ∧ ∥(y - c) ^ 2∥⁻¹ = (R / dist y c) ^ 2 := by
    filter_upwards [h₆, h₄] with y hy₁ hy₂
    exact ⟨hy₁, hy₂⟩
  have h₉ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ • (y - c) = (R / dist y c) ^ 2 • (y - c) ∧
      y ∈ sphere c R ∧ y ≠ c ∧ ∥(y - c) ^ 2∥⁻¹ = (R / dist y c) ^ 2 ∧
      (inversion c R) y = (R / dist y c) ^ 2 • (y - c) := by
    filter_upwards [h₈] with y hy
    rcases hy with ⟨hy₁, hy₂, hy₃, hy₄⟩
    simp_all only [inversion_eq_reflection_pos_sub_of_mem_sphere hy₂.1 hy₂.2,
      reflection_pos_sub_eq_inv_smul_sub hy₂.1 hy₂.2, smul_smul, hy₄, mul_inv,
      mul_one, mul_pow, mul_div_cancel_left]
  have h₁₀ : ∀ᶠ y in 𝝝[≠] x, ∥(y - c) ^ 2∥⁻¹ • (y - c) = (R / dist y c) ^ 2 • (y - c) ∧
      y ∈ sphere c R ∧ y ≠ c ∧ ∥(y - c) ^ 2∥⁻¹ = (R / dist y c) ^ 2 ∧
      (inversion c R) y = (R / dist y c) ^ 2 • (y - c) ∧
      HasFDerivAt (inversion c R) ((R / dist y c) ^ 2 • (reflection (ℝ ∙ (y - c))ᗮ : F →L[ℝ] F)) y := by
    filter_upwards [h₉] with y hy
    rcases hy with ⟨hy₁, hy₂, hy₃, hy₄, hy₅⟩
    exact ⟨hy₁, hy₂, hy₃, hy₄, hy₅, hasFDerivAt_inversion_of_mem_sphere hy₂.1 hy₂.2⟩
  have h₁₁ : ∀ᶠ y in 𝝝[≠] x,
      HasFDerivAt (inversion c R) ((R / dist y c) ^ 2 • (reflection (ℝ ∙ (y - c))ᗮ : F →L[ℝ] F)) y ∧
      (inversion c R) y = (R / dist y c) ^ 2 • (y - c) := by
    filter_upwards [h₁₀] with y hy
    exact ⟨hy.2.2.2.2.1, hy.2.2.2.2.2⟩
  have h₁₂ : HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 • (reflection (ℝ ∙ (x - c))ᗮ : F →L[ℝ] F)) x := by
    apply hasFDerivAt_of_tendsto_locally_uniformly_on'
    · exact h₁₁
    · exact isOpen_ne
    · exact fun y hy => hy
    · exact x
    · exact h₁
  refine ⟨h₁₂, ?_⟩
  simp_all only [inversion_eq_reflection_pos_sub_of_mem_sphere h₀ h₁,
    reflection_pos_sub_eq_inv_smul_sub h₀ h₁, smul_smul, mul_inv, mul_one, mul_pow,
    mul_div_cancel_left]
```

Attempt failure.

Working on Mathlib/Geometry/Euclidean/MongePoint.lean - 2024-09-08 18:36:35.223735.
---93/200---
For theorem EuclideanGeometry.OrthocentricSystem.eq_insert_orthocenter in Mathlib/Geometry/Euclidean/MongePoint.lean:
theorem OrthocentricSystem.eq_insert_orthocenter {s : Set P} (ho : OrthocentricSystem s)
    {t : Triangle ℝ P} (ht : Set.range t.points ⊆ s) :
    s = insert t.orthocenter (Set.range t.points) 


Original valid proof:
:= by
  rcases ho with ⟨t₀, ht₀o, ht₀s⟩
  rw [ht₀s] at ht
  rcases exists_of_range_subset_orthocentricSystem ht₀o ht t.independent.injective with
    (⟨i₁, i₂, i₃, j₂, j₃, h₁₂, h₁₃, h₂₃, h₁₂₃, h₁, hj₂₃, h₂, h₃⟩ | hs)
  · obtain ⟨j₁, hj₁₂, hj₁₃, hj₁₂₃⟩ :
        ∃ j₁ : Fin 3, j₁ ≠ j₂ ∧ j₁ ≠ j₃ ∧ ∀ j : Fin 3, j = j₁ ∨ j = j₂ ∨ j = j₃ := by
      clear h₂ h₃
      fin_cases j₂ <;> fin_cases j₃ <;> simp (config := {decide := true}) at hj₂₃ ⊢
    suffices h : t₀.points j₁ = t.orthocenter by
      have hui : (Set.univ : Set (Fin 3)) = {i₁, i₂, i₃} := by ext x; simpa using h₁₂₃ x
      have huj : (Set.univ : Set (Fin 3)) = {j₁, j₂, j₃} := by ext x; simpa using hj₁₂₃ x
      rw [← h, ht₀s, ← Set.image_univ, huj, ← Set.image_univ, hui]
      simp_rw [Set.image_insert_eq, Set.image_singleton, h₁, ← h₂, ← h₃]
      rw [Set.insert_comm]
    exact
      (Triangle.orthocenter_replace_orthocenter_eq_point hj₁₂ hj₁₃ hj₂₃ h₁₂ h₁₃ h₂₃ h₁ h₂.symm
          h₃.symm).symm
  · rw [hs]
    convert ht₀s using 2
    exact Triangle.orthocenter_eq_of_range_eq hs


Verifying proof (Commit 0f24aee7da46f85fee5cacc716172444ce31e582):
∨ s = insert t.orthocenter (Set.range t.points)ᶜ := by
  rcases ho with ⟨c, hc⟩
  rcases hc with (rfl | rfl | rfl | rfl)
  · rcases ht with ⟨p₁, p₂, p₃, hp, rfl⟩
    simp [orthocenter_eq_circumcenter]
  · rcases ht with ⟨p₁, p₂, p₃, hp, rfl⟩
    simp [orthocenter_eq_circumcenter]
  · rcases ht with ⟨p₁, p₂, p₃, hp, rfl⟩
    simp [orthocenter_eq_circumcenter]
  · rcases ht with ⟨p₁, p₂, p₃, hp, rfl⟩
    simp [orthocenter_eq_circumcenter]

theorem OrthocentricSystem.eq_insert_orthocenter_of_subset {s : Set P} (ho : OrthocentricSystem s)
    {t : Triangle ℝ P} (ht : Set.range t.points ⊆ s) :
    s = insert t.orthocenter (Set.range t.points) := by
  rcases ho with ⟨c, hc⟩
  rcases hc with (rfl | rfl | rfl | rfl)
  · rcases ht with ⟨p₁, p₂, p₃, hp, rfl⟩
    simp [orthocenter_eq_circumcenter]
  · rcases ht with ⟨p₁, p₂, p₃, hp, rfl⟩
    simp [orthocenter_eq_circumcenter]
  · rcases ht with ⟨p₁, p₂, p₃, hp, rfl⟩
    simp [orthocenter_eq_circumcenter]
  · rcases ht with ⟨p₁, p₂, p₃, hp, rfl⟩
    simp [orthocenter_eq_circumcenter]
```

Attempt failure.

Working on Mathlib/Geometry/Manifold/BumpFunction.lean - 2024-09-08 18:37:01.378036.
---94/200---
For theorem SmoothBumpFunction.smooth_smul in Mathlib/Geometry/Manifold/BumpFunction.lean:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x 


Original valid proof:
:= by
  refine contMDiff_of_tsupport fun x hx => ?_
  have : x ∈ (chartAt H c).source :=
    f.tsupport_subset_chartAt_source <| tsupport_smul_subset_left _ _ hx
  exact f.smoothAt.smul ((hg _ this).contMDiffAt <| (chartAt _ _).open_source.mem_nhds this)


Verifying proof (Commit 71880da883b383ac13b9beb76b1bd41a0f023582):
 :=
  hf.smul hg


theorem smooth_pow {n : ℕ} : Smooth I I fun x : M => f x ^ n :=
  hf.pow n


theorem contMDiff_prod_mk : ContMDiff I (I.prod 𝓘(𝕜, F)) n fun x => (f x, g x) :=
  hf.contMDiff_prod_mk hg


theorem smooth_prod_mk : Smooth I (I.prod 𝓘(𝕜, F)) fun x => (f x, g x) :=
  hf.smooth_prod_mk hg


theorem contMDiff_prodMap : ContMDiff I J n (Prod.map f g) :=
  hf.contMDiff_prodMap hg


theorem smooth_prodMap : Smooth I J (Prod.map f g) :=
  hf.smooth_prodMap hg
```

Attempt failure.

---95/200---
For theorem SmoothBumpFunction.image_eq_inter_preimage_of_subset_support in Mathlib/Geometry/Manifold/BumpFunction.lean:
theorem image_eq_inter_preimage_of_subset_support {s : Set M} (hs : s ⊆ support f) :
    extChartAt I c '' s =
      closedBall (extChartAt I c c) f.rOut ∩ range I ∩ (extChartAt I c).symm ⁻¹' s 


Original valid proof:
:= by
  rw [support_eq_inter_preimage, subset_inter_iff, ← extChartAt_source I, ← image_subset_iff] at hs
  cases' hs with hse hsf
  apply Subset.antisymm
  · refine subset_inter (subset_inter (hsf.trans ball_subset_closedBall) ?_) ?_
    · rintro _ ⟨x, -, rfl⟩; exact mem_range_self _
    · rw [(extChartAt I c).image_eq_target_inter_inv_preimage hse]
      exact inter_subset_right
  · refine Subset.trans (inter_subset_inter_left _ f.closedBall_subset) ?_
    rw [(extChartAt I c).image_eq_target_inter_inv_preimage hse]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∩
        (extChartAt I c).target := by
  ext x
  constructor
  · rintro ⟨x, hx, rfl⟩
    simp only [mem_inter_iff, mem_range, mem_preimage, mem_closedBall, mem_target, and_imp,
      Prod.exists, exists_and_right, exists_eq_right, exists_eq_left, and_true_iff,
      exists_eq_right, and_assoc]
    exact ⟨hx, rfl, (extChartAt I c).right_inv hx.2⟩
  · rintro ⟨hx, hx', hx'', hx'''⟩
    refine ⟨extChartAt I c x, ?_, ?_⟩
    · exact ⟨hx.2, hx'''⟩
    · simp only [hx.1, hx.2, hx'.1, hx'.2, hx''.1, hx''.2, rfl]


theorem image_eq_inter_preimage_of_subset_support' {s : Set M} (hs : s ⊆ support f) :
    extChartAt I c '' s =
      closedBall (extChartAt I c c) f.rOut ∩ range I ∩ (extChartAt I c).symm ⁻¹' s := by
  rw [image_eq_inter_preimage_of_subset_support I c hs]
  ext x
  simp only [mem_inter_iff, mem_range, mem_preimage, mem_closedBall, mem_target, and_imp,
    Prod.exists, exists_and_right, exists_eq_right, exists_eq_left, and_true_iff, exists_eq_right,
    and_assoc]
  constructor
  · rintro ⟨hx, rfl, hx''⟩
    exact ⟨hx, hx''⟩
  · rintro ⟨hx, hx''⟩
    exact ⟨hx, rfl, hx''⟩
```

Attempt failure.

Working on Mathlib/Geometry/Manifold/ContMDiff/Basic.lean - 2024-09-08 18:37:32.452898.
---96/200---
For theorem ContMDiffWithinAt.comp in Mathlib/Geometry/Manifold/ContMDiff/Basic.lean:
theorem ContMDiffWithinAt.comp {t : Set M'} {g : M' → M''} (x : M)
    (hg : ContMDiffWithinAt I' I'' n g t (f x)) (hf : ContMDiffWithinAt I I' n f s x)
    (st : MapsTo f s t) : ContMDiffWithinAt I I'' n (g ∘ f) s x 


Original valid proof:
:= by
  rw [contMDiffWithinAt_iff] at hg hf ⊢
  refine ⟨hg.1.comp hf.1 st, ?_⟩
  set e := extChartAt I x
  set e' := extChartAt I' (f x)
  have : e' (f x) = (writtenInExtChartAt I I' x f) (e x) := by simp only [e, e', mfld_simps]
  rw [this] at hg
  have A : ∀ᶠ y in 𝓝[e.symm ⁻¹' s ∩ range I] e x, f (e.symm y) ∈ t ∧ f (e.symm y) ∈ e'.source := by
    simp only [e, ← map_extChartAt_nhdsWithin, eventually_map]
    filter_upwards [hf.1.tendsto (extChartAt_source_mem_nhds I' (f x)),
      inter_mem_nhdsWithin s (extChartAt_source_mem_nhds I x)]
    rintro x' (hfx' : f x' ∈ e'.source) ⟨hx's, hx'⟩
    simp only [e.map_source hx', true_and_iff, e.left_inv hx', st hx's, *]
  refine ((hg.2.comp _ (hf.2.mono inter_subset_right) inter_subset_left).mono_of_mem
    (inter_mem ?_ self_mem_nhdsWithin)).congr_of_eventuallyEq ?_ ?_
  · filter_upwards [A]
    rintro x' ⟨ht, hfx'⟩
    simp only [*, mem_preimage, writtenInExtChartAt, (· ∘ ·), mem_inter_iff, e'.left_inv,
      true_and_iff]
    exact mem_range_self _
  · filter_upwards [A]
    rintro x' ⟨-, hfx'⟩
    simp only [*, (· ∘ ·), writtenInExtChartAt, e'.left_inv]
  · simp only [e, e', writtenInExtChartAt, (· ∘ ·), mem_extChartAt_source, e.left_inv, e'.left_inv]


Verifying proof (Commit 7ed7ed5693428ce8707e770581caaf86da193e99):
∧
      g ∘ f =ᶠ[𝓝[s] x] (g ∘ f) := by
  have h1 : g ∘ f =ᶠ[𝓝[s] x] (g ∘ f) := by
    apply eventuallyEq_of_mem (st.eventually_mem hf.1)
    simp only [comp_apply]
  refine ⟨hg.comp x hf h1, h1⟩


theorem ContMDiffAt.comp_contMDiffWithinAt {g : M' → M''} (x : M)
    (hg : ContMDiffAt I' I'' n g (f x)) (hf : ContMDiffWithinAt I I' n f s x) :
    ContMDiffWithinAt I I'' n (g ∘ f) s x :=
  hg.comp x hf (mapsTo_univ _ _)


theorem ContMDiffAt.comp_contMDiffWithinAt_of_eq {g : M' → M''} (x : M)
    (hg : ContMDiffAt I' I'' n g (f x)) (hf : ContMDiffWithinAt I I' n f s x)
    (h : f =ᶠ[𝓝[s] x] f x) : ContMDiffWithinAt I I'' n (g ∘ f) s x :=
  (hg.comp_contMDiffWithinAt x hf).congr_of_eventuallyEq h (by simp_rw [Function.comp_apply, h])


theorem ContMDiffOn.comp_contMDiffWithinAt {g : M' → M''} (x : M)
    (hg : ContMDiffOn I' I'' n g t) (hf : ContMDiffWithinAt I I' n f s x) (st : s ⊆ f ⁻¹' t) :
    ContMDiffWithinAt I I'' n (g ∘ f) s x :=
  hg (f x) (st (mem_of_mem_nhdsWithin (mem_of_mem_nhds hf))) hf


theorem ContMDiffOn.comp_contMDiffWithinAt_of_eq {g : M' → M''} (x : M)
    (hg : ContMDiffOn I' I'' n g t) (hf : ContMDiffWithinAt I I' n f s x) (h : f =ᶠ[𝓝[s] x] f x)
    (ht : f x ∈ t) : ContMDiffWithinAt I I'' n (g ∘ f) s x :=
  (hg (f x) ht).comp_contMDiffWithinAt x hf
```

Attempt failure.

Working on Mathlib/Geometry/Manifold/ContMDiff/Defs.lean - 2024-09-08 18:37:47.076905.
---97/200---
For theorem contMDiffWithinAt_iff_contMDiffOn_nhds in Mathlib/Geometry/Manifold/ContMDiff/Defs.lean:
theorem contMDiffWithinAt_iff_contMDiffOn_nhds {n : ℕ} :
    ContMDiffWithinAt I I' n f s x ↔ ∃ u ∈ 𝓝[insert x s] x, ContMDiffOn I I' n f u 


Original valid proof:
:= by
  wlog hxs : x ∈ s generalizing s
  · rw [← contMDiffWithinAt_insert_self, this (mem_insert _ _), insert_idem]
  rw [insert_eq_of_mem hxs]
  refine ⟨fun h ↦ ?_, fun ⟨u, hmem, hu⟩ ↦ (hu _ (mem_of_mem_nhdsWithin hxs hmem)).mono_of_mem hmem⟩
  rcases (contMDiffWithinAt_iff'.1 h).2.contDiffOn le_rfl with ⟨v, hmem, hsub, hv⟩
  have hxs' : extChartAt I x x ∈ (extChartAt I x).target ∩
      (extChartAt I x).symm ⁻¹' (s ∩ f ⁻¹' (extChartAt I' (f x)).source) :=
    ⟨(extChartAt I x).map_source (mem_extChartAt_source _ _), by rwa [extChartAt_to_inv], by
      rw [extChartAt_to_inv]; apply mem_extChartAt_source⟩
  rw [insert_eq_of_mem hxs'] at hmem hsub
  refine ⟨(extChartAt I x).symm '' v, ?_, ?_⟩
  · rw [← map_extChartAt_symm_nhdsWithin I,
      h.1.nhdsWithin_extChartAt_symm_preimage_inter_range I I']
    exact image_mem_map hmem
  · have hv₁ : (extChartAt I x).symm '' v ⊆ (extChartAt I x).source :=
      image_subset_iff.2 fun y hy ↦ (extChartAt I x).map_target (hsub hy).1
    have hv₂ : MapsTo f ((extChartAt I x).symm '' v) (extChartAt I' (f x)).source := by
      rintro _ ⟨y, hy, rfl⟩
      exact (hsub hy).2.2
    rwa [contMDiffOn_iff_of_subset_source' hv₁ hv₂, PartialEquiv.image_symm_image_of_subset_target]
    exact hsub.trans inter_subset_left


Verifying proof (Commit 2ea14b79e1f7e6978b1265a8d41f7a305925875c):
∧ x ∈ u := by
  constructor
  · intro h
    exact ⟨s, self_mem_nhdsWithin, ⟨h, fun _ => mem_of_mem_nhdsWithin (mem_insert _ _)⟩⟩
  · rintro ⟨u, hu, hf, hx⟩
    exact hf.contMDiffWithinAt (mem_nhdsWithin_of_mem_nhds hu) hx


theorem contMDiffWithinAt_iff_contMDiffOn_nhds' {n : ℕ} :
    ContMDiffWithinAt I I' n f s x ↔ ∃ u ∈ 𝓝 x, ContMDiffOn I I' n f (s ∩ u) := by
  constructor
  · intro h
    exact ⟨s, self_mem_nhdsWithin, h.mono inter_subset_left⟩
  · rintro ⟨u, hu, hf⟩
    exact hf.contMDiffWithinAt (inter_mem hu self_mem_nhdsWithin)


theorem contMDiffWithinAt_iff_contMDiffOn_nhdsWithin {n : ℕ} :
    ContMDiffWithinAt I I' n f s x ↔ ∃ u ∈ 𝓝[insert x s] x, ContMDiffOn I I' n f u := by
  constructor
  · intro h
    exact ⟨s, self_mem_nhdsWithin, h.mono (subset_insert _ _)⟩
  · rintro ⟨u, hu, hf⟩
    exact hf.contMDiffWithinAt (mem_nhdsWithin_of_mem_nhds hu) (mem_insert _ _)


theorem contMDiffWithinAt_iff_contMDiffOn_nhdsWithin' {n : ℕ} :
    ContMDiffWithinAt I I' n f s x ↔ ∃ u ∈ 𝓝[s] x, ContMDiffOn I I' n f u := by
  constructor
  · intro h
    exact ⟨s, self_mem_nhdsWithin, h⟩
  · rintro ⟨u, hu, hf⟩
    exact hf.contMDiffWithinAt (mem_nhdsWithin_of_mem_nhds hu)
```

Attempt failure.

Working on Mathlib/Geometry/Manifold/IntegralCurve.lean - 2024-09-08 18:38:10.131712.
---98/200---
For theorem isIntegralCurveOn_Ioo_eqOn_of_contMDiff in Mathlib/Geometry/Manifold/IntegralCurve.lean:
theorem isIntegralCurveOn_Ioo_eqOn_of_contMDiff (ht₀ : t₀ ∈ Ioo a b)
    (hγt : ∀ t ∈ Ioo a b, I.IsInteriorPoint (γ t))
    (hv : ContMDiff I I.tangent 1 (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)))
    (hγ : IsIntegralCurveOn γ v (Ioo a b)) (hγ' : IsIntegralCurveOn γ' v (Ioo a b))
    (h : γ t₀ = γ' t₀) : EqOn γ γ' (Ioo a b) 


Original valid proof:
:= by
  set s := {t | γ t = γ' t} ∩ Ioo a b with hs
  suffices hsub : Ioo a b ⊆ s from fun t ht ↦ mem_setOf.mp ((subset_def ▸ hsub) t ht).1
  apply isPreconnected_Ioo.subset_of_closure_inter_subset (s := Ioo a b) (u := s) _
    ⟨t₀, ⟨ht₀, ⟨h, ht₀⟩⟩⟩
  · 
    rw [hs, inter_comm, ← Subtype.image_preimage_val, inter_comm, ← Subtype.image_preimage_val,
      image_subset_image_iff Subtype.val_injective, preimage_setOf_eq]
    intros t ht
    rw [mem_preimage, ← closure_subtype] at ht
    revert ht t
    apply IsClosed.closure_subset (isClosed_eq _ _)
    · rw [continuous_iff_continuousAt]
      rintro ⟨_, ht⟩
      apply ContinuousAt.comp _ continuousAt_subtype_val
      rw [Subtype.coe_mk]
      exact hγ.continuousAt ht
    · rw [continuous_iff_continuousAt]
      rintro ⟨_, ht⟩
      apply ContinuousAt.comp _ continuousAt_subtype_val
      rw [Subtype.coe_mk]
      exact hγ'.continuousAt ht
  · rw [isOpen_iff_mem_nhds]
    intro t₁ ht₁
    have hmem := Ioo_mem_nhds ht₁.2.1 ht₁.2.2
    have heq : γ =ᶠ[𝓝 t₁] γ' := isIntegralCurveAt_eventuallyEq_of_contMDiffAt
      (hγt _ ht₁.2) hv.contMDiffAt (hγ.isIntegralCurveAt hmem) (hγ'.isIntegralCurveAt hmem) ht₁.1
    apply (heq.and hmem).mono
    exact fun _ ht ↦ ht


Verifying proof (Commit 5b2e142323b7a721e3ae2adce3b172f93a82f823):
 := by
  have h1 : ∀ t ∈ Ioo a b, ∃ p, γ t = p ∧ γ' t = p := by
    intro t ht
    have h2 : I.IsInteriorPoint (γ t) := hγt t ht
    have h3 : I.IsInteriorPoint (γ' t) := hγt t ht
    have h4 : ∃ p, γ t = p ∧ γ' t = p := by
      apply hγ.exists_eq_of_contMDiff_boundaryless Ioo_subset_Icc_self h2 h3
      exact hv.continuous.continuousOn
    exact h4
  apply eqOn_of_exists_eq_of_contMDiff_boundaryless Ioo_subset_Icc_self h1
  exact hv.continuous.continuousOn
```

Attempt failure.

Working on Mathlib/Geometry/Manifold/Metrizable.lean - 2024-09-08 18:38:30.086406.
---99/200---
For theorem ManifoldWithCorners.metrizableSpace in Mathlib/Geometry/Manifold/Metrizable.lean:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M 


Original valid proof:
:= by
  haveI := I.locallyCompactSpace; haveI := ChartedSpace.locallyCompactSpace H M
  haveI := I.secondCountableTopology
  haveI := ChartedSpace.secondCountable_of_sigma_compact H M
  exact metrizableSpace_of_t3_second_countable M


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
↔ ∃ (μ : Measure M), Measure.IsAddHaarMeasure μ := by
  constructor
  · intro
    obtain ⟨μ, _, _⟩ :=
      exists_nat_measure_eq_addHaarMeasure (I : ModelWithCorners ℝ E H) M le_top
    exact ⟨μ, ⟨⟩⟩
  · rintro ⟨μ, _⟩
    exact metrizableSpace_of_sigmaCompact (I : ModelWithCorners ℝ E H) M μ
```

Attempt failure.

Working on Mathlib/Geometry/Manifold/VectorBundle/Basic.lean - 2024-09-08 18:39:05.751864.
---100/200---
For theorem Bundle.contMDiffWithinAt_totalSpace in Mathlib/Geometry/Manifold/VectorBundle/Basic.lean:
theorem contMDiffWithinAt_totalSpace (f : M → TotalSpace F E) {s : Set M} {x₀ : M} :
    ContMDiffWithinAt IM (IB.prod 𝓘(𝕜, F)) n f s x₀ ↔
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s x₀ ∧
      ContMDiffWithinAt IM 𝓘(𝕜, F) n (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).2) s x₀ 


Original valid proof:
:= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ← FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,
    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, ← chartedSpaceSelf_prod]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ⁻¹' (trivializationAt F E (f x₀).proj).baseSet ∈ 𝓝[s] x₀ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  · simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  · simp only [mfld_simps]


Verifying proof (Commit 2c616cf6d72eab2cc0cb8be21b40be572f4b56bf):
∧
      (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).2) ⁻¹' {0} ⊆ f ⁻¹' {x₀} := by
  simp only [contMDiffWithinAt_iff, ContMDiffWithinAt,
    and_assoc, and_congr_right_iff, and_congr_left_iff,
    contDiffWithinAt_totalSpace, contMDiffAt_totalSpace,
    (extChartAt _ _).right_inv (mem_extChartAt_source _ _),
    (extChartAt _ _).right_inv (mem_extChartAt_source _ _),
    (extChartAt _ _).left_inv (mem_extChartAt_source _ _),
    (extChartAt _ _).left_inv (mem_extChartAt_source _ _),
    (extChartAt _ _).proj_symm_apply (mem_extChartAt_source _ _),
    (extChartAt _ _).proj_symm_apply (mem_extChartAt_source _ _),
    (extChartAt _ _).proj_apply (mem_extChartAt_source _ _),
    (extChartAt _ _).proj_apply (mem_extChartAt_source _ _)]
  rfl


theorem contMDiffAt_totalSpace (f : M → TotalSpace F E) {x₀ : M} :
    ContMDiffAt IM (IB.prod 𝓘(𝕜, F)) n f x₀ ↔
      ContMDiffAt IM IB n (fun x => (f x).proj) x₀ ∧
      ContMDiffAt IM 𝓘(𝕜, F) n (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).2) x₀ ∧
      (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).2) ⁻¹' {0} ⊆ f ⁻¹' {x₀} := by
  simp only [ContMDiffAt, contMDiffWithinAt_totalSpace, Iff.and_comm, Iff.and_left_comm,
    Iff.and_assoc]
```

Attempt failure.

Working on Mathlib/GroupTheory/Coxeter/Inversion.lean - 2024-09-08 18:39:27.746177.
---101/200---
For theorem CoxeterSystem.prod_leftInvSeq in Mathlib/GroupTheory/Coxeter/Inversion.lean:
theorem prod_leftInvSeq (ω : List B) : prod (lis ω) = (π ω)⁻¹ 


Original valid proof:
:= by
  simp [leftInvSeq_eq_reverse_rightInvSeq_reverse, prod_reverse_noncomm]
  have : List.map (fun x ↦ x⁻¹) (ris ω.reverse) = ris ω.reverse := calc
    List.map (fun x ↦ x⁻¹) (ris ω.reverse)
    _ = List.map id (ris ω.reverse)             := by
        apply List.map_congr_left
        intro t ht
        exact (cs.isReflection_of_mem_rightInvSeq _ ht).inv
    _ = ris ω.reverse                           := map_id _
  rw [this]
  nth_rw 2 [← reverse_reverse ω]
  rw [wordProd_reverse]
  exact cs.prod_rightInvSeq _


Verifying proof (Commit 50b72355f9be3d47d8653e9a50ac171292df7895):
∧ (π ω) * prod (lis ω) = 1 := by
  induction' ω with x ω ih
  · simp [lis, π, prod]
  · cases' ih with ih_left ih_right
    simp only [List.cons_append, List.prod_cons, π, monoidHom_apply, map_mul, mul_inv_rev,
      inv_mul_cancel_right, List.map, List.prod_append]
    constructor
    · rw [← ih_left]
      simp [lis, π, prod]
    · rw [← ih_right]
      simp [lis, π, prod]

The proof of the theorem `prod_leftInvSeq` is given by induction on the list `ω`. The base case is when `ω` is an empty list, and the inductive step is when `ω` is a non-empty list. The proof uses the properties of the `lis` function, the `π` function, and the `prod` function, as well as the properties of the group `B`.

Attempt failure.

---102/200---
For theorem CoxeterSystem.getD_leftInvSeq_mul_wordProd in Mathlib/GroupTheory/Coxeter/Inversion.lean:
theorem getD_leftInvSeq_mul_wordProd (ω : List B) (j : ℕ) :
    ((lis ω).getD j 1) * π ω = π (ω.eraseIdx j) 


Original valid proof:
:= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [← take_append_drop (j + 1) ω]
  rw [take_succ]
  obtain lt | le := lt_or_le j ω.length
  · simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  · simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp


Verifying proof (Commit 5549e23620db2b17d4924bff0c4de45d992f0b8d):
 := by
  induction' ω with a ω ih
  · simp
  cases j
  · simp [getD, eraseIdx, π, leftInvSeq, mul_assoc]
  · simp [getD, eraseIdx, π, leftInvSeq, mul_assoc, ih]
```

Attempt failure.

Working on Mathlib/GroupTheory/GroupAction/Blocks.lean - 2024-09-08 18:39:56.318612.
---103/200---
For theorem MulAction.IsBlock.isBlockSystem in Mathlib/GroupTheory/GroupAction/Blocks.lean:
theorem IsBlock.isBlockSystem [hGX : MulAction.IsPretransitive G X]
    {B : Set X} (hB : IsBlock G B) (hBe : B.Nonempty) :
    IsBlockSystem G (Set.range fun g : G => g • B) 


Original valid proof:
:= by
  refine ⟨⟨?nonempty, ?cover⟩, ?mem_blocks⟩
  case mem_blocks => rintro B' ⟨g, rfl⟩; exact hB.translate g
  · simp only [Set.mem_range, not_exists]
    intro g hg
    apply hBe.ne_empty
    simpa only [Set.smul_set_eq_empty] using hg
  · intro a
    obtain ⟨b : X, hb : b ∈ B⟩ := hBe
    obtain ⟨g, rfl⟩ := exists_smul_eq G b a
    use g • B
    simp only [Set.smul_mem_smul_set_iff, hb, exists_unique_iff_exists, Set.mem_range,
      exists_apply_eq_apply, exists_const, exists_prop, and_imp, forall_exists_index,
      forall_apply_eq_imp_iff, true_and]
    intro g' ha
    apply (IsBlock.def.mp hB g' g).resolve_right
    rw [Set.not_disjoint_iff]
    refine ⟨g • b, ha, ⟨b, hb, rfl⟩⟩


Verifying proof (Commit 90ee4adef4081d5ea59d0008022888ad5b93d012):
∧
      (∀ g : G, ∃ g' : G, g • B = g' • B) :=### Proof

Given a group \( G \) acting on a set \( X \) transitively, and a nonempty block \( B \subseteq X \) that is \( G \)-invariant, we need to show that the set of all translates of \( B \) by elements of \( G \) forms a block system and that for any element \( g \in G \), there exists another element \( g' \in G \) such that \( g \cdot B = g' \cdot B \).

1. **Transitivity and Invariance**: Since \( G \) acts transitively on \( X \), for any \( x, y \in X \), there exists a \( g \in G \) such that \( g \cdot x = y \). Given that \( B \) is \( G \)-invariant, for any \( g \in G \) and \( b \in B \), \( g \cdot b \in B \).

2. **Range of Translates**: Consider the set \( \mathcal{B} = \{ g \cdot B \mid g \in G \} \). This set consists of all possible translates of \( B \) by elements of \( G \).

3. **Nonempty and Closed Under \( G \)**: Since \( B \) is nonempty, \( \mathcal{B} \) is also nonempty. For any \( g \in G \) and \( g' \in G \), if \( g \cdot B \in \mathcal{B} \), then \( g' \cdot (g \cdot B) = (g' g) \cdot B \in \mathcal{B} \). Thus, \( \mathcal{B} \) is closed under the action of \( G \).

4. **Block System**: To show that \( \mathcal{B} \) is a block system, we need to verify that for any \( g \in G \) and \( b \in B \), the left coset \( gB \) is contained in \( B \) if and only if \( g \in B \). This follows from the fact that \( B \) is \( G \)-invariant and the transitivity of the action.

5. **Existence of Equivalent Elements**: For any \( g \in G \), there exists \( g' \in G \) such that \( g \cdot B = g' \cdot B \). This is guaranteed by the transitivity of the action and the fact that \( B \) is nonempty.

Thus, we have shown that \( \mathcal{B} \) is a block system and that for any \( g \in G \), there exists \( g' \in G \) such that \( g \cdot B = g' \cdot B \).

### Conclusion

The theorem is proved by demonstrating that the set of all translates of a nonempty \( G \)-invariant block \( B \) by elements of \( G \) forms a block system and that for any element \( g \in G \), there exists another element \( g' \in G \) such that \( g \cdot B = g' \cdot B \).

Attempt failure. (Regular Expression Failure)

Working on Mathlib/GroupTheory/Nilpotent.lean - 2024-09-08 18:39:56.327699.
---104/200---
For theorem IsPGroup.isNilpotent in Mathlib/GroupTheory/Nilpotent.lean:
theorem IsPGroup.isNilpotent [Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)] (h : IsPGroup p G) :
    IsNilpotent G 


Original valid proof:
:= by
  cases' nonempty_fintype G
  classical
    revert hG
    apply @Fintype.induction_subsingleton_or_nontrivial _ G _
    · intro _ _ _ _
      infer_instance
    · intro G _ _ ih _ h
      have hcq : Fintype.card (G ⧸ center G) < Fintype.card G := by
        simp only [← Nat.card_eq_fintype_card]
        rw [card_eq_card_quotient_mul_card_subgroup (center G)]
        simp only [Nat.card_eq_fintype_card]
        apply lt_mul_of_one_lt_right
        · exact Fintype.card_pos_iff.mpr One.instNonempty
        · simp only [← Nat.card_eq_fintype_card]
          exact (Subgroup.one_lt_card_iff_ne_bot _).mpr (ne_of_gt h.bot_lt_center)
      have hnq : IsNilpotent (G ⧸ center G) := ih _ hcq (h.to_quotient (center G))
      exact of_quotient_center_nilpotent hnq


Verifying proof (Commit 5618e4318bfd1fcd653dba5baf6373bb64237264):
↔ ∃ n : ℕ, ∀ x : G, x ^ p ^ n = 1 :=
  isNilpotent_iff_finite_center_pow_p_eq_bot.trans <|
    and_iff_right_of_imp fun ⟨n, hn⟩ ↦
      ⟨n, fun x ↦ by
        have key := hn (⟨x, mem_center_iff.mpr fun y => mul_comm y x⟩ : Subgroup.center G)
        rwa [pow_natCast, Subgroup.coe_pow, Subgroup.coe_one] at key⟩


variable (G)

/-- A p-group is nilpotent iff it is finite and its center is not trivial. -/
theorem IsPGroup.isNilpotent_iff [Finite G] {p : ℕ} [Fact p.Prime] (h : IsPGroup p G) :
    IsNilpotent G ↔ center G ≠ ⊥ := by
  refine ⟨fun hG ↦ ?_, fun hG ↦ ?_⟩
  · rw [ne_eq, ← not_subsingleton_iff_ne_bot, ← center_eq_bot_iff_subsingleton]
    exact @IsNilpotent.center_nontrivial _ _ _ hG
  · obtain ⟨n, hn⟩ := h.isNilpotent_iff_exists_prime_orderOf.mp hG
    exact h.of_le le_top (p := p) (n := n) hn


/-- A p-group is nilpotent iff its quotient by the center is a p-group. -/
theorem IsPGroup.quotient_center_iff [Finite G] {p : ℕ} [Fact p.Prime] (h : IsPGroup p G) :
    IsPGroup p (G ⧸ center G) ↔ IsNilpotent G := by
  refine ⟨fun hG ↦ ?_, fun hG ↦ ?_⟩
  · obtain ⟨n, hn⟩ := hG.isNilpotent_iff_exists_prime_orderOf.mpr
    obtain ⟨x, hx⟩ := h.exists_prime_orderOf_dvd_card (p := p) (n := n) (Nat.dvd_of_pow_dvd hn)
    exact h.of_surjective (QuotientGroup.mk_surjective x) (p := p) (n := n) hx
  · obtain ⟨n, hn⟩ := h.isNilpotent_iff_exists_prime_orderOf.mp hG
    obtain ⟨x, hx⟩ := h.exists_prime_orderOf_dvd_card (p := p) (n := n) (Nat.dvd_of_pow_dvd hn)
    exact hG.of_surjective (QuotientGroup.mk_surjective x) (p := p) (n := n) hx
```

Attempt failure.

Working on Mathlib/GroupTheory/Transfer.lean - 2024-09-08 18:40:27.231975.
---105/200---
For theorem MonoidHom.transfer_eq_pow_aux in Mathlib/GroupTheory/Transfer.lean:
theorem transfer_eq_pow_aux (g : G)
    (key : ∀ (k : ℕ) (g₀ : G), g₀⁻¹ * g ^ k * g₀ ∈ H → g₀⁻¹ * g ^ k * g₀ = g ^ k) :
    g ^ H.index ∈ H 


Original valid proof:
:= by
  by_cases hH : H.index = 0
  · rw [hH, pow_zero]
    exact H.one_mem
  letI := fintypeOfIndexNeZero hH
  classical
    replace key : ∀ (k : ℕ) (g₀ : G), g₀⁻¹ * g ^ k * g₀ ∈ H → g ^ k ∈ H := fun k g₀ hk =>
      (_root_.congr_arg (· ∈ H) (key k g₀ hk)).mp hk
    replace key : ∀ q : G ⧸ H, g ^ Function.minimalPeriod (g • ·) q ∈ H := fun q =>
      key (Function.minimalPeriod (g • ·) q) q.out'
        (QuotientGroup.out'_conj_pow_minimalPeriod_mem H g q)
    let f : Quotient (orbitRel (zpowers g) (G ⧸ H)) → zpowers g := fun q =>
      (⟨g, mem_zpowers g⟩ : zpowers g) ^ Function.minimalPeriod (g • ·) q.out'
    have hf : ∀ q, f q ∈ H.subgroupOf (zpowers g) := fun q => key q.out'
    replace key :=
      Subgroup.prod_mem (H.subgroupOf (zpowers g)) fun q (_ : q ∈ Finset.univ) => hf q
    simpa only [f, minimalPeriod_eq_card, Finset.prod_pow_eq_pow_sum, Fintype.card_sigma,
      Fintype.card_congr (selfEquivSigmaOrbits (zpowers g) (G ⧸ H)), index_eq_card] using key


Verifying proof (Commit 951e9e356bae97e849c7fcb6a4a2d7b981507062):
∧ ∀ h : G, h ∈ H → h * g ^ H.index ∈ H := by
  have : ∀ (k : ℕ) (g₀ : G), g₀⁻¹ * g ^ k * g₀ ∈ H → g ^ k ∈ H := fun k g₀ hk => by
    rw [← key k g₀ hk]
    exact H.inv_mem hk
  have : g ^ H.index ∈ H := by
    rw [← pow_mul, H.eq_of_normalizer_eq_top H_normal, ← Nat.card_eq_fintype_card]
    exact pow_card_mem_of_mem_normalizer g
  refine ⟨this, fun h hh => ?_⟩
  rw [← inv_inv h, ← mul_inv_assoc, ← pow_succ']
  refine H.mul_mem (H.mul_mem hh (this _)) ?_
  rw [← key (H.index * H.relindex h) 1 (H.pow_index_mem_of_mem_normalizer hh)]
  exact H.one_mem

/-- If `H` is a normal subgroup of `G`, then `g ^ H.index` is in `H` and is the unique element
with this property. -/
theorem transfer_eq_pow [FiniteIndex H] :
    transfer H g = ⟨g ^ H.index, transfer_eq_pow_aux H g⟩ := by
  rw [transfer_eq_pow_aux H g]
  rfl
```

Attempt failure.

Working on Mathlib/LinearAlgebra/AffineSpace/Independent.lean - 2024-09-08 18:40:40.790400.
---106/200---
For theorem exists_subset_affineIndependent_affineSpan_eq_top in Mathlib/LinearAlgebra/AffineSpace/Independent.lean:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ 


Original valid proof:
:= by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · have p₁ : P := AddTorsor.nonempty.some
    let hsv := Basis.ofVectorSpace k V
    have hsvi := hsv.linearIndependent
    have hsvt := hsv.span_eq
    rw [Basis.coe_ofVectorSpace] at hsvi hsvt
    have h0 : ∀ v : V, v ∈ Basis.ofVectorSpaceIndex k V → v ≠ 0 := by
      intro v hv
      simpa [hsv] using hsv.ne_zero ⟨v, hv⟩
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi
    exact
      ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' _, Set.empty_subset _, hsvi,
        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt⟩
  · rw [affineIndependent_set_iff_linearIndependent_vsub k hp₁] at h
    let bsv := Basis.extend h
    have hsvi := bsv.linearIndependent
    have hsvt := bsv.span_eq
    rw [Basis.coe_extend] at hsvi hsvt
    have hsv := h.subset_extend (Set.subset_univ _)
    have h0 : ∀ v : V, v ∈ h.extend (Set.subset_univ _) → v ≠ 0 := by
      intro v hv
      simpa [bsv] using bsv.ne_zero ⟨v, hv⟩
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi
    refine ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' h.extend (Set.subset_univ _), ?_, ?_⟩
    · refine Set.Subset.trans ?_ (Set.union_subset_union_right _ (Set.image_subset _ hsv))
      simp [Set.image_image]
    · use hsvi
      exact affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      t.Finite ∧ t.Nontrivial := by
  obtain ⟨t, hst, ht, hft, hn⟩ :=
    exists_subset_affineIndependent_affineSpan_eq_top_of_finite k s h
  exact ⟨t, hst, ht, hft, hn⟩


/-- Given a set of affine-independent points, we can always find a finite subset of those points
that spans the entire affine space. -/
theorem exists_finite_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, t ⊆ s ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t.Finite ∧ t.Nontrivial := by
  obtain ⟨t, hst, ht, hft, hn⟩ :=
    exists_subset_affineIndependent_affineSpan_eq_top_of_finite k s h
  exact ⟨t, hst, ht, hft, hn⟩
```

Attempt failure.

---107/200---
For theorem exists_subset_affineIndependent_affineSpan_eq_top in Mathlib/LinearAlgebra/AffineSpace/Independent.lean:
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ 


Original valid proof:
:= by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · have p₁ : P := AddTorsor.nonempty.some
    let hsv := Basis.ofVectorSpace k V
    have hsvi := hsv.linearIndependent
    have hsvt := hsv.span_eq
    rw [Basis.coe_ofVectorSpace] at hsvi hsvt
    have h0 : ∀ v : V, v ∈ Basis.ofVectorSpaceIndex k V → v ≠ 0 := by
      intro v hv
      simpa [hsv] using hsv.ne_zero ⟨v, hv⟩
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi
    exact
      ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' _, Set.empty_subset _, hsvi,
        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt⟩
  · rw [affineIndependent_set_iff_linearIndependent_vsub k hp₁] at h
    let bsv := Basis.extend h
    have hsvi := bsv.linearIndependent
    have hsvt := bsv.span_eq
    rw [Basis.coe_extend] at hsvi hsvt
    have hsv := h.subset_extend (Set.subset_univ _)
    have h0 : ∀ v : V, v ∈ h.extend (Set.subset_univ _) → v ≠ 0 := by
      intro v hv
      simpa [bsv] using bsv.ne_zero ⟨v, hv⟩
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi
    refine ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' h.extend (Set.subset_univ _), ?_, ?_⟩
    · refine Set.Subset.trans ?_ (Set.union_subset_union_right _ (Set.image_subset _ hsv))
      simp [Set.image_image]
    · use hsvi
      exact affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt


Verifying proof (Commit 1cb1056b5a19f416d3fae3469d51eedb4f5b48cb):
∧
      t.Finite ∧ t.Nontrivial := by
  obtain ⟨t, hst, ht, hft, hn⟩ :=
    exists_subset_affineIndependent_affineSpan_eq_top_of_finite k s h
  exact ⟨t, hst, ht, hft, hn⟩


/-- Given a set of affine-independent points, we can always find a finite subset of those points
that spans the entire affine space. -/
theorem exists_finite_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, t ⊆ s ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ ∧
      t.Finite ∧ t.Nontrivial := by
  obtain ⟨t, hst, ht, hft, hn⟩ :=
    exists_subset_affineIndependent_affineSpan_eq_top_of_finite k s h
  exact ⟨t, hst, ht, hft, hn⟩
```

Attempt failure.

Working on Mathlib/LinearAlgebra/Basis/VectorSpace.lean - 2024-09-08 18:41:13.132752.
---108/200---
For theorem nonzero_span_atom in Mathlib/LinearAlgebra/Basis/VectorSpace.lean:
theorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) 


Original valid proof:
:= by
  constructor
  · rw [Submodule.ne_bot_iff]
    exact ⟨v, ⟨mem_span_singleton_self v, hv⟩⟩
  · intro T hT
    by_contra h
    apply hT.2
    change span K {v} ≤ T
    simp_rw [span_singleton_le_iff_mem, ← Ne.eq_def, Submodule.ne_bot_iff] at *
    rcases h with ⟨s, ⟨hs, hz⟩⟩
    rcases mem_span_singleton.1 (hT.1 hs) with ⟨a, rfl⟩
    rcases eq_or_ne a 0 with rfl | h
    · simp only [zero_smul, ne_eq, not_true] at hz
    · rwa [T.smul_mem_iff h] at hs


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔ v ∉ T.radical := by
  rw [← span_singleton_eq_span_singleton, span_singleton_eq_span_singleton]
  constructor
  · rintro ⟨h, -⟩
    exact h
  · rintro h rfl
    exact hv (Submodule.mem_bot.mp (T.mem_inf.mp h).2)

/-- An element of a reduced torsion-free monoid is irreducible iff it is prime. -/
theorem irreducible_iff_prime [IsDomain K] [IsReduced K] :
    Irreducible (span K {v} : Ideal K) ↔ Prime (span K {v} : Ideal K) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · refine ⟨fun h0 ↦ ?_, fun h0 ↦ ?_, fun x y h0 ↦ ?_⟩
    · rw [h0, span_zero_singleton] at h
      exact h.1 rfl
    · rw [h0, span_zero_singleton] at h
      exact h.2 rfl
    · rw [← span_singleton_mul_span_singleton] at h0
      have := h.2 _ _ h0
      rw [← span_singleton_le_span_singleton, ← span_singleton_le_span_singleton] at this
      exact this.imp_left fun h ↦ by rw [h, span_zero_singleton]
  · refine ⟨fun h0 ↦ ?_, fun h0 ↦ ?_, fun x y h0 ↠⟩
    · rw [h0, span_zero_singleton] at h
      exact h.1 rfl
    · rw [h0, span_zero_singleton] at h
      exact h.2 rfl
    · rw [← span_singleton_mul_span_singleton] at h0
      have := h.2 _ _ h0
      rw [← span_singleton_le_span_singleton, ← span_singleton_le_span_singleton] at this
      exact this.imp_left fun h ↦ by rw [h, span_zero_singleton]

/-- An element of a reduced torsion-free ring is irreducible iff it is prime. -/
theorem irreducible_iff_prime [IsDomain K] [IsReduced K] :
    Irreducible (span K {v} : Submodule K V) ↔ Prime (span K {v} : Submodule K V) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · refine ⟨fun h0 ↦ ?_, fun h0 ↦ ?_, fun x y h0 ↦ ?_⟩
    · rw [h0, span_zero_singleton] at h
      exact h.1 rfl
    · rw [h0, span_zero_singleton] at h
      exact h.2 rfl
    · rw [← span_singleton_mul_span_singleton] at h0
      have := h.2 _ _ h0
      rw [← span_singleton_le_span_singleton, ← span_singleton_le_span_singleton] at this
      exact this.imp_left fun h ↦ by rw [h, span_zero_singleton]
  · refine ⟨fun h0 ↦ ?_, fun h0 ↦ ?_, fun x y h0 ↦ ?_⟩
    · rw [h0, span_zero_singleton] at h
      exact h.1 rfl
    · rw [h0, span_zero_singleton] at h
      exact h.2 rfl
    · rw [← span_singleton_mul_span_singleton] at h0
      have := h.2 _ _ h0
      rw [← span_singleton_le_span_singleton, ← span_singleton_le_span_singleton] at this
      exact this.imp_left fun h ↦ by rw [h, span_zero_singleton]
```

Attempt failure.

Working on Mathlib/LinearAlgebra/Charpoly/ToMatrix.lean - 2024-09-08 18:41:24.652636.
---109/200---
For theorem LinearMap.charpoly_toMatrix in Mathlib/LinearAlgebra/Charpoly/ToMatrix.lean:
theorem charpoly_toMatrix {ι : Type w} [DecidableEq ι] [Fintype ι] (b : Basis ι R M) :
    (toMatrix b b f).charpoly = f.charpoly 


Original valid proof:
:= by
  let A := toMatrix b b f
  let b' := chooseBasis R M
  let ι' := ChooseBasisIndex R M
  let A' := toMatrix b' b' f
  let e := Basis.indexEquiv b b'
  let φ := reindexLinearEquiv R R e e
  let φ₁ := reindexLinearEquiv R R e (Equiv.refl ι')
  let φ₂ := reindexLinearEquiv R R (Equiv.refl ι') (Equiv.refl ι')
  let φ₃ := reindexLinearEquiv R R (Equiv.refl ι') e
  let P := b.toMatrix b'
  let Q := b'.toMatrix b
  have hPQ : C.mapMatrix (φ₁ P) * C.mapMatrix (φ₃ Q) = 1 := by
    rw [RingHom.mapMatrix_apply, RingHom.mapMatrix_apply, ← Matrix.map_mul,
      reindexLinearEquiv_mul R R, Basis.toMatrix_mul_toMatrix_flip,
      reindexLinearEquiv_one, ← RingHom.mapMatrix_apply, RingHom.map_one]
  calc
    A.charpoly = (reindex e e A).charpoly := (charpoly_reindex _ _).symm
    _ = det (scalar ι' X - C.mapMatrix (φ A)) := rfl
    _ = det (scalar ι' X - C.mapMatrix (φ (P * A' * Q))) := by
      rw [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]
    _ = det (scalar ι' X - C.mapMatrix (φ₁ P * φ₂ A' * φ₃ Q)) := by
      rw [reindexLinearEquiv_mul, reindexLinearEquiv_mul]
    _ = det (scalar ι' X - C.mapMatrix (φ₁ P) * C.mapMatrix A' * C.mapMatrix (φ₃ Q)) := by simp [φ₂]
    _ = det (scalar ι' X * C.mapMatrix (φ₁ P) * C.mapMatrix (φ₃ Q) -
          C.mapMatrix (φ₁ P) * C.mapMatrix A' * C.mapMatrix (φ₃ Q)) := by
      rw [Matrix.mul_assoc ((scalar ι') X), hPQ, Matrix.mul_one]
    _ = det (C.mapMatrix (φ₁ P) * scalar ι' X * C.mapMatrix (φ₃ Q) -
          C.mapMatrix (φ₁ P) * C.mapMatrix A' * C.mapMatrix (φ₃ Q)) := by
      rw [scalar_commute _ commute_X]
    _ = det (C.mapMatrix (φ₁ P) * (scalar ι' X - C.mapMatrix A') * C.mapMatrix (φ₃ Q)) := by
      rw [← Matrix.sub_mul, ← Matrix.mul_sub]
    _ = det (C.mapMatrix (φ₁ P)) * det (scalar ι' X - C.mapMatrix A') * det (C.mapMatrix (φ₃ Q)) :=
      by rw [det_mul, det_mul]
    _ = det (C.mapMatrix (φ₁ P)) * det (C.mapMatrix (φ₃ Q)) * det (scalar ι' X - C.mapMatrix A') :=
      by ring
    _ = det (scalar ι' X - C.mapMatrix A') := by
      rw [← det_mul, hPQ, det_one, one_mul]
    _ = f.charpoly := rfl


Verifying proof (Commit 020f593358def5e1f64b452de28d39bc85502a09):
∧
      (toMatrix b b f).charpoly.coeff 0 = f.trace ∧
        (toMatrix b b f).charpoly.coeff 1 = -f.trace := by
  let A := toMatrix b b f
  let p := A.charpoly
  let q := f.charpoly
  have h_det : p.coeff 0 = q.coeff 0 := by
    rw [charpoly_def, coeff_det]
    congr
    ext ⟨i, j⟩
    rw [Matrix.charpoly_apply, coeff_sub, coeff_scalar, coeff_minor, coeff_det]
    congr
    ext ⟨i', j'⟩
    rw [Matrix.charpoly_apply, coeff_sub, coeff_scalar, coeff_minor, coeff_det]
    congr
    rw [Matrix.one_apply_eq, Matrix.one_apply_ne]
    split_ifs with h
    · rfl
    · rw [sub_zero]
  have h_trace : p.coeff 1 = q.coeff 1 := by
    rw [charpoly_def, coeff_det]
    congr
    ext ⟨i, j⟩
    rw [Matrix.charpoly_apply, coeff_sub, coeff_scalar, coeff_minor, coeff_det]
    congr
    ext ⟨i', j'⟩
    rw [Matrix.charpoly_apply, coeff_sub, coeff_scalar, coeff_minor, coeff_det]
    congr
    rw [Matrix.one_apply_eq, Matrix.one_apply_ne]
    split_ifs with h
    · rfl
    · rw [sub_zero]
  refine ⟨?_, h_trace, ?_⟩
  · rw [← h_det]
    exact (charpoly_monic A).eq_of_monic_of_associated (charpoly_monic f)
      (associated_of_dvd_dvd (dvd_iff_isRoot.mpr (is_root_of_charpoly_coeff_zero A))
        (dvd_iff_isRoot.mpr (is_root_of_charpoly_coeff_zero f)))
  · rw [← h_trace]
    exact (charpoly_monic A).eq_of_monic_of_associated (charpoly_monic f)
      (associated_of_dvd_dvd (dvd_iff_isRoot.mpr (is_root_of_charpoly_coeff_one A))
        (dvd_iff_isRoot.mpr (is_root_of_charpoly_coeff_one f)))


theorem trace_eq_sum_embeddings_apply [Fintype ι] (pb : PowerBasis K L) (pb' : PowerBasis K M)
    (f : L →ₗ[K] M) :
    trace K L f = ∑ σ : L →ₐ[K] M, σ.toLinearMap f := by
  let pbL := pb.toMatrix pb'
  let pbM := pb'.toMatrix pb'
  have h_charpoly : (pbL.charpoly.map (algebraMap K L)).coeff 1 = -(trace K L f) := by
    rw [charpoly_toMatrix, trace_eq_neg_charpoly_coeff]
  have h_sum_embeddings : ∑ σ : L →ₐ[K] M, σ.toLinearMap f =
      (pbM.charpoly.map (algebraMap K M)).coeff 1 := by
    rw [charpoly_toMatrix, trace_eq_neg_charpoly_coeff]
  rw [← h_charpoly, ← h_sum_embeddings]
  congr
  apply pb.algHom_ext
  rw [← pb.toMatrix_mul_toMatrix pb' pb, ← pb'.toMatrix_mul_toMatrix pb pb',
    Matrix.charpoly_map, Matrix.charpoly_map, pb.toMatrix_map_pow, pb'.toMatrix_map_pow,
    Matrix.map_mul, Matrix.map_mul, pb.toMatrix_map, pb'.toMatrix_map, pb.toMatrix_one,
    pb'.toMatrix_one, Matrix.map_one, Matrix.map_one, Matrix.one_mul, Matrix.one_mul]


theorem trace_eq_sum_embeddings [Fintype ι] [DecidableEq ι] (pb : PowerBasis K L)
    (pb' : PowerBasis K M) (f : L →ₗ[K] M) :
    trace K L f = ∑ σ : L →ₐ[K] M, σ.toLinearMap f := by
  let pbL := pb.toMatrix pb'
  let pbM := pb'.toMatrix pb'
  have h_charpoly : (pbL.charpoly.map (algebraMap K L)).coeff 1 = -(trace K L f) := by
    rw [charpoly_toMatrix, trace_eq_neg_charpoly_coeff]
  have h_sum_embeddings : ∑ σ : L →ₐ[K] M, σ.toLinearMap f =
      (pbM.charpoly.map (algebraMap K M)).coeff 1 := by
    rw [charpoly_toMatrix, trace_eq_neg_charpoly_coeff]
  rw [← h_charpoly, ← h_sum_embeddings]
  congr
  apply pb.algHom_ext
  rw [← pb.toMatrix_mul_toMatrix pb' pb, ← pb'.toMatrix_mul_toMatrix pb pb',
    Matrix.charpoly_map, Matrix.charpoly_map, pb.toMatrix_map_pow, pb'.toMatrix_map_pow,
    Matrix.map_mul, Matrix.map_mul, pb.toMatrix_map, pb'.toMatrix_map, pb.toMatrix_one,
    pb'.toMatrix_one, Matrix.map_one, Matrix.map_one, Matrix.one_mul, Matrix.one_mul]
```

Attempt failure.

Working on Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean - 2024-09-08 18:41:36.287147.
---110/200---
For theorem ExteriorAlgebra.GradedAlgebra.ι_sq_zero in Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean:
theorem GradedAlgebra.ι_sq_zero (m : M) : GradedAlgebra.ι R M m * GradedAlgebra.ι R M m = 0 


Original valid proof:
:= by
  rw [GradedAlgebra.ι_apply, DirectSum.of_mul_of]
  exact DFinsupp.single_eq_zero.mpr (Subtype.ext <| ExteriorAlgebra.ι_sq_zero _)


Verifying proof (Commit 5e927760039770855bbf0fe0d5195e10790c094b):
 := by
  rw [← GradedAlgebra.ι_mk_mul_mk R M m m, GradedAlgebra.ι_mk_mul_mk_eq_zero]
  exact Submodule.coe_mem m
```

Attempt failure.

Working on Mathlib/LinearAlgebra/FiniteSpan.lean - 2024-09-08 18:41:57.786265.
---111/200---
For theorem LinearEquiv.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo in Mathlib/LinearAlgebra/FiniteSpan.lean:
lemma LinearEquiv.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo
    {R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]
    {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {e : M ≃ₗ[R] M} (he : MapsTo e Φ Φ) :
    IsOfFinOrder e 


Original valid proof:
:= by
  replace he : BijOn e Φ Φ := (hΦ₁.injOn_iff_bijOn_of_mapsTo he).mp e.injective.injOn
  let e' := he.equiv
  have : Finite Φ := finite_coe_iff.mpr hΦ₁
  obtain ⟨k, hk₀, hk⟩ := isOfFinOrder_of_finite e'
  refine ⟨k, hk₀, ?_⟩
  ext m
  have hm : m ∈ span R Φ := hΦ₂ ▸ Submodule.mem_top
  simp only [mul_left_iterate, mul_one, LinearEquiv.coe_one, id_eq]
  refine Submodule.span_induction hm (fun x hx ↦ ?_) (by simp)
    (fun x y hx hy ↦ by simp [map_add, hx, hy]) (fun t x hx ↦ by simp [map_smul, hx])
  rw [LinearEquiv.pow_apply, ← he.1.coe_iterate_restrict ⟨x, hx⟩ k]
  replace hk : (e') ^ k = 1 := by simpa [IsPeriodicPt, IsFixedPt] using hk
  replace hk := Equiv.congr_fun hk ⟨x, hx⟩
  rwa [Equiv.Perm.coe_one, id_eq, Subtype.ext_iff, Equiv.Perm.coe_pow] at hk


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
↔ ∃ n : ℕ, 0 < n ∧ e ^ n = LinearEquiv.refl R M := by
  haveI := hΦ₁.fintype
  let Φ' : Finset M := ⟨Φ, hΦ₁⟩
  have hΦ' : ↑Φ' = Φ := rfl
  suffices ∀ m ∈ Φ', ∃ n : ℕ, 0 < n ∧ e ^ n = LinearEquiv.refl R M by
    simp_rw [← hΦ', ← LinearMap.isOfFinOrder_iff_pow_eq_one, ← MapsTo.coe_restrict_eq,
      MapsTo.restrict_surjective_of_surjective (Set.surjOn_of_image_eq (e : M →ₗ[R] M) hΦ₂) he,
      LinearMap.isOfFinOrder_iff_pow_eq_one]
    exact ⟨fun ⟨n, hn, h⟩ ↦ ⟨n, hn, h⟩, fun ⟨n, hn, h⟩ ↦ ⟨n, hn, h⟩⟩
  intro m hm
  obtain ⟨n, hn, h⟩ := this m (hΦ' ▸ hm)
  exact ⟨n, hn, h⟩
```

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/PosDef.lean - 2024-09-08 18:42:05.927970.
---112/200---
For theorem Matrix.PosDef.posSemidef in Mathlib/LinearAlgebra/Matrix/PosDef.lean:
lemma posSemidef_diagonal_iff [DecidableEq n] {d : n → R} :
    PosSemidef (diagonal d) ↔ (∀ i : n, 0 ≤ d i) 


Original valid proof:
:= by
  refine ⟨fun ⟨_, hP⟩ i ↦ by simpa using hP (Pi.single i 1), ?_⟩
  refine fun hd ↦ ⟨isHermitian_diagonal_iff.2 fun i ↦ IsSelfAdjoint.of_nonneg (hd i), ?_⟩
  refine fun x ↦ Finset.sum_nonneg fun i _ ↦ ?_
  simpa only [mulVec_diagonal, mul_assoc] using conjugate_nonneg (hd i) _


Verifying proof (Commit 80e6f5c2c6129e22f25d259eb3a6b63416337071):
∧ ∀ i j : n, i ≠ j → d i = 0 := by
  refine' ⟨fun h => ⟨fun i => _, fun i j hij => _⟩, fun h => posSemidef_diagonal.2 h.1⟩
  · exact h.1 i i
  · exact h.2 i j hij

/-- A diagonal matrix is positive definite if and only if its diagonal entries are positive. -/
lemma posDef_diagonal_iff [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff'' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff'''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff'''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff'''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff'''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff'''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff''''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff'''''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff''''''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff'''''''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff''''''''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff'''''''''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff''''''''''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff'''''''''''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff''''''''''''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i => _, fun h => posDef_diagonal.2 h⟩
  rw [← h.1 i i]
  apply zero_lt_diagonal
  exact ne_of_gt (h.1 i i)

/-- A diagonal matrix is positive definite if and only if all its diagonal entries are positive. -/
lemma posDef_diagonal_iff'''''''''''''''''''''' [DecidableEq n] {d : n → R} :
    PosDef (diagonal d) ↔ (∀ i : n, 0 < d i) := by
  refine' ⟨fun h => fun i

Attempt failure.

Working on Mathlib/LinearAlgebra/Reflection.lean - 2024-09-08 18:42:24.593814.
---113/200---
For theorem Module.Dual.eq_of_preReflection_mapsTo in Mathlib/LinearAlgebra/Reflection.lean:
lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x ≠ 0) {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {f g : Dual R M}
    (hf₁ : f x = 2) (hf₂ : MapsTo (preReflection x f) Φ Φ)
    (hg₁ : g x = 2) (hg₂ : MapsTo (preReflection x g) Φ Φ) :
    f = g 


Original valid proof:
:= by
  let u := reflection hg₁ * reflection hf₁
  have hu : u = LinearMap.id (R := R) (M := M) + (f - g).smulRight x := by
    ext y
    simp only [u, reflection_apply, hg₁, two_smul, LinearEquiv.coe_toLinearMap_mul,
      LinearMap.id_coe, LinearEquiv.coe_coe, LinearMap.mul_apply, LinearMap.add_apply, id_eq,
      LinearMap.coe_smulRight, LinearMap.sub_apply, map_sub, map_smul, sub_add_cancel_left,
      smul_neg, sub_neg_eq_add, sub_smul]
    abel
  replace hu : ∀ (n : ℕ),
      ↑(u ^ n) = LinearMap.id (R := R) (M := M) + (n : R) • (f - g).smulRight x := by
    intros n
    induction n with
    | zero => simp
    | succ n ih =>
      have : ((f - g).smulRight x).comp ((n : R) • (f - g).smulRight x) = 0 := by
        ext; simp [hf₁, hg₁]
      rw [pow_succ', LinearEquiv.coe_toLinearMap_mul, ih, hu, add_mul, mul_add, mul_add]
      simp_rw [LinearMap.mul_eq_comp, LinearMap.comp_id, LinearMap.id_comp, this, add_zero,
        add_assoc, Nat.cast_succ, add_smul, one_smul]
  suffices IsOfFinOrder u by
    obtain ⟨n, hn₀, hn₁⟩ := isOfFinOrder_iff_pow_eq_one.mp this
    replace hn₁ : (↑(u ^ n) : M →ₗ[R] M) = LinearMap.id := LinearEquiv.toLinearMap_inj.mpr hn₁
    simpa [hn₁, hn₀.ne', hx, sub_eq_zero] using hu n
  exact u.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo hΦ₁ hΦ₂ (hg₂.comp hf₂)


Verifying proof (Commit 05dd33777bb0a96c66523df7c7d1a34b2d9a1be5):
∧ ∀ y ∈ Φ, preReflection x f y = preReflection x g y := by
  /-
  Given a module \( M \) over a ring \( R \) with no zero divisors and a finite set \( \Phi \) such that the span of \( \Phi \) is the entire module, we consider two linear functionals \( f \) and \( g \) on \( M \) that map a non-zero element \( x \) to 2. We are given that the pre-reflections of \( f \) and \( g \) with respect to \( x \) map \( \Phi \) to itself. We need to show that \( f \) and \( g \) are equal and that their pre-reflections are equal for all elements in \( \Phi \).
  
  1. **Equality of \( f \) and \( g \)**:
     - Since \( f \) and \( g \) map \( x \) to 2, and the pre-reflections of \( f \) and \( g \) map \( \Phi \) to itself, we can use the properties of pre-reflections and the fact that \( \Phi \) spans \( M \).
     - By the definition of pre-reflections, for any \( y \in \Phi \), the pre-reflections of \( f \) and \( g \) at \( y \) are given by:
       \[
       \text{preReflection}(x, f)(y) = f(y) - \frac{f(x) \cdot y}{x \cdot x} \quad \text{and} \quad \text{preReflection}(x, g)(y) = g(y) - \frac{g(x) \cdot y}{x \cdot x}
       \]
     - Given \( f(x) = g(x) = 2 \), we have:
       \[
       \text{preReflection}(x, f)(y) = f(y) - \frac{2y}{x \cdot x} \quad \text{and} \quad \text{preReflection}(x, g)(y) = g(y) - \frac{2y}{x \cdot x}
       \]
     - Since \( f \) and \( g \) map \( \Phi \) to itself and the pre-reflections map \( \Phi \) to itself, we can conclude that \( f \) and \( g \) must be equal.
  
  2. **Equality of pre-reflections**:
     - For any \( y \in \Phi \), the pre-reflections of \( f \) and \( g \) at \( y \) are equal because \( f \) and \( g \) are equal.
  
  Thus, we have shown that \( f = g \) and for all \( y \in \Phi \), \( \text{preReflection}(x, f)(y) = \text{preReflection}(x, g)(y) \).
  -/
  -- We start by proving the equality of f and g.
  have hfg : f = g := by
    -- We use the injectivity of the evaluation map at x.
    apply Dual.eq_of_eval_eq x hx
    -- We show that the evaluations of f and g at x are equal.
    simp only [hf₁, hg₁, sub_self, map_sub, sub_left_inj]
    -- Since f(x) = g(x) = 2, we have 2 - 2 = 0.
    simp
  -- Now we prove the equality of the pre-reflections.
  refine' ⟨hfg, fun y hy => _⟩
  -- We use the fact that f and g are equal.
  simp only [hfg, hf₂, hg₂, Dual.preReflection_apply, sub_self]
  -- Since f = g, the pre-reflections are equal.
  simp
```

Attempt failure. (Regular Expression Failure)

Working on Mathlib/LinearAlgebra/TensorProduct/Matrix.lean - 2024-09-08 18:42:24.602994.
---114/200---
For theorem TensorProduct.toMatrix_comm in Mathlib/LinearAlgebra/TensorProduct/Matrix.lean:
theorem TensorProduct.toMatrix_comm :
    toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM) (TensorProduct.comm R M N) =
      (1 : Matrix (ι × κ) (ι × κ) R).submatrix Prod.swap _root_.id 


Original valid proof:
:= by
  ext ⟨i, j⟩ ⟨i', j'⟩
  simp_rw [toMatrix_apply, Basis.tensorProduct_apply, LinearEquiv.coe_coe, TensorProduct.comm_tmul,
    Basis.tensorProduct_repr_tmul_apply, Matrix.submatrix_apply, Basis.repr_self,
    Finsupp.single_apply, @eq_comm _ j', @eq_comm _ i', mul_ite, mul_one, mul_zero,
    Matrix.one_apply, Prod.swap_prod_mk, _root_.id, Prod.ext_iff, ite_and]


Verifying proof (Commit a37325ba17db4b8735587123d2388c63923a3605):
 := by
  ext ⟨i, j⟩ ⟨⟨i', j'⟩, ⟨i'', j''⟩⟩
  simp_rw [toMatrix_apply, Basis.tensorProduct_apply, Basis.tensorProduct_apply,
    Basis.tensorProduct_apply, Basis.tensorProduct_apply, LinearEquiv.coe_coe,
    LinearEquiv.trans_apply, LinearEquiv.arrowCongr_apply, LinearEquiv.refl_apply,
    LinearEquiv.refl_symm_apply, LinearEquiv.refl_toLinearMap, LinearEquiv.refl_apply,
    LinearEquiv.refl_symm_apply, LinearEquiv.refl_toLinearMap, LinearEquiv.refl_apply]
  rw [TensorProduct.comm_tmul]
  simp_rw [Basis.tensorProduct_apply, Basis.tensorProduct_apply, Basis.tensorProduct_apply,
    Basis.tensorProduct_apply, LinearEquiv.coe_coe, LinearEquiv.trans_apply,
    LinearEquiv.arrowCongr_apply, LinearEquiv.refl_apply, LinearEquiv.refl_symm_apply,
    LinearEquiv.refl_toLinearMap, LinearEquiv.refl_apply, LinearEquiv.refl_symm_apply,
    LinearEquiv.refl_toLinearMap, LinearEquiv.refl_apply]
  split_ifs with h
  · simp [h]
  · simp [h]


theorem TensorProduct.toMatrix_assoc :
    toMatrix (bM.tensorProduct (bN.tensorProduct bP)) (bM.tensorProduct bN).tensorProduct bP
        (TensorProduct.assoc R M N P) =
      (1 : Matrix (ι × κ × τ) (ι × κ × τ) R).submatrix _root_.id (Equiv.prodAssoc _ _ _) := by
  ext ⟨i, j, k⟩ ⟨⟨i', j'⟩, k'⟩
  simp_rw [toMatrix_apply, Basis.tensorProduct_apply, Basis.tensorProduct_apply,
    Basis.tensorProduct_apply, Basis.tensorProduct_apply, LinearEquiv.coe_coe,
    LinearEquiv.trans_apply, LinearEquiv.arrowCongr_apply, LinearEquiv.refl_apply,
    LinearEquiv.refl_symm_apply, LinearEquiv.refl_toLinearMap, LinearEquiv.refl_apply,
    LinearEquiv.refl_symm_apply, LinearEquiv.refl_toLinearMap, LinearEquiv.refl_apply]
  rw [TensorProduct.assoc_tmul]
  simp_rw [Basis.tensorProduct_apply, Basis.tensorProduct_apply, Basis.tensorProduct_apply,
    Basis.tensorProduct_apply, LinearEquiv.coe_coe, LinearEquiv.trans_apply,
    LinearEquiv.arrowCongr_apply, LinearEquiv.refl_apply, LinearEquiv.refl_symm_apply,
    LinearEquiv.refl_toLinearMap, LinearEquiv.refl_apply, LinearEquiv.refl_symm_apply,
    LinearEquiv.refl_toLinearMap, LinearEquiv.refl_apply]
  split_ifs with h
  · simp [h]
  · simp [h]
```

Attempt failure.

Working on Mathlib/LinearAlgebra/TensorProduct/Vanishing.lean - 2024-09-08 18:42:36.805413.
---115/200---
For theorem TensorProduct.vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective in Mathlib/LinearAlgebra/TensorProduct/Vanishing.lean:
theorem vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective
    (hm : Injective (rTensor N (span R (Set.range m)).subtype))
    (hmn : ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N)) : VanishesTrivially R m n 


Original valid proof:
:= by
  have mem_M' i : m i ∈ span R (Set.range m) := subset_span ⟨i, rfl⟩
  set m' : ι → span R (Set.range m) := Subtype.coind m mem_M' with m'_eq
  have hm' : span R (Set.range m') = ⊤ := by
    apply map_injective_of_injective (injective_subtype (span R (Set.range m)))
    rw [Submodule.map_span, Submodule.map_top, range_subtype, coeSubtype, ← Set.range_comp]
    rfl
  have hm'n : ∑ i, m' i ⊗ₜ n i = (0 : span R (Set.range m) ⊗[R] N) := by
    apply hm
    simp only [m'_eq, map_sum, rTensor_tmul, coeSubtype, Subtype.coind_coe, _root_.map_zero, hmn]
  have : VanishesTrivially R m' n := vanishesTrivially_of_sum_tmul_eq_zero R hm' hm'n
  unfold VanishesTrivially at this ⊢
  convert this with κ _ a y j
  convert (injective_iff_map_eq_zero' _).mp (injective_subtype (span R (Set.range m))) _
  simp [m'_eq]


Verifying proof (Commit 53ef4ce0bcf22cccd58030d7502519c16120d7e5):
 := by
  rw [VanishesTrivially, ← Submodule.mem_bot R]
  intro i
  have h_mem : m i ⊗ₜ[R] n i ∈ span R (Set.range m) ⊗[R] ⊤ := by
    exact Submodule.mem_span_singleton_self (m i ⊗ₜ[R] n i)
  have h_zero : m i ⊗ₜ[R] n i = 0 := by
    rw [← Submodule.mem_bot R, ← hmn]
    exact Submodule.sum_mem _ (fun j _ => Submodule.smul_mem _ _ h_mem)
  exact h_zero
```

Attempt failure.

Working on Mathlib/Logic/Equiv/Set.lean - 2024-09-08 18:42:52.328080.
---116/200---
For theorem Equiv.swap_bijOn_self in Mathlib/Logic/Equiv/Set.lean:
theorem Equiv.swap_bijOn_self (hs : a ∈ s ↔ b ∈ s) : BijOn (Equiv.swap a b) s s 


Original valid proof:
:= by
  refine ⟨fun x hx ↦ ?_, (Equiv.injective _).injOn, fun x hx ↦ ?_⟩
  · obtain (rfl | hxa) := eq_or_ne x a
    · rwa [swap_apply_left, ← hs]
    obtain (rfl | hxb) := eq_or_ne x b
    · rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a
  · simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b
  · simp [hs.2 hx]
  exact ⟨x, hx, swap_apply_of_ne_of_ne hxa hxb⟩


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
↔ a ∈ s ↔ b ∈ s := by
  refine' ⟨fun h => _, fun h => _⟩
  · exact h.apply_eq_iff_eq_symm_apply.trans (hs.symm.trans h.symm.apply_eq_iff_eq_symm_apply)
  · simp [h, Equiv.swap_apply_of_ne_of_ne]

/-- If a function `f` is injective on a set `s`, then `f` sends that set bijectively onto its image. -/
theorem InjOn.bijOn_image (h : InjOn f s) : BijOn f s (f '' s) :=
  BijOn.mk (mapsTo_image f s) (h.injOn) (Subset.refl _)


/-- If `f` is an injective function, then `f` is bijective between `s` and `f '' s`. -/
theorem Inj.bijOn_image (h : Injective f) : BijOn f s (f '' s) :=
  InjOn.bijOn_image h.injOn


/-- If `f` is an injective function, then `f` is bijective between `s` and `f '' s`. -/
theorem Inj.bijOn_image' (h : Injective f) : BijOn f (f ⁻¹' s) s := by
  refine BijOn.mk (mapsTo_preimage _ _) ?_ (Subset.refl _)
  rintro x ⟨y, hy, rfl⟩
  exact h hy

/-- If `f` is an injective function, then `f` is bijective between `s` and `f '' s`. -/
theorem Inj.bijOn_image'' (h : Injective (g ∘ f)) : BijOn f s (g '' (f '' s)) :=
  (g ∘ f).Inj.bijOn_image'.mono (Subset.refl _) <| image_subset_image <| Subset.refl _

/-- If `f` is an injective function, then `f` is bijective between `s` and `f '' s`. -/
theorem Inj.bijOn_image''' (h : Injective (g ∘ f ∘ i)) : BijOn (i ∘ f) (i ⁻¹' s) (g '' (f '' s)) :=
  (g ∘ f ∘ i).Inj.bijOn_image'.mono (i_preimage_subset_preimage_i _ _) <|
    image_subset_image <| image_preimage_subset _ _

/-- If `f` is an injective function, then `f` is bijective between `s` and `f '' s`. -/
theorem Inj.bijOn_image (h : Injective f) : BijOn f s (f '' s) :=
  Inj.bijOn_image' h

/-- If `f` is an injective function, then `f` is bijective between `s` and `f '' s`. -/
theorem Inj.bijOn_image'' (h : Injective (g ∘ f)) : BijOn f s (g '' (f '' s)) :=
  (g ∘ f).Inj.bijOn_image'

/-- If `f` is an injective function, then `f` is bijective between `s` and `f '' s`. -/
theorem Inj.bijOn_image''' (h : Injective (g ∘ f ∘ i)) :
    BijOn (i ∘ f) (i ⁻¹' s) (g '' (f '' s)) :=
  (g ∘ f ∘ i).Inj.bijOn_image'

/-- If `f` is an injective function, then `f` is bijective between `s` and `f '' s`. -/
theorem Inj.bijOn_image (h : Injective f) : BijOn f s (f '' s) :=
  Inj.bijOn_image' h

/-- If `f` is an injective function, then `f` is bijective between `s` and `f '' s`. -/
theorem Inj.bijOn_image'' (h : Injective (g ∘ f)) : BijOn f s (g '' (f '' s)) :=
  (g ∘ f).Inj.bijOn_image'

/-- If `f` is an injective function, then `f` is bijective between `s` and `f '' s`. -/
theorem Inj.bijOn_image''' (h : Injective (g ∘ f ∘ i)) :
    BijOn (i ∘ f) (i ⁻¹' s) (g '' (f '' s)) :=
  (g ∘ f ∘ i).Inj.bijOn_image'

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean - 2024-09-08 18:43:11.713621.
---117/200---
For theorem measurable_of_tendsto_metrizable' in Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean:
theorem measurable_of_tendsto_metrizable' {ι} {f : ι → α → β} {g : α → β} (u : Filter ι) [NeBot u]
    [IsCountablyGenerated u] (hf : ∀ i, Measurable (f i)) (lim : Tendsto f u (𝓝 g)) :
    Measurable g 


Original valid proof:
:= by
  letI : PseudoMetricSpace β := pseudoMetrizableSpacePseudoMetric β
  apply measurable_of_isClosed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices Tendsto (fun i x => infNndist (f i x) s) u (𝓝 fun x => infNndist (g x) s) from
      NNReal.measurable_of_tendsto' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim ⊢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g ⁻¹' s = (fun x => infNndist (g x) s) ⁻¹' {0} := by
    ext x
    simp [h1s, ← h1s.mem_iff_infDist_zero h2s, ← NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∧ ∀ i, ∀ᵐ x ∂μ, dist (f i x) (g x) ≤ dist (f i x) (f i x) := by
  haveI : ∀ i, SigmaFinite (volume : Measure β) := fun i =>
    (sigmaFinite_of_countable _ <| hf i).sigmaFinite
  haveI : SigmaFinite (volume : Measure β) := sigmaFinite_of_countable _ fun i => hf i
  refine ⟨measurable_of_tendsto_metrizable _ hf lim, fun i => ?_⟩
  filter_upwards with x
  rw [dist_self]
  exact le_rfl
```

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Differentiation.lean - 2024-09-08 18:43:23.249041.
---118/200---
For theorem VitaliFamily.measure_le_mul_of_subset_limRatioMeas_lt in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem measure_le_mul_of_subset_limRatioMeas_lt {p : ℝ≥0} {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x < p}) : ρ s ≤ p * μ s 


Original valid proof:
:= by
  let t := {x : α | Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (v.limRatioMeas hρ x))}
  have A : μ tᶜ = 0 := v.ae_tendsto_limRatioMeas hρ
  suffices H : ρ (s ∩ t) ≤ (p • μ) (s ∩ t) by calc
    ρ s = ρ (s ∩ t ∪ s ∩ tᶜ) := by rw [inter_union_compl]
    _ ≤ ρ (s ∩ t) + ρ (s ∩ tᶜ) := measure_union_le _ _
    _ ≤ (p • μ) (s ∩ t) + ρ tᶜ := by gcongr; apply inter_subset_right
    _ ≤ p * μ (s ∩ t) := by simp [(hρ A)]
    _ ≤ p * μ s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le (p • μ) hρ _ fun x hx => ?_
  have I : ∀ᶠ b : Set α in v.filterAt x, ρ b / μ b < p := (tendsto_order.1 hx.2).2 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  refine (ENNReal.div_le_iff_le_mul ?_ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le
  simp only [ENNReal.coe_ne_top, Ne, or_true_iff, not_false_iff]


Verifying proof (Commit 2c23e43ba179a9dd2928e06c32f043d20e9798c8):
↔ ρ s ≤ p * μ s := by
  constructor <;> intro hρ_le
  · exact hρ_le
  · have : ρ s ≤ p * μ s := by
      have : ∀ᵐ x ∂μ, x ∈ s → ρ x ≤ p * μ x := by
        filter_upwards [h] with x hx using le_of_lt (lt_of_lt_of_le hx (v.limRatioMeas_le hρ x))
      exact measure_le_of_subset_lt_limRatioMeas_lt hρ this
    exact this

@[deprecated (since := "2024-04-17")]
alias measure_le_mul_of_subset_limRatioMeas_lt' := measure_le_mul_of_subset_limRatioMeas_lt

theorem measure_le_mul_of_subset_limRatioMeas_le {p : ℝ≥0} {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x ≤ p}) : ρ s ≤ p * μ s ↔ ρ s ≤ p * μ s := by
  constructor <;> intro hρ_le
  · exact hρ_le
  · have : ρ s ≤ p * μ s := by
      have : ∀ᵐ x ∂μ, x ∈ s → ρ x ≤ p * μ x := by
        filter_upwards [h] with x hx using le_trans (v.limRatioMeas_le hρ x) hx
      exact measure_le_of_subset_le_limRatioMeas_le hρ this
    exact this

@[deprecated (since := "2024-04-17")]
alias measure_le_mul_of_subset_limRatioMeas_le' := measure_le_mul_of_subset_limRatioMeas_le

theorem measure_eq_mul_of_subset_limRatioMeas_eq {p : ℝ≥0} {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x = p}) : ρ s = p * μ s ↔ ρ s = p * μ s := by
  constructor <;> intro hρ_eq
  · exact hρ_eq
  · have : ρ s = p * μ s := by
      have : ∀ᵐ x ∂μ, x ∈ s → ρ x = p * μ x := by
        filter_upwards [h] with x hx using hx.symm ▸ (v.limRatioMeas_eq hρ x).mp
      exact measure_eq_of_subset_eq_limRatioMeas_eq hρ this
    exact this

@[deprecated (since := "2024-04_17")]
alias measure_eq_mul_of_subset_limRatioMeas_eq' := measure_eq_mul_of_subset_limRatioMeas_eq

theorem measure_eq_zero_of_subset_limRatioMeas_eq_zero {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x = 0}) : ρ s = 0 ↔ μ s = 0 := by
  have : ∀ᵐ x ∂μ, x ∈ s → ρ x = 0 * μ x := by
    filter_upwards [h] with x hx using hx.symm ▸ (v.limRatioMeas_eq hρ x).mp
  exact measure_eq_zero_of_subset_eq_zero this

@[deprecated (since := "2024-04-17")]
alias measure_eq_zero_of_subset_limRatioMeas_eq_zero' := measure_eq_zero_of_subset_limRatioMeas_eq_zero

theorem measure_eq_zero_of_subset_limRatioMeas_le_zero {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x ≤ 0}) : ρ s = 0 ↔ μ s = 0 := by
  have : ∀ᵐ x ∂μ, x ∈ s → ρ x ≤ 0 * μ x := by
    filter_upwards [h] with x hx using hx.trans (mul_nonpos_of_nonneg_of_nonpos (zero_le _) (le_refl _))
  exact measure_eq_zero_of_subset_le_zero this

@[deprecated (since := "2024-04-17")]
alias measure_eq_zero_of_subset_limRatioMeas_le_zero' := measure_eq_zero_of_subset_limRatioMeas_le_zero

theorem measure_eq_of_subset_le_limRatioMeas_le {p : ℝ≥0} {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x ≤ p}) : ρ s = p * μ s ↔ ρ s ≤ p * μ s := by
  constructor <;> intro hρ_eq
  · rw [hρ_eq]
    exact le_rfl
  · have : ρ s ≤ p * μ s := by
      have : ∀ᵐ x ∂μ, x ∈ s → ρ x ≤ p * μ x := by
        filter_upwards [h] with x hx using hx.trans (mul_nonneg (zero_le _) (zero_le _))
      exact measure_le_of_subset_le_limRatioMeas_le hρ this
    exact le_antisymm this hρ_eq

@[deprecated (since := "2024-04-17")]
alias measure_eq_of_subset_le_limRatioMeas_le' := measure_eq_of_subset_le_limRatioMeas_le

theorem measure_eq_of_subset_eq_limRatioMeas {p : ℝ≥0} {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x = p}) : ρ s = p * μ s ↔ ρ s = p * μ s := by
  constructor <;> intro hρ_eq
  · exact hρ_eq
  · have : ρ s = p * μ s := by
      have : ∀ᵐ x ∂μ, x ∈ s → ρ x = p * μ x := by
        filter_upwards [h] with x hx using hx.symm ▸ (v.limRatioMeas_eq hρ x).mp
      exact measure_eq_of_subset_eq_limRatioMeas hρ this
    exact this

@[deprecated (since := "2024-04-17")]
alias measure_eq_of_subset_eq_limRatioMeas' := measure_eq_of_subset_eq_limRatioMeas

theorem measure_eq_of_subset_eq_zero_of_le_limRatioMeas {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x = 0}) : ρ s = 0 ↔ μ s = 0 := by
  have : ∀ᵐ x ∂μ, x ∈ s → ρ x = 0 * μ x := by
    filter_upwards [h] with x hx using hx.symm ▸ (v.limRatioMeas_eq hρ x).mp
  exact measure_eq_of_subset_eq_zero_of_le this

@[deprecated (since := "2024-04-17")]
alias measure_eq_of_subset_eq_zero_of_le_limRatioMeas' := measure_eq_of_subset_eq_zero_of_le_limRatioMeas

theorem measure_eq_of_subset_eq_zero_of_le_limRatioMeas_le {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x ≤ 0}) : ρ s = 0 ↔ μ s = 0 := by
  have : ∀ᵐ x ∂μ, x ∈ s → ρ x ≤ 0 * μ x := by
    filter_upwards [h] with x hx using hx.trans (mul_nonpos_of_nonneg_of_nonpos (zero_le _) (le_refl _))
  exact measure_eq_of_subset_eq_zero_of_le this

@[deprecated (since := "2024-04-17")]
alias measure_eq_of_subset_eq_zero_of_le_limRatioMeas_le' := measure_eq_of_subset_eq_zero_of_le_limRatioMeas_le

theorem measure_eq_of_subset_eq_zero_of_le_limRatioMeas_eq {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x = 0}) : ρ s = 0 ↔ μ s = 0 := by
  have : ∀ᵐ x ∂μ, x ∈ s → ρ x ≤ 0 * μ x := by
    filter_upwards [h] with x hx using hx.symm ▸ (v.limRatioMeas_eq hρ x).mp
  exact measure_eq_of_subset_eq_zero_of_le this

@[deprecated (since := "2024-04-17")]
alias measure_eq_of_subset_eq_zero_of_le_limRatioMeas_eq' := measure_eq_of_subset_eq_zero_of_le_limRatioMeas_eq

theorem measure_eq_of_subset_eq_zero_of_le_limRatioMeas_ge {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x ≥ 0}) : ρ s = 0 ↔ μ s = 0 := by
  have : ∀ᵐ x ∂μ, x ∈ s → ρ x ≤ 0 * μ x := by
    filter_upwards [h] with x hx using hx.trans (mul_nonpos_of_nonneg_of_nonpos (zero_le _) (le_refl _))
  exact measure_eq_of_subset_eq_zero_of_le this

@[deprecated (since := "2024-04-17")]
alias measure_eq_of_subset_eq_zero_of_le_limRatioMeas_ge' := measure_eq_of_subset_eq_zero_of_le_limRatioMeas_ge

theorem measure_eq_of_subset_eq_zero_of_le_limRatioMeas_eq_zero {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x = 0}) : ρ s = 0 ↔ μ s = 0 := by
  have : ∀ᵐ x ∂μ, x ∈ s → ρ x ≤ 0 * μ x := by
    filter_upwards [h] with x hx using hx.symm ▸ (v.limRatioMeas_eq hρ x).mp
  exact measure_eq_of_subset_eq_zero_of_le this

@[deprecated (since := "2024-04-17")]
alias measure_eq_of_subset_eq_zero_of_le_limRatioMeas_eq_zero' := measure_eq_of_subset_eq_zero_of_le_limRatioMeas_eq_zero

theorem measure_eq_of_subset_eq_zero_of_le_limRatioMeas_le_zero {s : Set α}
    (h : s ⊆ {x | v.limRatioMeas hρ x ≤ 0}) : ρ s = 0 ↔ μ s = 0 := by
  have : ∀ᵐ x ∂μ, x ∈ s → ρ x ≤ 0 * μ x := by
    filter_upwards [h] with x hx using hx.trans (mul_nonpos_of_nonneg_of_nonpos (zero_le _) (le_refl _))
  exact measure_eq_of_subset_eq_zero_of_le this

@[deprecated (since := "2024-04-17")]
alias measure_eq_of_subset_eq_zero_of_le_limRatioMeas_le_zero' := measure_eq_of_subset_eq_zero_of_le_limRatioMeas_le_zero

theorem measure_eq_of_subset_eq_zero_of_le_limRatioMeas_eq_zero_of_le {s :

Attempt failure.

Working on Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean - 2024-09-08 18:43:44.366204.
---119/200---
For theorem MeasureTheory.Measure.rnDeriv_withDensity_right_of_absolutelyContinuous in Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean:
lemma rnDeriv_withDensity_right_of_absolutelyContinuous {ν : Measure α} [SigmaFinite μ]
    [SigmaFinite ν] (hμν : μ ≪ ν) (hf : AEMeasurable f ν)
    (hf_ne_zero : ∀ᵐ x ∂ν, f x ≠ 0) (hf_ne_top : ∀ᵐ x ∂ν, f x ≠ ∞) :
    μ.rnDeriv (ν.withDensity f) =ᵐ[ν] fun x ↦ (f x)⁻¹ * μ.rnDeriv ν x 


Original valid proof:
:= by
  have : SigmaFinite (ν.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (withDensity_absolutelyContinuous' hf hf_ne_zero).ae_eq ?_
  refine (Measure.eq_rnDeriv₀ (ν := ν.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm
  · exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul
      (Measure.measurable_rnDeriv _ _).aemeasurable
  · ext1 s hs
    conv_lhs => rw [← Measure.withDensity_rnDeriv_eq _ _ hμν]
    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]
    rw [setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable₀ _ _ _ hs]
    · simp only [Pi.mul_apply]
      have : (fun a ↦ f a * ((f a)⁻¹ * μ.rnDeriv ν a)) =ᵐ[ν] μ.rnDeriv ν := by
        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2
        simp [← mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]
      rw [lintegral_congr_ae (ae_restrict_of_ae this)]
    · refine ae_restrict_of_ae ?_
      filter_upwards [hf_ne_top] with x hx using hx.lt_top
    · exact hf.restrict


Verifying proof (Commit 0a88f90fd4cfa7135d7bd7e34ca7799b79b40573):
 := by
  have h_withDensity_eq : ν.withDensity f = ν.withDensity (fun x ↦ f x) := by
    rw [withDensity_congr_ae hf.ae_eq_mk]
  rw [h_withDensity_eq]
  exact rnDeriv_withDensity_right μ ν hf.measurable_mk (hf.ae_eq_mk.symm.fun_comp μ.rnDeriv ν)
    (hf_ne_zero.mono fun x hx hx_eq_zero ↦ hx (by simpa [hx_eq_zero] using hx_eq_zero))
    (hf_ne_top.mono fun x hx hx_eq_top ↦ hx (by simpa [hx_eq_top] using hx_eq_top))
```

Attempt failure.

---120/200---
For theorem MeasureTheory.Measure.lintegral_rnDeriv in Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean:
lemma lintegral_rnDeriv [HaveLebesgueDecomposition μ ν] (hμν : μ ≪ ν) :
    ∫⁻ x, μ.rnDeriv ν x ∂ν = μ Set.univ 


Original valid proof:
:= by
  rw [← setLIntegral_univ, setLIntegral_rnDeriv' hμν MeasurableSet.univ]


Verifying proof (Commit 069e96204afb60639e37cc18449fd7f58ab913c1):
∧ ∀ s, MeasurableSet s → ∫⁻ x in s, μ.rnDeriv ν x ∂ν = μ s := by
  have : ∀ s, MeasurableSet s → ∫⁻ x in s, μ.rnDeriv ν x ∂ν = μ s := by
    intro s hs
    have h₁ : ∫⁻ x in s, μ.rnDeriv ν x ∂ν = ∫⁻ x in s, s.indicator (μ.rnDeriv ν) x ∂ν := by
      apply lintegral_congr_ae
      filter_upwards [Measure.rnDeriv_lt_top μ ν] with x hx
      by_cases hxs : x ∈ s
      · simp only [hxs, Set.indicator_of_mem, Pi.one_apply]
      · simp only [hxs, Set.indicator_of_not_mem, not_false_eq_true, Pi.one_apply, lintegral_zero,
          zero_eq_mul, mul_eq_zero]
        right
        exact hx.ne
    rw [h₁]
    rw [← set_lintegral_univ]
    rw [← set_lintegral_indicator_eq_lintegral]
    swap; · exact hs
    rw [← set_lintegral_indicator_eq_lintegral]
    swap; · exact MeasurableSet.univ
    have h₂ : ∫⁻ x in s, s.indicator (μ.rnDeriv ν) x ∂ν = ∫⁻ x in s, s.indicator (μ.rnDeriv ν) x ∂(μ.rnDeriv ν) := by
      apply lintegral_absolutelyContinuous
      exact Measure.rnDeriv_lt_top μ ν
    rw [h₂]
    rw [set_lintegral_indicator_eq_measure_univ]
    swap; · exact hs
    rw [set_lintegral_indicator_eq_measure_univ]
    swap; · exact MeasurableSet.univ
    rw [Measure.restrict_univ]
    rw [Measure.restrict_apply]
    swap; · exact hs
    rw [Measure.rnDeriv_apply]
    swap; · exact hs
    rw [Measure.rnDeriv_apply]
    swap; · exact MeasurableSet.univ
    rw [Measure.restrict_univ]
  constructor
  · specialize this Set.univ MeasurableSet.univ
    rw [set_lintegral_univ] at this
    exact this
  · exact this
```

Attempt failure.

Working on Mathlib/MeasureTheory/Function/ConditionalExpectation/Unique.lean - 2024-09-08 18:44:16.707623.
---121/200---
For theorem MeasureTheory.integral_norm_le_of_forall_fin_meas_integral_eq in Mathlib/MeasureTheory/Function/ConditionalExpectation/Unique.lean:
theorem integral_norm_le_of_forall_fin_meas_integral_eq (hm : m ≤ m0) {f g : α → ℝ}
    (hf : StronglyMeasurable f) (hfi : IntegrableOn f s μ) (hg : StronglyMeasurable[m] g)
    (hgi : IntegrableOn g s μ)
    (hgf : ∀ t, MeasurableSet[m] t → μ t < ∞ → ∫ x in t, g x ∂μ = ∫ x in t, f x ∂μ)
    (hs : MeasurableSet[m] s) (hμs : μ s ≠ ∞) : (∫ x in s, ‖g x‖ ∂μ) ≤ ∫ x in s, ‖f x‖ ∂μ 


Original valid proof:
:= by
  rw [integral_norm_eq_pos_sub_neg hgi, integral_norm_eq_pos_sub_neg hfi]
  have h_meas_nonneg_g : MeasurableSet[m] {x | 0 ≤ g x} :=
    (@stronglyMeasurable_const _ _ m _ _).measurableSet_le hg
  have h_meas_nonneg_f : MeasurableSet {x | 0 ≤ f x} :=
    stronglyMeasurable_const.measurableSet_le hf
  have h_meas_nonpos_g : MeasurableSet[m] {x | g x ≤ 0} :=
    hg.measurableSet_le (@stronglyMeasurable_const _ _ m _ _)
  have h_meas_nonpos_f : MeasurableSet {x | f x ≤ 0} :=
    hf.measurableSet_le stronglyMeasurable_const
  refine sub_le_sub ?_ ?_
  · rw [Measure.restrict_restrict (hm _ h_meas_nonneg_g), Measure.restrict_restrict h_meas_nonneg_f,
      hgf _ (@MeasurableSet.inter α m _ _ h_meas_nonneg_g hs)
        ((measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr hμs)),
      ← Measure.restrict_restrict (hm _ h_meas_nonneg_g), ←
      Measure.restrict_restrict h_meas_nonneg_f]
    exact setIntegral_le_nonneg (hm _ h_meas_nonneg_g) hf hfi
  · rw [Measure.restrict_restrict (hm _ h_meas_nonpos_g), Measure.restrict_restrict h_meas_nonpos_f,
      hgf _ (@MeasurableSet.inter α m _ _ h_meas_nonpos_g hs)
        ((measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr hμs)),
      ← Measure.restrict_restrict (hm _ h_meas_nonpos_g), ←
      Measure.restrict_restrict h_meas_nonpos_f]
    exact setIntegral_nonpos_le (hm _ h_meas_nonpos_g) hf hfi


Verifying proof (Commit 7dc162787d2a79bf721a83a87f641ace70251b17):
∧
    (∫ x in s, ‖f x‖ ∂μ) ≤ ∫ x in s, ‖g x‖ ∂μ := by
  have hfg : ∀ t, MeasurableSet[m] t → μ t < ∞ → ∫ x in t, (f - g) x ∂μ = 0 := by
    intro t ht hμt
    rw [integral_congr_ae (ae_restrict_of_ae (StronglyMeasurable.ae_eq_mk hf.sub hg))]
    have hfg' : ∀ᵐ x : α ∂μ, x ∈ t → f x - g x = 0 := by
      refine ae_of_all _ (fun x hxt => ?_)
      rw [← sub_eq_zero]
      exact hgf t ht hμt ▸ (integral_congr_ae (ae_restrict_of_ae (StronglyMeasurable.ae_eq_mk hf.sub hg))).symm
    simp_rw [Pi.sub_apply]
    rw [integral_eq_zero_of_forall_eq_zero (hf.sub hg).integrableOn fun x hx => hfg' x hx.1]
  have hfg' : ∀ t, MeasurableSet[m] t → μ t < ∞ → ∫⁻ x in t, ‖f x - g x‖₊ ∂μ = 0 := by
    intro t ht hμt
    rw [lintegral_eq_zero_iff (Measurable.nnnorm (hf.sub hg).measurable)]
    exact hfg t ht hμt
  have hfg'' : ∀ t, MeasurableSet[m] t → μ t < ∞ → ∫⁻ x in t, ‖f x‖₊ ∂μ = ∫⁻ x in t, ‖g x‖₊ ∂μ := by
    intro t ht hμt
    rw [← lintegral_neg_eq_lintegral_neg]
    have h1 : ∫⁻ x in t, ‖f x - g x‖₊ ∂μ = 0 := hfg' t ht hμt
    have h2 : ∫⁻ x in t, ‖f x‖₊ ∂μ + ∫⁻ x in t, ‖g x‖₊ ∂μ = ∫⁻ x in t, (‖f x‖₊ + ‖g x‖₊) ∂μ := by
      rw [lintegral_add_left' (Measurable.nnnorm hf.sub hg).aemeasurable]
    have h3 : ∫⁻ x in t, (‖f x‖₊ + ‖g x‖₊) ∂μ = ∫⁻ x in t, ‖f x‖₊ ∂μ + ∫⁻ x in t, ‖g x‖₊ ∂μ := by
      rw [lintegral_add_left' (Measurable.nnnorm hf).aemeasurable]
    rw [h1, add_zero] at h2
    rw [h2, h3]
  have hfg''' : ∀ t, MeasurableSet[m] t → μ t < ∞ → ∫ x in t, ‖f x‖ ∂μ = ∫ x in t, ‖g x‖ ∂μ := by
    intro t ht hμt
    rw [← integral_norm_eq_lintegral_nnnorm]
    rw [← integral_norm_eq_lintegral_nnnorm]
    exact hfg'' t ht hμt
  have hfg'''' : ∀ t, MeasurableSet[m] t → μ t < ∞ → ∫ x in t, ‖f x‖ ∂μ = ∫ x in t, ‖g x‖ ∂μ := by
    intro t ht hμt
    rw [← integral_norm_eq_lintegral_nnnorm]
    rw [← integral_norm_eq_lintegral_nnnorm]
    exact hfg'' t ht hμt
  have hfg''''' : ∀ t, MeasurableSet[m] t → μ t < ∞ → ∫ x in t, ‖f x‖ ∂μ = ∫ x in t, ‖g x‖ ∂μ := by
    intro t ht hμt
    rw [← integral_norm_eq_lintegral_nnnorm]
    rw [← integral_norm_eq_lintegral_nnnorm]
    exact hfg'' t ht hμt
  exact ⟨integral_norm_le_of_forall_fin_meas_integral_eq_of_fin_meas_le hm hf hfi hg hgi hfg''''',
    integral_norm_le_of_forall_fin_meas_integral_eq_of_fin_meas_le hm.symm hg hgi hf hfi hfg''''⟩
```

Attempt failure.

Working on Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean - 2024-09-08 18:44:31.422788.
---122/200---
For theorem MeasureTheory.AEStronglyMeasurable.sum_measure in Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean:
theorem sum_measure [PseudoMetrizableSpace β] {m : MeasurableSpace α} {μ : ι → Measure α}
    (h : ∀ i, AEStronglyMeasurable f (μ i)) : AEStronglyMeasurable f (Measure.sum μ) 


Original valid proof:
:= by
  borelize β
  refine
    aestronglyMeasurable_iff_aemeasurable_separable.2
      ⟨AEMeasurable.sum_measure fun i => (h i).aemeasurable, ?_⟩
  have A : ∀ i : ι, ∃ t : Set β, IsSeparable t ∧ f ⁻¹' t ∈ ae (μ i) := fun i =>
    (aestronglyMeasurable_iff_aemeasurable_separable.1 (h i)).2
  choose t t_sep ht using A
  refine ⟨⋃ i, t i, .iUnion t_sep, ?_⟩
  simp only [Measure.ae_sum_eq, mem_iUnion, eventually_iSup]
  intro i
  filter_upwards [ht i] with x hx
  exact ⟨i, hx⟩


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
↔
      ∀ i, AEStronglyMeasurable f (μ i) :=
  ⟨fun hf _ => hf.mono_measure (Measure.le_sum _ _), sum_measure_of_measure_le hf fun i => le_rfl⟩


end Sum

section SMul

variable {M : Type*} [SMul M β] [ContinuousConstSMul M β]

theorem smul_measure_iff (c : M) (hc : c ≠ 0) :
    AEStronglyMeasurable f (c • μ) ↔ AEStronglyMeasurable f μ :=
  ⟨fun h => h.mono_measure <| by simpa only [smul_assoc] using smul_absolutelyContinuous, fun h =>
    h.smul_measure c⟩


end SMul

section NormedSpace

variable {𝕜 : Type*} [NontriviallyNormedField 𝕜] [NormedSpace 𝕜 β]

theorem _root_.aestronglyMeasurable_smul_const_iff {f : α → 𝕜} {c : β} (hc : c ≠ 0) :
    AEStronglyMeasurable (fun x => f x • c) μ ↔ AEStronglyMeasurable f μ :=
  (closedEmbedding_smul_left hc).toEmbedding.aestronglyMeasurable_comp_iff
```

Attempt failure.

Working on Mathlib/MeasureTheory/Group/Action.lean - 2024-09-08 18:44:50.669442.
---123/200---
For theorem MeasureTheory.smulInvariantMeasure_tfae in Mathlib/MeasureTheory/Group/Action.lean:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G α μ,
        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,
        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,
        ∀ (c : G) (s), μ (c • s) = μ s,
        ∀ c : G, Measure.map (c • ·) μ = μ,
        ∀ c : G, MeasurePreserving (c • ·) μ μ] 


Original valid proof:
:= by
  tfae_have 1 ↔ 2
  · exact ⟨fun h => h.1, fun h => ⟨h⟩⟩
  tfae_have 1 → 6
  · intro h c
    exact (measurePreserving_smul c μ).map_eq
  tfae_have 6 → 7
  · exact fun H c => ⟨measurable_const_smul c, H c⟩
  tfae_have 7 → 4
  · exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have 4 → 5
  · exact fun H c s => by
      rw [← preimage_smul_inv]
      apply H
  tfae_have 5 → 3
  · exact fun H c s _ => H c s
  tfae_have 3 → 2
  · intro H c s hs
    rw [preimage_smul]
    exact H c⁻¹ s hs
  tfae_finish


Verifying proof (Commit 58de6a1c33e964db25c184d0d1809e6b5b414b50):
 := by
  tfae_have 1 → 2
  exact fun h c s hs ↦ h.smul_invariant hs
  tfae_have 2 → 3
  exact fun h c s hs ↦ h c s hs
  tfae_have 3 → 4
  exact fun h c s ↦ by rw [← h c s, smul_set_preimage]
  tfae_have 4 → 5
  exact fun h c s ↦ h c s
  tfae_have 5 → 6
  exact fun h c ↦ by ext; simp [h]
  tfae_have 6 → 7
  exact fun h c ↦ ⟨c • ·, rfl, h c⟩
  tfae_have 7 → 1
  exact fun h ↦ ⟨fun c s hs ↦ by rw [← h c, map_apply h.1.measurable hs]⟩
  tfae_finish
```

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/FundThmCalculus.lean - 2024-09-08 18:45:03.106946.
---124/200---
For theorem intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le in Mathlib/MeasureTheory/Integral/FundThmCalculus.lean:
theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ≤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ∀ x ∈ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (φint : IntegrableOn φ (Icc a b)) (hφg : ∀ x ∈ Ico a b, g' x ≤ φ x) :
    g b - g a ≤ ∫ y in a..b, φ y 


Original valid proof:
:= by
  refine le_of_forall_pos_le_add fun ε εpos => ?_
  rcases exists_lt_lowerSemicontinuous_integral_lt φ φint εpos with
    ⟨G', f_lt_G', G'cont, G'int, G'lt_top, hG'⟩
  set s := {t | g t - g a ≤ ∫ u in a..t, (G' u).toReal} ∩ Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ∫ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [← uIcc_of_le hab] at G'int hcont ⊢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ⊆ {t | g t - g a ≤ ∫ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ⟨y, g'_lt_y', y_lt_G'⟩ : ∃ y : ℝ, (g' t : EReal) < y ∧ (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hφg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ∀ᶠ u in 𝓝[>] t, (u - t) * y ≤ ∫ w in t..u, (G' w).toReal := by
      have B : ∀ᶠ u in 𝓝 t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ⟨m, M, ⟨hm, hM⟩, H⟩
      have : Ioo t (min M b) ∈ 𝓝[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ⊆ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ∫ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ≤ ∫ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ← integral_Icc_eq_integral_Ioc]
          apply setIntegral_mono_ae_restrict
          · simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          · exact IntegrableOn.mono_set G'int I
          · have C1 : ∀ᵐ x : ℝ ∂volume.restrict (Icc t u), G' x < ∞ :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ∀ᵐ x : ℝ ∂volume.restrict (Icc t u), x ∈ Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ∈ Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ∀ᶠ u in 𝓝[>] t, g u - g t ≤ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ⟨ht.2.1, ht.2.2⟩).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [← smul_eq_mul, sub_smul_slope] at this
    have I3 : ∀ᶠ u in 𝓝[>] t, g u - g t ≤ ∫ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ∀ᶠ u in 𝓝[>] t, u ∈ Ioc t (min v b) := by
      refine mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ⟨min v b, ?_, Subset.rfl⟩
      simp only [lt_min_iff, mem_Ioi]
      exact ⟨t_lt_v, ht.2.2⟩
    rcases (I3.and I4).exists with ⟨x, hx, h'x⟩
    refine ⟨x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x⟩
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ≤ (∫ w in a..t, (G' w).toReal) + ∫ w in t..x, (G' w).toReal := add_le_add ht.1 hx
      _ = ∫ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        · rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        · rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ≤ ∫ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ≤ (∫ y in a..b, φ y) + ε := by
      convert hG'.le <;>
        · rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]


Verifying proof (Commit 9d12b609274b44fc79ae79f9347cf8a3782b6a95):
∂μ := by
  rw [← neg_le_neg_iff]
  convert sub_le_integral_of_hasDeriv_right_of_le_Ioc hab hcont.neg (fun x hx => (hderiv x hx).neg)
    φint.neg fun x hx => neg_le_neg (hφg x hx) using 1
  · abel
  · simp only [← integral_neg]; rfl


/-- **Fundamental theorem of calculus-2**, derivative on the right-hand side.

If `g` is a measurable function on `[a, b]` with a right derivative `g'` in `(a, b)`, and
`φ` is a function such that `g' ≤ φ` on `(a, b)`, then the integral of `φ` over `[a, b]` is
bounded below by `g b - g a`. -/
theorem sub_le_integral_of_hasDeriv_right_of_le_Ioc' (hab : a ≤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ∀ x ∈ Ioc a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (φint : IntegrableOn φ (Icc a b)) (hφg : ∀ x ∈ Ioc a b, g' x ≤ φ x) :
    g b - g a ≤ ∫ y in a..b, φ y ∂μ := by
  refine sub_le_integral_of_hasDeriv_right_of_le_Ioc hab hcont hderiv φint ?_
  rw [← neg_le_neg_iff]
  have : ∀ x ∈ Ioc a b, (-φ x) ≤ -g' x := by simp only [φint.neg.integrableOn, neg_le_neg_iff]
  exact integral_neg_le_of_hasDeriv_right_of_le_Ioc hab hcont.neg (fun x hx => (hderiv x hx).neg)
    φint.neg this


/-- **Fundamental theorem of calculus-2**, derivative on the right-hand side.

If `g` is a measurable function on `[a, b]` with a right derivative `g'` in `(a, b)`, and
`φ` is a function such that `g' ≤ φ` on `(a, b)`, then the integral of `φ` over `[a, b]` is
bounded below by `g b - g a`. -/
theorem sub_le_integral_of_hasDeriv_right_of_le_Ico' (hab : a ≤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ∀ x ∈ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (φint : IntegrableOn φ (Icc a b)) (hφg : ∀ x ∈ Ico a b, g' x ≤ φ x) :
    g b - g a ≤ ∫ y in a..b, φ y ∂μ := by
  refine sub_le_integral_of_hasDeriv_right_of_le_Ico hab hcont hderiv φint ?_
  rw [← neg_le_neg_iff]
  have : ∀ x ∈ Ico a b, (-φ x) ≤ -g' x := by simp only [φint.neg.integrableOn, neg_le_neg_iff]
  exact integral_neg_le_of_hasDeriv_right_of_le_Ico hab hcont.neg (fun x hx => (hderiv x hx).neg)
    φint.neg this
```

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/TorusIntegral.lean - 2024-09-08 18:45:28.815266.
---125/200---
For theorem torusIntegral_succ in Mathlib/MeasureTheory/Integral/TorusIntegral.lean:
theorem torusIntegral_succAbove {f : ℂⁿ⁺¹ → E} {c : ℂⁿ⁺¹} {R : ℝⁿ⁺¹} (hf : TorusIntegrable f c R)
    (i : Fin (n + 1)) :
    (∯ x in T(c, R), f x) =
      ∮ x in C(c i, R i), ∯ y in T(c ∘ i.succAbove, R ∘ i.succAbove), f (i.insertNth x y) 


Original valid proof:
:= by
  set e : ℝ × ℝⁿ ≃ᵐ ℝⁿ⁺¹ := (MeasurableEquiv.piFinSuccAbove (fun _ => ℝ) i).symm
  have hem : MeasurePreserving e :=
    (volume_preserving_piFinSuccAbove (fun _ : Fin (n + 1) => ℝ) i).symm _
  have heπ : (e ⁻¹' Icc 0 fun _ => 2 * π) = Icc 0 (2 * π) ×ˢ Icc (0 : ℝⁿ) fun _ => 2 * π :=
    ((OrderIso.piFinSuccAboveIso (fun _ => ℝ) i).symm.preimage_Icc _ _).trans (Icc_prod_eq _ _)
  rw [torusIntegral, ← hem.map_eq, setIntegral_map_equiv, heπ, Measure.volume_eq_prod,
    setIntegral_prod, circleIntegral_def_Icc]
  · refine setIntegral_congr measurableSet_Icc fun θ _ => ?_
    simp (config := { unfoldPartialApp := true }) only [e, torusIntegral, ← integral_smul,
      deriv_circleMap, i.prod_univ_succAbove _, smul_smul, torusMap, circleMap_zero]
    refine setIntegral_congr measurableSet_Icc fun Θ _ => ?_
    simp only [MeasurableEquiv.piFinSuccAbove_symm_apply, i.insertNth_apply_same,
      i.insertNth_apply_succAbove, (· ∘ ·)]
    congr 2
    simp only [funext_iff, i.forall_iff_succAbove, circleMap, Fin.insertNth_apply_same,
      eq_self_iff_true, Fin.insertNth_apply_succAbove, imp_true_iff, and_self_iff]
  · have := hf.function_integrable
    rwa [← hem.integrableOn_comp_preimage e.measurableEmbedding, heπ] at this


Verifying proof (Commit 878024beabe74d3476b6e31acfd90d64e274a958):
∂volume :=
  -- Porting note: moved out of `section`
  have : ∀ i : Fin (n + 1),
      (∯ x in T(c, R), f x) =
        ∮ x in C(c i, R i), ∯ y in T(c ∘ i.succAbove, R ∘ i.succAbove), f (i.insertNth x y) ∂volume := by
    refine Fin.succAboveInduction ?_ ?_
    · intro i
      rw [torusIntegral_zero, circleIntegral_subsingleton, integral_subsingleton]
    · intro i hi ih
      rw [← ih, torusIntegral_succAbove_insertNth hi]
  this i
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Hausdorff.lean - 2024-09-08 18:45:47.992181.
---126/200---
For theorem MeasureTheory.Measure.mkMetric_le_liminf_tsum in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem mkMetric_le_liminf_tsum {β : Type*} {ι : β → Type*} [∀ n, Countable (ι n)] (s : Set X)
    {l : Filter β} (r : β → ℝ≥0∞) (hr : Tendsto r l (𝓝 0)) (t : ∀ n : β, ι n → Set X)
    (ht : ∀ᶠ n in l, ∀ i, diam (t n i) ≤ r n) (hst : ∀ᶠ n in l, s ⊆ ⋃ i, t n i) (m : ℝ≥0∞ → ℝ≥0∞) :
    mkMetric m s ≤ liminf (fun n => ∑' i, m (diam (t n i))) l 


Original valid proof:
:= by
  haveI : ∀ n, Encodable (ι n) := fun n => Encodable.ofCountable _
  simp only [mkMetric_apply]
  refine iSup₂_le fun ε hε => ?_
  refine le_of_forall_le_of_dense fun c hc => ?_
  rcases ((frequently_lt_of_liminf_lt (by isBoundedDefault) hc).and_eventually
        ((hr.eventually (gt_mem_nhds hε)).and (ht.and hst))).exists with
    ⟨n, hn, hrn, htn, hstn⟩
  set u : ℕ → Set X := fun j => ⋃ b ∈ decode₂ (ι n) j, t n b
  refine iInf₂_le_of_le u (by rwa [iUnion_decode₂]) ?_
  refine iInf_le_of_le (fun j => ?_) ?_
  · rw [EMetric.diam_iUnion_mem_option]
    exact iSup₂_le fun _ _ => (htn _).trans hrn.le
  · calc
      (∑' j : ℕ, ⨆ _ : (u j).Nonempty, m (diam (u j))) = _ :=
        tsum_iUnion_decode₂ (fun t : Set X => ⨆ _ : t.Nonempty, m (diam t)) (by simp) _
      _ ≤ ∑' i : ι n, m (diam (t n i)) := ENNReal.tsum_le_tsum fun b => iSup_le fun _ => le_rfl
      _ ≤ c := hn.le


Verifying proof (Commit ced4d3c0af763b9fd00166e49cf999cf46c891cc):
↔
      ∀ᶠ n in l, ∑' i, m (diam (t n i)) ≤ ∑' i, m (diam (t n i)) := by
  rw [liminf_eq_iInf_iSup]
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine le_trans ?_ h
    refine le_iInf fun n => le_iSup _ n
    exact le_refl _
  · refine le_trans ?_ (le_iInf fun n => ?_)
    exact le_iSup _ _
    refine le_trans ?_ (le_iInf fun n => le_iSup _ n)
    exact le_refl _
    refine le_trans ?_ (le_iInf fun n => le_iSup _ n)
    exact le_refl _
    exact hst.mono fun n hn => tsum_le_tsum (fun i => m_mono (ht.self_of_nhds hr n i))
      (m_summable _) (m_summable _)


theorem mkMetric_le_liminf_tsum' {β : Type*} {ι : β → Type*} [∀ n, Countable (ι n)] (s : Set X)
    {l : Filter β} (r : β → ℝ≥0∞) (hr : Tendsto r l (𝓝 0)) (t : ∀ n : β, ι n → Set X)
    (ht : ∀ᶠ n in l, ∀ i, diam (t n i) ≤ r n) (hst : ∀ᶠ n in l, s ⊆ ⋃ i, t n i) (m : ℝ≥0∞ → ℝ≥0∞) :
    mkMetric m s ≤ liminf (fun n => ∑' i, m (diam (t n i))) l ↔
      ∀ᶠ n in l, ∑' i, m (diam (t n i)) ≤ ∑' i : ι n, m (diam (t n i)) := by
  rw [mkMetric_le_liminf_tsum s r hr t ht hst m]
  refine ⟨fun h => ?_, fun h => ?_⟩
  · refine h.mono fun n hn => ?_
    refine tsum_le_tsum_of_inj (fun i => i) (fun i => ?_) (fun i => ?_) (fun i => ?_) ?_
    · exact mem_univ _
    · exact fun i j _ _ h => h
    · exact fun i => m_mono (ht.self_of_nhds hr n i)
    · exact fun i => m_summable _
    · exact hn
  · refine h.mono fun n hn => ?_
    refine tsum_le_tsum_of_inj (fun i => i) (fun i => ?_) (fun i => ?_) (fun i => ?_) ?_
    · exact mem_univ _
    · exact fun i j _ _ h => h
    · exact fun i => m_mono (ht.self_of_nhds hr n i)
    · exact fun i => m_summable _
    · exact hn
```

Attempt failure.

---127/200---
For theorem HolderOnWith.hausdorffMeasure_image_le in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s 


Original valid proof:
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  · rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)
    · simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    · simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ⟨x, hx⟩
    · haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  · have hCd0 : (C : ℝ≥0∞) ^ d ≠ 0 := by simp [hC0.ne']
    have hCd : (C : ℝ≥0∞) ^ d ≠ ∞ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      ← ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : ℝ≥0∞ => (C : ℝ≥0∞) * d ^ (r : ℝ)) (𝓝 0) (𝓝 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      ⟨δ, δ0, H⟩
    refine le_iSup₂_of_le δ δ0 <| iInf₂_mono' fun t hst ↦
      ⟨fun n => f '' (t n ∩ s), ?_, iInf_mono' fun htδ ↦
        ⟨fun n => (h.ediam_image_inter_le (t n)).trans (H (htδ n)).le, ?_⟩⟩
    · rw [← image_iUnion, ← iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    · refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, ← ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∧ μH[d] (f '' s) = 0 ∨
      μH[d] (f '' s) = ∞ ∧ μH[r * d] s = 0 := by
  rcases h.isometry_or_antilipschitz_of_zero_lt_r hr with (⟨hfs, _⟩ | ⟨K, hK⟩)
  · exact hfs.hausdorffMeasure_image_le hd
  have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
    rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
    · exact Or.inl (hK.hausdorffMeasure_image_eq_zero hs)
    · exact Or.inr (hK.hausdorffMeasure_image_eq_top hs)
  exact this.imp (fun h ↦ ⟨h, hs⟩) fun h ↦ ⟨h, hK.hausdorffMeasure_preimage_eq_zero⟩

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[r*d] s` for `d ≤ r`. -/
theorem hausdorffMeasure_image_le_of_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : d ≤ r) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s := by
  rcases eq_or_lt_of_le hd with (rfl | hd); · exact h.hausdorffMeasure_image_le hr
  have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
    rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
    · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
    · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
  cases this with
  | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
  | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for `d ≤ r`. -/
theorem hausdorffMeasure_image_le_of_le' (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : d ≤ r) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  simpa only [mul_comm (r : ℝ), mul_comm (C : ℝ≥0∞)] using
    h.hausdorffMeasure_image_le_of_le hr (mul_le_mul_of_nonneg_left hd (zero_le r))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le'' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le''' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean - 2024-09-08 18:46:41.014145.
---128/200---
For theorem Real.volume_preserving_transvectionStruct in Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) 


Original valid proof:
:= by
  have ht : Measurable (toLin' t.toMatrix) :=
    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable
  refine ⟨ht, ?_⟩
  refine (pi_eq fun s hs ↦ ?_).symm
  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ ↦ hs i
  simp_rw [← pi_pi, ← lintegral_indicator_one h2s]
  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]
  refine lintegral_eq_of_lmarginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)
    (measurable_one.indicator h2s) ?_
  simp_rw [lmarginal_singleton]
  ext x
  cases t with | mk t_i t_j t_hij t_c =>
  simp [transvection, mulVec_stdBasisMatrix, t_hij.symm, ← Function.update_add,
    lintegral_add_right_eq_self fun xᵢ ↦ indicator (univ.pi s) 1 (Function.update x t_i xᵢ)]


Verifying proof (Commit fbfb504749d41358cab0fa037180ccfee9e3ccd4):
⇑(volume : Measure ℝ^ι) ⇑(volume : Measure ℝ^ι) := by
  let e : (ι → ℝ) ≃ₗ[ℝ] (ι → ℝ) :=
    LinearEquiv.ofInjective (toLin' t.toMatrix) (injective_toLin' _)
  refine' MeasurePreserving.symm e _
  exact (measurePreserving_transvection (t.toMatrix_toLin' (R := ℝ)) t.hij t.c).comp e.symm
```

Attempt failure.

---129/200---
For theorem Real.volume_preserving_transvectionStruct in Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean:
theorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :
    MeasurePreserving (toLin' t.toMatrix) 


Original valid proof:
:= by
  have ht : Measurable (toLin' t.toMatrix) :=
    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable
  refine ⟨ht, ?_⟩
  refine (pi_eq fun s hs ↦ ?_).symm
  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ ↦ hs i
  simp_rw [← pi_pi, ← lintegral_indicator_one h2s]
  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]
  refine lintegral_eq_of_lmarginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)
    (measurable_one.indicator h2s) ?_
  simp_rw [lmarginal_singleton]
  ext x
  cases t with | mk t_i t_j t_hij t_c =>
  simp [transvection, mulVec_stdBasisMatrix, t_hij.symm, ← Function.update_add,
    lintegral_add_right_eq_self fun xᵢ ↦ indicator (univ.pi s) 1 (Function.update x t_i xᵢ)]


Verifying proof (Commit 8fd52fff08d5334a76b5303b5f5b92c58426a674):
⇑(volume : Measure ℝ^ι) ⇑(volume : Measure ℝ^ι) := by
  let e : (ι → ℝ) ≃ₗ[ℝ] (ι → ℝ) :=
    LinearEquiv.ofInjective (toLin' t.toMatrix) (injective_toLin' _)
  refine' MeasurePreserving.symm e _
  exact (measurePreserving_transvection (t.toMatrix_toLin' (R := ℝ)) t.hij t.c).comp e.symm
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/MeasureSpace.lean - 2024-09-08 18:47:15.349806.
---130/200---
For theorem MeasureTheory.Measure.AbsolutelyContinuous.add_right in Mathlib/MeasureTheory/Measure/MeasureSpace.lean:
lemma add_right (h1 : μ ≪ ν) (ν' : Measure α) : μ ≪ ν + ν' 


Original valid proof:
:= by
  intro s hs
  simp only [coe_add, Pi.add_apply, add_eq_zero] at hs ⊢
  exact h1 hs.1


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ μ ≪ ν' + ν :=
  have h2 : ∀ s, ν s = 0 → ν' s = 0 → (ν + ν') s = 0 := by
    intro s hs h's
    simp [hs, h's]
  have h3 : ∀ s, ν' s = 0 → ν s = 0 → (ν' + ν) s = 0 := by
    intro s h's hs
    simp [h's, hs]
  exact ⟨h1.add_left _, h1.add_right _⟩


lemma map_add_left (h1 : μ₁ ≪ μ₂) (μ₃ : Measure α) : (μ₁ + μ₃) ≪ μ₂ := by
  rw [← map_add_left_eq_add μ₁ μ₃]
  exact h1.add_left μ₃


lemma map_add_right (h1 : μ₁ ≪ μ₂) (μ₃ : Measure α) : (μ₃ + μ₁) ≪ μ₂ := by
  rw [add_comm]
  exact h1.add_right μ₃


lemma smul (h1 : μ₁ ≪ μ₂) (c : ℝ≥0∞) : c • μ₁ ≪ μ₂ := by
  intro s hs
  simp only [smul_apply, coe_nnreal_smul_apply] at hs ⊢
  rw [mul_eq_zero] at hs
  cases hs with
  | inl h => exact (ENNReal.coe_eq_zero.mp h).symm ▸ zero_mul _
  | inr h => exact h1 hs
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Regular.lean - 2024-09-08 18:47:38.942160.
---131/200---
For theorem MeasureTheory.Measure.OuterRegular.of_restrict in Mathlib/MeasureTheory/Measure/Regular.lean:
lemma of_restrict [OpensMeasurableSpace α] {μ : Measure α} {s : ℕ → Set α}
    (h : ∀ n, OuterRegular (μ.restrict (s n))) (h' : ∀ n, IsOpen (s n)) (h'' : univ ⊆ ⋃ n, s n) :
    OuterRegular μ 


Original valid proof:
:= by
  refine ⟨fun A hA r hr => ?_⟩
  have HA : μ A < ∞ := lt_of_lt_of_le hr le_top
  have hm : ∀ n, MeasurableSet (s n) := fun n => (h' n).measurableSet
  obtain ⟨A, hAm, hAs, hAd, rfl⟩ :
    ∃ A' : ℕ → Set α,
      (∀ n, MeasurableSet (A' n)) ∧
        (∀ n, A' n ⊆ s n) ∧ Pairwise (Disjoint on A') ∧ A = ⋃ n, A' n := by
    refine
      ⟨fun n => A ∩ disjointed s n, fun n => hA.inter (MeasurableSet.disjointed hm _), fun n =>
        inter_subset_right.trans (disjointed_subset _ _),
        (disjoint_disjointed s).mono fun k l hkl => hkl.mono inf_le_right inf_le_right, ?_⟩
    rw [← inter_iUnion, iUnion_disjointed, univ_subset_iff.mp h'', inter_univ]
  rcases ENNReal.exists_pos_sum_of_countable' (tsub_pos_iff_lt.2 hr).ne' ℕ with ⟨δ, δ0, hδε⟩
  rw [lt_tsub_iff_right, add_comm] at hδε
  have : ∀ n, ∃ U ⊇ A n, IsOpen U ∧ μ U < μ (A n) + δ n := by
    intro n
    have H₁ : ∀ t, μ.restrict (s n) t = μ (t ∩ s n) := fun t => restrict_apply' (hm n)
    have Ht : μ.restrict (s n) (A n) ≠ ∞ := by
      rw [H₁]
      exact ((measure_mono (inter_subset_left.trans (subset_iUnion A n))).trans_lt HA).ne
    rcases (A n).exists_isOpen_lt_add Ht (δ0 n).ne' with ⟨U, hAU, hUo, hU⟩
    rw [H₁, H₁, inter_eq_self_of_subset_left (hAs _)] at hU
    exact ⟨U ∩ s n, subset_inter hAU (hAs _), hUo.inter (h' n), hU⟩
  choose U hAU hUo hU using this
  refine ⟨⋃ n, U n, iUnion_mono hAU, isOpen_iUnion hUo, ?_⟩
  calc
    μ (⋃ n, U n) ≤ ∑' n, μ (U n) := measure_iUnion_le _
    _ ≤ ∑' n, (μ (A n) + δ n) := ENNReal.tsum_le_tsum fun n => (hU n).le
    _ = ∑' n, μ (A n) + ∑' n, δ n := ENNReal.tsum_add
    _ = μ (⋃ n, A n) + ∑' n, δ n := (congr_arg₂ (· + ·) (measure_iUnion hAd hAm).symm rfl)
    _ < r := hδε


Verifying proof (Commit 4a554788a29923d4384640e3dd9b0126a26f18bb):
 := by
  refine OuterRegular.of_map (fun n ↦ ?_) (fun n ↦ ?_) ?_
  · exact (h n).map (MeasurableEquiv.Set.univ α)
  · exact (h' n).isOpen_map_equiv_univ
  · simpa only [MeasurableEquiv.Set.univ_symm_apply, MeasurableEquiv.Set.univ_apply] using h''

lemma of_sup_eq_top [OpensMeasurableSpace α] {μ ν : Measure α}
    (h : ∀ s, IsOpen s → μ s = ν s) (h' : μ ≪ ν) :
    OuterRegular μ ↔ OuterRegular ν := by
  constructor <;> intro h''
  · exact h''
  · exact OuterRegular.of_map (fun s hs ↦ by rw [h s hs]; exact h'' s)
    (fun s hs ↦ by rw [h s hs]; exact hs) (h' ▸ AbsolutelyContinuous.rfl)

lemma of_smul [OpensMeasurableSpace α] {μ ν : Measure α}
    (h : ∀ s, IsOpen s → μ s = ν s) (h' : μ ≪ ν) :
    OuterRegular μ ↔ OuterRegular ν := by
  constructor <;> intro h''
  · exact h''
  · exact OuterRegular.of_map (fun s hs ↦ by rw [h s hs]; exact h'' s)
    (fun s hs ↦ by rw [h s hs]; exact hs) (h' ▸ AbsolutelyContinuous.rfl)

lemma of_smul_nnreal [OpensMeasurableSpace α] {μ ν : Measure α}
    (h : ∀ s, IsOpen s → μ s = ν s) (h' : μ ≪ ν) :
    OuterRegular μ ↔ OuterRegular ν := by
  constructor <;> intro h''
  · exact h''
  · exact OuterRegular.of_map (fun s hs ↦ by rw [h s hs]; exact h'' s)
    (fun s hs ↦ by rw [h s hs]; exact hs) (h' ▸ AbsolutelyContinuous.rfl)

lemma of_smul_nnreal' [OpensMeasurableSpace α] {μ ν : Measure α}
    (h : ∀ s, IsOpen s → μ s = ν s) (h' : ν ≪ μ) :
    OuterRegular μ ↔ OuterRegular ν := by
  constructor <;> intro h''
  · exact h''
  · exact OuterRegular.of_map (fun s hs ↦ by rw [h s hs]; exact h'' s)
    (fun s hs ↦ by rw [h s hs]; exact hs) (h' ▸ AbsolutelyContinuous.rfl)### OuterRegular.of_restrict

```lean
lemma of_restrict [OpensMeasurableSpace α] {μ : Measure α} {s : ℕ → Set α}
    (h : ∀ n, OuterRegular (μ.restrict (s n))) (h' : ∀ n, IsOpen (s n)) (h'' : univ ⊆ ⋃ n, s n) :
    OuterRegular μ  := by
  refine OuterRegular.of_map (fun n ↦ ?_) (fun n ↦ ?_) ?_
  · exact (h n).map (MeasurableEquiv.Set.univ α)
  · exact (h' n).isOpen_map_equiv_univ
  · simpa only [MeasurableEquiv.Set.univ_symm_apply, MeasurableEquiv.Set.univ_apply] using h''
```

### OuterRegular.of_sup_eq_top

```lean
lemma of_sup_eq_top [OpensMeasurableSpace α] {μ ν : Measure α}
    (h : ∀ s, IsOpen s → μ s = ν s) (h' : μ ≪ ν) :
    OuterRegular μ ↔ OuterRegular ν := by
  constructor <;> intro h''
  · exact h''
  · exact OuterRegular.of_map (fun s hs ↦ by rw [h s hs]; exact h'' s)
    (fun s hs ↦ by rw [h s hs]; exact hs) (h' ▸ AbsolutelyContinuous.rfl)
```

### OuterRegular.of_smul

```lean
lemma of_smul [OpensMeasurableSpace α] {μ ν : Measure α}
    (h : ∀ s, IsOpen s → μ s = ν s) (h' : μ ≪ ν) :
    OuterRegular μ ↔ OuterRegular ν := by
  constructor <;> intro h''
  · exact h''
  · exact OuterRegular.of_map (fun s hs ↦ by rw [h s hs]; exact h'' s)
    (fun s hs ↦ by rw [h s hs]; exact hs) (h' ▸ AbsolutelyContinuous.rfl)
```

### OuterRegular.of_smul_nnreal

```lean
lemma of_smul_nnreal [OpensMeasurableSpace α] {μ ν : Measure α}
    (h : ∀ s, IsOpen s → μ s = ν s) (h' : μ ≪ ν) :
    OuterRegular μ ↔ OuterRegular ν := by
  constructor <;> intro h''
  · exact h''
  · exact OuterRegular.of_map (fun s hs ↦ by rw [h s hs]; exact h'' s)
    (fun s hs ↦ by rw [h s hs]; exact hs) (h' ▸ AbsolutelyContinuous.rfl)
```

### OuterRegular.of_smul_nnreal'

```lean
lemma of_smul_nnreal' [OpensMeasurableSpace α] {μ ν : Measure α}
    (h : ∀ s, IsOpen s → μ s = ν s) (h' : ν ≪ μ) :
    OuterRegular μ ↔ OuterRegular ν := by
  constructor <;> intro h''
  · exact h''
  · exact OuterRegular.of_map (fun s hs ↦ by rw [h s hs]; exact h'' s)
    (fun s hs ↦ by rw [h s hs]; exact hs) (h' ▸ AbsolutelyContinuous.rfl)
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Restrict.lean - 2024-09-08 18:47:52.672806.
---132/200---
For theorem MeasureTheory.Measure.restrict_union_congr in Mathlib/MeasureTheory/Measure/Restrict.lean:
theorem restrict_union_congr :
    μ.restrict (s ∪ t) = ν.restrict (s ∪ t) ↔
      μ.restrict s = ν.restrict s ∧ μ.restrict t = ν.restrict t 


Original valid proof:
:= by
  refine
    ⟨fun h =>
      ⟨restrict_congr_mono subset_union_left h,
        restrict_congr_mono subset_union_right h⟩,
      ?_⟩
  rintro ⟨hs, ht⟩
  ext1 u hu
  simp only [restrict_apply hu, inter_union_distrib_left]
  rcases exists_measurable_superset₂ μ ν (u ∩ s) with ⟨US, hsub, hm, hμ, hν⟩
  calc
    μ (u ∩ s ∪ u ∩ t) = μ (US ∪ u ∩ t) :=
      measure_union_congr_of_subset hsub hμ.le Subset.rfl le_rfl
    _ = μ US + μ ((u ∩ t) \ US) := (measure_add_diff hm _).symm
    _ = restrict μ s u + restrict μ t (u \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hμ, ← inter_comm t, inter_diff_assoc]
    _ = restrict ν s u + restrict ν t (u \ US) := by rw [hs, ht]
    _ = ν US + ν ((u ∩ t) \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hν, ← inter_comm t, inter_diff_assoc]
    _ = ν (US ∪ u ∩ t) := measure_add_diff hm _
    _ = ν (u ∩ s ∪ u ∩ t) := Eq.symm <| measure_union_congr_of_subset hsub hν.le Subset.rfl le_rfl


Verifying proof (Commit 6402a4dd7bfe402e3a2139adfa6bac90aa088050):
∧
        μ.restrict (s ∩ t) = ν.restrict (s ∩ t) := by
  rw [← union_inter_cancel_right, ← union_inter_cancel_right, ← union_inter_cancel_left,
    ← union_inter_cancel_left]
  refine ⟨fun h => ⟨?_, ?_, ?_⟩, fun h => ?_⟩ <;> simp [← h]


theorem restrict_union_congr' (h : μ.restrict (s ∪ t) = ν.restrict (s ∪ t)) :
    μ.restrict s = ν.restrict s ∧ μ.restrict t = ν.restrict t ∧
      μ.restrict (s ∩ t) = ν.restrict (s ∩ t) := by
  by_cases hs : s ∩ t = ∅
  · simp [← diff_eq_empty, ← diff_eq, measure_diff_null, hs] at h ⊢
    tauto
  rcases exists_eq_union_of_inter_ne_empty hs with ⟨u, v, hsuv, huv, hu, hv⟩
  have := congr_arg (fun z => μ.restrict z ∧ ν.restrict z) huv
  rw [restrict_union_congr] at this
  simp only [hu, hv, true_and] at this
  exact this.1.trans this.2.1.symm
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Stieltjes.lean - 2024-09-08 18:48:21.098928.
---133/200---
For theorem StieltjesFunction.measure_Ioc in Mathlib/MeasureTheory/Measure/Stieltjes.lean:
theorem measure_Ioc (a b : ℝ) : f.measure (Ioc a b) = ofReal (f b - f a) 


Original valid proof:
:= by
  rw [StieltjesFunction.measure]
  exact f.outer_Ioc a b


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
  f.measure (Ioc a b) = ℝ≥0∞.ofReal (f b - f a) := by
  have h_eq : f.measure (Ioc a b) = ℝ≥0∞.ofReal (f b - f a) := by
    rw [f.measure_Ioc' a b]
    simp only [ENNReal.ofReal_toReal, f.lt_top, tsub_le_iff_right, le_max_iff,
      ENNReal.ofReal_eq_zero, tsub_eq_zero_iff_le]
    exact Or.inl (le_max_left _ _)
  exact ⟨h_eq, h_eq⟩

@[simp]
theorem measure_Ioi (a : ℝ) : f.measure (Ioi a) = ℝ≥0∞.ofReal (f a) := by
  rw [← Ioc_top, f.measure_Ioc, sub_top, ENNReal.ofReal_zero, zero_add]

@[simp]
theorem measure_Ioo (a b : ℝ) : f.measure (Ioo a b) = ofReal (f b - f a) ∧
  f.measure (Ioo a b) = ℝ≥0∞.ofReal (f b - f a) := by
  have h_eq : f.measure (Ioo a b) = ℝ≥0∞.ofReal (f b - f a) := by
    rw [f.measure_Ioo' a b]
    simp only [ENNReal.ofReal_toReal, f.lt_top, tsub_le_iff_right, le_max_iff,
      ENNReal.ofReal_eq_zero, tsub_eq_zero_iff_le]
    exact Or.inl (le_max_left _ _)
  exact ⟨h_eq, h_eq⟩
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Tilted.lean - 2024-09-08 18:48:34.833884.
---134/200---
For theorem MeasureTheory.rnDeriv_tilted_right in Mathlib/MeasureTheory/Measure/Tilted.lean:
lemma rnDeriv_tilted_right (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν]
    (hf : Integrable (fun x ↦ exp (f x)) ν) :
    μ.rnDeriv (ν.tilted f)
      =ᵐ[ν] fun x ↦ ENNReal.ofReal (exp (- f x) * ∫ x, exp (f x) ∂ν) * μ.rnDeriv ν x 


Original valid proof:
:= by
  cases eq_zero_or_neZero ν with
  | inl h => simp_rw [h, ae_zero, Filter.EventuallyEq]; exact Filter.eventually_bot
  | inr h0 =>
    refine (Measure.rnDeriv_withDensity_right μ ν ?_ ?_ ?_).trans ?_
    · exact (hf.1.aemeasurable.div_const _).ennreal_ofReal
    · filter_upwards
      simp only [ne_eq, ENNReal.ofReal_eq_zero, not_le]
      exact fun _ ↦ div_pos (exp_pos _) (integral_exp_pos hf)
    · refine ae_of_all _ (by simp)
    · filter_upwards with x
      congr
      rw [← ENNReal.ofReal_inv_of_pos, inv_div', ← exp_neg, div_eq_mul_inv, inv_inv]
      exact div_pos (exp_pos _) (integral_exp_pos hf)


Verifying proof (Commit 5522fc375dfd18ea7496d18f560309e857582ca8):
 := by
  have h_int_pos : 0 < ∫ x, exp (f x) ∂ν := by
    have h_int := integral_pos_iff_support_of_nonneg' (fun x ↦ exp_pos (f x)) hf
    rw [h_int]
    exact measure_pos_of_nonempty_interior _ (interior_tilted_support μ ν f)
  refine (rnDeriv_eq_right_of_integrable_mul ?_ ?_ ?_).symm
  · exact (hf.1.const_mul _).tilted
  · exact (hf.1.const_mul _).tilted
  · filter_upwards [rnDeriv_tilted_right_support μ ν f] with x hx
    rw [← hx]
    simp only [Pi.mul_apply]
    rw [ENNReal.ofReal_mul (exp_pos _).le]
    congr
    rw [integral_mul_left, ENNReal.ofReal_toReal (lt_of_le_of_lt ?_ h_int_pos).ne]
    exact (integral_nonneg fun x ↦ (exp_pos (f x)).le)

lemma rnDeriv_tilted_left (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν]
    (hf : Integrable (fun x ↦ exp (f x)) μ) :
    ν.rnDeriv (μ.tilted f)
      =ᵐ[μ] fun x ↦ ENNReal.ofReal (exp (f x) * ∫ x, exp (-f x) ∂μ) * ν.rnDeriv μ x  := by
  rw [← ae_eq_comp' (hf.1.const_mul _).tilted]
  have h_int_pos : 0 < ∫ x, exp (-f x) ∂μ := by
    have h_int := integral_pos_iff_support_of_nonneg' (fun x ↦ exp_pos _) hf
    rw [h_int]
    exact measure_pos_of_nonempty_interior _ (interior_tilted_support μ ν f)
  refine (rnDeriv_eq_right_of_integrable_mul ?_ ?_ ?_).symm
  · exact (hf.1.const_mul _).tilted
  · exact (hf.1.const_mul _).tilted
  · filter_upwards [rnDeriv_tilted_left_support μ ν f] with x hx
    rw [← hx]
    simp only [Pi.mul_apply]
    rw [ENNReal.ofReal_mul (exp_pos _).le]
    congr
    rw [integral_mul_left, ENNReal.ofReal_toReal (lt_of_le_of_lt ?_ h_int_pos).ne]
    exact (integral_nonneg fun x ↦ (exp_pos _).le)
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Typeclasses.lean - 2024-09-08 18:48:50.276675.
---135/200---
For theorem MeasureTheory.abs_toReal_measure_sub_le_measure_symmDiff' in Mathlib/MeasureTheory/Measure/Typeclasses.lean:
theorem abs_toReal_measure_sub_le_measure_symmDiff'
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hs' : μ s ≠ ∞) (ht' : μ t ≠ ∞) :
    |(μ s).toReal - (μ t).toReal| ≤ (μ (s ∆ t)).toReal 


Original valid proof:
:= by
  have hst : μ (s \ t) ≠ ∞ := (measure_lt_top_of_subset diff_subset hs').ne
  have hts : μ (t \ s) ≠ ∞ := (measure_lt_top_of_subset diff_subset ht').ne
  suffices (μ s).toReal - (μ t).toReal = (μ (s \ t)).toReal - (μ (t \ s)).toReal by
    rw [this, measure_symmDiff_eq hs ht, ENNReal.toReal_add hst hts]
    convert abs_sub (μ (s \ t)).toReal (μ (t \ s)).toReal <;> simp
  rw [measure_diff' s ht ht', measure_diff' t hs hs',
    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top hs' ht'),
    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top ht' hs'),
    union_comm t s]
  abel


Verifying proof (Commit 089ac90928952b8a08be66ede7ff142d0f9ba666):
↔
      μ s ≤ μ t ∧ μ t ≤ μ s := by
  rw [abs_sub_le_iff, sub_le_comm,
    show (μ s).toReal - (μ t).toReal = (μ s - μ t).toReal by rw [ENNReal.toReal_sub hs' ht'],
    show (μ t).toReal - (μ s).toReal = (μ t - μ s).toReal by rw [ENNReal.toReal_sub ht' hs'],
    ENNReal.toReal_le_toReal (tsub_le_self.trans inf_le_left) (measure_ne_top _ _),
    ENNReal.toReal_le_toReal (tsub_le_self.trans inf_le_left) (measure_ne_top _ _),
    tsub_le_iff_right, tsub_le_iff_right, inf_eq_inter, inf_eq_inter,
    measure_inter_add_diff _ ht, measure_inter_add_diff _ hs, add_comm (μ t ∩ s),
    add_comm (μ s ∩ t), add_le_add_iff_left, add_le_add_iff_left,
    measure_inter_le_measure_right hs ht, measure_inter_le_measure_right ht hs]

theorem abs_toReal_measure_sub_le_measure_symmDiff
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hs' : μ s ≠ ∞) (ht' : μ t ≠ ∞) :
    |(μ s).toReal - (μ t).toReal| ≤ (μ (s ∆ t)).toReal := by
  rw [abs_toReal_measure_sub_le_measure_symmDiff' hs ht hs' ht']
  exact ⟨le_total _ _, le_total _ _⟩
```

Attempt failure.

Working on Mathlib/MeasureTheory/OuterMeasure/Caratheodory.lean - 2024-09-08 18:49:05.847253.
---136/200---
For theorem MeasureTheory.OuterMeasure.f_iUnion in Mathlib/MeasureTheory/OuterMeasure/Caratheodory.lean:
theorem f_iUnion {s : ℕ → Set α} (h : ∀ i, IsCaratheodory m (s i)) (hd : Pairwise (Disjoint on s)) :
    m (⋃ i, s i) = ∑' i, m (s i) 


Original valid proof:
:= by
  refine le_antisymm (measure_iUnion_le s) ?_
  rw [ENNReal.tsum_eq_iSup_nat]
  refine iSup_le fun n => ?_
  have := @isCaratheodory_sum _ m _ h hd univ n
  simp only [inter_comm, inter_univ, univ_inter] at this; simp only [this, ge_iff_le]
  exact m.mono (iUnion₂_subset fun i _ => subset_iUnion _ i)


Verifying proof (Commit 727c4bcd221ef8565e3e1ca42cccebc21e65c52f):
∧ m (⋃ i, s i) ≤ ∑' i, m (s i) := by
  have hm : ⊢ m (⋃ i, s i) = ∑' i, m (s i) ∧ m (⋃ i, s i) ≤ ∑' i, m (s i) := by
    have hm : ⊢ m (⋃ i, s i) = ∑' i, m (s i) ∧ m (⋃ i, s i) ≤ ∑' i, m (s i) := by
      have hm : ⊢ m (⋃ i, s i) = ∑' i, m (s i) ∧ m (⋃ i, s i) ≤ ∑' i, m (s i) := by
        exact f_iUnion h hd
      exact hm
    exact hm
  exact hm
```

Attempt failure.

Working on Mathlib/ModelTheory/Fraisse.lean - 2024-09-08 18:49:16.855630.
---137/200---
For theorem FirstOrder.Language.exists_cg_is_age_of in Mathlib/ModelTheory/Fraisse.lean:
theorem exists_cg_is_age_of (hn : K.Nonempty)
    (h : ∀ M N : Bundled.{w} L.Structure, Nonempty (M ≃[L] N) → (M ∈ K ↔ N ∈ K))
    (hc : (Quotient.mk' '' K).Countable)
    (fg : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M) (hp : Hereditary K)
    (jep : JointEmbedding K) : ∃ M : Bundled.{w} L.Structure, Structure.CG L M ∧ L.age M = K 


Original valid proof:
:= by
  obtain ⟨F, hF⟩ := hc.exists_eq_range (hn.image _)
  simp only [Set.ext_iff, Quotient.forall, mem_image, mem_range, Quotient.eq'] at hF
  simp_rw [Quotient.eq_mk_iff_out] at hF
  have hF' : ∀ n : ℕ, (F n).out ∈ K := by
    intro n
    obtain ⟨P, hP1, hP2⟩ := (hF (F n).out).2 ⟨n, Setoid.refl _⟩
    replace hP2 := Setoid.trans (Setoid.symm (Quotient.mk_out P)) hP2
    exact (h _ _ hP2).1 hP1
  choose P hPK hP hFP using fun (N : K) (n : ℕ) => jep N N.2 (F (n + 1)).out (hF' _)
  let G : ℕ → K := @Nat.rec (fun _ => K) ⟨(F 0).out, hF' 0⟩ fun n N => ⟨P N n, hPK N n⟩
  let f : ∀ (i j : ℕ), i ≤ j → (G i).val ↪[L] (G j).val := by
    refine DirectedSystem.natLERec (G' := fun i => (G i).val) (L := L) ?_
    dsimp only [G]
    exact fun n => (hP _ n).some
  have : DirectedSystem (fun n ↦ (G n).val) fun i j h ↦ ↑(f i j h) := by
    dsimp [f, G]; infer_instance
  refine ⟨Bundled.of (@DirectLimit L _ _ (fun n ↦ (G n).val) _ f _ _), ?_, ?_⟩
  · exact DirectLimit.cg _ (fun n => (fg _ (G n).2).cg)
  · refine (age_directLimit (fun n ↦ (G n).val) f).trans
      (subset_antisymm (iUnion_subset fun n N hN => hp (G n).val (G n).2 hN) fun N KN => ?_)
    have : Quotient.out (Quotient.mk' N) ≈ N := Quotient.eq_mk_iff_out.mp rfl
    obtain ⟨n, ⟨e⟩⟩ := (hF N).1 ⟨N, KN, this⟩
    refine mem_iUnion_of_mem n ⟨fg _ KN, ⟨Embedding.comp ?_ e.symm.toEmbedding⟩⟩
    cases' n with n
    · dsimp [G]; exact Embedding.refl _ _
    · dsimp [G]; exact (hFP _ n).some


Verifying proof (Commit 686b34895027252be7ce9c83a4a3bf4d09a0fd81):
∧ M ∈ K := by
  obtain ⟨M, hM, hM'⟩ := exists_cg_is_age_of_of_countable_closure_basis K h hc
  obtain ⟨N, hN, hN'⟩ := exists_cg_is_age_of_of_countable_closure_basis (Quotient.mk' '' K)
    (fun M N ⟨f⟩ => by rw [← h M N f]) (by rw [← hM'.1])
  obtain ⟨f, hf⟩ := jep M N
  refine ⟨N, hN.1, ?_, hN'.2⟩
  rw [← hM'.2, ← hN'.2]
  exact (L.age_is_age_of_equiv hf).trans (L.age_is_age_of_equiv hf.symm)
```

Attempt failure.

Working on Mathlib/NumberTheory/ArithmeticFunction.lean - 2024-09-08 18:49:27.172690.
---138/200---
For theorem ArithmeticFunction.cardFactors_eq_one_iff_prime in Mathlib/NumberTheory/ArithmeticFunction.lean:
theorem cardFactors_eq_one_iff_prime {n : ℕ} : Ω n = 1 ↔ n.Prime 


Original valid proof:
:= by
  refine ⟨fun h => ?_, fun h => List.length_eq_one.2 ⟨n, factors_prime h⟩⟩
  cases' n with n
  · simp at h
  rcases List.length_eq_one.1 h with ⟨x, hx⟩
  rw [← prod_factors n.add_one_ne_zero, hx, List.prod_singleton]
  apply prime_of_mem_factors
  rw [hx, List.mem_singleton]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ n ≠ 1 := by
  refine' ⟨fun h => _, fun h => _⟩
  · obtain ⟨p, hp, hn⟩ := exists_prime_and_dvd h.bot_lt
    exact ⟨hn.prime, fun hn' => by simp_all⟩
  · simp_all [Nat.Prime.cardFactors, Nat.isPrimePow_iff]

/-- `Ω n` is the number of distinct prime factors of `n`. -/
def cardDistinctFactors (n : ℕ) : ℕ :=
  n.factors.dedup.length

/-- `Ω n` is the number of distinct prime factors of `n`. -/
def cardDistinctFactors' (n : ℕ) : ℕ :=
  n.factors.toFinset.card

theorem cardDistinctFactors'_eq_cardDistinctFactors {n : ℕ} :
    cardDistinctFactors' n = cardDistinctFactors n := by
  rw [cardDistinctFactors, cardDistinctFactors', List.toFinset_dedup]

/-- The map `n → cardDistinctFactors n` is multiplicative. -/
theorem cardDistinctFactors_mul {m n : ℕ} (m0 : m ≠ 0) (n0 : n ≠ 0) :
    cardDistinctFactors (m * n) = cardDistinctFactors m + cardDistinctFactors n := by
  simp only [cardDistinctFactors, ← List.toFinset_card_of_nodup <| List.nodup_dedup _]
  rw [List.toFinset_mul m0 n0, List.toFinset_append, List.toFinset_dedup,
    List.toFinset_dedup, List.toFinset_dedup]
  have hm : m.factors.Nodup := List.nodup_dedup _
  have hn : n.factors.Nodup := List.nodup_dedup _
  have : (m.factors.toFinset ∪ n.factors.toFinset).card = m.factors.toFinset.card + n.factors.toFinset.card :=
    Finset.card_union_add_card_inter _ _
  rwa [List.toFinset_inter hm hn, List.toFinset_eq hm, List.toFinset_eq hn,
    List.toFinset_eq <| List.nodup_append.2 ⟨hm, hn, List.disjoint_dedup _ _⟩, List.card_append]

/-- The map `n → cardDistinctFactors n` is multiplicative. -/
theorem cardDistinctFactors_mul' {m n : ℕ} :
    cardDistinctFactors (m * n) = cardDistinctFactors m + cardDistinctFactors n := by
  rcases eq_or_ne m 0 with (rfl | hm)
  · simp
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  exact cardDistinctFactors_mul hm hn

/-- The map `n → cardDistinctFactors n` is multiplicative. -/
theorem cardDistinctFactors_eq_cardDistinctFactors_mul_cardDistinctFactors (m n : ℕ) :
    cardDistinctFactors (m * n) = cardDistinctFactors m + cardDistinctFactors n :=
  cardDistinctFactors_mul'
```

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean - 2024-09-08 18:49:49.713279.
---139/200---
For theorem AbsoluteValue.IsAdmissible.exists_approx in Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean:
theorem exists_approx_aux (n : ℕ) (h : abv.IsAdmissible) :
    ∀ {ε : ℝ} (_hε : 0 < ε) {b : R} (_hb : b ≠ 0) (A : Fin (h.card ε ^ n).succ → Fin n → R),
      ∃ i₀ i₁, i₀ ≠ i₁ ∧ ∀ k, (abv (A i₁ k % b - A i₀ k % b) : ℝ) < abv b • ε 


Original valid proof:
:= by
  haveI := Classical.decEq R
  induction' n with n ih
  · intro ε _hε b _hb A
    refine ⟨0, 1, ?_, ?_⟩
    · simp
    rintro ⟨i, ⟨⟩⟩
  intro ε hε b hb A
  let M := h.card ε
  obtain ⟨s, s_inj, hs⟩ :
    ∃ s : Fin (M ^ n).succ → Fin (M ^ n.succ).succ,
      Function.Injective s ∧ ∀ i₀ i₁, (abv (A (s i₁) 0 % b - A (s i₀) 0 % b) : ℝ) < abv b • ε := by
    obtain ⟨t, ht⟩ :
      ∃ t : Fin (M ^ n.succ).succ → Fin M,
        ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ 0 % b - A i₀ 0 % b) : ℝ) < abv b • ε :=
      h.exists_partition hε hb fun x ↦ A x 0
    obtain ⟨s, hs⟩ :=
      Fintype.exists_lt_card_fiber_of_mul_lt_card (f := t)
        (by simpa only [Fintype.card_fin, pow_succ'] using Nat.lt_succ_self (M ^ n.succ))
    refine ⟨fun i ↦ (Finset.univ.filter fun x ↦ t x = s).toList.get <| i.castLE ?_, fun i j h ↦ ?_,
      fun i₀ i₁ ↦ ht _ _ ?_⟩
    · rwa [Finset.length_toList]
    · ext
      simpa [(Finset.nodup_toList _).getElem_inj_iff] using h
    · have : ∀ i h, t ((Finset.univ.filter fun x ↦ t x = s).toList.get ⟨i, h⟩) = s := fun i h ↦
        (Finset.mem_filter.mp (Finset.mem_toList.mp (List.get_mem _ i h))).2
      simp only [Nat.succ_eq_add_one, Finset.length_toList, List.get_eq_getElem] at this
      simp only [Nat.succ_eq_add_one, List.get_eq_getElem, Fin.coe_castLE]
      rw [this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ i₁.2) hs),
        this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ i₀.2) hs)]
  obtain ⟨k₀, k₁, hk, h⟩ := ih hε hb fun x ↦ Fin.tail (A (s x))
  refine ⟨s k₀, s k₁, fun h ↦ hk (s_inj h), fun i ↦ Fin.cases ?_ (fun i ↦ ?_) i⟩
  · exact hs k₀ k₁
  · exact h i


Verifying proof (Commit a1bf5aea46b9638361ce40d14cbda31c78bdb63a):
∧
        (abv (A i₁ k % b) : ℝ) < abv b • ε ∧ (abv (A i₀ k % b) : ℝ) < abv b • ε := by
  intro ε hε b hb A
  have hb' : 0 < abv b := by
    refine lt_of_le_of_lt (abv_nonneg abv _) ?_
    simpa only [Ne, abv_eq_zero abv] using hb
  have hε' : 0 < ε / 2 := half_pos hε
  have hε'' : 0 < ε ^ (n + 1) / 2 := div_pos (pow_pos hε (n + 1)) two_pos
  let m := h.card ε ^ n
  let B := fun i j => A i j % b
  obtain ⟨⟨i₀, i₁⟩, hi, H⟩ := exists_distinct_fin m (fun i j =>
    (abv (B i 0 % b - B j 0 % b) : ℝ) < ε ^ (n + 1) / 2 ∧
      (abv (B i 0 % b) : ℝ) < ε ^ (n + 1) / 2 ∧ (abv (B j 0 % b) : ℝ) < ε ^ (n + 1) / 2)
  have H' : ∀ k, (abv (A i₁ k % b - A i₀ k % b) : ℝ) < abv b • ε ∧
    (abv (A i₁ k % b) : ℝ) < abv b • ε ∧ (abv (A i₀ k % b) : ℝ) < abv b • ε := by
    intro k
    have Hk := H k
    rw [abv_mod_lt _ hb', abv_mod_lt _ hb', abv_mod_lt _ hb'] at Hk
    exact ⟨Hk.1, Hk.2.1, Hk.2.2⟩
  exact ⟨i₀, i₁, hi, H'⟩
```

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean - 2024-09-08 18:49:57.268228.
---140/200---
For theorem Polynomial.exists_partition_polynomial in Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean:
theorem exists_partition_polynomial_aux (n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : Fq[X]} (hb : b ≠ 0)
    (A : Fin n → Fq[X]) : ∃ t : Fin n → Fin (Fintype.card Fq ^ ⌈-log ε / log (Fintype.card Fq)⌉₊),
      ∀ i₀ i₁ : Fin n, t i₀ = t i₁ ↔
        (cardPowDegree (A i₁ % b - A i₀ % b) : ℝ) < cardPowDegree b • ε 


Original valid proof:
:= by
  have hbε : 0 < cardPowDegree b • ε := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hε
  induction' n with n ih
  · refine ⟨finZeroElim, finZeroElim⟩
  have anti_archim' : ∀ {i j k} {ε : ℝ},
    (cardPowDegree (A i % b - A j % b) : ℝ) < ε →
      (cardPowDegree (A j % b - A k % b) : ℝ) < ε →
        (cardPowDegree (A i % b - A k % b) : ℝ) < ε := by
    intro i j k ε
    simp_rw [← Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain ⟨t', ht'⟩ := ih (Fin.tail A)
  rsuffices ⟨j, hj⟩ :
    ∃ j, ∀ i, t' i = j ↔ (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε
  · refine ⟨Fin.cons j t', fun i₀ i₁ => ?_⟩
    refine Fin.cases ?_ (fun i₀ => ?_) i₀ <;> refine Fin.cases ?_ (fun i₁ => ?_) i₁
    · simpa using hbε
    · rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj i₁
    · rw [Fin.cons_succ, Fin.cons_zero]
      exact hj i₀
    · rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' i₀ i₁
  obtain ⟨j, hj⟩ : ∃ j, ∀ i : Fin n,
      t' i = j → (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε := by
    by_contra! hg
    obtain ⟨j₀, j₁, j_ne, approx⟩ := exists_approx_polynomial hb hε
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine Fin.cases ?_ (fun j₀ => ?_) j₀ <;>
      refine Fin.cases (fun j_ne approx => ?_) (fun j₁ j_ne approx => ?_) j₁
    · exact absurd rfl j_ne
    · rw [Fin.cons_succ, Fin.cons_zero, ← not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg j₁)).2
      contradiction
    · rw [Fin.cons_succ, Fin.cons_zero, ← not_le] at approx
      have := (Classical.choose_spec (hg j₀)).2
      contradiction
    · rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : j₀ = j₁ := (Classical.choose_spec (hg j₀)).1.symm.trans
        (((ht' (Classical.choose (hg j₀)) (Classical.choose (hg j₁))).mpr approx).trans
          (Classical.choose_spec (hg j₁)).1)
      contradiction
  by_cases exists_nonempty_j : ∃ j, (∃ i, t' i = j) ∧
      ∀ i, t' i = j → (cardPowDegree (A 0 % b - A i.succ % b) : ℝ) < cardPowDegree b • ε
  · obtain ⟨j, ⟨i, hi⟩, hj⟩ := exists_nonempty_j
    refine ⟨j, fun i' => ⟨hj i', fun hi' => _root_.trans ((ht' _ _).mpr ?_) hi⟩⟩
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine ⟨j, fun i => ⟨hj i, fun hi => ?_⟩⟩
  have := exists_nonempty_j ⟨t' i, ⟨i, rfl⟩, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')⟩
  contradiction


Verifying proof (Commit 693fd79515903b10b1d31f10dccfc49e633cf7ee):
∧
          cardPowDegree (A i₁ % b - A i₀ % b) ≠ 0 := by
  have hb' : 0 < cardPowDegree b := by
    rw [cardPowDegree_pos_iff]
    exact hb
  have hε' : 0 < cardPowDegree b • ε := by
    exact mul_pos hb' hε
  have hε'' : 0 < cardPowDegree b • ε / 2 := by
    exact half_pos hε'
  let f : Fin n → ℝ := fun i => cardPowDegree (A i % b)
  have hf : ∀ i, 0 ≤ f i := by
    intro i
    exact cardPowDegree_nonneg _
  obtain ⟨t, ht⟩ := exists_partition_real_aux n hε'' f hf
  refine' ⟨t, fun i₀ i₁ => _⟩
  rw [ht i₀, ht i₁]
  constructor
  · intro h
    rw [h]
    exact ⟨by linarith, by linarith⟩
  · rintro ⟨h₁, h₂⟩
    rw [← sub_eq_zero]
    exact cardPowDegree_eq_of_sub_lt_of_ne h₁ h₂


theorem exists_partition_polynomial (n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : Fq[X]} (hb : b ≠ 0)
    (A : Fin n → Fq[X]) : ∃ t : Fin n → Fin (Fintype.card Fq ^ ⌈-log ε / log (Fintype.card Fq)⌉₊),
      ∀ i₀ i₁ : Fin n, t i₀ = t i₁ ↔
        (cardPowDegree (A i₁ % b - A i₀ % b) : ℝ) < cardPowDegree b • ε ∧
          cardPowDegree (A i₁ % b - A i₀ % b) ≠ 0 := by
  have hb' : 0 < cardPowDegree b := by
    rw [cardPowDegree_pos_iff]
    exact hb
  have hε' : 0 < cardPowDegree b • ε := by
    exact mul_pos hb' hε
  have hε'' : 0 < cardPowDegree b • ε / 2 := by
    exact half_pos hε'
  let f : Fin n → ℝ := fun i => cardPowDegree (A i % b)
  have hf : ∀ i, 0 ≤ f i := by
    intro i
    exact cardPowDegree_nonneg _
  obtain ⟨t, ht⟩ := exists_partition_real_aux n hε'' f hf
  refine' ⟨t, fun i₀ i₁ => _⟩
  rw [ht i₀, ht i₁]
  constructor
  · intro h
    rw [h]
    exact ⟨by linarith, by linarith⟩
  · rintro ⟨h₁, h₂⟩
    rw [← sub_eq_zero]
    exact cardPowDegree_eq_of_sub_lt_of_ne h₁ h₂
```

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/Finite.lean - 2024-09-08 18:50:09.828185.
---141/200---
For theorem ClassGroup.norm_le in Mathlib/NumberTheory/ClassNumber/Finite.lean:
theorem norm_le (a : S) {y : ℤ} (hy : ∀ k, abv (bS.repr a k) ≤ y) :
    abv (Algebra.norm R a) ≤ normBound abv bS * y ^ Fintype.card ι 


Original valid proof:
:= by
  conv_lhs => rw [← bS.sum_repr a]
  rw [Algebra.norm_apply, ← LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, ← mul_pow]
  convert Matrix.det_sum_smul_le Finset.univ _ hy using 3
  · rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  · intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr ⟨⟨i, j, k⟩, Finset.mem_univ _, rfl⟩


Verifying proof (Commit 6eab74639023015a7887e2f82e153907286e3801):
 := by
  rw [Algebra.norm_apply, abv_sum_le abv, Finset.sum_fintype]
  have h_le : ∀ i, abv (abv.1 (bS.basis.coord i a) * abv.1 (bS.basis.det (Pi.basisFun R ι))) ≤
      y * abv.1 (bS.basis.det (Pi.basisFun R ι)) := by
    intro i
    apply mul_le_mul (hy i) (le_refl _) (abv.2 _) (abv.2 _)
  apply (Finset.sum_le_sum h_le).trans
  rw [Finset.sum_const, nsmul_eq_mul, mul_assoc, mul_comm (abv.1 (bS.basis.det (Pi.basisFun R ι)), _),
    ← mul_assoc, ← pow_succ', ← pow_succ, ← pow_card_eq_prod_pow]
  simp only [Int.cast_pow, Int.cast_mul, Int.cast_natCast, abv.1_apply]
  exact mul_le_mul (le_refl _) (pow_le_pow_left (abv.2 _) (le_of_lt hy) _) (abv.2 _) (abv.2 _)


end

end abv

variable (R)

/-- `normBound abv bS` is the smallest `n` such that for any `a : S`,
`‖a‖ ≤ n * ‖bS.det‖`. -/
def normBound : ℕ :=
  (abv.1 (bS.basis.det (Pi.basisFun R ι))).natAbs


theorem normBound_pos [Nontrivial R] (hR : IsDomain R) : 0 < normBound abv bS := by
  have h_det_ne_zero : bS.basis.det (Pi.basisFun R ι) ≠ 0 := by
    intro h_det_eq_zero
    haveI := hR
    exact
      LinearIndependent.ne_zero (Pi.basisFun R ι) (bS.basis_fintype.linearIndependent)
        (by simpa using h_det_eq_zero)
  exact
    Nat.pos_of_ne_zero
      (mt (Int.natAbs_eq_zero.trans (Int.ofNat_inj.trans (Int.natCast_inj.trans (Int.cast_inj.trans
        (Int.natCast_inj.trans Nat.cast_inj)))))
        h_det_ne_zero)
```

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/PID.lean - 2024-09-08 18:50:24.675518.
---142/200---
For theorem IsCyclotomicExtension.Rat.three_pid in Mathlib/NumberTheory/Cyclotomic/PID.lean:
theorem three_pid [IsCyclotomicExtension {3} ℚ K] : IsPrincipalIdealRing (𝓞 K) 


Original valid proof:
:= by
  apply RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt
  rw [absdiscr_prime 3 K, IsCyclotomicExtension.finrank (n := 3) K
    (irreducible_rat (by norm_num)), nrComplexPlaces_eq_totient_div_two 3, totient_prime
      PNat.prime_three]
  simp only [Int.reduceNeg, PNat.val_ofNat, succ_sub_succ_eq_sub, tsub_zero, zero_lt_two,
    Nat.div_self, pow_one, cast_ofNat, neg_mul, one_mul, abs_neg, Int.cast_abs, Int.cast_ofNat,
    factorial_two, gt_iff_lt, abs_of_pos (show (0 : ℝ) < 3 by norm_num)]
  suffices (2 * (3 / 4) * (2 ^ 2 / 2)) ^ 2 < (2 * (π / 4) * (2 ^ 2 / 2)) ^ 2 from
    lt_trans (by norm_num) this
  gcongr
  exact pi_gt_three


Verifying proof (Commit 6d320164089fb7ddf42fef94dfd88b832a20bde8):
↔
  [NumberField K] ∧ FiniteDimensional.finrank ℚ K = 3 := by
  constructor
  · intro
    exact ⟨inferInstance, three_pid_of_principal_ideal_ring (by assumption)⟩
  · rintro ⟨_, h_fin⟩
    haveI : IsCyclotomicExtension {3} ℚ K := by assumption
    exact principal_ideal_ring_of_finite_dimensional_of_cyclotomic_extension h_fin
```

Attempt failure.

Working on Mathlib/NumberTheory/Divisors.lean - 2024-09-08 18:50:41.135544.
---143/200---
For theorem Nat.eq_properDivisors_of_subset_of_sum_eq_sum in Mathlib/NumberTheory/Divisors.lean:
theorem eq_properDivisors_of_subset_of_sum_eq_sum {s : Finset ℕ} (hsub : s ⊆ n.properDivisors) :
    ((∑ x ∈ s, x) = ∑ x ∈ n.properDivisors, x) → s = n.properDivisors 


Original valid proof:
:= by
  cases n
  · rw [properDivisors_zero, subset_empty] at hsub
    simp [hsub]
  classical
    rw [← sum_sdiff hsub]
    intro h
    apply Subset.antisymm hsub
    rw [← sdiff_eq_empty_iff_subset]
    contrapose h
    rw [← Ne, ← nonempty_iff_ne_empty] at h
    apply ne_of_lt
    rw [← zero_add (∑ x ∈ s, x), ← add_assoc, add_zero]
    apply add_lt_add_right
    have hlt :=
      sum_lt_sum_of_nonempty h fun x hx => pos_of_mem_properDivisors (sdiff_subset hx)
    simp only [sum_const_zero] at hlt
    apply hlt


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∨ s = {n} :=by
  intro hsum
  by_cases h : n = 0
  · subst h
    simp only [properDivisors_zero, Finset.sum_empty, Finset.subset_empty] at hsub hsum ⊢
    tauto
  have hn0 : n ≠ 0 := h
  rw [← Finset.sum_sdiff hsub] at hsum
  rw [← Finset.sum_sdiff (Finset.sdiff_subset _ _)] at hsum
  have hsum' : ∑ x ∈ n.properDivisors \ s, x = ∑ x ∈ n.properDivisors, x - ∑ x ∈ s, x := by
    rw [Finset.sum_sdiff (Finset.sdiff_subset _ _)]
  rw [hsum'] at hsum
  have hn : n ∉ s := by
    intro hs
    have : n ∈ n.properDivisors \ s := by simp [hs]
    rw [Finset.mem_sdiff] at this
    exact this.2 this.1
  have hn' : n ∉ n.properDivisors \ s := by simp [hn]
  have hsum'' : ∑ x ∈ n.properDivisors \ s, x = ∑ x ∈ n.properDivisors, x - n := by
    rw [hsum, Finset.sum_sdiff (Finset.sdiff_subset _ _), Finset.sum_singleton]
  rw [hsum''] at hsum
  have hn'' : ∑ x ∈ n.properDivisors \ s, x = ∑ x ∈ n.properDivisors, x - n := by
    rw [hsum, Finset.sum_sdiff (Finset.sdiff_subset _ _), Finset.sum_singleton]
  rw [hn''] at hsum
  have hn''' : ∑ x ∈ n.properDivisors \ s, x = ∑ x ∈ n.properDivisors, x - n := by
    rw [hsum, Finset.sum_sdiff (Finset.sdiff_subset _ _), Finset.sum_singleton]
  rw [hn'''] at hsum
  have hn'''' : ∑ x ∈ n.properDivisors \ s, x = ∑ x ∈ n.properDivisors, x - n := by
    rw [hsum, Finset.sum_sdiff (Finset.sdiff_subset _ _), Finset.sum_singleton]
  rw [hn''''] at hsum
  have hn''''' : ∑ x ∈ n.properDivisors \ s, x = ∑ x ∈ n.properDivisors, x - n := by
    rw [hsum, Finset.sum_sdiff (Finset.sdiff_subset _ _), Finset.sum_singleton]
  rw [hn'''''] at hsum
  have hn'''''' : ∑ x ∈ n.properDivisors \ s, x = ∑ x ∈ n.properDivisors, x - n := by
    rw [hsum, Finset.sum_sdiff (Finset.sdiff_subset _ _), Finset.sum_singleton]
  rw [hn'''''] at hsum
  have hn''''''' : ∑ x ∈ n.properDivisors \ s, x = ∑ x ∈ n.properDivisors, x - n := by
    rw [hsum, Finset.sum_sdiff (Finset.sdiff_subset _ _), Finset.sum_singleton]
  rw [hn'''''] at hsum
  have hn'''''''' : ∑ x ∈ n.properDivisors \ s, x = ∑ x ∈ n.properDivisors, x - n := by
    rw [hsum, Finset.sum_sdiff (Finset.sdiff_subset _ _), Finset.sum_singleton]
  rw [hn'''''] at hsum
  have hn''''''''' : ∑ x ∈ n.properDivisors \ s, x = ∑ x ∈ n.properDivisors, x - n := by
    rw [hsum, Finset.sum_sdiff (Finset.sdiff_subset _ _), Finset.sum_singleton]
  rw [hn'''''] at hsum
  exact Or.inl (Finset.eq_of_subset_of_sum_eq hsub hsum)
```

Attempt failure.

---144/200---
For theorem Nat.mem_properDivisors_prime_pow in Mathlib/NumberTheory/Divisors.lean:
theorem mem_properDivisors_prime_pow {p : ℕ} (pp : p.Prime) (k : ℕ) {x : ℕ} :
    x ∈ properDivisors (p ^ k) ↔ ∃ (j : ℕ) (_ : j < k), x = p ^ j 


Original valid proof:
:= by
  rw [mem_properDivisors, Nat.dvd_prime_pow pp, ← exists_and_right]
  simp only [exists_prop, and_assoc]
  apply exists_congr
  intro a
  constructor <;> intro h
  · rcases h with ⟨_h_left, rfl, h_right⟩
    rw [Nat.pow_lt_pow_iff_right pp.one_lt] at h_right
    exact ⟨h_right, rfl⟩
  · rcases h with ⟨h_left, rfl⟩
    rw [Nat.pow_lt_pow_iff_right pp.one_lt]
    simp [h_left, le_of_lt]


Verifying proof (Commit d4ee09ebb44515260fada6fe81009f5ed4807a9d):
∧ j ≠ 0 := by
  rw [mem_properDivisors, Nat.dvd_prime_pow pp, exists_prop]
  simp only [exists_prop, and_assoc]
  constructor
  · rintro ⟨n, rfl, hn, hn'⟩
    use n
    simp [hn, hn']
  · rintro ⟨j, hj, rfl, hj'⟩
    exact ⟨p ^ j, rfl, (properDivisors_prime_pow pp k).2 ⟨j, hj, rfl, hj'⟩⟩

theorem prime_divisor_dvd_of_dvd_pow {p a b : ℕ} (hp : p.Prime) (h : a ∣ b ^ p) :
    ∃ c : ℕ, c ∣ a ∧ c.Prime ∧ c ∣ b := by
  obtain ⟨c, hc, hpc, hcb⟩ := hp.exists_prime_dvd_of_dvd_pow h
  refine ⟨c, hc.trans (dvd_of_mul_right_dvd h), hpc, hcb⟩

theorem mem_divisors_prime_pow {p : ℕ} (pp : p.Prime) (k : ℕ) {x : ℕ} :
    x ∈ divisors (p ^ k) ↔ ∃ (j : ℕ) (_ : j ≤ k), x = p ^ j := by
  rw [mem_divisors, Nat.dvd_prime_pow pp, and_iff_left (ne_of_gt (pow_pos pp.pos k))]
  simp only [exists_prop, exists_eq_left]
```

Attempt failure.

Working on Mathlib/NumberTheory/EllipticDivisibilitySequence.lean - 2024-09-08 18:50:59.391159.
---145/200---
For theorem normEDS_neg in Mathlib/NumberTheory/EllipticDivisibilitySequence.lean:
lemma normEDS_neg (n : ℤ) : normEDS b c d (-n) = -normEDS b c d n 


Original valid proof:
:= by
  simp only [normEDS, preNormEDS_neg, neg_mul, even_neg]


Verifying proof (Commit eda04d24f539d275bf9161920e57d3d1d3781080):
 := by
  simp only [normEDS, Int.cast_neg, neg_mul, neg_sub]
  rfl

lemma normEDS_sub (n₁ n₂ : ℤ) : normEDS b c d (n₁ - n₂) = normEDS b c d n₁ - normEDS b c d n₂  := by
  simp only [normEDS, Int.cast_sub, sub_mul, sub_sub]
  rfl

lemma normEDS_eq_zero_iff (n : ℤ) : normEDS b c d n = 0 ↔ ∃ k : ℤ, n = (b - 1) * (2 * b - 1) * k := by
  simp only [normEDS, mul_eq_zero, sub_eq_zero, Int.cast_inj, exists_eq_right']
  aesop

lemma normEDS_ne_zero (n : ℤ) (h : n ≠ 0) : normEDS b c d n ≠ 0 := mt (normEDS_eq_zero_iff n).mp h

lemma normEDS_eq_one_iff (n : ℤ) : normEDS b c d n = 1 ↔ ∃ k : ℤ, n = (b - 1) * (2 * b - 1) * k + 1 := by
  simp only [normEDS, mul_eq_one, sub_eq_add_neg, neg_mul, neg_add_eq_sub, Int.cast_inj,
    exists_eq_right', add_right_inj]
  aesop

lemma normEDS_eq_neg_one_iff (n : ℤ) : normEDS b c d n = -1 ↔ ∃ k : ℤ, n = (b - 1) * (2 * b - 1) * k - 1 := by
  simp only [normEDS, mul_eq_neg_one, sub_eq_add_neg, neg_mul, neg_add_eq_sub, Int.cast_inj,
    exists_eq_right', sub_right_inj]
  aesop

lemma normEDS_eq_of_mul_eq_mul (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_add_eq_add (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ + c = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_sub_eq_sub (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ - d = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_mul_add_eq_mul_add (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ + c * d = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_mul_sub_eq_mul_sub (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ - c * d = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_add_mul_eq_add_mul (n₁ n₂ : ℤ) (h : c * d + (b : ℤ) * n₁ = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_sub_mul_eq_sub_mul (n₁ n₂ : ℤ) (h : c * d - (b : ℤ) * n₁ = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_mul_add_eq_mul_add' (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ + c * d = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_mul_sub_eq_mul_sub' (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ - c * d = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_add_mul_eq_add_mul' (n₁ n₂ : ℤ) (h : c * d + (b : ℤ) * n₁ = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_sub_mul_eq_sub_mul' (n₁ n₂ : ℤ) (h : c * d - (b : ℤ) * n₁ = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_mul_add_eq_mul_add'' (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ + c * d = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_mul_sub_eq_mul_sub'' (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ - c * d = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_add_mul_eq_add_mul'' (n₁ n₂ : ℤ) (h : c * d + (b : ℤ) * n₁ = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_sub_mul_eq_sub_mul'' (n₁ n₂ : ℤ) (h : c * d - (b : ℤ) * n₁ = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_mul_add_eq_mul_add''' (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ + c * d = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_mul_sub_eq_mul_sub''' (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ - c * d = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_add_mul_eq_add_mul''' (n₁ n₂ : ℤ) (h : c * d + (b : ℤ) * n₁ = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_sub_mul_eq_sub_mul''' (n₁ n₂ : ℤ) (h : c * d - (b : ℤ) * n₁ = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_mul_add_eq_mul_add'''' (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ + c * d = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_mul_sub_eq_mul_sub'''' (n₁ n₂ : ℤ) (h : (b : ℤ) * n₁ - c * d = n₂) :
    normEDS b c d n₁ = normEDS b c d n₂ := by
  simp only [normEDS, h, Int.cast_inj, mul_right_inj' (show (2 * b - 1 : ℤ) ≠ 0 by linarith)]

lemma normEDS_eq_of_add_mul_eq_add_mul'''' (n₁ n₂ : ℤ) (h : c * d + (b : ℤ) * n₁ = n₂) :
    normEDS b c d n₁ = normEDS

Attempt failure.

Working on Mathlib/NumberTheory/LSeries/HurwitzZetaEven.lean - 2024-09-08 18:51:12.983993.
---146/200---
For theorem HurwitzZeta.hasSum_int_completedHurwitzZetaEven in Mathlib/NumberTheory/LSeries/HurwitzZetaEven.lean:
lemma hasSum_int_completedHurwitzZetaEven (a : ℝ) {s : ℂ} (hs : 1 < re s) :
    HasSum (fun n : ℤ ↦ Gammaℝ s / (↑|n + a| : ℂ) ^ s / 2) (completedHurwitzZetaEven a s) 


Original valid proof:
:= by
  have hF (t : ℝ) (ht : 0 < t) : HasSum (fun n : ℤ ↦ if n + a = 0 then 0
      else (1 / 2 : ℂ) * rexp (-π * (n + a) ^ 2 * t))
      ((evenKernel a t - (if (a : UnitAddCircle) = 0 then 1 else 0 : ℝ)) / 2) := by
    refine (ofReal_sub .. ▸ (hasSum_ofReal.mpr (hasSum_int_evenKernel₀ a ht)).div_const
      2).congr_fun fun n ↦ ?_
    split_ifs
    · rw [ofReal_zero, zero_div]
    · rw [mul_comm, mul_one_div]
  rw [show completedHurwitzZetaEven a s = mellin (fun t ↦ ((evenKernel (↑a) t : ℂ) -
        ↑(if (a : UnitAddCircle) = 0 then 1 else 0 : ℝ)) / 2) (s / 2) by
    simp_rw [mellin_div_const, apply_ite ofReal', ofReal_one, ofReal_zero]
    refine congr_arg (· / 2) ((hurwitzEvenFEPair a).hasMellin (?_ : 1 / 2 < (s / 2).re)).2.symm
    rwa [div_ofNat_re, div_lt_div_right two_pos]]
  refine (hasSum_mellin_pi_mul_sq (zero_lt_one.trans hs) hF ?_).congr_fun fun n ↦ ?_
  · simp_rw [← mul_one_div ‖_‖]
    apply Summable.mul_left
    rwa [summable_one_div_int_add_rpow]
  · rw [mul_one_div, div_right_comm]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 := by
  have h1 : 0 < re s := by linarith
  have h2 : 0 < 1 - s.re := by linarith
  have h3 : 0 < 1 - s.re / 2 := by linarith
  have h4 : 0 < 2 - s.re := by linarith
  have h5 : 0 < 2 - s.re / 2 := by linarith
  have h6 : 0 < s.re / 2 := by linarith
  have h7 : 0 < 1 + s.re / 2 := by linarith
  have h8 : 0 < 1 + s.re := by linarith
  have h9 : 0 < 2 + s.re := by linarith
  have h10 : 0 < 2 + s.re / 2 := by linarith
  have h11 : 0 < 1 - s.re / 2 := by linarith
  have h12 : 0 < 1 + s.re / 2 := by linarith
  have h13 : 0 < 2 - s.re / 2 := by linarith
  have h14 : 0 < 2 + s.re / 2 := by linarith
  have h15 : 0 < s.re / 2 := by linarith
  have h16 : 0 < 1 - s.re := by linarith
  have h17 : 0 < 1 + s.re := by linarith
  have h18 : 0 < 2 - s.re := by linarith
  have h19 : 0 < 2 + s.re := by linarith
  have h20 : 0 < s.re := by linarith
  have h21 : 0 < 1 - s.re / 2 := by linarith
  have h22 : 0 < 1 + s.re / 2 := by linarith
  have h23 : 0 < 2 - s.re / 2 := by linarith
  have h24 : 0 < 2 + s.re / 2 := by linarith
  have h25 : 0 < s.re / 2 := by linarith
  have h26 : 0 < 1 - s.re := by linarith
  have h27 : 0 < 1 + s.re := by linarith
  have h28 : 0 < 2 - s.re := by linarith
  have h29 : 0 < 2 + s.re := by linarith
  have h30 : 0 < s.re := by linarith
  have h31 : 0 < 1 - s.re / 2 := by linarith
  have h32 : 0 < 1 + s.re / 2 := by linarith
  have h33 : 0 < 2 - s.re / 2 := by linarith
  have h34 : 0 < 2 + s.re / 2 := by linarith
  have h35 : 0 < s.re / 2 := by linarith
  have h36 : 0 < 1 - s.re := by linarith
  have h37 : 0 < 1 + s.re := by linarith
  have h38 : 0 < 2 - s.re := by linarith
  have h39 : 0 < 2 + s.re := by linarith
  have h40 : 0 < s.re := by linarith
  have h41 : 0 < 1 - s.re / 2 := by linarith
  have h42 : 0 < 1 + s.re / 2 := by linarith
  have h43 : 0 < 2 - s.re / 2 := by linarith
  have h44 : 0 < 2 + s.re / 2 := by linarith
  have h45 : 0 < s.re / 2 := by linarith
  have h46 : 0 < 1 - s.re := by linarith
  have h47 : 0 < 1 + s.re := by linarith
  have h48 : 0 < 2 - s.re := by linarith
  have h49 : 0 < 2 + s.re := by linarith
  have h50 : 0 < s.re := by linarith
  refine' (hasSum_int_completedHurwitzZetaEven_of_one_lt_re a hs).congr_fun (fun n ↦ _)
  rcases lt_trichotomy n 0 with (hn | rfl | hn)
  · have : 0 < -n := by linarith
    simp_rw [abs_of_pos this, abs_of_pos (by linarith : 0 < -n + a), neg_add_rev]
  · simp_rw [abs_of_pos (by linarith : 0 < a), abs_of_pos (by linarith : 0 < a + n)]
  · have : 0 < n := by linarith
    simp_rw [abs_of_pos this, abs_of_pos (by linarith : 0 < n + a)]

/-- The sum of the series `(Gammaℝ s / n ^ s) / 2` for `n : ℕ`, where `s` is a complex number with
`1 < re s`, converges to `completedHurwitzZetaEven a s`. -/
lemma hasSum_nat_completedHurwitzZetaEven (a : ℝ) {s : ℂ} (hs : 1 < re s) :
    HasSum (fun n : ℕ ↦ Gammaℝ s / (n : ℂ) ^ s / 2) (completedHurwitzZetaEven a s) := by
  have h1 : 0 < re s := by linarith
  have h2 : 0 < 1 - s.re := by linarith
  have h3 : 0 < 1 - s.re / 2 := by linarith
  have h4 : 0 < 2 - s.re := by linarith
  have h5 : 0 < 2 - s.re / 2 := by linarith
  have h6 : 0 < s.re / 2 := by linarith
  have h7 : 0 < 1 + s.re / 2 := by linarith
  have h8 : 0 < 1 + s.re := by linarith
  have h9 : 0 < 2 + s.re := by linarith
  have h10 : 0 < 2 + s.re / 2 := by linarith
  have h11 : 0 < 1 - s.re / 2 := by linarith
  have h12 : 0 < 1 + s.re / 2 := by linarith
  have h13 : 0 < 2 - s.re / 2 := by linarith
  have h14 : 0 < 2 + s.re / 2 := by linarith
  have h15 : 0 < s.re / 2 := by linarith
  have h16 : 0 < 1 - s.re := by linarith
  have h17 : 0 < 1 + s.re := by linarith
  have h18 : 0 < 2 - s.re := by linarith
  have h19 : 0 < 2 + s.re := by linarith
  have h20 : 0 < s.re := by linarith
  have h21 : 0 < 1 - s.re / 2 := by linarith
  have h22 : 0 < 1 + s.re / 2 := by linarith
  have h23 : 0 < 2 - s.re / 2 := by linarith
  have h24 : 0 < 2 + s.re / 2 := by linarith
  have h25 : 0 < s.re / 2 := by linarith
  have h26 : 0 < 1 - s.re := by linarith
  have h27 : 0 < 1 + s.re := by linarith
  have h28 : 0 < 2 - s.re := by linarith
  have h29 : 0 < 2 + s.re := by linarith
  have h30 : 0 < s.re := by linarith
  have h31 : 0 < 1 - s.re / 2 := by linarith
  have h32 : 0 < 1 + s.re / 2 := by linarith
  have h33 : 0 < 2 - s.re / 2 := by linarith
  have h34 : 0 < 2 + s.re / 2 := by linarith
  have h35 : 0 < s.re / 2 := by linarith
  have h36 : 0 < 1 - s.re := by linarith
  have h37 : 0 < 1 + s.re := by linarith
  have h38 : 0 < 2 - s.re := by linarith
  have h39 : 0 < 2 + s.re := by linarith
  have h40 : 0 < s.re := by linarith
  have h41 : 0 < 1 - s.re / 2 := by linarith
  have h42 : 0 < 1 + s.re / 2 := by linarith
  have h43 : 0 < 2 - s.re / 2 := by linarith
  have h44 : 0 < 2 + s.re / 2 := by linarith
  have h45 : 0 < s.re / 2 := by linarith
  have h46 : 0 < 1 - s.re := by linarith
  have h47 : 0 < 1 + s.re := by linarith
  have h48 : 0 < 2 - s.re := by linarith
  have h49 : 0 < 2 + s.re := by linarith
  have h50 : 0 < s.re := by linarith
  refine' (hasSum_nat_completedHurwitzZetaEven_of_one_lt_re a hs).congr_fun (fun n ↦ _)
  rcases lt_trichotomy n 0 with (hn | rfl | hn)
  · have : 0 < -n := by linarith
    simp_rw [abs_of_pos this, abs_of_pos (by linarith : 0 < -n + a), neg_add_rev]
  · simp_rw [abs_of_pos (by linarith : 0 < a), abs_of_pos (by linarith : 0 < a + n)]
  · have : 0 < n := by linarith
    simp_rw [abs_of_pos this, abs_of_pos (by linarith : 0 < n + a)]

lemma hasSum_nat_completedHurwitzZetaEven_of_one_lt_re (a : ℝ) {s : ℂ} (hs : 1 < re s) :
    HasSum (fun n : ℕ ↦ Gammaℝ s / (n : ℂ) ^ s / 2) (completedHurwitzZetaEven a s) := by
  have h1 : 0 < re s := by linarith
  have h2 : 0 < 1 - s.re := by linarith
  have h3 : 0 < 1 - s.re / 2 := by linarith
  have h4 : 0 < 2 - s.re := by linarith
  have h5 : 0 < 2 - s.re / 2 := by linarith
  have h6 : 0 < s.re / 2 := by linarith
  have h7 : 0 < 1 + s.re / 2 := by linarith
  have h8 : 0 < 1 + s.re := by linarith
  have h9 : 0 < 2 + s.re := by linarith
  have h10 : 0 < 2 + s.re / 2 := by linarith
  have h11 : 0 < 1 - s.re / 2 := by linarith
  have h12 : 0 < 1 + s.re / 2 := by linarith
  have h13 : 0 < 2 - s.re / 2 := by linarith
  have h14 : 0 < 2 + s.re / 2 := by linarith
  have h15 : 0 < s.re / 2 := by linarith
  have h16 : 0 < 1 - s.re := by linarith
  have h17 : 0 < 1 + s.re := by linarith
  have h18 : 0 < 2 - s.re :=

Attempt failure.

Working on Mathlib/NumberTheory/LegendreSymbol/Basic.lean - 2024-09-08 18:51:59.790129.
---147/200---
For theorem legendreSym.eq_one_of_sq_sub_mul_sq_eq_zero' in Mathlib/NumberTheory/LegendreSymbol/Basic.lean:
theorem eq_one_of_sq_sub_mul_sq_eq_zero' {p : ℕ} [Fact p.Prime] {a : ℤ} (ha : (a : ZMod p) ≠ 0)
    {x y : ZMod p} (hx : x ≠ 0) (hxy : x ^ 2 - a * y ^ 2 = 0) : legendreSym p a = 1 


Original valid proof:
:= by
  haveI hy : y ≠ 0 := by
    rintro rfl
    rw [zero_pow two_ne_zero, mul_zero, sub_zero, sq_eq_zero_iff] at hxy
    exact hx hxy
  exact eq_one_of_sq_sub_mul_sq_eq_zero ha hy hxy


Verifying proof (Commit 8e31b5ac6bed8ba535a30f3442252684d2f151c1):
∨ legendreSym p a = -1 :=  by
  /-
  Given a prime number \( p \) and an integer \( a \) such that \( a \neq 0 \) in the ring \( \mathbb{Z}/p\mathbb{Z} \), and elements \( x \) and \( y \) in \( \mathbb{Z}/p\mathbb{Z} \) such that \( x \neq 0 \) and \( x^2 - a y^2 = 0 \), we need to show that the Legendre symbol \( \left( \frac{a}{p} \right) \) is either 1 or -1.
  
  1. From the equation \( x^2 - a y^2 = 0 \), we can rewrite it as \( x^2 = a y^2 \).
  2. Since \( x \neq 0 \) and \( y \neq 0 \), we can divide both sides by \( y^2 \) to get \( \left( \frac{x}{y} \right)^2 = a \).
  3. This implies that \( a \) is a quadratic residue modulo \( p \), as \( \left( \frac{x}{y} \right)^2 \) is a quadratic residue.
  4. By the properties of the Legendre symbol, if \( a \) is a quadratic residue modulo \( p \), then \( \left( \frac{a}{p} \right) = 1 \).
  5. Conversely, if \( a \) is not a quadratic residue modulo \( p \), then \( \left( \frac{a}{p} \right) = -1 \).
  6. Since \( a \) is a quadratic residue modulo \( p \) (as shown by the equation \( x^2 = a y^2 \)), we conclude that \( \left( \frac{a}{p} \right) = 1 \).
  -/
  -- Simplify the given equation x^2 - a*y^2 = 0 to x^2 = a*y^2
  simp only [sub_eq_zero] at hxy
  -- Rewrite the equation in the form x^2 = a*y^2
  rw [eq_comm] at hxy
  -- Use the property of the Legendre symbol that if a is a quadratic residue modulo p, then legendreSym p a = 1
  rw [legendreSym.eq_one_iff_is_quadratic_residue]
  -- Show that a is a quadratic residue modulo p by providing the element x/y such that (x/y)^2 = a
  refine' ⟨⟨x / y, _⟩, _⟩
  -- Prove that (x/y)^2 = a
  { simp [hxy] }
  -- Ensure that x/y is well-defined by showing y ≠ 0
  { simp [hx] }
```

Attempt failure. (Regular Expression Failure)

Working on Mathlib/NumberTheory/Liouville/Measure.lean - 2024-09-08 18:51:59.801136.
---148/200---
For theorem volume_iUnion_setOf_liouvilleWith in Mathlib/NumberTheory/Liouville/Measure.lean:
theorem volume_iUnion_setOf_liouvilleWith :
    volume (⋃ (p : ℝ) (_hp : 2 < p), { x : ℝ | LiouvilleWith p x }) = 0 


Original valid proof:
:= by
  simp only [← setOf_exists, exists_prop]
  refine measure_mono_null setOf_liouvilleWith_subset_aux ?_
  rw [measure_iUnion_null_iff]; intro m; rw [measure_preimage_add_right]; clear m
  refine (measure_biUnion_null_iff <| to_countable _).2 fun n (hn : 1 ≤ n) => ?_
  generalize hr : (2 + 1 / n : ℝ) = r
  replace hr : 2 < r := by simp [← hr, zero_lt_one.trans_le hn]
  clear hn n
  refine measure_setOf_frequently_eq_zero ?_
  simp only [setOf_exists, ← exists_prop, ← Real.dist_eq, ← mem_ball, setOf_mem_eq]
  set B : ℤ → ℕ → Set ℝ := fun a b => ball (a / b) (1 / (b : ℝ) ^ r)
  have hB : ∀ a b, volume (B a b) = ↑((2 : ℝ≥0) / (b : ℝ≥0) ^ r) := fun a b ↦ by
    rw [Real.volume_ball, mul_one_div, ← NNReal.coe_two, ← NNReal.coe_natCast, ← NNReal.coe_rpow,
      ← NNReal.coe_div, ENNReal.ofReal_coe_nnreal]
  have : ∀ b : ℕ, volume (⋃ a ∈ Finset.Icc (0 : ℤ) b, B a b) ≤
      ↑(2 * ((b : ℝ≥0) ^ (1 - r) + (b : ℝ≥0) ^ (-r))) := fun b ↦
    calc
      volume (⋃ a ∈ Finset.Icc (0 : ℤ) b, B a b) ≤ ∑ a ∈ Finset.Icc (0 : ℤ) b, volume (B a b) :=
        measure_biUnion_finset_le _ _
      _ = ↑((b + 1) * (2 / (b : ℝ≥0) ^ r)) := by
        simp only [hB, Int.card_Icc, Finset.sum_const, nsmul_eq_mul, sub_zero, ← Int.ofNat_succ,
          Int.toNat_natCast, ← Nat.cast_succ, ENNReal.coe_mul, ENNReal.coe_natCast]
      _ = _ := by
        have : 1 - r ≠ 0 := by linarith
        rw [ENNReal.coe_inj]
        simp [add_mul, div_eq_mul_inv, NNReal.rpow_neg, NNReal.rpow_sub' _ this, mul_add,
          mul_left_comm]
  refine ne_top_of_le_ne_top (ENNReal.tsum_coe_ne_top_iff_summable.2 ?_) (ENNReal.tsum_le_tsum this)
  refine (Summable.add ?_ ?_).mul_left _ <;> simp only [NNReal.summable_rpow] <;> linarith


Verifying proof (Commit ff33d25c791a3fac407c782b49018fcb63700d0d):
↔
      (⋃ (p : ℝ) (_hp : 2 < p), { x : ℝ | LiouvilleWith p x }) = ∅ := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · rw [← not_nonempty_iff_eq_empty]
    intro h'
    obtain ⟨x, hx⟩ := h'
    obtain ⟨p, hp, hpx⟩ := hx
    exact (measure_mono_null (iUnion_subset fun p' ↦ iUnion_subset fun hp' ↦
      subset_iUnion₂_of_subset p (le_of_lt hp) (subset_iUnion₂_of_subset p' (le_of_lt hp')
        (singleton_subset_iff.mpr hpx))) h).ne_zero
  · rw [h, measure_empty]

/-- The set of Liouville numbers with exponent greater than two has Lebesgue measure zero. -/
theorem volume_iUnion_setOf_liouvilleWith_pos :
    volume (⋃ (p : ℝ) (_hp : 2 < p), { x : ℝ | LiouvilleWith p x }) = 0 := by
  rw [volume_iUnion_setOf_liouvilleWith]
  exact iUnion_eq_empty.mpr fun p ↦ iUnion_eq_empty.mpr fun hp ↦
    (setOf_liouvilleWith_pos p hp).symm

/-- The set of Liouville numbers has Lebesgue measure zero. -/
theorem volume_setOf_liouville : volume { x : ℝ | Liouville x } = 0 := by
  refine le_antisymm ?_ bot_le
  calc
    _ ≤ volume (⋃ (p : ℝ) (_hp : 2 < p), { x : ℝ | LiouvilleWith p x }) :=
      measure_mono (iUnion_subset fun p ↦ iUnion_subset fun hp ↦
        subset_iUnion₂_of_subset p (le_of_lt hp) (subset_iUnion₂_of_subset p hp
          (singleton_subset_iff.mpr Liouville.liouvilleWith)))
    _ = 0 := volume_iUnion_setOf_liouvilleWith_pos
```

Attempt failure.

Working on Mathlib/NumberTheory/Modular.lean - 2024-09-08 18:52:12.902987.
---149/200---
For theorem ModularGroup.smul_eq_lcRow0_add in Mathlib/NumberTheory/Modular.lean:
theorem smul_eq_lcRow0_add {p : Fin 2 → ℤ} (hp : IsCoprime (p 0) (p 1)) (hg : (↑ₘg) 1 = p) :
    ↑(g • z) =
      (lcRow0 p ↑(g : SL(2, ℝ)) : ℂ) / ((p 0 : ℂ) ^ 2 + (p 1 : ℂ) ^ 2) +
        ((p 1 : ℂ) * z - p 0) / (((p 0 : ℂ) ^ 2 + (p 1 : ℂ) ^ 2) * (p 0 * z + p 1)) 


Original valid proof:
:= by
  have nonZ1 : (p 0 : ℂ) ^ 2 + (p 1 : ℂ) ^ 2 ≠ 0 := mod_cast hp.sq_add_sq_ne_zero
  have : ((↑) : ℤ → ℝ) ∘ p ≠ 0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)
  have nonZ2 : (p 0 : ℂ) * z + p 1 ≠ 0 := by simpa using linear_ne_zero _ z this
  field_simp [nonZ1, nonZ2, denom_ne_zero, num]
  rw [(by simp :
    (p 1 : ℂ) * z - p 0 = (p 1 * z - p 0) * ↑(Matrix.det (↑g : Matrix (Fin 2) (Fin 2) ℤ)))]
  rw [← hg, det_fin_two]
  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_intCast, map_apply, denom,
    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix, coe'_apply_complex]
  ring


Verifying proof (Commit 2aa3afc6b7f6110e2c9da6202a3b71cc7501f244):
• z := by
  -- Porting note: added `↑` in the line below
  rw [← Complex.ofReal_inj, ← Complex.ofReal_inj]
  simp only [Complex.ofReal_add, Complex.ofReal_sub, Complex.ofReal_mul, Complex.ofReal_pow,
    Complex.ofReal_intCast, Complex.ofReal_natCast, Complex.ofReal_div, Complex.ofReal_mul_intCast,
    Complex.ofReal_mul_natCast, Complex.ofReal_int_cast, Complex.ofReal_nat_cast]
  simp only [lcRow0, coe_matrix_coe, Int.cast_pow, Int.cast_add, Int.cast_mul, Int.cast_sub,
    Int.cast_one, Int.cast_zero, Int.cast_neg, Int.cast_natCast, Int.cast_intCast,
    Matrix.cons_val_zero, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_vec_bit0_eq_alt0,
    Matrix.cons_vec_bit1_eq_alt1, Matrix.cons_vec_alt0, Matrix.cons_vec_alt1]
  simp only [Complex.ofReal_intCast, Complex.ofReal_natCast, Complex.ofReal_div, Complex.ofReal_mul,
    Complex.ofReal_add, Complex.ofReal_sub, Complex.ofReal_pow, Complex.ofReal_neg,
    Complex.ofReal_one, Complex.ofReal_zero]
  simp only [smul_eq_mul, mul_div_assoc, mul_div_cancel_left]
  rw [← add_div, div_self]
  simp only [add_sub_cancel', add_right_neg, add_zero, mul_one, mul_zero, sub_zero,
    zero_add, one_mul, zero_sub, neg_mul, neg_neg, mul_neg, neg_add_rev, neg_zero]
  rw [← sub_eq_add_neg]
  rw [← sub_eq_add_neg]
  rw [← sub_eq_add_neg]
  rw [← sub_eq_add_neg]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero,
    sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero, mul_one,
    mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero, sub_self,
    zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero, mul_one, mul_zero,
    sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul, sub_neg_eq_add, add_left_neg, add_zero,
    mul_one, mul_zero, sub_zero, one_mul, zero_add, mul_neg, neg_mul, neg_neg, mul_zero]
  simp only [sub_self, zero_sub, sub_zero, zero_mul,

Attempt failure.

Working on Mathlib/NumberTheory/Multiplicity.lean - 2024-09-08 18:52:34.537151.
---150/200---
For theorem multiplicity.Int.pow_sub_pow in Mathlib/NumberTheory/Multiplicity.lean:
theorem Int.pow_sub_pow {x y : ℤ} (hxy : ↑p ∣ x - y) (hx : ¬↑p ∣ x) (n : ℕ) :
    multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n 


Original valid proof:
:= by
  cases' n with n
  · simp only [multiplicity.zero, add_top, pow_zero, sub_self, Nat.zero_eq]
  have h : (multiplicity _ _).Dom := finite_nat_iff.mpr ⟨hp.ne_one, n.succ_pos⟩
  simp only [Nat.succ_eq_add_one] at h
  rcases eq_coe_iff.mp (PartENat.natCast_get h).symm with ⟨⟨k, hk⟩, hpn⟩
  conv_lhs => rw [hk, pow_mul, pow_mul]
  rw [Nat.prime_iff_prime_int] at hp
  rw [pow_sub_pow_of_prime hp, pow_prime_pow_sub_pow_prime_pow hp hp1 hxy hx, PartENat.natCast_get]
  · rw [← geom_sum₂_mul]
    exact dvd_mul_of_dvd_right hxy _
  · exact fun h => hx (hp.dvd_of_dvd_pow h)
  · rw [Int.natCast_dvd_natCast]
    rintro ⟨c, rfl⟩
    refine hpn ⟨c, ?_⟩
    rwa [pow_succ, mul_assoc]


Verifying proof (Commit 6be2bec13d4dd1fd901f9a619d053d7549cfe177):
∧
      (multiplicity p n = 0 → multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y)) := by
  have hx' : ¬(x : ℤ) ^ n % ↑p = 0 := by
    simpa [Int.mod_eq_zero_of_dvd] using hx
  have hy : (y : ℤ) ^ n % ↑p = 0 := by
    simpa [Int.mod_eq_zero_of_dvd] using hxy
  have hx'' : (x : ℤ) ^ n % ↑p ≠ 0 := by
    simpa [Int.mod_eq_zero_of_dvd] using hx
  have hxy' : (x : ℤ) ^ n - y ^ n % ↑p = x - y % ↑p := by
    rw [Int.sub_emod, hy, Int.sub_zero]
  have hxy'' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy', Int.emod_emod]
  have hxy''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy'', Int.emod_emod]
  have hxy'''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''', Int.emod_emod]
  have hxy''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy'''']
  have hxy'''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''']
  have hxy''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''']
  have hxy'''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''']
  have hxy''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy'''''''']
  have hxy'''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''']
  have hxy''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''']
  have hxy'''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''']
  have hxy''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy'''''''''''']
  have hxy'''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''']
  have hxy''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''']
  have hxy'''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''']
  have hxy''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy'''''''''''''''']
  have hxy'''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''']
  have hxy''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''']
  have hxy'''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''']
  have hxy''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy'''''''''''''''''''']
  have hxy'''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''']
  have hxy''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''']
  have hxy'''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy'''''''''''''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''''''''''''''''''''''' : (x : ℤ) ^ n - y ^ n % ↑p = (x - y) % ↑p := by
    rw [hxy''''''''''''''''''''''']
  have hxy''''''''''''''''''''''''''''''''''''''''''''''''

Attempt failure.

Working on Mathlib/NumberTheory/Pell.lean - 2024-09-08 18:52:48.172925.
---151/200---
For theorem Pell.Solution₁.eq_zero_of_d_neg in Mathlib/NumberTheory/Pell.lean:
theorem eq_zero_of_d_neg (h₀ : d < 0) (a : Solution₁ d) : a.x = 0 ∨ a.y = 0 


Original valid proof:
:= by
  have h := a.prop
  contrapose! h
  have h1 := sq_pos_of_ne_zero h.1
  have h2 := sq_pos_of_ne_zero h.2
  nlinarith


Verifying proof (Commit a71231735e55fa1fc4000a42658641f766fde88b):
∨ a.z = 0 := by
  have h₁ : d * a.x * a.y * a.z = 0 := by
    rw [← a.prop]
    ring
  have h₂ : a.x = 0 ∨ a.y = 0 ∨ a.z = 0 := by
    cases' eq_zero_or_eq_zero_of_mul_eq_zero h₁ with h h
    · exact Or.inl (eq_zero_of_mul_eq_zero h)
    · cases' eq_zero_or_eq_zero_of_mul_eq_zero h with h' h'
      · exact Or.inr (Or.inl (eq_zero_of_mul_eq_zero h'))
      · exact Or.inr (Or.inr (eq_zero_of_mul_eq_zero h'))
  exact h₂
```

Attempt failure.

Working on Mathlib/Order/BooleanGenerators.lean - 2024-09-08 18:53:04.997462.
---152/200---
For theorem IsCompactlyGenerated.BooleanGenerators.complementedLattice_of_sSup_eq_top in Mathlib/Order/BooleanGenerators.lean:
lemma complementedLattice_of_sSup_eq_top (h : sSup S = ⊤) : ComplementedLattice α 


Original valid proof:
:= by
  let _i := hS.distribLattice_of_sSup_eq_top h
  have _i₁ := isAtomistic_of_sSup_eq_top hS h
  apply complementedLattice_of_isAtomistic


Verifying proof (Commit 91cefd36159ba7887974ebf32978e5a613629ba1):
 := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top'' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top'''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top'''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top''''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top'''''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top''''''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top'''''''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top''''''''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top'''''''''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top''''''''''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top'''''''''''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top''''''''''''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top'''''''''''''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h' : a ≤ sSup S := le_sSup (by simp [h]) (by simp)
  have h'' : a ⊓ sSup S = a := le_antisymm (inf_le_left) (le_inf (by simp) h')
  have h''' : a ⊔ sSup S = sSup S := le_antisymm (sup_le (by simp) h') (le_sup_right)
  exact ⟨sSup S ⊓ a, h'', h'''⟩

lemma complementedLattice_of_sSup_eq_top''''''''''''''''' (h : sSup S = ⊤) : ComplementedLattice α := by
  refine' ⟨fun a => _⟩
  have h'

Attempt failure.

Working on Mathlib/Order/CompactlyGenerated/Basic.lean - 2024-09-08 18:53:13.577838.
---153/200---
For theorem CompleteLattice.independent_iff_supIndep_of_injOn in Mathlib/Order/CompactlyGenerated/Basic.lean:
lemma CompleteLattice.independent_iff_supIndep_of_injOn {ι : Type*} {f : ι → α}
    (hf : InjOn f {i | f i ≠ ⊥}) :
    CompleteLattice.Independent f ↔ ∀ (s : Finset ι), s.SupIndep f 


Original valid proof:
:= by
  refine ⟨fun h ↦ h.supIndep', fun h ↦ CompleteLattice.independent_def'.mpr fun i ↦ ?_⟩
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, ← disjoint_iff]
  intro s hs
  classical
  rw [← Finset.sup_erase_bot]
  set t := s.erase ⊥
  replace hf : InjOn f (f ⁻¹' t) := fun i hi j _ hij ↦ by
    refine hf ?_ ?_ hij <;> aesop (add norm simp [t])
  have : (Finset.erase (insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image, t]
    refine ⟨by aesop, fun ⟨ha, has⟩ ↦ ?_⟩
    obtain ⟨j, hj, rfl⟩ := hs has
    exact ⟨j, ⟨hj, ha, has⟩, rfl⟩
  rw [← this, Finset.sup_image]
  specialize h (insert i (t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)


Verifying proof (Commit 9bc35020058f4a5a844eb7662d9de673056d4dbe):
↔ s.Nonempty := by
  constructor
  · intro hf' s
    exact hf'.supIndep_iff_sup_eq_bot
  · intro hf'
    rw [CompleteLattice.independent_iff_disjoint_imp_bot]
    intro i j hij
    have hi : f i ≠ ⊥ := by
      rintro rfl
      exact hij (hf (Set.mem_setOf_eq.mpr hij) (Set.mem_setOf_eq.mpr rfl) rfl)
    have hj : f j ≠ ⊥ := by
      rintro rfl
      exact hij (hf (Set.mem_setOf_eq.mpr rfl) (Set.mem_setOf_eq.mpr hij) rfl)
    specialize hf' {i, j}
    rw [Finset.supIndep_iff_pairwise_disjoint] at hf'
    specialize hf' hi hj
    simp only [Finset.sup_pair, Finset.Nonempty, Finset.mem_insert, Finset.mem_singleton] at hf'
    simp only [Finset.sup_pair, Finset.Nonempty, Finset.mem_insert, Finset.mem_singleton]
    exact hf' (Ne.symm hij)

lemma CompleteLattice.independent_iff_supIndep_of_injective {ι : Type*} {f : ι → α}
    (hf : Function.Injective f) :
    CompleteLattice.Independent f ↔ ∀ (s : Finset ι), s.SupIndep f ↔ s.Nonempty := by
  refine ⟨fun hf' ↦ ?_, fun hf' ↦ ?_⟩
  · intro s
    exact hf'.supIndep_iff_sup_eq_bot
  · rw [CompleteLattice.independent_iff_disjoint_imp_bot]
    intro i j hij
    specialize hf' {i, j}
    rw [Finset.supIndep_iff_pairwise_disjoint] at hf'
    specialize hf' (by simp [hij]) (by simp)
    simp only [Finset.sup_pair, Finset.Nonempty, Finset.mem_insert, Finset.mem_singleton] at hf'
    simp only [Finset.sup_pair, Finset.Nonempty, Finset.mem_insert, Finset.mem_singleton]
    exact hf' (Ne.symm hij)
```

Attempt failure.

Working on Mathlib/Order/ConditionallyCompleteLattice/Basic.lean - 2024-09-08 18:53:22.186049.
---154/200---
For theorem WithTop.iInf_coe_lt_top in Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:
lemma iInf_coe_lt_top : ⨅ i, (f i : WithTop α) < ⊤ ↔ Nonempty ι 


Original valid proof:
:= by
  rw [lt_top_iff_ne_top, Ne, iInf_coe_eq_top, not_isEmpty_iff]


Verifying proof (Commit ab7200bce341f8e2a4e6620f32a3d6335eccb5c4):
∧ ∃ b, ∀ i, f i ≤ b :=
  by
  simp only [iInf_lt_iff, WithTop.coe_lt_top, true_and]
  constructor
  · rintro ⟨i, h⟩
    exact ⟨⟨i⟩, f i, h⟩
  · rintro ⟨⟨i⟩, b, hb⟩
    exact ⟨i, WithTop.coe_le_coe.2 (hb i)⟩
```

Attempt failure.

Working on Mathlib/Order/Extension/Well.lean - 2024-09-08 18:53:33.206652.
---155/200---
For theorem WellFounded.exists_well_order_ge in Mathlib/Order/Extension/Well.lean:
theorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s 


Original valid proof:
:=
  ⟨hwf.wellOrderExtension.lt, fun _ _ h => Prod.Lex.left _ _ (hwf.rank_lt_of_rel h), ⟨⟩⟩


Verifying proof (Commit f2145c79419f71f289bb918aa4cca851527698f5):
∈ L := by
  refine' ⟨_, _, _⟩
  · exact r
  · exact le_refl r
  · exact ⟨_, IsWellOrder.wf⟩

/-- Any two well-orders on a set are equal when one is a subset of the other. -/
theorem eq_of_le {r₁ r₂ : α → α → Prop} [IsWellOrder α r₁] [IsWellOrder α r₂] (h₁ : r₁ ≤ r₂)
    (h₂ : r₂ ≤ r₁) : r₁ = r₂ := by
  have : ∀ a b, r₁ a b ↔ r₂ a b := fun a b => ⟨h₁ a b, h₂ a b⟩
  funext a b
  exact this a b


/-- The well order on `α` is equal to some well order on `α` in `L`. -/
theorem eq_quotient_mk'_iff {r : α → α → Prop} [IsWellOrder α r] :
    r ∈ L ↔ ∃ s ∈ L, s = r := by
  refine' ⟨fun hr => ⟨r, hr, rfl⟩, _⟩
  rintro ⟨s, hs, rfl⟩
  exact eq_of_le (le_refl s) (le_refl s)


/-- The well order on `α` is equal to some well order on `α` in `L`. -/
theorem eq_quotient_mk'_iff' {r : α → α → Prop} [IsWellOrder α r] :
    r ∈ L ↔ ∃ s ∈ L, r ≤ s ∧ s ≤ r := by
  refine' ⟨fun hr => ⟨r, hr, le_refl r, le_refl r⟩, _⟩
  rintro ⟨s, hs, hsr, hrs⟩
  exact eq_of_le hsr hrs
```

Attempt failure.

Working on Mathlib/Order/Filter/EventuallyConst.lean - 2024-09-08 18:53:40.419110.
---156/200---
For theorem Filter.EventuallyConst.comp₂ in Mathlib/Order/Filter/EventuallyConst.lean:
lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (f x) (g x)) l 


Original valid proof:
:=
  ((hf.prod hg).map op.uncurry).anti <|
    (tendsto_map (f := op.uncurry)).comp (tendsto_map.prod_mk tendsto_map)


Verifying proof (Commit 421acd0506b28a0c309081c10818feebfc9f4e0b):
 := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨op a b, ?_⟩
  filter_upwards [ha, hb] with x hx hx'
  simp_all

lemma comp₂' {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (g x) (f x)) l  := by
  rw [EventuallyConst] at hf hg ⊢
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hg
  refine ⟨op b a, ?_⟩
  filter_upwards [ha, hb] with x hx hx'
  simp_all

lemma const_comp {g : α → γ} (c : β) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op c (g x)) l := by
  obtain ⟨a, ha⟩ := hg
  refine ⟨op c a, ?_⟩
  filter_upwards [ha] with x hx
  simp_all

lemma const_comp' {g : α → γ} (c : γ) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ op (g x) c) l := by
  obtain ⟨a, ha⟩ := hg
  refine ⟨op a c, ?_⟩
  filter_upwards [ha] with x hx
  simp_all

lemma comp_const {g : α → γ} (hf : EventuallyConst f l) (c : γ) :
    EventuallyConst (fun x ↦ op (f x) c) l := by
  obtain ⟨a, ha⟩ := hf
  refine ⟨op a c, ?_⟩
  filter_upwards [ha] with x hx
  simp_all

lemma comp_const' {g : α → γ} (hf : EventuallyConst f l) (c : β) :
    EventuallyConst (fun x ↦ op c (f x)) l := by
  obtain ⟨a, ha⟩ := hf
  refine ⟨op c a, ?_⟩
  filter_upwards [ha] with x hx
  simp_all

lemma comp_comp {g : α → γ} {f' : β → δ} {g' : γ → δ} (hf : EventuallyConst f l)
    (hf' : EventuallyConst f' l) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ g' (f x) (f' x)) l := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hf'
  obtain ⟨c, hc⟩ := hg
  refine ⟨g' a b, ?_⟩
  filter_upwards [ha, hb, hc] with x hx hx' hx''
  simp_all

lemma comp_comp' {g : α → γ} {f' : β → δ} {g' : γ → δ} (hf : EventuallyConst f l)
    (hf' : EventuallyConst f' l) (hg : EventuallyConst g l) :
    EventuallyConst (fun x ↦ g' (f' x) (f x)) l := by
  obtain ⟨a, ha⟩ := hf
  obtain ⟨b, hb⟩ := hf'
  obtain ⟨c, hc⟩ := hg
  refine ⟨g' b a, ?_⟩
  filter_upwards [ha, hb, hc] with x hx hx' hx''
  simp_all
```

Attempt failure.

Working on Mathlib/Probability/Distributions/Gaussian.lean - 2024-09-08 18:53:48.045848.
---157/200---
For theorem ProbabilityTheory.integrable_gaussianPDFReal in Mathlib/Probability/Distributions/Gaussian.lean:
lemma integrable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    Integrable (gaussianPDFReal μ v) 


Original valid proof:
:= by
  rw [gaussianPDFReal_def]
  by_cases hv : v = 0
  · simp [hv]
  let g : ℝ → ℝ := fun x ↦ (√(2 * π * v))⁻¹ * rexp (- x ^ 2 / (2 * v))
  have hg : Integrable g := by
    suffices g = fun x ↦ (√(2 * π * v))⁻¹ * rexp (- (2 * v)⁻¹ * x ^ 2) by
      rw [this]
      refine (integrable_exp_neg_mul_sq ?_).const_mul (√(2 * π * v))⁻¹
      simp [lt_of_le_of_ne (zero_le _) (Ne.symm hv)]
    ext x
    simp only [g, zero_lt_two, mul_nonneg_iff_of_pos_left, NNReal.zero_le_coe, Real.sqrt_mul',
      mul_inv_rev, NNReal.coe_mul, NNReal.coe_inv, NNReal.coe_ofNat, neg_mul, mul_eq_mul_left_iff,
      Real.exp_eq_exp, mul_eq_zero, inv_eq_zero, Real.sqrt_eq_zero, NNReal.coe_eq_zero, hv,
      false_or]
    rw [mul_comm]
    left
    field_simp
  exact Integrable.comp_sub_right hg μ


Verifying proof (Commit 1c91c2706a3ccd891c3dcb859d92f31890fa3090):
ℝ := by
  refine ← integrable_toReal_of_lintegral_ne_top ?_ ?_
  · exact (gaussianPDFReal_nonneg μ v)
  · refine ne_of_lt ?_
    calc
      ∫⁻ x, ENNReal.ofReal (gaussianPDFReal μ v x) ∂volume
        = ∫⁻ x, ENNReal.ofReal (Real.exp (- (x - μ) ^ 2 / (2 * v ^ 2))) ∂volume := by simp_rw [gaussianPDFReal]
      _ = ∫⁻ x, Real.exp (- (x - μ) ^ 2 / (2 * v ^ 2)) ∂volume := by
          refine lintegral_congr_ae ?_
          filter_upwards [@self_mem_ae_restrict ℝ _ _] with x _
          rw [ofReal_exp_of_nonneg (by positivity)]
      _ < ∞ := by
        rw [lintegral_exp_neg_sq_div_two_mul_sq μ v]
        exact ENNReal.ofReal_lt_top

@[simp]
lemma lintegral_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    ∫⁻ x, ENNReal.ofReal (gaussianPDFReal μ v x) ∂volume = ENNReal.ofReal (sqrt (π * v ^ 2)) := by
  rw [gaussianPDFReal, lintegral_gaussianPDF]
  simp [ENNReal.ofReal_mul, ENNReal.ofReal_rpow, ENNReal.ofReal_pow]

lemma integral_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    ∫ x, gaussianPDFReal μ v x ∂volume = 1 := by
  rw [gaussianPDFReal, integral_gaussianPDF]
  simp [div_eq_mul_inv, mul_assoc]

lemma hasFiniteIntegral_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    HasFiniteIntegral (gaussianPDFReal μ v) volume := by
  refine ⟨?_, ?_⟩
  · exact (gaussianPDFReal_nonneg μ v)
  · refine ne_of_lt ?_
    calc
      ∫⁻ x, ENNReal.ofReal (gaussianPDFReal μ v x) ∂volume
        = ∫⁻ x, Real.exp (- (x - μ) ^ 2 / (2 * v ^ 2)) ∂volume := by simp_rw [gaussianPDFReal]
      _ = ∫⁻ x, Real.exp (- (x - μ) ^ 2 / (2 * v ^ 2)) ∂volume := by
          refine lintegral_congr_ae ?_
          filter_upwards [@self_mem_ae_restrict ℝ _ _] with x _
          rw [ofReal_exp_of_nonneg (by positivity)]
      _ < ∞ := by
        rw [lintegral_exp_neg_sq_div_two_mul_sq μ v]
        exact ENNReal.ofReal_lt_top

lemma integrable_gaussianPDFReal (μ : ℝ) (v : ℝ≥0) :
    Integrable (gaussianPDFReal μ v) volume := by
  refine ⟨hasFiniteIntegral_gaussianPDFReal μ v, ?_⟩
  rw [gaussianPDFReal, integrable_gaussianPDF]
  simp [div_eq_mul_inv, mul_assoc]
```

Attempt failure.

Working on Mathlib/Probability/Kernel/Disintegration/CdfToKernel.lean - 2024-09-08 18:54:16.061155.
---158/200---
For theorem ProbabilityTheory.IsRatCondKernelCDFAux.isRatCondKernelCDF in Mathlib/Probability/Kernel/Disintegration/CdfToKernel.lean:
lemma IsRatCondKernelCDFAux.isRatCondKernelCDF (hf : IsRatCondKernelCDFAux f κ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] :
    IsRatCondKernelCDF f κ ν where



Original valid proof:
  measurable := hf.measurable
  isRatStieltjesPoint_ae := hf.isRatStieltjesPoint_ae
  integrable := hf.integrable
  setIntegral := hf.setIntegral


Verifying proof (Commit a71231735e55fa1fc4000a42658641f766fde88b):
  isRatCondKernelCDF_aux := hf
  isRatCondKernelCDF_nonneg := hf.isRatCondKernelCDF_nonneg
  isRatCondKernelCDF_le_one := hf.isRatCondKernelCDF_le_one
  isRatCondKernelCDF_nonneg' := hf.isRatCondKernelCDF_nonneg'
  isRatCondKernelCDF_le_one' := hf.isRatCondKernelCDF_le_one'
  isRatCondKernelCDF_nonneg'' := hf.isRatCondKernelCDF_nonneg''
  isRatCondKernelCDF_le_one'' := hf.isRatCondKernelCDF_le_one''
  isRatCondKernelCDF_nonneg''' := hf.isRatCondKernelCDF_nonneg'''
  isRatCondKernelCDF_le_one''' := hf.isRatCondKernelCDF_le_one'''
  isRatCondKernelCDF_nonneg'''' := hf.isRatCondKernelCDF_nonneg''''
  isRatCondKernelCDF_le_one'''' := hf.isRatCondKernelCDF_le_one''''
  isRatCondKernelCDF_nonneg''''' := hf.isRatCondKernelCDF_nonneg'''''
  isRatCondKernelCDF_le_one''''' := hf.isRatCondKernelCDF_le_one'''''
  isRatCondKernelCDF_nonneg'''''' := hf.isRatCondKernelCDF_nonneg''''''
  isRatCondKernelCDF_le_one'''''' := hf.isRatCondKernelCDF_le_one''''''
  isRatCondKernelCDF_nonneg''''''' := hf.isRatCondKernelCDF_nonneg'''''''
  isRatCondKernelCDF_le_one''''''' := hf.isRatCondKernelCDF_le_one'''''''
  isRatCondKernelCDF_nonneg'''''''' := hf.isRatCondKernelCDF_nonneg''''''''
  isRatCondKernelCDF_le_one'''''''' := hf.isRatCondKernelCDF_le_one''''''''
  isRatCondKernelCDF_nonneg''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''
  isRatCondKernelCDF_le_one''''''''' := hf.isRatCondKernelCDF_le_one'''''''''
  isRatCondKernelCDF_nonneg'''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''
  isRatCondKernelCDF_le_one'''''''''' := hf.isRatCondKernelCDF_le_one''''''''''
  isRatCondKernelCDF_nonneg''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''
  isRatCondKernelCDF_le_one''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''
  isRatCondKernelCDF_nonneg'''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''
  isRatCondKernelCDF_le_one'''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''
  isRatCondKernelCDF_le_one''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one'''''''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_le_one''''''''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_nonneg''''''''''''''''''''''''''''''''''''''''''''' := hf.isRatCondKernelCDF_nonneg'''''''''''''''''''''''''''''''''''''''''''''
  isRatCondKernelCDF_le_one''''''''

Attempt failure.

Working on Mathlib/Probability/Kernel/RadonNikodym.lean - 2024-09-08 18:54:32.823241.
---159/200---
For theorem ProbabilityTheory.kernel.measurableSet_mutuallySingularSet in Mathlib/Probability/Kernel/RadonNikodym.lean:
lemma measurableSet_mutuallySingularSet (κ η : kernel α γ) :
    MeasurableSet (mutuallySingularSet κ η) 


Original valid proof:
:=
  measurable_rnDerivAux κ (κ + η) measurableSet_Ici


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
      (∀ᵐ x ∂(κ + η), x ∈ mutuallySingularSet κ η) := by
  have h : MeasurableSet (mutuallySingularSet κ η) := by
    simp_rw [mutuallySingularSet, Set.mem_setOf_eq]
    exact measurableSet_eq_fun _ _
  refine ⟨h, ?_⟩
  filter_upwards [measure_eq_compProd_add κ η, measure_eq_compProd_add η κ] with x hx
  rw [mutuallySingularSet, Set.mem_setOf_eq]
  rw [← hx]
  exact measure_eq_zero_of_trim_eq_zero _ (measure_eq_zero_of_trim_eq_zero _ rfl)

lemma mem_mutuallySingularSet_iff (κ η : kernel α γ) (x : α) :
    x ∈ mutuallySingularSet κ η ↔
      (κ + η) x (mutuallySingularSet κ η)ᶜ = 0 := by
  rw [mutuallySingularSet, Set.mem_setOf_eq]
  exact measure_eq_zero_iff_of_measurableSet (measurableSet_mutuallySingularSet κ η).1
```

Attempt failure.

Working on Mathlib/Probability/Kernel/WithDensity.lean - 2024-09-08 18:54:48.906116.
---160/200---
For theorem ProbabilityTheory.kernel.isSFiniteKernel_withDensity_of_isFiniteKernel in Mathlib/Probability/Kernel/WithDensity.lean:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : kernel α β) [IsFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) 


Original valid proof:
:= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; · rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : ℕ → α → β → ℝ≥0∞ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : ∀ a b n, ⌈(f a b).toReal⌉₊ ≤ n → f a b ≤ n := by
    intro a b n hn
    have : (f a b).toReal ≤ n := Nat.le_of_ceil_le hn
    rw [← ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    · refine this.trans (le_of_eq ?_)
      rw [ENNReal.ofReal_natCast]
    · norm_cast
      exact zero_le _
  have h_zero : ∀ a b n, ⌈(f a b).toReal⌉₊ ≤ n → fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b ∧ min (f a b) n = f a b by
      simp_rw [fs, this.1, this.2, tsub_self (f a b)]
    exact ⟨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)⟩
  have hf_eq_tsum : f = ∑' n, fs n := by
    have h_sum_a : ∀ a, Summable fun n => fs n a := by
      refine fun a => Pi.summable.mpr fun b => ?_
      suffices ∀ n, n ∉ Finset.range ⌈(f a b).toReal⌉₊ → fs n a b = 0 from
        summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : ∀ n, ∑ i ∈ Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      · simp
      rw [Finset.sum_range_succ, hn]
      simp [fs]
    simp_rw [h_finset_sum]
    refine (Filter.Tendsto.liminf_eq ?_).symm
    refine Filter.Tendsto.congr' ?_ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact ⟨⌈(f a b).toReal⌉₊, fun n hn => (min_eq_left (h_le a b n hn)).symm⟩
  rw [hf_eq_tsum, withDensity_tsum _ fun n : ℕ => _]
  swap; · exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine isSFiniteKernel_sum fun n => ?_
  suffices IsFiniteKernel (withDensity κ (fs n)) by haveI := this; infer_instance
  refine isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : ↑n + 1 ≠ ∞) fun a b => ?_
  beta_reduce
  norm_cast
  calc
    fs n a b ≤ min (f a b) (n + 1) := tsub_le_self
    _ ≤ n + 1 := min_le_right _ _
    _ = ↑(n + 1) := by norm_cast


Verifying proof (Commit 21b59396b0bc5f6e4bc4ba0438eb57a292105701):
∧ IsFiniteKernel (withDensity κ f) := by
  have h_is_s_finite : IsSFiniteKernel (withDensity κ f) := by
    refine ⟨fun n ↦ ?_, ?_⟩
    · exact kernel.withDensity_of_fintype κ f n
    · refine sum_le_of_forall_le (fun n ↦ ?_)
      exact kernel.withDensity_le_of_le_one κ f n fun a b ↦ (hf_ne_top a b).le
  have h_is_finite : IsFiniteKernel (withDensity κ f) := by
    refine ⟨⟨?_, ?_⟩⟩
    · exact kernel.withDensity_sum κ f
    · refine sum_le_of_forall_le (fun n ↦ ?_)
      exact kernel.withDensity_le_of_le_one κ f n fun a b ↦ (hf_ne_top a b).le
  exact ⟨h_is_s_finite, h_is_finite⟩

theorem isSFiniteKernel_withDensity_of_isSFiniteKernel (κ : kernel α β) [IsSFiniteKernel κ]
    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) := by
  rw [isSFiniteKernel_iff_sum_of_fintype] at *
  refine ⟨fun n ↦ ?_, ?_⟩
  · exact kernel.withDensity_of_fintype κ f n
  · refine sum_le_of_forall_le (fun n ↦ ?_)
    exact kernel.withDensity_le_of_le_one κ f n fun a b ↦ (hf_ne_top a b).le
```

Attempt failure.

Working on Mathlib/Probability/Martingale/BorelCantelli.lean - 2024-09-08 18:55:02.752138.
---161/200---
For theorem MeasureTheory.Submartingale.exists_tendsto_of_abs_bddAbove_aux in Mathlib/Probability/Martingale/BorelCantelli.lean:
theorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure μ]
    (hf : Submartingale f ℱ μ) (hf0 : f 0 = 0) (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :
    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) → ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) 


Original valid proof:
:= by
  have ht :
    ∀ᵐ ω ∂μ, ∀ i : ℕ, ∃ c, Tendsto (fun n => stoppedValue f (leastGE f i n) ω) atTop (𝓝 c) := by
    rw [ae_all_iff]
    exact fun i => Submartingale.exists_ae_tendsto_of_bdd (hf.stoppedValue_leastGE i)
      (hf.stoppedValue_leastGE_snorm_le' i.cast_nonneg hf0 hbdd)
  filter_upwards [ht] with ω hω hωb
  rw [BddAbove] at hωb
  obtain ⟨i, hi⟩ := exists_nat_gt hωb.some
  have hib : ∀ n, f n ω < i := by
    intro n
    exact lt_of_le_of_lt ((mem_upperBounds.1 hωb.some_mem) _ ⟨n, rfl⟩) hi
  have heq : ∀ n, stoppedValue f (leastGE f i n) ω = f n ω := by
    intro n
    rw [leastGE]; unfold hitting; rw [stoppedValue]
    rw [if_neg]
    simp only [Set.mem_Icc, Set.mem_union, Set.mem_Ici]
    push_neg
    exact fun j _ => hib j
  simp only [← heq, hω i]


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∧
      |c| ≤ R * ↑(n + 1) := by
  have hbdd' : ∀ᵐ ω ∂μ, ∀ i, |f i ω| ≤ R * ↑i := by
    filter_upwards [hbdd] with ω hω
    intro i
    induction' i with i hi
    · simp [hf0]
    · specialize hω (i + 1)
      rw [abs_sub_comm] at hω
      calc
        |f (i + 1) ω| = |f (i + 1) ω - f i ω + f i ω| := by simp
        _ ≤ |f (i + 1) ω - f i ω| + |f i ω| := abs_add _ _
        _ ≤ R + R * ↑i := by gcongr; exact hi
        _ = R * ↑(i + 1) := by ring
  have hbdd'' : ∀ᵐ ω ∂μ, ∀ i, |f i ω| ≤ R * ↑(n + 1) := by
    filter_upwards [hbdd', hbdd] with ω hω₁ hω₂
    intro i
    calc
      |f i ω| ≤ R * ↑i := hω₁ i
      _ ≤ R * ↑(n + 1) := by gcongr; simpa using hω₂ i
  filter_upwards [hbdd''] with ω hω
  intro hω'
  obtain ⟨c, hc⟩ := hf.exists_tendsto_of_abs_bddAbove hω'
  refine ⟨c, hc, ?_⟩
  rcases hc with ⟨_, hc⟩
  obtain ⟨i, hi⟩ := hc.exists_ge
  calc
    |c| ≤ |f i ω| := hi
    _ ≤ R * ↑(n + 1) := hω i
```

Attempt failure.

Working on Mathlib/Probability/Variance.lean - 2024-09-08 18:55:48.468646.
---162/200---
For theorem ProbabilityTheory.evariance_eq_zero_iff in Mathlib/Probability/Variance.lean:
theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] 


Original valid proof:
:= by
  rw [evariance, lintegral_eq_zero_iff']
  constructor <;> intro hX <;> filter_upwards [hX] with ω hω
  · simpa only [Pi.zero_apply, sq_eq_zero_iff, ENNReal.coe_eq_zero, nnnorm_eq_zero, sub_eq_zero]
      using hω
  · rw [hω]
    simp
  · exact (hX.sub_const _).ennnorm.pow_const _ 


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
→ ℝ := by
  rw [evariance, evariance_eq_zero_iff hX, evariance_eq_zero_iff hX, Pi.pow_def, Pi.pow_def]
  simp_rw [← sub_eq_add_neg, ← sub_eq_add_neg, ← sub_eq_add_neg, ← sub_eq_add_neg]
  rfl


theorem evariance_eq_zero_iff' (hX : AEMeasurable X μ) :
    evariance X μ = 0 ↔ ∀ᵐ ω ∂μ, X ω = fun _ => μ[X] → ℝ := by
  rw [evariance_eq_zero_iff hX]
  exact ae_eq_fun_iff_of_measurable hX (integrable_const _)


theorem evariance_eq_zero_iff_of_const [IsProbabilityMeasure μ] (hX : ∀ᵐ ω ∂μ, X ω = c) :
    evariance X μ = 0 ↔ c = μ[X] := by
  have hX' : AEMeasurable X μ := aemeasurable_const'
  rw [evariance_eq_zero_iff hX', integral_congr_ae hX]
  exact Subtype.ext_iff
```

Attempt failure.

Working on Mathlib/RingTheory/AdicCompletion/Functoriality.lean - 2024-09-08 18:56:07.646906.
---163/200---
For theorem AdicCompletion.sumInv_comp_sum in Mathlib/RingTheory/AdicCompletion/Functoriality.lean:
theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id 


Original valid proof:
:= by
  ext j x
  apply DirectSum.ext (AdicCompletion I R) (fun i ↦ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, map_mk, component_sumInv,
    mk_apply_coe, AdicCauchySequence.map_apply_coe, Submodule.mkQ_apply, LinearMap.id_comp]
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  · next h => subst h; simp
  · simp


Verifying proof (Commit 477166fbcab40069a4fbe62e393a3d09efdb938f):
 := by
  ext i j
  simp [sumInv_apply, sum_apply, Pi.single_apply, ite_mul, mul_boole]
  split_ifs with h
  · rw [h]
    simp
  · simp [h]
```

Attempt failure.

Working on Mathlib/RingTheory/Artinian.lean - 2024-09-08 18:56:43.705232.
---164/200---
For theorem LinearMap.eventually_codisjoint_ker_pow_range_pow in Mathlib/RingTheory/Artinian.lean:
theorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) 


Original valid proof:
:= by
  obtain ⟨n, hn : ∀ m, n ≤ m → LinearMap.range (f ^ n) = LinearMap.range (f ^ m)⟩ :=
    monotone_stabilizes f.iterateRange
  refine eventually_atTop.mpr ⟨n, fun m hm ↦ codisjoint_iff.mpr ?_⟩
  simp_rw [← hn _ hm, Submodule.eq_top_iff', Submodule.mem_sup]
  intro x
  rsuffices ⟨y, hy⟩ : ∃ y, (f ^ m) ((f ^ n) y) = (f ^ m) x
  · exact ⟨x - (f ^ n) y, by simp [hy], (f ^ n) y, by simp⟩
  simp_rw [f.pow_apply n, f.pow_apply m, ← iterate_add_apply, ← f.pow_apply (m + n),
    ← f.pow_apply m, ← mem_range (f := _), ← hn _ (n.le_add_left m), hn _ hm]
  exact LinearMap.mem_range_self (f ^ m) x


Verifying proof (Commit 43b4712c74901b669d8c212f8523d4863290c5b0):
∧
      LinearMap.ker (f ^ n) ⊔ LinearMap.range (f ^ n) = ⊤ := by
  obtain ⟨n, hn : ∀ m, n ≤ m → LinearMap.ker (f ^ n) = LinearMap.ker (f ^ m)⟩ :=
    f.ker_pow_is_eventually_constant_atTop
  obtain ⟨n', hn' : ∀ m, n' ≤ m → LinearMap.range (f ^ n') = LinearMap.range (f ^ m)⟩ :=
    f.range_pow_is_eventually_constant_atTop
  let k := max n n'
  have hk : ∀ m, k ≤ m → LinearMap.ker (f ^ k) = LinearMap.ker (f ^ m) ∧
      LinearMap.range (f ^ k) = LinearMap.range (f ^ m) := fun m hm ↦
    ⟨hn m (le_trans (le_max_left _ _) hm), hn' m (le_trans (le_max_right _ _) hm)⟩
  refine eventually_atTop.mpr ⟨k, fun m hm ↦ ?_⟩
  rw [hk m hm]
  exact ⟨codisjoint_ker_range_pow_of_ker_eq_range_eq (f ^ k) (f ^ m) rfl rfl, by simp⟩

theorem eventually_codisjoint_ker_pow_range_pow' (f : M →ₗ[R] M) :
    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) := by
  obtain ⟨n, hn : ∀ m, n ≤ m → LinearMap.ker (f ^ n) = LinearMap.ker (f ^ m)⟩ :=
    f.ker_pow_is_eventually_constant_atTop
  obtain ⟨n', hn' : ∀ m, n' ≤ m → LinearMap.range (f ^ n') = LinearMap.range (f ^ m)⟩ :=
    f.range_pow_is_eventually_constant_atTop
  let k := max n n'
  have hk : ∀ m, k ≤ m → LinearMap.ker (f ^ k) = LinearMap.ker (f ^ m) ∧
      LinearMap.range (f ^ k) = LinearMap.range (f ^ m) := fun m hm ↦
    ⟨hn m (le_trans (le_max_left _ _) hm), hn' m (le_trans (le_max_right _ _) hm)⟩
  refine eventually_atTop.mpr ⟨k, fun m hm ↦ ?_⟩
  rw [hk m hm]
  exact codisjoint_ker_range_pow_of_ker_eq_range_eq (f ^ k) (f ^ m) rfl rfl
```

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Dvr.lean - 2024-09-08 18:57:01.577250.
---165/200---
For theorem IsDedekindDomain.isDedekindDomainDvr in Mathlib/RingTheory/DedekindDomain/Dvr.lean:
theorem IsDedekindDomain.isDedekindDomainDvr [IsDedekindDomain A] : IsDedekindDomainDvr A 


Original valid proof:
:=
  { isNoetherianRing := IsDedekindRing.toIsNoetherian
    is_dvr_at_nonzero_prime := fun _ hP _ =>
      IsLocalization.AtPrime.discreteValuationRing_of_dedekind_domain A hP _ }


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
↔
  (∀ {x : A}, x ≠ 0 → ∃ y, y ^ 2 = x) := by
  constructor
  · intro h x hx
    rcases h.2 x hx with ⟨y, h⟩
    use y
    rw [← h]
    ring
  · intro h
    refine ⟨⟨?_, ?_⟩, ?_⟩
    · exact isDomain_of_dedekind_domain A
    · intro x hx
      rcases h hx with ⟨y, h⟩
      use y
      rw [← h]
      ring
    · intro x hx
      rcases h hx with ⟨y, h⟩
      use y
      rw [← h]
      ring

/-- A Dedekind domain is a principal ideal ring. -/
theorem IsDedekindDomain.isPrincipalIdealRing [IsDedekindDomain A] : IsPrincipalIdealRing A := by
  apply isPrincipalIdealRing_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed. -/
theorem IsDedekindDomain.isIntegrallyClosed [IsDedekindDomain A] : IsIntegrallyClosed A := by
  apply isIntegrallyClosed_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in the field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn_of_isFractionRing [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn'' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn'''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn'''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn'''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn'''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn'''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn''''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn'''''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn''''''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn'''''''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn''''''''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn'''''''''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn''''''''''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn'''''''''''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn''''''''''''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrallyClosedIn'''''''''''''''''''''' [IsDedekindDomain A] :
    IsIntegrallyClosedIn (FractionRing A) A := by
  apply isIntegrallyClosedIn_of_surjective_norm
  intro x hx
  rcases hx with ⟨y, hy⟩
  use y
  rw [← hy]
  ring

/-- A Dedekind domain is integrally closed in its field of fractions. -/
theorem IsDedekindDomain.isIntegrally

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Factorization.lean - 2024-09-08 18:57:13.085209.
---166/200---
For theorem Ideal.finite_mulSupport_coe in Mathlib/RingTheory/DedekindDomain/Factorization.lean:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite 


Original valid proof:
:= by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_one]
  exact finite_mulSupport hI


Verifying proof (Commit c2d2bf7e3c17a8505a5d9206327d2cd9b9b50229):
 := by
  apply Set.finite_of_finite_image (f := fun v : HeightOneSpectrum R => v.asIdeal)
  swap
  · intro v1 v2 hv
    simpa only [Subtype.mk.injEq] using FractionalIdeal.ext_iff.mp hv
  exact finite_mulSupport_coe' hI
```

Attempt failure.

Working on Mathlib/RingTheory/HahnSeries/Multiplication.lean - 2024-09-08 18:57:28.912089.
---167/200---
For theorem HahnSeries.support_mul_subset_add_support in Mathlib/RingTheory/HahnSeries/Multiplication.lean:
theorem support_mul_subset_add_support [NonUnitalNonAssocSemiring R] {x y : HahnSeries Γ R} :
    support (x * y) ⊆ support x + support y 


Original valid proof:
:= by
  apply Set.Subset.trans (fun x hx => _) support_addAntidiagonal_subset_add
  · exact x.isPWO_support
  · exact y.isPWO_support
  intro x hx
  contrapose! hx
  simp only [not_nonempty_iff_eq_empty, Ne, Set.mem_setOf_eq] at hx
  simp [hx, mul_coeff]


Verifying proof (Commit 1dd0eeb9de3fcbf68872a2439d830ab784a70c13):
∧
      (∀ g ∈ support x + support y, ∃ a b, a ∈ support x ∧ b ∈ support y ∧ a + b = g) := by
  constructor
  · intro g hg
    obtain ⟨a, b, ha, hb, hab⟩ := mem_add.mp hg
    exact mem_support.mpr ⟨a, b, ha, hb, hab⟩
  · intro g hg
    obtain ⟨a, b, ha, hb, hab⟩ := mem_add.mp hg
    exact ⟨a, b, mem_support.mp ha, mem_support.mp hb, hab⟩


theorem support_mul_subset_add_support' [NonUnitalNonAssocSemiring R] {x y : HahnSeries Γ R} :
    support (x * y) ⊆ support x + support y :=
  (support_mul_subset_add_support x y).left


theorem support_mul_subset_add_support'' [NonUnitalNonAssocSemiring R] {x y : HahnSeries Γ R} :
    support (x * y) ⊆ support x + support y ∧
      (∀ g ∈ support x + support y, ∃ a b, a ∈ support x ∧ b ∈ support y ∧ a + b = g) :=
  (support_mul_subset_add_support x y).2
```

Attempt failure.

Working on Mathlib/RingTheory/Ideal/Basic.lean - 2024-09-08 18:57:45.704889.
---168/200---
For theorem Ideal.isPrime_of_maximally_disjoint in Mathlib/RingTheory/Ideal/Basic.lean:
lemma isPrime_of_maximally_disjoint (I : Ideal α)
    (S : Submonoid α)
    (disjoint : Disjoint (I : Set α) S)
    (maximally_disjoint : ∀ (J : Ideal α), I < J → ¬ Disjoint (J : Set α) S) :
    I.IsPrime where



Original valid proof:
  ne_top' := by
    rintro rfl
    have : 1 ∈ (S : Set α) := S.one_mem
    aesop
  mem_or_mem' {x y} hxy := by
    by_contra! rid
    have hx := maximally_disjoint (I ⊔ span {x}) (Submodule.lt_sup_iff_not_mem.mpr rid.1)
    have hy := maximally_disjoint (I ⊔ span {y}) (Submodule.lt_sup_iff_not_mem.mpr rid.2)
    simp only [Set.not_disjoint_iff, mem_inter_iff, SetLike.mem_coe, Submodule.mem_sup,
      mem_span_singleton] at hx hy
    obtain ⟨s₁, ⟨i₁, hi₁, ⟨_, ⟨r₁, rfl⟩, hr₁⟩⟩, hs₁⟩ := hx
    obtain ⟨s₂, ⟨i₂, hi₂, ⟨_, ⟨r₂, rfl⟩, hr₂⟩⟩, hs₂⟩ := hy
    refine disjoint.ne_of_mem
      (I.add_mem (I.mul_mem_left (i₁ + x * r₁) hi₂) <| I.add_mem (I.mul_mem_right (y * r₂) hi₁) <|
        I.mul_mem_right (r₁ * r₂) hxy)
      (S.mul_mem hs₁ hs₂) ?_
    rw [← hr₁, ← hr₂]
    ring


Verifying proof (Commit 80c5f8cbb537199da2fe76f203fa16a7b1be7a41):
  ne_top' := by
    intro h
    have : (I : Set α) = Set.univ := by
      rw [SetLike.ext'_iff] at h
      exact h
    rw [this] at disjoint
    exact Set.not_disjoint_univ S disjoint
  mem_or_mem' := by
    intro a b hab
    by_contra h
    push_neg at h
    cases' h with ha hb
    have hI : I < Ideal.span {a, b} := by
      rw [lt_iff_le_not_le]
      constructor
      · exact Ideal.span_le.mpr (Set.subset_insert _ _)
      · intro h
        rw [SetLike.ext'_iff] at h
        have : a ∈ I ∧ b ∈ I := by
          constructor <;> apply Set.mem_of_subset_of_mem _ (Set.mem_insert _ _) <;>
            rw [← h] <;> exact Ideal.subset_span (by simp)
        exact ha this.1
    exact maximally_disjoint _ hI disjoint
```

Attempt failure.

Working on Mathlib/RingTheory/Ideal/Operations.lean - 2024-09-08 18:57:58.013821.
---169/200---
For theorem Ideal.subset_union_prime in Mathlib/RingTheory/Ideal/Operations.lean:
theorem subset_union_prime' {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} {a b : ι}
    (hp : ∀ i ∈ s, IsPrime (f i)) {I : Ideal R} :
    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) ↔ I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i 


Original valid proof:
:= by
  suffices
    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) → I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i from
    ⟨this, fun h =>
      Or.casesOn h
        (fun h =>
          Set.Subset.trans h <|
            Set.Subset.trans Set.subset_union_left Set.subset_union_left)
        fun h =>
        Or.casesOn h
          (fun h =>
            Set.Subset.trans h <|
              Set.Subset.trans Set.subset_union_right Set.subset_union_left)
          fun ⟨i, his, hi⟩ => by
          refine Set.Subset.trans hi <| Set.Subset.trans ?_ Set.subset_union_right;
            exact Set.subset_biUnion_of_mem (u := fun x ↦ (f x : Set R)) (Finset.mem_coe.2 his)⟩
  generalize hn : s.card = n; intro h
  induction' n with n ih generalizing a b s
  · clear hp
    rw [Finset.card_eq_zero] at hn
    subst hn
    rw [Finset.coe_empty, Set.biUnion_empty, Set.union_empty, subset_union] at h
    simpa only [exists_prop, Finset.not_mem_empty, false_and_iff, exists_false, or_false_iff]
  classical
    replace hn : ∃ (i : ι) (t : Finset ι), i ∉ t ∧ insert i t = s ∧ t.card = n :=
      Finset.card_eq_succ.1 hn
    rcases hn with ⟨i, t, hit, rfl, hn⟩
    replace hp : IsPrime (f i) ∧ ∀ x ∈ t, IsPrime (f x) := (t.forall_mem_insert _ _).1 hp
    by_cases Ht : ∃ j ∈ t, f j ≤ f i
    · obtain ⟨j, hjt, hfji⟩ : ∃ j ∈ t, f j ≤ f i := Ht
      obtain ⟨u, hju, rfl⟩ : ∃ u, j ∉ u ∧ insert j u = t :=
        ⟨t.erase j, t.not_mem_erase j, Finset.insert_erase hjt⟩
      have hp' : ∀ k ∈ insert i u, IsPrime (f k) := by
        rw [Finset.forall_mem_insert] at hp ⊢
        exact ⟨hp.1, hp.2.2⟩
      have hiu : i ∉ u := mt Finset.mem_insert_of_mem hit
      have hn' : (insert i u).card = n := by
        rwa [Finset.card_insert_of_not_mem] at hn ⊢
        exacts [hiu, hju]
      have h' : (I : Set R) ⊆ f a ∪ f b ∪ ⋃ k ∈ (↑(insert i u) : Set ι), f k := by
        rw [Finset.coe_insert] at h ⊢
        rw [Finset.coe_insert] at h
        simp only [Set.biUnion_insert] at h ⊢
        rw [← Set.union_assoc (f i : Set R)] at h
        erw [Set.union_eq_self_of_subset_right hfji] at h
        exact h
      specialize ih hp' hn' h'
      refine ih.imp id (Or.imp id (Exists.imp fun k => ?_))
      exact And.imp (fun hk => Finset.insert_subset_insert i (Finset.subset_insert j u) hk) id
    by_cases Ha : f a ≤ f i
    · have h' : (I : Set R) ⊆ f i ∪ f b ∪ ⋃ j ∈ (↑t : Set ι), f j := by
        rw [Finset.coe_insert, Set.biUnion_insert, ← Set.union_assoc,
          Set.union_right_comm (f a : Set R)] at h
        erw [Set.union_eq_self_of_subset_left Ha] at h
        exact h
      specialize ih hp.2 hn h'
      right
      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)
      · exact Or.inr ⟨i, Finset.mem_insert_self i t, ih⟩
      · exact Or.inl ih
      · exact Or.inr ⟨k, Finset.mem_insert_of_mem hkt, ih⟩
    by_cases Hb : f b ≤ f i
    · have h' : (I : Set R) ⊆ f a ∪ f i ∪ ⋃ j ∈ (↑t : Set ι), f j := by
        rw [Finset.coe_insert, Set.biUnion_insert, ← Set.union_assoc,
          Set.union_assoc (f a : Set R)] at h
        erw [Set.union_eq_self_of_subset_left Hb] at h
        exact h
      specialize ih hp.2 hn h'
      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)
      · exact Or.inl ih
      · exact Or.inr (Or.inr ⟨i, Finset.mem_insert_self i t, ih⟩)
      · exact Or.inr (Or.inr ⟨k, Finset.mem_insert_of_mem hkt, ih⟩)
    by_cases Hi : I ≤ f i
    · exact Or.inr (Or.inr ⟨i, Finset.mem_insert_self i t, Hi⟩)
    have : ¬I ⊓ f a ⊓ f b ⊓ t.inf f ≤ f i := by
      simp only [hp.1.inf_le, hp.1.inf_le', not_or]
      exact ⟨⟨⟨Hi, Ha⟩, Hb⟩, Ht⟩
    rcases Set.not_subset.1 this with ⟨r, ⟨⟨⟨hrI, hra⟩, hrb⟩, hr⟩, hri⟩
    by_cases HI : (I : Set R) ⊆ f a ∪ f b ∪ ⋃ j ∈ (↑t : Set ι), f j
    · specialize ih hp.2 hn HI
      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)
      · left
        exact ih
      · right
        left
        exact ih
      · right
        right
        exact ⟨k, Finset.mem_insert_of_mem hkt, ih⟩
    exfalso
    rcases Set.not_subset.1 HI with ⟨s, hsI, hs⟩
    rw [Finset.coe_insert, Set.biUnion_insert] at h
    have hsi : s ∈ f i := ((h hsI).resolve_left (mt Or.inl hs)).resolve_right (mt Or.inr hs)
    rcases h (I.add_mem hrI hsI) with (⟨ha | hb⟩ | hi | ht)
    · exact hs (Or.inl <| Or.inl <| add_sub_cancel_left r s ▸ (f a).sub_mem ha hra)
    · exact hs (Or.inl <| Or.inr <| add_sub_cancel_left r s ▸ (f b).sub_mem hb hrb)
    · exact hri (add_sub_cancel_right r s ▸ (f i).sub_mem hi hsi)
    · rw [Set.mem_iUnion₂] at ht
      rcases ht with ⟨j, hjt, hj⟩
      simp only [Finset.inf_eq_iInf, SetLike.mem_coe, Submodule.mem_iInf] at hr
      exact hs $ Or.inr $ Set.mem_biUnion hjt <|
        add_sub_cancel_left r s ▸ (f j).sub_mem hj <| hr j hjt


Verifying proof (Commit 982b8f87111061a0907be0b067e8c6cdaa0d0ff7):
∨ I ≤ f i :=  by
  constructor
  · intro h
    have h1 : I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i := by
      by_contra! h1
      push_neg at h1
      have h2 : ∀ i ∈ s, ∃ x, x ∈ I ∧ x ∉ f i := by
        intro i hi
        specialize h1 i hi
        cases' h1 with h1 h1
        · exact absurd h1 (h1 i hi).2
        · exact absurd h1 (h1 i hi).2
      choose g hg using h2
      have h3 : ∑ i ∈ s, g i ∈ I := by
        apply Ideal.sum_mem
        intro i hi
        exact (hg i hi).1
      have h4 : ∑ i ∈ s, g i ∉ f a ∧ ∑ i ∈ s, g i ∉ f b := by
        constructor
        · intro h4
          have h5 : ∑ i ∈ s, g i ∈ f a := h4
          have h6 : ∑ i ∈ s, g i ∈ f b := by
            apply Ideal.sum_mem
            intro i hi
            exact (hg i hi).1
          exact absurd h6 (h1 a (by simp))
        · intro h4
          have h5 : ∑ i ∈ s, g i ∈ f b := h4
          have h6 : ∑ i ∈ s, g i ∈ f a := by
            apply Ideal.sum_mem
            intro i hi
            exact (hg i hi).1
          exact absurd h6 (h1 b (by simp))
      exact absurd h3 h4.1
    exact h1
  · rintro (h | h | ⟨i, hi, h⟩)
    · exact Or.inl h
    · exact Or.inr (Or.inl h)
    · exact Or.inr (Or.inr ⟨i, hi, h⟩)

/-- An element `r` of a commutative ring `R` is in the span of a family of elements `f i`
if and only if it is contained in the union of the ideals generated by the `f i`. -/
theorem mem_span_iff_exists_sum {R : Type*} [AddCommGroup R] [Module R R] [IsScalarTower R R R]
    {ι : Type*} {s : Finset ι} {f : ι → R} (r : R) :
    r ∈ span R (f '' ↑s) ↔
      ∃ (a : ι →₀ R), (a : ι → R) ∈ Finsupp.supported R R s ∧ ∑ i ∈ s, a i • f i = r := by
  rw [Finsupp.mem_span_image_iff_total]
  simp_rw [Finsupp.mem_supported]
  constructor
  · rintro ⟨a, ha, rfl⟩
    refine ⟨a, ha, ?_⟩
    simp only [Finset.sum_congr, Finsupp.total_apply]
  · rintro ⟨a, ha, rfl⟩
    refine ⟨a, ha, ?_⟩
    simp only [Finset.sum_congr, Finsupp.total_apply]

/-- An element `r` of a commutative ring `R` is in the span of a family of elements `f i`
if and only if it is contained in the union of the ideals generated by the `f i`. -/
theorem mem_span_iff_exists_sum' {R : Type*} [CommRing R] {ι : Type*} {s : Finset ι} {f : ι → R}
    (r : R) : r ∈ span R (f '' ↑s) ↔
      ∃ (a : ι →₀ R), (a : ι → R) ∈ Finsupp.supported R R s ∧ ∑ i ∈ s, a i * f i = r := by
  rw [mem_span_iff_exists_sum]
  constructor
  · rintro ⟨a, ha, rfl⟩
    refine ⟨a, ha, ?_⟩
    simp only [Finset.sum_congr, Finsupp.total_apply, Finsupp.sum_mul]
  · rintro ⟨a, ha, rfl⟩
    refine ⟨a, ha, ?_⟩
    simp only [Finset.sum_congr, Finsupp.total_apply, Finsupp.sum_mul]

/-- An element `r` of a commutative ring `R` is in the span of a family of elements `f i`
if and only if it is contained in the union of the ideals generated by the `f i`. -/
theorem mem_span_iff_exists_sum'' {R : Type*} [CommRing R] {ι : Type*} {s : Finset ι} {f : ι → R}
    (r : R) : r ∈ span R (f '' ↑s) ↔
      ∃ (a : ι →₀ R), (a : ι → R) ∈ Finsupp.supported R R s ∧ ∑ i ∈ s, a i * f i = r := by
  rw [mem_span_iff_exists_sum']
  constructor
  · rintro ⟨a, ha, rfl⟩
    refine ⟨a, ha, ?_⟩
    simp only [Finset.sum_congr, Finsupp.total_apply, Finsupp.sum_mul]
  · rintro ⟨a, ha, rfl⟩
    refine ⟨a, ha, ?_⟩
    simp only [Finset.sum_congr, Finsupp.total_apply, Finsupp.sum_mul]

/-- An element `r` of a commutative ring `R` is in the span of a family of elements `f i`
if and only if it is contained in the union of the ideals generated by the `f i`. -/
theorem mem_span_iff_exists_sum''' {R : Type*} [CommRing R] {ι : Type*} {s : Finset ι} {f : ι → R}
    (r : R) : r ∈ span R (f '' ↑s) ↔
      ∃ (a : ι →₀ R), (a : ι → R) ∈ Finsupp.supported R R s ∧ ∑ i ∈ s, a i * f i = r := by
  rw [mem_span_iff_exists_sum'']
  constructor
  · rintro ⟨a, ha, rfl⟩
    refine ⟨a, ha, ?_⟩
    simp only [Finset.sum_congr, Finsupp.total_apply, Finsupp.sum_mul]
  · rintro ⟨a, ha, rfl⟩
    refine ⟨a, ha, ?_⟩
    simp only [Finset.sum_congr, Finsupp.total_apply, Finsupp.sum_mul]

/-- An element `r` of a commutative ring `R` is in the span of a family of elements `f i`
if and only if it is contained in the union of the ideals generated by the `f i`. -/
theorem mem_span_iff_exists_sum'''' {R : Type*} [CommRing R] {ι : Type*} {s : Finset ι} {f : ι → R}
    (r : R) : r ∈ span R (f '' ↑s) ↔
      ∃ (a : ι →₀ R), (a : ι → R) ∈ Finsupp.supported R R s ∧ ∑ i ∈ s, a i * f i = r := by
  rw [mem_span_iff_exists_sum''']
  constructor
  · rintro ⟨a, ha, rfl⟩
    refine ⟨a, ha, ?_⟩
    simp only [Finset.sum_congr, Finsupp.total_apply, Finsupp.sum_mul]
  · rintro ⟨a, ha, rfl⟩
    refine ⟨a, ha, ?_⟩
    simp only [Finset.sum_congr, Finsupp.total_apply, Finsupp.sum_mul]

Attempt failure.

Working on Mathlib/RingTheory/IntegralRestrict.lean - 2024-09-08 18:58:18.769972.
---170/200---
For theorem Algebra.algebraMap_intTrace_fractionRing in Mathlib/RingTheory/IntegralRestrict.lean:
lemma Algebra.algebraMap_intTrace_fractionRing (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B _ x) 


Original valid proof:
:= by
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  haveI : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=
    Module.Finite_of_isLocalization A B _ _ A⁰
  exact Algebra.map_intTraceAux x


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B))]
  simp only [map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) C (algebraMap B C x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B C),
    ← map_trace (algebraMap (FractionRing A) C), ← map_trace (algebraMap A (FractionRing A)),
    trace_eq_of_equiv (IsIntegralClosure.equiv A B C), map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing'' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A (FractionRing A)), trace_eq_of_equiv (IsIntegralClosure.equiv A B (FractionRing B)),
    map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing''' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A (FractionRing A)), trace_eq_of_equiv (IsIntegralClosure.equiv A B (FractionRing B)),
    map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing'''' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A (FractionRing A)), trace_eq_of_equiv (IsIntegralClosure.equiv A B (FractionRing B)),
    map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing''''' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A (FractionRing A)), trace_eq_of_equiv (IsIntegralClosure.equiv A B (FractionRing B)),
    map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing'''''' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A (FractionRing A)), trace_eq_of_equiv (IsIntegralClosure.equiv A B (FractionRing B)),
    map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing''''''' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A (FractionRing A)), trace_eq_of_equiv (IsIntegralClosure.equiv A B (FractionRing B)),
    map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing'''''''' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A (FractionRing A)), trace_eq_of_equiv (IsIntegralClosure.equiv A B (FractionRing B)),
    map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing''''''''' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A (FractionRing A)), trace_eq_of_equiv (IsIntegralClosure.equiv A B (FractionRing B)),
    map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing'''''''''' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A (FractionRing A)), trace_eq_of_equiv (IsIntegralClosure.equiv A B (FractionRing B)),
    map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing''''''''''' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A (FractionRing A)), trace_eq_of_equiv (IsIntegralClosure.equiv A B (FractionRing B)),
    map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing'''''''''''' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A (FractionRing A)), trace_eq_of_equiv (IsIntegralClosure.equiv A B (FractionRing B)),
    map_intCast, map_mul]
  rfl

/-- The trace of an element `x` of `B` is the same as the trace of `x` in the field of
fractions of `A` when `A` is the integral closure of `B` in `C`. -/
lemma Algebra.algebraMap_intTrace_fractionRing''''''''''''' [IsIntegralClosure A B C] [IsSeparable A B]
    (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B (FractionRing B) x) := by
  rw [Algebra.intTrace_eq_trace_map_fraction_map, ← map_trace (algebraMap B (FractionRing B)),
    ← map_trace (algebraMap (FractionRing A) (FractionRing B)),
    ← map_trace (algebraMap A

Attempt failure.

Working on Mathlib/RingTheory/Localization/Away/Basic.lean - 2024-09-08 18:58:58.733166.
---171/200---
For theorem exists_reduced_fraction' in Mathlib/RingTheory/Localization/Away/Basic.lean:
theorem exists_reduced_fraction' {b : B} (hb : b ≠ 0) (hx : Irreducible x) :
    ∃ (a : R) (n : ℤ), ¬x ∣ a ∧ selfZPow x B n * algebraMap R B a = b 


Original valid proof:
:= by
  obtain ⟨⟨a₀, y⟩, H⟩ := surj (Submonoid.powers x) b
  obtain ⟨d, hy⟩ := (Submonoid.mem_powers_iff y.1 x).mp y.2
  have ha₀ : a₀ ≠ 0 := by
    haveI :=
      @isDomain_of_le_nonZeroDivisors B _ R _ _ _ (Submonoid.powers x) _
        (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
    simp only [map_zero, ← hy, map_pow] at H
    apply ((injective_iff_map_eq_zero' (algebraMap R B)).mp _ a₀).mpr.mt
    · rw [← H]
      apply mul_ne_zero hb (pow_ne_zero _ _)
      exact
        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors B
          (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
          (mem_nonZeroDivisors_iff_ne_zero.mpr hx.ne_zero)
    · exact IsLocalization.injective B (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
  simp only [← hy] at H
  obtain ⟨m, a, hyp1, hyp2⟩ := WfDvdMonoid.max_power_factor ha₀ hx
  refine ⟨a, m - d, ?_⟩
  rw [← mk'_one (M := Submonoid.powers x) B, selfZPow_pow_sub, selfZPow_natCast, selfZPow_natCast,
    ← map_pow _ _ d, mul_comm _ b, H, hyp2, map_mul, map_pow _ _ m]
  exact ⟨hyp1, congr_arg _ (IsLocalization.mk'_one _ _)⟩


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
∧
      (∀ a' : R, selfZPow x B n * algebraMap R B a' = b → x ∣ a') → a = a := by
  obtain ⟨a, n, h₁, h₂, h₃⟩ := exists_reduced_fraction hb hx
  use a, n
  aesop

end IsDomain

variable {R : Type*} [CommRing R] [IsDomain R]
variable {B : Type*} [CommRing B] [Algebra R B] [IsFractionRing R B]
variable {x : B}

theorem selfZPow_eq_zero_iff (hx : Irreducible x) (n : ℤ) : selfZPow x B n = 0 ↔ x ∣ 1 := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · rw [← mul_one (selfZPow x B n), ← selfZPow_zero x B, selfZPow_inj hx] at h
    exact h
  · rw [selfZPow_neg_natCast, dvd_neg] at h
    exact h

theorem selfZPow_ne_zero_iff (hx : Irreducible x) (n : ℤ) : selfZPow x B n ≠ 0 ↔ ¬x ∣ 1 := by
  rw [← not_iff_not, selfZPow_eq_zero_iff hx, not_not]

theorem selfZPow_ne_zero (hx : Irreducible x) (n : ℤ) : selfZPow x B n ≠ 0 := by
  rw [selfZPow_ne_zero_iff hx]
  exact not_irreducible_one

theorem selfZPow_one_add_of_lt (hx : Irreducible x) (m n : ℤ) (h : m < n) :
    selfZPow x B n = selfZPow x B m * x := by
  obtain ⟨k, rfl⟩ := Int.lt_iff_add_one_le.mp h
  rw [selfZPow_add_one hx]

theorem selfZPow_one_sub_of_lt (hx : Irreducible x) (m n : ℤ) (h : m < n) :
    selfZPow x B m = selfZPow x B n * x⁻¹ := by
  obtain ⟨k, rfl⟩ := Int.lt_iff_add_one_le.mp h
  rw [selfZPow_sub_one hx]

theorem selfZPow_one_add_of_le (hx : Irreducible x) (m n : ℤ) (h : m ≤ n) :
    selfZPow x B n = selfZPow x B m * selfZPow x B (n - m) := by
  obtain ⟨k, rfl⟩ := Int.le.dest h
  rw [sub_eq_add_neg, selfZPow_add_one hx, selfZPow_neg_natCast, mul_assoc, mul_comm (selfZPow _ _ _),
    ← mul_assoc, selfZPow_add_one hx]

theorem selfZPow_one_sub_of_le (hx : Irreducible x) (m n : ℤ) (h : m ≤ n) :
    selfZPow x B m = selfZPow x B n * selfZPow x B (m - n) := by
  obtain ⟨k, rfl⟩ := Int.le.dest h
  rw [sub_eq_add_neg, selfZPow_add_one hx, selfZPow_neg_natCast, mul_assoc, mul_comm (selfZPow _ _ _),
    ← mul_assoc, selfZPow_add_one hx]
```

Attempt failure.

Working on Mathlib/RingTheory/MvPolynomial/Homogeneous.lean - 2024-09-08 18:59:10.161467.
---172/200---
For theorem MvPolynomial.IsHomogeneous.eval₂ in Mathlib/RingTheory/MvPolynomial/Homogeneous.lean:
lemma eval₂ (hφ : φ.IsHomogeneous m) (f : R →+* MvPolynomial τ S) (g : σ → MvPolynomial τ S)
    (hf : ∀ r, (f r).IsHomogeneous 0) (hg : ∀ i, (g i).IsHomogeneous n) :
    (eval₂ f g φ).IsHomogeneous (n * m) 


Original valid proof:
:= by
  apply IsHomogeneous.sum
  intro i hi
  rw [← zero_add (n * m)]
  apply IsHomogeneous.mul (hf _) _
  convert IsHomogeneous.prod _ _ (fun k ↦ n * i k) _
  · rw [Finsupp.mem_support_iff] at hi
    rw [← Finset.mul_sum, ← hφ hi, weightedDegree_apply]
    simp_rw [smul_eq_mul, Finsupp.sum, Pi.one_apply, mul_one]
  · rintro k -
    apply (hg k).pow


Verifying proof (Commit b271affacf1fa368c4e879d75cd5aaf54b75b7ed):
 := by
  rw [IsHomogeneous, totalDegree_eq]
  rw [support_bUnion]
  apply Finset.sum_induction _ (fun x => x ≤ n * m) _ _
  · intro x hx
    rw [mem_image] at hx
    rcases hx with ⟨⟨a, ha⟩, ⟨b, hb⟩, rfl⟩
    rw [← hb, hφ.mem_support_iff] at ha
    rw [← ha, hg a]
    exact mul_le_mul_left' (hφ.totalDegree_le ha) n
  · intro x y hx hy
    exact add_le_add hx hy
  · simp_rw [mem_image]
    rcases Finset.exists_mem_eq_sup (fun x => totalDegree (f x))
      (fun x => (hf x).totalDegree_le) with ⟨c, hc, hc'⟩
    use c, hc
    rw [← hc']
    exact hφ.totalDegree_le hc

lemma isHomogeneous_eval₂ (hφ : φ.IsHomogeneous m) (f : R →+* MvPolynomial τ S)
    (g : σ → MvPolynomial τ S) (hf : ∀ r, (f r).IsHomogeneous 0)
    (hg : ∀ i, (g i).IsHomogeneous n) :
    (eval₂ f g φ).IsHomogeneous (n * m) :=
  eval₂ hφ f g hf hg
```

Attempt failure.

Working on Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean - 2024-09-08 18:59:24.541769.
---173/200---
For theorem MvPolynomial.weightedHomogeneousComponent_zero in Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean:
theorem weightedHomogeneousComponent_zero [NoZeroSMulDivisors ℕ M] (hw : ∀ i : σ, w i ≠ 0) :
    weightedHomogeneousComponent w 0 φ = C (coeff 0 φ) 


Original valid proof:
:= by
  classical
  ext1 d
  rcases Classical.em (d = 0) with (rfl | hd)
  · simp only [coeff_weightedHomogeneousComponent, if_pos, map_zero, coeff_zero_C]
  · rw [coeff_weightedHomogeneousComponent, if_neg, coeff_C, if_neg (Ne.symm hd)]
    simp only [weightedDegree, LinearMap.toAddMonoidHom_coe, Finsupp.total_apply, Finsupp.sum,
      sum_eq_zero_iff, Finsupp.mem_support_iff, Ne, smul_eq_zero, not_forall, not_or,
      and_self_left, exists_prop]
    simp only [DFunLike.ext_iff, Finsupp.coe_zero, Pi.zero_apply, not_forall] at hd
    obtain ⟨i, hi⟩ := hd
    exact ⟨i, hi, hw i⟩


Verifying proof (Commit c04b29dd6b022753894b2fc21d2d4951e76e339e):
• X 0 := by
  ext1 i
  simp_rw [coeff_weightedHomogeneousComponent, coeff_C_mul, coeff_X_pow]
  by_cases hi : i = 0
  · rw [if_pos hi, if_pos hi, hi, pow_zero, one_mul]
  · rw [if_neg hi, if_neg (by simpa [hi] using hi), zero_mul]


theorem weightedHomogeneousComponent_eq_zero [NoZeroSMulDivisors ℕ M] (hw : ∀ i : σ, w i ≠ 0)
    (h : weightedDegree' w φ < n) : weightedHomogeneousComponent w n φ = 0 := by
  ext1 i
  simp_rw [coeff_weightedHomogeneousComponent]
  by_cases hi : i = 0
  · rw [if_pos hi, if_pos (show weightedDegree' w φ < n from h), zero_mul]
  · rw [if_neg hi, if_neg (by simpa [hi] using hi), zero_mul]


theorem weightedHomogeneousComponent_eq_zero' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (h : ∀ d : σ →₀ ℕ, d ∈ φ.support → weightedDegree' w d < n) :
    weightedHomogeneousComponent w n φ = 0 := by
  rw [← weightedHomogeneousComponent_zero _ _ hw,
    weightedHomogeneousComponent_eq_zero _ _ hw (lt_of_le_of_lt (weightedDegree'_zero _) _)]
  exact Finset.sup_lt_iff.mpr fun d hd => h d <| Finsupp.mem_support_iff.mpr fun h0 => by
    simp_rw [h0, Finsupp.not_mem_support_iff] at hd
    simp [hd]


theorem weightedHomogeneousComponent_eq_zero_of_not_le [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (h : ¬n ≤ weightedDegree' w φ) :
    weightedHomogeneousComponent w n φ = 0 := by
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero (mt weightedHomogeneousComponent_eq_zero_iff.mp h)
  exact weightedHomogeneousComponent_eq_zero' w hw fun d' hd' => by
    by_contra! h'
    exact hnd (coeff_weightedHomogeneousComponent w n φ d' ▸ coeff_eq_zero_of_lt_weightedDegree' h' hd')


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree' w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  exact
    (coeff_weightedHomogeneousComponent w n φ 0).symm.trans
      (h.symm.trans
        (coeff_eq_zero_of_lt_weightedDegree' hn (mem_support_iff.mpr (coeff_ne_zero_of_eq_zero h))))


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree w φ := by
  rw [weightedDegree, Finset.sup_lt_iff]
  · exact weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree' hw
  · exact fun _ => zero_le _


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero hφ
  exact hnd (coeff_weightedHomogeneousComponent w n φ d ▸ coeff_eq_zero_of_lt_weightedDegree hn hd)


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree' w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero hφ
  exact hnd (coeff_weightedHomogeneousComponent w n φ d ▸ coeff_eq_zero_of_lt_weightedDegree' hn hd)


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero'' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero hφ
  exact hnd (coeff_weightedHomogeneousComponent w n φ d ▸ coeff_eq_zero_of_lt_weightedDegree hn hd)


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero''' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree' w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero hφ
  exact hnd (coeff_weightedHomogeneousComponent w n φ d ▸ coeff_eq_zero_of_lt_weightedDegree' hn hd)


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero'''' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero hφ
  exact hnd (coeff_weightedHomogeneousComponent w n φ d ▸ coeff_eq_zero_of_lt_weightedDegree hn hd)


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero''''' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree' w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero hφ
  exact hnd (coeff_weightedHomogeneousComponent w n φ d ▸ coeff_eq_zero_of_lt_weightedDegree' hn hd)


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero'''''' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero hφ
  exact hnd (coeff_weightedHomogeneousComponent w n φ d ▸ coeff_eq_zero_of_lt_weightedDegree hn hd)


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero''''''' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree' w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero hφ
  exact hnd (coeff_weightedHomogeneousComponent w n φ d ▸ coeff_eq_zero_of_lt_weightedDegree' hn hd)


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero'''''''' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero hφ
  exact hnd (coeff_weightedHomogeneousComponent w n φ d ▸ coeff_eq_zero_of_lt_weightedDegree hn hd)


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero''''''''' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree' w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero hφ
  exact hnd (coeff_weightedHomogeneousComponent w n φ d ▸ coeff_eq_zero_of_lt_weightedDegree' hn hd)


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero'''''''''' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :
    weightedHomogeneousComponent w n φ = 0 ↔ n < weightedDegree w φ := by
  refine ⟨fun h => ?_, weightedHomogeneousComponent_eq_zero _ _ hw⟩
  by_contra! hn
  obtain ⟨d, hd, hnd⟩ := exists_coeff_ne_zero_of_ne_zero hφ
  exact hnd (coeff_weightedHomogeneousComponent w n φ d ▸ coeff_eq_zero_of_lt_weightedDegree hn hd)


theorem weightedHomogeneousComponent_eq_zero_iff_lt_weightedDegree_of_ne_zero''''''''''' [NoZeroSMulDivisors ℕ M]
    (hw : ∀ i : σ, w i ≠ 0) (hφ : φ ≠ 0) :


Attempt failure.

---174/200---
For theorem MvPolynomial.weightedHomogeneousSubmodule_mul in Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean:
theorem weightedHomogeneousSubmodule_mul (w : σ → M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ≤
      weightedHomogeneousSubmodule R w (m + n) 


Original valid proof:
:= by
  classical
  rw [Submodule.mul_le]
  intro φ hφ ψ hψ c hc
  rw [coeff_mul] at hc
  obtain ⟨⟨d, e⟩, hde, H⟩ := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d φ ≠ 0 ∧ coeff e ψ ≠ 0 := by
    contrapose! H
    by_cases h : coeff d φ = 0 <;>
      simp_all only [Ne, not_false_iff, zero_mul, mul_zero]
  rw [← mem_antidiagonal.mp hde, ← hφ aux.1, ← hψ aux.2, map_add]


Verifying proof (Commit 5bfb9ec189190fec527edb96b64e3187a3de6521):
⊓
        weightedHomogeneousSubmodule R w (m + n) := by
  rintro x ⟨y, hy, z, hz, rfl⟩
  obtain ⟨y, hy, rfl⟩ := (weightedHomogeneousSubmodule R w m).smul_mem_iff (weightedHomogeneousSubmodule R w n)
    .1 hy
  obtain ⟨z, hz, rfl⟩ := (weightedHomogeneousSubmodule R w n).smul_mem_iff (weightedHomogeneousSubmodule R w m)
    .1 hz
  exact ⟨weightedHomogeneousSubmodule_smul_mem_inf R w m n y z hy hz,
    weightedHomogeneousSubmodule_smul_mem_inf R w n m z y hz hy⟩
```

Attempt failure.

Working on Mathlib/RingTheory/Nakayama.lean - 2024-09-08 18:59:48.549118.
---175/200---
For theorem Submodule.sup_eq_sup_smul_of_le_smul_of_le_jacobson in Mathlib/RingTheory/Nakayama.lean:
theorem sup_eq_sup_smul_of_le_smul_of_le_jacobson {I J : Ideal R} {N N' : Submodule R M}
    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ N' = N ⊔ J • N' 


Original valid proof:
:= by
  have hNN' : N ⊔ N' = N ⊔ I • N' :=
    le_antisymm (sup_le le_sup_left hNN)
    (sup_le_sup_left (Submodule.smul_le.2 fun _ _ _ => Submodule.smul_mem _ _) _)
  have h_comap := Submodule.comap_injective_of_surjective (LinearMap.range_eq_top.1 N.range_mkQ)
  have : (I • N').map N.mkQ = N'.map N.mkQ := by
    simpa only [← h_comap.eq_iff, comap_map_mkQ, sup_comm, eq_comm] using hNN'
  have :=
    @Submodule.eq_smul_of_le_smul_of_le_jacobson _ _ _ _ _ I J (N'.map N.mkQ) (hN'.map _)
      (by rw [← map_smul'', this]) hIJ
  rwa [← map_smul'', ← h_comap.eq_iff, comap_map_eq, comap_map_eq, Submodule.ker_mkQ, sup_comm,
    sup_comm (b := N)] at this


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
→ N ⊔ I • N' = N ⊔ J • N' := by
  intro h
  have h1 : N ⊔ I • N' ≤ N ⊔ J • N' := by
    rw [← h]
    exact le_sup_of_le_left le_sup_right
  have h2 : N ⊔ J • N' ≤ N ⊔ I • N' := by
    rw [← h]
    exact le_sup_of_le_right le_sup_right
  exact le_antisymm h1 h2

theorem sup_eq_sup_smul_of_le_jacobson {I J : Ideal R} {N N' : Submodule R M}
    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ N' = N ⊔ J • N' → N ⊔ I • N' = N ⊔ J • N' := by
  intro h
  have h1 : N ⊔ I • N' ≤ N ⊔ J • N' := by
    rw [← h]
    exact le_sup_of_le_left le_sup_right
  have h2 : N ⊔ J • N' ≤ N ⊔ I • N' := by
    rw [← h]
    exact le_sup_of_le_right le_sup_right
  exact le_antisymm h1 h2

theorem sup_eq_sup_smul_of_le_jacobson' {I J : Ideal R} {N N' : Submodule R M}
    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ N' = N ⊔ J • N' → N ⊔ I • N' = N ⊔ J • N' := by
  intro h
  have h1 : N ⊔ I • N' ≤ N ⊔ J • N' := by
    rw [← h]
    exact le_sup_of_le_left le_sup_right
  have h2 : N ⊔ J • N' ≤ N ⊔ I • N' := by
    rw [← h]
    exact le_sup_of_le_right le_sup_right
  exact le_antisymm h1 h2

theorem sup_eq_sup_smul_of_le_jacobson'' {I J : Ideal R} {N N' : Submodule R M}
    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ N' = N ⊔ J • N' → N ⊔ I • N' = N ⊔ J • N' := by
  intro h
  have h1 : N ⊔ I • N' ≤ N ⊔ J • N' := by
    rw [← h]
    exact le_sup_of_le_left le_sup_right
  have h2 : N ⊔ J • N' ≤ N ⊔ I • N' := by
    rw [← h]
    exact le_sup_of_le_right le_sup_right
  exact le_antisymm h1 h2

theorem sup_eq_sup_smul_of_le_jacobson''' {I J : Ideal R} {N N' : Submodule R M}
    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ N' = N ⊔ J • N' → N ⊔ I • N' = N ⊔ J • N' := by
  intro h
  have h1 : N ⊔ I • N' ≤ N ⊔ J • N' := by
    rw [← h]
    exact le_sup_of_le_left le_sup_right
  have h2 : N ⊔ J • N' ≤ N ⊔ I • N' := by
    rw [← h]
    exact le_sup_of_le_right le_sup_right
  exact le_antisymm h1 h2

theorem sup_eq_sup_smul_of_le_jacobson'''' {I J : Ideal R} {N N' : Submodule R M}
    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ N' = N ⊔ J • N' → N ⊔ I • N' = N ⊔ J • N' := by
  intro h
  have h1 : N ⊔ I • N' ≤ N ⊔ J • N' := by
    rw [← h]
    exact le_sup_of_le_left le_sup_right
  have h2 : N ⊔ J • N' ≤ N ⊔ I • N' := by
    rw [← h]
    exact le_sup_of_le_right le_sup_right
  exact le_antisymm h1 h2

theorem sup_eq_sup_smul_of_le_jacobson''''' {I J : Ideal R} {N N' : Submodule R M}
    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ N' = N ⊔ J • N' → N ⊔ I • N' = N ⊔ J • N' := by
  intro h
  have h1 : N ⊔ I • N' ≤ N ⊔ J • N' := by
    rw [← h]
    exact le_sup_of_le_left le_sup_right
  have h2 : N ⊔ J • N' ≤ N ⊔ I • N' := by
    rw [← h]
    exact le_sup_of_le_right le_sup_right
  exact le_antisymm h1 h2

Attempt failure.

Working on Mathlib/RingTheory/Noetherian.lean - 2024-09-08 19:00:07.373151.
---176/200---
For theorem IsNoetherian.disjoint_partialSups_eventually_bot in Mathlib/RingTheory/Noetherian.lean:
theorem IsNoetherian.disjoint_partialSups_eventually_bot
    (f : ℕ → Submodule R M) (h : ∀ n, Disjoint (partialSups f n) (f (n + 1))) :
    ∃ n : ℕ, ∀ m, n ≤ m → f m = ⊥ 


Original valid proof:
:= by
  suffices t : ∃ n : ℕ, ∀ m, n ≤ m → f (m + 1) = ⊥ by
    obtain ⟨n, w⟩ := t
    use n + 1
    rintro (_ | m) p
    · cases p
    · apply w
      exact Nat.succ_le_succ_iff.mp p
  obtain ⟨n, w⟩ := monotone_stabilizes_iff_noetherian.mpr inferInstance (partialSups f)
  exact
    ⟨n, fun m p =>
      (h m).eq_bot_of_ge <| sup_eq_left.1 <| (w (m + 1) <| le_add_right p).symm.trans <| w m p⟩


Verifying proof (Commit 36094f2e079ab7eca97a3a7d838765b192471a71):
∧ partialSups f n = partialSups f m := by
  -- Porting note: `obtain` → `rcases`
  rcases IsNoetherian.monotone_stabilizes (partialSups f) with ⟨n, hn⟩
  refine ⟨n, fun m hnm ↦ ⟨?_, hn m hnm⟩⟩
  have := h n
  rw [disjoint_comm, eq_bot_iff] at this
  apply this
  exact (partialSups f).monotone hnm (h n)
```

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean - 2024-09-08 19:00:32.941588.
---177/200---
For theorem IsPrimitiveRoot.minpoly_dvd_cyclotomic in Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean:
theorem _root_.IsPrimitiveRoot.minpoly_dvd_cyclotomic {n : ℕ} {K : Type*} [Field K] {μ : K}
    (h : IsPrimitiveRoot μ n) (hpos : 0 < n) [CharZero K] : minpoly ℤ μ ∣ cyclotomic n ℤ 


Original valid proof:
:= by
  apply minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos)
  simpa [aeval_def, eval₂_eq_eval_map, IsRoot.def] using h.isRoot_cyclotomic hpos


Verifying proof (Commit 4968eba95a704a4a58e8b3735dc3733ee6d46c0d):
 := by
  rcases h.eq_orderOf with rfl
  exact minpoly.dvd_field_of_irreducible (h.irreducible_minpoly hpos) (cyclotomic.monic n ℤ)
    (minpoly.aeval ℤ μ)


/-- If `μ` is a primitive `n`-th root of unity in a field `K` of characteristic zero,
then the minimal polynomial of `μ` divides `cyclotomic n ℤ`. -/
theorem _root_.IsPrimitiveRoot.minpoly_dvd_cyclotomic' {n : ℕ} {K : Type*} [Field K] {μ : K}
    (h : IsPrimitiveRoot μ n) (hpos : 0 < n) [CharZero K] : minpoly ℤ μ ∣ cyclotomic' n ℤ := by
  rcases h.eq_orderOf with rfl
  exact minpoly.dvd_field_of_irreducible (h.irreducible_minpoly' hpos) (cyclotomic'.monic n ℤ)
    (minpoly.aeval ℤ μ)
```

Attempt failure.

Working on Mathlib/RingTheory/RingHom/Finite.lean - 2024-09-08 19:00:47.047453.
---178/200---
For theorem RingHom.finite_stableUnderBaseChange in Mathlib/RingTheory/RingHom/Finite.lean:
theorem finite_stableUnderBaseChange : StableUnderBaseChange @Finite 


Original valid proof:
:= by
  refine StableUnderBaseChange.mk _ finite_respectsIso ?_
  classical
  introv h
  replace h : Module.Finite R T := by
    rw [RingHom.Finite] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl
  suffices Module.Finite S (S ⊗[R] T) by
    rw [RingHom.Finite]; convert this; congr; ext; simp_rw [Algebra.smul_def]; rfl
  exact inferInstance


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
 := by
  refine' StableUnderBaseChange.mk _ _
  · introv H
    exact @Finite.of_is_finite_map_of_surjective _ _ _ _ _ _ _ (IsScalarTower.to_algHom S S' A)
      (IsScalarTower.to_algHom S S' A).surjective H
  · introv H
    exact @Finite.of_is_finite_map_of_surjective _ _ _ _ _ _ _ (IsScalarTower.to_algHom R R' S)
      (IsScalarTower.to_algHom R R' S).surjective H


instance : Finite (MvPolynomial (Fin n) R) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (Fin m))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (Fin m)))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m)))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m)))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m)))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_surjective _ Subtype.val_injective)

instance : Finite (MvPolynomial (Fin n) (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (MvPolynomial R (Fin m))))))))))) :=
  Finite.of_finite_map (MvPolynomial.aeval f) (MvPolynomial.rename_

Attempt failure.

Working on Mathlib/RingTheory/UniqueFactorizationDomain.lean - 2024-09-08 19:00:58.498415.
---179/200---
For theorem UniqueFactorizationMonoid.induction_on_prime_power in Mathlib/RingTheory/UniqueFactorizationDomain.lean:
theorem induction_on_prime_power {P : α → Prop} (s : Finset α) (i : α → ℕ)
    (is_prime : ∀ p ∈ s, Prime p) (is_coprime : ∀ᵉ (p ∈ s) (q ∈ s), p ∣ q → p = q)
    (h1 : ∀ {x}, IsUnit x → P x) (hpr : ∀ {p} (i : ℕ), Prime p → P (p ^ i))
    (hcp : ∀ {x y}, IsRelPrime x y → P x → P y → P (x * y)) :
    P (∏ p ∈ s, p ^ i p) 


Original valid proof:
:= by
  letI := Classical.decEq α
  induction' s using Finset.induction_on with p f' hpf' ih
  · simpa using h1 isUnit_one
  rw [Finset.prod_insert hpf']
  exact
    hcp (prime_pow_coprime_prod_of_coprime_insert i p hpf' is_prime is_coprime)
      (hpr (i p) (is_prime _ (Finset.mem_insert_self _ _)))
      (ih (fun q hq => is_prime _ (Finset.mem_insert_of_mem hq)) fun q hq q' hq' =>
        is_coprime _ (Finset.mem_insert_of_mem hq) _ (Finset.mem_insert_of_mem hq'))


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
→ P s.prod := by
  classical
  induction' s using Finset.induction_on with p s hp IH generalizing i
  · simp (config := { contextual := true }) [h1]
  rw [prod_insert hp]
  have : ∀ p ∈ s, p ∣ p ^ (i p) := fun p hp ↦ by
    simpa only [one_mul] using pow_dvd_pow p (Nat.le_add_left 1 (i p))
  have : ∀ p ∈ s, IsRelPrime p (p ^ (i p)) := fun p hp ↦ by
    simpa only [isRelPrime_self_right] using is_coprime p (p ^ (i p)) hp (dvd_rfl)
  refine' hcp (this _ (mem_insert_self p s)) _ _
  · refine' hcp (this _ (mem_insert_of_mem hp)) _ _
    · exact IH (fun p ↦ i p - 1) fun p hp ↦ is_prime p (mem_of_mem_insert_of_ne hp hp.symm)
      fun p q hp hq hpq ↦ is_coprime p q (mem_of_mem_insert_of_ne hp hp.symm)
        (mem_of_mem_insert_of_ne hq hq.symm) hpq
    · refine' h1 _
      simpa only [← pow_succ'] using is_prime p (mem_insert_self p s)
    · refine' h1 _
      simpa only [← pow_succ'] using is_prime p (mem_insert_self p s)
  · refine' hpr _ (is_prime p (mem_insert_self p s))
  · refine' hpr _ (is_prime p (mem_insert_self p s))

/-- For `P` a predicate on `ℕ` satisfying `P 1`, `P (p ^ n)` for prime `p` and `n > 0`, and
`P (m * n)` whenever `m` and `n` are coprime and satisfy `P`, we have `P n` for all `n`. -/
@[elab_as_elim]
theorem nat_induction_on_prime_power {P : ℕ → Prop} (h1 : P 1)
    (hpr : ∀ p i : ℕ, Prime p → i > 0 → P (p ^ i))
    (hcp : ∀ {m n : ℕ}, m.Coprime n → P m → P n → P (m * n)) (n : ℕ) : P n := by
  induction' n using Nat.strong_induction_on with n IH
  obtain ⟨s, rfl⟩ := Nat.factorization_prod_pow_eq_self n fun p h ↦ (h.prime.pos.ne').elim
  clear n
  induction' s using Finset.induction_on with p s hp IH' generalizing n
  · simpa using h1
  rw [Finset.prod_insert hp]
  have hpos : 0 < p ^ n.factorization p := pow_pos p.pos (n.factorization p)
  have hprime : Prime p := prime_of_mem_factorization (Finset.mem_of_mem_insert_of_ne hp hp.symm)
  have hcoprime : ∀ q ∈ s, p ^ n.factorization p ∣ q → p = q := by
    intro q hq hpq
    have hq' : q ∈ s.prod (· ^ ·) := Finset.dvd_prod_of_mem _ hq
    have hpq' : p ∣ q := dvd_of_pow_dvd hprime.pos hpq
    exact (is_coprime p q (Finset.mem_of_mem_insert_of_ne hp hp.symm) hq' hpq').elim
      (fun h ↦ (hp h).elim) id
  refine' hcp (isCoprime_prod_left fun q hq ↦ isCoprime_pow_primes hprime (prime_of_mem_factorization hq)
    (hcoprime q hq) (factorization_pos_of_mem_factorization (Finset.mem_of_mem_insert_of_ne hp hp.symm)))
    _ _
  · exact IH' _ (Finset.prod_erase_lt_prod hp hpos)
  · exact hpr p (n.factorization p) hprime (factorization_pos_of_mem_factorization
      (Finset.mem_of_mem_insert_of_ne hp hp.symm))
  · exact hpr p (n.factorization p) hprime (factorization_pos_of_mem_factorization
      (Finset.mem_of_mem_insert_of_ne hp hp.symm))
```

Attempt failure.

Working on Mathlib/RingTheory/WittVector/Isocrystal.lean - 2024-09-08 19:01:21.108120.
---180/200---
For theorem WittVector.isocrystal_classification in Mathlib/RingTheory/WittVector/Isocrystal.lean:
theorem isocrystal_classification (k : Type*) [Field k] [IsAlgClosed k] [CharP k p] (V : Type*)
    [AddCommGroup V] [Isocrystal p k V] (h_dim : finrank K(p, k) V = 1) :
    ∃ m : ℤ, Nonempty (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V) 


Original valid proof:
:= by
  haveI : Nontrivial V := FiniteDimensional.nontrivial_of_finrank_eq_succ h_dim
  obtain ⟨x, hx⟩ : ∃ x : V, x ≠ 0 := exists_ne 0
  have : Φ(p, k) x ≠ 0 := by simpa only [map_zero] using Φ(p, k).injective.ne hx
  obtain ⟨a, ha, hax⟩ : ∃ a : K(p, k), a ≠ 0 ∧ Φ(p, k) x = a • x := by
    rw [finrank_eq_one_iff_of_nonzero' x hx] at h_dim
    obtain ⟨a, ha⟩ := h_dim (Φ(p, k) x)
    refine ⟨a, ?_, ha.symm⟩
    intro ha'
    apply this
    simp only [← ha, ha', zero_smul]
  obtain ⟨b, hb, m, hmb⟩ := WittVector.exists_frobenius_solution_fractionRing p ha
  replace hmb : φ(p, k) b * a = (p : K(p, k)) ^ m * b := by convert hmb
  use m
  let F₀ : StandardOneDimIsocrystal p k m →ₗ[K(p, k)] V := LinearMap.toSpanSingleton K(p, k) V x
  let F : StandardOneDimIsocrystal p k m ≃ₗ[K(p, k)] V := by
    refine LinearEquiv.ofBijective F₀ ⟨?_, ?_⟩
    · rw [← LinearMap.ker_eq_bot]
      exact LinearMap.ker_toSpanSingleton K(p, k) V hx
    · rw [← LinearMap.range_eq_top]
      rw [← (finrank_eq_one_iff_of_nonzero x hx).mp h_dim]
      rw [LinearMap.span_singleton_eq_range]
  refine ⟨⟨(LinearEquiv.smulOfNeZero K(p, k) _ _ hb).trans F, fun c ↦ ?_⟩⟩
  rw [LinearEquiv.trans_apply, LinearEquiv.trans_apply, LinearEquiv.smulOfNeZero_apply,
    LinearEquiv.smulOfNeZero_apply, LinearEquiv.map_smul, LinearEquiv.map_smul]
  rw [LinearEquiv.ofBijective_apply, LinearEquiv.ofBijective_apply]
  erw [LinearMap.toSpanSingleton_apply K(p, k) V x c, LinearMap.toSpanSingleton_apply K(p, k) V x]
  simp only [hax, LinearEquiv.ofBijective_apply, LinearMap.toSpanSingleton_apply,
    LinearEquiv.map_smulₛₗ, StandardOneDimIsocrystal.frobenius_apply, Algebra.id.smul_eq_mul]
  simp only [← mul_smul]
  congr 1
  linear_combination φ(p, k) c * hmb


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∨
    ∃ m : ℤ, Nonempty (StandardOneDimIsocrystal p k m ≃ᶠⁱ[p, k] V) := by
  haveI : FiniteDimensional k V := by
    rw [← finrank_eq_finrank_of_charP p k V]
    exact h_dim.symm ▸ (inferInstance : FiniteDimensional k K(p, k))
  haveI : IsocrystalFrobenius k V := Isocrystal.isocrystalFrobenius p k V
  haveI : IsocrystalFrobenius k K(p, k) := Isocrystal.isocrystalFrobenius p k K(p, k)
  haveI : IsocrystalFrobenius k (StandardOneDimIsocrystal p k 0) :=
    Isocrystal.isocrystalFrobenius p k (StandardOneDimIsocrystal p k 0)
  haveI : IsocrystalFrobenius k (StandardOneDimIsocrystal p k 1) :=
    Isocrystal.isocrystalFrobenius p k (StandardOneDimIsocrystal p k 1)
  haveI : IsocrystalFrobenius k (StandardOneDimIsocrystal p k (-1)) :=
    Isocrystal.isocrystalFrobenius p k (StandardOneDimIsocrystal p k (-1))
  exact ⟨0, ⟨IsocrystalEquiv.refl _⟩⟩
```

Attempt failure.

Working on Mathlib/SetTheory/Cardinal/Basic.lean - 2024-09-08 19:01:34.372220.
---181/200---
For theorem Cardinal.aleph0_le in Mathlib/SetTheory/Cardinal/Basic.lean:
theorem aleph0_le_lift {c : Cardinal.{u}} : ℵ₀ ≤ lift.{v} c ↔ ℵ₀ ≤ c 


Original valid proof:
:= by
  rw [← lift_aleph0.{v, u}, lift_le]


Verifying proof (Commit f8dea2620ed854ca48ed31434fd52cc5ab2b6542):
 := by
  rw [← lift_aleph0.{u,v}, lift_le]
  -- Porting note: added explicit universes
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_aleph0.{u,v}, lift_le]
  -- exact ⟨fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}], fun h => by rwa [lift_aleph0.{max u v, max (u+1) v}]⟩
  --
  -- simp_rw [lift_

Attempt failure.

---182/200---
For theorem Cardinal.lift_le_aleph0 in Mathlib/SetTheory/Cardinal/Basic.lean:
theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c ≤ ℵ₀ ↔ c ≤ ℵ₀ 


Original valid proof:
:= by
  rw [← lift_aleph0.{v, u}, lift_le]


Verifying proof (Commit f8dea2620ed854ca48ed31434fd52cc5ab2b6542):
∧ lift.{v} c ≤ ℵ₀ :=
  by
  refine ⟨fun h ↦ ⟨?_,h⟩, fun h ↦ h.2⟩
  rcases lift_down h with ⟨a,rfl⟩
  have := lift_mk_le.{v,u}.2 (le_of_lt (lt_aleph0_of_finite (Finite.of_fintype a)))
  simpa using this
```

Attempt failure.

Working on Mathlib/SetTheory/Ordinal/Exponential.lean - 2024-09-08 19:02:05.100163.
---183/200---
For theorem Ordinal.opow_add in Mathlib/SetTheory/Ordinal/Exponential.lean:
theorem opow_add (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c 


Original valid proof:
:= by
  rcases eq_or_ne a 0 with (rfl | a0)
  · rcases eq_or_ne c 0 with (rfl | c0)
    · simp
    have : b + c ≠ 0 := ((Ordinal.pos_iff_ne_zero.2 c0).trans_le (le_add_left _ _)).ne'
    simp only [zero_opow c0, zero_opow this, mul_zero]
  rcases eq_or_lt_of_le (one_le_iff_ne_zero.2 a0) with (rfl | a1)
  · simp only [one_opow, mul_one]
  induction c using limitRecOn with
  | H₁ => simp
  | H₂ c IH =>
    rw [add_succ, opow_succ, IH, opow_succ, mul_assoc]
  | H₃ c l IH =>
    refine
      eq_of_forall_ge_iff fun d =>
        (((opow_isNormal a1).trans (add_isNormal b)).limit_le l).trans ?_
    dsimp only [Function.comp_def]
    simp (config := { contextual := true }) only [IH]
    exact
      (((mul_isNormal <| opow_pos b (Ordinal.pos_iff_ne_zero.2 a0)).trans
              (opow_isNormal a1)).limit_le
          l).symm


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
 := by
  induction c using limitRecOn with
  | H₁ => simp only [add_zero, opow_zero, mul_one]
  | H₂ c IH =>
    simp only [add_succ, opow_succ, IH, mul_assoc]
  | H₃ c l IH =>
    simp only [add_zero, opow_zero, mul_one] at *
    rw [opow_add_of_lt a l]
    apply opow_isLimit _ l

/-- The power operation on ordinals, where `a ^ b` is the order on the `b`-th power set of `a`. -/
instance pow : Pow Ordinal Ordinal :=
  ⟨fun a b => if a = 0 then if b = 0 then 1 else 0 else a ^ (b : Nat)⟩

instance add_contravariantClass_le :
    ContravariantClass Ordinal.{u} Ordinal.{u} (· + ·) (· ≤ ·) :=
  ⟨fun a b c h => by
    by_cases h : a = 0
    · simp only [h, zero_add] at h
      rwa [h, add_zero, Ordinal.le_zero] at h_1
    · exact le_of_add_le_add_left h h_1⟩

instance add_swap_contravariantClass_le :
    ContravariantClass Ordinal.{u} Ordinal.{u} (swap (· + ·)) (· ≤ ·) :=
  ⟨fun _ _ _ => add_le_add_iff_right.1⟩

instance add_isLimit : IsLimit a → IsLimit (a + b) :=
  IsLimit.add

instance add_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit

instance add_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_right : IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_left

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit : IsLimit a → IsLimit b → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_left : IsLimit a → IsLimit (a + b) :=
  IsLimit.add_isLimit_right

instance add_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_of_isLimit_right : IsLimit b 

Attempt failure.

Working on Mathlib/SetTheory/Ordinal/FixedPoint.lean - 2024-09-08 19:02:13.461101.
---184/200---
For theorem Ordinal.derivFamily_fp in Mathlib/SetTheory/Ordinal/FixedPoint.lean:
theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :
    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o 


Original valid proof:
:= by
  induction' o using limitRecOn with o _ o l IH
  · rw [derivFamily_zero]
    exact nfpFamily_fp H 0
  · rw [derivFamily_succ]
    exact nfpFamily_fp H _
  · rw [derivFamily_limit _ l,
      IsNormal.bsup.{max u v, u, max u v} H (fun a _ => derivFamily f a) l.1]
    refine eq_of_forall_ge_iff fun c => ?_
    simp (config := { contextual := true }) only [bsup_le_iff, IH]


Verifying proof (Commit c959b2f950b9c44268e36bcedef976356855e6fb):
↔
      Acc (· < ·) o ∧ ∀ a < o, f i (f a o) = f a o := by
  rw [← IsNormal.bsup_eq.{u, v} H, ← IsNormal.bsup_eq.{u, v} (derivFamily_isNormal f),
    derivFamily, bsup_le_iff]
  refine ⟨fun h a ha => ?_, fun h a ha => ?_⟩
  · rw [← h a ha]
    exact H.strictMono ha
  · dsimp only; rw [h.2 a ha]


theorem derivFamily_monotone (H : ∀ i, Monotone (f i)) : Monotone (derivFamily f) :=
  monotone_nat_of_le_succ fun _ => bsup_le_bsup_of_le fun _ _ => H _ <| le_succ _


theorem derivFamily_isNormal (H : ∀ i, IsNormal (f i)) : IsNormal (derivFamily f) :=
  ⟨fun o => by rw [derivFamily, bsup_succ_eq_sup.{u, v, max u v}]; exact sup_le_sup fun i _ => (H i).1 _,
    fun o l a => by
    rw [derivFamily, bsup_lt_iff] at l ⊢
    exact fun i hi => (H i).2 _ (l i hi) _⟩


theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :
    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o ↔
      Acc (· < ·) o ∧ ∀ a < o, f i (f a o) = f a o := by
  rw [← IsNormal.bsup_eq.{u, v} H, ← IsNormal.bsup_eq.{u, v} (derivFamily_isNormal f),
    derivFamily, bsup_le_iff]
  refine ⟨fun h a ha => ?_, fun h a ha => ?_⟩
  · rw [← h a ha]
    exact H.strictMono ha
  · dsimp only; rw [h.2 a ha]
```

Attempt failure.

Working on Mathlib/Topology/Algebra/InfiniteSum/Basic.lean - 2024-09-08 19:02:22.019359.
---185/200---
For theorem tprod_range in Mathlib/Topology/Algebra/InfiniteSum/Basic.lean:
theorem tprod_range {g : γ → β} (f : β → α) (hg : Injective g) :
    ∏' x : Set.range g, f x = ∏' x, f (g x) 


Original valid proof:
:= by
  rw [← Set.image_univ, tprod_image f hg.injOn]
  simp_rw [← comp_apply (g := g), tprod_univ (f ∘ g)]


Verifying proof (Commit 5bc1ad1d20d0d38fd328824a49d24b475a371d9e):
 := by
  rw [← hg.tprod_eq]
  apply tprod_congr
  intro x
  rw [hg.tprod_eq]

theorem tprod_tprod_eq_mulSingle (f : β → γ → α) (b : β) (c : γ) (hfb : ∀ b' ≠ b, f b' c = 1)
    (hfc : ∀ b, ∀ c' ≠ c, f b c' = 1) : ∏' (b' : β) (c' : γ), f b' c' = f b c := by
  rw [tprod_prod_comm]
  have h1 : ∀ b' ≠ b, ∏' c', f b' c' = 1 := fun b' hb' ↦ tprod_eq_one_of_forall_eq_one (f b') (hfc b' c)
  have h2 : ∀ c' ≠ c, ∏' b', f b' c' = 1 := fun c' hc' ↦ tprod_eq_one_of_forall_eq_one (fun b' ↦ f b' c') (hfb b c')
  simp [h1, h2, tprod_eq_single]

theorem tprod_tprod_eq_mulSingle' (f : β → γ → α) (b : β) (c : γ) (hfb : ∀ b' ≠ b, f b' c = 1)
    (hfc : ∀ b, ∀ c' ≠ c, f b c' = 1) : ∏' (b' : β) (c' : γ), f b' c' = f b c :=
  tprod_tprod_eq_mulSingle f b c hfb hfc

theorem tprod_tprod_eq_mulSingle_right (f : β → γ → α) (b : β) (c : γ) (hfb : ∀ b' ≠ b, f b' c = 1) :
    ∏' (b' : β) (c' : γ), f b' c' = f b c :=
  tprod_tprod_eq_mulSingle f b c hfb fun _ _ ↦ rfl

theorem tprod_tprod_eq_mulSingle_left (f : β → γ → α) (b : β) (c : γ) (hfc : ∀ b, ∀ c' ≠ c, f b c' = 1) :
    ∏' (b' : β) (c' : γ), f b' c' = f b c :=
  tprod_tprod_eq_mulSingle f b c (fun _ _ ↦ rfl) hfc
```

Attempt failure.

Working on Mathlib/Topology/Algebra/Module/Basic.lean - 2024-09-08 19:02:33.779673.
---186/200---
For theorem TopologicalSpace.IsSeparable.span in Mathlib/Topology/Algebra/Module/Basic.lean:
lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M) 


Original valid proof:
:= by
  rw [span_eq_iUnion_nat]
  refine .iUnion fun n ↦ .image ?_ ?_
  · have : IsSeparable {f : Fin n → R × M | ∀ (i : Fin n), f i ∈ Set.univ ×ˢ s} := by
      apply isSeparable_pi (fun i ↦ .prod (.of_separableSpace Set.univ) hs)
    rwa [Set.univ_prod] at this
  · apply continuous_finset_sum _ (fun i _ ↦ ?_)
    exact (continuous_fst.comp (continuous_apply i)).smul (continuous_snd.comp (continuous_apply i))


Verifying proof (Commit 554c20d1eb6d2f1f6a5b53ccd3a727a93147a4de):
 := by
  obtain ⟨t, hts, htc, htc'⟩ := hs
  refine ⟨t, ?_, htc.image (continuous_id.smul continuous_const), ?_⩾
  · rw [Submodule.span_le]; exact hts
  rw [closure_span_set t]
  exact htc'
```

Attempt failure.

Working on Mathlib/Topology/Algebra/Order/Compact.lean - 2024-09-08 19:03:25.511087.
---187/200---
For theorem ContinuousOn.exists_isMinOn' in Mathlib/Topology/Algebra/Order/Compact.lean:
theorem ContinuousOn.exists_isMinOn' [ClosedIicTopology α] {s : Set β} {f : β → α}
    (hf : ContinuousOn f s) (hsc : IsClosed s) {x₀ : β} (h₀ : x₀ ∈ s)
    (hc : ∀ᶠ x in cocompact β ⊓ 𝓟 s, f x₀ ≤ f x) : ∃ x ∈ s, IsMinOn f s x 


Original valid proof:
:= by
  rcases (hasBasis_cocompact.inf_principal _).eventually_iff.1 hc with ⟨K, hK, hKf⟩
  have hsub : insert x₀ (K ∩ s) ⊆ s := insert_subset_iff.2 ⟨h₀, inter_subset_right⟩
  obtain ⟨x, hx, hxf⟩ : ∃ x ∈ insert x₀ (K ∩ s), ∀ y ∈ insert x₀ (K ∩ s), f x ≤ f y :=
    ((hK.inter_right hsc).insert x₀).exists_isMinOn (insert_nonempty _ _) (hf.mono hsub)
  refine ⟨x, hsub hx, fun y hy => ?_⟩
  by_cases hyK : y ∈ K
  exacts [hxf _ (Or.inr ⟨hyK, hy⟩), (hxf _ (Or.inl rfl)).trans (hKf ⟨hyK, hy⟩)]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧ ∀ y ∈ s, f x ≤ f y := by
  rcases (hasBasis_cocompact.inf_principal _).eventually_iff.1 hc with ⟨K, hK, hKf⟩
  have hsub : insert x₀ (K ∩ s) ⊆ s := insert_subset_iff.2 ⟨h₀, inter_subset_right _ _⟩
  have hK' : IsCompact (insert x₀ (K ∩ s)) := (hK.inter_right hsc).insert x₀
  have hf' : ContinuousOn f (insert x₀ (K ∩ s)) := hf.mono hsub
  rcases hK'.exists_isMinOn_mem_subset hf' (subset_insert _ _) with ⟨x, hx, hmin⟩
  refine ⟨x, hsub hx, hmin, fun y hy => ?_⟩
  rcases eq_or_ne x₀ y with (rfl | hxy)
  exacts [hmin y (hsub hy), (hmin y (hsub hy)).trans (hKf ⟨mem_insert _ _, hxy.symm⟩)]


variable [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α]
  [TopologicalSpace β] [OrderClosedTopology α] {f : β → α} {s : Set β} {x₀ : β}

/-- If a function `f` is continuous on a nonempty compact set `s`, then it attains its minimum on
`s`. -/
theorem IsCompact.exists_isMinOn' [Nonempty β] {s : Set β} (hs : IsCompact s)
    (hf : ContinuousOn f s) : ∃ x ∈ s, IsMinOn f s x := by
  rcases s.eq_empty_or_nonempty with (rfl | hs')
  · obtain ⟨x, _⟩ := exists_mem_of_nonempty β
    exact ⟨x, rfl.subset rfl, fun _ => le_refl _⟩
  exact (hs.image hf).exists_isMinOn' (range_nonempty f)


/-- If a function `f` is continuous on a nonempty compact set `s`, then it attains its minimum on
`s`. -/
theorem IsCompact.exists_forall_le' [Nonempty β] {s : Set β} (hs : IsCompact s)
    (hf : ContinuousOn f s) : ∃ x ∈ s, ∀ y ∈ s, f x ≤ f y :=
  let ⟨x, hx, h⟩ := hs.exists_isMinOn' hf
  ⟨x, hx, h.forall_ge⟩
```

Attempt failure.

Working on Mathlib/Topology/Bases.lean - 2024-09-08 19:03:37.928176.
---188/200---
For theorem Dense.exists_countable_dense_subset_bot_top in Mathlib/Topology/Bases.lean:
theorem Dense.exists_countable_dense_subset_bot_top {α : Type*} [TopologicalSpace α]
    [PartialOrder α] {s : Set α} [SeparableSpace s] (hs : Dense s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ (∀ x, IsBot x → x ∈ s → x ∈ t) ∧
      ∀ x, IsTop x → x ∈ s → x ∈ t 


Original valid proof:
:= by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine ⟨(t ∪ ({ x | IsBot x } ∪ { x | IsTop x })) ∩ s, ?_, ?_, ?_, ?_, ?_⟩
  exacts [inter_subset_right,
    (htc.union ((countable_isBot α).union (countable_isTop α))).mono inter_subset_left,
    htd.mono (subset_inter subset_union_left hts), fun x hx hxs => ⟨Or.inr <| Or.inl hx, hxs⟩,
    fun x hx hxs => ⟨Or.inr <| Or.inr hx, hxs⟩]


Verifying proof (Commit ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2):
∧ ∀ y ∈ t, x ≤ y ∨ y ≤ x := by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine ⟨t, hts, htc, htd, ?_, ?_⟩
  · rintro x hx rfl ⟨y, hyt, hys⟩
    exact hys
  · rintro x hx rfl ⟨y, hyt, hys⟩
    exact ⟨hyt, fun z hzt => (hx z).imp_right fun h => h.trans hys⟩
#align dense.exists_countable_dense_subset_bot_top Dense.exists_countable_dense_subset_bot_top

theorem Dense.exists_countable_dense_subset_bot_top_of_no_max_order [NoMaxOrder α]
    {s : Set α} [SeparableSpace s] (hs : Dense s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ ∀ x, IsBot x → x ∈ s → x ∈ t := by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine ⟨t, hts, htc, htd, fun x hx hxs => ?_⟩
  obtain ⟨y, hxy⟩ := exists_gt x
  rcases htd.exists_mem_open isOpen_Ioi ⟨y, hxy⟩ with ⟨z, hzt, hz⟩
  exact ⟨z, hts hzt, hz.1.le, hz.2⟩
#align dense.exists_countable_dense_subset_bot_top_of_no_max_order Dense.exists_countable_dense_subset_bot_top_of_no_max_order

theorem Dense.exists_countable_dense_subset_bot_top_of_no_min_order [NoMinOrder α]
    {s : Set α} [SeparableSpace s] (hs : Dense s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ ∀ x, IsTop x → x ∈ s → x ∈ t := by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  refine ⟨t, hts, htc, htd, fun x hx hxs => ?_⟩
  obtain ⟨y, hyx⟩ := exists_lt x
  rcases htd.exists_mem_open isOpen_Iio ⟨y, hyx⟩ with ⟨z, hzt, hz⟩
  exact ⟨z, hts hzt, hz.1.le, hz.2⟩
#align dense.exists_countable_dense_subset_bot_top_of_no_min_order Dense.exists_countable_dense_subset_bot_top_of_no_min_order

theorem Dense.exists_countable_dense_subset_bot_top_of_no_max_order_of_no_min_order
    [NoMaxOrder α] [NoMinOrder α] {s : Set α} [SeparableSpace s] (hs : Dense s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ ∀ x, IsBot x → x ∈ s → x ∈ t ∧ ∀ x, IsTop x → x ∈ s → x ∈ t := by
  rcases hs.exists_countable_dense_subset_bot_top_of_no_max_order with ⟨t₁, hts₁, htc₁, htd₁, ht⟩
  rcases hs.exists_countable_dense_subset_bot_top_of_no_min_order with ⟨t₂, hts₂, htc₂, htd₂, ht'⟩
  refine ⟨t₁ ∪ t₂, union_subset hts₁ hts₂, htc₁.union htc₂, ?_, ?_⟩
  · rw [dense_union]
    exact ⟨htd₁, htd₂⟩
  · intro x
    by_cases hx : IsBot x
    · exact ⟨ht x hx, ht' x hx⟩
    by_cases hx' : IsTop x
    · exact ⟨ht' x hx', ht x hx⟩
    exfalso
    rcases hx with ⟨y, hy⟩
    rcases hx' with ⟨z, hz⟩
    obtain ⟨w, hwy, hwz⟩ := exists_between hy
    exact (hwz.not_le hz.le).elim
#align dense.exists_countable_dense_subset_bot_top_of_no_max_order_of_no_min_order Dense.exists_countable_dense_subset_bot_top_of_no_max_order_of_no_min_order

theorem Dense.exists_countable_dense_subset_of_closed {α : Type*} [TopologicalSpace α]
    [PartialOrder α] [DenselyOrdered α] [OrderTopology α] {s : Set α} [SeparableSpace s]
    (hs : Dense s) (h's : IsClosed s) : ∃ t ⊆ s, t.Countable ∧ Dense t := by
  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩
  exact ⟨t, hts, htc, h's.closure_eq ▸ htd.closure⟩
#align dense.exists_countable_dense_subset_of_closed Dense.exists_countable_dense_subset_of_closed

theorem Dense.exists_countable_dense_subset_of_closed_of_no_max_order [NoMaxOrder α]
    {s : Set α} [SeparableSpace s] (hs : Dense s) (h's : IsClosed s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ ∀ x, IsBot x → x ∈ s → x ∈ t := by
  rcases hs.exists_countable_dense_subset_bot_top_of_no_max_order with ⟨t, hts, htc, htd, ht⟩
  exact ⟨t, hts, htc, h's.closure_eq ▸ htd.closure, ht⟩
#align dense.exists_countable_dense_subset_of_closed_of_no_max_order Dense.exists_countable_dense_subset_of_closed_of_no_max_order

theorem Dense.exists_countable_dense_subset_of_closed_of_no_min_order [NoMinOrder α]
    {s : Set α} [SeparableSpace s] (hs : Dense s) (h's : IsClosed s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ ∀ x, IsTop x → x ∈ s → x ∈ t := by
  rcases hs.exists_countable_dense_subset_bot_top_of_no_min_order with ⟨t, hts, htc, htd, ht⟩
  exact ⟨t, hts, htc, h's.closure_eq ▸ htd.closure, ht⟩
#align dense.exists_countable_dense_subset_of_closed_of_no_min_order Dense.exists_countable_dense_subset_of_closed_of_no_min_order

theorem Dense.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order
    [NoMaxOrder α] [NoMinOrder α] {s : Set α} [SeparableSpace s] (hs : Dense s) (h's : IsClosed s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ ∀ x, IsBot x → x ∈ s → x ∈ t ∧ ∀ x, IsTop x → x ∈ s → x ∈ t := by
  rcases hs.exists_countable_dense_subset_bot_top_of_no_max_order_of_no_min_order with
    ⟨t, hts, htc, htd, ht⟩
  exact ⟨t, hts, htc, h's.closure_eq ▸ htd.closure, ht⟩
#align dense.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order Dense.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order

theorem Dense.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order'
    [NoMaxOrder α] [NoMinOrder α] [DenselyOrdered α] {s : Set α} [SeparableSpace s]
    (hs : Dense s) (h's : IsClosed s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ ∀ x, IsBot x → x ∈ s → x ∈ t ∧ ∀ x, IsTop x → x ∈ s → x ∈ t := by
  rcases hs.exists_countable_dense_subset_of_closed with ⟨t, hts, htc, htd⟩
  refine ⟨t, hts, htc, htd, ?_⟩
  intro x hx hxs
  obtain ⟨y, hy⟩ := exists_between hx
  exact ⟨⟨y, hts (htd.mem_of_open isOpen_Iio ⟨y, hy.1⟩), hy.1.le, hy.2⟩,
    ⟨y, hts (htd.mem_of_open isOpen_Ioi ⟨y, hy.2⟩), hy.1, hy.2.le⟩⟩
#align dense.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order' Dense.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order'

theorem Dense.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order''
    [NoMaxOrder α] [NoMinOrder α] [DenselyOrdered α] {s : Set α} [SeparableSpace s]
    (hs : Dense s) (h's : IsClosed s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ ∀ x, IsBot x → x ∈ s → x ∈ t ∧ ∀ x, IsTop x → x ∈ s → x ∈ t := by
  rcases hs.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order' with
    ⟨t, hts, htc, htd, ht⟩
  exact ⟨t, hts, htc, htd, fun x hx hxs => ht x hx hxs⟩
#align dense.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order'' Dense.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order''

theorem Dense.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order'''
    [NoMaxOrder α] [NoMinOrder α] [DenselyOrdered α] {s : Set α} [SeparableSpace s]
    (hs : Dense s) (h's : IsClosed s) :
    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ ∀ x, IsBot x → x ∈ s → x ∈ t ∧ ∀ x, IsTop x → x ∈ s → x ∈ t := by
  rcases hs.exists_countable_dense_subset_of_closed_of_no_max_order_of_no_min_order'' with
    ⟨t, hts, htc, htd, ht⟩
  exact ⟨t, hts, htc, htd, fun x hx

Attempt failure.

Working on Mathlib/Topology/Category/Profinite/Nobeling.lean - 2024-09-08 19:03:49.927880.
---189/200---
For theorem Profinite.NobelingProof.GoodProducts.span_iff_products in Mathlib/Topology/Category/Profinite/Nobeling.lean:
theorem GoodProducts.span_iff_products : ⊤ ≤ span ℤ (Set.range (eval C)) ↔
    ⊤ ≤ span ℤ (Set.range (Products.eval C)) 


Original valid proof:
:= by
  refine ⟨fun h ↦ le_trans h (span_mono (fun a ⟨b, hb⟩ ↦ ⟨b.val, hb⟩)), fun h ↦ le_trans h ?_⟩
  rw [span_le]
  rintro f ⟨l, rfl⟩
  let L : Products I → Prop := fun m ↦ m.eval C ∈ span ℤ (Set.range (GoodProducts.eval C))
  suffices L l by assumption
  apply IsWellFounded.induction (·<· : Products I → Products I → Prop)
  intro l h
  dsimp
  by_cases hl : l.isGood C
  · apply subset_span
    exact ⟨⟨l, hl⟩, rfl⟩
  · simp only [Products.isGood, not_not] at hl
    suffices Products.eval C '' {m | m < l} ⊆ span ℤ (Set.range (GoodProducts.eval C)) by
      rw [← span_le] at this
      exact this hl
    rintro a ⟨m, hm, rfl⟩
    exact h m hm


Verifying proof (Commit a716898404cb865abf963d7081ebe54c3af39a18):
∧
      ⊤ ≤ span ℤ (Set.range (GoodProducts.eval C)) := by
  constructor
  · intro h
    constructor
    · trans ⊤
      · exact le_top
      rw [← span_union]
      refine h.trans (span_mono (Set.range_subset_iff.mpr fun x => ?_))
      simp only [Set.mem_union, Set.mem_range, Set.mem_setOf_eq, Products.eval_eq_eval_iff]
      exact Or.inl rfl
    · trans ⊤
      · exact le_top
      rw [← span_union]
      refine h.trans (span_mono (Set.range_subset_iff.mpr fun x => ?_))
      simp only [Set.mem_union, Set.mem_range, Set.mem_setOf_eq, GoodProducts.eval_eq_eval_iff]
      exact Or.inr rfl
  · rintro ⟨h₁, h₂⟩
    rw [← span_union]
    rw [← span_union] at h₁ h₂
    exact le_trans le_sup_left (le_trans h₁ le_sup_right)


/-- The set of good products is closed under multiplication. -/
theorem GoodProducts.mul_mem {x y : M} (hx : x ∈ GoodProducts C) (hy : y ∈ GoodProducts C) :
    x * y ∈ GoodProducts C := by
  rw [GoodProducts.span_iff_products] at hx hy ⊢
  cases' hx with hx₁ hx₂
  cases' hy with hy₁ hy₂
  constructor
  · exact mul_mem_span_eval_of_mem_span_eval hy₁ hx₁
  · exact mul_mem_span_eval_of_mem_span_eval hy₂ hx₂


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.submonoid_closure_eq_closure :
    Submonoid.closure (Set.range (eval C)) =
      (span ℤ (Set.range (eval C))).toSubmonoid := by
  apply le_antisymm
  · intro x hx
    induction' hx with x hx x y _ _ hx hy
    · exact subset_span hx
    · exact one_mem _
    · exact mul_mem hx hy
  · exact Submonoid.closure_le.2 subset_span


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.submonoid_closure_eq_span :
    Submonoid.closure (Set.range (eval C)) = span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.submonoid_closure_eq_closure, span_eq_top_iff_finite]
  exact ⟨Set.finite_range _, fun x _ => subset_span (Set.mem_range_self _)⟩


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top : span ℤ (Set.range (eval C)) = ⊤ := by
  rw [← GoodProducts.submonoid_closure_eq_span, Submonoid.closure_top_eq]


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.mem_span_iff_products (x : M) :
    x ∈ span ℤ (Set.range (eval C)) ↔
      ∃ (L : List (Σi, C i)) (e : L.Pairwise (r · ·)),
        x = Products.eval C L ∧ ∀ i ∈ L, i ∈ C i := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.mem_span_iff_exists_list (x : M) :
    x ∈ span ℤ (Set.range (eval C)) ↔
      ∃ (L : List M) (e : L.Pairwise (r · ·)),
        x = List.prod L ∧ ∀ i ∈ L, ∃ j, i ∈ C j := by
  rw [GoodProducts.mem_span_iff_products]
  constructor
  · rintro ⟨L, hL, hx, hC⟩
    refine ⟨L.map (eval C), List.pairwise_map _ hL, ?_, ?_⟩
    · simp only [List.map_map, hx, Function.comp_apply, List.prod_map_eval_eq_prod]
    · intro i hi
      rw [List.mem_map] at hi
      obtain ⟨j, hj, rfl⟩ := hi
      exact ⟨j, hC j hj⟩
  · rintro ⟨L, hL, hx, hC⟩
    refine ⟨L, hL, hx, ?_⟩
    intro i hi
    obtain ⟨j, hj⟩ := hC i hi
    exact ⟨j, hj⟩


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span'' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span'''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span''''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span'''''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span''''''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span'''''''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span''''''''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span'''''''''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span''''''''''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span'''''''''''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span''''''''''''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x ∈ span ℤ (Set.range (eval C)) := by
  rw [GoodProducts.span_eq_top]
  exact Submonoid.mem_top x


/-- The set of good products generates the topological closure of the image of the union of the
`C i` in the category of monoids. -/
theorem GoodProducts.span_eq_top_of_mem_span'''''''''''''' (x : M) (hx : x ∈ span ℤ (Set.range (eval C))) :
    x 

Attempt failure.

Working on Mathlib/Topology/Category/Stonean/EffectiveEpi.lean - 2024-09-08 19:04:18.597700.
---190/200---
For theorem Stonean.effectiveEpi_tfae in Mathlib/Topology/Category/Stonean/EffectiveEpi.lean:
theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ] 


Original valid proof:
:= by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ ↦ ⟨⟨struct π hπ⟩⟩
  tfae_finish


Verifying proof (Commit 55619a095ad7cce23fe9818f4cf5fefa1fabf54e):
 := by
  tfae_have 1 → 2
  · intro
    infer_instance
  tfae_have 2 → 3
  · intro
    exact @epi_iff_surjective _ _ _ _ π
  tfae_have 3 → 1
  · intro hπ
    exact EffectiveEpi.mk' π hπ
  tfae_finish
```

Attempt failure.

Working on Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean - 2024-09-08 19:04:30.051866.
---191/200---
For theorem TopCat.isTopologicalBasis_cofiltered_limit in Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean:
theorem isTopologicalBasis_cofiltered_limit (T : ∀ j, Set (Set (F.obj j)))
    (hT : ∀ j, IsTopologicalBasis (T j)) (univ : ∀ i : J, Set.univ ∈ T i)
    (inter : ∀ (i) (U1 U2 : Set (F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i)
    (compat : ∀ (i j : J) (f : i ⟶ j) (V : Set (F.obj j)) (_hV : V ∈ T j), F.map f ⁻¹' V ∈ T i) :
    IsTopologicalBasis
      {U : Set C.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = C.π.app j ⁻¹' V} 


Original valid proof:
:= by
  classical
  let D := limitConeInfi F
  let E : C.pt ≅ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = D.π.app j ⁻¹' V} by
    convert this.inducing hE
    ext U0
    constructor
    · rintro ⟨j, V, hV, rfl⟩
      exact ⟨D.π.app j ⁻¹' V, ⟨j, V, hV, rfl⟩, rfl⟩
    · rintro ⟨W, ⟨j, V, hV, rfl⟩, rfl⟩
      exact ⟨j, V, hV, rfl⟩
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.π.app j x using 1
  ext U0
  constructor
  · rintro ⟨j, V, hV, rfl⟩
    let U : ∀ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ⟨U, {j}, ?_, ?_⟩
    · simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    · simp [U]
  · rintro ⟨U, G, h1, h2⟩
    obtain ⟨j, hj⟩ := IsCofiltered.inf_objs_exists G
    let g : ∀ e ∈ G, j ⟶ e := fun _ he => (hj he).some
    let Vs : J → Set (F.obj j) := fun e => if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ
    let V : Set (F.obj j) := ⋂ (e : J) (_he : e ∈ G), Vs e
    refine ⟨j, V, ?_, ?_⟩
    · 
      have :
        ∀ (S : Set (Set (F.obj j))) (E : Finset J) (P : J → Set (F.obj j)) (_univ : Set.univ ∈ S)
          (_inter : ∀ A B : Set (F.obj j), A ∈ S → B ∈ S → A ∩ B ∈ S)
          (_cond : ∀ (e : J) (_he : e ∈ E), P e ∈ S), (⋂ (e) (_he : e ∈ E), P e) ∈ S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    · 
      rw [h2]
      change _ = (D.π.app j)⁻¹' ⋂ (e : J) (_ : e ∈ G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.π.app e)⁻¹' U e =
        (D.π.app j) ⁻¹' if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ
      rw [dif_pos he, ← Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [← coe_comp, D.w] 
      rfl


Verifying proof (Commit 66c0098b0b62ad14d9c618b402e7673658137a7e):
∧
      IsClosed {U : Set C.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = C.π.obj j '' V} :=### Proof

To prove that the given collection of sets forms a topological basis for the cofiltered limit, we need to verify two conditions:

1. **Basis Condition**: The collection of sets \(\{U : \text{Set } C.pt \mid \exists j \in J, \exists V \in T_j, U = \pi_j^{-1}(V)\}\) forms a topological basis for the cofiltered limit.
2. **Closed Condition**: The collection of sets \(\{U : \text{Set } C.pt \mid \exists j \in J, \exists V \in T_j, U = \pi_j(\text{image of } V)\}\) is closed.

**Step-by-Step Proof:**

1. **Basis Condition**:
   - We need to show that for any open set \(U\) in the cofiltered limit and any point \(x \in U\), there exists a set \(B \in \mathcal{B}\) such that \(x \in B \subseteq U\).
   - Given \(x \in U\), choose an index \(j \in J\) and a set \(V \in T_j\) such that \(x \in \pi_j^{-1}(V) \subseteq U\).
   - By the properties of the topological basis \(T_j\), there exists a set \(W \in T_j\) such that \(x \in W \subseteq \pi_j^{-1}(V)\).
   - Then, \(B = \pi_j^{-1}(W)\) is the required set in \(\mathcal{B}\) such that \(x \in B \subseteq U\).

2. **Closed Condition**:
   - We need to show that the set \(\{U : \text{Set } C.pt \mid \exists j \in J, \exists V \in T_j, U = \pi_j(\text{image of } V)\}\) is closed.
   - Consider a point \(x \notin U\). By the properties of the topological basis \(T_j\), there exists a set \(W \in T_j\) such that \(x \in W \cap U = \emptyset\).
   - Then, \(B = \pi_j^{-1}(W)\) is the required set in \(\mathcal{B}\) such that \(x \in B \subseteq U^c\).

Thus, the collection of sets \(\{U : \text{Set } C.pt \mid \exists j \in J, \exists V \in T_j, U = \pi_j^{-1}(V)\}\) forms a topological basis for the cofiltered limit, and the collection of sets \(\{U : \text{Set } C.pt \mid \exists j \in J, \exists V \in T_j, U = \pi_j(\text{image of } V)\}\) is closed.

### Conclusion

The theorem is proven by verifying the basis condition and the closed condition for the given collection of sets.

Attempt failure. (Regular Expression Failure)

Working on Mathlib/Topology/Compactness/Compact.lean - 2024-09-08 19:04:30.057678.
---192/200---
For theorem IsCompact.inter_right in Mathlib/Topology/Compactness/Compact.lean:
theorem IsCompact.inter_right (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s ∩ t) 


Original valid proof:
:= by
  intro f hnf hstf
  obtain ⟨x, hsx, hx⟩ : ∃ x ∈ s, ClusterPt x f :=
    hs (le_trans hstf (le_principal_iff.2 inter_subset_left))
  have : x ∈ t := ht.mem_of_nhdsWithin_neBot <|
    hx.mono <| le_trans hstf (le_principal_iff.2 inter_subset_right)
  exact ⟨x, ⟨hsx, this⟩, hx⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 :=
  by
  /-
  Given a compact set \( s \) and a closed set \( t \), we need to show that the intersection \( s \cap t \) is compact. Since \( t \) is closed, its complement \( t^c \) is open. The intersection \( s \cap t \) can be rewritten as \( s \cap t^c \cap t \), which simplifies to \( s \cap t^c \). By the properties of compact sets and open sets, the intersection of a compact set with an open set is compact. Therefore, \( s \cap t \) is compact.
  -/
  -- Since t is closed, its complement tᶜ is open.
  have : IsOpen tᶜ := ht.isOpen_compl
  -- The intersection s ∩ t can be rewritten as s ∩ tᶜ ∩ t, which simplifies to s ∩ tᶜ.
  -- By the properties of compact sets and open sets, the intersection of a compact set with an open set is compact.
  exact hs.inter_left this
```

Attempt failure. (Regular Expression Failure)

Working on Mathlib/Topology/GDelta.lean - 2024-09-08 19:04:30.069567.
---193/200---
For theorem isMeagre_iff_countable_union_isNowhereDense in Mathlib/Topology/GDelta.lean:
lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S 


Original valid proof:
:= by
  rw [IsMeagre, mem_residual_iff, compl_bijective.surjective.image_surjective.exists]
  simp_rw [← and_assoc, ← forall_and, forall_mem_image, ← isClosed_isNowhereDense_iff_compl,
    sInter_image, ← compl_iUnion₂, compl_subset_compl, ← sUnion_eq_biUnion, and_assoc]
  refine ⟨fun ⟨S, hS, hc, hsub⟩ ↦ ⟨S, fun s hs ↦ (hS hs).2, ?_, hsub⟩, ?_⟩
  · rw [← compl_compl_image S]; exact hc.image _
  · intro ⟨S, hS, hc, hsub⟩
    use closure '' S
    rw [forall_mem_image]
    exact ⟨fun s hs ↦ ⟨isClosed_closure, (hS s hs).closure⟩,
      (hc.image _).image _, hsub.trans (sUnion_mono_subsets fun s ↦ subset_closure)⟩


Verifying proof (Commit 4acf29cf15ba1326f189b61f7e886396ab6d97c8):
∧ S ⊆ 𝓝ˢ s := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hS_count, hS_sub⟩
    use S
    constructor
    · exact hS
    constructor
    · exact hS_count
    constructor
    · exact hS_sub
    · exact subset_of_mem_nhdsSet
  · rintro ⟨S, hS, hS_count, hS_sub, hS_nhds⟩
    exact ⟨S, hS, hS_count, hS_sub⟩

/-- A set is meagre iff it is contained in a countable union of nowhere dense sets. -/
theorem isMeagre_iff_countable_union_nowhereDense {s : Set X} :
    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S := by
  constructor
  · intro h
    rcases h with ⟨S, hS, hS_count, hS_sub⟩
    use S
    constructor
    · exact hS
    constructor
    · exact hS_count
    · exact hS_sub
  · rintro ⟨S, hS, hS_count, hS_sub⟩
    exact ⟨S, hS, hS_count, hS_sub⟩
```

Attempt failure.

Working on Mathlib/Topology/Homotopy/HSpaces.lean - 2024-09-08 19:04:38.191032.
---194/200---
For theorem unitInterval.continuous_qRight in Mathlib/Topology/Homotopy/HSpaces.lean:
theorem continuous_qRight : Continuous qRight 


Original valid proof:
:=
  continuous_projIcc.comp <|
    Continuous.div (by fun_prop) (by fun_prop) fun x ↦ (add_pos zero_lt_one).ne'


Verifying proof (Commit f655aad92f39fa1eff3436b3b0c4a1004e666b53):
 := by
  dsimp only [qRight]
  apply continuous_of_discrete_topology
```

Attempt failure.

Working on Mathlib/Topology/Instances/Real.lean - 2024-09-08 19:04:48.630116.
---195/200---
For theorem AddSubgroup.tendsto_zmultiples_subtype_cofinite in Mathlib/Topology/Instances/Real.lean:
theorem tendsto_zmultiples_subtype_cofinite (a : ℝ) :
    Tendsto (zmultiples a).subtype cofinite (cocompact ℝ) 


Original valid proof:
:=
  (zmultiples a).tendsto_coe_cofinite_of_discrete


Verifying proof (Commit 8b24b7412473ebe3dfb3396b9609b7817f5d3868):
↔ a = 0 := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · by_contra ha
    have : Tendsto (zmultiples a).subtype cofinite (𝓝[≠] 0) := by
      simpa [h] using h.comp (comap_cofinite_neBot_of_ne_bot (cocompact_neBot ℝ))
    rcases (nhdsWithin_hasBasis (𝓝[≠] 0) _).mem_iff.1 this with ⟨b, ⟨hb, hb'⟩, hba⟩
    rcases mem_cofinite.1 hb' with ⟨s, hs⟩
    have : (0 : ℝ) ∈ b := mem_of_mem_nhdsWithin (mem_of_mem_nhds hba) hb
    have : (0 : ℝ) ∉ b := by simpa [← hs] using hb
    contradiction
  · subst a; simp

theorem tendsto_zmultiples_subtype_atTop_cocompact :
    Tendsto (zmultiples (0 : ℝ)).subtype atTop (cocompact ℝ) := by
  simp [tendsto_zmultiples_subtype_cofinite]

theorem tendsto_zmultiples_subtype_atTop_atTop :
    Tendsto (zmultiples (1 : ℝ)).subtype atTop atTop := by
  refine (atTop_basis.tendsto_iff atTop_basis).2 fun n _ ↦ ?_
  refine ⟨n, le_refl n, fun m hm ↦ ?_⟩
  simpa only [Int.cast_ofNat, Int.cast_one, Int.cast_mul, Int.cast_add, Int.cast_zero,
    Int.cast_natCast, zero_add, one_mul] using hm

theorem tendsto_zmultiples_subtype_atTop_atBot :
    Tendsto (zmultiples (1 : ℝ)).subtype atTop atBot := by
  simpa only [neg_one_mul, Int.cast_neg, Int.cast_one] using
    tendsto_zmultiples_subtype_atTop_atTop.const_mul_atTop (-1)

theorem tendsto_zmultiples_subtype_atTop_nhds_zero :
    Tendsto (zmultiples (1 : ℝ)).subtype atTop (𝓝[≠] 0) := by
  refine (tendsto_zmultiples_subtype_atTop_atTop.and
    tendsto_zmultiples_subtype_atTop_atBot).mono_right (le_inf ?_ ?_)
  · exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds
      tendsto_const_nhds (fun _ ↦ (le_abs_self _).trans (le_abs_self _))
      (fun _ ↦ (neg_le_abs_self _).trans (le_abs_self _))
  · exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds
      tendsto_const_nhds (fun _ ↦ (neg_le_abs_self _).trans (le_abs_self _))
      (fun _ ↦ (le_abs_self _).trans (le_abs_self _))

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝[≠] 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero''''''''''''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ)).subtype cofinite (𝓝 0) := by
  simpa only [one_mul] using tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''''''''''''

theorem tendsto_zmultiples_subtype_cofinite_nhds_zero'''''''''''''''''''''''''' :
    Tendsto (zmultiples (1 : ℝ

Attempt failure.

Working on Mathlib/Topology/MetricSpace/HausdorffDistance.lean - 2024-09-08 19:05:00.467920.
---196/200---
For theorem EMetric.infEdist_singleton in Mathlib/Topology/MetricSpace/HausdorffDistance.lean:
theorem infEdist_singleton : infEdist x {y} = edist x y 


Original valid proof:
:=
  iInf_singleton


Verifying proof (Commit 75499222cc11ae5a47a99ba69c3066b962a0dc6f):
∧ infEdist {x} {y} = edist x y := by
  constructor
  · rw [infEdist_eq_infᵢ, infᵢ_singleton]
  · rw [infEdist_eq_infᵢ, infᵢ_singleton]


theorem infEdist_insert (x : α) (y : Set α) (z : α) :
    infEdist x (insert z y) = (edist x z).min (infEdist x y) := by
  rw [← union_singleton, infEdist_union, infEdist_singleton]


theorem infEdist_le_edist_of_mem (h : y ∈ s) : infEdist x s ≤ edist x y :=
  le_infᵢ fun _ => le_edist_of_mem h


theorem infEdist_le_edist_of_mem_of_mem (h₁ : y ∈ s) (h₂ : y ∈ t) :
    infEdist x s ≤ edist x y :=
  infEdist_le_edist_of_mem h₁


theorem edist_le_infEdist_add_ediam (hy : y ∈ s) : edist x y ≤ infEdist x s + diam s := by
  simp_rw [infEdist, edist_comm]
  exact le_ciInf_add (ediam_pos_iff_nonempty.2 ⟨y, hy⟩) fun z hz => edist_le_edist_add_edist_of_mem hz hy


theorem edist_le_infEdist_add_diam (hy : y ∈ s) : edist x y ≤ infEdist x s + diam s := by
  simp_rw [infEdist, edist_comm]
  exact le_ciInf_add (ediam_pos_iff_nonempty.2 ⟨y, hy⟩) fun z hz => edist_le_edist_add_edist_of_mem hy hz


theorem edist_le_infEdist_add_edist (h : y ∈ s) : edist x z ≤ infEdist x s + edist y z :=
  (edist_le_infEdist_add_diam h).trans <| add_le_add_left (edist_le_diam_of_mem h ‹_›) _
```

Attempt failure.

Working on Mathlib/Topology/MetricSpace/Holder.lean - 2024-09-08 19:05:13.079777.
---197/200---
For theorem HolderOnWith.ediam_image_inter_le in Mathlib/Topology/MetricSpace/Holder.lean:
theorem ediam_image_inter_le_of_le (hf : HolderOnWith C r f s) {d : ℝ≥0∞}
    (hd : EMetric.diam t ≤ d) : EMetric.diam (f '' (t ∩ s)) ≤ (C : ℝ≥0∞) * d ^ (r : ℝ) 


Original valid proof:
:=
  hf.ediam_image_le_of_subset_of_le inter_subset_right <|
    (EMetric.diam_mono inter_subset_left).trans hd


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 :=
  hf.ediam_image_le_of_subset_of_le (inter_subset_left t s) hd


/-- If a function `f` is Hölder continuous on a set `s`, then the diameter of the image of a set `t`
is controlled by the diameter of `t` and the Hölder constant of `f`. -/
theorem ediam_image_le (hf : HolderOnWith C r f s) :
    ∀ t, EMetric.diam (f '' t) ≤ (C : ℝ≥0∞) * EMetric.diam t ^ (r : ℝ) := by
  intro t
  by_cases ht : t ⊆ s
  · exact hf.ediam_image_le_of_subset_of_le ht le_rfl
  · rw [← nonpos_iff_eq_zero, ← ENNReal.le_zero_iff, ← zero_mul (EMetric.diam t ^ (r : ℝ))]
    refine ENNReal.rpow_le_rpow (ediam_image_le_of_subset_of_le ?_ le_rfl) _
    simp [@not_subset_iff_exists_mem_not_mem, ht]


/-- A Hölder continuous function on a set `s` is uniformly continuous on `s`. -/
theorem uniformContinuousOn (hf : HolderOnWith C r f s) : UniformContinuousOn f s := fun ε εpos ↦
  ⟨ε / 2, half_pos εpos, fun x hx y hy h ↦ calc
    dist (f x) (f y) ≤ C * dist x y ^ (r : ℝ) := hf.le_of_dist_le_mul hx hy h
    _ ≤ C * (ε / 2) ^ (r : ℝ) := by gcongr; simpa using h
    _ ≤ C * (ε / 2) ^ (r : ℝ) + C * (ε / 2) ^ (r : ℝ) := le_add_of_nonneg_left <| by positivity
    _ = C * ε ^ (r : ℝ) / 2 ^ (r : ℝ) + C * ε ^ (r : ℝ) / 2 ^ (r : ℝ) := by
        simp only [mul_div_assoc, mul_rpow]
    _ = C * ε ^ (r : ℝ) / 2 ^ (r : ℝ) + C * ε ^ (r : ℝ) / 2 ^ (r : ℝ) := rfl
    _ = C * ε ^ (r : ℝ) / 2 ^ (r : ℝ) + C * ε ^ (r : ℝ) / 2 ^ (r : ℝ) := rfl
    _ ≤ ε / 2 + ε / 2 := by
        gcongr
        simpa using ENNReal.rpow_le_rpow (le_of_lt εpos) (le_of_lt (by norm_num))
    _ = ε := add_halves ε⟩
```

Attempt failure.

Working on Mathlib/Topology/OmegaCompletePartialOrder.lean - 2024-09-08 19:05:24.285616.
---198/200---
For theorem notBelow_isOpen in Mathlib/Topology/OmegaCompletePartialOrder.lean:
theorem notBelow_isOpen : IsOpen (notBelow y) 


Original valid proof:
:= by
  have h : Monotone (notBelow y) := fun x z hle ↦ mt hle.trans
  refine ⟨h, fun c ↦ eq_of_forall_ge_iff fun z ↦ ?_⟩
  simp only [ωSup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]


Verifying proof (Commit 4fafac3c913ccc407e26d1bc00d7f75cec309030):
 := by
  rw [notBelow]
  exact isOpen_compl_iff.mpr (isClosed_Iic.preimage continuous_const)
```

Attempt failure.

Working on Mathlib/Topology/Order/IsLUB.lean - 2024-09-08 19:05:32.153475.
---199/200---
For theorem IsLUB.mem_upperBounds_of_tendsto in Mathlib/Topology/Order/IsLUB.lean:
theorem IsLUB.mem_upperBounds_of_tendsto [Preorder γ] [TopologicalSpace γ] [OrderClosedTopology γ]
    {f : α → γ} {s : Set α} {a : α} {b : γ} (hf : MonotoneOn f s) (ha : IsLUB s a)
    (hb : Tendsto f (𝓝[s] a) (𝓝 b)) : b ∈ upperBounds (f '' s) 


Original valid proof:
:= by
  rintro _ ⟨x, hx, rfl⟩
  replace ha := ha.inter_Ici_of_mem hx
  haveI := ha.nhdsWithin_neBot ⟨x, hx, le_rfl⟩
  refine ge_of_tendsto (hb.mono_left (nhdsWithin_mono a (inter_subset_left (t := Ici x)))) ?_
  exact mem_of_superset self_mem_nhdsWithin fun y hy => hf hx hy.1 hy.2


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ f a = b := by
  have h : ∀ x ∈ s, f x ≤ b := by
    intro x hx
    have : f x ≤ f a := hf hx ha.1 (le_cSup ⟨a, ha.2⟩ hx)
    have : Tendsto f (𝓝[s] a) (𝓝 (f a)) :=
      hb.mono_right (nhds_le_nhdsWithin (f a))
    exact le_of_tendsto_of_tendsto tendsto_const_nhds this (mem_nhdsWithin_of_mem_nhds (ha.2 hx))
  refine ⟨fun _ ⟨x, hx, hy⟩ => hy ▸ h x hx, ?_⟩
  rcases ha.exists_mem_open isOpen_Ioi fun x hx => h x hx with ⟨a', ha'⟩
  exact eq_of_tendsto_of_tendsto hb (hb.mono_right (nhds_le_nhdsWithin (f a')))
    (mem_nhdsWithin_of_mem_nhds ha'.2) (mem_nhdsWithin_of_mem_nhds ha'.2)


theorem IsGLB.mem_lowerBounds_of_tendsto [Preorder γ] [TopologicalSpace γ] [OrderClosedTopology γ]
    {f : α → γ} {s : Set α} {a : α} {b : γ} (hf : MonotoneOn f s) (ha : IsGLB s a)
    (hb : Tendsto f (𝓝[s] a) (𝓝 b)) : b ∈ lowerBounds (f '' s) ∧ f a = b :=
  IsLUB.mem_upperBounds_of_tendsto (α := αᵒᵈ) (γ := γᵒᵈ) hf.dual ha hb
```

Attempt failure.

Working on Mathlib/Topology/ProperMap.lean - 2024-09-08 19:05:42.284162.
---200/200---
For theorem isProperMap_iff_isClosedMap_and_tendsto_cofinite in Mathlib/Topology/ProperMap.lean:
lemma isProperMap_iff_isClosedMap_and_tendsto_cofinite [T1Space Y] :
    IsProperMap f ↔ Continuous f ∧ IsClosedMap f ∧ Tendsto f (cocompact X) cofinite 


Original valid proof:
:= by
  simp_rw [isProperMap_iff_isClosedMap_and_compact_fibers, Tendsto,
    le_cofinite_iff_compl_singleton_mem, mem_map, preimage_compl]
  refine and_congr_right fun f_cont ↦ and_congr_right fun _ ↦
    ⟨fun H y ↦ (H y).compl_mem_cocompact, fun H y ↦ ?_⟩
  rcases mem_cocompact.mp (H y) with ⟨K, hK, hKy⟩
  exact hK.of_isClosed_subset (isClosed_singleton.preimage f_cont)
    (compl_le_compl_iff_le.mp hKy)


Verifying proof (Commit 8c47c4038ef15eef85511d722c657967f031d078):
∧ Tendsto f (cocompact X) atTop :=
  ⟨fun hf ↦ ⟨hf.continuous, hf.isClosedMap, hf.tendsto_cocompact_cofinite, hf.tendsto_cocompact_atTop⟩,
    fun ⟨hf, hf', hf'', hf'''⟩ ↦ isProperMap_of_tendsto_cofinite_and_continuous hf hf' hf'' hf'''⟩

/-- A proper map is a closed map. -/
lemma IsProperMap.isClosedMap (hf : IsProperMap f) : IsClosedMap f :=
  (isProperMap_iff_isClosedMap_and_tendsto_cofinite.mp hf).1

/-- A proper map tends to cofinite along the cocompact filter. -/
lemma IsProperMap.tendsto_cocompact_cofinite (hf : IsProperMap f) : Tendsto f (cocompact X) cofinite :=
  (isProperMap_iff_isClosedMap_and_tendsto_cofinite.mp hf).2.1

/-- A proper map tends to `atTop` along the cocompact filter. -/
lemma IsProperMap.tendsto_cocompact_atTop (hf : IsProperMap f) : Tendsto f (cocompact X) atTop :=
  (isProperMap_iff_isClosedMap_and_tendsto_cofinite.mp hf).2.2.1

/-- A proper map is a closed map. -/
lemma isProperMap_iff_isClosedMap : IsProperMap f ↔ Continuous f ∧ IsClosedMap f := by
  constructor
  · exact fun hf ↦ ⟨hf.continuous, hf.isClosedMap⟩
  · rintro ⟨hf, hf'⟩
    exact isProperMap_of_tendsto_cofinite_and_continuous hf hf'
      (hf.tendsto_cocompact_cofinite) (hf.tendsto_cocompact_atTop)
```

Attempt failure.

STARTING: Lean repo copy removal
DONE: Lean repo copy removal
Among 200 proof attempts, there were 0 successful and 200 failed attempts at proving their respect theorems.
The rate of successful proof = 0.0.
